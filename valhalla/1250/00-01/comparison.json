{"files":[{"patch":"@@ -8,0 +8,1 @@\n+warning=issuestitle\n","filename":".jcheck\/conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,0 +193,11 @@\n+  # Setup default CDS alignment. On platforms where one build may run on machines with different\n+  # page sizes, the JVM choses a compatible alignment to fit all possible page sizes. This slightly\n+  # increases archive size.\n+  # The only platform having this problem at the moment is Linux on aarch64, which may encounter\n+  # three different page sizes: 4K, 64K, and if run on Mac m1 hardware, 16K.\n+  COMPATIBLE_CDS_ALIGNMENT_DEFAULT=false\n+  if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" && test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=true\n+  fi\n+  AC_SUBST(COMPATIBLE_CDS_ALIGNMENT_DEFAULT)\n+\n@@ -676,1 +687,1 @@\n-  UTIL_ARG_ENABLE(NAME: compatible-cds-alignment, DEFAULT: false,\n+  UTIL_ARG_ENABLE(NAME: compatible-cds-alignment, DEFAULT: $COMPATIBLE_CDS_ALIGNMENT_DEFAULT,\n","filename":"make\/autoconf\/jdk-options.m4","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    jdk.internal.le \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    static final String LIKELY_SCRIPT_PREFIX = \"likelyScript.\";\n@@ -117,0 +118,1 @@\n+    static boolean nonlikelyScript;\n@@ -120,0 +122,3 @@\n+    \/\/ \"likelyScript\" map\n+    private static final Map<String, SortedSet<String>> likelyScriptMap = new HashMap<>();\n+\n@@ -178,1 +183,1 @@\n-       \/\/ no instantiation\n+        \/\/ no instantiation\n@@ -478,2 +483,2 @@\n-                .filter(key -> key.startsWith(PARENT_LOCALE_PREFIX))\n-                .forEach(key -> {\n+            .filter(key -> key.startsWith(PARENT_LOCALE_PREFIX))\n+            .forEach(key -> {\n@@ -495,0 +500,10 @@\n+        handlerLikelySubtags.getData().forEach((from, to) -> {\n+            if (!from.contains(\"-\")) { \/\/ look for language-only tag\n+                var script = to.split(\"-\")[1];\n+                var key = LIKELY_SCRIPT_PREFIX + script;\n+                var prev = likelyScriptMap.putIfAbsent(key, new TreeSet<String>(Set.of(from)));\n+                if (prev != null) {\n+                    prev.add(from);\n+                }\n+            }\n+        });\n@@ -564,0 +579,1 @@\n+            metaInfo.putAll(likelyScriptMap);\n@@ -1138,1 +1154,1 @@\n-            Locale p = childToParentLocaleMap.get(l);\n+            Locale p = getParentLocale(l);\n@@ -1155,0 +1171,21 @@\n+    private static Locale getParentLocale(Locale child) {\n+        Locale parent = childToParentLocaleMap.get(child);\n+\n+        \/\/ check non-likely script for root\n+        if (nonlikelyScript && parent == null && child.getCountry().isEmpty()) {\n+            var lang = \" \" + child.getLanguage() + \" \";\n+            var script = child.getScript();\n+\n+            if (!script.isEmpty()) {\n+                parent = likelyScriptMap.entrySet().stream()\n+                    .filter(e -> e.getValue().contains(lang))\n+                    .findAny()\n+                    .map(Map.Entry::getKey)\n+                    .map(likely -> likely.equals(script) ? null : Locale.ROOT)\n+                    .orElse(null);\n+            }\n+        }\n+\n+        return parent;\n+    }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.stream.Collectors;\n@@ -309,7 +310,6 @@\n-                    private static final Map<String, String> resourceNameToLocales = HashMap.newHashMap(%d);\n-                %s\n-                    static {\n-                \"\"\", CLDRConverter.isBaseModule ? \"cldr\" : \"resources.cldr.provider\",\n-                className, metaInfo.keySet().stream().filter(k -> k.equals(\"AvailableLocales\")).count(),\n-                CLDRConverter.isBaseModule ?\n-                    \"\"\"\n+                \"\"\",\n+                    CLDRConverter.isBaseModule ? \"cldr\" : \"resources.cldr.provider\",\n+                    className);\n+\n+            if (CLDRConverter.isBaseModule) {\n+                out.printf(\"\"\"\n@@ -318,0 +318,3 @@\n+                        static final boolean nonlikelyScript = %s; \/\/ package access from CLDRLocaleProviderAdapter\n+\n+                        static {\n@@ -320,24 +323,11 @@\n-                        CLDRConverter.handlerSupplMeta.getLanguageAliasData().size()) :\n-                    \"\");\n-\n-            for (String key : metaInfo.keySet()) {\n-                if (key.startsWith(CLDRConverter.PARENT_LOCALE_PREFIX)) {\n-                    String parentTag = key.substring(CLDRConverter.PARENT_LOCALE_PREFIX.length());\n-                    if (\"root\".equals(parentTag)) {\n-                        out.printf(\"        parentLocalesMap.put(Locale.ROOT,\\n\");\n-                    } else {\n-                        out.printf(\"        parentLocalesMap.put(Locale.forLanguageTag(\\\"%s\\\"),\\n\",\n-                                   parentTag);\n-                    }\n-                    String[] children = toLocaleList(metaInfo.get(key), true).split(\" \");\n-                    Arrays.sort(children);\n-                    out.printf(\"            new String[] {\\n\" +\n-                               \"                \");\n-                    int count = 0;\n-                    for (int i = 0; i < children.length; i++) {\n-                        String child = children[i];\n-                        out.printf(\"\\\"%s\\\", \", child);\n-                        count += child.length() + 4;\n-                        if (i != children.length - 1 && count > 64) {\n-                            out.printf(\"\\n                \");\n-                            count = 0;\n+                        CLDRConverter.handlerSupplMeta.getLanguageAliasData().size(),\n+                        Boolean.valueOf(CLDRConverter.nonlikelyScript)));\n+\n+                for (String key : metaInfo.keySet()) {\n+                    if (key.startsWith(CLDRConverter.PARENT_LOCALE_PREFIX)) {\n+                        String parentTag = key.substring(CLDRConverter.PARENT_LOCALE_PREFIX.length());\n+                        if (\"root\".equals(parentTag)) {\n+                            out.printf(\"        parentLocalesMap.put(Locale.ROOT,\\n\");\n+                        } else {\n+                            out.printf(\"        parentLocalesMap.put(Locale.forLanguageTag(\\\"%s\\\"),\\n\",\n+                                    parentTag);\n@@ -345,6 +335,1 @@\n-                    }\n-                    out.printf(\"\\n            });\\n\");\n-                } else {\n-                    if (\"AvailableLocales\".equals(key)) {\n-                        out.printf(\"        resourceNameToLocales.put(\\\"%s\\\",\\n\", key);\n-                        out.printf(\"            \\\"%s\\\");\\n\", toLocaleList(applyLanguageAliases(metaInfo.get(key)), false));\n+                        generateStringArray(metaInfo.get(key), out);\n@@ -353,3 +338,3 @@\n-            }\n-            \/\/ for languageAliasMap\n-            if (CLDRConverter.isBaseModule) {\n+                out.println();\n+\n+                \/\/ for languageAliasMap\n@@ -359,1 +344,1 @@\n-            }\n+                out.printf(\"    }\\n\\n\");\n@@ -361,1 +346,1 @@\n-            out.printf(\"    }\\n\\n\");\n+                \/\/ end of static initializer block.\n@@ -363,4 +348,1 @@\n-            \/\/ end of static initializer block.\n-\n-            \/\/ Canonical TZ names for delayed initialization\n-            if (CLDRConverter.isBaseModule) {\n+                \/\/ Delayed initialization section\n@@ -368,2 +350,4 @@\n-                               private static class TZCanonicalIDMapHolder {\n-                                   static final Map<String, String> tzCanonicalIDMap = HashMap.newHashMap(%d);\n+                               private static class CLDRMapHolder {\n+                                   private static final Map<String, String> tzCanonicalIDMap = HashMap.newHashMap(%d);\n+                                   private static final Map<String, String> likelyScriptMap = HashMap.newHashMap(%d);\n+\n@@ -371,1 +355,2 @@\n-                           \"\"\", CLDRConverter.handlerTimeZone.getData().size());\n+                           \"\"\", CLDRConverter.handlerTimeZone.getData().size(),\n+                                metaInfo.keySet().stream().filter(k -> k.startsWith(CLDRConverter.LIKELY_SCRIPT_PREFIX)).count());\n@@ -376,1 +361,1 @@\n-                                ids[0]);\n+                            ids[0]);\n@@ -382,1 +367,12 @@\n-                out.printf(\"        }\\n    }\\n\\n\");\n+                out.println();\n+\n+                \/\/ for likelyScript map\n+                for (String key : metaInfo.keySet()) {\n+                    if (key.startsWith(CLDRConverter.LIKELY_SCRIPT_PREFIX)) {\n+                        \/\/ ensure spaces at the begin\/end for delimiting purposes\n+                        out.printf(\"            likelyScriptMap.put(\\\"%s\\\", \\\"%s\\\");\\n\",\n+                                key.substring(CLDRConverter.LIKELY_SCRIPT_PREFIX.length()),\n+                                \" \" + metaInfo.get(key).stream().collect(Collectors.joining(\" \")) + \" \");\n+                    }\n+                }\n+                out.printf(\"        }\\n    }\\n\");\n@@ -384,0 +380,1 @@\n+            out.println();\n@@ -393,1 +390,1 @@\n-                        return resourceNameToLocales.getOrDefault(category, \"\");\n+                        return \" %s\";\n@@ -395,2 +392,0 @@\n-                    %s\n-                }\n@@ -398,1 +393,4 @@\n-                CLDRConverter.isBaseModule ? \"\"\"\n+                toLocaleList(applyLanguageAliases(metaInfo.get(\"AvailableLocales\")), false));\n+\n+            if(CLDRConverter.isBaseModule) {\n+                out.printf(\"\"\"\n@@ -407,1 +405,1 @@\n-                        return TZCanonicalIDMapHolder.tzCanonicalIDMap;\n+                        return CLDRMapHolder.tzCanonicalIDMap;\n@@ -413,1 +411,8 @@\n-                \"\"\" : \"\");\n+\n+                    \/\/ package access from CLDRLocaleProviderAdapter\n+                    Map<String, String> likelyScriptMap() {\n+                        return CLDRMapHolder.likelyScriptMap;\n+                    }\n+                \"\"\");\n+            }\n+            out.printf(\"}\\n\");\n@@ -417,0 +422,18 @@\n+    private static void generateStringArray(SortedSet<String> set, PrintWriter out) throws IOException {\n+        String[] children = toLocaleList(set, true).split(\" \");\n+        Arrays.sort(children);\n+        out.printf(\"            new String[] {\\n\" +\n+                \"                \");\n+        int count = 0;\n+        for (int i = 0; i < children.length; i++) {\n+            String child = children[i];\n+            out.printf(\"\\\"%s\\\", \", child);\n+            count += child.length() + 4;\n+            if (i != children.length - 1 && count > 64) {\n+                out.printf(\"\\n                \");\n+                count = 0;\n+            }\n+        }\n+        out.printf(\"\\n            });\\n\");\n+    }\n+\n@@ -436,1 +459,3 @@\n-                sb.append(' ');\n+                if (sb.length() > 0) {\n+                    sb.append(' ');\n+                }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":84,"deletions":59,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    private final Map<String, Object> firstDayMap;\n-    private final Map<String, Object> minDaysMap;\n+    private static final Map<String, Object> firstDayMap = new HashMap<>();\n+    private static final Map<String, Object> minDaysMap = new HashMap<>();\n@@ -67,1 +67,1 @@\n-    private final Map<String, String> parentLocalesMap;\n+    private static final Map<String, String> parentLocalesMap = new HashMap<>();\n@@ -71,1 +71,1 @@\n-    private final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap;\n+    private static final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap = new HashMap<>();\n@@ -76,7 +76,0 @@\n-    SupplementalDataParseHandler() {\n-        firstDayMap = new HashMap<>();\n-        minDaysMap = new HashMap<>();\n-        parentLocalesMap = new HashMap<>();\n-        inputSkeletonMap = new HashMap<>();\n-    }\n-\n@@ -161,0 +154,2 @@\n+                    var parent = attributes.getValue(\"parent\").replaceAll(\"_\", \"-\");\n+\n@@ -162,1 +157,1 @@\n-                        attributes.getValue(\"parent\").replaceAll(\"_\", \"-\"),\n+                        parent,\n@@ -164,0 +159,4 @@\n+\n+                    if (\"root\".equals(parent)) {\n+                        CLDRConverter.nonlikelyScript = \"nonlikelyScript\".equals(attributes.getValue(\"localeRules\"));\n+                    }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementalDataParseHandler.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,3 +315,0 @@\n-            if (Math.abs(time - System.currentTimeMillis()) > ((long) 10) * 365 * 24 * 60 * 60 * 1000) {\n-                throw new RuntimeException(\"time is more than 10 years from present: \" + time);\n-            }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecurrencydata\/GenerateCurrencyData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-#\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-include LibCommon.gmk\n-\n-ifeq ($(call isTargetOs, aix), false)\n-  ##############################################################################\n-  ## Build lible\n-  ##############################################################################\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBLE, \\\n-      NAME := le, \\\n-      LINK_TYPE := C++, \\\n-      OPTIMIZATION := LOW, \\\n-      EXTRA_HEADER_DIRS := \\\n-          java.base:libjava \\\n-          java.base:libjvm, \\\n-      LD_SET_ORIGIN := false, \\\n-      LIBS_windows := user32.lib, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBLE)\n-endif\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1265,1 +1265,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -2690,1 +2691,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -894,1 +894,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -927,0 +933,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -1149,1 +1158,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1166,1 +1181,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n@@ -1200,1 +1215,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -289,2 +289,1 @@\n-\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array) {\n@@ -315,1 +314,3 @@\n-  initialize_body(obj, arr_size, base_offset, t1, t2);\n+  if (zero_array) {\n+    initialize_body(obj, arr_size, base_offset, t1, t2);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5908,1 +5908,0 @@\n-  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n@@ -5911,0 +5910,1 @@\n+  int klass_offset  = arrayOopDesc::klass_offset_in_bytes();\n@@ -5914,0 +5914,10 @@\n+  \/\/ When the length offset is not aligned to 8 bytes,\n+  \/\/ then we align it down. This is valid because the new\n+  \/\/ offset will always be the klass which is the same\n+  \/\/ for type arrays.\n+  int start_offset = align_down(length_offset, BytesPerWord);\n+  int extra_length = base_offset - start_offset;\n+  assert(start_offset == length_offset || start_offset == klass_offset,\n+         \"start offset must be 8-byte-aligned or be the klass offset\");\n+  assert(base_offset != start_offset, \"must include the length field\");\n+  extra_length = extra_length \/ elem_size; \/\/ We count in elements, not bytes.\n@@ -5947,5 +5957,4 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n-    eorw(tmp5, cnt1, cnt2);\n-    cbnzw(tmp5, DONE);\n-    lea(a1, Address(a1, base_offset));\n-    lea(a2, Address(a2, base_offset));\n+    \/\/ Increase loop counter by diff between base- and actual start-offset.\n+    addw(cnt1, cnt1, extra_length);\n+    lea(a1, Address(a1, start_offset));\n+    lea(a2, Address(a2, start_offset));\n@@ -6014,1 +6023,3 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n+    \/\/ Increase loop counter by diff between base- and actual start-offset.\n+    addw(cnt1, cnt1, extra_length);\n+\n@@ -6019,1 +6030,1 @@\n-    ldr(tmp3, Address(pre(a1, base_offset)));\n+    ldr(tmp3, Address(pre(a1, start_offset)));\n@@ -6022,1 +6033,1 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n@@ -6024,2 +6035,0 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n@@ -6057,3 +6066,1 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n@@ -6080,3 +6087,0 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n-    cbz(cnt1, SAME);\n@@ -6084,2 +6088,2 @@\n-    ldr(tmp3, Address(a1, base_offset));\n-    ldr(tmp4, Address(a2, base_offset));\n+    ldr(tmp3, Address(a1, start_offset));\n+    ldr(tmp4, Address(a2, start_offset));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -37,1 +37,1 @@\n-    guarantee(ni->data() == (intptr_t)(x + o), \"instructions must match\");\n+    guarantee(ni->data() == (intptr_t)x, \"instructions must match\");\n@@ -39,1 +39,1 @@\n-    ni->set_data((intptr_t)(x + o));\n+    ni->set_data((intptr_t)x);\n","filename":"src\/hotspot\/cpu\/arm\/relocInfo_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ Currently we don't support splitting of relocations.\n-  assert(o == 0, \"tried to split relocations\");\n-\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1872,1 +1872,0 @@\n-  INSN(vandn_vx,   0b1010111, 0b100, 0b000001);\n@@ -1874,1 +1873,0 @@\n-  INSN(vclmul_vx,  0b1010111, 0b110, 0b001100);\n@@ -1876,1 +1874,0 @@\n-  INSN(vclmulh_vx, 0b1010111, 0b110, 0b001101);\n@@ -1878,1 +1875,0 @@\n-  INSN(vror_vx,    0b1010111, 0b100, 0b010100);\n@@ -1880,1 +1876,0 @@\n-  INSN(vrol_vx,    0b1010111, 0b100, 0b010101);\n@@ -1894,0 +1889,3 @@\n+  INSN(vclz_v,  0b1010111, 0b010, 0b01100, 0b010010); \/\/ count leading zeros\n+  INSN(vctz_v,  0b1010111, 0b010, 0b01101, 0b010010); \/\/ count trailing zeros\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+      case Op_CountTrailingZerosV:\n+      case Op_CountLeadingZerosV:\n@@ -3762,3 +3764,3 @@\n-instruct vreverse_bytes_masked(vReg dst, vReg src, vRegMask_V0 v0) %{\n-  match(Set dst (ReverseBytesV src v0));\n-  format %{ \"vreverse_bytes_masked $dst, $src, v0\" %}\n+instruct vreverse_bytes_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (ReverseBytesV dst_src v0));\n+  format %{ \"vreverse_bytes_masked $dst_src, $dst_src, v0\" %}\n@@ -3769,1 +3771,1 @@\n-    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), Assembler::v0_t);\n+    __ vrev8_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n@@ -3820,3 +3822,3 @@\n-instruct vpopcount_masked(vReg dst, vReg src, vRegMask_V0 v0) %{\n-  match(Set dst (PopCountVI src v0));\n-  match(Set dst (PopCountVL src v0));\n+instruct vpopcount_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (PopCountVI dst_src v0));\n+  match(Set dst_src (PopCountVL dst_src v0));\n@@ -3824,1 +3826,1 @@\n-  format %{ \"vcpop_v $dst, $src, $v0\\t# vcpop_v with mask\" %}\n+  format %{ \"vcpop_v $dst_src, $dst_src, $v0\\t# vcpop_v with mask\" %}\n@@ -3829,1 +3831,1 @@\n-    __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), Assembler::v0_t);\n+    __ vcpop_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n@@ -3848,0 +3850,56 @@\n+\/\/ ------------------------------ CountLeadingZerosV --------------------------\n+\n+instruct vcountLeadingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (CountLeadingZerosV dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_leading_zeros_masked $dst_src, $dst_src, v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vclz_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_leading_zeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vclz_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (CountTrailingZerosV dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_trailing_zeros_masked $dst_src, $dst_src, v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vctz_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_trailing_zeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vctz_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":67,"deletions":9,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,4 +355,0 @@\n-\n-  RelocationHolder rspec(int offset) const {\n-    return offset == 0 ? _rspec : _rspec.plus(offset);\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ we don't support splitting of relocations, so o must be zero:\n-  assert(o == 0, \"tried to split relocations\");\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -39,1 +37,1 @@\n-        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n@@ -43,1 +41,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x));\n@@ -45,1 +43,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x));\n@@ -50,1 +48,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x), code());\n@@ -53,1 +51,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x), code());\n","filename":"src\/hotspot\/cpu\/s390\/relocInfo_s390.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1661,1 +1661,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -3639,1 +3640,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1032,1 +1032,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1044,0 +1050,7 @@\n+  int flags;\n+  ciArrayKlass* expected_type;\n+  arraycopy_helper(x, &flags, &expected_type);\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n+\n@@ -1051,0 +1064,5 @@\n+\n+  if (expected_type != nullptr && flags == 0) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(3 * BytesPerWord);\n+  }\n@@ -1072,4 +1090,0 @@\n-  int flags;\n-  ciArrayKlass* expected_type;\n-  arraycopy_helper(x, &flags, &expected_type);\n-\n@@ -1338,1 +1352,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1355,1 +1375,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n@@ -1389,1 +1409,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array) {\n@@ -316,5 +316,7 @@\n-  const Register len_zero = len;\n-  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n-  \/\/ following the length field in initialize_header().\n-  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, base_offset, len_zero);\n+  if (zero_array) {\n+    const Register len_zero = len;\n+    \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+    \/\/ following the length field in initialize_header().\n+    int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+    initialize_body(obj, arr_size, base_offset, len_zero);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -41,1 +41,0 @@\n-  x += o;\n@@ -83,1 +82,1 @@\n-    guarantee(*pd_address_in_code() == (x + o), \"instructions must match\");\n+    guarantee(*pd_address_in_code() == x, \"instructions must match\");\n@@ -85,1 +84,1 @@\n-    *pd_address_in_code() = x + o;\n+    *pd_address_in_code() = x;\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/zero\/relocInfo_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                      untype(offset) \/ M, untype(offset) + length \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -153,1 +153,1 @@\n-                      untype(offset) \/ M, untype(offset) + length \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-                      untype(offset) \/ M, untype(offset + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -700,1 +700,1 @@\n-                      untype(offset) \/ M, untype(offset + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-                      untype(offset) \/ M, (untype(offset) + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -235,1 +235,1 @@\n-                      untype(offset) \/ M, (untype(offset) + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zPhysicalMemoryBacking_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+#if defined(X86) || defined(AARCH64)\n+  case vmIntrinsics::_clone:\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2272,2 +2272,5 @@\n-      if (type != nullptr && type->is_loaded() &&\n-          type->is_instance_klass() && !type->as_instance_klass()->is_interface()) {\n+      if (type != nullptr && type->is_loaded()) {\n+        assert(!type->is_instance_klass() || !type->as_instance_klass()->is_interface(), \"Must not be an interface\");\n+        \/\/ Detects non-interface instances, primitive arrays, and some object arrays.\n+        \/\/ Array receivers can only call Object methods, so we should be able to allow\n+        \/\/ all object arrays here too, even those with unloaded types.\n@@ -2494,1 +2497,1 @@\n-  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before)));\n+  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before, true)));\n@@ -3926,0 +3929,1 @@\n+  case vmIntrinsics::_clone                  : append_alloc_array_copy(callee); return;\n@@ -3929,0 +3933,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return;\n+  }\n@@ -3990,0 +3997,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return false;\n+  }\n@@ -4703,0 +4713,37 @@\n+void GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n+  const int args_base = state()->stack_size() - callee->arg_size();\n+  ciType* receiver_type = state()->stack_at(args_base)->exact_type();\n+  if (receiver_type == nullptr) {\n+    inline_bailout(\"must have a receiver\");\n+    return;\n+  }\n+  if (!receiver_type->is_type_array_klass()) {\n+    inline_bailout(\"clone array not primitive\");\n+    return;\n+  }\n+\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_force_reexecute();\n+  Value src = apop();\n+  BasicType basic_type = src->exact_type()->as_array_klass()->element_type()->basic_type();\n+  Value length = append(new ArrayLength(src, state_before));\n+  Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n+\n+  ValueType* result_type = as_ValueType(callee->return_type());\n+  vmIntrinsics::ID id = vmIntrinsics::_arraycopy;\n+  Values* args = new Values(5);\n+  args->push(src);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(new_array);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(length);\n+  const bool has_receiver = true;\n+  Intrinsic* array_copy = new Intrinsic(result_type, id,\n+                                    args, has_receiver, state_before,\n+                                    vmIntrinsics::preserves_state(id),\n+                                    vmIntrinsics::can_trap(id));\n+  array_copy->set_flag(Instruction::OmitChecksFlag, true);\n+  append_split(array_copy);\n+  apush(new_array);\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+  void append_alloc_array_copy(ciMethod* callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -388,0 +388,1 @@\n+    OmitChecksFlag,\n@@ -1392,0 +1393,1 @@\n+  bool _zero_array;\n@@ -1395,1 +1397,1 @@\n-  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)\n+  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before, bool zero_array)\n@@ -1398,0 +1400,1 @@\n+  , _zero_array(zero_array)\n@@ -1402,0 +1405,1 @@\n+  bool zero_array()    const                     { return _zero_array; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,0 +390,7 @@\n+#if defined(X86) || defined(AARCH64)\n+  if (expected_type != nullptr && flags == 0) {\n+    _stub = nullptr;\n+  } else {\n+    _stub = new ArrayCopyStub(this);\n+  }\n+#else\n@@ -391,0 +398,1 @@\n+#endif\n@@ -1124,1 +1132,4 @@\n-  masm->append_code_stub(stub());\n+  ArrayCopyStub* code_stub = stub();\n+  if (code_stub != nullptr) {\n+    masm->append_code_stub(code_stub);\n+  }\n@@ -1515,1 +1526,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array, bool is_null_free) {\n@@ -1526,0 +1537,1 @@\n+                           zero_array,\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1854,0 +1854,1 @@\n+  bool      _zero_array;\n@@ -1857,1 +1858,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool is_null_free)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array, bool is_null_free)\n@@ -1867,0 +1868,1 @@\n+    , _zero_array(zero_array)\n@@ -1878,0 +1880,1 @@\n+  bool      zero_array()   const                 { return _zero_array;  }\n@@ -2444,1 +2447,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true, bool is_null_free = false);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  bool     _force_reexecute;                     \/\/ force the reexecute flag on, used for patching stub\n@@ -231,0 +232,3 @@\n+  bool force_reexecute() const         { return _force_reexecute; }\n+  void set_force_reexecute()           { _force_reexecute = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  _current_dump_space(nullptr),\n+  _current_dump_region(nullptr),\n@@ -344,1 +344,1 @@\n-  _current_dump_space = &_rw_region;\n+  _current_dump_region = &_rw_region;\n@@ -347,1 +347,1 @@\n-  _current_dump_space->init(&_shared_rs, &_shared_vs);\n+  _current_dump_region->init(&_shared_rs, &_shared_vs);\n@@ -563,1 +563,1 @@\n-void ArchiveBuilder::start_dump_space(DumpRegion* next) {\n+void ArchiveBuilder::start_dump_region(DumpRegion* next) {\n@@ -565,1 +565,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -568,2 +568,2 @@\n-  current_dump_space()->pack(next);\n-  _current_dump_space = next;\n+  current_dump_region()->pack(next);\n+  _current_dump_region = next;\n@@ -572,1 +572,1 @@\n-  _last_verified_top = (address)(current_dump_space()->top());\n+  _last_verified_top = (address)(current_dump_region()->top());\n@@ -577,1 +577,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -633,1 +633,1 @@\n-  start_dump_space(&_ro_region);\n+  start_dump_region(&_ro_region);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  DumpRegion* _current_dump_space;\n+  DumpRegion* _current_dump_region;\n@@ -117,1 +117,1 @@\n-  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+  DumpRegion* current_dump_region() const {  return _current_dump_region;  }\n@@ -281,1 +281,1 @@\n-  void start_dump_space(DumpRegion* next);\n+  void start_dump_region(DumpRegion* next);\n@@ -287,5 +287,5 @@\n-  address buffer_bottom()                    const { return _buffer_bottom;                       }\n-  address buffer_top()                       const { return (address)current_dump_space()->top(); }\n-  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;    }\n-  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;       }\n-  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;           }\n+  address buffer_bottom()                    const { return _buffer_bottom;                        }\n+  address buffer_top()                       const { return (address)current_dump_region()->top(); }\n+  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;     }\n+  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;        }\n+  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;            }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,2 +70,4 @@\n-typedef ResourceHashtable<address, size_t,\n-      127, \/\/ prime number\n+typedef ResourceHashtable<\n+      size_t,    \/\/ offset of a filler from ArchiveHeapWriter::buffer_bottom()\n+      size_t,    \/\/ size of this filler (in bytes)\n+      127,       \/\/ prime number\n@@ -364,1 +366,1 @@\n-    _fillers->put((address)filler, fill_bytes);\n+    _fillers->put(buffered_address_to_offset((address)filler), fill_bytes);\n@@ -369,1 +371,1 @@\n-  size_t* p = _fillers->get(buffered_addr);\n+  size_t* p = _fillers->get(buffered_address_to_offset(buffered_addr));\n@@ -533,4 +535,2 @@\n-  \/\/ in the shared heap. This also has the side effect of pre-initializing the\n-  \/\/ identity_hash for all shared objects, so they are less likely to be written\n-  \/\/ into during run time, increasing the potential of memory sharing.\n-  if (src_obj != nullptr && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n+  \/\/ in the shared heap.\n+  if (src_obj != nullptr && !src_obj->fast_no_hash_check() && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -313,11 +313,3 @@\n-  _dump_region->append_intptr_t((intptr_t)ptr, true);\n-}\n-\n-void WriteClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    do_ptr((void**)start);\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n+  \/\/ null pointers do not need to be converted to offsets\n+  if (ptr != nullptr) {\n+    ptr = (address)ArchiveBuilder::current()->buffer_to_offset(ptr);\n@@ -325,0 +317,1 @@\n+  _dump_region->append_intptr_t((intptr_t)ptr, false);\n@@ -332,1 +325,1 @@\n-  *p = (void*)obj;\n+  *p = (void*)obj != nullptr ? (void*)(SharedBaseAddress + obj) : (void*)obj;\n@@ -358,11 +351,0 @@\n-void ReadClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    *(intptr_t*)start = nextPtr();\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -218,1 +218,4 @@\n-  void do_region(u_char* start, size_t size);\n+  char* region_top() {\n+    return _dump_region->top();\n+  }\n+\n@@ -241,1 +244,0 @@\n-  void do_region(u_char* start, size_t size);\n@@ -243,0 +245,1 @@\n+  char* region_top() { return nullptr; }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -57,1 +58,5 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) :\n+    _classlist_file(file),\n+    _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n+    _file_input(do_open(file), \/* need_close=*\/true),\n+    _input_stream(&_file_input) {\n@@ -60,11 +65,1 @@\n-  _classlist_file = file;\n-  _file = nullptr;\n-  \/\/ Use os::open() because neither fopen() nor os::fopen()\n-  \/\/ can handle long path name on Windows.\n-  int fd = os::open(file, O_RDONLY, S_IREAD);\n-  if (fd != -1) {\n-    \/\/ Obtain a File* from the file descriptor so that fgets()\n-    \/\/ can be used in parse_one_line()\n-    _file = os::fdopen(fd, \"r\");\n-  }\n-  if (_file == nullptr) {\n+  if (!_file_input.is_open()) {\n@@ -75,2 +70,1 @@\n-  _line_no = 0;\n-  _token = _line;\n+  _token = _line = nullptr;\n@@ -87,0 +81,13 @@\n+FILE* ClassListParser::do_open(const char* file) {\n+  \/\/ Use os::open() because neither fopen() nor os::fopen()\n+  \/\/ can handle long path name on Windows. (See JDK-8216184)\n+  int fd = os::open(file, O_RDONLY, S_IREAD);\n+  FILE* fp = nullptr;\n+  if (fd != -1) {\n+    \/\/ Obtain a FILE* from the file descriptor so that _input_stream\n+    \/\/ can be used in ClassListParser::parse()\n+    fp = os::fdopen(fd, \"r\");\n+  }\n+  return fp;\n+}\n+\n@@ -92,3 +99,0 @@\n-  if (_file != nullptr) {\n-    fclose(_file);\n-  }\n@@ -104,1 +108,9 @@\n-  while (parse_one_line()) {\n+  for (; !_input_stream.done(); _input_stream.next()) {\n+    _line = _input_stream.current_line();\n+    if (*_line == '#') { \/\/ comment\n+      continue;\n+    }\n+    if (!parse_one_line()) {\n+      break;\n+    }\n+\n@@ -115,0 +127,1 @@\n+    check_class_name(_class_name);\n@@ -168,21 +181,7 @@\n-  for (;;) {\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n-      return false;\n-    }\n-    ++ _line_no;\n-    _line_len = (int)strlen(_line);\n-    if (_line_len > _max_allowed_line_len) {\n-      error(\"input line too long (must be no longer than %d chars)\", _max_allowed_line_len);\n-    }\n-    if (*_line == '#') { \/\/ comment\n-      continue;\n-    }\n-\n-    {\n-      int len = (int)strlen(_line);\n-      int i;\n-      \/\/ Replace \\t\\r\\n\\f with ' '\n-      for (i=0; i<len; i++) {\n-        if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n-          _line[i] = ' ';\n-        }\n+  {\n+    int len = (int)strlen(_line);\n+    int i;\n+    \/\/ Replace \\t\\r\\n\\f with ' '\n+    for (i=0; i<len; i++) {\n+      if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n+        _line[i] = ' ';\n@@ -190,0 +189,1 @@\n+    }\n@@ -191,8 +191,7 @@\n-      \/\/ Remove trailing newline\/space\n-      while (len > 0) {\n-        if (_line[len-1] == ' ') {\n-          _line[len-1] = '\\0';\n-          len --;\n-        } else {\n-          break;\n-        }\n+    \/\/ Remove trailing newline\/space\n+    while (len > 0) {\n+      if (_line[len-1] == ' ') {\n+        _line[len-1] = '\\0';\n+        len --;\n+      } else {\n+        break;\n@@ -200,1 +199,0 @@\n-      _line_len = len;\n@@ -202,3 +200,1 @@\n-\n-    \/\/ valid line\n-    break;\n+    _line_len = len;\n@@ -289,1 +285,1 @@\n-    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_no);\n+    error(\"Too few items following the @ tag \\\"%s\\\" line #%zu\", _line, lineno());\n@@ -307,1 +303,1 @@\n-      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_no);\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%zu\", _token, lineno());\n@@ -318,1 +314,1 @@\n-    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_no);\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%zu\", _token, lineno());\n@@ -426,2 +422,2 @@\n-              \"An error has occurred while processing class list file %s %d:%d.\\n\",\n-              _classlist_file, _line_no, (error_index + 1));\n+              \"An error has occurred while processing class list file %s %zu:%d.\\n\",\n+              _classlist_file, lineno(), (error_index + 1));\n@@ -453,0 +449,19 @@\n+void ClassListParser::check_class_name(const char* class_name) {\n+  const char* err = nullptr;\n+  size_t len = strlen(class_name);\n+  if (len > (size_t)Symbol::max_length()) {\n+    err = \"class name too long\";\n+  } else {\n+    assert(Symbol::max_length() < INT_MAX && len < INT_MAX, \"must be\");\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n+      err = \"class name is not valid UTF8\";\n+    }\n+  }\n+  if (err != nullptr) {\n+    jio_fprintf(defaultStream::error_stream(),\n+              \"An error has occurred while processing class list file %s:%zu %s\\n\",\n+              _classlist_file, lineno(), err);\n+    vm_exit_during_initialization(\"class list format error.\", nullptr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":72,"deletions":57,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -83,8 +84,0 @@\n-\n-    \/\/ Max number of bytes allowed per line in the classlist.\n-    \/\/ Theoretically Java class names could be 65535 bytes in length. Also, an input line\n-    \/\/ could have a very long path name up to JVM_MAXPATHLEN bytes in length. In reality,\n-    \/\/ 4K bytes is more than enough.\n-    _max_allowed_line_len = 4096,\n-    _line_buf_extra       = 10, \/\/ for detecting input too long\n-    _line_buf_size        = _max_allowed_line_len + _line_buf_extra\n@@ -99,1 +92,0 @@\n-  FILE* _file;\n@@ -103,3 +95,3 @@\n-  \/\/ The following field contains information from the *current* line being\n-  \/\/ parsed.\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n+  FileInput           _file_input;\n+  inputStream         _input_stream;\n+  char*               _line;                  \/\/ The buffer that holds the current line. Some characters in\n@@ -108,1 +100,0 @@\n-  int                 _line_no;               \/\/ Line number for current line being parsed\n@@ -135,0 +126,2 @@\n+  size_t lineno() { return _input_stream.lineno(); }\n+  FILE* do_open(const char* file);\n@@ -186,0 +179,1 @@\n+  void check_class_name(const char* class_name);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-CppVtableInfo** CppVtables::_index = nullptr;\n+static CppVtableInfo* _index[_num_cloned_vtable_kinds];\n@@ -224,1 +224,7 @@\n-char* CppVtables::dumptime_init(ArchiveBuilder* builder) {\n+\/\/ Vtables are all fixed offsets from ArchiveBuilder::current()->mapped_base()\n+\/\/ E.g. ConstantPool is at offset 0x58. We can archive these offsets in the\n+\/\/ RO region and use them to alculate their location at runtime without storing\n+\/\/ the pointers in the RW region\n+char* CppVtables::_vtables_serialized_base = nullptr;\n+\n+void CppVtables::dumptime_init(ArchiveBuilder* builder) {\n@@ -226,2 +232,0 @@\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(CppVtableInfo*);\n-  _index = (CppVtableInfo**)builder->rw_region()->allocate(vtptrs_bytes);\n@@ -233,2 +237,0 @@\n-\n-  return (char*)_index;\n@@ -238,1 +240,6 @@\n-  soc->do_ptr(&_index);\n+  if (!soc->reading()) {\n+    _vtables_serialized_base = (char*)ArchiveBuilder::current()->buffer_top();\n+  }\n+  for (int i = 0; i < _num_cloned_vtable_kinds; i++) {\n+    soc->do_ptr(&_index[i]);\n+  }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  static CppVtableInfo** _index;\n+  static char* _vtables_serialized_base;\n@@ -41,1 +41,1 @@\n-  static char* dumptime_init(ArchiveBuilder* builder);\n+  static void dumptime_init(ArchiveBuilder* builder);\n@@ -46,0 +46,1 @@\n+  static char* vtables_serialized_base() { return _vtables_serialized_base; }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-      assert(current_dump_space() == ro_region(), \"Must be RO space\");\n+      assert(current_dump_region() == ro_region(), \"Must be RO space\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,8 +281,0 @@\n-\n-    \/\/ The archived objects are discovered in a predictable order. Compute\n-    \/\/ their identity_hash() as soon as we see them. This ensures that the\n-    \/\/ the identity_hash in the object header will have a predictable value,\n-    \/\/ making the archive reproducible.\n-    if (!obj->klass()->is_inline_klass()) {\n-      obj->identity_hash();\n-    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-  char* cloned_vtables = CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&builder);\n@@ -547,1 +547,1 @@\n-  mapinfo->set_cloned_vtables(cloned_vtables);\n+  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,14 @@\n-  \/\/ Read\/write the region specified.\n-  virtual void do_region(u_char* start, size_t size) = 0;\n+  \/\/ Iterate on the pointers from p[0] through p[num_pointers-1]\n+  void do_ptrs(void** p, size_t size) {\n+    assert((intptr_t)p % sizeof(intptr_t) == 0, \"bad alignment\");\n+    assert(size % sizeof(intptr_t) == 0, \"bad size\");\n+    do_tag((int)size);\n+    while (size > 0) {\n+      do_ptr(p);\n+      p++;\n+      size -= sizeof(intptr_t);\n+    }\n+  }\n+\n+  \/\/ Address of the first element being written (write only)\n+  virtual char* region_top() = 0;\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  soc->do_region((u_char*)&Symbol::_vm_symbols[FIRST_SID],\n+  soc->do_ptrs((void**)&Symbol::_vm_symbols[FIRST_SID],\n@@ -210,1 +210,1 @@\n-  soc->do_region((u_char*)_type_signatures, sizeof(_type_signatures));\n+  soc->do_ptrs((void**)_type_signatures, sizeof(_type_signatures));\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,24 +280,0 @@\n-\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n-\n-RelocationHolder RelocationHolder::plus(int offset) const {\n-  if (offset != 0) {\n-    switch (type()) {\n-    case relocInfo::none:\n-      break;\n-    case relocInfo::oop_type:\n-      {\n-        oop_Relocation* r = (oop_Relocation*)reloc();\n-        return oop_Relocation::spec(r->oop_index(), r->offset() + offset);\n-      }\n-    case relocInfo::metadata_type:\n-      {\n-        metadata_Relocation* r = (metadata_Relocation*)reloc();\n-        return metadata_Relocation::spec(r->metadata_index(), r->offset() + offset);\n-      }\n-    default:\n-      ShouldNotReachHere();\n-    }\n-  }\n-  return (*this);\n-}\n-\n@@ -405,1 +381,1 @@\n-  p = pack_2_ints_to(p, _oop_index, _offset);\n+  p = pack_1_int_to(p, _oop_index);\n@@ -411,1 +387,1 @@\n-  unpack_2_ints(_oop_index, _offset);\n+  _oop_index = unpack_1_int();\n@@ -416,1 +392,1 @@\n-  p = pack_2_ints_to(p, _metadata_index, _offset);\n+  p = pack_1_int_to(p, _metadata_index);\n@@ -422,1 +398,1 @@\n-  unpack_2_ints(_metadata_index, _offset);\n+  _metadata_index = unpack_1_int();\n@@ -858,2 +834,2 @@\n-      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(oop_addr), p2i(raw_oop), r->offset());\n+      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(oop_addr), p2i(raw_oop));\n@@ -881,2 +857,2 @@\n-      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(metadata_addr), p2i(raw_metadata), r->offset());\n+      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(metadata_addr), p2i(raw_metadata));\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -132,6 +132,1 @@\n-\/\/          [n]      n is the index of an oop in the CodeBlob's oop pool\n-\/\/          [[N]n l] and l is a byte offset to be applied to the oop\n-\/\/          [Nn Ll]  both index and offset may be 32 bits if necessary\n-\/\/   Here is a special hack, used only by the old compiler:\n-\/\/          [[N]n 00] the value is the __address__ of the nth oop in the pool\n-\/\/   (Note that the offset allows optimal references to class variables.)\n+\/\/          [[N]n]   the index of an oop in the CodeBlob's oop pool\n@@ -518,3 +513,0 @@\n-  \/\/ Add a constant offset to a relocation.  Helper for class Address.\n-  RelocationHolder plus(int offset) const;\n-\n@@ -791,2 +783,2 @@\n-  void       pd_set_data_value       (address x, intptr_t off, bool verify_only = false); \/\/ a set or mem-ref\n-  void       pd_verify_data_value    (address x, intptr_t off) { pd_set_data_value(x, off, true); }\n+  void       pd_set_data_value       (address x, bool verify_only = false); \/\/ a set or mem-ref\n+  void       pd_verify_data_value    (address x) { pd_set_data_value(x, true); }\n@@ -898,1 +890,0 @@\n-\/\/ By convention, the \"value\" does not include a separately reckoned \"offset\".\n@@ -903,1 +894,1 @@\n-  bool          is_data() override             { return true; }\n+  bool    is_data() override { return true; }\n@@ -905,6 +896,4 @@\n-  \/\/ both target and offset must be computed somehow from relocation data\n-  virtual int    offset()                      { return 0; }\n-  address         value() override             = 0;\n-  void        set_value(address x) override    { set_value(x, offset()); }\n-  void        set_value(address x, intptr_t o) {\n-    if (addr_in_const())\n+  \/\/ target must be computed somehow from relocation data\n+  address value() override = 0;\n+  void    set_value(address x) override {\n+    if (addr_in_const()) {\n@@ -912,2 +901,3 @@\n-    else\n-      pd_set_data_value(x, o);\n+    } else {\n+      pd_set_data_value(x);\n+    }\n@@ -915,2 +905,2 @@\n-  void        verify_value(address x) {\n-    if (addr_in_const())\n+  void    verify_value(address x) {\n+    if (addr_in_const()) {\n@@ -918,2 +908,3 @@\n-    else\n-      pd_verify_data_value(x, offset());\n+    } else {\n+      pd_verify_data_value(x);\n+    }\n@@ -921,12 +912,0 @@\n-\n-  \/\/ The \"o\" (displacement) argument is relevant only to split relocations\n-  \/\/ on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins'ns\n-  \/\/ can encode more than 32 bits between them.  This allows compilers to\n-  \/\/ share set-hi instructions between addresses that differ by a small\n-  \/\/ offset (e.g., different static variables in the same class).\n-  \/\/ On such machines, the \"x\" argument to set_value on all set-lo\n-  \/\/ instructions must be the same as the \"x\" argument for the\n-  \/\/ corresponding set-hi instructions.  The \"o\" arguments for the\n-  \/\/ set-hi instructions are ignored, and must not affect the high-half\n-  \/\/ immediate constant.  The \"o\" arguments for the set-lo instructions are\n-  \/\/ added into the low-half immediate constant, and must not overflow it.\n@@ -979,3 +958,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an oop in the CodeBlob's oop pool\n-  static RelocationHolder spec(int oop_index, int offset = 0) {\n+  \/\/ an oop in the CodeBlob's oop pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int oop_index) {\n@@ -983,1 +961,1 @@\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -985,1 +963,1 @@\n-  \/\/ an oop in the instruction stream\n+  \/\/ an oop in the instruction stream; encoded as []\n@@ -992,2 +970,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -1000,1 +977,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the oop itself\n@@ -1002,2 +978,2 @@\n-  oop_Relocation(int oop_index, int offset)\n-    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index), _offset(offset) { }\n+  oop_Relocation(int oop_index)\n+    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index) { }\n@@ -1010,1 +986,0 @@\n-  int offset() override { return _offset; }\n@@ -1012,1 +987,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ oop_index is packed in \"1_int\" format:  [n] or [Nn]\n@@ -1034,3 +1009,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an metadata in the CodeBlob's metadata pool\n-  static RelocationHolder spec(int metadata_index, int offset = 0) {\n+  \/\/ an metadata in the CodeBlob's metadata pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int metadata_index) {\n@@ -1038,1 +1012,1 @@\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1040,1 +1014,1 @@\n-  \/\/ an metadata in the instruction stream\n+  \/\/ an metadata in the instruction stream; encoded as []\n@@ -1043,2 +1017,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1051,1 +1024,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the metadata itself\n@@ -1053,2 +1025,2 @@\n-  metadata_Relocation(int metadata_index, int offset)\n-    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index), _offset(offset) { }\n+  metadata_Relocation(int metadata_index)\n+    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index) { }\n@@ -1066,1 +1038,0 @@\n-  int offset() override { return _offset; }\n@@ -1068,1 +1039,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ metadata_index is packed in \"1_int\" format:  [n] or [Nn]\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":32,"deletions":61,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -1084,22 +1085,2 @@\n-  char token[1024];\n-  int  pos = 0;\n-  int  c = getc(stream);\n-  bool success = true;\n-  while(c != EOF && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_from_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n-    }\n-    c = getc(stream);\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_from_line(token)) {\n-    success = false;\n-  }\n-  fclose(stream);\n-  return success;\n+  FileInput input(stream, \/*need_close=*\/ true);\n+  return parse_from_input(&input, parse_from_line);\n@@ -1108,5 +1089,3 @@\n-bool CompilerOracle::parse_from_string(const char* str, bool (*parse_line)(char*)) {\n-  char token[1024];\n-  int  pos = 0;\n-  const char* sp = str;\n-  int  c = *sp++;\n+bool CompilerOracle::parse_from_input(inputStream::Input* input,\n+                                      CompilerOracle::\n+                                      parse_from_line_fn_t* parse_from_line) {\n@@ -1114,9 +1093,3 @@\n-  while (c != '\\0' && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n+  for (inputStream in(input); !in.done(); in.next()) {\n+    if (!parse_from_line(in.current_line())) {\n+      success = false;\n@@ -1124,5 +1097,0 @@\n-    c = *sp++;\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_line(token)) {\n-    success = false;\n@@ -1133,0 +1101,7 @@\n+bool CompilerOracle::parse_from_string(const char* str,\n+                                       CompilerOracle::\n+                                       parse_from_line_fn_t* parse_from_line) {\n+  MemoryInput input(str, strlen(str));\n+  return parse_from_input(&input, parse_from_line);\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":16,"deletions":41,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -123,0 +124,3 @@\n+ public:\n+  typedef bool parse_from_line_fn_t(char*);\n+\n@@ -128,0 +132,4 @@\n+  \/\/ The core parser.\n+  static bool parse_from_input(inputStream::Input* input,\n+                               parse_from_line_fn_t* parse_from_line);\n+\n@@ -180,1 +188,2 @@\n-  static bool parse_from_string(const char* option_string, bool (*parser)(char*));\n+  static bool parse_from_string(const char* option_string,\n+                                parse_from_line_fn_t* parser);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,0 +33,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArenaFreeMemoryTask.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -56,0 +55,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  product(bool, ZGenerational, false,                                       \\\n+  product(bool, ZGenerational, true,                                        \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2016, 2024, Red Hat, Inc. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  warning(\"Non-generational ZGC is deprecated.\");\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  log_info(gc, init)(\"Using legacy single-generation mode\");\n+  log_info(gc, init)(\"Using deprecated non-generational mode\");\n","filename":"src\/hotspot\/share\/gc\/x\/xInitialize.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-ZActivatedArray<T>::~ZActivatedArray<T>() {\n+ZActivatedArray<T>::~ZActivatedArray() {\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/jfrbitset.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,6 +251,0 @@\n-    \/\/ Traverse the monitor chunks\n-    MonitorChunk* chunk = jt->monitor_chunks();\n-    for (; chunk != nullptr; chunk = chunk->next()) {\n-      chunk->oops_do(&rcl);\n-    }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNativeMemoryEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n@@ -102,57 +103,0 @@\n-#define MEMORY_TYPES_DO(f)                                                           \\\n-  \/* Memory type by sub systems. It occupies lower byte. *\/                          \\\n-  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n-  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n-  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n-  f(mtThreadStack,    \"Thread Stack\")                                                \\\n-  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n-  f(mtGC,             \"GC\")                                                          \\\n-  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n-  f(mtCompiler,       \"Compiler\")                                                    \\\n-  f(mtJVMCI,          \"JVMCI\")                                                       \\\n-  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n-                                     \/* any of above categories, and not used by  *\/ \\\n-                                     \/* NMT                                       *\/ \\\n-  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n-  f(mtSymbol,         \"Symbol\")                                                      \\\n-  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n-  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n-  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n-  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n-  f(mtTracing,        \"Tracing\")                                                     \\\n-  f(mtLogging,        \"Logging\")                                                     \\\n-  f(mtStatistics,     \"Statistics\")                                                  \\\n-  f(mtArguments,      \"Arguments\")                                                   \\\n-  f(mtModule,         \"Module\")                                                      \\\n-  f(mtSafepoint,      \"Safepoint\")                                                   \\\n-  f(mtSynchronizer,   \"Synchronization\")                                             \\\n-  f(mtServiceability, \"Serviceability\")                                              \\\n-  f(mtMetaspace,      \"Metaspace\")                                                   \\\n-  f(mtStringDedup,    \"String Deduplication\")                                        \\\n-  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n-  f(mtNone,           \"Unknown\")                                                     \\\n-  \/\/end\n-\n-#define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \\\n-  type,\n-\n-\/*\n- * Memory types\n- *\/\n-enum class MEMFLAGS : uint8_t  {\n-  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)\n-  mt_number_of_types   \/\/ number of memory types (mtDontTrack\n-                       \/\/ is not included as validate type)\n-};\n-\/\/ Extra insurance that MEMFLAGS truly has the same size as uint8_t.\n-STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n-\n-#define MEMORY_TYPE_SHORTNAME(type, human_readable) \\\n-  constexpr MEMFLAGS type = MEMFLAGS::type;\n-\n-\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MEMFLAGS::mtGC.\n-MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME)\n-\n-\/\/ Make an int version of the sentinel end value.\n-constexpr int mt_number_of_types = static_cast<int>(MEMFLAGS::mt_number_of_types);\n-\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":58,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n@@ -28,0 +26,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/allocationSite.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -34,0 +36,4 @@\n+\/\/ The malloc header, as well as the coming VMATree implementation, rely on MEMFLAGS\n+\/\/ fitting into eight bits.\n+STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,2 @@\n-#include \"memory\/allocation.hpp\" \/\/ for mt_number_of_types\n+#include \"nmt\/memflags.hpp\"\n+#include \"utilities\/debug.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memFlagBitmap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,6 +149,11 @@\n-  out->print_cr(\"State: %s\", NMTUtil::tracking_level_to_string(_tracking_level));\n-  out->print_cr(\"Malloc allocation site table size: %d\", MallocSiteTable::hash_buckets());\n-  out->print_cr(\"             Tracking stack depth: %d\", NMT_TrackingStackDepth);\n-  out->cr();\n-  MallocSiteTable::print_tuning_statistics(out);\n-  out->cr();\n+  out->print_cr(\"State: %s\",\n+                NMTUtil::tracking_level_to_string(_tracking_level));\n+  if (_tracking_level == NMT_detail) {\n+    out->print_cr(\"Malloc allocation site table size: %d\",\n+                  MallocSiteTable::hash_buckets());\n+    out->print_cr(\"             Tracking stack depth: %d\",\n+                  NMT_TrackingStackDepth);\n+    out->cr();\n+    MallocSiteTable::print_tuning_statistics(out);\n+    out->cr();\n+  }\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMFLAGS_HPP\n+#define SHARE_NMT_MEMFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define MEMORY_TYPES_DO(f)                                                           \\\n+  \/* Memory type by sub systems. It occupies lower byte. *\/                          \\\n+  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n+  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n+  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n+  f(mtThreadStack,    \"Thread Stack\")                                                \\\n+  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n+  f(mtGC,             \"GC\")                                                          \\\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n+  f(mtCompiler,       \"Compiler\")                                                    \\\n+  f(mtJVMCI,          \"JVMCI\")                                                       \\\n+  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n+                                     \/* any of above categories, and not used by  *\/ \\\n+                                     \/* NMT                                       *\/ \\\n+  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n+  f(mtSymbol,         \"Symbol\")                                                      \\\n+  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n+  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n+  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n+  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n+  f(mtTracing,        \"Tracing\")                                                     \\\n+  f(mtLogging,        \"Logging\")                                                     \\\n+  f(mtStatistics,     \"Statistics\")                                                  \\\n+  f(mtArguments,      \"Arguments\")                                                   \\\n+  f(mtModule,         \"Module\")                                                      \\\n+  f(mtSafepoint,      \"Safepoint\")                                                   \\\n+  f(mtSynchronizer,   \"Synchronization\")                                             \\\n+  f(mtServiceability, \"Serviceability\")                                              \\\n+  f(mtMetaspace,      \"Metaspace\")                                                   \\\n+  f(mtStringDedup,    \"String Deduplication\")                                        \\\n+  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n+  f(mtNone,           \"Unknown\")                                                     \\\n+  \/\/end\n+\n+#define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \\\n+  type,\n+\n+enum class MEMFLAGS : uint8_t  {\n+  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)\n+  mt_number_of_types   \/\/ number of memory types (mtDontTrack\n+                       \/\/ is not included as validate type)\n+};\n+\n+#define MEMORY_TYPE_SHORTNAME(type, human_readable) \\\n+  constexpr MEMFLAGS type = MEMFLAGS::type;\n+\n+\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MEMFLAGS::mtGC.\n+MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME)\n+\n+\/\/ Make an int version of the sentinel end value.\n+constexpr int mt_number_of_types = static_cast<int>(MEMFLAGS::mt_number_of_types);\n+\n+#endif \/\/ SHARE_NMT_MEMFLAGS_HPP\n","filename":"src\/hotspot\/share\/nmt\/memflags.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-#include \"memory\/allocation.hpp\" \/\/ for MEMFLAGS only\n+#include \"memory\/allStatic.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/nmtCommon.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-    if (check_detail_tracking_level(output())) {\n+    if (MemTracker::enabled()) {\n@@ -142,0 +142,2 @@\n+    } else {\n+      output()->print_cr(\"Native memory tracking is not enabled\");\n","filename":"src\/hotspot\/share\/nmt\/nmtDCmd.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -562,2 +562,2 @@\n-        } else if (nesting > 0 && load_type->isa_narrowklass()) {\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Nested NarrowKlass Load: %s\", n->_idx, _invocation, use_use->Name());)\n+        } else if (load_type->isa_narrowklass() || load_type->isa_klassptr()) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. [Narrow] Klass Load: %s\", n->_idx, _invocation, use_use->Name());)\n@@ -2226,1 +2226,2 @@\n-                  strcmp(call->as_CallLeaf()->_name, \"get_class_id_intrinsic\") == 0)\n+                  strcmp(call->as_CallLeaf()->_name, \"get_class_id_intrinsic\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"unsafe_setmemory\") == 0)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  _align_to_ref(nullptr),                                   \/\/ memory reference to align vectors to\n@@ -54,0 +53,2 @@\n+  _mem_ref_for_main_loop_alignment(nullptr),\n+  _aw_for_main_loop_alignment(0),\n@@ -519,5 +520,0 @@\n-  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n-  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n-  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n-  MemNode* align_to_mem_ref = nullptr;\n-\n@@ -530,5 +526,0 @@\n-    if (align_to_mem_ref == nullptr) {\n-      align_to_mem_ref = mem_ref;\n-      set_align_to_ref(align_to_mem_ref);\n-    }\n-\n@@ -576,3 +567,0 @@\n-  assert(_pairset.is_empty() || align_to_mem_ref != nullptr,\n-         \"pairset empty or we find the alignment reference\");\n-\n@@ -1726,1 +1714,5 @@\n-    set_align_to_ref(current->as_constrained()->mem_ref());\n+    MemNode const* mem = current->as_constrained()->mem_ref();\n+    Node_List* pack = get_pack(mem);\n+    assert(pack != nullptr, \"memop of final solution must still be packed\");\n+    _mem_ref_for_main_loop_alignment = mem;\n+    _aw_for_main_loop_alignment = pack->size() * mem->memory_size();\n@@ -3400,0 +3392,26 @@\n+\/\/ Find the memop pack with the maximum vector width, unless they were already\n+\/\/ determined by SuperWord::filter_packs_for_alignment().\n+void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+  if (_mem_ref_for_main_loop_alignment != nullptr) {\n+    assert(vectors_should_be_aligned(), \"mem_ref only set if filtered for alignment\");\n+    return;\n+  }\n+\n+  MemNode const* mem_ref = nullptr;\n+  int max_aw = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    MemNode* first = pack->at(0)->isa_Mem();\n+    if (first == nullptr) { continue; }\n+\n+    int vw = first->memory_size() * pack->size();\n+    if (vw > max_aw) {\n+      max_aw = vw;\n+      mem_ref = first;\n+    }\n+  }\n+  assert(mem_ref != nullptr && max_aw > 0, \"found mem_ref and aw\");\n+  _mem_ref_for_main_loop_alignment = mem_ref;\n+  _aw_for_main_loop_alignment = max_aw;\n+}\n+\n@@ -3410,2 +3428,3 @@\n-\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n-\/\/ iteration count by adjusting the pre-loop limit.\n+\/\/ the address of \"_mem_ref_for_main_loop_alignment\" to \"_aw_for_main_loop_alignment\", which is a\n+\/\/ sufficiently large alignment width. We adjust the pre-loop iteration count by adjusting the\n+\/\/ pre-loop limit.\n@@ -3413,2 +3432,4 @@\n-  const MemNode* align_to_ref = _align_to_ref;\n-  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  determine_mem_ref_and_aw_for_main_loop_alignment();\n+  const MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\n+  const int aw                = _aw_for_main_loop_alignment;\n+  assert(align_to_ref != nullptr && aw > 0, \"must have alignment reference and aw\");\n@@ -3559,4 +3580,1 @@\n-\n-  \/\/ We chose an aw that is the maximal possible vector width for the type of\n-  \/\/ align_to_ref.\n-  const int aw       = vector_width_in_bytes(align_to_ref);\n+  \/\/\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-  MemNode const* _align_to_ref;          \/\/ Memory reference that pre-loop will align to\n@@ -419,0 +418,5 @@\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n@@ -566,2 +570,0 @@\n-  const MemNode* align_to_ref() const { return _align_to_ref; }\n-  void set_align_to_ref(const MemNode* m) { _align_to_ref = m; }\n@@ -673,0 +675,1 @@\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,0 +62,11 @@\n+#define log_if_needed(...)        \\\n+  if (C->print_intrinsics()) {    \\\n+    tty->print_cr(__VA_ARGS__);   \\\n+  }\n+\n+#ifndef PRODUCT\n+#define non_product_log_if_needed(...) log_if_needed(__VA_ARGS__)\n+#else\n+#define non_product_log_if_needed(...)\n+#endif\n+\n@@ -88,6 +99,2 @@\n-      #ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n-                        NodeClassNames[Op_VectorLoadMask], type2name(elem_bt), num_elem);\n-        }\n-      #endif\n+        non_product_log_if_needed(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n+                                  NodeClassNames[Op_VectorLoadMask], type2name(elem_bt), num_elem);\n@@ -101,6 +108,2 @@\n-      #ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n-                        NodeClassNames[opc], type2name(elem_bt), num_elem);\n-        }\n-      #endif\n+        non_product_log_if_needed(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n+                                  NodeClassNames[opc], type2name(elem_bt), num_elem);\n@@ -188,5 +191,1 @@\n-#ifndef PRODUCT\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** Rejected intrinsification because no valid vector op could be extracted\");\n-    }\n-#endif\n+    non_product_log_if_needed(\"  ** Rejected intrinsification because no valid vector op could be extracted\");\n@@ -198,6 +197,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -208,6 +203,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support integral vector negate\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support integral vector negate\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -219,6 +210,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -233,6 +220,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -244,6 +227,2 @@\n-#ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n-                        NodeClassNames[sopc], type2name(type), num_elem);\n-        }\n-#endif\n+        non_product_log_if_needed(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n+                                  NodeClassNames[sopc], type2name(type), num_elem);\n@@ -257,4 +236,2 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n-                    NodeClassNames[sopc], type2name(type), num_elem);\n-    }\n+    log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                  NodeClassNames[sopc], type2name(type), num_elem);\n@@ -270,6 +247,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[Op_VectorLoadMask], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[Op_VectorLoadMask], type2name(type), num_elem);\n@@ -286,6 +259,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"Rejected vector mask storing (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[Op_VectorStoreMask], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"Rejected vector mask storing (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[Op_VectorStoreMask], type2name(type), num_elem);\n@@ -308,6 +277,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -363,2 +328,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -369,1 +333,0 @@\n-    }\n@@ -375,3 +338,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -381,3 +342,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -393,3 +352,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -400,3 +357,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -407,3 +362,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -419,3 +372,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n@@ -426,2 +377,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n+      log_if_needed(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n@@ -429,1 +379,0 @@\n-      }\n@@ -442,3 +391,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** vector stubs support is disabled\");\n-      }\n+      log_if_needed(\"  ** vector stubs support is disabled\");\n@@ -448,3 +395,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** no vector calling conventions supported\");\n-      }\n+      log_if_needed(\"  ** no vector calling conventions supported\");\n@@ -454,2 +399,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+      log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n@@ -457,1 +401,0 @@\n-      }\n@@ -466,2 +409,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d is_masked_op=%d\",\n+    log_if_needed(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d is_masked_op=%d\",\n@@ -470,1 +412,0 @@\n-    }\n@@ -477,2 +418,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=0 is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=0 is_masked_op=1\",\n@@ -480,1 +420,0 @@\n-    }\n@@ -489,2 +428,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v3=%s\",\n+        log_if_needed(\"  ** unbox failed v3=%s\",\n@@ -492,1 +430,0 @@\n-        }\n@@ -500,2 +437,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v2=%s\",\n+        log_if_needed(\"  ** unbox failed v2=%s\",\n@@ -503,1 +439,0 @@\n-        }\n@@ -511,2 +446,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v1=%s\",\n+        log_if_needed(\"  ** unbox failed v1=%s\",\n@@ -514,1 +448,0 @@\n-        }\n@@ -529,2 +462,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -532,1 +464,0 @@\n-      }\n@@ -542,2 +473,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n+      log_if_needed(\"  ** svml call failed for %s_%s_%d\",\n@@ -547,1 +477,0 @@\n-      }\n@@ -602,3 +531,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -711,3 +638,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -723,2 +648,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n@@ -726,1 +650,0 @@\n-    }\n@@ -735,2 +658,1 @@\n-    if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -738,1 +660,0 @@\n-    }\n@@ -777,3 +698,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -794,2 +713,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n@@ -797,1 +715,0 @@\n-    }\n@@ -841,2 +758,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n@@ -847,1 +763,0 @@\n-    }\n@@ -852,3 +767,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -859,3 +772,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -875,2 +786,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n+    log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n@@ -880,1 +790,0 @@\n-    }\n@@ -976,2 +885,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -982,1 +890,0 @@\n-    }\n@@ -986,3 +893,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -994,3 +899,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1004,2 +907,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ismask=no\",\n@@ -1008,1 +910,0 @@\n-    }\n@@ -1049,3 +950,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** non-primitive array element type\");\n-    }\n+    log_if_needed(\"  ** non-primitive array element type\");\n@@ -1056,2 +955,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n@@ -1060,1 +958,0 @@\n-    }\n@@ -1071,2 +968,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+        log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n@@ -1075,1 +971,0 @@\n-        }\n@@ -1083,2 +978,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+        log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n@@ -1087,1 +981,0 @@\n-        }\n@@ -1201,2 +1094,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -1208,1 +1100,0 @@\n-    }\n@@ -1212,3 +1103,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1219,3 +1108,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** mask klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1227,3 +1114,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1251,2 +1136,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n@@ -1255,1 +1139,0 @@\n-    }\n@@ -1277,2 +1160,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** missing constant: offsetInRange=%s\",\n+        log_if_needed(\"  ** missing constant: offsetInRange=%s\",\n@@ -1280,1 +1162,0 @@\n-        }\n@@ -1289,2 +1170,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: op=%s vlen=%d etype=%s mismatched_ms=%d\",\n+      log_if_needed(\"  ** not supported: op=%s vlen=%d etype=%s mismatched_ms=%d\",\n@@ -1293,1 +1173,0 @@\n-      }\n@@ -1304,2 +1183,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s mismatched_ms=%d\",\n+    log_if_needed(\"  ** not supported: op=loadMasked vlen=%d etype=%s mismatched_ms=%d\",\n@@ -1307,1 +1185,0 @@\n-    }\n@@ -1317,2 +1194,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s mismatched_ms=1\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s mismatched_ms=1\",\n@@ -1321,1 +1197,0 @@\n-      }\n@@ -1331,2 +1206,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s\",\n@@ -1335,1 +1209,0 @@\n-    }\n@@ -1355,2 +1228,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1359,1 +1231,0 @@\n-    }\n@@ -1368,2 +1239,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed vector=%s\",\n+      log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -1371,1 +1241,0 @@\n-      }\n@@ -1463,2 +1332,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n@@ -1469,1 +1337,0 @@\n-    }\n@@ -1474,3 +1341,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1482,3 +1347,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1495,3 +1358,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(1)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(1)->Opcode()]);\n@@ -1502,3 +1363,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1509,3 +1368,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -1518,2 +1375,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=1\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=1\",\n@@ -1522,1 +1378,0 @@\n-      }\n@@ -1528,2 +1383,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=0\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=0\",\n@@ -1532,1 +1386,0 @@\n-      }\n@@ -1540,2 +1393,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n@@ -1544,1 +1396,0 @@\n-      }\n@@ -1562,2 +1413,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n@@ -1566,1 +1416,0 @@\n-    }\n@@ -1598,2 +1447,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1602,1 +1450,0 @@\n-      }\n@@ -1672,2 +1519,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -1678,1 +1524,0 @@\n-    }\n@@ -1682,3 +1527,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1689,3 +1532,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1699,3 +1540,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -1706,3 +1545,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1713,3 +1550,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -1727,2 +1562,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=%d\",\n@@ -1730,1 +1564,0 @@\n-    }\n@@ -1737,2 +1570,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=1\",\n@@ -1740,1 +1572,0 @@\n-    }\n@@ -1759,2 +1590,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1762,1 +1592,0 @@\n-      }\n@@ -1825,2 +1654,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s\",\n@@ -1831,1 +1659,0 @@\n-    }\n@@ -1835,3 +1662,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1842,3 +1667,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1854,2 +1677,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=test\/%d vlen=%d etype=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=2 op=test\/%d vlen=%d etype=%s ismask=%d\",\n@@ -1858,1 +1680,0 @@\n-    }\n@@ -1903,2 +1724,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -1909,1 +1729,0 @@\n-    }\n@@ -1913,3 +1732,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1920,3 +1737,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1930,2 +1745,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=blend vlen=%d etype=%s ismask=useload\",\n+    log_if_needed(\"  ** not supported: arity=2 op=blend vlen=%d etype=%s ismask=useload\",\n@@ -1933,1 +1747,0 @@\n-    }\n@@ -1977,2 +1790,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -1984,1 +1796,0 @@\n-    }\n@@ -1988,3 +1799,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1995,3 +1804,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2007,2 +1814,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+      log_if_needed(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n@@ -2010,1 +1816,0 @@\n-      }\n@@ -2016,2 +1821,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+    log_if_needed(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n@@ -2019,1 +1823,0 @@\n-    }\n@@ -2035,2 +1838,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: mask = null arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: mask = null arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n@@ -2038,1 +1840,0 @@\n-    }\n@@ -2044,2 +1845,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n@@ -2047,1 +1847,0 @@\n-    }\n@@ -2100,2 +1899,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s\",\n@@ -2106,1 +1904,0 @@\n-    }\n@@ -2111,3 +1908,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2118,3 +1913,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2128,2 +1921,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n@@ -2131,1 +1923,0 @@\n-    }\n@@ -2141,3 +1932,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** mask_klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** mask_klass argument not initialized\");\n@@ -2152,2 +1941,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=2 op=shuffle\/rearrange vlen=%d etype=%s ismask=no\",\n+      log_if_needed(\"  ** not supported: arity=2 op=shuffle\/rearrange vlen=%d etype=%s ismask=no\",\n@@ -2155,1 +1943,0 @@\n-      }\n@@ -2178,2 +1965,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=3 op=shuffle\/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1\",\n+      log_if_needed(\"  ** not supported: arity=3 op=shuffle\/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1\",\n@@ -2181,1 +1967,0 @@\n-      }\n@@ -2283,2 +2068,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -2289,1 +2073,0 @@\n-    }\n@@ -2293,3 +2076,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2303,3 +2084,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -2310,3 +2089,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -2317,3 +2094,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -2326,3 +2101,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2340,3 +2113,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: op=%d bt=%s\", opr->get_con(), type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: op=%d bt=%s\", opr->get_con(), type2name(elem_bt));\n@@ -2348,3 +2119,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n@@ -2373,2 +2142,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s is_masked_op=%d\",\n+      log_if_needed(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s is_masked_op=%d\",\n@@ -2376,1 +2144,0 @@\n-      }\n@@ -2407,3 +2174,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n@@ -2459,2 +2224,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass_from=%s etype_from=%s vlen_from=%s vclass_to=%s etype_to=%s vlen_to=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass_from=%s etype_from=%s vlen_from=%s vclass_to=%s etype_to=%s vlen_to=%s\",\n@@ -2468,1 +2232,0 @@\n-    }\n@@ -2472,3 +2235,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2511,2 +2272,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%s\/1 vlen1=%d etype1=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%s\/1 vlen1=%d etype1=%s ismask=%d\",\n@@ -2515,1 +2275,0 @@\n-    }\n@@ -2524,2 +2283,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%s\/2 vlen2=%d etype2=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%s\/2 vlen2=%d etype2=%s ismask=%d\",\n@@ -2528,1 +2286,0 @@\n-    }\n@@ -2568,2 +2325,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s ismask=%d\",\n+      log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s ismask=%d\",\n@@ -2571,1 +2327,0 @@\n-      }\n@@ -2583,2 +2338,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/4 vlen1=%d etype2=%s ismask=%d\",\n+        log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/4 vlen1=%d etype2=%s ismask=%d\",\n@@ -2587,1 +2341,0 @@\n-        }\n@@ -2605,2 +2358,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=1 op=cast\/5 vlen2=%d etype1=%s ismask=%d\",\n+        log_if_needed(\"  ** not supported: arity=1 op=cast\/5 vlen2=%d etype1=%s ismask=%d\",\n@@ -2608,1 +2360,0 @@\n-        }\n@@ -2619,2 +2370,1 @@\n-          if (C->print_intrinsics()) {\n-            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+          log_if_needed(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n@@ -2622,1 +2372,0 @@\n-          }\n@@ -2660,2 +2409,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n@@ -2666,1 +2414,0 @@\n-    }\n@@ -2670,3 +2417,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2677,3 +2422,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2685,2 +2428,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=insert vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=1 op=insert vlen=%d etype=%s ismask=no\",\n@@ -2688,1 +2430,0 @@\n-    }\n@@ -2754,2 +2495,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2759,1 +2499,0 @@\n-    }\n@@ -2763,3 +2502,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2770,3 +2507,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2810,3 +2545,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected mask extraction because architecture does not support it\");\n-      }\n+      log_if_needed(\"  ** Rejected mask extraction because architecture does not support it\");\n@@ -2818,3 +2551,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n@@ -2826,2 +2557,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n+      log_if_needed(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n@@ -2829,1 +2559,0 @@\n-      }\n@@ -2885,2 +2614,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -2892,1 +2620,0 @@\n-    }\n@@ -2897,3 +2624,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2905,3 +2630,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2916,2 +2639,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+    log_if_needed(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n@@ -2919,1 +2641,0 @@\n-    }\n@@ -2930,2 +2651,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed vector=%s\",\n+      log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -2933,1 +2653,0 @@\n-      }\n@@ -2944,2 +2663,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -2947,1 +2665,0 @@\n-    }\n@@ -2978,2 +2695,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2983,1 +2699,0 @@\n-    }\n@@ -2988,3 +2703,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2996,3 +2709,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -3007,3 +2718,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3024,3 +2733,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3035,2 +2742,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+        log_if_needed(\"  ** Rejected op (%s) because architecture does not support it\",\n@@ -3038,1 +2744,0 @@\n-        }\n@@ -3048,2 +2753,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed vector=%s\",\n+    log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -3051,1 +2755,0 @@\n-    }\n@@ -3064,3 +2767,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3127,2 +2828,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n@@ -3132,1 +2832,0 @@\n-    }\n@@ -3137,3 +2836,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -3145,3 +2842,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -3160,3 +2855,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3171,2 +2864,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+        log_if_needed(\"  ** Rejected op (%s) because architecture does not support it\",\n@@ -3174,1 +2866,0 @@\n-        }\n@@ -3183,3 +2874,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** offset or limit argument is null\");\n-    }\n+    log_if_needed(\"  ** offset or limit argument is null\");\n@@ -3241,0 +2930,3 @@\n+\n+#undef non_product_log_if_needed\n+#undef log_if_needed\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":175,"deletions":483,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -932,1 +932,3 @@\n-    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n+    if (_thread->is_in_any_VTMS_transition()) {\n+      return; \/\/ no events should be posted if thread is in any VTMS transition\n+    }\n@@ -1369,2 +1371,2 @@\n-  if (thread->is_in_tmp_VTMS_transition()) {\n-    return; \/\/ skip ClassLoad events in tmp VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1372,1 +1374,0 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"class load events are not allowed in any VTMS transition\");\n@@ -1407,2 +1408,2 @@\n-  if (thread->is_in_tmp_VTMS_transition()) {\n-    return; \/\/ skip ClassPrepare events in tmp VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1410,1 +1411,0 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"class prepare events are not allowed in any VTMS transition\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -500,0 +500,1 @@\n+  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::undefined(), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1829,1 +1829,1 @@\n-      array->element(i)->free_monitors(thread);\n+      array->element(i)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,2 +434,0 @@\n-  _monitor_chunks(nullptr),\n-\n@@ -1054,7 +1052,1 @@\n-  if (Thread::is_lock_owned(adr)) return true;\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) return true;\n-  }\n-\n-  return false;\n+  return is_in_full_stack(adr);\n@@ -1071,16 +1063,0 @@\n-void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n-  chunk->set_next(monitor_chunks());\n-  set_monitor_chunks(chunk);\n-}\n-\n-void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n-  guarantee(monitor_chunks() != nullptr, \"must be non empty\");\n-  if (monitor_chunks() == chunk) {\n-    set_monitor_chunks(chunk->next());\n-  } else {\n-    MonitorChunk* prev = monitor_chunks();\n-    while (prev->next() != chunk) prev = prev->next();\n-    prev->set_next(chunk->next());\n-  }\n-}\n-\n@@ -1412,7 +1388,0 @@\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the monitor chunks\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n-      chunk->oops_do(f);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -197,4 +197,0 @@\n-  MonitorChunk* _monitor_chunks;              \/\/ Contains the off stack monitors\n-                                              \/\/ allocated during deoptimization\n-                                              \/\/ and by JNI_MonitorEnter\/Exit\n-\n@@ -683,1 +679,1 @@\n-  \/\/ Fast-locking support\n+  \/\/ Stack-locking support (not for LM_LIGHTWEIGHT)\n@@ -889,3 +885,0 @@\n- private:\n-  void set_monitor_chunks(MonitorChunk* monitor_chunks) { _monitor_chunks = monitor_chunks; }\n-\n@@ -893,3 +886,0 @@\n-  MonitorChunk* monitor_chunks() const           { return _monitor_chunks; }\n-  void add_monitor_chunk(MonitorChunk* chunk);\n-  void remove_monitor_chunk(MonitorChunk* chunk);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-  _next               = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  MonitorChunk*    _next;\n@@ -47,4 +46,0 @@\n-  \/\/ link operations\n-  MonitorChunk* next() const                { return _next; }\n-  void set_next(MonitorChunk* next)         { _next = next; }\n-\n@@ -57,1 +52,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-  ATTRIBUTE_NORETURN static void infinite_sleep();\n+  [[noreturn]] static void infinite_sleep();\n@@ -633,1 +633,1 @@\n-  ATTRIBUTE_NORETURN static void exit(int num);\n+  [[noreturn]] static void exit(int num);\n@@ -637,1 +637,1 @@\n-  ATTRIBUTE_NORETURN static void _exit(int num);\n+  [[noreturn]] static void _exit(int num);\n@@ -644,2 +644,2 @@\n-  ATTRIBUTE_NORETURN static void abort(bool dump_core, void *siginfo, const void *context);\n-  ATTRIBUTE_NORETURN static void abort(bool dump_core = true);\n+  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n+  [[noreturn]] static void abort(bool dump_core = true);\n@@ -652,1 +652,1 @@\n-  ATTRIBUTE_NORETURN static void die();\n+  [[noreturn]] static void die();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1101,1 +1101,3 @@\n-    } else if (LockingMode == LM_LEGACY && mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    } else if (LockingMode == LM_LEGACY && mark.has_locker()\n+               && current->is_Java_thread()\n+               && JavaThread::cast(current)->is_lock_owned((address)mark.locker())) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -106,1 +107,4 @@\n-  _hashStateX = os::random();\n+  \/\/ If we are dumping, keep ihashes constant. Note that during dumping we only\n+  \/\/ ever run one java thread, and no other thread should generate ihashes either,\n+  \/\/ so using a constant seed should work fine.\n+  _hashStateX = CDSConfig::is_dumping_static_archive() ? 0x12345678 : os::random();\n@@ -530,10 +534,0 @@\n-\/\/ We had to move these methods here, because vm threads get into ObjectSynchronizer::enter\n-\/\/ However, there is a note in JavaThread::is_lock_owned() about the VM threads not being\n-\/\/ used for compilation in the future. If that change is made, the need for these methods\n-\/\/ should be revisited, and they should be removed if possible.\n-\n-bool Thread::is_lock_owned(address adr) const {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n-  return is_in_full_stack(adr);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -478,3 +478,0 @@\n-  \/\/ Used by fast lock support\n-  virtual bool is_lock_owned(address adr) const;\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -51,1 +52,1 @@\n-void vframeArrayElement::free_monitors(JavaThread* jt) {\n+void vframeArrayElement::free_monitors() {\n@@ -55,1 +56,0 @@\n-     jt->remove_monitor_chunk(chunk);\n@@ -75,1 +75,1 @@\n-    Thread* current_thread = Thread::current();\n+    JavaThread* current_thread = JavaThread::current();\n@@ -88,1 +88,0 @@\n-      vf->thread()->add_monitor_chunk(_monitors);\n@@ -98,1 +97,2 @@\n-          assert(monitor->owner() == nullptr || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n+          assert(monitor->owner() != nullptr, \"monitor owner must not be null\");\n+          assert(!monitor->owner()->is_unlocked(), \"monitor must be locked\");\n@@ -100,0 +100,3 @@\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, before move_to\");\n+\n@@ -101,0 +104,3 @@\n+\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, after move_to\");\n@@ -311,0 +317,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, before move_to\");\n@@ -312,0 +320,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, after move_to\");\n@@ -652,1 +662,0 @@\n-  JavaThread* jt = JavaThread::current();\n@@ -654,1 +663,1 @@\n-     element(index)->free_monitors(jt);\n+     element(index)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  void free_monitors(JavaThread* jt);\n+  void free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/mallocLimit.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/mallocLimit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n-#define SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n-\n-\/\/ Provide a (temporary) macro for the [[noreturn]] attribute.\n-\/\/\n-\/\/ Unfortunately, some older (though still in use) compilers have bugs when\n-\/\/ using [[noreturn]].  For them we use an empty definition for the attribute.\n-\/\/\n-\/\/ Note: This can't be placed in globalDefinitions_xxx.hpp because the\n-\/\/ attribute is used in debug.hpp, which can't include globalDefinitions.hpp.\n-\n-\/\/ clang 12 (and possibly prior) crashes during build if we use [[noreturn]]\n-\/\/ for assertion failure reporting functions.  The problem seems to be fixed\n-\/\/ in clang 13.\n-#ifdef __clang__\n-#if __clang_major__ < 13\n-#define ATTRIBUTE_NORETURN\n-#endif\n-#endif\n-\n-\/\/ All other platforms can use [[noreturn]].\n-#ifndef ATTRIBUTE_NORETURN\n-#define ATTRIBUTE_NORETURN [[noreturn]]\n-#endif\n-\n-#endif \/\/ SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n","filename":"src\/hotspot\/share\/utilities\/attributeNoreturn.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  ChunkedList<T, F>() : _top(_values), _next_used(nullptr), _next_free(nullptr) {}\n+  ChunkedList() : _top(_values), _next_used(nullptr), _next_free(nullptr) {}\n","filename":"src\/hotspot\/share\/utilities\/chunkedList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/attributeNoreturn.hpp\"\n@@ -257,1 +256,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -260,1 +259,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -265,1 +264,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -269,1 +268,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -273,1 +272,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -278,3 +277,3 @@\n-ATTRIBUTE_NORETURN void report_should_not_call(const char* file, int line);\n-ATTRIBUTE_NORETURN void report_should_not_reach_here(const char* file, int line);\n-ATTRIBUTE_NORETURN void report_unimplemented(const char* file, int line);\n+[[noreturn]] void report_should_not_call(const char* file, int line);\n+[[noreturn]] void report_should_not_reach_here(const char* file, int line);\n+[[noreturn]] void report_unimplemented(const char* file, int line);\n@@ -282,1 +281,1 @@\n-\/\/ NOT ATTRIBUTE_NORETURN\n+\/\/ NOT [[noreturn]]\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  EventLogBase<T>(const char* name, const char* handle, int length = LogEventsBufferEntries):\n+  EventLogBase(const char* name, const char* handle, int length = LogEventsBufferEntries):\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/attributeNoreturn.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/xmlstream.hpp\"\n+\n+#ifndef ASSERT\n+#define COV(casen) {}\n+#else \/\/ASSERT\n+\/\/ Support for coverage testing.  Used by the gtest.\n+\/* $ sed < istream.cpp '\/^.* COV(\\([A-Z][^)]*\\)).*$\/!d;s\/\/COV_FN(\\1)\/' |\n+     tr '\\12' ' ' | fold -sw72 | sed 's| $||;s|.*|  & \\\\|'\n+  *\/\n+#define DO_COV_CASES(COV_FN) \\\n+  COV_FN(NXT_L) COV_FN(NXT_N) COV_FN(FIB_P) COV_FN(FIB_E) COV_FN(FIB_N) \\\n+  COV_FN(FIB_L) COV_FN(PFB_C) COV_FN(PFB_P) COV_FN(PFB_A) \\\n+  COV_FN(PFB_G) COV_FN(PFB_H) COV_FN(SBC_C) COV_FN(SBC_B) COV_FN(SBC_N) \\\n+  COV_FN(SBC_L) COV_FN(EXB_R) COV_FN(EXB_A)\n+  \/**\/\n+#define COV_COUNT(casename) coverage_case_##casename\n+#define DECLARE_COV_CASE(casename) static int COV_COUNT(casename);\n+DO_COV_CASES(DECLARE_COV_CASE)\n+#undef DECLARE_COV_CASE\n+\n+static int current_coverage_mode = 0;\n+#define COV(casename) {                                 \\\n+    if (current_coverage_mode != 0) {                   \\\n+      COV_COUNT(casename)++;                            \\\n+    }                                                  }\n+#endif \/\/ASSERT\n+\n+bool inputStream::next() {\n+  \/\/ We have to look at the current line first, just in case nobody\n+  \/\/ actually called current_line() or done().\n+  preload();\n+  if (definitely_done()) {\n+    return false;         \/\/ OK to call this->next() after done is true\n+  }\n+  \/\/ current line is at buffer[beg..end]; now skip past its '\\0'\n+  assert(have_current_line(), \"\");\n+\n+  set_buffer_content(_next, _content_end);\n+  if (!need_to_read()) {  \/\/ any next line was already in the buffer\n+    COV(NXT_L);\n+    assert(have_current_line(), \"\");\n+    return true;\n+  } else {                \/\/ go back to the source for more\n+    COV(NXT_N);\n+    return fill_buffer();\n+  }\n+}\n+\n+void inputStream::set_done() {\n+  size_t end = _beg = _end = _content_end;\n+  _next = end + NEXT_PHANTOM;\n+  _line_ending = 0;\n+  assert(definitely_done(), \"\");\n+}\n+\n+void inputStream::set_error(bool error_condition) {\n+  if (error_condition) {\n+    set_done();\n+    _input_state = IState::ERR_STATE;\n+    assert(error(), \"\");\n+  } else if (error()) {\n+    _input_state = definitely_done() ? IState::EOF_STATE : IState::NTR_STATE;\n+  }\n+}\n+\n+void inputStream::clear_buffer() {\n+  _content_end = _beg = _end = _next = 0;\n+  _line_ending = 0;\n+}\n+\n+const char* inputStream::next_content(size_t& next_content_length) const {\n+  assert(is_sane(), \"\");\n+  size_t len = buffered_content_length(false);\n+  next_content_length = len;\n+  return len == 0 ? \"\" : &_buffer[_next];\n+}\n+\n+void inputStream::set_input(inputStream::Input* input) {\n+  clear_buffer();\n+  _input = input;\n+  _input_state = IState::NTR_STATE;\n+}\n+\n+bool inputStream::fill_buffer() {\n+  size_t fill_offset, fill_length;\n+  assert(!definitely_done(), \"\");  \/\/ caller responsibility\n+  while (need_to_read()) {\n+    prepare_to_fill_buffer(fill_offset, fill_length);\n+    if (error())  return false;\n+    assert(fill_length > 0, \"\");\n+    assert(fill_offset < _buffer_size, \"\");\n+    assert(fill_offset + fill_length <= _buffer_size, \"\");\n+    size_t nr = 0;\n+    if (_input != nullptr && _input_state == IState::NTR_STATE) {\n+      nr = _input->read(&_buffer[fill_offset], fill_length);\n+      if (nr == 0)  _input_state = IState::EOF_STATE;  \/\/ do not get EOF twice\n+    }\n+    bool last_partial = false;\n+    if (nr > 0) {\n+      fill_offset += nr;\n+    } else if (_beg == _end) {  \/\/ no partial line, so end it now\n+      \/\/ we hit the end of the file (or there was never anything there)\n+      COV(FIB_P);\n+      assert(!definitely_done(), \"\");\n+      set_done();\n+      assert(definitely_done(), \"\");\n+      return false;\n+    } else {\n+      \/\/ pretend to read a newline, to complete the last partial line\n+      COV(FIB_E);\n+      _buffer[fill_offset++] = '\\n';  \/\/ insert phantom newline\n+      last_partial = true;\n+    }\n+    set_buffer_content(_beg, fill_offset);\n+    assert(!definitely_done(), \"\");\n+    if (need_to_read()) { COV(FIB_N); }\n+    else                { COV(FIB_L); }\n+    if (last_partial) {\n+      assert(have_current_line(), \"\");\n+      _line_ending = 0;\n+      _content_end -= 1;  \/\/ reverse insertion of phantom newline\n+      assert(_next == _content_end + NEXT_PHANTOM, \"\");\n+      assert(have_current_line(), \"\");\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Find some space in the buffer for reading.  If there is already a\n+\/\/ partial line in the buffer, new space must follow it immediately.\n+\/\/ The partial line is between _beg and _end, and no other parts of\n+\/\/ the buffer are in use.\n+void inputStream::prepare_to_fill_buffer(size_t& fill_offset,\n+                                         size_t& fill_length) {\n+  assert(need_to_read(), \"\");  \/\/ _next pointer out of the way\n+  size_t end = _content_end;\n+  if (_beg == end) { \/\/ if no partial line present...\n+    COV(PFB_C);\n+    clear_buffer();\n+    fill_offset = 0;\n+    fill_length = _buffer_size;\n+    return;   \/\/ use the whole buffer\n+  }\n+  \/\/ at this point we have a pending line that needs more input\n+  if (_beg > 0 && (_input != nullptr || end == _buffer_size)) {\n+    COV(PFB_P);\n+    \/\/ compact the buffer by overwriting characters from previous lines\n+    size_t shift_left = _beg;\n+    ::memmove(_buffer, _buffer + shift_left, _content_end - _beg);\n+    _beg -= shift_left;\n+    _end -= shift_left;\n+    _next -= shift_left;\n+    _content_end -= shift_left;\n+    end = _content_end;\n+  }\n+  if (end < _buffer_size) {\n+    COV(PFB_A);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the whole buffer except partial line at the beginning\n+  }\n+  \/\/ the whole buffer contains a partial line, which means we must expand\n+  COV(PFB_G);\n+  size_t new_size = (_buffer_size < BIG_SIZE ? BIG_SIZE\n+                     : _buffer_size + _buffer_size \/ 2);\n+  assert(new_size > _buffer_size, \"\");\n+  if (expand_buffer(new_size)) {\n+    COV(PFB_H);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the expanded buffer, except the partial line\n+  }\n+  \/\/ no recovery from failed allocation; just set the error state and bail\n+  set_error();\n+}\n+\n+\/\/ The only buffer content is between the given offsets.\n+\/\/ Set _beg, _end, _next, and _content_end appropriately.\n+void inputStream::set_buffer_content(size_t content_start,\n+                                     size_t content_end) {\n+  assert(content_end <= _buffer_size, \"\");\n+  assert(content_start <= content_end + NEXT_PHANTOM, \"\");\n+  if (content_start >= content_end) {   \/\/ empty content; clear buffer\n+    COV(SBC_C);\n+    clear_buffer();\n+    return;\n+  }\n+  COV(SBC_B);\n+  size_t content_len = content_end - content_start;\n+  _beg = content_start;\n+  _content_end = content_end;\n+\n+  \/\/ this is where we scan for newlines\n+  char* nl = (char*) memchr(&_buffer[content_start], '\\n', content_len);\n+  if (nl == nullptr) {\n+    COV(SBC_N);\n+    _next = _end = content_end;\n+    _line_ending = 0;\n+    assert(need_to_read(), \"\");\n+  } else {\n+    COV(SBC_L);\n+    *nl = '\\0';  \/\/ so that this->current_line() will work\n+    ++_line_count;\n+    size_t end = nl - &_buffer[0];\n+    _next = end + 1;\n+    assert(_next != _content_end + NEXT_PHANTOM, \"\");\n+    if (end > content_start && nl[-1] == '\\r') { \/\/ yuck\n+      \/\/ again, for this->current_line(), remove '\\r' before '\\n'\n+      nl[-1] = '\\0';\n+      --end;\n+      \/\/ Note: we could treat '\\r' alone as a line ending on some\n+      \/\/ platforms, but that is way too much work.  Newline '\\n' is\n+      \/\/ supported everywhere, and some tools insist on accompanying\n+      \/\/ it with return as well, so we remove that.  But return '\\r'\n+      \/\/ by itself is an obsolete format, and also inconsistent with\n+      \/\/ outputStream, which standarizes on '\\n' and never emits '\\r'.\n+      \/\/ Postel's law suggests that we write '\\n' only and grudgingly\n+      \/\/ accept '\\r' before '\\n'.\n+    }\n+    _end = end;  \/\/ now this->current_line() points to buf[beg..end]\n+    _line_ending = (int)(_next - end);\n+    assert(have_current_line(), \"\");\n+    assert(current_line() == &_buffer[_beg], \"\");\n+    assert(current_line_length() == _end - _beg, \"\");\n+  }\n+}\n+\n+\/\/ Return true iff we expanded the buffer to the given length.\n+bool inputStream::expand_buffer(size_t new_length) {\n+  assert(new_length > _buffer_size, \"\");\n+  char* new_buf = nullptr;\n+  assert(new_length > sizeof(_small_buffer), \"\");\n+  if (_buffer == &_small_buffer[0]) {\n+    \/\/ fresh alloc from c-heap\n+    COV(EXB_A);\n+    new_buf = NEW_C_HEAP_ARRAY(char, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+    if (_content_end > 0) {\n+      assert(_content_end <= _buffer_size, \"\");\n+      ::memcpy(new_buf, _buffer, _content_end);  \/\/ copy only the active content\n+    }\n+  } else {\n+    \/\/ realloc\n+    COV(EXB_R);\n+    new_buf = REALLOC_C_HEAP_ARRAY(char, _buffer, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+  }\n+\n+  if (new_buf == nullptr) {\n+    return false;   \/\/ do not further update _buffer etc.\n+  }\n+  _buffer = new_buf;\n+  _buffer_size = new_length;\n+  return true;\n+}\n+\n+inputStream::~inputStream() {\n+  if (has_c_heap_buffer()) {\n+    FreeHeap(_buffer);\n+    DEBUG_ONLY(_buffer = (char*)((uintptr_t)0xdeadbeef)); \/\/ sanity\n+  }\n+}\n+\n+#ifdef ASSERT\n+void inputStream::dump(const char* what) {\n+  int diff = (int)(_end - _beg);\n+  if (!_buffer || _beg > _buffer_size || _end > _buffer_size)\n+    diff = 0;\n+\n+  bool ntr = (_next == _end),\n+       hcl = (_beg < _content_end && _end < _next),\n+       ddn = (_beg == _content_end && _next > _content_end);\n+  tty->print_cr(\"%s%sistream %s%s%s%s%s [%d<%.*s>%d\/%d..%d] LE=%d,\"\n+                \" B=%llx%s[%d], LN=%d, CH=%d\",\n+                what ? what : \"\", what ? \": \" : \"\",\n+                _buffer == nullptr ? \"U\" : \"\",\n+                ntr ? \"R\" : \"\",\n+                hcl ? \"L\" : \"\",\n+                ddn ? \"D\" : \"\",\n+                (_next < _content_end ? \"\" :\n+                 _next == _content_end ? \"N\" : \"P\"),\n+                (int)_beg,\n+                diff < 0 ? 0 : diff > 10 ? 10 : diff,\n+                _buffer ? &_buffer[_beg] : \"\",\n+                (int)_end, (int)_next, (int)_content_end,\n+                _line_ending,\n+                (unsigned long long)(intptr_t)_buffer,\n+                _buffer == _small_buffer ? \"(SB)\" : \"\",\n+                (int)_buffer_size,\n+                (int)_line_count,\n+                has_c_heap_buffer());\n+  assert(is_sane(), \"\");\n+}\n+#endif\n+\n+#ifdef ASSERT\n+\/\/ More support for coverage testing.\n+int inputStream::coverage_mode(int start,\n+                               int& cases, int& total, int& zeroes) {\n+  int old_mode = current_coverage_mode;\n+  current_coverage_mode = start;\n+  int num_cases = 0, zero_count = 0, case_count = 0;\n+#define COUNT_COV_CASE(casename) {              \\\n+    int tem = COV_COUNT(casename);              \\\n+    case_count += tem;                          \\\n+    if (tem == 0)  ++zero_count;                \\\n+    num_cases++;                                \\\n+  }\n+  DO_COV_CASES(COUNT_COV_CASE)\n+#undef COUNT_COV_CASE\n+  if (start < 0) {\n+    tty->print(\"istream coverage:\");\n+    #define PRINT_COV_CASE(casename) \\\n+      tty->print(\" %s:%d\", #casename, COV_COUNT(casename));\n+    DO_COV_CASES(PRINT_COV_CASE)\n+    tty->cr();\n+    #undef PRINT_COV_CASE\n+    if (zero_count != 0) {\n+      case_count = -case_count;\n+      #define ZERO_COV_CASE(casename)                  \\\n+        if (COV_COUNT(casename) == 0)                  \\\n+          tty->print_cr(\"%s: no coverage for %s\",      \\\n+                        __FILE__, #casename);          \\\n+      DO_COV_CASES(ZERO_COV_CASE)\n+      #undef ZERO_COV_CASE\n+    }\n+  }\n+  if (start >= 2 || start < 0) {\n+    #define CLEAR_COV_CASE(casename) \\\n+       COV_COUNT(casename) = 0;\n+    DO_COV_CASES(CLEAR_COV_CASE)\n+    #undef CLEAR_COV_CASE\n+  }\n+  cases  = num_cases;\n+  total  = case_count;\n+  zeroes = zero_count;\n+  return old_mode;\n+}\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/utilities\/istream.cpp","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ISTREAM_HPP\n+#define SHARE_UTILITIES_ISTREAM_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Input streams for reading line-oriented textual data. These streams\n+\/\/ treat newline '\\n' very differently from all other bytes.  Carriage\n+\/\/ return '\\r' is just another bit of whitespace, although it is\n+\/\/ removed just before newline.\n+\/\/\n+\/\/ Null '\\0' is just a data byte, although it also terminates C\n+\/\/ strings; the `current_line` function adds a null after removing any\n+\/\/ line terminator but does not specially process any nulls embedded\n+\/\/ in the line.\n+\/\/\n+\/\/ There are sizing access functions which allow lines to contain\n+\/\/ null, but the simpler function assumes null termination, and thus\n+\/\/ lines containing null will \"look\" shorter when viewed as C strings.\n+\/\/ Use the sizing access functions if you care about this.\n+\/\/\n+\/\/ Formatting guidelines:\n+\/\/\n+\/\/ Configuration data should be line-oriented.  It should be readable\n+\/\/ by humans (though perhaps with difficulty).  It should be easily\n+\/\/ processed by text editors and by widely available text processing\n+\/\/ tools such as grep, sed, and awk.\n+\/\/\n+\/\/ Configuration data should not require \"compilers\" to generate, if\n+\/\/ possible.  It should be editable by hand, if possible.  In cases\n+\/\/ where binary data is strongly required, pick a binary format\n+\/\/ already native to Hotspot, such as classfile, jar, or jmod.\n+\/\/\n+\/\/ Each line should be separately parseable; the parsing can be ad\n+\/\/ hoc.  For constructs inherently larger than single lines (such as\n+\/\/ complex method configuration information), try to use a structuring\n+\/\/ principle that allows \"leaf\" data to be line-oriented, and delimits\n+\/\/ that data with markup lines of some sort.  Try to pick a\n+\/\/ line-friendly version of a standard format like XML or Markdown.\n+\/\/ JSON is somewhat problematic because there is no line-friendly leaf\n+\/\/ syntax: everything at the leaves must be a quoted string in JSON.\n+\/\/\n+\/\/ Use simple parsing via scanf-like formats for simple applications.\n+\/\/ But, keep in mind that these formats may lose data when applied to\n+\/\/ unusual strings, such as class names that contain spaces, or method\n+\/\/ names that contain punctuation.  For more robust transmission of\n+\/\/ potentially unusual names, consider wrapping them in XML-flavored\n+\/\/ lines like <tag attr='pay load'\/>.\n+\/\/\n+\/\/ Note: Input streams are never MT-safe.\n+\n+class inputStream : public CHeapObjBase {\n+ public:\n+  class Input;\n+\n+ private:\n+  NONCOPYABLE(inputStream);\n+\n+  static constexpr size_t SMALL_SIZE =  240 DEBUG_ONLY(*0 + 10);\n+  static constexpr size_t BIG_SIZE   = 2048 DEBUG_ONLY(*0 + 20);\n+\n+ protected:\n+  \/\/ Values for _input_state, to distinguish some phases of history:\n+  \/\/ Do we need to read more input (NTR)?  Did we see EOF already?\n+  \/\/ Was there an error getting input or allocating buffer space?\n+  enum class IState : int { NTR_STATE, EOF_STATE, ERR_STATE };\n+\n+  \/\/ Named offset for _next relative to _content_end, of phantom '\\n'.\n+  static const int NEXT_PHANTOM = 1;\n+\n+  Input* _input;   \/\/ where the input comes from or else nullptr\n+  IState _input_state;  \/\/ one of {NTR,EOF,ERR}_STATE\n+  char   _line_ending;  \/\/ one of {0,1,2} for \"\", \"\\n\", \"\\r\\n\"\n+  char*  _buffer;       \/\/ scratch buffer holding at least the current line\n+  size_t _buffer_size;  \/\/ allocated size of buffer\n+  size_t _content_end;  \/\/ offset to end of valid contents of buffer\n+  size_t _beg;          \/\/ offset in buffer to start of current line\n+  size_t _end;          \/\/ offset to end of known current line (else content_end)\n+  size_t _next;         \/\/ offset to known start of next line (else =end)\n+  size_t _line_count;   \/\/ increasing non-resettable count of lines read\n+  char   _small_buffer[SMALL_SIZE];  \/\/ stack-allocated buffer for holding lines;\n+                                     \/\/ will switch to C_HEAP allocation when necessary.\n+\n+  bool has_c_heap_buffer() {\n+    return _buffer != &_small_buffer[0];\n+  }\n+\n+  \/\/ Buffer states\n+  \/\/\n+  \/\/ The current line (less any line ending) is always [beg..end).\n+  \/\/ It is always the case that 0 <= beg <= end <= con_end <= buffer_size.\n+  \/\/ When there is a current line buffered, end < next <= 1+con_end.\n+  \/\/ In that case, the value of next is end + max(1, strlen(lend)),\n+  \/\/ where lend is \"\\n\", \"\\r\\n\", or (for a last partial line) \"\".\n+  \/\/ But if next == end, we need to read more input, or observe an EOF.\n+  \/\/\n+  \/\/   beg ==end ==next ==  con_end => nothing buffered, we need to read\n+  \/\/   beg <=end < next <=  con_end => have current line, with terminator\n+  \/\/   beg < end < next ==1+con_end => have partial current line (saw EOF)\n+  \/\/   beg < end ==next ==  con_end => partial line, we need to read\n+  \/\/   beg ==end < next ==1+con_end => definitely done; no more I\/O\n+  \/\/\n+  \/\/ These states are in three mutually exclusive groups:\n+  \/\/   need_to_read()      <= nothing or partial line in buffer\n+  \/\/   have_current_line() <= beg\/end point to valid line (partial only if EOF)\n+  \/\/   definitely_done()   <= consumed all lines && (hit EOF || hit error)\n+  \/\/ These states are internal; the user can only look at next\/done\/error.\n+  \/\/\n+  \/\/ Relative to these states, everything already read from the input\n+  \/\/ before the first byte of the current line is logically present\n+  \/\/ (but not accessible) before _beg, while everything not yet read\n+  \/\/ from the input is after _content_end.  The difference between\n+  \/\/ these two pointers is constant, except when characters change\n+  \/\/ from being in the current line to being (logically) before it,\n+  \/\/ when next is called.\n+\n+  bool is_sane() const {\n+    assert(_buffer != nullptr, \"\");\n+    assert(_content_end <= _buffer_size, \"\");\n+    assert(_beg <= _end && _end <= _content_end, \"\");\n+    assert(_end <= _next && _next <= _content_end + NEXT_PHANTOM, \"\");\n+    assert(_buffer_size == 0 || _next <= _buffer_size, \"\");\n+    return true;\n+  }\n+\n+  bool need_to_read() const {\n+    assert(is_sane(), \"\");\n+    return _next == _end;\n+  }\n+  bool have_current_line() const {\n+    assert(is_sane(), \"\");\n+    \/\/ _beg < _content_end because there is an \\0 (was \\n) at _end,\n+    \/\/ or else it is a non-empty partial line and the \\0 is at\n+    \/\/ _content_end.  In either case, if _end == _next we are\n+    \/\/ still searching for more input.\n+    return (_beg < _content_end && _end < _next);\n+  }\n+  bool definitely_done() const {\n+    assert(is_sane(), \"\");\n+    \/\/ If _beg < _content_end we still have a line of some sort.\n+    \/\/ Otherwise, if _next > _content_end, we have seen EOF or error.\n+    return (_beg == _content_end && _next > _content_end);\n+  }\n+\n+  \/\/ Reset indexes within the buffer to point to no content.\n+  void clear_buffer();\n+\n+  \/\/ Reset indexes within the buffer to point to the given content.\n+  \/\/ This is where we scan for newlines as well.\n+  void set_buffer_content(size_t content_start, size_t content_end);\n+\n+  \/\/ Try to make the buffer bigger.  This may be necessary in order to\n+  \/\/ buffer a very long line.  Returns false if there was an\n+  \/\/ allocation failure.\n+  \/\/\n+  \/\/ On allocation failure, just make do with whatever buffer there\n+  \/\/ was to start with; the caller must check for this condition and\n+  \/\/ avoid buffering more data in the non-expanded buffer.  However,\n+  \/\/ the buffer will always be non-null, so at least one line can be\n+  \/\/ buffered, if it is of normal size.\n+  bool expand_buffer(size_t new_length);\n+\n+  \/\/ Make sure there is at least one line in the buffer, and set\n+  \/\/ _beg\/_end to indicate where it is.  Any content before _beg can\n+  \/\/ be overwritten to make more room in the buffer.  If there is no\n+  \/\/ more input, set the state up to indicate we are done.\n+  bool fill_buffer();\n+\n+  \/\/ Find some room in the buffer so we can call read on it.\n+  \/\/ This might call expand_buffer but will try not to.\n+  \/\/ The assumption is that read already buffers slow I\/O calls.\n+  \/\/ The purpose for the small buffer managed here is to store whole lines,\n+  \/\/ and perhaps edit them in-place.\n+  void prepare_to_fill_buffer(size_t& fill_offset, size_t& fill_length);\n+\n+  \/\/ Quick check for an initially incomplete buffer...\n+  void preload() const {\n+    if (need_to_read()) {\n+      const_cast<inputStream*>(this)->fill_buffer();\n+    }\n+  }\n+\n+  \/\/ How much content is buffered (if any) after the current line?\n+  size_t buffered_content_length(bool include_current) const {\n+    return (include_current       ? _content_end - _beg :\n+            _content_end >= _next ? _content_end - _next : 0);\n+  }\n+\n+  \/\/ Returns a pointer and count to characters buffered after the\n+  \/\/ current line, but not yet read from my input source.  Only useful\n+  \/\/ if you are trying to stack input streams on top of each other\n+  \/\/ somehow.  You can also ask the input source if it thinks it has\n+  \/\/ more bytes.\n+  const char* next_content(size_t& next_content_length) const;\n+\n+ public:\n+  \/\/ Create an empty input stream.\n+  \/\/ Call push_back_input or set_input to configure.\n+  inputStream() :\n+    _input(nullptr),\n+    _input_state(IState::NTR_STATE),\n+    _line_ending(0),\n+    _buffer(&_small_buffer[0]),\n+    _buffer_size(sizeof(_small_buffer)),\n+    _content_end(0),\n+    _beg(0),\n+    _end(0),\n+    _next(0),\n+    _line_count(0) {}\n+\n+  \/\/ Take input from the given source.  Buffer only a modest amount.\n+  inputStream(Input* input)\n+    : inputStream()\n+  {\n+    set_input(input);\n+  }\n+\n+  virtual ~inputStream();\n+\n+  \/\/ Discards any previous input and sets the given input source.\n+  void set_input(Input* input);\n+\n+  \/\/ Returns a pointer to a null terminated mutable copy of the current line.\n+  \/\/ Note that embedded nulls may make the line appear shorter than it really is.\n+  \/\/ This may trigger input activity if there is not enough data buffered.\n+  \/\/ If there are no more lines, return an empty line, statically allocated.\n+  char* current_line() const {\n+    preload();\n+    if (definitely_done())\n+      return (char*)\"\";\n+    return &_buffer[_beg];\n+  }\n+\n+  \/\/ Return the size of the current line, exclusive of any line terminator.\n+  \/\/ If no lines have been read yet, or there are none remaining, return zero.\n+  size_t current_line_length() const {\n+    preload();\n+    return _end - _beg;\n+  }\n+\n+  \/\/ Reports my current input source, if any, else a null pointer.\n+  Input* input() const { return _input; }\n+\n+  \/\/ Discards the current line, gets ready to report the next line.\n+  \/\/ Returns true if there is one, which is always the opposite of done().\n+  \/\/ Fetches input if necessary.\n+  bool next();\n+\n+  \/\/ Reports if there are no more lines.  Fetches input if necessary.\n+  bool done() const  {\n+    preload();\n+    return definitely_done();\n+  }\n+\n+  \/\/ Discard pending input and do not read any more.\n+  \/\/ Takes no action if already done, whether in an error state or not.\n+  void set_done();\n+\n+  \/\/ Reports if this stream has had an error was reported on it.\n+  bool error() const {\n+    return _input_state == IState::ERR_STATE;\n+  }\n+\n+  \/\/ Set this stream done with an error, if the argument is true.\n+  \/\/ If it is false but there is an error condition, clear the error.\n+  \/\/ Otherwise do nothing.\n+  void set_error(bool error_condition = true);\n+\n+  \/\/ lineno is the 1-based ordinal of the current line; it starts at one\n+  size_t lineno() const         { preload(); return _line_count; }\n+\n+  \/\/ Copy the current line to the given output stream.\n+  void print_on(outputStream* out);\n+\n+  \/\/ Copy the current line to the given output stream, and also call cr().\n+  void print_cr_on(outputStream* out) {\n+    print_on(out); out->cr();\n+  }\n+\n+#ifdef ASSERT\n+  void dump(const char* what = nullptr);\n+  static int coverage_mode(int mode, int& cases, int& total, int& zeroes);\n+#else\n+  void dump(const char* what = nullptr) { }\n+#endif\n+\n+\n+  \/\/ Block-oriented input, which treats all bytes equally.\n+  class Input : public CHeapObjBase {\n+  public:\n+    \/\/ Read some characters from an external source into the line buffer.\n+    \/\/ If there are no more, return zero, otherwise return non-zero.\n+    \/\/ It must be OK to call read even after it returns zero.\n+    virtual size_t read(char* buf, size_t size) = 0;\n+    \/\/ Example: read(b,s) { return fread(b, 1, s, _my_fp); }\n+    \/\/ Example: read(b,s) { return 0; } \/\/ never more than the initial buffer\n+  };\n+};\n+\n+\/\/ for reading lines from files\n+class FileInput : public inputStream::Input {\n+  NONCOPYABLE(FileInput);\n+\n+ protected:\n+  fileStream& _fs;\n+  fileStream _private_fs;\n+\n+  \/\/ it does not seem likely there are such file streams around\n+  FileInput(fileStream& fs)\n+    : _fs(fs)\n+  { }\n+\n+ public:\n+  \/\/ just forward all the constructor arguments to the wrapped line-input class\n+  template<typename... Arg>\n+  FileInput(Arg... arg)\n+    : _fs(_private_fs), _private_fs(arg...)\n+  { }\n+\n+  FileInput(const char* file_name)\n+    : FileInput(file_name, \"rt\")\n+  { }\n+\n+  bool is_open() const { return _fs.is_open(); }\n+\n+ protected:\n+  size_t read(char* buf, size_t size) override {\n+    return _fs.read(buf, size);\n+  }\n+};\n+\n+class MemoryInput : public inputStream::Input {\n+  const void* _base;\n+  const size_t _limit;\n+  size_t      _offset;\n+\n+ public:\n+  MemoryInput(const void* base, size_t size,\n+              size_t offset = 0)\n+    : _base(base), _limit(size), _offset(offset) {}\n+\n+  MemoryInput(const char* start)\n+    : MemoryInput(start, 0, strlen(start))\n+  { }\n+\n+ protected:\n+  size_t read(char* buf, size_t size) override {\n+    size_t nr = size;\n+    if (nr > _limit - _offset) {\n+      nr = _limit - _offset;\n+    }\n+    if (nr > 0) {\n+      ::memcpy(buf, (char*)_base + _offset, nr);\n+      _offset += nr;\n+    }\n+    return nr;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ISTREAM_HPP\n","filename":"src\/hotspot\/share\/utilities\/istream.hpp","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -85,1 +85,1 @@\n-  NONCOPYABLE(LinkedList<E>);\n+  NONCOPYABLE(LinkedList);\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-  copy[_written] = 0;  \/\/ terminating null\n+  copy[_written] = '\\0';  \/\/ terminating null\n@@ -593,13 +593,0 @@\n-char* fileStream::readln(char *data, int count ) {\n-  char * ret = nullptr;\n-  if (_file != nullptr) {\n-    ret = ::fgets(data, count, _file);\n-    \/\/ Get rid of annoying \\n char only if it is present.\n-    size_t len = ::strlen(data);\n-    if (len > 0 && data[len - 1] == '\\n') {\n-      data[len - 1] = '\\0';\n-    }\n-  }\n-  return ret;\n-}\n-\n@@ -608,2 +595,2 @@\n-    if (_need_close) fclose(_file);\n-    _file      = nullptr;\n+    close();\n+    _file = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,3 +245,13 @@\n-  size_t read(void *data, size_t size, size_t count) { return _file != nullptr ? ::fread(data, size, count, _file) : 0; }\n-  char* readln(char *data, int count);\n-  int eof() { return _file != nullptr ? feof(_file) : -1; }\n+  \/\/ unlike other classes in this file, fileStream can perform input as well as output\n+  size_t read(void* data, size_t size) {\n+    if (_file == nullptr)  return 0;\n+    return ::fread(data, 1, size, _file);\n+  }\n+  size_t read(void *data, size_t size, size_t count) {\n+    return read(data, size * count);\n+  }\n+  void close() {\n+    if (_file == nullptr || !_need_close)  return;\n+    fclose(_file);\n+    _need_close = false;\n+  }\n@@ -249,1 +259,0 @@\n-  void rewind() { if (_file != nullptr) ::rewind(_file); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -172,1 +172,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -177,1 +177,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -183,1 +183,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -187,1 +187,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -192,1 +192,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -195,2 +195,3 @@\n-    \/\/ Holder for the initial value of `in`, set within `initPhase1()`.\n-    private static InputStream initialIn;\n+    \/\/ Initial values of System.in and System.err, set in initPhase1().\n+    private static @Stable InputStream initialIn;\n+    private static @Stable PrintStream initialErr;\n@@ -359,3 +360,0 @@\n-    \/\/ Remember initial System.err. setSecurityManager() warning goes here\n-    private static volatile @Stable PrintStream initialErrStream;\n-\n@@ -421,1 +419,1 @@\n-                initialErrStream.printf(\"\"\"\n+                initialErr.printf(\"\"\"\n@@ -2204,1 +2202,2 @@\n-        setErr0(newPrintStream(fdErr, props.getProperty(\"stderr.encoding\")));\n+        initialErr = newPrintStream(fdErr, props.getProperty(\"stderr.encoding\"));\n+        setErr0(initialErr);\n@@ -2410,2 +2409,0 @@\n-        initialErrStream = System.err;\n-\n@@ -2602,0 +2599,4 @@\n+            public PrintStream initialSystemErr() {\n+                return initialErr;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    private final int newarraycode;\n+    private final int newarrayCode;\n@@ -69,3 +69,6 @@\n-    \/** {@return the code used by the {@code newarray} opcode corresponding to this type} *\/\n-    public int newarraycode() {\n-        return newarraycode;\n+    \/**\n+     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * @since 23\n+     *\/\n+    public int newarrayCode() {\n+        return newarrayCode;\n@@ -97,1 +100,1 @@\n-    TypeKind(String name, String descriptor, int newarraycode) {\n+    TypeKind(String name, String descriptor, int newarrayCode) {\n@@ -100,1 +103,1 @@\n-        this.newarraycode = newarraycode;\n+        this.newarrayCode = newarrayCode;\n@@ -106,1 +109,3 @@\n-     * @param newarraycode the operand of the {@code newarray} instruction\n+     * @param newarrayCode the operand of the {@code newarray} instruction\n+     * @throws IllegalArgumentException if the code is invalid\n+     * @since 23\n@@ -108,2 +113,2 @@\n-    public static TypeKind fromNewArrayCode(int newarraycode) {\n-        return switch (newarraycode) {\n+    public static TypeKind fromNewarrayCode(int newarrayCode) {\n+        return switch (newarrayCode) {\n@@ -118,1 +123,1 @@\n-            default -> throw new IllegalArgumentException(\"Bad new array code: \" + newarraycode);\n+            default -> throw new IllegalArgumentException(\"Bad newarray code: \" + newarrayCode);\n@@ -125,0 +130,1 @@\n+     * @throws IllegalArgumentException only if the descriptor is not valid\n@@ -127,0 +133,3 @@\n+        if (s.isEmpty()) { \/\/ implicit null check\n+            throw new IllegalArgumentException(\"Empty descriptor\");\n+        }\n@@ -147,1 +156,3 @@\n-        return fromDescriptor(descriptor.descriptorString());\n+        return descriptor.isPrimitive() \/\/ implicit null check\n+                ? fromDescriptor(descriptor.descriptorString())\n+                : TypeKind.ReferenceType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        if (typeKind.newarraycode() < 0) {\n+        if (typeKind.newarrayCode() < 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -76,0 +75,1 @@\n+        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -90,0 +90,6 @@\n+        HolderClassBuilder addLinkerType(String methodType) {\n+            validateMethodType(methodType);\n+            linkerTypes.add(methodType);\n+            return this;\n+        }\n+\n@@ -133,1 +139,1 @@\n-            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ The linker type to ask for is retrieved by removing the first\n@@ -135,0 +141,16 @@\n+            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n+            index = 0;\n+            for (String linkerType : linkerTypes) {\n+                MethodType mt = asMethodType(linkerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (!checkLinkerTypeParams(mt)) {\n+                    throw new RuntimeException(\n+                            \"Linker type parameter must start and end with Object: \" + linkerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ argument, which needs to be of Object.class\n@@ -139,1 +161,0 @@\n-                final int lastParam = mt.parameterCount() - 1;\n@@ -142,1 +163,1 @@\n-                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n@@ -144,2 +165,1 @@\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n@@ -174,1 +194,1 @@\n-                            invokerMethodTypes, callSiteMethodTypes));\n+                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n@@ -210,0 +230,6 @@\n+            return (mt.parameterCount() >= 2 &&\n+                    mt.parameterType(0) == Object.class &&\n+                    mt.parameterType(1) == Object.class);\n+        }\n+\n+        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -323,0 +349,3 @@\n+                                } else if (parts[2].endsWith(\"nvoker\")) {\n+                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n+                                    builder.addInvokerType(methodType);\n@@ -324,8 +353,1 @@\n-                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n-                                    \/\/ Work around JDK-8327499\n-                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n-                                        builder.addInvokerType(methodType);\n-                                    } else {\n-                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n-                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n-                                    }\n+                                    builder.addLinkerType(methodType);\n@@ -468,2 +490,2 @@\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n+     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n@@ -472,1 +494,2 @@\n-            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n+            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n+            MethodType[] callSiteMethodTypes) {\n@@ -477,2 +500,2 @@\n-        int[] types = {\n-            MethodTypeForm.LF_EX_LINKER,\n+\n+        int[] invokerTypes = {\n@@ -480,2 +503,1 @@\n-            MethodTypeForm.LF_GEN_LINKER,\n-            MethodTypeForm.LF_GEN_INVOKER\n+            MethodTypeForm.LF_GEN_INVOKER,\n@@ -484,1 +506,1 @@\n-        for (int i = 0; i < invokerMethodTypes.length; i++) {\n+        for (MethodType methodType : invokerMethodTypes) {\n@@ -486,3 +508,3 @@\n-            if (dedupSet.add(invokerMethodTypes[i])) {\n-                for (int type : types) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n+            if (dedupSet.add(methodType)) {\n+                for (int type : invokerTypes) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n@@ -496,0 +518,18 @@\n+        int[] linkerTypes = {\n+                MethodTypeForm.LF_EX_LINKER,\n+                MethodTypeForm.LF_GEN_LINKER,\n+        };\n+\n+        dedupSet = new HashSet<>();\n+        for (MethodType methodType : linkerMethodTypes) {\n+            \/\/ generate methods representing linkers of the specified type\n+            if (dedupSet.add(methodType)) {\n+                for (int type : linkerTypes) {\n+                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n+                            \/*customized*\/false, type);\n+                    forms.add(linkerForm);\n+                    names.add(linkerForm.kind.defaultLambdaName);\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5683,12 +5683,2 @@\n-        long q1, r_tmp;\n-        if (v1 == 1) {\n-            q1 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q1 = tmp \/ v1;\n-            r_tmp = tmp - q1 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q1 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q1 = Long.divideUnsigned(tmp, v1);\n+        long r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5705,12 +5695,2 @@\n-        long q0;\n-        if (v1 == 1) {\n-            q0 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q0 = tmp \/ v1;\n-            r_tmp = tmp - q0 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q0 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q0 = Long.divideUnsigned(tmp, v1);\n+        r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5796,31 +5776,0 @@\n-    \/**\n-     * Calculate the quotient and remainder of dividing a negative long by\n-     * another long.\n-     *\n-     * @param n the numerator; must be negative\n-     * @param d the denominator; must not be unity\n-     * @return a two-element {@code long} array with the remainder and quotient in\n-     *         the initial and final elements, respectively\n-     *\/\n-    private static long[] divRemNegativeLong(long n, long d) {\n-        assert n < 0 : \"Non-negative numerator \" + n;\n-        assert d != 1 : \"Unity denominator\";\n-\n-        \/\/ Approximate the quotient and remainder\n-        long q = (n >>> 1) \/ (d >>> 1);\n-        long r = n - q * d;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += d;\n-            q--;\n-        }\n-        while (r >= d) {\n-            r -= d;\n-            q++;\n-        }\n-\n-        \/\/ n - q*d == r && 0 <= r < d, hence we're done.\n-        return new long[] {r, q};\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":5,"deletions":56,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1095,3 +1095,3 @@\n-            long dividendValue = value[offset] & LONG_MASK;\n-            int q = (int) (dividendValue \/ divisorLong);\n-            int r = (int) (dividendValue - q * divisorLong);\n+            int dividendValue = value[offset];\n+            int q = Integer.divideUnsigned(dividendValue, divisor);\n+            int r = Integer.remainderUnsigned(dividendValue, divisor);\n@@ -1109,15 +1109,3 @@\n-        \/\/ Normalize the divisor\n-        int shift = Integer.numberOfLeadingZeros(divisor);\n-\n-        int rem = value[offset];\n-        long remLong = rem & LONG_MASK;\n-        if (remLong < divisorLong) {\n-            quotient.value[0] = 0;\n-        } else {\n-            quotient.value[0] = (int)(remLong \/ divisorLong);\n-            rem = (int) (remLong - (quotient.value[0] * divisorLong));\n-            remLong = rem & LONG_MASK;\n-        }\n-        int xlen = intLen;\n-        while (--xlen > 0) {\n-            long dividendEstimate = (remLong << 32) |\n+        long rem = 0;\n+        for (int xlen = intLen; xlen > 0; xlen--) {\n+            long dividendEstimate = (rem << 32) |\n@@ -1125,9 +1113,2 @@\n-            int q;\n-            if (dividendEstimate >= 0) {\n-                q = (int) (dividendEstimate \/ divisorLong);\n-                rem = (int) (dividendEstimate - q * divisorLong);\n-            } else {\n-                long tmp = divWord(dividendEstimate, divisor);\n-                q = (int) (tmp & LONG_MASK);\n-                rem = (int) (tmp >>> 32);\n-            }\n+            int q = (int) Long.divideUnsigned(dividendEstimate, divisorLong);\n+            rem = Long.remainderUnsigned(dividendEstimate, divisorLong);\n@@ -1135,1 +1116,0 @@\n-            remLong = rem & LONG_MASK;\n@@ -1139,5 +1119,1 @@\n-        \/\/ Unnormalize\n-        if (shift > 0)\n-            return rem % divisor;\n-        else\n-            return rem;\n+        return (int)rem;\n@@ -1560,8 +1536,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat = (int) (tmp & LONG_MASK);\n-                    qrem = (int) (tmp >>> 32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1619,8 +1589,2 @@\n-            if (nChunk >= 0) {\n-                qhat = (int) (nChunk \/ dhLong);\n-                qrem = (int) (nChunk - (qhat * dhLong));\n-            } else {\n-                long tmp = divWord(nChunk, dh);\n-                qhat = (int) (tmp & LONG_MASK);\n-                qrem = (int) (tmp >>> 32);\n-            }\n+            qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+            qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1735,8 +1699,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat =(int)(tmp & LONG_MASK);\n-                    qrem = (int)(tmp>>>32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1837,34 +1795,0 @@\n-    \/**\n-     * This method divides a long quantity by an int to estimate\n-     * qhat for two multi precision numbers. It is used when\n-     * the signed value of n is less than zero.\n-     * Returns long value where high 32 bits contain remainder value and\n-     * low 32 bits contain quotient value.\n-     *\/\n-    static long divWord(long n, int d) {\n-        long dLong = d & LONG_MASK;\n-        long r;\n-        long q;\n-        if (dLong == 1) {\n-            q = (int)n;\n-            r = 0;\n-            return (r << 32) | (q & LONG_MASK);\n-        }\n-\n-        \/\/ Approximate the quotient and remainder\n-        q = (n >>> 1) \/ (dLong >>> 1);\n-        r = n - q*dLong;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += dLong;\n-            q--;\n-        }\n-        while (r >= dLong) {\n-            r -= dLong;\n-            q++;\n-        }\n-        \/\/ n - q*dlong == r && 0 <= r <dLong, hence we're done.\n-        return (r << 32) | (q & LONG_MASK);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":16,"deletions":92,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Function;\n@@ -983,0 +984,1 @@\n+\n@@ -989,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n@@ -992,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n@@ -996,4 +998,11 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n-    private static Locale createLocale(Object key) {\n-        if (key instanceof BaseLocale base) {\n-            return new Locale(base, null);\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n+        @Override\n+        public Locale apply(Object key) {\n+            if (key instanceof BaseLocale base) {\n+                return new Locale(base, null);\n+            }\n+            LocaleKey lk = (LocaleKey)key;\n+            return new Locale(lk.base, lk.exts);\n@@ -1001,3 +1010,1 @@\n-        LocaleKey lk = (LocaleKey)key;\n-        return new Locale(lk.base, lk.exts);\n-    }\n+    };\n@@ -1006,0 +1013,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n- * l.lock();\n+ * l.lock(); \/\/ lock() as the last statement before the try block\n@@ -87,1 +87,1 @@\n- *   l.unlock();\n+ *   l.unlock(); \/\/ unlock() as the first statement in the finally block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/Lock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,2 +74,3 @@\n- * follow a call to {@code lock} with a {@code try} block, most\n- * typically in a before\/after construction such as:\n+ * follow a call to {@code lock} with a {@code try} block, and\n+ * to <em>always<\/em> immediately call {@code unlock} as the\n+ * first statement in the finally block, as follows:\n@@ -83,1 +84,1 @@\n- *     lock.lock();  \/\/ block until condition holds\n+ *     lock.lock();  \/\/ lock() as the last statement before the try block\n@@ -87,1 +88,1 @@\n- *       lock.unlock();\n+ *       lock.unlock(); \/\/ unlock() as the first statement in the finally block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantLock.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+ *     \/\/ Code between the lock() above, and the unlock() below must not throw\n@@ -161,1 +162,1 @@\n- *\n+ *     \/\/ Make sure that code that could throw is executed inside the try block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+ * Note that the CLDR locale data are subject to change. Users should not assume\n+ * that the locale data remain the same across CLDR versions. Otherwise, unexpected\n+ * incompatible behaviors may occur, such as an exception on parsing a date.\n+ * Refer to <a href=\"https:\/\/cldr.unicode.org\/index\/downloads\">CLDR Releases<\/a>\n+ * for the deltas between their releases.\n@@ -267,1 +272,1 @@\n-}\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleServiceProvider.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -405,0 +406,5 @@\n+    \/**\n+     * Returns the initial value of System.err.\n+     *\/\n+    PrintStream initialSystemErr();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            return TypeKind.fromNewArrayCode(code.classReader.readU1(pos + 1));\n+            return TypeKind.fromNewarrayCode(code.classReader.readU1(pos + 1));\n@@ -1152,1 +1152,1 @@\n-            writer.writeNewPrimitiveArray(typeKind.newarraycode());\n+            writer.writeNewPrimitiveArray(typeKind.newarrayCode());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -207,4 +208,1 @@\n-        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n-        \/\/ we check the root layout instead\n-        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n-        VarHandle handle = accessedLayout.varHandle();\n+        VarHandle handle = valueLayout.varHandle();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.PrintStream;\n@@ -499,0 +500,7 @@\n+\n+    \/**\n+     * Return the initial value of System.err that was set during VM initialization.\n+     *\/\n+    public static PrintStream initialErr() {\n+        return SharedSecrets.getJavaLangAccess().initialSystemErr();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,0 +103,15 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    public static <K, V> Supplier<Map<ReferenceKey<K>, V>> concurrentHashMapSupplier() {\n+        return new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<K>, V> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,9 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <E> the type of elements maintained by this set\n+     *\/\n+    public static <E> Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> concurrentHashMapSupplier() {\n+        return ReferencedKeyMap.concurrentHashMapSupplier();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,18 @@\n+\n+            if (parent == null) {\n+                \/\/ check nonlikelyScript locales\n+                if (CLDRBaseLocaleDataMetaInfo.nonlikelyScript && locale.getCountry().isEmpty()) {\n+                    var lang = \" \" + locale.getLanguage() + \" \";\n+                    var script= locale.getScript();\n+                    if (!script.isEmpty()) {\n+                        parent = baseMetaInfo.likelyScriptMap().entrySet().stream()\n+                            .filter(e -> e.getValue().contains(lang))\n+                            .findAny()\n+                            .map(Map.Entry::getKey)\n+                            .map(likely -> likely.equals(script) ? null : Locale.ROOT)\n+                            .orElse(null);\n+                    }\n+                }\n+            }\n+\n+            \/\/ no parent found\n","filename":"src\/java.base\/share\/classes\/sun\/util\/cldr\/CLDRLocaleProviderAdapter.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.UnaryOperator;\n@@ -96,1 +96,1 @@\n-            ReferencedKeySet.create(true, ConcurrentHashMap::new);\n+            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -167,5 +167,2 @@\n-            (b) -> new BaseLocale(\n-                LocaleUtils.toLowerString(b.language).intern(),\n-                LocaleUtils.toTitleString(b.script).intern(),\n-                LocaleUtils.toUpperString(b.region).intern(),\n-                b.variant.intern()));\n+                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n+                INTERNER);\n@@ -174,0 +171,11 @@\n+    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n+        @Override\n+        public BaseLocale apply(BaseLocale b) {\n+            return new BaseLocale(\n+                    LocaleUtils.toLowerString(b.language).intern(),\n+                    LocaleUtils.toTitleString(b.script).intern(),\n+                    LocaleUtils.toUpperString(b.region).intern(),\n+                    b.variant.intern());\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,0 +351,2 @@\n+        Color tabbedPaneBg = new ColorUIResource(238, 238, 238);\n+        Color unselectedTabColor = new ColorUIResource(255, 255, 255);\n@@ -1023,0 +1025,5 @@\n+            \"TabbedPane.selected\", tabbedPaneBg,\n+            \"TabbedPane.contentOpaque\", Boolean.TRUE,\n+            \"TabbedPane.tabsOpaque\", Boolean.TRUE,\n+            \"TabbedPane.contentAreaColor\", tabbedPaneBg,\n+            \"TabbedPane.unselectedBackground\", unselectedTabColor,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -975,0 +975,3 @@\n+        \/\/ Fill the tab rect area\n+        g.fillRect(x, y, w, h);\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,3 @@\n+      <uiColor name=\"nimbusTabbedPaneContentArea\">\n+         <matte red=\"238\" green=\"238\" blue=\"238\" alpha=\"255\" hueOffset=\"0.0\" saturationOffset=\"0.0\" brightnessOffset=\"0.0\" alphaOffset=\"0\"\/>\n+      <\/uiColor>\n@@ -21649,0 +21652,5 @@\n+               <uiProperty name=\"contentOpaque\" type=\"BOOLEAN\" value=\"true\"\/>\n+               <uiProperty name=\"tabsOpaque\" type=\"BOOLEAN\" value=\"true\"\/>\n+               <uiProperty name=\"contentAreaColor\" type=\"COLOR\">\n+                  <matte red=\"238\" green=\"238\" blue=\"238\" alpha=\"255\" uiDefaultParentName=\"nimbusTabbedPaneContentArea\" hueOffset=\"0.0\" saturationOffset=\"0.0\" brightnessOffset=\"0.0\" alphaOffset=\"0\"\/>\n+               <\/uiProperty>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/skin.laf","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.awt.Color;\n@@ -124,0 +125,7 @@\n+    \/\/ Background color for selected tab and content pane\n+    private Color selectColor;\n+    \/\/ Background color for unselected tabs\n+    private Color unselectedBackground;\n+    private boolean contentOpaque = true;\n+    private boolean tabsOpaque = true;\n+\n@@ -149,0 +157,4 @@\n+        selectColor = UIManager.getColor(\"TabbedPane.selected\");\n+        contentOpaque = UIManager.getBoolean(\"TabbedPane.contentOpaque\");\n+        tabsOpaque = UIManager.getBoolean(\"TabbedPane.tabsOpaque\");\n+        unselectedBackground = UIManager.getColor(\"TabbedPane.unselectedBackground\");\n@@ -639,2 +651,11 @@\n-        tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n-                x, y, width, height, tabIndex, placement);\n+\n+        if (isSelected) {\n+            g.setColor(selectColor);\n+        } else {\n+            g.setColor(getUnselectedBackgroundAt(tabIndex));\n+        }\n+\n+        if (tabsOpaque || tabPane.isOpaque()) {\n+            tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n+                    x, y, width, height, tabIndex, placement);\n+        }\n@@ -658,0 +679,2 @@\n+        }\n+    }\n@@ -659,1 +682,4 @@\n-\n+    private Color getUnselectedBackgroundAt(int index) {\n+        Color color = tabPane.getBackgroundAt(index);\n+        if (color instanceof UIResource && unselectedBackground != null) {\n+            return unselectedBackground;\n@@ -661,0 +687,1 @@\n+        return color;\n@@ -740,0 +767,15 @@\n+\n+        if (tabPane.getTabCount() > 0 && (contentOpaque || tabPane.isOpaque())) {\n+            \/\/ Fill region behind content area\n+            Color color = UIManager.getColor(\"TabbedPane.contentAreaColor\");\n+            if (color != null) {\n+                g.setColor(color);\n+            } else if (selectColor == null || selectedIndex == -1) {\n+                g.setColor(tabPane.getBackground());\n+            } else {\n+                g.setColor(selectColor);\n+            }\n+            \/\/ fill content area rect for both GTK and Nimbus LAF here\n+            g.fillRect(x, y, w, h);\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTabbedPaneUI.java","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,2 @@\n+     *\n+     * @since 13\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/keyinfo\/KeyValue.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2991,1 +2991,1 @@\n-                    tree.expr.type,\n+                    types.erasure(tree.expr.type),\n@@ -2994,1 +2994,1 @@\n-                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+                    .VarDef(dollar_s, instanceOfExpr);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -461,1 +461,3 @@\n-            cases = processCases(tree, newCases.toList());\n+            cases = newCases.toList();\n+            patchCompletingNormallyCases(cases);\n+            cases = processCases(tree, cases);\n@@ -526,2 +528,0 @@\n-            patchCompletingNormallyCases(cases);\n-\n@@ -688,1 +688,1 @@\n-                cases.tail.head.guard != null) {\n+                (cases.tail.head.guard != null || cases.tail.head.labels.stream().anyMatch(cl -> cl instanceof JCPatternCaseLabel p && p.syntheticGuard != null))) {\n@@ -703,0 +703,1 @@\n+                currentCase.completesNormally = false;\n@@ -951,0 +952,1 @@\n+        boolean previousCompletesNormally = false;\n@@ -955,0 +957,1 @@\n+            boolean currentCompletesNormally = c.head.completesNormally;\n@@ -989,0 +992,2 @@\n+                       !previousCompletesNormally &&\n+                       !currentCompletesNormally &&\n@@ -1004,0 +1009,1 @@\n+            previousCompletesNormally = currentCompletesNormally;\n@@ -1476,2 +1482,2 @@\n-                if (!e.getKey().isPreserved() ||\n-                    !parent.tryPrepend(e.getKey(), decl)) {\n+                if (!e.getValue().isUnnamedVariable() &&\n+                        (!e.getKey().isPreserved() || !parent.tryPrepend(e.getKey(), decl))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4161,1 +4161,1 @@\n-            } else if (def.hasTag(Tag.IMPORT)) {\n+            } else if (def.hasTag(Tag.IMPORT) || def.hasTag(Tag.MODULEIMPORT)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,3 @@\n+    \/\/ whether to allow legacy mechanisms\n+    private boolean allowLegacy = false;\n+\n@@ -254,0 +257,4 @@\n+    boolean getAllowLegacy() {\n+        return allowLegacy;\n+    }\n+\n@@ -456,0 +463,2 @@\n+            case \"allowLegacy\"->\n+                allowLegacy = parseBooleanEntry(st.sval);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -457,3 +457,12 @@\n-            if (encrypt) {\n-                token.p11.C_EncryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+\n+            if (type == Transformation.AES_GCM) {\n+                CK_VERSION cryptokiVersion = token.p11.getVersion();\n+                boolean useNormativeMechFirst = cryptokiVersion.major > 2 ||\n+                    (cryptokiVersion.major == 2  && cryptokiVersion.minor >= 40);\n+                if (encrypt) {\n+                    token.p11.C_GCMEncryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                } else {\n+                    token.p11.C_GCMDecryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                }\n@@ -461,2 +470,7 @@\n-                token.p11.C_DecryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+                if (encrypt) {\n+                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                } else {\n+                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1225,19 +1225,0 @@\n-    private static boolean isLegacy(CK_MECHANISM_INFO mechInfo)\n-            throws PKCS11Exception {\n-        \/\/ assume full support if no mech info available\n-        \/\/ For vendor-specific mechanisms, often no mech info is provided\n-        boolean partialSupport = false;\n-\n-        if (mechInfo != null) {\n-            if ((mechInfo.flags & CKF_DECRYPT) != 0) {\n-                \/\/ non-legacy cipher mechs should support encryption\n-                partialSupport |= ((mechInfo.flags & CKF_ENCRYPT) == 0);\n-            }\n-            if ((mechInfo.flags & CKF_VERIFY) != 0) {\n-                \/\/ non-legacy signature mechs should support signing\n-                partialSupport |= ((mechInfo.flags & CKF_SIGN) == 0);\n-            }\n-        }\n-        return partialSupport;\n-    }\n-\n@@ -1312,6 +1293,0 @@\n-            if (isLegacy(mechInfo)) {\n-                if (showInfo) {\n-                    System.out.println(\"DISABLED due to legacy\");\n-                }\n-                continue;\n-            }\n@@ -1339,0 +1314,1 @@\n+            boolean allowLegacy = config.getAllowLegacy();\n@@ -1354,0 +1330,15 @@\n+\n+                    \/\/ assume full support if no mech info available\n+                    if (!allowLegacy && mechInfo != null) {\n+                        if ((d.type == CIP &&\n+                                (mechInfo.flags & CKF_ENCRYPT) == 0) ||\n+                                (d.type == SIG &&\n+                                (mechInfo.flags & CKF_SIGN) == 0)) {\n+                            if (showInfo) {\n+                                System.out.println(\"DISABLED \" +  d.type +\n+                                        \" \" + d.algorithm +\n+                                        \" due to partial support\");\n+                            }\n+                            continue;\n+                        }\n+                    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -796,0 +796,18 @@\n+    \/**\n+     * C_GCMEncryptInitWithRetry initializes a GCM encryption operation and retry\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the encryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the encryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMEncryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n@@ -890,0 +908,18 @@\n+    \/**\n+     * C_GCMDecryptInitWithRetry initializes a GCM decryption operation\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the decryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the decryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMDecryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1017,2 +1017,3 @@\n- * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS_NO_IVBITS pointer\n- * Note: Need to try NSS definition first to avoid SIGSEGV.\n+ * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS pointer\n+ * Note: Early NSS versions crash w\/ CK_GCM_PARAMS and need to use\n+ * CK_GCM_PARAMS_NO_IVBITS to avoid SIGSEGV.\n@@ -1023,1 +1024,1 @@\n- * @return pointer to the new CK_GCM_PARAMS_NO_IVBITS structure\n+ * @return pointer to the new CK_GCM_PARAMS structure\n@@ -1025,1 +1026,1 @@\n-CK_GCM_PARAMS_NO_IVBITS_PTR\n+CK_GCM_PARAMS_PTR\n@@ -1028,1 +1029,1 @@\n-    CK_GCM_PARAMS_NO_IVBITS_PTR ckParamPtr;\n+    CK_GCM_PARAMS_PTR ckParamPtr;\n@@ -1056,2 +1057,2 @@\n-    \/\/ allocate memory for CK_GCM_PARAMS_NO_IVBITS pointer\n-    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+    \/\/ allocate memory for CK_GCM_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS));\n@@ -1068,0 +1069,2 @@\n+    \/\/ adjust since the value is in bits\n+    ckParamPtr->ulIvBits = ckParamPtr->ulIvLen << 3;\n@@ -1077,1 +1080,1 @@\n-        *pLength = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+        *pLength = sizeof(CK_GCM_PARAMS);\n@@ -1079,1 +1082,1 @@\n-    TRACE1(\"Created inner GCM_PARAMS PTR w\/o ulIvBits %p\\n\", ckParamPtr);\n+    TRACE1(\"Created inner GCM_PARAMS PTR %p\\n\", ckParamPtr);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -93,10 +92,50 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_EncryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMEncryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMEncryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n+            rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle,\n+                ckpMechanism, ckKeyHandle);\n@@ -106,1 +145,1 @@\n-    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMEncryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n@@ -315,1 +354,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -333,10 +371,51 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_DecryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMDecryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMDecryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+        ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_DecryptInit with normative CK_GCM_PARAMS\\n\");\n+            rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+                ckKeyHandle);\n@@ -346,1 +425,1 @@\n-    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMDecryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_crypt.c","additions":104,"deletions":25,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,5 +330,1 @@\n-                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n-                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n-                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n+                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n@@ -338,0 +334,4 @@\n+                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n@@ -454,3 +454,3 @@\n-\/* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated\n- * with the specified CK_MECHANISM structure with CK_GCM_PARAMS\n- * structure.\n+\/* This function updates the specified CK_MECHANISM structure\n+ * and its GCM parameter structure switching between CK_GCM_PARAMS and\n+ * CK_GCM_PARAMS_NO_IVBITS.\n@@ -459,1 +459,1 @@\n- * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.\n+ * the to-be-converted CK_GCM_PARAMS \/ CK_GCM_PARAMS_NO_IVBITS structure.\n@@ -461,1 +461,1 @@\n- * converted CK_GCM_PARAMS structure or NULL if no conversion took place.\n+ * converted structure or NULL if no conversion is done.\n@@ -464,9 +464,35 @@\n-    CK_GCM_PARAMS* pGcmParams2 = NULL;\n-    CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;\n-    if ((mechPtr->mechanism == CKM_AES_GCM) &&\n-            (mechPtr->pParameter != NULL_PTR) &&\n-            (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {\n-        pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));\n-        if (pGcmParams2 == NULL) {\n-            p11ThrowOutOfMemoryError(env, 0);\n-            return NULL;\n+    CK_GCM_PARAMS_PTR pParams;\n+    CK_GCM_PARAMS_NO_IVBITS_PTR pParamsNoIvBits;\n+    CK_ULONG paramLen;\n+\n+    if (mechPtr != NULL) {\n+        paramLen = mechPtr->ulParameterLen;\n+        if (paramLen == sizeof(CK_GCM_PARAMS)) {\n+            \/\/ CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS\n+            pParams = (CK_GCM_PARAMS*) mechPtr->pParameter;\n+            pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+            pParamsNoIvBits->pIv = pParams->pIv;\n+            pParamsNoIvBits->ulIvLen = pParams->ulIvLen;\n+            pParamsNoIvBits->pAAD = pParams->pAAD;\n+            pParamsNoIvBits->ulAADLen = pParams->ulAADLen;\n+            pParamsNoIvBits->ulTagBits = pParams->ulTagBits;\n+            mechPtr->pParameter = pParamsNoIvBits;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+            free(pParams);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS to CK_GCM_PARAMS_NO_IVBITS\\n\");\n+            return mechPtr;\n+        } else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+            \/\/ CK_GCM_PARAMS_NO_IVBITS => CK_GCM_PARAMS\n+            pParamsNoIvBits = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n+            pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n+            pParams->pIv = pParamsNoIvBits->pIv;\n+            pParams->ulIvLen = pParamsNoIvBits->ulIvLen;\n+            pParams->ulIvBits = pParamsNoIvBits->ulIvLen << 3;\n+            pParams->pAAD = pParamsNoIvBits->pAAD;\n+            pParams->ulAADLen = pParamsNoIvBits->ulAADLen;\n+            pParams->ulTagBits = pParamsNoIvBits->ulTagBits;\n+            mechPtr->pParameter = pParams;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n+            free(pParamsNoIvBits);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS_NO_IVBITS to CK_GCM_PARAMS\\n\");\n+            return mechPtr;\n@@ -474,16 +500,0 @@\n-        pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n-        pGcmParams2->pIv = pParams->pIv;\n-        pGcmParams2->ulIvLen = pParams->ulIvLen;\n-        pGcmParams2->ulIvBits = (pGcmParams2->ulIvLen << 3);\n-        pGcmParams2->pAAD = pParams->pAAD;\n-        pGcmParams2->ulAADLen = pParams->ulAADLen;\n-        pGcmParams2->ulTagBits = pParams->ulTagBits;\n-        TRACE1(\"DEBUG updateGCMParams: pMech %p\\n\", mechPtr);\n-        TRACE2(\"\\t=> GCM param w\/o ulIvBits %p => GCM param %p\\n\", pParams,\n-                pGcmParams2);\n-        free(pParams);\n-        mechPtr->pParameter = pGcmParams2;\n-        mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n-        return mechPtr;\n-    } else {\n-        TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n@@ -491,0 +501,1 @@\n+    TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":47,"deletions":36,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  private static Address mapped_base_address;\n@@ -101,1 +102,1 @@\n-    Address mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n+    mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n@@ -173,8 +174,20 @@\n-      \/\/ vtablesIndex points to this:\n-      \/\/     class CppVtableInfo {\n-      \/\/         intptr_t _vtable_size;\n-      \/\/         intptr_t _cloned_vtable[1];\n-      \/\/         ...\n-      \/\/     };\n-      \/\/     CppVtableInfo** CppVtables::_index;\n-      \/\/ This is the index of all the cloned vtables. E.g., for\n+      \/\/ vtablesIndex points to to an array like this:\n+      \/\/ long info[] = {\n+      \/\/   offset of the CppVtableInfo for ConstantPool,\n+      \/\/   offset of the CppVtableInfo for InstanceKlass,\n+      \/\/   offset of the CppVtableInfo for InstanceClassLoaderKlass,\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ class CppVtableInfo {\n+      \/\/   intptr_t _vtable_size;\n+      \/\/   intptr_t _cloned_vtable[1];\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ The loop below computes the following\n+      \/\/     CppVtableInfo* t_ConstantPool  = mapped_base_address + info[0];\n+      \/\/     CppVtableInfo* t_InstanceKlass = mapped_base_address + info[1];\n+      \/\/     ...\n+      \/\/\n+      \/\/ If we have the following objects\n@@ -183,3 +196,19 @@\n-      \/\/ the following holds true:\n-      \/\/     &_index[ConstantPool_Kind]->_cloned_vtable[0]  == ((intptr_t**)cp)[0]\n-      \/\/     &_index[InstanceKlass_Kind]->_cloned_vtable[0] == ((intptr_t**)ik)[0]\n+      \/\/\n+      \/\/ then the following holds true:\n+      \/\/     ((intptr_t**)cp)[0] == &t_ConstantPool->_cloned_vtable[0]  \/\/ The vtable for archived ConstantPools\n+      \/\/     ((intptr_t**)ik)[0] == &t_InstanceKlass->_cloned_vtable[0] \/\/ The vtable for archived InstanceKlasses\n+      \/\/\n+      \/\/ To get an idea what these address look like, do this:\n+      \/\/\n+      \/\/ $ java -Xlog:cds+vtables=debug -XX:+UnlockDiagnosticVMOptions -XX:ArchiveRelocationMode=0 --version\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for ConstantPool to 0x800000018\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceKlass to 0x800000090\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceClassLoaderKlass to 0x8000001e0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceMirrorKlass to 0x800000330\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceRefKlass to 0x800000480\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceStackChunkKlass to 0x8000005d0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for Method to 0x800000720\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for ObjArrayKlass to 0x800000798\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for TypeArrayKlass to 0x8000008f0\n+      \/\/ java 23-internal 2024-09-17\n+      \/\/ ...\n@@ -188,2 +217,8 @@\n-        Address vtableInfoAddress = vtablesIndex.getAddressAt(i * addressSize); \/\/ = _index[i]\n-        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize); \/\/ = &_index[i]->_cloned_vtable[0]\n+        long vtable_offset = vtablesIndex.getJLongAt(i * addressSize); \/\/ long offset = _index[i]\n+\n+        \/\/ CppVtableInfo* t = the address of the CppVtableInfo for the i-th table\n+        Address vtableInfoAddress = mapped_base_address.addOffsetTo(vtable_offset);\n+\n+        \/\/ vtableAddress = &t->_cloned_vtable[0]\n+        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize);\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-        if (sp == -1 || !auth.substring(0, sp).equals (\"Basic\")) {\n+        if (sp == -1 || !auth.substring(0, sp).equalsIgnoreCase(\"Basic\")) {\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/BasicAuthenticator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.Inet6Address;\n@@ -172,0 +173,7 @@\n+            if (inetAddr instanceof Inet6Address && addr.contains(\":\") && !addr.startsWith(\"[\")) {\n+                \/\/ we use the \"addr\" when printing the URL, so make sure it\n+                \/\/ conforms to RFC-2732, section 2:\n+                \/\/ To use a literal IPv6 address in a URL, the literal\n+                \/\/ address should be enclosed in \"[\" and \"]\" characters.\n+                addr = \"[\" + addr + \"]\";\n+            }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static int isatty(int fd) {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static String ttyname(int fd) {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/aix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        return LinuxNativePty.current(console);\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        return LinuxNativePty.open(attr, size);\n-    }\n-\n-    static int isatty(int fd) {\n-        return LinuxNativePty.isatty(fd);\n-    }\n-\n-    static String ttyname(int fd) {\n-        return LinuxNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.List;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Platform;\n-\/\/import com.sun.jna.Structure;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public interface CLibrary {\/\/extends com.sun.jna.Library {\n-\n-    void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    void ioctl(int fd, int cmd, winsize data) throws LastErrorException;\n-\n-    int isatty(int fd);\n-\n-    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    class winsize { \/\/extends Structure {\n-        public short ws_row;\n-        public short ws_col;\n-        public short ws_xpixel;\n-        public short ws_ypixel;\n-\n-        public winsize() {\n-        }\n-\n-        public winsize(Size ws) {\n-            ws_row = (short) ws.getRows();\n-            ws_col = (short) ws.getColumns();\n-        }\n-\n-        public Size toSize() {\n-            return new Size(ws_col, ws_row);\n-        }\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"ws_row\",\/\/\n-\/\/                    \"ws_col\",\/\/\n-\/\/                    \"ws_xpixel\",\/\/\n-\/\/                    \"ws_ypixel\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-    }\n-\n-    class termios {\/\/ extends Structure {\n-\n-        public int c_iflag;\n-        public int c_oflag;\n-        public int c_cflag;\n-        public int c_lflag;\n-        public byte c_line;\n-        public byte[] c_cc = new byte[32];\n-        public int c_ispeed;\n-        public int c_ospeed;\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"c_iflag\",\/\/\n-\/\/                    \"c_oflag\",\/\/\n-\/\/                    \"c_cflag\",\/\/\n-\/\/                    \"c_lflag\",\/\/\n-\/\/                    \"c_line\",\/\/\n-\/\/                    \"c_cc\",\/\/\n-\/\/                    \"c_ispeed\",\/\/\n-\/\/                    \"c_ospeed\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-        public termios() {\n-        }\n-\n-        public termios(Attributes t) {\n-            \/\/ Input flags\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n-            \/\/ Output flags\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n-            \/\/ Control flags\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n-            \/\/ Local flags\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n-            \/\/ Control chars\n-            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n-            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n-            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n-            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n-            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n-            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n-            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n-            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n-            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n-            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n-            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n-            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n-            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n-            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n-            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n-            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n-        }\n-\n-        private int setFlag(boolean flag, int value, int org) {\n-            return flag ? (org | value) : org;\n-        }\n-\n-        public Attributes toAttributes() {\n-            Attributes attr = new Attributes();\n-            \/\/ Input flags\n-            EnumSet<InputFlag> iflag = attr.getInputFlags();\n-            addFlag(c_iflag, iflag, InputFlag.IGNBRK,   IGNBRK);\n-            addFlag(c_iflag, iflag, InputFlag.IGNBRK, IGNBRK);\n-            addFlag(c_iflag, iflag, InputFlag.BRKINT, BRKINT);\n-            addFlag(c_iflag, iflag, InputFlag.IGNPAR, IGNPAR);\n-            addFlag(c_iflag, iflag, InputFlag.PARMRK, PARMRK);\n-            addFlag(c_iflag, iflag, InputFlag.INPCK, INPCK);\n-            addFlag(c_iflag, iflag, InputFlag.ISTRIP, ISTRIP);\n-            addFlag(c_iflag, iflag, InputFlag.INLCR, INLCR);\n-            addFlag(c_iflag, iflag, InputFlag.IGNCR, IGNCR);\n-            addFlag(c_iflag, iflag, InputFlag.ICRNL, ICRNL);\n-            addFlag(c_iflag, iflag, InputFlag.IXON, IXON);\n-            addFlag(c_iflag, iflag, InputFlag.IXOFF, IXOFF);\n-            addFlag(c_iflag, iflag, InputFlag.IXANY, IXANY);\n-            addFlag(c_iflag, iflag, InputFlag.IMAXBEL, IMAXBEL);\n-            addFlag(c_iflag, iflag, InputFlag.IUTF8, IUTF8);\n-            \/\/ Output flags\n-            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n-            addFlag(c_oflag, oflag, OutputFlag.OPOST, OPOST);\n-            addFlag(c_oflag, oflag, OutputFlag.ONLCR, ONLCR);\n-            addFlag(c_oflag, oflag, OutputFlag.OCRNL, OCRNL);\n-            addFlag(c_oflag, oflag, OutputFlag.ONOCR, ONOCR);\n-            addFlag(c_oflag, oflag, OutputFlag.ONLRET, ONLRET);\n-            addFlag(c_oflag, oflag, OutputFlag.OFILL, OFILL);\n-            addFlag(c_oflag, oflag, OutputFlag.NLDLY, NLDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.TABDLY, TABDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.CRDLY, CRDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.FFDLY, FFDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.BSDLY, BSDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.VTDLY, VTDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.OFDEL, OFDEL);\n-            \/\/ Control flags\n-            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n-            addFlag(c_cflag, cflag, ControlFlag.CS5, CS5);\n-            addFlag(c_cflag, cflag, ControlFlag.CS6, CS6);\n-            addFlag(c_cflag, cflag, ControlFlag.CS7, CS7);\n-            addFlag(c_cflag, cflag, ControlFlag.CS8, CS8);\n-            addFlag(c_cflag, cflag, ControlFlag.CSTOPB, CSTOPB);\n-            addFlag(c_cflag, cflag, ControlFlag.CREAD, CREAD);\n-            addFlag(c_cflag, cflag, ControlFlag.PARENB, PARENB);\n-            addFlag(c_cflag, cflag, ControlFlag.PARODD, PARODD);\n-            addFlag(c_cflag, cflag, ControlFlag.HUPCL, HUPCL);\n-            addFlag(c_cflag, cflag, ControlFlag.CLOCAL, CLOCAL);\n-            \/\/ Local flags\n-            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOKE, ECHOKE);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOE, ECHOE);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOK, ECHOK);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHO, ECHO);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHONL, ECHONL);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOPRT, ECHOPRT);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOCTL, ECHOCTL);\n-            addFlag(c_lflag, lflag, LocalFlag.ISIG, ISIG);\n-            addFlag(c_lflag, lflag, LocalFlag.ICANON, ICANON);\n-            addFlag(c_lflag, lflag, LocalFlag.EXTPROC, EXTPROC);\n-            addFlag(c_lflag, lflag, LocalFlag.TOSTOP, TOSTOP);\n-            addFlag(c_lflag, lflag, LocalFlag.FLUSHO, FLUSHO);\n-            addFlag(c_lflag, lflag, LocalFlag.NOFLSH, NOFLSH);\n-            \/\/ Control chars\n-            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n-            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n-            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n-            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n-            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n-            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n-            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n-            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n-            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n-            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n-            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n-            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n-            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n-            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n-            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n-            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n-            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n-            \/\/ Return\n-            return attr;\n-        }\n-\n-        private <T extends Enum<T>> void addFlag(int value, EnumSet<T> flags, T flag, int v) {\n-            if ((value & v) != 0) {\n-                flags.add(flag);\n-            }\n-        }\n-    }\n-\n-    \/\/ CONSTANTS\n-\n-    int TIOCGWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x40087468 : *\/0x00005413;\n-    int TIOCSWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x80087467 : *\/0x00005414;\n-\n-    int VINTR       = 0;\n-    int VQUIT       = 1;\n-    int VERASE      = 2;\n-    int VKILL       = 3;\n-    int VEOF        = 4;\n-    int VTIME       = 5;\n-    int VMIN        = 6;\n-    int VSWTC       = 7;\n-    int VSTART      = 8;\n-    int VSTOP       = 9;\n-    int VSUSP       = 10;\n-    int VEOL        = 11;\n-    int VREPRINT    = 12;\n-    int VDISCARD    = 13;\n-    int VWERASE     = 14;\n-    int VLNEXT      = 15;\n-    int VEOL2       = 16;\n-\n-    int IGNBRK =   0x0000001;\n-    int BRKINT =   0x0000002;\n-    int IGNPAR =   0x0000004;\n-    int PARMRK =   0x0000008;\n-    int INPCK =    0x0000010;\n-    int ISTRIP =   0x0000020;\n-    int INLCR =    0x0000040;\n-    int IGNCR =    0x0000080;\n-    int ICRNL =    0x0000100;\n-    int IUCLC =    0x0000200;\n-    int IXON =     0x0000400;\n-    int IXANY =    0x0000800;\n-    int IXOFF =    0x0001000;\n-    int IMAXBEL =  0x0002000;\n-    int IUTF8 =    0x0004000;\n-\n-    int OPOST =    0x0000001;\n-    int OLCUC =    0x0000002;\n-    int ONLCR =    0x0000004;\n-    int OCRNL =    0x0000008;\n-    int ONOCR =    0x0000010;\n-    int ONLRET =   0x0000020;\n-    int OFILL =    0x0000040;\n-    int OFDEL =    0x0000080;\n-    int NLDLY =    0x0000100;\n-      int NL0 =    0x0000000;\n-      int NL1 =    0x0000100;\n-    int CRDLY =    0x0000600;\n-      int CR0 =    0x0000000;\n-      int CR1 =    0x0000200;\n-      int CR2 =    0x0000400;\n-      int CR3 =    0x0000600;\n-    int TABDLY =   0x0001800;\n-      int TAB0 =   0x0000000;\n-      int TAB1 =   0x0000800;\n-      int TAB2 =   0x0001000;\n-      int TAB3 =   0x0001800;\n-      int XTABS =  0x0001800;\n-    int BSDLY =    0x0002000;\n-      int BS0 =    0x0000000;\n-      int BS1 =    0x0002000;\n-    int VTDLY =    0x0004000;\n-      int VT0 =    0x0000000;\n-      int VT1 =    0x0004000;\n-    int FFDLY =    0x0008000;\n-      int FF0 =    0x0000000;\n-      int FF1 =    0x0008000;\n-\n-    int CBAUD =    0x000100f;\n-     int B0 =      0x0000000;\n-     int B50 =     0x0000001;\n-     int B75 =     0x0000002;\n-     int B110 =    0x0000003;\n-     int B134 =    0x0000004;\n-     int B150 =    0x0000005;\n-     int B200 =    0x0000006;\n-     int B300 =    0x0000007;\n-     int B600 =    0x0000008;\n-     int B1200 =   0x0000009;\n-     int B1800 =   0x000000a;\n-     int B2400 =   0x000000b;\n-     int B4800 =   0x000000c;\n-     int B9600 =   0x000000d;\n-     int B19200 =  0x000000e;\n-     int B38400 =  0x000000f;\n-    int EXTA =  B19200;\n-    int EXTB =  B38400;\n-    int CSIZE =    0x0000030;\n-      int CS5 =    0x0000000;\n-      int CS6 =    0x0000010;\n-      int CS7 =    0x0000020;\n-      int CS8 =    0x0000030;\n-    int CSTOPB =   0x0000040;\n-    int CREAD =    0x0000080;\n-    int PARENB =   0x0000100;\n-    int PARODD =   0x0000200;\n-    int HUPCL =    0x0000400;\n-    int CLOCAL =   0x0000800;\n-\n-    int ISIG =     0x0000001;\n-    int ICANON =   0x0000002;\n-    int XCASE =    0x0000004;\n-    int ECHO =     0x0000008;\n-    int ECHOE =    0x0000010;\n-    int ECHOK =    0x0000020;\n-    int ECHONL =   0x0000040;\n-    int NOFLSH =   0x0000080;\n-    int TOSTOP =   0x0000100;\n-    int ECHOCTL =  0x0000200;\n-    int ECHOPRT =  0x0000400;\n-    int ECHOKE =   0x0000800;\n-    int FLUSHO =   0x0001000;\n-    int PENDIN =   0x0002000;\n-    int IEXTEN =   0x0008000;\n-    int EXTPROC =  0x0010000;\n-\n-    int TCSANOW =          0x0;\n-    int TCSADRAIN =        0x1;\n-    int TCSAFLUSH =        0x2;\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public final class CLibraryImpl implements CLibrary {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public void ioctl(int fd, int cmd, winsize data) throws LastErrorException {\n-        if (cmd == CLibrary.TIOCGWINSZ || cmd == CLibrary.TIOCSWINSZ) {\n-            ioctl0(fd, cmd, data);\n-        } else {\n-            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n-        }\n-    }\n-\n-    private native void ioctl0(int fd, int cmd, winsize data) throws LastErrorException;\n-\n-    @Override\n-    public native int isatty(int fd);\n-\n-    @Override\n-    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibraryImpl.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TCSADRAIN;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCGWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCSWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.termios;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.winsize;\n-\n-public class LinuxNativePty extends JnaNativePty {\n-\n-\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-    private static final CLibrary C_LIBRARY = new CLibraryImpl();\n-\n-    public interface UtilLibrary {\/\/ extends com.sun.jna.Library {\n-\n-        void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException;\n-\n-\/\/        UtilLibrary INSTANCE = Native.load(\"util\", UtilLibrary.class);\n-        UtilLibrary INSTANCE = new UtilLibraryImpl();\n-    }\n-\n-    public static LinuxNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n-        switch (consoleStream) {\n-            case Output:\n-                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n-            case Error:\n-                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-    }\n-\n-    public static LinuxNativePty open(Attributes attr, Size size) throws IOException {\n-        int[] master = new int[1];\n-        int[] slave = new int[1];\n-        byte[] buf = new byte[64];\n-        UtilLibrary.INSTANCE.openpty(master, slave, buf,\n-                attr != null ? new termios(attr) : null,\n-                size != null ? new winsize(size) : null);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        String name = new String(buf, 0, len);\n-        return new LinuxNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n-    }\n-\n-    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        super(master, masterFD, slave, slaveFD, name);\n-    }\n-\n-    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        termios termios = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), termios);\n-        return termios.toAttributes();\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        termios termios = new termios(attr);\n-        termios org = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), org);\n-        org.c_iflag = termios.c_iflag;\n-        org.c_oflag = termios.c_oflag;\n-        org.c_lflag = termios.c_lflag;\n-        System.arraycopy(termios.c_cc, 0, org.c_cc, 0, termios.c_cc.length);\n-        C_LIBRARY.tcsetattr(getSlave(), TCSADRAIN, org);\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        winsize sz = new winsize();\n-        C_LIBRARY.ioctl(getSlave(), TIOCGWINSZ, sz);\n-        return sz.toSize();\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        winsize sz = new winsize(size);\n-        C_LIBRARY.ioctl(getSlave(), TIOCSWINSZ, sz);\n-    }\n-\n-    public static int isatty(int fd) {\n-        return C_LIBRARY.isatty(fd);\n-    }\n-\n-    public static String ttyname(int slave) {\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.ttyname_r(slave, buf, buf.length);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        return new String(buf, 0, len);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/LinuxNativePty.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty.UtilLibrary;\n-\n-public final class UtilLibraryImpl implements UtilLibrary {\n-\n-    @Override\n-    public void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/UtilLibraryImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,207 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <termios.h>\n-#include <unistd.h>\n-#include <sys\/ioctl.h>\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-static jclass termios_j;\n-static jfieldID c_iflag;\n-static jfieldID c_oflag;\n-static jfieldID c_cflag;\n-static jfieldID c_lflag;\n-static jfieldID c_line;\n-static jfieldID c_cc;\n-static jfieldID c_ispeed;\n-static jfieldID c_ospeed;\n-\n-static jclass winsize_j;\n-static jfieldID ws_row;\n-static jfieldID ws_col;\n-static jfieldID ws_xpixel;\n-static jfieldID ws_ypixel;\n-\n-static void throw_errno(JNIEnv *env);\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_initIDs\n-  (JNIEnv *env, jclass unused) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$termios\");\n-    CHECK_NULL(cls);\n-    termios_j = (jclass) env->NewGlobalRef(cls);\n-    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"I\");\n-    CHECK_NULL(c_iflag);\n-    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"I\");\n-    CHECK_NULL(c_oflag);\n-    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"I\");\n-    CHECK_NULL(c_cflag);\n-    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"I\");\n-    CHECK_NULL(c_lflag);\n-    c_line = env->GetFieldID(termios_j, \"c_line\", \"B\");\n-    CHECK_NULL(c_line);\n-    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n-    CHECK_NULL(c_cc);\n-    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"I\");\n-    CHECK_NULL(c_ispeed);\n-    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"I\");\n-    CHECK_NULL(c_ospeed);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$winsize\");\n-    CHECK_NULL(cls);\n-    winsize_j = (jclass) env->NewGlobalRef(cls);\n-    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n-    CHECK_NULL(ws_row);\n-    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n-    CHECK_NULL(ws_col);\n-    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n-    CHECK_NULL(ws_xpixel);\n-    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n-    CHECK_NULL(ws_ypixel);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcgetattr\n-  (JNIEnv *env, jobject, jint fd, jobject result) {\n-    termios data;\n-\n-    if (tcgetattr(fd, &data) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetIntField(result, c_iflag, data.c_iflag);\n-    env->SetIntField(result, c_oflag, data.c_oflag);\n-    env->SetIntField(result, c_cflag, data.c_cflag);\n-    env->SetIntField(result, c_lflag, data.c_lflag);\n-    env->SetIntField(result, c_line, data.c_line);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n-    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\/\/TODO: cast?\n-    env->SetIntField(result, c_ispeed, cfgetispeed(&data));\n-    env->SetIntField(result, c_ospeed, cfgetospeed(&data));\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    tcsetattr\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/termios;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcsetattr\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n-    termios data;\n-\n-    data.c_iflag = env->GetIntField(input, c_iflag);\n-    data.c_oflag = env->GetIntField(input, c_oflag);\n-    data.c_cflag = env->GetIntField(input, c_cflag);\n-    data.c_lflag = env->GetIntField(input, c_lflag);\n-    data.c_line = env->GetIntField(input, c_line);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n-    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n-    cfsetispeed(&data, env->GetIntField(input, c_ispeed));\n-    cfsetospeed(&data, env->GetIntField(input, c_ospeed));\n-\n-    if (tcsetattr(fd, cmd, &data) != 0) {\n-        throw_errno(env);\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    ioctl0\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/winsize;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ioctl0\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject data) {\n-    winsize ws;\n-\n-    ws.ws_row = env->GetShortField(data, ws_row);\n-    ws.ws_col = env->GetShortField(data, ws_col);\n-    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n-\n-    if (ioctl(fd, cmd, &ws) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetShortField(data, ws_row, ws.ws_row);\n-    env->SetShortField(data, ws_col, ws.ws_col);\n-    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    isatty\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_isatty\n-  (JNIEnv *, jobject, jint fd) {\n-    return isatty(fd);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    ttyname_r\n- * Signature: (I[BI)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ttyname_1r\n-  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n-    char *data = new char[len];\n-    int error = ttyname_r(fd, data, len);\n-\n-    if (error != 0) {\n-        delete[] data;\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n-    delete[] data;\n-}\n-\n-\/*\n- * Throws LastErrorException based on the errno:\n- *\/\n-static void throw_errno(JNIEnv *env) {\n-    jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                 lastErrorExceptionConstructor,\n-                                 errno);\n-    env->Throw((jthrowable) exc);\n-}\n","filename":"src\/jdk.internal.le\/linux\/native\/lible\/CLibrary.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        return OsXNativePty.current(console);\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        return OsXNativePty.open(attr, size);\n-    }\n-\n-    static int isatty(int fd) {\n-        return OsXNativePty.isatty(fd);\n-    }\n-\n-    static String ttyname(int fd) {\n-        return OsXNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,394 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.List;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.NativeLong;\n-\/\/import com.sun.jna.Structure;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public interface CLibrary {\/\/extends com.sun.jna.Library {\n-\n-    void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException;\n-\n-    int isatty(int fd);\n-\n-    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException;\n-\n-    class winsize { \/\/extends Structure {\n-        public short ws_row;\n-        public short ws_col;\n-        public short ws_xpixel;\n-        public short ws_ypixel;\n-\n-        public winsize() {\n-        }\n-\n-        public winsize(Size ws) {\n-            ws_row = (short) ws.getRows();\n-            ws_col = (short) ws.getColumns();\n-        }\n-\n-        public Size toSize() {\n-            return new Size(ws_col, ws_row);\n-        }\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"ws_row\",\/\/\n-\/\/                    \"ws_col\",\/\/\n-\/\/                    \"ws_xpixel\",\/\/\n-\/\/                    \"ws_ypixel\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-    }\n-\n-    class termios { \/\/extends Structure {\n-\n-        public NativeLong c_iflag;\n-        public NativeLong c_oflag;\n-        public NativeLong c_cflag;\n-        public NativeLong c_lflag;\n-        public byte[] c_cc = new byte[20];\n-        public NativeLong c_ispeed;\n-        public NativeLong c_ospeed;\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"c_iflag\",\/\/\n-\/\/                    \"c_oflag\",\/\/\n-\/\/                    \"c_cflag\",\/\/\n-\/\/                    \"c_lflag\",\/\/\n-\/\/                    \"c_cc\",\/\/\n-\/\/                    \"c_ispeed\",\/\/\n-\/\/                    \"c_ospeed\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-        {\n-            c_iflag  = new NativeLong(0);\n-            c_oflag  = new NativeLong(0);\n-            c_cflag  = new NativeLong(0);\n-            c_lflag  = new NativeLong(0);\n-            c_ispeed = new NativeLong(0);\n-            c_ospeed = new NativeLong(0);\n-        }\n-\n-        public termios() {\n-        }\n-\n-        public termios(Attributes t) {\n-            \/\/ Input flags\n-            setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n-            \/\/ Output flags\n-            setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OXTABS),         OXTABS,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONOEOT),         ONOEOT,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n-            \/\/ Control flags\n-            setFlag(t.getControlFlag(ControlFlag.CIGNORE),      CIGNORE,    c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CCTS_OFLOW),   CCTS_OFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CRTS_IFLOW),   CRTS_IFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CDTR_IFLOW),   CDTR_IFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CDSR_OFLOW),   CDSR_OFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CCAR_OFLOW),   CCAR_OFLOW, c_cflag);\n-            \/\/ Local flags\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ALTWERASE),        ALTWERASE,  c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.IEXTEN),           IEXTEN,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.NOKERNINFO),       NOKERNINFO, c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.PENDIN),           PENDIN,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n-            \/\/ Control chars\n-            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n-            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n-            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n-            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n-            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n-            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n-            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n-            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n-            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n-            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n-            c_cc[VDSUSP]    = (byte) t.getControlChar(ControlChar.VDSUSP);\n-            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n-            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n-            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n-            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n-            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n-            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n-            c_cc[VSTATUS]   = (byte) t.getControlChar(ControlChar.VSTATUS);\n-        }\n-\n-        private void setFlag(boolean flag, long value, NativeLong org) {\n-            org.setValue(flag ? org.longValue() | value : org.longValue());\n-        }\n-\n-        public Attributes toAttributes() {\n-            Attributes attr = new Attributes();\n-            \/\/ Input flags\n-            EnumSet<InputFlag> iflag = attr.getInputFlags();\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK,   IGNBRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK, IGNBRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.BRKINT, BRKINT);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNPAR, IGNPAR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.PARMRK, PARMRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.INPCK, INPCK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.ISTRIP, ISTRIP);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.INLCR, INLCR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNCR, IGNCR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.ICRNL, ICRNL);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXON, IXON);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXOFF, IXOFF);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXANY, IXANY);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IMAXBEL, IMAXBEL);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IUTF8, IUTF8);\n-            \/\/ Output flags\n-            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OPOST, OPOST);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLCR, ONLCR);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OXTABS, OXTABS);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOEOT, ONOEOT);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OCRNL, OCRNL);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOCR, ONOCR);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLRET, ONLRET);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFILL, OFILL);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.NLDLY, NLDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.TABDLY, TABDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.CRDLY, CRDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.FFDLY, FFDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.BSDLY, BSDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.VTDLY, VTDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFDEL, OFDEL);\n-            \/\/ Control flags\n-            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CIGNORE, CIGNORE);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS5, CS5);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS6, CS6);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS7, CS7);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS8, CS8);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CSTOPB, CSTOPB);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CREAD, CREAD);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARENB, PARENB);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARODD, PARODD);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.HUPCL, HUPCL);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CLOCAL, CLOCAL);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCTS_OFLOW, CCTS_OFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CRTS_IFLOW, CRTS_IFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CDSR_OFLOW, CDSR_OFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCAR_OFLOW, CCAR_OFLOW);\n-            \/\/ Local flags\n-            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOKE, ECHOKE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOE, ECHOE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOK, ECHOK);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHO, ECHO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHONL, ECHONL);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOPRT, ECHOPRT);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOCTL, ECHOCTL);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ISIG, ISIG);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ICANON, ICANON);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ALTWERASE, ALTWERASE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.IEXTEN, IEXTEN);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.EXTPROC, EXTPROC);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.TOSTOP, TOSTOP);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.FLUSHO, FLUSHO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOKERNINFO, NOKERNINFO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.PENDIN, PENDIN);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOFLSH, NOFLSH);\n-            \/\/ Control chars\n-            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n-            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n-            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n-            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n-            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n-            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n-            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n-            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n-            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n-            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n-            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n-            cc.put(ControlChar.VDSUSP,      (int) c_cc[VDSUSP]);\n-            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n-            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n-            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n-            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n-            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n-            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n-            cc.put(ControlChar.VSTATUS,     (int) c_cc[VSTATUS]);\n-            \/\/ Return\n-            return attr;\n-        }\n-\n-        private <T extends Enum<T>> void addFlag(long value, EnumSet<T> flags, T flag, int v) {\n-            if ((value & v) != 0) {\n-                flags.add(flag);\n-            }\n-        }\n-    }\n-\n-    \/\/ CONSTANTS\n-\n-     long TIOCGWINSZ = 0x40087468L;\n-     long TIOCSWINSZ = 0x80087467L;\n-\n-     int TCSANOW     = 0x00000000;\n-\n-     int VEOF        = 0;\n-     int VEOL        = 1;\n-     int VEOL2       = 2;\n-     int VERASE      = 3;\n-     int VWERASE     = 4;\n-     int VKILL       = 5;\n-     int VREPRINT    = 6;\n-     int VINTR       = 8;\n-     int VQUIT       = 9;\n-     int VSUSP       = 10;\n-     int VDSUSP      = 11;\n-     int VSTART      = 12;\n-     int VSTOP       = 13;\n-     int VLNEXT      = 14;\n-     int VDISCARD    = 15;\n-     int VMIN        = 16;\n-     int VTIME       = 17;\n-     int VSTATUS     = 18;\n-\n-     int IGNBRK      = 0x00000001;\n-     int BRKINT      = 0x00000002;\n-     int IGNPAR      = 0x00000004;\n-     int PARMRK      = 0x00000008;\n-     int INPCK       = 0x00000010;\n-     int ISTRIP      = 0x00000020;\n-     int INLCR       = 0x00000040;\n-     int IGNCR       = 0x00000080;\n-     int ICRNL       = 0x00000100;\n-     int IXON        = 0x00000200;\n-     int IXOFF       = 0x00000400;\n-     int IXANY       = 0x00000800;\n-     int IMAXBEL     = 0x00002000;\n-     int IUTF8       = 0x00004000;\n-\n-     int OPOST       = 0x00000001;\n-     int ONLCR       = 0x00000002;\n-     int OXTABS      = 0x00000004;\n-     int ONOEOT      = 0x00000008;\n-     int OCRNL       = 0x00000010;\n-     int ONOCR       = 0x00000020;\n-     int ONLRET      = 0x00000040;\n-     int OFILL       = 0x00000080;\n-     int NLDLY       = 0x00000300;\n-     int TABDLY      = 0x00000c04;\n-     int CRDLY       = 0x00003000;\n-     int FFDLY       = 0x00004000;\n-     int BSDLY       = 0x00008000;\n-     int VTDLY       = 0x00010000;\n-     int OFDEL       = 0x00020000;\n-\n-     int CIGNORE     = 0x00000001;\n-     int CS5         = 0x00000000;\n-     int CS6         = 0x00000100;\n-     int CS7         = 0x00000200;\n-     int CS8         = 0x00000300;\n-     int CSTOPB      = 0x00000400;\n-     int CREAD       = 0x00000800;\n-     int PARENB      = 0x00001000;\n-     int PARODD      = 0x00002000;\n-     int HUPCL       = 0x00004000;\n-     int CLOCAL      = 0x00008000;\n-     int CCTS_OFLOW  = 0x00010000;\n-     int CRTS_IFLOW  = 0x00020000;\n-     int CDTR_IFLOW  = 0x00040000;\n-     int CDSR_OFLOW  = 0x00080000;\n-     int CCAR_OFLOW  = 0x00100000;\n-\n-     int ECHOKE      = 0x00000001;\n-     int ECHOE       = 0x00000002;\n-     int ECHOK       = 0x00000004;\n-     int ECHO        = 0x00000008;\n-     int ECHONL      = 0x00000010;\n-     int ECHOPRT     = 0x00000020;\n-     int ECHOCTL     = 0x00000040;\n-     int ISIG        = 0x00000080;\n-     int ICANON      = 0x00000100;\n-     int ALTWERASE   = 0x00000200;\n-     int IEXTEN      = 0x00000400;\n-     int EXTPROC     = 0x00000800;\n-     int TOSTOP      = 0x00400000;\n-     int FLUSHO      = 0x00800000;\n-     int NOKERNINFO  = 0x02000000;\n-     int PENDIN      = 0x20000000;\n-     int NOFLSH      = 0x80000000;\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary.java","additions":0,"deletions":394,"binary":false,"changes":394,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public final class CLibraryImpl implements CLibrary {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException {\n-        if (cmd.longValue() == CLibrary.TIOCGWINSZ || cmd.longValue() == CLibrary.TIOCSWINSZ) {\n-            ioctl0(fd, cmd.longValue(), data);\n-        } else {\n-            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n-        }\n-    }\n-\n-    private native void ioctl0(int fd, long cmd, winsize data) throws LastErrorException;\n-\n-    @Override\n-    public native int isatty(int fd);\n-\n-    @Override\n-    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    @Override\n-    public void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibraryImpl.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-class NativeLong {\n-\n-    public long value;\n-\n-    public NativeLong(long value) {\n-        this.value = value;\n-    }\n-\n-    public void setValue(long value) {\n-        this.value = value;\n-    }\n-\n-    public long longValue() {\n-        return value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.NativeLong;\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TCSANOW;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCGWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCSWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.termios;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.winsize;\n-\n-public class OsXNativePty extends JnaNativePty {\n-\n-\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-    private static final CLibrary C_LIBRARY = new CLibraryImpl();\/\/Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-\n-    public static OsXNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n-        switch (consoleStream) {\n-            case Output:\n-                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n-            case Error:\n-                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-    }\n-\n-    public static OsXNativePty open(Attributes attr, Size size) throws IOException {\n-        int[] master = new int[1];\n-        int[] slave = new int[1];\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.openpty(master, slave, buf,\n-                attr != null ? new termios(attr) : null,\n-                size != null ? new winsize(size) : null);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        String name = new String(buf, 0, len);\n-        return new OsXNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n-    }\n-\n-    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        super(master, masterFD, slave, slaveFD, name);\n-    }\n-\n-    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        termios termios = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), termios);\n-        return termios.toAttributes();\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        termios termios = new termios(attr);\n-        C_LIBRARY.tcsetattr(getSlave(), TCSANOW, termios);\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        winsize sz = new winsize();\n-        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCGWINSZ), sz);\n-        return sz.toSize();\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        winsize sz = new winsize(size);\n-        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCSWINSZ), sz);\n-    }\n-\n-    public static int isatty(int fd) {\n-        return C_LIBRARY.isatty(fd);\n-    }\n-\n-    public static String ttyname(int fd) {\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.ttyname_r(fd, buf, buf.length);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        return new String(buf, 0, len);\n-    }\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/OsXNativePty.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <termios.h>\n-#include <unistd.h>\n-#include <sys\/ioctl.h>\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-static jclass termios_j;\n-static jfieldID c_iflag;\n-static jfieldID c_oflag;\n-static jfieldID c_cflag;\n-static jfieldID c_lflag;\n-static jfieldID c_cc;\n-static jfieldID c_ispeed;\n-static jfieldID c_ospeed;\n-\n-static jclass winsize_j;\n-static jfieldID ws_row;\n-static jfieldID ws_col;\n-static jfieldID ws_xpixel;\n-static jfieldID ws_ypixel;\n-\n-static jclass nativelong_j;\n-static jfieldID nativelong_value;\n-\n-static void throw_errno(JNIEnv *env);\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_initIDs\n-  (JNIEnv *env, jclass) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$termios\");\n-    CHECK_NULL(cls);\n-    termios_j = (jclass) env->NewGlobalRef(cls);\n-    CHECK_NULL(termios_j);\n-    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_iflag);\n-    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_oflag);\n-    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_cflag);\n-    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_lflag);\n-    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n-    CHECK_NULL(c_cc);\n-    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_ispeed);\n-    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_ospeed);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$winsize\");\n-    CHECK_NULL(cls);\n-    winsize_j = (jclass) env->NewGlobalRef(cls);\n-    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n-    CHECK_NULL(ws_row);\n-    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n-    CHECK_NULL(ws_col);\n-    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n-    CHECK_NULL(ws_xpixel);\n-    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n-    CHECK_NULL(ws_ypixel);\n-\n-    nativelong_j = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong\");\n-    CHECK_NULL(nativelong_j);\n-    nativelong_value = env->GetFieldID(nativelong_j, \"value\", \"J\");\n-    CHECK_NULL(nativelong_value);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcgetattr\n-  (JNIEnv *env, jobject, jint fd, jobject result) {\n-    termios data;\n-\n-    if (tcgetattr(fd, &data) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetLongField(env->GetObjectField(result, c_iflag), nativelong_value, data.c_iflag);\n-    env->SetLongField(env->GetObjectField(result, c_oflag), nativelong_value, data.c_oflag);\n-    env->SetLongField(env->GetObjectField(result, c_cflag), nativelong_value, data.c_cflag);\n-    env->SetLongField(env->GetObjectField(result, c_lflag), nativelong_value, data.c_lflag);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n-    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\n-    env->SetLongField(env->GetObjectField(result, c_ispeed), nativelong_value, data.c_ispeed);\n-    env->SetLongField(env->GetObjectField(result, c_ospeed), nativelong_value, data.c_ospeed);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    tcsetattr\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/termios;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcsetattr\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n-    termios data;\n-\n-    data.c_iflag = env->GetLongField(env->GetObjectField(input, c_iflag), nativelong_value);\n-    data.c_oflag = env->GetLongField(env->GetObjectField(input, c_oflag), nativelong_value);\n-    data.c_cflag = env->GetLongField(env->GetObjectField(input, c_cflag), nativelong_value);\n-    data.c_lflag = env->GetLongField(env->GetObjectField(input, c_lflag), nativelong_value);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n-    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n-    data.c_ispeed = env->GetLongField(env->GetObjectField(input, c_ispeed), nativelong_value);\n-    data.c_ospeed = env->GetLongField(env->GetObjectField(input, c_ospeed), nativelong_value);\n-\n-    if (tcsetattr(fd, cmd, &data) != 0) {\n-        throw_errno(env);\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    ioctl0\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/winsize;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ioctl0\n-  (JNIEnv *env, jobject, jint fd, jlong cmd, jobject data) {\n-    winsize ws;\n-\n-    ws.ws_row = env->GetShortField(data, ws_row);\n-    ws.ws_col = env->GetShortField(data, ws_col);\n-    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n-\n-    if (ioctl(fd, cmd, &ws) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetShortField(data, ws_row, ws.ws_row);\n-    env->SetShortField(data, ws_col, ws.ws_col);\n-    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    isatty\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_isatty\n-  (JNIEnv *, jobject, jint fd) {\n-    return isatty(fd);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    ttyname_r\n- * Signature: (I[BI)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ttyname_1r\n-  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n-    char *data = new char[len];\n-    int error = ttyname_r(fd, data, len);\n-\n-    if (error != 0) {\n-        delete[] data;\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n-    delete[] data;\n-}\n-\n-\/*\n- * Throws LastErrorException based on the errno:\n- *\/\n-static void throw_errno(JNIEnv *env) {\n-    jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                 lastErrorExceptionConstructor,\n-                                 errno);\n-    env->Throw((jthrowable) exc);\n-}\n","filename":"src\/jdk.internal.le\/macosx\/native\/lible\/CLibrary.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -101,1 +101,1 @@\n-                return jline.readLine(fmt.formatted(args));\n+                return jline.readLine(fmt.formatted(args).replace(\"%\", \"%%\"));\n@@ -116,1 +116,2 @@\n-                return jline.readLine(fmt.formatted(args), '\\0').toCharArray();\n+                return jline.readLine(fmt.formatted(args).replace(\"%\", \"%%\"), '\\0')\n+                            .toCharArray();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -69,1 +69,1 @@\n-        for (;;) {\n+        for (; ; ) {\n@@ -81,2 +81,1 @@\n-                }\n-                else {\n+                } else {\n@@ -237,1 +236,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/keymap\/BindingReader.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,2 +11,0 @@\n-import java.io.IOException;\n-import java.io.StringWriter;\n@@ -221,1 +219,0 @@\n-\n@@ -267,1 +264,0 @@\n-\n@@ -309,3 +305,1 @@\n-                doGetBoundKeys((KeyMap<T>) keyMap.mapping[c],\n-                        prefix + (char) (c),\n-                        bound);\n+                doGetBoundKeys((KeyMap<T>) keyMap.mapping[c], prefix + (char) (c), bound);\n@@ -459,1 +453,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/keymap\/KeyMap.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,1 +17,1 @@\n- * @see jdk.internal.org.jline.keymap.KeyMap\n+ * @see org.jline.keymap.KeyMap\n@@ -21,2 +21,1 @@\n-public interface Binding {\n-}\n+public interface Binding {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Binding.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -87,4 +87,4 @@\n-    \/\/ JDK specific modification\n-    default void zeroOut() {\n-        throw new UnsupportedOperationException();\n-    }\n+    \/**\n+     * Clear any internal buffer.\n+     *\/\n+    void zeroOut();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Buffer.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -50,1 +50,9 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete, int sort) {\n+    public Candidate(\n+            String value,\n+            String displ,\n+            String group,\n+            String descr,\n+            String suffix,\n+            String key,\n+            boolean complete,\n+            int sort) {\n@@ -72,1 +80,2 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+    public Candidate(\n+            String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n@@ -162,1 +171,0 @@\n-\n@@ -166,1 +174,1 @@\n-        if( sort == o.sort() ) {\n+        if (sort == o.sort()) {\n@@ -183,1 +191,1 @@\n-        return Objects.hash(value);\n+        return Objects.hashCode(value);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -21,2 +21,1 @@\n-public interface Completer\n-{\n+public interface Completer {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Completer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -13,1 +13,1 @@\n- * of the {@link jdk.internal.org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n+ * of the {@link org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n@@ -25,1 +25,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletingParsedLine.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -26,2 +26,7 @@\n-    void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName);\n+    void compile(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName);\n@@ -47,1 +52,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,7 +2,1 @@\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Copyright (c) 2023, the original author(s).\n@@ -10,1 +4,2 @@\n- *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -12,6 +7,1 @@\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n@@ -48,1 +38,1 @@\n-    public int getOpenBrackets(){\n+    public int getOpenBrackets() {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EOFError.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -16,0 +16,1 @@\n+\n@@ -17,0 +18,1 @@\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Editor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -20,2 +20,1 @@\n-    public EndOfFileException() {\n-    }\n+    public EndOfFileException() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EndOfFileException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -16,1 +16,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Expander.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -24,2 +24,1 @@\n-public interface History extends Iterable<History.Entry>\n-{\n+public interface History extends Iterable<History.Entry> {\n@@ -78,1 +77,0 @@\n-\n@@ -113,2 +111,1 @@\n-    interface Entry\n-    {\n+    interface Entry {\n@@ -135,0 +132,1 @@\n+\n@@ -139,0 +137,1 @@\n+\n@@ -143,0 +142,1 @@\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -24,1 +24,1 @@\n- * <h3>Thread safety<\/h3>\n+ * <h2>Thread safety<\/h2>\n@@ -34,1 +34,1 @@\n- * <h3>Prompt strings<\/h3>\n+ * <h2>Prompt strings<\/h2>\n@@ -84,1 +84,0 @@\n-\n@@ -287,0 +286,1 @@\n+    String DUMB = \"dumb\";\n@@ -304,0 +304,1 @@\n+\n@@ -320,0 +321,1 @@\n+\n@@ -323,0 +325,1 @@\n+\n@@ -326,0 +329,1 @@\n+\n@@ -329,0 +333,1 @@\n+\n@@ -332,0 +337,1 @@\n+\n@@ -393,0 +399,20 @@\n+    \/**\n+     * Max number of times a command can be repeated.\n+     *\/\n+    String MAX_REPEAT_COUNT = \"max-repeat-count\";\n+\n+    \/**\n+     * Number of spaces to display a tabulation, the default is 4.\n+     *\/\n+    String TAB_WIDTH = \"tab-width\";\n+\n+    \/**\n+     * Name of inputrc to read at line reader creation time.\n+     *\/\n+    String INPUT_RC_FILE_NAME = \"input-rc-file-name\";\n+\n+    \/**\n+     * Prefix to automatically delegate variables to system properties\n+     *\/\n+    String SYSTEM_PROPERTY_PREFIX = \"system-property-prefix\";\n+\n@@ -472,2 +498,1 @@\n-        DISABLE_UNDO\n-        ;\n+        DISABLE_UNDO;\n@@ -614,1 +639,2 @@\n-    String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException;\n+    String readLine(String prompt, String rightPrompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException;\n@@ -634,1 +660,2 @@\n-    String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException;\n+    String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer)\n+            throws UserInterruptException, EndOfFileException;\n@@ -705,1 +732,1 @@\n-     * Read a mouse event when the {@link jdk.internal.org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n+     * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n@@ -754,4 +781,4 @@\n-    \/\/ JDK specific modification\n-    default void zeroOut() {\n-        throw new UnsupportedOperationException();\n-    }\n+    \/**\n+     * Clear any internal buffers.\n+     *\/\n+    void zeroOut();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -41,2 +41,1 @@\n-    private LineReaderBuilder() {\n-    }\n+    private LineReaderBuilder() {}\n@@ -91,2 +90,3 @@\n-                    Log.warn(\"The Parser of class \" + parser.getClass().getName() + \" does not support the CompletingParsedLine interface. \" +\n-                            \"Completion with escaped or quoted words won't work correctly.\");\n+                    Log.warn(\"The Parser of class \" + parser.getClass().getName()\n+                            + \" does not support the CompletingParsedLine interface. \"\n+                            + \"Completion with escaped or quoted words won't work correctly.\");\n@@ -156,1 +156,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -38,2 +38,1 @@\n-        return \"Macro[\" +\n-                sequence + ']';\n+        return \"Macro[\" + sequence + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Macro.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -34,1 +34,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/MaskingCallback.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -67,1 +67,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ParsedLine.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -38,1 +38,1 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+|$)\");\n+        Pattern patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+|$)\");\n@@ -53,1 +53,1 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*(\" + REGEX_VARIABLE + \")\\\\s*=[^=~].*\");\n+        Pattern patternCommand = Pattern.compile(\"^\\\\s*(\" + REGEX_VARIABLE + \")\\\\s*=[^=~].*\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/PrintAboveWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -41,2 +41,1 @@\n-        return \"Reference[\" +\n-                name + ']';\n+        return \"Reference[\" + name + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Reference.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,7 +2,1 @@\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Copyright (c) 2023, the original author(s).\n@@ -10,1 +4,2 @@\n- *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -12,6 +7,1 @@\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/SyntaxError.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,3 +17,1 @@\n-public class UserInterruptException\n-    extends RuntimeException\n-{\n+public class UserInterruptException extends RuntimeException {\n@@ -24,2 +22,1 @@\n-    public UserInterruptException(String partialLine)\n-    {\n+    public UserInterruptException(String partialLine) {\n@@ -32,2 +29,1 @@\n-    public String getPartialLine()\n-    {\n+    public String getPartialLine() {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/UserInterruptException.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -18,1 +18,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Widget.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -23,2 +23,1 @@\n-public class BufferImpl implements Buffer\n-{\n+public class BufferImpl implements Buffer {\n@@ -49,1 +48,1 @@\n-    public BufferImpl copy () {\n+    public BufferImpl copy() {\n@@ -110,1 +109,1 @@\n-        write(new int[] { c });\n+        write(new int[] {c});\n@@ -124,1 +123,1 @@\n-        write(new int[] { c });\n+        write(new int[] {c});\n@@ -227,2 +226,1 @@\n-        }\n-        else if ((cursor + where) > length()) {\n+        } else if ((cursor + where) > length()) {\n@@ -374,1 +372,0 @@\n-    \/\/ JDK specific modification\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/BufferImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -11,6 +11,0 @@\n-import jdk.internal.org.jline.reader.Candidate;\n-import jdk.internal.org.jline.reader.CompletingParsedLine;\n-import jdk.internal.org.jline.reader.CompletionMatcher;\n-import jdk.internal.org.jline.reader.LineReader;\n-import jdk.internal.org.jline.utils.AttributedString;\n-\n@@ -23,0 +17,6 @@\n+import jdk.internal.org.jline.reader.Candidate;\n+import jdk.internal.org.jline.reader.CompletingParsedLine;\n+import jdk.internal.org.jline.reader.CompletionMatcher;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.utils.AttributedString;\n+\n@@ -29,2 +29,1 @@\n-    public CompletionMatcherImpl() {\n-    }\n+    public CompletionMatcherImpl() {}\n@@ -40,2 +39,7 @@\n-    public void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName) {\n+    public void compile(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName) {\n@@ -50,2 +54,1 @@\n-        for (Function<Map<String, List<Candidate>>,\n-                Map<String, List<Candidate>>> matcher : matchers) {\n+        for (Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> matcher : matchers) {\n@@ -57,2 +60,6 @@\n-        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).distinct().collect(Collectors.toList())\n-                                   : new ArrayList<>();\n+        return !matching.isEmpty()\n+                ? matching.entrySet().stream()\n+                        .flatMap(e -> e.getValue().stream())\n+                        .distinct()\n+                        .collect(Collectors.toList())\n+                : new ArrayList<>();\n@@ -66,1 +73,2 @@\n-        return matching.values().stream().flatMap(Collection::stream)\n+        return matching.values().stream()\n+                .flatMap(Collection::stream)\n@@ -69,1 +77,2 @@\n-                .findFirst().orElse(null);\n+                .findFirst()\n+                .orElse(null);\n@@ -87,2 +96,7 @@\n-    protected void defaultMatchers(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName) {\n+    protected void defaultMatchers(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName) {\n@@ -97,2 +111,1 @@\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp))\n-            ));\n+                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp))));\n@@ -112,3 +125,4 @@\n-                        simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),\n-                        simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches())\n-                ));\n+                        simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s)\n+                                .matches()),\n+                        simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s)\n+                                .matches())));\n@@ -118,2 +132,1 @@\n-                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi))\n-                ));\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi))));\n@@ -131,2 +144,2 @@\n-    protected Function<Map<String, List<Candidate>>,\n-            Map<String, List<Candidate>>> simpleMatcher(Predicate<String> predicate) {\n+    protected Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> simpleMatcher(\n+            Predicate<String> predicate) {\n@@ -138,2 +151,2 @@\n-    protected Function<Map<String, List<Candidate>>,\n-            Map<String, List<Candidate>>> typoMatcher(String word, int errors, boolean caseInsensitive, String originalGroupName) {\n+    protected Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> typoMatcher(\n+            String word, int errors, boolean caseInsensitive, String originalGroupName) {\n@@ -142,1 +155,3 @@\n-                    .filter(e -> ReaderUtils.distance(word, caseInsensitive ? e.getKey().toLowerCase() : e.getKey()) < errors)\n+                    .filter(e -> ReaderUtils.distance(\n+                                    word, caseInsensitive ? e.getKey().toLowerCase() : e.getKey())\n+                            < errors)\n@@ -181,1 +196,2 @@\n-                    .computeIfAbsent(AttributedString.fromAnsi(candidate.value()).toString(), s -> new ArrayList<>())\n+                    .computeIfAbsent(\n+                            AttributedString.fromAnsi(candidate.value()).toString(), s -> new ArrayList<>())\n@@ -209,2 +225,1 @@\n-\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":49,"deletions":34,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -35,2 +35,1 @@\n-            }\n-            else if (escaped) {\n+            } else if (escaped) {\n@@ -43,2 +42,1 @@\n-            }\n-            else if (c == '\\'') {\n+            } else if (c == '\\'') {\n@@ -47,2 +45,1 @@\n-            }\n-            else if (inQuote) {\n+            } else if (inQuote) {\n@@ -50,2 +47,1 @@\n-            }\n-            else {\n+            } else {\n@@ -54,2 +50,4 @@\n-                        \/\/ any '\\!' should be considered an expansion escape, so skip expansion and strip the escape character\n-                        \/\/ a leading '\\^' should be considered an expansion escape, so skip expansion and strip the escape character\n+                        \/\/ any '\\!' should be considered an expansion escape, so skip expansion and strip the escape\n+                        \/\/ character\n+                        \/\/ a leading '\\^' should be considered an expansion escape, so skip expansion and strip the\n+                        \/\/ escape character\n@@ -94,1 +92,2 @@\n-                                    String previous = history.get(history.index() - 1).trim();\n+                                    String previous =\n+                                            history.get(history.index() - 1).trim();\n@@ -131,1 +130,2 @@\n-                                        throw new IllegalArgumentException((neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n+                                        throw new IllegalArgumentException(\n+                                                (neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n@@ -135,1 +135,3 @@\n-                                    } else if (!neg && idx > history.index() - history.size() && idx <= history.index()) {\n+                                    } else if (!neg\n+                                            && idx > history.index() - history.size()\n+                                            && idx <= history.index()) {\n@@ -138,1 +140,2 @@\n-                                        throw new IllegalArgumentException((neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n+                                        throw new IllegalArgumentException(\n+                                                (neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultExpander.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -13,0 +13,1 @@\n+import jdk.internal.org.jline.reader.Highlighter;\n@@ -15,1 +16,0 @@\n-import jdk.internal.org.jline.reader.Highlighter;\n@@ -60,1 +60,2 @@\n-                while (negativeEnd < reader.getBuffer().length() - 1 && reader.getBuffer().atChar(negativeEnd + 1) != '\\n') {\n+                while (negativeEnd < reader.getBuffer().length() - 1\n+                        && reader.getBuffer().atChar(negativeEnd + 1) != '\\n') {\n@@ -107,1 +108,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultHighlighter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,4 +24,4 @@\n-        ROUND,   \/\/ ()\n-        CURLY,   \/\/ {}\n-        SQUARE,  \/\/ []\n-        ANGLE    \/\/ <>\n+        ROUND, \/\/ ()\n+        CURLY, \/\/ {}\n+        SQUARE, \/\/ []\n+        ANGLE \/\/ <>\n@@ -33,0 +33,1 @@\n+\n@@ -34,2 +35,1 @@\n-            if (start == null || end == null\n-              || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n+            if (start == null || end == null || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n@@ -188,16 +188,16 @@\n-                case ROUND:\n-                    openingBrackets[i] = '(';\n-                    closingBrackets[i] = ')';\n-                    break;\n-                case CURLY:\n-                    openingBrackets[i] = '{';\n-                    closingBrackets[i] = '}';\n-                    break;\n-                case SQUARE:\n-                    openingBrackets[i] = '[';\n-                    closingBrackets[i] = ']';\n-                    break;\n-                case ANGLE:\n-                    openingBrackets[i] = '<';\n-                    closingBrackets[i] = '>';\n-                    break;\n+                    case ROUND:\n+                        openingBrackets[i] = '(';\n+                        closingBrackets[i] = ')';\n+                        break;\n+                    case CURLY:\n+                        openingBrackets[i] = '{';\n+                        closingBrackets[i] = '}';\n+                        break;\n+                    case SQUARE:\n+                        openingBrackets[i] = '[';\n+                        closingBrackets[i] = ']';\n+                        break;\n+                    case ANGLE:\n+                        openingBrackets[i] = '<';\n+                        closingBrackets[i] = '>';\n+                        break;\n@@ -232,1 +232,0 @@\n-\n@@ -299,1 +298,1 @@\n-                if (current.length()==0) {\n+                if (current.length() == 0) {\n@@ -327,1 +326,2 @@\n-                    rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                    rawWordLength = handleDelimiterAndGetRawWordLength(\n+                            current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n@@ -333,1 +333,2 @@\n-                } else if (quoteStart < 0 && !lineCommented\n+                } else if (quoteStart < 0\n+                        && !lineCommented\n@@ -342,1 +343,2 @@\n-                        rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                        rawWordLength = handleDelimiterAndGetRawWordLength(\n+                                current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n@@ -346,2 +348,1 @@\n-                } else if (quoteStart < 0 && !lineCommented\n-                        && isCommentDelim(line, i, blockCommentEnd)) {\n+                } else if (quoteStart < 0 && !lineCommented && isCommentDelim(line, i, blockCommentEnd)) {\n@@ -380,2 +381,2 @@\n-                throw new EOFError(-1, -1, \"Missing closing quote\", line.charAt(quoteStart) == '\\''\n-                        ? \"quote\" : \"dquote\");\n+                throw new EOFError(\n+                        -1, -1, \"Missing closing quote\", line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n@@ -384,2 +385,1 @@\n-                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\",\n-                        \"add: \" + blockCommentEnd);\n+                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\", \"add: \" + blockCommentEnd);\n@@ -388,2 +388,1 @@\n-                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\",\n-                        \"missing: \" + blockCommentStart);\n+                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\", \"missing: \" + blockCommentStart);\n@@ -401,2 +400,7 @@\n-                throw new EOFError(-1, -1, message, missing,\n-                        bracketChecker.getOpenBrackets(), bracketChecker.getNextClosingBracket());\n+                throw new EOFError(\n+                        -1,\n+                        -1,\n+                        message,\n+                        missing,\n+                        bracketChecker.getOpenBrackets(),\n+                        bracketChecker.getNextClosingBracket());\n@@ -423,1 +427,7 @@\n-    private int handleDelimiterAndGetRawWordLength(StringBuilder current, List<String> words, int rawWordStart, int rawWordCursor, int rawWordLength, int pos) {\n+    private int handleDelimiterAndGetRawWordLength(\n+            StringBuilder current,\n+            List<String> words,\n+            int rawWordStart,\n+            int rawWordCursor,\n+            int rawWordLength,\n+            int pos) {\n@@ -473,1 +483,1 @@\n-            for (String comment: lineCommentDelims) {\n+            for (String comment : lineCommentDelims) {\n@@ -587,2 +597,2 @@\n-                    if (!nested.isEmpty() && bid == nested.get(nested.size()-1)) {\n-                        nested.remove(nested.size()-1);\n+                    if (!nested.isEmpty() && bid == nested.get(nested.size() - 1)) {\n+                        nested.remove(nested.size() - 1);\n@@ -637,1 +647,1 @@\n-            for (int i=0; i < brackets.length; i++) {\n+            for (int i = 0; i < brackets.length; i++) {\n@@ -651,2 +661,1 @@\n-    public class ArgumentList implements ParsedLine, CompletingParsedLine\n-    {\n+    public class ArgumentList implements ParsedLine, CompletingParsedLine {\n@@ -670,5 +679,15 @@\n-        public ArgumentList(final String line, final List<String> words,\n-                            final int wordIndex, final int wordCursor,\n-                            final int cursor) {\n-            this(line, words, wordIndex, wordCursor, cursor,\n-                    null, wordCursor, words.get(wordIndex).length());\n+        public ArgumentList(\n+                final String line,\n+                final List<String> words,\n+                final int wordIndex,\n+                final int wordCursor,\n+                final int cursor) {\n+            this(\n+                    line,\n+                    words,\n+                    wordIndex,\n+                    wordCursor,\n+                    cursor,\n+                    null,\n+                    wordCursor,\n+                    words.get(wordIndex).length());\n@@ -688,4 +707,9 @@\n-        public ArgumentList(final String line, final List<String> words,\n-                            final int wordIndex, final int wordCursor,\n-                            final int cursor, final String openingQuote,\n-                            final int rawWordCursor, final int rawWordLength) {\n+        public ArgumentList(\n+                final String line,\n+                final List<String> words,\n+                final int wordIndex,\n+                final int wordCursor,\n+                final int cursor,\n+                final String openingQuote,\n+                final int rawWordCursor,\n+                final int rawWordLength) {\n@@ -735,2 +759,2 @@\n-            if (openingQuote==null) {\n-                for (int i=0; i < sb.length(); i++) {\n+            if (openingQuote == null) {\n+                for (int i = 0; i < sb.length(); i++) {\n@@ -749,1 +773,2 @@\n-                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);\n+                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i))\n+                                || String.valueOf(sb.charAt(i)).equals(openingQuote);\n@@ -759,2 +784,2 @@\n-                        needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i))\n-                                || isRawQuoteChar(sb.charAt(i));\n+                        needToBeEscaped = i ->\n+                                isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));\n@@ -795,1 +820,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":84,"deletions":60,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2002-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader.impl;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.reader.Macro;\n+import jdk.internal.org.jline.reader.Reference;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.Log;\n+\n+public final class InputRC {\n+\n+    public static void configure(LineReader reader, URL url) throws IOException {\n+        try (InputStream is = url.openStream()) {\n+            configure(reader, is);\n+        }\n+    }\n+\n+    public static void configure(LineReader reader, InputStream is) throws IOException {\n+        try (InputStreamReader r = new InputStreamReader(is)) {\n+            configure(reader, r);\n+        }\n+    }\n+\n+    public static void configure(LineReader reader, Reader r) throws IOException {\n+        BufferedReader br;\n+        if (r instanceof BufferedReader) {\n+            br = (BufferedReader) r;\n+        } else {\n+            br = new BufferedReader(r);\n+        }\n+\n+        Terminal terminal = reader.getTerminal();\n+\n+        if (Terminal.TYPE_DUMB.equals(terminal.getType()) || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType())) {\n+            reader.getVariables().putIfAbsent(LineReader.EDITING_MODE, \"dumb\");\n+        } else {\n+            reader.getVariables().putIfAbsent(LineReader.EDITING_MODE, \"emacs\");\n+        }\n+\n+        reader.setKeyMap(LineReader.MAIN);\n+        new InputRC(reader).parse(br);\n+        if (\"vi\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.VIINS));\n+        } else if (\"emacs\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.EMACS));\n+        } else if (\"dumb\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.DUMB));\n+        }\n+    }\n+\n+    private final LineReader reader;\n+\n+    private InputRC(LineReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    private void parse(BufferedReader br) throws IOException, IllegalArgumentException {\n+        String line;\n+        boolean parsing = true;\n+        List<Boolean> ifsStack = new ArrayList<>();\n+        while ((line = br.readLine()) != null) {\n+            try {\n+                line = line.trim();\n+                if (line.length() == 0) {\n+                    continue;\n+                }\n+                if (line.charAt(0) == '#') {\n+                    continue;\n+                }\n+                int i = 0;\n+                if (line.charAt(i) == '$') {\n+                    String cmd;\n+                    String args;\n+                    ++i;\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    cmd = line.substring(s, i);\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    args = line.substring(s, i);\n+                    if (\"if\".equalsIgnoreCase(cmd)) {\n+                        ifsStack.add(parsing);\n+                        if (!parsing) {\n+                            continue;\n+                        }\n+                        if (args.startsWith(\"term=\")) {\n+                            \/\/ TODO\n+                        } else if (args.startsWith(\"mode=\")) {\n+                            String mode = (String) reader.getVariable(LineReader.EDITING_MODE);\n+                            parsing = args.substring(\"mode=\".length()).equalsIgnoreCase(mode);\n+                        } else {\n+                            parsing = args.equalsIgnoreCase(reader.getAppName());\n+                        }\n+                    } else if (\"else\".equalsIgnoreCase(cmd)) {\n+                        if (ifsStack.isEmpty()) {\n+                            throw new IllegalArgumentException(\"$else found without matching $if\");\n+                        }\n+                        boolean invert = true;\n+                        for (boolean b : ifsStack) {\n+                            if (!b) {\n+                                invert = false;\n+                                break;\n+                            }\n+                        }\n+                        if (invert) {\n+                            parsing = !parsing;\n+                        }\n+                    } else if (\"endif\".equalsIgnoreCase(cmd)) {\n+                        if (ifsStack.isEmpty()) {\n+                            throw new IllegalArgumentException(\"endif found without matching $if\");\n+                        }\n+                        parsing = ifsStack.remove(ifsStack.size() - 1);\n+                    } else if (\"include\".equalsIgnoreCase(cmd)) {\n+                        \/\/ TODO\n+                    }\n+                    continue;\n+                }\n+                if (!parsing) {\n+                    continue;\n+                }\n+                if (line.charAt(i++) == '\"') {\n+                    boolean esc = false;\n+                    for (; ; i++) {\n+                        if (i >= line.length()) {\n+                            throw new IllegalArgumentException(\"Missing closing quote on line '\" + line + \"'\");\n+                        }\n+                        if (esc) {\n+                            esc = false;\n+                        } else if (line.charAt(i) == '\\\\') {\n+                            esc = true;\n+                        } else if (line.charAt(i) == '\"') {\n+                            break;\n+                        }\n+                    }\n+                }\n+                while (i < line.length() && line.charAt(i) != ':' && line.charAt(i) != ' ' && line.charAt(i) != '\\t') {\n+                    i++;\n+                }\n+                String keySeq = line.substring(0, i);\n+                boolean equivalency = i + 1 < line.length() && line.charAt(i) == ':' && line.charAt(i + 1) == '=';\n+                i++;\n+                if (equivalency) {\n+                    i++;\n+                }\n+                if (keySeq.equalsIgnoreCase(\"set\")) {\n+                    String key;\n+                    String val;\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    key = line.substring(s, i);\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    val = line.substring(s, i);\n+                    setVar(reader, key, val);\n+                } else {\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int start = i;\n+                    if (i < line.length() && (line.charAt(i) == '\\'' || line.charAt(i) == '\\\"')) {\n+                        char delim = line.charAt(i++);\n+                        boolean esc = false;\n+                        for (; ; i++) {\n+                            if (i >= line.length()) {\n+                                break;\n+                            }\n+                            if (esc) {\n+                                esc = false;\n+                            } else if (line.charAt(i) == '\\\\') {\n+                                esc = true;\n+                            } else if (line.charAt(i) == delim) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    for (; i < line.length() && line.charAt(i) != ' ' && line.charAt(i) != '\\t'; i++)\n+                        ;\n+                    String val = line.substring(Math.min(start, line.length()), Math.min(i, line.length()));\n+                    if (keySeq.charAt(0) == '\"') {\n+                        keySeq = translateQuoted(keySeq);\n+                    } else {\n+                        \/\/ Bind key name\n+                        String keyName =\n+                                keySeq.lastIndexOf('-') > 0 ? keySeq.substring(keySeq.lastIndexOf('-') + 1) : keySeq;\n+                        char key = getKeyFromName(keyName);\n+                        keyName = keySeq.toLowerCase();\n+                        keySeq = \"\";\n+                        if (keyName.contains(\"meta-\") || keyName.contains(\"m-\")) {\n+                            keySeq += \"\\u001b\";\n+                        }\n+                        if (keyName.contains(\"control-\") || keyName.contains(\"c-\") || keyName.contains(\"ctrl-\")) {\n+                            key = (char) (Character.toUpperCase(key) & 0x1f);\n+                        }\n+                        keySeq += key;\n+                    }\n+                    if (val.length() > 0 && (val.charAt(0) == '\\'' || val.charAt(0) == '\\\"')) {\n+                        reader.getKeys().bind(new Macro(translateQuoted(val)), keySeq);\n+                    } else {\n+                        reader.getKeys().bind(new Reference(val), keySeq);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                Log.warn(\"Unable to parse user configuration: \", e);\n+            }\n+        }\n+    }\n+\n+    private static String translateQuoted(String keySeq) {\n+        int i;\n+        String str = keySeq.substring(1, keySeq.length() - 1);\n+        StringBuilder sb = new StringBuilder();\n+        for (i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            if (c == '\\\\') {\n+                boolean ctrl = str.regionMatches(i, \"\\\\C-\", 0, 3) || str.regionMatches(i, \"\\\\M-\\\\C-\", 0, 6);\n+                boolean meta = str.regionMatches(i, \"\\\\M-\", 0, 3) || str.regionMatches(i, \"\\\\C-\\\\M-\", 0, 6);\n+                i += (meta ? 3 : 0) + (ctrl ? 3 : 0) + (!meta && !ctrl ? 1 : 0);\n+                if (i >= str.length()) {\n+                    break;\n+                }\n+                c = str.charAt(i);\n+                if (meta) {\n+                    sb.append(\"\\u001b\");\n+                }\n+                if (ctrl) {\n+                    c = c == '?' ? 0x7f : (char) (Character.toUpperCase(c) & 0x1f);\n+                }\n+                if (!meta && !ctrl) {\n+                    switch (c) {\n+                        case 'a':\n+                            c = 0x07;\n+                            break;\n+                        case 'b':\n+                            c = '\\b';\n+                            break;\n+                        case 'd':\n+                            c = 0x7f;\n+                            break;\n+                        case 'e':\n+                            c = 0x1b;\n+                            break;\n+                        case 'f':\n+                            c = '\\f';\n+                            break;\n+                        case 'n':\n+                            c = '\\n';\n+                            break;\n+                        case 'r':\n+                            c = '\\r';\n+                            break;\n+                        case 't':\n+                            c = '\\t';\n+                            break;\n+                        case 'v':\n+                            c = 0x0b;\n+                            break;\n+                        case '\\\\':\n+                            c = '\\\\';\n+                            break;\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                            c = 0;\n+                            for (int j = 0; j < 3; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 8);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 8 + k);\n+                            }\n+                            c &= 0xFF;\n+                            break;\n+                        case 'x':\n+                            i++;\n+                            c = 0;\n+                            for (int j = 0; j < 2; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 16);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 16 + k);\n+                            }\n+                            c &= 0xFF;\n+                            break;\n+                        case 'u':\n+                            i++;\n+                            c = 0;\n+                            for (int j = 0; j < 4; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 16);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 16 + k);\n+                            }\n+                            break;\n+                    }\n+                }\n+                sb.append(c);\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static char getKeyFromName(String name) {\n+        if (\"DEL\".equalsIgnoreCase(name) || \"Rubout\".equalsIgnoreCase(name)) {\n+            return 0x7f;\n+        } else if (\"ESC\".equalsIgnoreCase(name) || \"Escape\".equalsIgnoreCase(name)) {\n+            return '\\033';\n+        } else if (\"LFD\".equalsIgnoreCase(name) || \"NewLine\".equalsIgnoreCase(name)) {\n+            return '\\n';\n+        } else if (\"RET\".equalsIgnoreCase(name) || \"Return\".equalsIgnoreCase(name)) {\n+            return '\\r';\n+        } else if (\"SPC\".equalsIgnoreCase(name) || \"Space\".equalsIgnoreCase(name)) {\n+            return ' ';\n+        } else if (\"Tab\".equalsIgnoreCase(name)) {\n+            return '\\t';\n+        } else {\n+            return name.charAt(0);\n+        }\n+    }\n+\n+    static void setVar(LineReader reader, String key, String val) {\n+        if (LineReader.KEYMAP.equalsIgnoreCase(key)) {\n+            reader.setKeyMap(val);\n+            return;\n+        }\n+\n+        for (LineReader.Option option : LineReader.Option.values()) {\n+            if (option.name().toLowerCase(Locale.ENGLISH).replace('_', '-').equals(val)) {\n+                if (\"on\".equalsIgnoreCase(val)) {\n+                    reader.setOpt(option);\n+                } else if (\"off\".equalsIgnoreCase(val)) {\n+                    reader.unsetOpt(option);\n+                }\n+                return;\n+            }\n+        }\n+\n+        reader.setVariable(key, val);\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/InputRC.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/KillRing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2022, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -21,0 +21,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -59,0 +62,1 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -69,2 +73,1 @@\n-public class LineReaderImpl implements LineReader, Flushable\n-{\n+public class LineReaderImpl implements LineReader, Flushable {\n@@ -73,0 +76,4 @@\n+    \/**\n+     * @deprecated use {@link #DEFAULT_TAB_WIDTH} and {@link #getTabWidth()}\n+     *\/\n+    @Deprecated\n@@ -75,0 +82,1 @@\n+    public static final int DEFAULT_TAB_WIDTH = 4;\n@@ -81,5 +89,5 @@\n-    public static final int    DEFAULT_LIST_MAX = 100;\n-    public static final int    DEFAULT_MENU_LIST_MAX = Integer.MAX_VALUE;\n-    public static final int    DEFAULT_ERRORS = 2;\n-    public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;\n-    public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;\n+    public static final int DEFAULT_LIST_MAX = 100;\n+    public static final int DEFAULT_MENU_LIST_MAX = Integer.MAX_VALUE;\n+    public static final int DEFAULT_ERRORS = 2;\n+    public static final long DEFAULT_BLINK_MATCHING_PAREN = 500L;\n+    public static final long DEFAULT_AMBIGUOUS_BINDING = 1000L;\n@@ -99,3 +107,4 @@\n-    public static final int    DEFAULT_INDENTATION = 0;\n-    public static final int    DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;\n-    public static final int    DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE = 1;\n+    public static final int DEFAULT_INDENTATION = 0;\n+    public static final int DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;\n+    public static final int DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE = 1;\n+    public static final String DEFAULT_SYSTEM_PROPERTY_PREFIX = \"org.jline.reader.props.\";\n@@ -112,0 +121,1 @@\n+    public static final int DEFAULT_MAX_REPEAT_COUNT = 9999;\n@@ -200,1 +210,0 @@\n-\n@@ -204,1 +213,0 @@\n-\n@@ -209,0 +217,1 @@\n+\n@@ -215,0 +224,1 @@\n+\n@@ -221,0 +231,1 @@\n+\n@@ -235,1 +246,1 @@\n-    protected UndoTree<Buffer> undo = new UndoTree<>(this::setBuffer);\n+    protected UndoTree<Buffer> undo;\n@@ -245,1 +256,1 @@\n-    protected State   state = State.DONE;\n+    protected State state = State.DONE;\n@@ -281,1 +292,4 @@\n-    int candidateStartPosition = 0;\n+    protected int candidateStartPosition = 0;\n+\n+    protected String alternateIn;\n+    protected String alternateOut;\n@@ -291,0 +305,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -303,0 +318,11 @@\n+        String prefix = getString(SYSTEM_PROPERTY_PREFIX, DEFAULT_SYSTEM_PROPERTY_PREFIX);\n+        if (prefix != null) {\n+            Properties sysProps = System.getProperties();\n+            for (String s : sysProps.stringPropertyNames()) {\n+                if (s.startsWith(prefix)) {\n+                    String key = s.substring(prefix.length());\n+                    InputRC.setVar(this, key, sysProps.getProperty(s));\n+                }\n+            }\n+        }\n+\n@@ -304,0 +330,4 @@\n+        if (!Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET)) {\n+            this.alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));\n+            this.alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));\n+        }\n@@ -305,0 +335,1 @@\n+        undo = new UndoTree<>(this::setBuffer);\n@@ -308,0 +339,13 @@\n+\n+        String inputRc = getString(INPUT_RC_FILE_NAME, null);\n+        if (inputRc != null) {\n+            Path inputRcPath = Paths.get(inputRc);\n+            if (Files.exists(inputRcPath)) {\n+                try (InputStream is = Files.newInputStream(inputRcPath)) {\n+                    InputRC.configure(this, is);\n+                } catch (Exception e) {\n+                    Log.debug(\"Error reading inputRc config file: \", inputRc, e);\n+                }\n+            }\n+        }\n+\n@@ -492,1 +536,2 @@\n-    public String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -506,1 +551,2 @@\n-    public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, String rightPrompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -520,1 +566,2 @@\n-    public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -621,11 +668,3 @@\n-                    if (isSet(Option.AUTO_FRESH_LINE))\n-                        callWidget(FRESH_LINE);\n-                    if (isSet(Option.MOUSE))\n-                        terminal.trackMouse(Terminal.MouseTracking.Normal);\n-                    if (isSet(Option.BRACKETED_PASTE))\n-                        terminal.writer().write(BRACKETED_PASTE_ON);\n-                } else {\n-                    \/\/ For dumb terminals, we need to make sure that CR are ignored\n-                    Attributes attr = new Attributes(originalAttributes);\n-                    attr.setInputFlag(Attributes.InputFlag.IGNCR, true);\n-                    terminal.setAttributes(attr);\n+                    if (isSet(Option.AUTO_FRESH_LINE)) callWidget(FRESH_LINE);\n+                    if (isSet(Option.MOUSE)) terminal.trackMouse(Terminal.MouseTracking.Normal);\n+                    if (isSet(Option.BRACKETED_PASTE)) terminal.writer().write(BRACKETED_PASTE_ON);\n@@ -636,2 +675,1 @@\n-                if (!isSet(Option.DISABLE_UNDO))\n-                    undo.newState(buf.copy());\n+                if (!isSet(Option.DISABLE_UNDO)) undo.newState(buf.copy());\n@@ -657,1 +695,2 @@\n-                if (buf.length() == 0 && getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {\n+                if (buf.length() == 0\n+                        && getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {\n@@ -678,1 +717,3 @@\n-                    Buffer copy = buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE) ? buf.copy() : null;\n+                    Buffer copy = buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                            ? buf.copy()\n+                            : null;\n@@ -683,1 +724,4 @@\n-                    if (!isSet(Option.DISABLE_UNDO) && !isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                    if (!isSet(Option.DISABLE_UNDO)\n+                            && !isUndo\n+                            && copy != null\n+                            && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n@@ -721,2 +765,2 @@\n-        }\n-        finally {\n+        } finally {\n+            AtomicBoolean interrupted = new AtomicBoolean(Thread.interrupted());\n@@ -728,0 +772,5 @@\n+                Terminal.SignalHandler tmpHandler = terminal.handle(Signal.INT, s -> interrupted.set(true));\n+                if (previousIntrHandler == null) {\n+                    previousIntrHandler = tmpHandler;\n+                }\n+\n@@ -744,0 +793,3 @@\n+                if (interrupted.get()) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -749,2 +801,1 @@\n-        return Terminal.TYPE_DUMB.equals(terminal.getType())\n-                || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());\n+        return Terminal.TYPE_DUMB.equals(terminal.getType()) || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());\n@@ -760,2 +811,1 @@\n-        if (isSet(Option.DELAY_LINE_WRAP))\n-            display.setDelayLineWrap(true);\n+        if (isSet(Option.DELAY_LINE_WRAP)) display.setDelayLineWrap(true);\n@@ -968,2 +1018,4 @@\n-            if (!KILL_LINE.equals(ref) && !KILL_WHOLE_LINE.equals(ref)\n-                    && !BACKWARD_KILL_WORD.equals(ref) && !KILL_WORD.equals(ref)) {\n+            if (!KILL_LINE.equals(ref)\n+                    && !KILL_WHOLE_LINE.equals(ref)\n+                    && !BACKWARD_KILL_WORD.equals(ref)\n+                    && !KILL_WORD.equals(ref)) {\n@@ -1086,1 +1138,1 @@\n-        Constructor<?> ctor = Class.forName(\"jdk.internal.org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n@@ -1100,0 +1152,4 @@\n+    protected int getTabWidth() {\n+        return getInt(LineReader.TAB_WIDTH, DEFAULT_TAB_WIDTH);\n+    }\n+\n@@ -1140,1 +1196,1 @@\n-        if (historyLine != null && historyLine.length() > 0 ) {\n+        if (historyLine != null && historyLine.length() > 0) {\n@@ -1146,1 +1202,1 @@\n-    protected void handleSignal(Signal signal) {\n+    protected synchronized void handleSignal(Signal signal) {\n@@ -1149,0 +1205,2 @@\n+            size.copy(terminal.getBufferSize());\n+            display.resize(size.getRows(), size.getColumns());\n@@ -1151,1 +1209,2 @@\n-                status.hardReset();\n+                status.resize(size);\n+                status.reset();\n@@ -1153,4 +1212,3 @@\n-            size.copy(terminal.getBufferSize());\n-            display.resize(size.getRows(), size.getColumns());\n-            \/\/ restores prompt but also prevents scrolling in consoleZ, see #492\n-            \/\/ redrawLine();\n+            terminal.puts(Capability.carriage_return);\n+            terminal.puts(Capability.clr_eos);\n+            redrawLine();\n@@ -1158,2 +1216,1 @@\n-        }\n-        else if (signal == Signal.CONT) {\n+        } else if (signal == Signal.CONT) {\n@@ -1203,2 +1260,1 @@\n-        this.prompt = (prompt == null ? AttributedString.EMPTY\n-                       : expandPromptPattern(prompt, 0, \"\", 0));\n+        this.prompt = (prompt == null ? AttributedString.EMPTY : expandPromptPattern(prompt, 0, \"\", 0));\n@@ -1208,2 +1264,1 @@\n-        this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY\n-                            : expandPromptPattern(rightPrompt, 0, \"\", 0));\n+        this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY : expandPromptPattern(rightPrompt, 0, \"\", 0));\n@@ -1236,1 +1291,1 @@\n-    protected String viDeleteChangeYankToRemap (String op) {\n+    protected String viDeleteChangeYankToRemap(String op) {\n@@ -1295,1 +1350,0 @@\n-\n@@ -1335,1 +1389,0 @@\n-\n@@ -1368,3 +1421,1 @@\n-                while (buf.cursor() < buf.length()\n-                        && !isViAlphaNum(buf.currChar())\n-                        && !isWhitespace(buf.currChar())) {\n+                while (buf.cursor() < buf.length() && !isViAlphaNum(buf.currChar()) && !isWhitespace(buf.currChar())) {\n@@ -1378,3 +1429,1 @@\n-            while (buf.cursor() < buf.length()\n-                    && nl < 2\n-                    && isWhitespace(buf.currChar())) {\n+            while (buf.cursor() < buf.length() && nl < 2 && isWhitespace(buf.currChar())) {\n@@ -1400,3 +1449,1 @@\n-            while (buf.cursor() < buf.length()\n-                    && nl < 2\n-                    && isWhitespace(buf.currChar())) {\n+            while (buf.cursor() < buf.length() && nl < 2 && isWhitespace(buf.currChar())) {\n@@ -1454,1 +1501,3 @@\n-                    while (buf.cursor() < buf.length() && !isViAlphaNum(buf.nextChar()) && !isWhitespace(buf.nextChar())) {\n+                    while (buf.cursor() < buf.length()\n+                            && !isViAlphaNum(buf.nextChar())\n+                            && !isWhitespace(buf.nextChar())) {\n@@ -1723,3 +1772,1 @@\n-                buf.currChar(first\n-                        ? Character.toUpperCase(buf.currChar())\n-                        : Character.toLowerCase(buf.currChar()));\n+                buf.currChar(first ? Character.toUpperCase(buf.currChar()) : Character.toLowerCase(buf.currChar()));\n@@ -1813,1 +1860,2 @@\n-            while (end1 < lend && !isDelimiter(buf.atChar(++end1)));\n+            while (end1 < lend && !isDelimiter(buf.atChar(++end1)))\n+                ;\n@@ -1822,1 +1870,2 @@\n-                    while (isDelimiter(buf.atChar(++sta2)));\n+                    while (isDelimiter(buf.atChar(++sta2)))\n+                        ;\n@@ -1824,1 +1873,2 @@\n-                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)));\n+                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)))\n+                        ;\n@@ -1833,1 +1883,2 @@\n-                while (sta2 < lend && isDelimiter(buf.atChar(++sta2)));\n+                while (sta2 < lend && isDelimiter(buf.atChar(++sta2)))\n+                    ;\n@@ -1846,1 +1897,2 @@\n-                    while (end2 < lend && !isDelimiter(buf.atChar(++end2))) ;\n+                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)))\n+                        ;\n@@ -1850,2 +1902,4 @@\n-                String res = buf.substring(0, sta1) + buf.substring(sta2, end2)\n-                        + buf.substring(end1, sta2) + buf.substring(sta1, end1)\n+                String res = buf.substring(0, sta1)\n+                        + buf.substring(sta2, end2)\n+                        + buf.substring(end1, sta2)\n+                        + buf.substring(sta1, end1)\n@@ -1857,2 +1911,4 @@\n-                String res = buf.substring(0, sta2) + buf.substring(sta1, end1)\n-                        + buf.substring(end2, sta1) + buf.substring(sta2, end2)\n+                String res = buf.substring(0, sta2)\n+                        + buf.substring(sta1, end1)\n+                        + buf.substring(end2, sta1)\n+                        + buf.substring(sta2, end2)\n@@ -1991,1 +2047,2 @@\n-            } while (buf.cursor() > 0 && buf.cursor() < buf.length()\n+            } while (buf.cursor() > 0\n+                    && buf.cursor() < buf.length()\n@@ -1994,2 +2051,1 @@\n-            if (buf.cursor() <= 0 || buf.cursor() >= buf.length()\n-                    || buf.currChar() == '\\n') {\n+            if (buf.cursor() <= 0 || buf.cursor() >= buf.length() || buf.currChar() == '\\n') {\n@@ -2214,1 +2270,1 @@\n-        int pos        = buf.cursor();\n+        int pos = buf.cursor();\n@@ -2220,3 +2276,3 @@\n-        int type       = getBracketType(buf.atChar(pos));\n-        int move       = (type < 0) ? -1 : 1;\n-        int count      = 1;\n+        int type = getBracketType(buf.atChar(pos));\n+        int move = (type < 0) ? -1 : 1;\n+        int count = 1;\n@@ -2224,2 +2280,1 @@\n-        if (type == 0)\n-            return false;\n+        if (type == 0) return false;\n@@ -2238,2 +2293,1 @@\n-            }\n-            else if (curType == -type) {\n+            } else if (curType == -type) {\n@@ -2248,2 +2302,1 @@\n-        if (move > 0 && isInViMoveOperation())\n-            ++pos;\n+        if (move > 0 && isInViMoveOperation()) ++pos;\n@@ -2262,1 +2315,1 @@\n-    protected int getBracketType (int ch) {\n+    protected int getBracketType(int ch) {\n@@ -2264,6 +2317,12 @@\n-            case '[': return  1;\n-            case ']': return -1;\n-            case '{': return  2;\n-            case '}': return -2;\n-            case '(': return  3;\n-            case ')': return -3;\n+            case '[':\n+                return 1;\n+            case ']':\n+                return -1;\n+            case '{':\n+                return 2;\n+            case '}':\n+                return -2;\n+            case '(':\n+                return 3;\n+            case ')':\n+                return -3;\n@@ -2334,1 +2393,1 @@\n-\/\/            state = State.INTERRUPT;\n+            \/\/            state = State.INTERRUPT;\n@@ -2381,0 +2440,4 @@\n+        int maxRepeatCount = getInt(MAX_REPEAT_COUNT, DEFAULT_MAX_REPEAT_COUNT);\n+        if (repeatCount > maxRepeatCount) {\n+            throw new IllegalArgumentException(\"digit argument should be less than \" + maxRepeatCount);\n+        }\n@@ -2441,1 +2504,2 @@\n-        while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+        while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+            ;\n@@ -2444,1 +2508,2 @@\n-            while (buf.move(1) == 1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(1) == 1 && buf.prevChar() != '\\n')\n+                ;\n@@ -2557,2 +2622,4 @@\n-    static class Pair<U,V> {\n-        final U u; final V v;\n+    static class Pair<U, V> {\n+        final U u;\n+        final V v;\n+\n@@ -2563,0 +2630,1 @@\n+\n@@ -2566,0 +2634,1 @@\n+\n@@ -2578,1 +2647,2 @@\n-                .codePoints().forEach(c -> bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));\n+                .codePoints()\n+                .forEach(c -> bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));\n@@ -2586,2 +2656,2 @@\n-                        + (searchBackward ? \"bck-i-search\" : \"fwd-i-search\")\n-                        + \": \" + searchTerm + \"_\");\n+                + (searchBackward ? \"bck-i-search\" : \"fwd-i-search\")\n+                + \": \" + searchTerm + \"_\");\n@@ -2633,2 +2703,3 @@\n-                    Pattern pat = Pattern.compile(pattern, caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE\n-                                                                           : Pattern.UNICODE_CASE);\n+                    Pattern pat = Pattern.compile(\n+                            pattern,\n+                            caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE : Pattern.UNICODE_CASE);\n@@ -2644,1 +2715,5 @@\n-                                    Spliterators.spliteratorUnknownSize(history.reverseIterator(searchIndex < 0 ? history.last() : searchIndex - 1), Spliterator.ORDERED), false)\n+                                            Spliterators.spliteratorUnknownSize(\n+                                                    history.reverseIterator(\n+                                                            searchIndex < 0 ? history.last() : searchIndex - 1),\n+                                                    Spliterator.ORDERED),\n+                                            false)\n@@ -2657,1 +2732,5 @@\n-                                    Spliterators.spliteratorUnknownSize(history.iterator((searchIndex < 0 ? history.last() : searchIndex) + 1), Spliterator.ORDERED), false)\n+                                            Spliterators.spliteratorUnknownSize(\n+                                                    history.iterator(\n+                                                            (searchIndex < 0 ? history.last() : searchIndex) + 1),\n+                                                    Spliterator.ORDERED),\n+                                            false)\n@@ -2717,1 +2796,4 @@\n-                sb.append(\"[\").append(Character.toLowerCase(c)).append(Character.toUpperCase(c)).append(\"]\");\n+                sb.append(\"[\")\n+                        .append(Character.toLowerCase(c))\n+                        .append(Character.toUpperCase(c))\n+                        .append(\"]\");\n@@ -2745,2 +2827,1 @@\n-        if (historyBuffer == null || buf.length() == 0\n-                || !buf.toString().equals(history.current())) {\n+        if (historyBuffer == null || buf.length() == 0 || !buf.toString().equals(history.current())) {\n@@ -2794,2 +2875,1 @@\n-        if (historyBuffer == null || buf.length() == 0\n-                || !buf.toString().equals(history.current())) {\n+        if (historyBuffer == null || buf.length() == 0 || !buf.toString().equals(history.current())) {\n@@ -2987,1 +3067,1 @@\n-        int indent = getInt(INDENTATION, DEFAULT_INDENTATION)*nb;\n+        int indent = getInt(INDENTATION, DEFAULT_INDENTATION) * nb;\n@@ -3020,1 +3100,0 @@\n-\n@@ -3111,2 +3190,1 @@\n-        return upLine()\n-                || upHistory() && viFirstNonBlank();\n+        return upLine() || upHistory() && viFirstNonBlank();\n@@ -3116,2 +3194,1 @@\n-        return downLine()\n-                || downHistory() && viFirstNonBlank();\n+        return downLine() || downHistory() && viFirstNonBlank();\n@@ -3178,2 +3255,1 @@\n-        return viChange(buf.cursor(), buf.length())\n-                && setKeyMap(VIINS);\n+        return viChange(buf.cursor(), buf.length()) && setKeyMap(VIINS);\n@@ -3202,1 +3278,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3256,1 +3333,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3263,1 +3341,2 @@\n-            while (buf.move(1) == 1 && buf.currChar() != '\\n') ;\n+            while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+                ;\n@@ -3387,1 +3466,1 @@\n-        if (! isChange && startPos > 0 && startPos == buf.length()) {\n+        if (!isChange && startPos > 0 && startPos == buf.length()) {\n@@ -3427,1 +3506,2 @@\n-        while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+        while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+            ;\n@@ -3434,1 +3514,2 @@\n-        while (buf.move(1) == 1 && buf.currChar() != '\\n') ;\n+        while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+            ;\n@@ -3446,1 +3527,2 @@\n-            while (buf.move(1) == 1 && buf.currChar() != '\\n');\n+            while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+                ;\n@@ -3449,2 +3531,2 @@\n-            buf.move(- yankBuffer.length());\n-        } else if (yankBuffer.length () != 0) {\n+            buf.move(-yankBuffer.length());\n+        } else if (yankBuffer.length() != 0) {\n@@ -3464,1 +3546,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n');\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3466,2 +3549,2 @@\n-            buf.move(- yankBuffer.length());\n-        } else if (yankBuffer.length () != 0) {\n+            buf.move(-yankBuffer.length());\n+        } else if (yankBuffer.length() != 0) {\n@@ -3684,1 +3767,1 @@\n-\/\/        addBuiltinWidget(widgets, QUIT, this::quit);\n+        \/\/        addBuiltinWidget(widgets, QUIT, this::quit);\n@@ -3777,0 +3860,1 @@\n+\n@@ -3800,3 +3884,0 @@\n-                if (terminal.getType().startsWith(AbstractWindowsTerminal.TYPE_WINDOWS)) {\n-                    status.resize();\n-                }\n@@ -3807,1 +3888,1 @@\n-                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -3880,1 +3961,1 @@\n-                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -3887,1 +3968,2 @@\n-                List<AttributedString> promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+                List<AttributedString> promptLines =\n+                        sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -3907,1 +3989,1 @@\n-                if (lineId  > cursorNewLinesId) {\n+                if (lineId > cursorNewLinesId) {\n@@ -3952,4 +4034,3 @@\n-        for (char c: buffer.replace(\"\\\\\", \"\\\\\\\\\").toCharArray()) {\n-            if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '*'\n-                     || c == '$' || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!'\n-                     || c == '-') {\n+        for (char c : buffer.replace(\"\\\\\", \"\\\\\\\\\").toCharArray()) {\n+            if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '*' || c == '$'\n+                    || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!' || c == '-') {\n@@ -3987,1 +4068,1 @@\n-        AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+        AttributedStringBuilder full = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -4043,1 +4124,2 @@\n-        if (highlighter != null && !isSet(Option.DISABLE_HIGHLIGHTER)\n+        if (highlighter != null\n+                && !isSet(Option.DISABLE_HIGHLIGHTER)\n@@ -4050,2 +4132,1 @@\n-    private AttributedString expandPromptPattern(String pattern, int padToWidth,\n-                                                 String message, int line) {\n+    private AttributedString expandPromptPattern(String pattern, int padToWidth, String message, int line) {\n@@ -4068,1 +4149,2 @@\n-                decode: while (true) {\n+                decode:\n+                while (true) {\n@@ -4076,1 +4158,1 @@\n-                                astr = AttributedString.fromAnsi(str);\n+                                astr = fromAnsi(str);\n@@ -4099,2 +4181,1 @@\n-                            if (message != null)\n-                                sb.append(message);\n+                            if (message != null) sb.append(message);\n@@ -4103,2 +4184,1 @@\n-                            if (countSeen && count >= 0)\n-                                padToWidth = count;\n+                            if (countSeen && count >= 0) padToWidth = count;\n@@ -4143,2 +4223,1 @@\n-            } else\n-                sb.append(ch);\n+            } else sb.append(ch);\n@@ -4150,3 +4229,2 @@\n-            while (--padCount >= 0)\n-                sb.insert(padPos, (char) padChar); \/\/ FIXME if wide\n-            parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));\n+            while (--padCount >= 0) sb.insert(padPos, (char) padChar); \/\/ FIXME if wide\n+            parts.set(padPartIndex, fromAnsi(sb.toString()));\n@@ -4157,0 +4235,4 @@\n+    private AttributedString fromAnsi(String str) {\n+        return AttributedString.fromAnsi(str, Collections.singletonList(0), alternateIn, alternateOut);\n+    }\n+\n@@ -4161,1 +4243,2 @@\n-    private AttributedString insertSecondaryPrompts(AttributedString strAtt, List<AttributedString> prompts, boolean computePrompts) {\n+    private AttributedString insertSecondaryPrompts(\n+            AttributedString strAtt, List<AttributedString> prompts, boolean computePrompts) {\n@@ -4174,1 +4257,3 @@\n-                width = new TerminalLine(prompt.toString(), 0, size.getColumns()).getEndLine().length();\n+                width = new TerminalLine(prompt.toString(), 0, size.getColumns())\n+                        .getEndLine()\n+                        .length();\n@@ -4230,2 +4315,1 @@\n-        boolean endsWithNl = line.length() > 0\n-            && line.charAt(line.length() - 1) == '\\n';\n+        boolean endsWithNl = line.length() > 0 && line.charAt(line.length() - 1) == '\\n';\n@@ -4233,2 +4317,1 @@\n-        int nb = size.getColumns() - width\n-            - (line.columnLength() + (endsWithNl ? 1 : 0));\n+        int nb = size.getColumns() - width - (line.columnLength() + (endsWithNl ? 1 : 0));\n@@ -4256,2 +4339,2 @@\n-                    && getLastBinding().equals(\"\\t\")\n-                    && buf.toString().matches(\"(^|[\\\\s\\\\S]*\\n)[\\r\\n\\t ]*\");\n+                && getLastBinding().equals(\"\\t\")\n+                && buf.toString().matches(\"(^|[\\\\s\\\\S]*\\n)[\\r\\n\\t ]*\");\n@@ -4468,1 +4551,2 @@\n-                        if (SELF_INSERT.equals(ref) && chars.indexOf(getLastBinding().charAt(0)) >= 0\n+                        if (SELF_INSERT.equals(ref)\n+                                        && chars.indexOf(getLastBinding().charAt(0)) >= 0\n@@ -4536,0 +4620,1 @@\n+\n@@ -4539,0 +4624,1 @@\n+\n@@ -4542,0 +4628,1 @@\n+\n@@ -4545,0 +4632,1 @@\n+\n@@ -4548,0 +4636,1 @@\n+\n@@ -4551,0 +4640,1 @@\n+\n@@ -4554,0 +4644,1 @@\n+\n@@ -4557,0 +4648,1 @@\n+\n@@ -4567,2 +4659,1 @@\n-        return Comparator\n-                .comparing(Candidate::value, Comparator.comparingInt(wordDistance))\n+        return Comparator.comparing(Candidate::value, Comparator.comparingInt(wordDistance))\n@@ -4580,1 +4671,0 @@\n-\n@@ -4582,1 +4672,3 @@\n-        return Comparator.<String>comparingInt(s -> getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)\n+        return Comparator.<String>comparingInt(s -> getOthersGroupName().equals(s)\n+                        ? 1\n+                        : getOriginalGroupName().equals(s) ? -1 : 0)\n@@ -4603,5 +4695,3 @@\n-                    String disp = candidates.stream()\n-                            .map(Candidate::displ)\n-                            .collect(Collectors.joining(\" \"));\n-                    possible.add(new Candidate(first.value(), disp, first.group(),\n-                            first.descr(), first.suffix(), null, first.complete()));\n+                    String disp = candidates.stream().map(Candidate::displ).collect(Collectors.joining(\" \"));\n+                    possible.add(new Candidate(\n+                            first.value(), disp, first.group(), first.descr(), first.suffix(), null, first.complete()));\n@@ -4639,2 +4729,4 @@\n-        AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-        return text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+        AttributedString text =\n+                insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+        return text.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                .size();\n@@ -4654,1 +4746,2 @@\n-        public MenuSupport(List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+        public MenuSupport(\n+                List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4717,1 +4810,1 @@\n-                axis = options%axis;\n+                axis = options % axis;\n@@ -4775,1 +4868,3 @@\n-                            .append(post).append(\"\\n\").toAttributedString();\n+                            .append(post)\n+                            .append(\"\\n\")\n+                            .toAttributedString();\n@@ -4788,1 +4883,2 @@\n-                        .style(AttributedStyle.DEFAULT).toAttributedString());\n+                        .style(AttributedStyle.DEFAULT)\n+                        .toAttributedString());\n@@ -4801,1 +4897,0 @@\n-\n@@ -4804,1 +4899,2 @@\n-    protected boolean doMenu(List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+    protected boolean doMenu(\n+            List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4857,1 +4953,1 @@\n-                                && chars.indexOf(getLastBinding().charAt(0)) >= 0\n+                                        && chars.indexOf(getLastBinding().charAt(0)) >= 0\n@@ -4869,2 +4965,2 @@\n-                                && completion.suffix() != null\n-                                && completion.suffix().startsWith(getLastBinding()))) {\n+                                    && completion.suffix() != null\n+                                    && completion.suffix().startsWith(getLastBinding()))) {\n@@ -4891,2 +4987,5 @@\n-    protected boolean doList(List<Candidate> possible\n-                           , String completed, boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+    protected boolean doList(\n+            List<Candidate> possible,\n+            String completed,\n+            boolean runLoop,\n+            BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4896,3 +4995,6 @@\n-    protected boolean doList(List<Candidate> possible\n-                           , String completed\n-                           , boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper, boolean forSuggestion) {\n+    protected boolean doList(\n+            List<Candidate> possible,\n+            String completed,\n+            boolean runLoop,\n+            BiFunction<CharSequence, Boolean, CharSequence> escaper,\n+            boolean forSuggestion) {\n@@ -4904,2 +5006,4 @@\n-        AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-        int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+        AttributedString text =\n+                insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+        int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                .size();\n@@ -4909,2 +5013,5 @@\n-        if (listMax > 0 && possible.size() >= listMax\n-                || lines >= size.getRows() - promptLines) {\n+        int possibleSize = possible.size();\n+        if (possibleSize == 0 || size.getRows() == 0) {\n+            return false;\n+        }\n+        if (listMax > 0 && possibleSize >= listMax || lines >= size.getRows() - promptLines) {\n@@ -4913,1 +5020,1 @@\n-                post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possible.size()\n+                post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possibleSize\n@@ -4933,2 +5040,1 @@\n-                completionMatcher.compile(options, false, new CompletingWord(current), caseInsensitive, 0\n-                        , null);\n+                completionMatcher.compile(options, false, new CompletingWord(current), caseInsensitive, 0, null);\n@@ -4947,2 +5053,4 @@\n-                AttributedString t = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-                int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+                AttributedString t = insertSecondaryPrompts(\n+                        AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+                int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                        .size();\n@@ -4957,1 +5065,2 @@\n-                    List<AttributedString> ls = pr.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+                    List<AttributedString> ls =\n+                            pr.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -5077,5 +5186,24 @@\n-    protected PostResult computePost(List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed) {\n-        return computePost(possible, selection, ordered, completed, display::wcwidth, size.getColumns(), isSet(Option.AUTO_GROUP), isSet(Option.GROUP), isSet(Option.LIST_ROWS_FIRST));\n-    }\n-\n-    protected PostResult computePost(List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed, Function<String, Integer> wcwidth, int width, boolean autoGroup, boolean groupName, boolean rowsFirst) {\n+    protected PostResult computePost(\n+            List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed) {\n+        return computePost(\n+                possible,\n+                selection,\n+                ordered,\n+                completed,\n+                display::wcwidth,\n+                size.getColumns(),\n+                isSet(Option.AUTO_GROUP),\n+                isSet(Option.GROUP),\n+                isSet(Option.LIST_ROWS_FIRST));\n+    }\n+\n+    protected PostResult computePost(\n+            List<Candidate> possible,\n+            Candidate selection,\n+            List<Candidate> ordered,\n+            String completed,\n+            Function<String, Integer> wcwidth,\n+            int width,\n+            boolean autoGroup,\n+            boolean groupName,\n+            boolean rowsFirst) {\n@@ -5083,1 +5211,0 @@\n-        boolean customOrder = possible.stream().anyMatch(c -> c.sort() != 0);\n@@ -5086,4 +5213,2 @@\n-            Map<String, Map<Object, Candidate>> sorted;\n-            sorted = groupComparator != null\n-                        ? new TreeMap<>(groupComparator)\n-                        : new LinkedHashMap<>();\n+            Map<String, List<Candidate>> sorted;\n+            sorted = groupComparator != null ? new TreeMap<>(groupComparator) : new LinkedHashMap<>();\n@@ -5092,2 +5217,2 @@\n-                sorted.computeIfAbsent(group != null ? group : \"\", s -> new LinkedHashMap<>())\n-                        .put((customOrder ? cand.sort() : cand.value()), cand);\n+                sorted.computeIfAbsent(group != null ? group : \"\", s -> new ArrayList<>())\n+                        .add(cand);\n@@ -5095,1 +5220,1 @@\n-            for (Map.Entry<String, Map<Object, Candidate>> entry : sorted.entrySet()) {\n+            for (Map.Entry<String, List<Candidate>> entry : sorted.entrySet()) {\n@@ -5103,1 +5228,3 @@\n-                strings.add(new ArrayList<>(entry.getValue().values()));\n+                List<Candidate> candidates = entry.getValue();\n+                Collections.sort(candidates);\n+                strings.add(candidates);\n@@ -5105,1 +5232,1 @@\n-                    ordered.addAll(entry.getValue().values());\n+                    ordered.addAll(candidates);\n@@ -5110,1 +5237,1 @@\n-            TreeMap<Object, Candidate> sorted = new TreeMap<>();\n+            List<Candidate> sorted = new ArrayList<>();\n@@ -5116,1 +5243,1 @@\n-                sorted.put((customOrder ? cand.sort() : cand.value()), cand);\n+                sorted.add(cand);\n@@ -5121,1 +5248,2 @@\n-            strings.add(new ArrayList<>(sorted.values()));\n+            Collections.sort(sorted);\n+            strings.add(sorted);\n@@ -5123,1 +5251,1 @@\n-                ordered.addAll(sorted.values());\n+                ordered.addAll(sorted);\n@@ -5166,2 +5294,4 @@\n-        List<String> values = cands.stream().map(c -> AttributedString.stripAnsi(c.displ()))\n-                .filter(c -> !c.matches(\"\\\\w+\") && c.length() > 1).collect(Collectors.toList());\n+        List<String> values = cands.stream()\n+                .map(c -> AttributedString.stripAnsi(c.displ()))\n+                .filter(c -> !c.matches(\"\\\\w+\") && c.length() > 1)\n+                .collect(Collectors.toList());\n@@ -5169,1 +5299,2 @@\n-        values.forEach(v -> v.substring(0, v.length() - 1).chars()\n+        values.forEach(v -> v.substring(0, v.length() - 1)\n+                .chars()\n@@ -5171,1 +5302,1 @@\n-                .forEach(c -> notDelimiters.add(Character.toString((char)c))));\n+                .forEach(c -> notDelimiters.add(Character.toString((char) c))));\n@@ -5182,2 +5313,1 @@\n-            if (buffer.substring(0, i).matches(\".*\\\\W\")\n-                    && !notDelimiters.contains(buffer.substring(i - 1, i))) {\n+            if (buffer.substring(0, i).matches(\".*\\\\W\") && !notDelimiters.contains(buffer.substring(i - 1, i))) {\n@@ -5192,1 +5322,7 @@\n-    protected PostResult toColumns(List<Object> items, Candidate selection, String completed, Function<String, Integer> wcwidth, int width, boolean rowsFirst) {\n+    protected PostResult toColumns(\n+            List<Object> items,\n+            Candidate selection,\n+            String completed,\n+            Function<String, Integer> wcwidth,\n+            int width,\n+            boolean rowsFirst) {\n@@ -5202,2 +5338,1 @@\n-            }\n-            else if (item instanceof List) {\n+            } else if (item instanceof List) {\n@@ -5221,1 +5356,4 @@\n-                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), visibleDisplayRows() - promptLines())) {\n+                    && listSize\n+                            < Math.min(\n+                                    getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX),\n+                                    visibleDisplayRows() - promptLines())) {\n@@ -5254,2 +5392,10 @@\n-    protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed\n-                           , boolean rowsFirst, boolean doMenuList, int[] out) {\n+    protected void toColumns(\n+            Object items,\n+            int width,\n+            int maxWidth,\n+            AttributedStringBuilder sb,\n+            Candidate selection,\n+            String completed,\n+            boolean rowsFirst,\n+            boolean doMenuList,\n+            int[] out) {\n@@ -5308,2 +5454,2 @@\n-                        AttributedString left = AttributedString.fromAnsi(cand.displ());\n-                        AttributedString right = AttributedString.fromAnsi(cand.descr());\n+                        AttributedString left = fromAnsi(cand.displ());\n+                        AttributedString right = fromAnsi(cand.descr());\n@@ -5313,2 +5459,5 @@\n-                            int rem = maxWidth - (lw + MARGIN_BETWEEN_DISPLAY_AND_DESC\n-                                    + DESC_PREFIX.length() + DESC_SUFFIX.length());\n+                            int rem = maxWidth\n+                                    - (lw\n+                                            + MARGIN_BETWEEN_DISPLAY_AND_DESC\n+                                            + DESC_PREFIX.length()\n+                                            + DESC_SUFFIX.length());\n@@ -5318,2 +5467,1 @@\n-                                            right.columnSubSequence(0, rem - WCWidth.wcwidth('\\u2026')),\n-                                            \"\\u2026\");\n+                                        right.columnSubSequence(0, rem - WCWidth.wcwidth('\\u2026')), \"\\u2026\");\n@@ -5328,2 +5476,3 @@\n-                            if (left.toString().regionMatches(\n-                                    isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n+                            if (left.toString()\n+                                    .regionMatches(\n+                                            isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n@@ -5343,2 +5492,3 @@\n-                            if (left.toString().regionMatches(\n-                                    isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n+                            if (left.toString()\n+                                    .regionMatches(\n+                                            isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n@@ -5450,1 +5600,1 @@\n-        return AttributedString.fromAnsi(\"\\u001b[\" + str + \"m \").styleAt(0);\n+        return fromAnsi(\"\\u001b[\" + str + \"m \").styleAt(0);\n@@ -5480,2 +5630,1 @@\n-        }\n-        else if (!next && !history.previous()) {\n+        } else if (!next && !history.previous()) {\n@@ -5485,3 +5634,4 @@\n-        setBuffer(modifiedHistory.containsKey(history.index())\n-                    ? modifiedHistory.get(history.index())\n-                    : history.current());\n+        setBuffer(\n+                modifiedHistory.containsKey(history.index())\n+                        ? modifiedHistory.get(history.index())\n+                        : history.current());\n@@ -5518,1 +5668,0 @@\n-\n@@ -5728,2 +5877,1 @@\n-        if (event.getType() == MouseEvent.Type.Released\n-                && event.getButton() == MouseEvent.Button.Button1) {\n+        if (event.getType() == MouseEvent.Type.Released && event.getButton() == MouseEvent.Button.Button1) {\n@@ -5737,1 +5885,1 @@\n-            AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+            AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -5740,1 +5888,2 @@\n-            List<AttributedString> promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+            List<AttributedString> promptLines =\n+                    sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -5744,2 +5893,6 @@\n-            int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();\n-            int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();\n+            int pl0 = currentLine == 0\n+                    ? prompt.columnLength()\n+                    : secondaryPrompts.get(currentLine - 1).columnLength();\n+            int pl1 = wantedLine == 0\n+                    ? prompt.columnLength()\n+                    : secondaryPrompts.get(wantedLine - 1).columnLength();\n@@ -5817,2 +5970,1 @@\n-                bell_preference = getBoolean(PREFER_VISIBLE_BELL, false)\n-                        ? BellType.VISIBLE : BellType.AUDIBLE;\n+                bell_preference = getBoolean(PREFER_VISIBLE_BELL, false) ? BellType.VISIBLE : BellType.AUDIBLE;\n@@ -5822,2 +5974,1 @@\n-            if (terminal.puts(Capability.flash_screen)\n-                    || terminal.puts(Capability.bell)) {\n+            if (terminal.puts(Capability.flash_screen) || terminal.puts(Capability.bell)) {\n@@ -5872,2 +6023,1 @@\n-        return Character.isLetterOrDigit(c)\n-                || (c < 128 && wordchars.indexOf((char) c) >= 0);\n+        return Character.isLetterOrDigit(c) || (c < 128 && wordchars.indexOf((char) c) >= 0);\n@@ -5902,0 +6052,2 @@\n+        keyMaps.put(DUMB, dumb());\n+\n@@ -5912,2 +6064,3 @@\n-        \/\/ By default, link main to emacs\n-        keyMaps.put(MAIN, keyMaps.get(EMACS));\n+        \/\/ By default, link main to emacs unless the temrinal is dumb\n+        keyMaps.put(MAIN, keyMaps.get(isTerminalDumb() ? DUMB : EMACS));\n+\n@@ -5920,72 +6073,72 @@\n-        bind(emacs, SET_MARK_COMMAND,                       ctrl('@'));\n-        bind(emacs, BEGINNING_OF_LINE,                      ctrl('A'));\n-        bind(emacs, BACKWARD_CHAR,                          ctrl('B'));\n-        bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl('D'));\n-        bind(emacs, END_OF_LINE,                            ctrl('E'));\n-        bind(emacs, FORWARD_CHAR,                           ctrl('F'));\n-        bind(emacs, SEND_BREAK,                             ctrl('G'));\n-        bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl('H'));\n-        bind(emacs, EXPAND_OR_COMPLETE,                     ctrl('I'));\n-        bind(emacs, ACCEPT_LINE,                            ctrl('J'));\n-        bind(emacs, KILL_LINE,                              ctrl('K'));\n-        bind(emacs, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(emacs, ACCEPT_LINE,                            ctrl('M'));\n-        bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl('N'));\n-        bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl('O'));\n-        bind(emacs, UP_LINE_OR_HISTORY,                     ctrl('P'));\n-        bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(emacs, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(emacs, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(emacs, QUOTED_INSERT,                          ctrl('V'));\n-        bind(emacs, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(emacs, YANK,                                   ctrl('Y'));\n-        bind(emacs, CHARACTER_SEARCH,                       ctrl(']'));\n-        bind(emacs, UNDO,                                   ctrl('_'));\n-        bind(emacs, SELF_INSERT,                            range(\" -~\"));\n-        bind(emacs, INSERT_CLOSE_PAREN,                     \")\");\n-        bind(emacs, INSERT_CLOSE_SQUARE,                    \"]\");\n-        bind(emacs, INSERT_CLOSE_CURLY,                     \"}\");\n-        bind(emacs, BACKWARD_DELETE_CHAR,                   del());\n-        bind(emacs, VI_MATCH_BRACKET,                       translate(\"^X^B\"));\n-        bind(emacs, SEND_BREAK,                             translate(\"^X^G\"));\n-        bind(emacs, EDIT_AND_EXECUTE_COMMAND,               translate(\"^X^E\"));\n-        bind(emacs, VI_FIND_NEXT_CHAR,                      translate(\"^X^F\"));\n-        bind(emacs, VI_JOIN,                                translate(\"^X^J\"));\n-        bind(emacs, KILL_BUFFER,                            translate(\"^X^K\"));\n-        bind(emacs, INFER_NEXT_HISTORY,                     translate(\"^X^N\"));\n-        bind(emacs, OVERWRITE_MODE,                         translate(\"^X^O\"));\n-        bind(emacs, REDO,                                   translate(\"^X^R\"));\n-        bind(emacs, UNDO,                                   translate(\"^X^U\"));\n-        bind(emacs, VI_CMD_MODE,                            translate(\"^X^V\"));\n-        bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(\"^X^X\"));\n-        bind(emacs, DO_LOWERCASE_VERSION,                   translate(\"^XA-^XZ\"));\n-        bind(emacs, WHAT_CURSOR_POSITION,                   translate(\"^X=\"));\n-        bind(emacs, KILL_LINE,                              translate(\"^X^?\"));\n-        bind(emacs, SEND_BREAK,                             alt(ctrl('G')));\n-        bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl('H')));\n-        bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl('M')));\n-        bind(emacs, COMPLETE_WORD,                          alt(esc()));\n-        bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(']')));\n-        bind(emacs, COPY_PREV_WORD,                         alt(ctrl('_')));\n-        bind(emacs, SET_MARK_COMMAND,                       alt(' '));\n-        bind(emacs, NEG_ARGUMENT,                           alt('-'));\n-        bind(emacs, DIGIT_ARGUMENT,                         range(\"\\\\E0-\\\\E9\"));\n-        bind(emacs, BEGINNING_OF_HISTORY,                   alt('<'));\n-        bind(emacs, LIST_CHOICES,                           alt('='));\n-        bind(emacs, END_OF_HISTORY,                         alt('>'));\n-        bind(emacs, LIST_CHOICES,                           alt('?'));\n-        bind(emacs, DO_LOWERCASE_VERSION,                   range(\"^[A-^[Z\"));\n-        bind(emacs, ACCEPT_AND_HOLD,                        alt('a'));\n-        bind(emacs, BACKWARD_WORD,                          alt('b'));\n-        bind(emacs, CAPITALIZE_WORD,                        alt('c'));\n-        bind(emacs, KILL_WORD,                              alt('d'));\n-        bind(emacs, KILL_WORD,                              translate(\"^[[3;5~\")); \/\/ ctrl-delete\n-        bind(emacs, FORWARD_WORD,                           alt('f'));\n-        bind(emacs, DOWN_CASE_WORD,                         alt('l'));\n-        bind(emacs, HISTORY_SEARCH_FORWARD,                 alt('n'));\n-        bind(emacs, HISTORY_SEARCH_BACKWARD,                alt('p'));\n-        bind(emacs, TRANSPOSE_WORDS,                        alt('t'));\n-        bind(emacs, UP_CASE_WORD,                           alt('u'));\n-        bind(emacs, YANK_POP,                               alt('y'));\n-        bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));\n+        bind(emacs, SET_MARK_COMMAND, ctrl('@'));\n+        bind(emacs, BEGINNING_OF_LINE, ctrl('A'));\n+        bind(emacs, BACKWARD_CHAR, ctrl('B'));\n+        bind(emacs, DELETE_CHAR_OR_LIST, ctrl('D'));\n+        bind(emacs, END_OF_LINE, ctrl('E'));\n+        bind(emacs, FORWARD_CHAR, ctrl('F'));\n+        bind(emacs, SEND_BREAK, ctrl('G'));\n+        bind(emacs, BACKWARD_DELETE_CHAR, ctrl('H'));\n+        bind(emacs, EXPAND_OR_COMPLETE, ctrl('I'));\n+        bind(emacs, ACCEPT_LINE, ctrl('J'));\n+        bind(emacs, KILL_LINE, ctrl('K'));\n+        bind(emacs, CLEAR_SCREEN, ctrl('L'));\n+        bind(emacs, ACCEPT_LINE, ctrl('M'));\n+        bind(emacs, DOWN_LINE_OR_HISTORY, ctrl('N'));\n+        bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY, ctrl('O'));\n+        bind(emacs, UP_LINE_OR_HISTORY, ctrl('P'));\n+        bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(emacs, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(emacs, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(emacs, QUOTED_INSERT, ctrl('V'));\n+        bind(emacs, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(emacs, YANK, ctrl('Y'));\n+        bind(emacs, CHARACTER_SEARCH, ctrl(']'));\n+        bind(emacs, UNDO, ctrl('_'));\n+        bind(emacs, SELF_INSERT, range(\" -~\"));\n+        bind(emacs, INSERT_CLOSE_PAREN, \")\");\n+        bind(emacs, INSERT_CLOSE_SQUARE, \"]\");\n+        bind(emacs, INSERT_CLOSE_CURLY, \"}\");\n+        bind(emacs, BACKWARD_DELETE_CHAR, del());\n+        bind(emacs, VI_MATCH_BRACKET, translate(\"^X^B\"));\n+        bind(emacs, SEND_BREAK, translate(\"^X^G\"));\n+        bind(emacs, EDIT_AND_EXECUTE_COMMAND, translate(\"^X^E\"));\n+        bind(emacs, VI_FIND_NEXT_CHAR, translate(\"^X^F\"));\n+        bind(emacs, VI_JOIN, translate(\"^X^J\"));\n+        bind(emacs, KILL_BUFFER, translate(\"^X^K\"));\n+        bind(emacs, INFER_NEXT_HISTORY, translate(\"^X^N\"));\n+        bind(emacs, OVERWRITE_MODE, translate(\"^X^O\"));\n+        bind(emacs, REDO, translate(\"^X^R\"));\n+        bind(emacs, UNDO, translate(\"^X^U\"));\n+        bind(emacs, VI_CMD_MODE, translate(\"^X^V\"));\n+        bind(emacs, EXCHANGE_POINT_AND_MARK, translate(\"^X^X\"));\n+        bind(emacs, DO_LOWERCASE_VERSION, translate(\"^XA-^XZ\"));\n+        bind(emacs, WHAT_CURSOR_POSITION, translate(\"^X=\"));\n+        bind(emacs, KILL_LINE, translate(\"^X^?\"));\n+        bind(emacs, SEND_BREAK, alt(ctrl('G')));\n+        bind(emacs, BACKWARD_KILL_WORD, alt(ctrl('H')));\n+        bind(emacs, SELF_INSERT_UNMETA, alt(ctrl('M')));\n+        bind(emacs, COMPLETE_WORD, alt(esc()));\n+        bind(emacs, CHARACTER_SEARCH_BACKWARD, alt(ctrl(']')));\n+        bind(emacs, COPY_PREV_WORD, alt(ctrl('_')));\n+        bind(emacs, SET_MARK_COMMAND, alt(' '));\n+        bind(emacs, NEG_ARGUMENT, alt('-'));\n+        bind(emacs, DIGIT_ARGUMENT, range(\"\\\\E0-\\\\E9\"));\n+        bind(emacs, BEGINNING_OF_HISTORY, alt('<'));\n+        bind(emacs, LIST_CHOICES, alt('='));\n+        bind(emacs, END_OF_HISTORY, alt('>'));\n+        bind(emacs, LIST_CHOICES, alt('?'));\n+        bind(emacs, DO_LOWERCASE_VERSION, range(\"^[A-^[Z\"));\n+        bind(emacs, ACCEPT_AND_HOLD, alt('a'));\n+        bind(emacs, BACKWARD_WORD, alt('b'));\n+        bind(emacs, CAPITALIZE_WORD, alt('c'));\n+        bind(emacs, KILL_WORD, alt('d'));\n+        bind(emacs, KILL_WORD, translate(\"^[[3;5~\")); \/\/ ctrl-delete\n+        bind(emacs, FORWARD_WORD, alt('f'));\n+        bind(emacs, DOWN_CASE_WORD, alt('l'));\n+        bind(emacs, HISTORY_SEARCH_FORWARD, alt('n'));\n+        bind(emacs, HISTORY_SEARCH_BACKWARD, alt('p'));\n+        bind(emacs, TRANSPOSE_WORDS, alt('t'));\n+        bind(emacs, UP_CASE_WORD, alt('u'));\n+        bind(emacs, YANK_POP, alt('y'));\n+        bind(emacs, BACKWARD_KILL_WORD, alt(del()));\n@@ -5993,6 +6146,6 @@\n-        bind(emacs, FORWARD_WORD,                           translate(\"^[[1;5C\")); \/\/ ctrl-left\n-        bind(emacs, BACKWARD_WORD,                          translate(\"^[[1;5D\")); \/\/ ctrl-right\n-        bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));\n-        bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));\n-        bind(emacs, FORWARD_WORD,                           alt(translate(\"^[[C\")));\n-        bind(emacs, BACKWARD_WORD,                          alt(translate(\"^[[D\")));\n+        bind(emacs, FORWARD_WORD, translate(\"^[[1;5C\")); \/\/ ctrl-left\n+        bind(emacs, BACKWARD_WORD, translate(\"^[[1;5D\")); \/\/ ctrl-right\n+        bind(emacs, FORWARD_WORD, alt(key(Capability.key_right)));\n+        bind(emacs, BACKWARD_WORD, alt(key(Capability.key_left)));\n+        bind(emacs, FORWARD_WORD, alt(translate(\"^[[C\")));\n+        bind(emacs, BACKWARD_WORD, alt(translate(\"^[[D\")));\n@@ -6005,26 +6158,26 @@\n-        bind(viins, SELF_INSERT,                            range(\"^@-^_\"));\n-        bind(viins, LIST_CHOICES,                           ctrl('D'));\n-        bind(viins, SEND_BREAK,                             ctrl('G'));\n-        bind(viins, BACKWARD_DELETE_CHAR,                   ctrl('H'));\n-        bind(viins, EXPAND_OR_COMPLETE,                     ctrl('I'));\n-        bind(viins, ACCEPT_LINE,                            ctrl('J'));\n-        bind(viins, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(viins, ACCEPT_LINE,                            ctrl('M'));\n-        bind(viins, MENU_COMPLETE,                          ctrl('N'));\n-        bind(viins, REVERSE_MENU_COMPLETE,                  ctrl('P'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(viins, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(viins, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(viins, QUOTED_INSERT,                          ctrl('V'));\n-        bind(viins, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(viins, YANK,                                   ctrl('Y'));\n-        bind(viins, VI_CMD_MODE,                            ctrl('['));\n-        bind(viins, UNDO,                                   ctrl('_'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('X') + \"r\");\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('X') + \"s\");\n-        bind(viins, SELF_INSERT,                            range(\" -~\"));\n-        bind(viins, INSERT_CLOSE_PAREN,                     \")\");\n-        bind(viins, INSERT_CLOSE_SQUARE,                    \"]\");\n-        bind(viins, INSERT_CLOSE_CURLY,                     \"}\");\n-        bind(viins, BACKWARD_DELETE_CHAR,                   del());\n+        bind(viins, SELF_INSERT, range(\"^@-^_\"));\n+        bind(viins, LIST_CHOICES, ctrl('D'));\n+        bind(viins, SEND_BREAK, ctrl('G'));\n+        bind(viins, BACKWARD_DELETE_CHAR, ctrl('H'));\n+        bind(viins, EXPAND_OR_COMPLETE, ctrl('I'));\n+        bind(viins, ACCEPT_LINE, ctrl('J'));\n+        bind(viins, CLEAR_SCREEN, ctrl('L'));\n+        bind(viins, ACCEPT_LINE, ctrl('M'));\n+        bind(viins, MENU_COMPLETE, ctrl('N'));\n+        bind(viins, REVERSE_MENU_COMPLETE, ctrl('P'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(viins, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(viins, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(viins, QUOTED_INSERT, ctrl('V'));\n+        bind(viins, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(viins, YANK, ctrl('Y'));\n+        bind(viins, VI_CMD_MODE, ctrl('['));\n+        bind(viins, UNDO, ctrl('_'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('X') + \"r\");\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('X') + \"s\");\n+        bind(viins, SELF_INSERT, range(\" -~\"));\n+        bind(viins, INSERT_CLOSE_PAREN, \")\");\n+        bind(viins, INSERT_CLOSE_SQUARE, \"]\");\n+        bind(viins, INSERT_CLOSE_CURLY, \"}\");\n+        bind(viins, BACKWARD_DELETE_CHAR, del());\n@@ -6037,109 +6190,109 @@\n-        bind(vicmd, LIST_CHOICES,                           ctrl('D'));\n-        bind(vicmd, EMACS_EDITING_MODE,                     ctrl('E'));\n-        bind(vicmd, SEND_BREAK,                             ctrl('G'));\n-        bind(vicmd, VI_BACKWARD_CHAR,                       ctrl('H'));\n-        bind(vicmd, ACCEPT_LINE,                            ctrl('J'));\n-        bind(vicmd, KILL_LINE,                              ctrl('K'));\n-        bind(vicmd, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(vicmd, ACCEPT_LINE,                            ctrl('M'));\n-        bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                ctrl('N'));\n-        bind(vicmd, VI_UP_LINE_OR_HISTORY,                  ctrl('P'));\n-        bind(vicmd, QUOTED_INSERT,                          ctrl('Q'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(vicmd, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(vicmd, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(vicmd, QUOTED_INSERT,                          ctrl('V'));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(vicmd, YANK,                                   ctrl('Y'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('X') + \"r\");\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('X') + \"s\");\n-        bind(vicmd, SEND_BREAK,                             alt(ctrl('G')));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     alt(ctrl('H')));\n-        bind(vicmd, SELF_INSERT_UNMETA,                     alt(ctrl('M')));\n-        bind(vicmd, COMPLETE_WORD,                          alt(esc()));\n-        bind(vicmd, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(']')));\n-        bind(vicmd, SET_MARK_COMMAND,                       alt(' '));\n-\/\/        bind(vicmd, INSERT_COMMENT,                         alt('#'));\n-\/\/        bind(vicmd, INSERT_COMPLETIONS,                     alt('*'));\n-        bind(vicmd, DIGIT_ARGUMENT,                         alt('-'));\n-        bind(vicmd, BEGINNING_OF_HISTORY,                   alt('<'));\n-        bind(vicmd, LIST_CHOICES,                           alt('='));\n-        bind(vicmd, END_OF_HISTORY,                         alt('>'));\n-        bind(vicmd, LIST_CHOICES,                           alt('?'));\n-        bind(vicmd, DO_LOWERCASE_VERSION,                   range(\"^[A-^[Z\"));\n-        bind(vicmd, BACKWARD_WORD,                          alt('b'));\n-        bind(vicmd, CAPITALIZE_WORD,                        alt('c'));\n-        bind(vicmd, KILL_WORD,                              alt('d'));\n-        bind(vicmd, FORWARD_WORD,                           alt('f'));\n-        bind(vicmd, DOWN_CASE_WORD,                         alt('l'));\n-        bind(vicmd, HISTORY_SEARCH_FORWARD,                 alt('n'));\n-        bind(vicmd, HISTORY_SEARCH_BACKWARD,                alt('p'));\n-        bind(vicmd, TRANSPOSE_WORDS,                        alt('t'));\n-        bind(vicmd, UP_CASE_WORD,                           alt('u'));\n-        bind(vicmd, YANK_POP,                               alt('y'));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     alt(del()));\n-\n-        bind(vicmd, FORWARD_CHAR,                           \" \");\n-        bind(vicmd, VI_INSERT_COMMENT,                      \"#\");\n-        bind(vicmd, END_OF_LINE,                            \"$\");\n-        bind(vicmd, VI_MATCH_BRACKET,                       \"%\");\n-        bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                \"+\");\n-        bind(vicmd, VI_REV_REPEAT_FIND,                     \",\");\n-        bind(vicmd, VI_UP_LINE_OR_HISTORY,                  \"-\");\n-        bind(vicmd, VI_REPEAT_CHANGE,                       \".\");\n-        bind(vicmd, VI_HISTORY_SEARCH_BACKWARD,             \"\/\");\n-        bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE,          \"0\");\n-        bind(vicmd, DIGIT_ARGUMENT,                         range(\"1-9\"));\n-        bind(vicmd, VI_REPEAT_FIND,                         \";\");\n-        bind(vicmd, LIST_CHOICES,                           \"=\");\n-        bind(vicmd, VI_HISTORY_SEARCH_FORWARD,              \"?\");\n-        bind(vicmd, VI_ADD_EOL,                             \"A\");\n-        bind(vicmd, VI_BACKWARD_BLANK_WORD,                 \"B\");\n-        bind(vicmd, VI_CHANGE_EOL,                          \"C\");\n-        bind(vicmd, VI_KILL_EOL,                            \"D\");\n-        bind(vicmd, VI_FORWARD_BLANK_WORD_END,              \"E\");\n-        bind(vicmd, VI_FIND_PREV_CHAR,                      \"F\");\n-        bind(vicmd, VI_FETCH_HISTORY,                       \"G\");\n-        bind(vicmd, VI_INSERT_BOL,                          \"I\");\n-        bind(vicmd, VI_JOIN,                                \"J\");\n-        bind(vicmd, VI_REV_REPEAT_SEARCH,                   \"N\");\n-        bind(vicmd, VI_OPEN_LINE_ABOVE,                     \"O\");\n-        bind(vicmd, VI_PUT_BEFORE,                          \"P\");\n-        bind(vicmd, VI_REPLACE,                             \"R\");\n-        bind(vicmd, VI_KILL_LINE,                           \"S\");\n-        bind(vicmd, VI_FIND_PREV_CHAR_SKIP,                 \"T\");\n-        bind(vicmd, REDO,                                   \"U\");\n-        bind(vicmd, VISUAL_LINE_MODE,                       \"V\");\n-        bind(vicmd, VI_FORWARD_BLANK_WORD,                  \"W\");\n-        bind(vicmd, VI_BACKWARD_DELETE_CHAR,                \"X\");\n-        bind(vicmd, VI_YANK_WHOLE_LINE,                     \"Y\");\n-        bind(vicmd, VI_FIRST_NON_BLANK,                     \"^\");\n-        bind(vicmd, VI_ADD_NEXT,                            \"a\");\n-        bind(vicmd, VI_BACKWARD_WORD,                       \"b\");\n-        bind(vicmd, VI_CHANGE,                              \"c\");\n-        bind(vicmd, VI_DELETE,                              \"d\");\n-        bind(vicmd, VI_FORWARD_WORD_END,                    \"e\");\n-        bind(vicmd, VI_FIND_NEXT_CHAR,                      \"f\");\n-        bind(vicmd, WHAT_CURSOR_POSITION,                   \"ga\");\n-        bind(vicmd, VI_BACKWARD_BLANK_WORD_END,             \"gE\");\n-        bind(vicmd, VI_BACKWARD_WORD_END,                   \"ge\");\n-        bind(vicmd, VI_BACKWARD_CHAR,                       \"h\");\n-        bind(vicmd, VI_INSERT,                              \"i\");\n-        bind(vicmd, DOWN_LINE_OR_HISTORY,                   \"j\");\n-        bind(vicmd, UP_LINE_OR_HISTORY,                     \"k\");\n-        bind(vicmd, VI_FORWARD_CHAR,                        \"l\");\n-        bind(vicmd, VI_REPEAT_SEARCH,                       \"n\");\n-        bind(vicmd, VI_OPEN_LINE_BELOW,                     \"o\");\n-        bind(vicmd, VI_PUT_AFTER,                           \"p\");\n-        bind(vicmd, VI_REPLACE_CHARS,                       \"r\");\n-        bind(vicmd, VI_SUBSTITUTE,                          \"s\");\n-        bind(vicmd, VI_FIND_NEXT_CHAR_SKIP,                 \"t\");\n-        bind(vicmd, UNDO,                                   \"u\");\n-        bind(vicmd, VISUAL_MODE,                            \"v\");\n-        bind(vicmd, VI_FORWARD_WORD,                        \"w\");\n-        bind(vicmd, VI_DELETE_CHAR,                         \"x\");\n-        bind(vicmd, VI_YANK,                                \"y\");\n-        bind(vicmd, VI_GOTO_COLUMN,                         \"|\");\n-        bind(vicmd, VI_SWAP_CASE,                           \"~\");\n-        bind(vicmd, VI_BACKWARD_CHAR,                       del());\n+        bind(vicmd, LIST_CHOICES, ctrl('D'));\n+        bind(vicmd, EMACS_EDITING_MODE, ctrl('E'));\n+        bind(vicmd, SEND_BREAK, ctrl('G'));\n+        bind(vicmd, VI_BACKWARD_CHAR, ctrl('H'));\n+        bind(vicmd, ACCEPT_LINE, ctrl('J'));\n+        bind(vicmd, KILL_LINE, ctrl('K'));\n+        bind(vicmd, CLEAR_SCREEN, ctrl('L'));\n+        bind(vicmd, ACCEPT_LINE, ctrl('M'));\n+        bind(vicmd, VI_DOWN_LINE_OR_HISTORY, ctrl('N'));\n+        bind(vicmd, VI_UP_LINE_OR_HISTORY, ctrl('P'));\n+        bind(vicmd, QUOTED_INSERT, ctrl('Q'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(vicmd, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(vicmd, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(vicmd, QUOTED_INSERT, ctrl('V'));\n+        bind(vicmd, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(vicmd, YANK, ctrl('Y'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('X') + \"r\");\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('X') + \"s\");\n+        bind(vicmd, SEND_BREAK, alt(ctrl('G')));\n+        bind(vicmd, BACKWARD_KILL_WORD, alt(ctrl('H')));\n+        bind(vicmd, SELF_INSERT_UNMETA, alt(ctrl('M')));\n+        bind(vicmd, COMPLETE_WORD, alt(esc()));\n+        bind(vicmd, CHARACTER_SEARCH_BACKWARD, alt(ctrl(']')));\n+        bind(vicmd, SET_MARK_COMMAND, alt(' '));\n+        \/\/        bind(vicmd, INSERT_COMMENT,                         alt('#'));\n+        \/\/        bind(vicmd, INSERT_COMPLETIONS,                     alt('*'));\n+        bind(vicmd, DIGIT_ARGUMENT, alt('-'));\n+        bind(vicmd, BEGINNING_OF_HISTORY, alt('<'));\n+        bind(vicmd, LIST_CHOICES, alt('='));\n+        bind(vicmd, END_OF_HISTORY, alt('>'));\n+        bind(vicmd, LIST_CHOICES, alt('?'));\n+        bind(vicmd, DO_LOWERCASE_VERSION, range(\"^[A-^[Z\"));\n+        bind(vicmd, BACKWARD_WORD, alt('b'));\n+        bind(vicmd, CAPITALIZE_WORD, alt('c'));\n+        bind(vicmd, KILL_WORD, alt('d'));\n+        bind(vicmd, FORWARD_WORD, alt('f'));\n+        bind(vicmd, DOWN_CASE_WORD, alt('l'));\n+        bind(vicmd, HISTORY_SEARCH_FORWARD, alt('n'));\n+        bind(vicmd, HISTORY_SEARCH_BACKWARD, alt('p'));\n+        bind(vicmd, TRANSPOSE_WORDS, alt('t'));\n+        bind(vicmd, UP_CASE_WORD, alt('u'));\n+        bind(vicmd, YANK_POP, alt('y'));\n+        bind(vicmd, BACKWARD_KILL_WORD, alt(del()));\n+\n+        bind(vicmd, FORWARD_CHAR, \" \");\n+        bind(vicmd, VI_INSERT_COMMENT, \"#\");\n+        bind(vicmd, END_OF_LINE, \"$\");\n+        bind(vicmd, VI_MATCH_BRACKET, \"%\");\n+        bind(vicmd, VI_DOWN_LINE_OR_HISTORY, \"+\");\n+        bind(vicmd, VI_REV_REPEAT_FIND, \",\");\n+        bind(vicmd, VI_UP_LINE_OR_HISTORY, \"-\");\n+        bind(vicmd, VI_REPEAT_CHANGE, \".\");\n+        bind(vicmd, VI_HISTORY_SEARCH_BACKWARD, \"\/\");\n+        bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE, \"0\");\n+        bind(vicmd, DIGIT_ARGUMENT, range(\"1-9\"));\n+        bind(vicmd, VI_REPEAT_FIND, \";\");\n+        bind(vicmd, LIST_CHOICES, \"=\");\n+        bind(vicmd, VI_HISTORY_SEARCH_FORWARD, \"?\");\n+        bind(vicmd, VI_ADD_EOL, \"A\");\n+        bind(vicmd, VI_BACKWARD_BLANK_WORD, \"B\");\n+        bind(vicmd, VI_CHANGE_EOL, \"C\");\n+        bind(vicmd, VI_KILL_EOL, \"D\");\n+        bind(vicmd, VI_FORWARD_BLANK_WORD_END, \"E\");\n+        bind(vicmd, VI_FIND_PREV_CHAR, \"F\");\n+        bind(vicmd, VI_FETCH_HISTORY, \"G\");\n+        bind(vicmd, VI_INSERT_BOL, \"I\");\n+        bind(vicmd, VI_JOIN, \"J\");\n+        bind(vicmd, VI_REV_REPEAT_SEARCH, \"N\");\n+        bind(vicmd, VI_OPEN_LINE_ABOVE, \"O\");\n+        bind(vicmd, VI_PUT_BEFORE, \"P\");\n+        bind(vicmd, VI_REPLACE, \"R\");\n+        bind(vicmd, VI_KILL_LINE, \"S\");\n+        bind(vicmd, VI_FIND_PREV_CHAR_SKIP, \"T\");\n+        bind(vicmd, REDO, \"U\");\n+        bind(vicmd, VISUAL_LINE_MODE, \"V\");\n+        bind(vicmd, VI_FORWARD_BLANK_WORD, \"W\");\n+        bind(vicmd, VI_BACKWARD_DELETE_CHAR, \"X\");\n+        bind(vicmd, VI_YANK_WHOLE_LINE, \"Y\");\n+        bind(vicmd, VI_FIRST_NON_BLANK, \"^\");\n+        bind(vicmd, VI_ADD_NEXT, \"a\");\n+        bind(vicmd, VI_BACKWARD_WORD, \"b\");\n+        bind(vicmd, VI_CHANGE, \"c\");\n+        bind(vicmd, VI_DELETE, \"d\");\n+        bind(vicmd, VI_FORWARD_WORD_END, \"e\");\n+        bind(vicmd, VI_FIND_NEXT_CHAR, \"f\");\n+        bind(vicmd, WHAT_CURSOR_POSITION, \"ga\");\n+        bind(vicmd, VI_BACKWARD_BLANK_WORD_END, \"gE\");\n+        bind(vicmd, VI_BACKWARD_WORD_END, \"ge\");\n+        bind(vicmd, VI_BACKWARD_CHAR, \"h\");\n+        bind(vicmd, VI_INSERT, \"i\");\n+        bind(vicmd, DOWN_LINE_OR_HISTORY, \"j\");\n+        bind(vicmd, UP_LINE_OR_HISTORY, \"k\");\n+        bind(vicmd, VI_FORWARD_CHAR, \"l\");\n+        bind(vicmd, VI_REPEAT_SEARCH, \"n\");\n+        bind(vicmd, VI_OPEN_LINE_BELOW, \"o\");\n+        bind(vicmd, VI_PUT_AFTER, \"p\");\n+        bind(vicmd, VI_REPLACE_CHARS, \"r\");\n+        bind(vicmd, VI_SUBSTITUTE, \"s\");\n+        bind(vicmd, VI_FIND_NEXT_CHAR_SKIP, \"t\");\n+        bind(vicmd, UNDO, \"u\");\n+        bind(vicmd, VISUAL_MODE, \"v\");\n+        bind(vicmd, VI_FORWARD_WORD, \"w\");\n+        bind(vicmd, VI_DELETE_CHAR, \"x\");\n+        bind(vicmd, VI_YANK, \"y\");\n+        bind(vicmd, VI_GOTO_COLUMN, \"|\");\n+        bind(vicmd, VI_SWAP_CASE, \"~\");\n+        bind(vicmd, VI_BACKWARD_CHAR, del());\n@@ -6153,3 +6306,3 @@\n-        bind(menu, MENU_COMPLETE,                     \"\\t\");\n-        bind(menu, REVERSE_MENU_COMPLETE,             key(Capability.back_tab));\n-        bind(menu, ACCEPT_LINE,                       \"\\r\", \"\\n\");\n+        bind(menu, MENU_COMPLETE, \"\\t\");\n+        bind(menu, REVERSE_MENU_COMPLETE, key(Capability.back_tab));\n+        bind(menu, ACCEPT_LINE, \"\\r\", \"\\n\");\n@@ -6162,3 +6315,3 @@\n-        bind(safe, SELF_INSERT,                 range(\"^@-^?\"));\n-        bind(safe, ACCEPT_LINE,                 \"\\r\", \"\\n\");\n-        bind(safe, SEND_BREAK,                  ctrl('G'));\n+        bind(safe, SELF_INSERT, range(\"^@-^?\"));\n+        bind(safe, ACCEPT_LINE, \"\\r\", \"\\n\");\n+        bind(safe, SEND_BREAK, ctrl('G'));\n@@ -6168,0 +6321,8 @@\n+    public KeyMap<Binding> dumb() {\n+        KeyMap<Binding> dumb = new KeyMap<>();\n+        bind(dumb, SELF_INSERT, range(\"^@-^?\"));\n+        bind(dumb, ACCEPT_LINE, \"\\r\", \"\\n\");\n+        bind(dumb, BEEP, ctrl('G'));\n+        return dumb;\n+    }\n+\n@@ -6170,7 +6331,7 @@\n-        bind(visual, UP_LINE,                   key(Capability.key_up),     \"k\");\n-        bind(visual, DOWN_LINE,                 key(Capability.key_down),   \"j\");\n-        bind(visual, this::deactivateRegion,    esc());\n-        bind(visual, EXCHANGE_POINT_AND_MARK,   \"o\");\n-        bind(visual, PUT_REPLACE_SELECTION,     \"p\");\n-        bind(visual, VI_DELETE,                 \"x\");\n-        bind(visual, VI_OPER_SWAP_CASE,         \"~\");\n+        bind(visual, UP_LINE, key(Capability.key_up), \"k\");\n+        bind(visual, DOWN_LINE, key(Capability.key_down), \"j\");\n+        bind(visual, this::deactivateRegion, esc());\n+        bind(visual, EXCHANGE_POINT_AND_MARK, \"o\");\n+        bind(visual, PUT_REPLACE_SELECTION, \"p\");\n+        bind(visual, VI_DELETE, \"x\");\n+        bind(visual, VI_OPER_SWAP_CASE, \"~\");\n@@ -6182,3 +6343,3 @@\n-        bind(viOpp, UP_LINE,                    key(Capability.key_up),     \"k\");\n-        bind(viOpp, DOWN_LINE,                  key(Capability.key_down),   \"j\");\n-        bind(viOpp, VI_CMD_MODE,                esc());\n+        bind(viOpp, UP_LINE, key(Capability.key_up), \"k\");\n+        bind(viOpp, DOWN_LINE, key(Capability.key_down), \"j\");\n+        bind(viOpp, VI_CMD_MODE, esc());\n@@ -6213,13 +6374,13 @@\n-        bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));\n-        bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));\n-        bind(map, BACKWARD_CHAR,        key(Capability.key_left));\n-        bind(map, FORWARD_CHAR,         key(Capability.key_right));\n-        bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));\n-        bind(map, END_OF_LINE,          key(Capability.key_end));\n-        bind(map, DELETE_CHAR,          key(Capability.key_dc));\n-        bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));\n-        bind(map, OVERWRITE_MODE,       key(Capability.key_ic));\n-        bind(map, MOUSE,                key(Capability.key_mouse));\n-        bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);\n-        bind(map, FOCUS_IN,             FOCUS_IN_SEQ);\n-        bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);\n+        bind(map, UP_LINE_OR_SEARCH, key(Capability.key_up));\n+        bind(map, DOWN_LINE_OR_SEARCH, key(Capability.key_down));\n+        bind(map, BACKWARD_CHAR, key(Capability.key_left));\n+        bind(map, FORWARD_CHAR, key(Capability.key_right));\n+        bind(map, BEGINNING_OF_LINE, key(Capability.key_home));\n+        bind(map, END_OF_LINE, key(Capability.key_end));\n+        bind(map, DELETE_CHAR, key(Capability.key_dc));\n+        bind(map, KILL_WHOLE_LINE, key(Capability.key_dl));\n+        bind(map, OVERWRITE_MODE, key(Capability.key_ic));\n+        bind(map, MOUSE, key(Capability.key_mouse));\n+        bind(map, BEGIN_PASTE, BRACKETED_PASTE_BEGIN);\n+        bind(map, FOCUS_IN, FOCUS_IN_SEQ);\n+        bind(map, FOCUS_OUT, FOCUS_OUT_SEQ);\n@@ -6234,8 +6395,4 @@\n-            rebind(keyMap, BACKWARD_DELETE_CHAR,\n-                    del(), (char) attr.getControlChar(ControlChar.VERASE));\n-            rebind(keyMap, BACKWARD_KILL_WORD,\n-                    ctrl('W'),  (char) attr.getControlChar(ControlChar.VWERASE));\n-            rebind(keyMap, KILL_WHOLE_LINE,\n-                    ctrl('U'), (char) attr.getControlChar(ControlChar.VKILL));\n-            rebind(keyMap, QUOTED_INSERT,\n-                    ctrl('V'), (char) attr.getControlChar(ControlChar.VLNEXT));\n+            rebind(keyMap, BACKWARD_DELETE_CHAR, del(), (char) attr.getControlChar(ControlChar.VERASE));\n+            rebind(keyMap, BACKWARD_KILL_WORD, ctrl('W'), (char) attr.getControlChar(ControlChar.VWERASE));\n+            rebind(keyMap, KILL_WHOLE_LINE, ctrl('U'), (char) attr.getControlChar(ControlChar.VKILL));\n+            rebind(keyMap, QUOTED_INSERT, ctrl('V'), (char) attr.getControlChar(ControlChar.VLNEXT));\n@@ -6253,1 +6410,0 @@\n-    \/\/ JDK specific modification\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":679,"deletions":523,"binary":false,"changes":1202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -16,1 +16,1 @@\n-    private ReaderUtils() { }\n+    private ReaderUtils() {}\n@@ -33,2 +33,1 @@\n-            return s.isEmpty() || s.equalsIgnoreCase(\"on\")\n-                    || s.equalsIgnoreCase(\"1\") || s.equalsIgnoreCase(\"true\");\n+            return s.isEmpty() || s.equalsIgnoreCase(\"on\") || s.equalsIgnoreCase(\"1\") || s.equalsIgnoreCase(\"true\");\n@@ -80,1 +79,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/ReaderUtils.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -11,2 +11,0 @@\n-import jdk.internal.org.jline.reader.MaskingCallback;\n-\n@@ -15,0 +13,2 @@\n+import jdk.internal.org.jline.reader.MaskingCallback;\n+\n@@ -32,1 +32,1 @@\n-            for (int i = line.length(); i-- > 0;) {\n+            for (int i = line.length(); i-- > 0; ) {\n@@ -43,1 +43,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/SimpleMaskingCallback.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -23,0 +23,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -74,1 +75,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/UndoTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -27,3 +27,1 @@\n-public class AggregateCompleter\n-    implements Completer\n-{\n+public class AggregateCompleter implements Completer {\n@@ -81,3 +79,1 @@\n-        return getClass().getSimpleName() + \"{\" +\n-            \"completers=\" + completers +\n-            '}';\n+        return getClass().getSimpleName() + \"{\" + \"completers=\" + completers + '}';\n@@ -85,1 +81,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/AggregateCompleter.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -32,2 +32,1 @@\n-public class ArgumentCompleter implements Completer\n-{\n+public class ArgumentCompleter implements Completer {\n@@ -111,2 +110,1 @@\n-        }\n-        else {\n+        } else {\n@@ -116,1 +114,2 @@\n-        \/\/ ensure that all the previous completers are successful before allowing this completer to pass (only if strict).\n+        \/\/ ensure that all the previous completers are successful before allowing this completer to pass (only if\n+        \/\/ strict).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/ArgumentCompleter.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -22,2 +22,1 @@\n-public class EnumCompleter extends StringsCompleter\n-{\n+public class EnumCompleter extends StringsCompleter {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/EnumCompleter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -12,0 +12,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -44,1 +45,1 @@\n- * @deprecated use <code>jdk.internal.org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n+ * @deprecated use <code>org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n@@ -47,2 +48,1 @@\n-public class FileNameCompleter implements Completer\n-{\n+public class FileNameCompleter implements Completer {\n@@ -75,2 +75,2 @@\n-        try {\n-            Files.newDirectoryStream(current, this::accept).forEach(p -> {\n+        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(current, this::accept)) {\n+            directoryStream.forEach(p -> {\n@@ -82,1 +82,2 @@\n-                            null, null,\n+                            null,\n+                            null,\n@@ -87,2 +88,2 @@\n-                    candidates.add(new Candidate(value, getDisplay(reader.getTerminal(), p),\n-                            null, null, null, null, true));\n+                    candidates.add(\n+                            new Candidate(value, getDisplay(reader.getTerminal(), p), null, null, null, null, true));\n@@ -128,1 +129,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/FileNameCompleter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,3 +25,1 @@\n-public final class NullCompleter\n-    implements Completer\n-{\n+public final class NullCompleter implements Completer {\n@@ -30,2 +28,1 @@\n-    public void complete(LineReader reader, final ParsedLine line, final List<Candidate> candidates) {\n-    }\n+    public void complete(LineReader reader, final ParsedLine line, final List<Candidate> candidates) {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/NullCompleter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -30,2 +30,1 @@\n-public class StringsCompleter implements Completer\n-{\n+public class StringsCompleter implements Completer {\n@@ -57,1 +56,1 @@\n-    public StringsCompleter(Candidate ... candidates) {\n+    public StringsCompleter(Candidate... candidates) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/StringsCompleter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -25,2 +25,2 @@\n-    private Map<String,List<Completer>> completers = new HashMap<>();\n-    private Map<String,String> aliasCommand = new HashMap<>();\n+    private Map<String, List<Completer>> completers = new HashMap<>();\n+    private Map<String, String> aliasCommand = new HashMap<>();\n@@ -47,3 +47,3 @@\n-                    for (String c: completers.keySet()) {\n-                        candidates.add(new Candidate(AttributedString.stripAnsi(curBuf+c)\n-                                    , c, null, null, null, null, true));\n+                    for (String c : completers.keySet()) {\n+                        candidates.add(\n+                                new Candidate(AttributedString.stripAnsi(curBuf + c), c, null, null, null, null, true));\n@@ -84,1 +84,1 @@\n-        for (String c: commands) {\n+        for (String c : commands) {\n@@ -107,2 +107,2 @@\n-        for (Map.Entry<String, List<Completer>> entry: other.getCompleters().entrySet()) {\n-            for (Completer c: entry.getValue()) {\n+        for (Map.Entry<String, List<Completer>> entry : other.getCompleters().entrySet()) {\n+            for (Completer c : entry.getValue()) {\n@@ -115,1 +115,1 @@\n-    public void addAliases(Map<String,String> aliasCommand) {\n+    public void addAliases(Map<String, String> aliasCommand) {\n@@ -122,1 +122,1 @@\n-    private Map<String,String> getAliases() {\n+    private Map<String, String> getAliases() {\n@@ -131,1 +131,1 @@\n-        for (Map.Entry<String, List<Completer>> entry: completers.entrySet()) {\n+        for (Map.Entry<String, List<Completer>> entry : completers.entrySet()) {\n@@ -146,1 +146,1 @@\n-    public Map<String,List<Completer>> getCompleters() {\n+    public Map<String, List<Completer>> getCompleters() {\n@@ -149,1 +149,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -44,2 +44,1 @@\n-    public DefaultHistory() {\n-    }\n+    public DefaultHistory() {}\n@@ -47,0 +46,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -70,2 +70,1 @@\n-            }\n-            catch (IllegalArgumentException | IOException e) {\n+            } catch (IllegalArgumentException | IOException e) {\n@@ -120,1 +119,1 @@\n-    private String doHistoryFileDataKey (Path path){\n+    private String doHistoryFileDataKey(Path path) {\n@@ -126,1 +125,1 @@\n-        if (!historyFiles.containsKey(key)){\n+        if (!historyFiles.containsKey(key)) {\n@@ -136,1 +135,1 @@\n-    private boolean isLineReaderHistory (Path path) throws IOException {\n+    private boolean isLineReaderHistory(Path path) throws IOException {\n@@ -144,1 +143,1 @@\n-    private void setLastLoaded(Path path, int lastloaded){\n+    private void setLastLoaded(Path path, int lastloaded) {\n@@ -148,1 +147,1 @@\n-    private void setEntriesInFile(Path path, int entriesInFile){\n+    private void setEntriesInFile(Path path, int entriesInFile) {\n@@ -152,1 +151,1 @@\n-    private void incEntriesInFile(Path path, int amount){\n+    private void incEntriesInFile(Path path, int amount) {\n@@ -156,1 +155,1 @@\n-    private int getLastLoaded(Path path){\n+    private int getLastLoaded(Path path) {\n@@ -160,1 +159,1 @@\n-    private int getEntriesInFile(Path path){\n+    private int getEntriesInFile(Path path) {\n@@ -171,3 +170,2 @@\n-            final String badHistoryFileSyntax = \"Bad history file syntax! \" +\n-                \"The history file `\" + path + \"` may be an older history: \" +\n-                \"please remove it or use a different history file.\";\n+            final String badHistoryFileSyntax = \"Bad history file syntax! \" + \"The history file `\" + path\n+                    + \"` may be an older history: \" + \"please remove it or use a different history file.\";\n@@ -186,2 +184,1 @@\n-        }\n-        else {\n+        } else {\n@@ -213,2 +210,1 @@\n-        internalWrite(file != null ? file : getPath(),\n-                      incremental ? getLastLoaded(file) : 0);\n+        internalWrite(file != null ? file : getPath(), incremental ? getLastLoaded(file) : 0);\n@@ -230,2 +226,5 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(path.toAbsolutePath(),\n-              StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(\n+                    path.toAbsolutePath(),\n+                    StandardOpenOption.WRITE,\n+                    StandardOpenOption.APPEND,\n+                    StandardOpenOption.CREATE)) {\n@@ -251,6 +250,10 @@\n-        try (BufferedReader reader = Files.newBufferedReader(path)) {\n-            reader.lines().forEach(l -> {\n-                int idx = l.indexOf(':');\n-                Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));\n-                String line = unescape(l.substring(idx + 1));\n-                allItems.add(createEntry(allItems.size(), time, line));\n+        try (BufferedReader historyFileReader = Files.newBufferedReader(path)) {\n+            historyFileReader.lines().forEach(l -> {\n+                if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {\n+                    int idx = l.indexOf(':');\n+                    Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));\n+                    String line = unescape(l.substring(idx + 1));\n+                    allItems.add(createEntry(allItems.size(), time, line));\n+                } else {\n+                    allItems.add(createEntry(allItems.size(), Instant.now(), unescape(l)));\n+                }\n@@ -262,1 +265,2 @@\n-        Path temp = Files.createTempFile(path.toAbsolutePath().getParent(), path.getFileName().toString(), \".tmp\");\n+        Path temp = Files.createTempFile(\n+                path.toAbsolutePath().getParent(), path.getFileName().toString(), \".tmp\");\n@@ -354,1 +358,1 @@\n-            throw new IllegalArgumentException(\"IndexOutOfBounds: Index:\" + idx +\", Size:\" + items.size());\n+            throw new IllegalArgumentException(\"IndexOutOfBounds: Index:\" + idx + \", Size:\" + items.size());\n@@ -385,2 +389,1 @@\n-            }\n-            catch (IOException e) {\n+            } catch (IOException e) {\n@@ -420,1 +423,1 @@\n-            for (Entry e: items) {\n+            for (Entry e : items) {\n@@ -433,1 +436,1 @@\n-            for (HistoryFileData hfd: historyFiles.values()) {\n+            for (HistoryFileData hfd : historyFiles.values()) {\n@@ -636,2 +639,1 @@\n-        public HistoryFileData() {\n-        }\n+        public HistoryFileData() {}\n@@ -670,1 +672,0 @@\n-\n@@ -672,1 +673,0 @@\n-\n@@ -674,1 +674,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":38,"deletions":39,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -46,14 +46,16 @@\n-        IGNBRK,       \/* ignore BREAK condition *\/\n-        BRKINT,       \/* map BREAK to SIGINTR *\/\n-        IGNPAR,       \/* ignore (discard) parity errors *\/\n-        PARMRK,       \/* mark parity and framing errors *\/\n-        INPCK,        \/* enable checking of parity errors *\/\n-        ISTRIP,       \/* strip 8th bit off chars *\/\n-        INLCR,        \/* map NL into CR *\/\n-        IGNCR,        \/* ignore CR *\/\n-        ICRNL,        \/* map CR to NL (ala CRMOD) *\/\n-        IXON,         \/* enable output flow control *\/\n-        IXOFF,        \/* enable input flow control *\/\n-        IXANY,        \/* any char will restart after stop *\/\n-        IMAXBEL,      \/* ring bell on input queue full *\/\n-        IUTF8         \/* maintain state for UTF-8 VERASE *\/\n+        IGNBRK, \/* ignore BREAK condition *\/\n+        BRKINT, \/* map BREAK to SIGINTR *\/\n+        IGNPAR, \/* ignore (discard) parity errors *\/\n+        PARMRK, \/* mark parity and framing errors *\/\n+        INPCK, \/* enable checking of parity errors *\/\n+        ISTRIP, \/* strip 8th bit off chars *\/\n+        INLCR, \/* map NL into CR *\/\n+        IGNCR, \/* ignore CR *\/\n+        ICRNL, \/* map CR to NL (ala CRMOD) *\/\n+        IXON, \/* enable output flow control *\/\n+        IXOFF, \/* enable input flow control *\/\n+        IXANY, \/* any char will restart after stop *\/\n+        IMAXBEL, \/* ring bell on input queue full *\/\n+        IUTF8, \/* maintain state for UTF-8 VERASE *\/\n+\n+        INORMEOL \/* normalize end-of-line *\/\n@@ -66,15 +68,15 @@\n-        OPOST,       \/* enable following output processing *\/\n-        ONLCR,       \/* map NL to CR-NL (ala CRMOD) *\/\n-        OXTABS,      \/* expand tabs to spaces *\/\n-        ONOEOT,      \/* discard EOT's (^D) on output) *\/\n-        OCRNL,       \/* map CR to NL on output *\/\n-        ONOCR,       \/* no CR output at column 0 *\/\n-        ONLRET,      \/* NL performs CR function *\/\n-        OFILL,       \/* use fill characters for delay *\/\n-        NLDLY,       \/* \\n delay *\/\n-        TABDLY,      \/* horizontal tab delay *\/\n-        CRDLY,       \/* \\r delay *\/\n-        FFDLY,       \/* form feed delay *\/\n-        BSDLY,       \/* \\b delay *\/\n-        VTDLY,       \/* vertical tab delay *\/\n-        OFDEL        \/* fill is DEL, else NUL *\/\n+        OPOST, \/* enable following output processing *\/\n+        ONLCR, \/* map NL to CR-NL (ala CRMOD) *\/\n+        OXTABS, \/* expand tabs to spaces *\/\n+        ONOEOT, \/* discard EOT's (^D) on output) *\/\n+        OCRNL, \/* map CR to NL on output *\/\n+        ONOCR, \/* no CR output at column 0 *\/\n+        ONLRET, \/* NL performs CR function *\/\n+        OFILL, \/* use fill characters for delay *\/\n+        NLDLY, \/* \\n delay *\/\n+        TABDLY, \/* horizontal tab delay *\/\n+        CRDLY, \/* \\r delay *\/\n+        FFDLY, \/* form feed delay *\/\n+        BSDLY, \/* \\b delay *\/\n+        VTDLY, \/* vertical tab delay *\/\n+        OFDEL \/* fill is DEL, else NUL *\/\n@@ -87,16 +89,16 @@\n-        CIGNORE,          \/* ignore control flags *\/\n-        CS5,              \/* 5 bits    (pseudo) *\/\n-        CS6,              \/* 6 bits *\/\n-        CS7,              \/* 7 bits *\/\n-        CS8,              \/* 8 bits *\/\n-        CSTOPB,           \/* send 2 stop bits *\/\n-        CREAD,            \/* enable receiver *\/\n-        PARENB,           \/* parity enable *\/\n-        PARODD,           \/* odd parity, else even *\/\n-        HUPCL,            \/* hang up on last close *\/\n-        CLOCAL,           \/* ignore modem status lines *\/\n-        CCTS_OFLOW,       \/* CTS flow control of output *\/\n-        CRTS_IFLOW,       \/* RTS flow control of input *\/\n-        CDTR_IFLOW,       \/* DTR flow control of input *\/\n-        CDSR_OFLOW,       \/* DSR flow control of output *\/\n-        CCAR_OFLOW        \/* DCD flow control of output *\/\n+        CIGNORE, \/* ignore control flags *\/\n+        CS5, \/* 5 bits    (pseudo) *\/\n+        CS6, \/* 6 bits *\/\n+        CS7, \/* 7 bits *\/\n+        CS8, \/* 8 bits *\/\n+        CSTOPB, \/* send 2 stop bits *\/\n+        CREAD, \/* enable receiver *\/\n+        PARENB, \/* parity enable *\/\n+        PARODD, \/* odd parity, else even *\/\n+        HUPCL, \/* hang up on last close *\/\n+        CLOCAL, \/* ignore modem status lines *\/\n+        CCTS_OFLOW, \/* CTS flow control of output *\/\n+        CRTS_IFLOW, \/* RTS flow control of input *\/\n+        CDTR_IFLOW, \/* DTR flow control of input *\/\n+        CDSR_OFLOW, \/* DSR flow control of output *\/\n+        CCAR_OFLOW \/* DCD flow control of output *\/\n@@ -113,17 +115,17 @@\n-        ECHOKE,           \/* visual erase for line kill *\/\n-        ECHOE,            \/* visually erase chars *\/\n-        ECHOK,            \/* echo NL after line kill *\/\n-        ECHO,             \/* enable echoing *\/\n-        ECHONL,           \/* echo NL even if ECHO is off *\/\n-        ECHOPRT,          \/* visual erase mode for hardcopy *\/\n-        ECHOCTL,          \/* echo control chars as ^(Char) *\/\n-        ISIG,             \/* enable signals INTR, QUIT, [D]SUSP *\/\n-        ICANON,           \/* canonicalize input lines *\/\n-        ALTWERASE,        \/* use alternate WERASE algorithm *\/\n-        IEXTEN,           \/* enable DISCARD and LNEXT *\/\n-        EXTPROC,          \/* external processing *\/\n-        TOSTOP,           \/* stop background jobs from output *\/\n-        FLUSHO,           \/* output being flushed (state) *\/\n-        NOKERNINFO,       \/* no kernel output from VSTATUS *\/\n-        PENDIN,           \/* XXX retype pending input (state) *\/\n-        NOFLSH            \/* don't flush after interrupt *\/\n+        ECHOKE, \/* visual erase for line kill *\/\n+        ECHOE, \/* visually erase chars *\/\n+        ECHOK, \/* echo NL after line kill *\/\n+        ECHO, \/* enable echoing *\/\n+        ECHONL, \/* echo NL even if ECHO is off *\/\n+        ECHOPRT, \/* visual erase mode for hardcopy *\/\n+        ECHOCTL, \/* echo control chars as ^(Char) *\/\n+        ISIG, \/* enable signals INTR, QUIT, [D]SUSP *\/\n+        ICANON, \/* canonicalize input lines *\/\n+        ALTWERASE, \/* use alternate WERASE algorithm *\/\n+        IEXTEN, \/* enable DISCARD and LNEXT *\/\n+        EXTPROC, \/* external processing *\/\n+        TOSTOP, \/* stop background jobs from output *\/\n+        FLUSHO, \/* output being flushed (state) *\/\n+        NOKERNINFO, \/* no kernel output from VSTATUS *\/\n+        PENDIN, \/* XXX retype pending input (state) *\/\n+        NOFLSH \/* don't flush after interrupt *\/\n@@ -138,2 +140,1 @@\n-    public Attributes() {\n-    }\n+    public Attributes() {}\n@@ -141,0 +142,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -313,7 +315,6 @@\n-        return \"Attributes[\" +\n-                \"lflags: \" + append(lflag) + \", \" +\n-                \"iflags: \" + append(iflag) + \", \" +\n-                \"oflags: \" + append(oflag) + \", \" +\n-                \"cflags: \" + append(cflag) + \", \" +\n-                \"cchars: \" + append(EnumSet.allOf(ControlChar.class), this::display) +\n-                \"]\";\n+        return \"Attributes[\" + \"lflags: \"\n+                + append(lflag) + \", \" + \"iflags: \"\n+                + append(iflag) + \", \" + \"oflags: \"\n+                + append(oflag) + \", \" + \"cflags: \"\n+                + append(cflag) + \", \" + \"cchars: \"\n+                + append(EnumSet.allOf(ControlChar.class), this::display) + \"]\";\n@@ -348,1 +349,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Attributes.java","additions":73,"deletions":73,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Cursor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -74,7 +74,6 @@\n-        return \"MouseEvent[\" +\n-                \"type=\" + type +\n-                \", button=\" + button +\n-                \", modifiers=\" + modifiers +\n-                \", x=\" + x +\n-                \", y=\" + y +\n-                ']';\n+        return \"MouseEvent[\" + \"type=\"\n+                + type + \", button=\"\n+                + button + \", modifiers=\"\n+                + modifiers + \", x=\"\n+                + x + \", y=\"\n+                + y + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/MouseEvent.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -16,2 +16,1 @@\n-    public Size() {\n-    }\n+    public Size() {}\n@@ -19,0 +18,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -53,1 +53,1 @@\n-        return row * (cols+1) + col;\n+        return row * (cols + 1) + col;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Size.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -37,0 +37,1 @@\n+\n@@ -45,0 +46,3 @@\n+    \/**\n+     * Types of signals.\n+     *\/\n@@ -54,0 +58,5 @@\n+    \/**\n+     * The SignalHandler defines the interface used to trap signals and perform specific behaviors.\n+     * @see Terminal.Signal\n+     * @see Terminal#handle(Signal, SignalHandler)\n+     *\/\n@@ -56,0 +65,4 @@\n+        \/**\n+         * The {@code SIG_DFL} value can be used to specify that the JVM default behavior\n+         * should be used to handle this signal.\n+         *\/\n@@ -57,0 +70,5 @@\n+\n+        \/**\n+         * The {@code SIG_IGN} value can be used to ignore this signal and not perform\n+         * any special processing.\n+         *\/\n@@ -59,0 +77,4 @@\n+        \/**\n+         * Handle the signal.\n+         * @param signal the signal\n+         *\/\n@@ -62,0 +84,10 @@\n+    \/**\n+     * Registers a handler for the given {@link Signal}.\n+     * <p>\n+     * Note that the JVM does not easily allow catching the {@link Signal#QUIT} signal, which causes a thread dump\n+     * to be displayed.  This signal is mainly used when connecting through an SSH socket to a virtual terminal.\n+     *\n+     * @param signal the signal to register a handler for\n+     * @param handler the handler\n+     * @return the previous signal handler\n+     *\/\n@@ -64,0 +96,11 @@\n+    \/**\n+     * Raise the specific signal.\n+     * This is not method usually called by non system terminals.\n+     * When accessing a terminal through a SSH or Telnet connection, signals may be\n+     * conveyed by the protocol and thus need to be raised when reaching the terminal code.\n+     * The terminals do that automatically when the terminal input stream has a character\n+     * mapped to {@link Attributes.ControlChar#VINTR}, {@link Attributes.ControlChar#VQUIT},\n+     * or {@link Attributes.ControlChar#VSUSP}.\n+     *\n+     * @param signal the signal to raise\n+     *\/\n@@ -183,0 +226,7 @@\n+    \/**\n+     * Returns the terminal attributes.\n+     * The returned object can be safely modified\n+     * further used in a call to {@link #setAttributes(Attributes)}.\n+     *\n+     * @return the terminal attributes.\n+     *\/\n@@ -185,0 +235,6 @@\n+    \/**\n+     * Set the terminal attributes.\n+     * The terminal will perform a copy of the given attributes.\n+     *\n+     * @param attr the new attributes\n+     *\/\n@@ -337,1 +393,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Terminal.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -11,3 +11,0 @@\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -22,0 +19,4 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n@@ -27,0 +28,1 @@\n+import java.util.Set;\n@@ -34,1 +36,0 @@\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n@@ -36,0 +37,3 @@\n+import jdk.internal.org.jline.terminal.impl.DumbTerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalExt;\n@@ -52,4 +56,16 @@\n-    public static final String PROP_JNA = \"org.jline.terminal.jna\";\n-    public static final String PROP_JANSI = \"org.jline.terminal.jansi\";\n-    public static final String PROP_EXEC = \"org.jline.terminal.exec\";\n-    public static final String PROP_DUMB = \"org.jline.terminal.dumb\";\n+    public static final String PROP_PROVIDER = \"org.jline.terminal.provider\";\n+    public static final String PROP_PROVIDERS = \"org.jline.terminal.providers\";\n+    public static final String PROP_PROVIDER_FFM = \"ffm\";\n+    public static final String PROP_PROVIDER_JNI = \"jni\";\n+    public static final String PROP_PROVIDER_JANSI = \"jansi\";\n+    public static final String PROP_PROVIDER_JNA = \"jna\";\n+    public static final String PROP_PROVIDER_EXEC = \"exec\";\n+    public static final String PROP_PROVIDER_DUMB = \"dumb\";\n+    public static final String PROP_PROVIDERS_DEFAULT = String.join(\n+            \",\", PROP_PROVIDER_FFM, PROP_PROVIDER_JNI, PROP_PROVIDER_JANSI, PROP_PROVIDER_JNA, PROP_PROVIDER_EXEC);\n+    public static final String PROP_FFM = \"org.jline.terminal.\" + PROP_PROVIDER_FFM;\n+    public static final String PROP_JNI = \"org.jline.terminal.\" + PROP_PROVIDER_JNI;\n+    public static final String PROP_JANSI = \"org.jline.terminal.\" + PROP_PROVIDER_JANSI;\n+    public static final String PROP_JNA = \"org.jline.terminal.\" + PROP_PROVIDER_JNA;\n+    public static final String PROP_EXEC = \"org.jline.terminal.\" + PROP_PROVIDER_EXEC;\n+    public static final String PROP_DUMB = \"org.jline.terminal.\" + PROP_PROVIDER_DUMB;\n@@ -62,0 +78,2 @@\n+    public static final String PROP_OUTPUT_FORCED_OUT = \"forced-out\";\n+    public static final String PROP_OUTPUT_FORCED_ERR = \"forced-err\";\n@@ -71,0 +89,26 @@\n+    \/\/\n+    \/\/ System properties controlling how FileDescriptor are create.\n+    \/\/ The value can be a comma separated list of defined mechanisms.\n+    \/\/\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE = \"org.jline.terminal.pty.fileDescriptorCreationMode\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE = \"native\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION = \"reflection\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT =\n+            String.join(\",\", PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION, PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE);\n+\n+    \/\/\n+    \/\/ System properties controlling how RedirectPipe are created.\n+    \/\/ The value can be a comma separated list of defined mechanisms.\n+    \/\/\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE = \"org.jline.terminal.exec.redirectPipeCreationMode\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE = \"native\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION = \"reflection\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT =\n+            String.join(\",\", PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION, PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE);\n+\n+    public static final Set<String> DEPRECATED_PROVIDERS =\n+            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(PROP_PROVIDER_JNA, PROP_PROVIDER_JANSI)));\n+\n+    public static final String PROP_DISABLE_DEPRECATED_PROVIDER_WARNING =\n+            \"org.jline.terminal.disableDeprecatedProviderWarning\";\n+\n@@ -78,1 +122,3 @@\n-        SysErrOrSysOut\n+        SysErrOrSysOut,\n+        ForcedSysOut,\n+        ForcedSysErr\n@@ -118,0 +164,2 @@\n+    private String provider;\n+    private String providers;\n@@ -120,0 +168,1 @@\n+    private Boolean jni;\n@@ -121,0 +170,1 @@\n+    private Boolean ffm;\n@@ -125,1 +175,1 @@\n-    private boolean nativeSignals = false;\n+    private boolean nativeSignals = true;\n@@ -130,2 +180,1 @@\n-    private TerminalBuilder() {\n-    }\n+    private TerminalBuilder() {}\n@@ -163,0 +212,10 @@\n+    public TerminalBuilder provider(String provider) {\n+        this.provider = provider;\n+        return this;\n+    }\n+\n+    public TerminalBuilder providers(String providers) {\n+        this.providers = providers;\n+        return this;\n+    }\n+\n@@ -173,0 +232,5 @@\n+    public TerminalBuilder jni(boolean jni) {\n+        this.jni = jni;\n+        return this;\n+    }\n+\n@@ -178,0 +242,5 @@\n+    public TerminalBuilder ffm(boolean ffm) {\n+        this.ffm = ffm;\n+        return this;\n+    }\n+\n@@ -283,0 +352,6 @@\n+    \/**\n+     * Determines the default value for signal handlers.\n+     * All signals will be mapped to the given handler.\n+     * @param signalHandler the default signal handler\n+     * @return The builder\n+     *\/\n@@ -308,0 +383,5 @@\n+    \/**\n+     * Builds the terminal.\n+     * @return the newly created terminal, never {@code null}\n+     * @throws IOException if an error occurs\n+     *\/\n@@ -316,1 +396,2 @@\n-            Log.debug(() -> \"Using pty \" + ((AbstractPosixTerminal) terminal).getPty().getClass().getSimpleName());\n+            Log.debug(() -> \"Using pty \"\n+                    + ((AbstractPosixTerminal) terminal).getPty().getClass().getSimpleName());\n@@ -326,39 +407,6 @@\n-        Charset encoding = this.encoding;\n-        if (encoding == null) {\n-            String charsetName = System.getProperty(PROP_ENCODING);\n-            if (charsetName != null && Charset.isSupported(charsetName)) {\n-                encoding = Charset.forName(charsetName);\n-            }\n-        }\n-        if (encoding == null) {\n-            int codepage = this.codepage;\n-            if (codepage <= 0) {\n-                String str = System.getProperty(PROP_CODEPAGE);\n-                if (str != null) {\n-                    codepage = Integer.parseInt(str);\n-                }\n-            }\n-            if (codepage >= 0) {\n-                encoding = getCodepageCharset(codepage);\n-            } else {\n-                encoding = StandardCharsets.UTF_8;\n-            }\n-        }\n-        String type = this.type;\n-        if (type == null) {\n-            type = System.getProperty(PROP_TYPE);\n-        }\n-        if (type == null) {\n-            type = System.getenv(\"TERM\");\n-        }\n-        Boolean jna = this.jna;\n-        if (jna == null) {\n-            jna = getBoolean(PROP_JNA, true);\n-        }\n-        Boolean jansi = this.jansi;\n-        if (jansi == null) {\n-            jansi = getBoolean(PROP_JANSI, true);\n-        }\n-        Boolean exec = this.exec;\n-        if (exec == null) {\n-            exec = getBoolean(PROP_EXEC, true);\n+        Charset encoding = computeEncoding();\n+        String type = computeType();\n+\n+        String provider = this.provider;\n+        if (provider == null) {\n+            provider = System.getProperty(PROP_PROVIDER, null);\n@@ -366,0 +414,4 @@\n+\n+        boolean forceDumb =\n+                (DumbTerminal.TYPE_DUMB.equals(type) || type != null && type.startsWith(DumbTerminal.TYPE_DUMB_COLOR))\n+                        || (provider != null && provider.equals(PROP_PROVIDER_DUMB));\n@@ -371,30 +423,1 @@\n-        List<TerminalProvider> providers = new ArrayList<>();\n-        if (jna) {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"jna\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load JNA support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-        if (jansi) {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"jansi\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load JANSI support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-        if (exec)\n-        {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"exec\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load EXEC support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-\n+        List<TerminalProvider> providers = getProviders(provider, exception);\n@@ -403,2 +426,3 @@\n-            if (system != null && ((in != null && !in.equals(System.in)) ||\n-                    (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n+            if (system != null\n+                    && ((in != null && !in.equals(System.in))\n+                            || (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n@@ -410,28 +434,5 @@\n-            if (out != null) {\n-                if (out.equals(System.out)) {\n-                    systemOutput = SystemOutput.SysOut;\n-                } else if (out.equals(System.err)) {\n-                    systemOutput = SystemOutput.SysErr;\n-                }\n-            }\n-            if (systemOutput == null) {\n-                String str = System.getProperty(PROP_OUTPUT);\n-                if (str != null) {\n-                    switch (str.trim().toLowerCase(Locale.ROOT)) {\n-                        case PROP_OUTPUT_OUT: systemOutput = SystemOutput.SysOut; break;\n-                        case PROP_OUTPUT_ERR: systemOutput = SystemOutput.SysErr; break;\n-                        case PROP_OUTPUT_OUT_ERR: systemOutput = SystemOutput.SysOutOrSysErr; break;\n-                        case PROP_OUTPUT_ERR_OUT: systemOutput = SystemOutput.SysErrOrSysOut; break;\n-                        default:\n-                            Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n-                                    + String.join(\", \", PROP_OUTPUT_OUT, PROP_OUTPUT_ERR, PROP_OUTPUT_OUT_ERR,PROP_OUTPUT_ERR_OUT)\n-                                    + \".\");\n-                    }\n-                }\n-            }\n-            if (systemOutput == null) {\n-                systemOutput = SystemOutput.SysOutOrSysErr;\n-            }\n-            Map<TerminalProvider.Stream, Boolean> system = Stream.of(TerminalProvider.Stream.values())\n-                    .collect(Collectors.toMap(stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n-            TerminalProvider.Stream console = select(system, systemOutput);\n+            SystemOutput systemOutput = computeSystemOutput();\n+            Map<SystemStream, Boolean> system = Stream.of(SystemStream.values())\n+                    .collect(Collectors.toMap(\n+                            stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n+            SystemStream systemStream = select(system, systemOutput);\n@@ -439,1 +440,1 @@\n-            if (system.get(TerminalProvider.Stream.Input) && console != null) {\n+            if (!forceDumb && system.get(SystemStream.Input) && systemStream != null) {\n@@ -446,2 +447,4 @@\n-                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)  && \"xterm\".equals(type)\n-                        && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)\n+                        && \"xterm\".equals(type)\n+                        && this.type == null\n+                        && System.getProperty(PROP_TYPE) == null) {\n@@ -450,1 +453,1 @@\n-                for ( TerminalProvider provider : providers) {\n+                for (TerminalProvider prov : providers) {\n@@ -453,2 +456,10 @@\n-                            terminal = provider.sysTerminal(name, type, ansiPassThrough, encoding,\n-                                    nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+                            terminal = prov.sysTerminal(\n+                                    name,\n+                                    type,\n+                                    ansiPassThrough,\n+                                    encoding,\n+                                    nativeSignals,\n+                                    signalHandler,\n+                                    paused,\n+                                    systemStream,\n+                                    inputStreamWrapper);\n@@ -456,1 +467,1 @@\n-                            Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                            Log.debug(\"Error creating \" + prov.name() + \" based terminal: \", t.getMessage(), t);\n@@ -461,3 +472,5 @@\n-                if (terminal == null && OSUtils.IS_WINDOWS &&  !jna && !jansi && (dumb == null || !dumb)) {\n-                    throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n-                            + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n+                if (terminal == null && OSUtils.IS_WINDOWS && providers.isEmpty() && (dumb == null || !dumb)) {\n+                    throw new IllegalStateException(\n+                            \"Unable to create a system terminal. On Windows, either JLine's native libraries, JNA \"\n+                                    + \"or Jansi library is required.  Make sure to add one of those in the classpath.\",\n+                            exception);\n@@ -471,3 +484,3 @@\n-                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \"\n+                            + \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \"\n+                            + \"or that previously created system Terminals have been correctly closed.\"));\n@@ -478,27 +491,10 @@\n-            if (terminal == null && (dumb == null || dumb)) {\n-                \/\/ forced colored dumb terminal\n-                Boolean color = this.color;\n-                if (color == null) {\n-                    color = getBoolean(PROP_DUMB_COLOR, false);\n-                    \/\/ detect emacs using the env variable\n-                    if (!color) {\n-                        String emacs = System.getenv(\"INSIDE_EMACS\");\n-                        color = emacs != null && emacs.contains(\"comint\");\n-                    }\n-                    \/\/ detect Intellij Idea\n-                    if (!color) {\n-                        String command = getParentProcessCommand();\n-                        color = command != null && command.contains(\"idea\");\n-                    }\n-                    if (!color) {\n-                        color = system.get(TerminalProvider.Stream.Output) && System.getenv(\"TERM\") != null;\n-                    }\n-                    if (!color && dumb == null) {\n-                        if (Log.isDebugEnabled()) {\n-                            Log.warn(\"input is tty: {}\", system.get(TerminalProvider.Stream.Input));\n-                            Log.warn(\"output is tty: {}\", system.get(TerminalProvider.Stream.Output));\n-                            Log.warn(\"error is tty: {}\", system.get(TerminalProvider.Stream.Error));\n-                            Log.warn(\"Creating a dumb terminal\", exception);\n-                        } else {\n-                            Log.warn(\"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n-                        }\n+            if (terminal == null && (forceDumb || dumb == null || dumb)) {\n+                if (!forceDumb && dumb == null) {\n+                    if (Log.isDebugEnabled()) {\n+                        Log.warn(\"input is tty: \" + system.get(SystemStream.Input));\n+                        Log.warn(\"output is tty: \" + system.get(SystemStream.Output));\n+                        Log.warn(\"error is tty: \" + system.get(SystemStream.Error));\n+                        Log.warn(\"Creating a dumb terminal\", exception);\n+                    } else {\n+                        Log.warn(\n+                                \"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n@@ -507,5 +503,8 @@\n-                terminal = new DumbTerminal(name, color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB,\n-                        new FileInputStream(FileDescriptor.in),\n-                        \/\/JDK change: always write into stdout:\n-                        new FileOutputStream(FileDescriptor.out),\n-                        encoding, signalHandler);\n+                type = getDumbTerminalType(dumb, systemStream);\n+                terminal = new DumbTerminalProvider()\n+                        .sysTerminal(name, type, false, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n+                if (OSUtils.IS_WINDOWS) {\n+                    Attributes attr = terminal.getAttributes();\n+                    attr.setInputFlag(Attributes.InputFlag.IGNCR, true);\n+                    terminal.setAttributes(attr);\n+                }\n@@ -514,1 +513,1 @@\n-            for ( TerminalProvider provider : providers) {\n+            for (TerminalProvider prov : providers) {\n@@ -517,1 +516,2 @@\n-                        terminal = provider.newTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n+                        terminal = prov.newTerminal(\n+                                name, type, in, out, encoding, signalHandler, paused, attributes, size);\n@@ -519,1 +519,1 @@\n-                        Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                        Log.debug(\"Error creating \" + prov.name() + \" based terminal: \", t.getMessage(), t);\n@@ -528,0 +528,9 @@\n+        if (terminal instanceof TerminalExt) {\n+            TerminalExt te = (TerminalExt) terminal;\n+            if (DEPRECATED_PROVIDERS.contains(te.getProvider().name())\n+                    && !getBoolean(PROP_DISABLE_DEPRECATED_PROVIDER_WARNING, false)) {\n+                Log.warn(\"The terminal provider \" + te.getProvider().name()\n+                        + \" has been deprecated, check your configuration. This warning can be disabled by setting the system property \"\n+                        + PROP_DISABLE_DEPRECATED_PROVIDER_WARNING + \" to true.\");\n+            }\n+        }\n@@ -531,1 +540,183 @@\n-    private TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, SystemOutput systemOutput) {\n+    private String getDumbTerminalType(Boolean dumb, SystemStream systemStream) {\n+        \/\/ forced colored dumb terminal\n+        Boolean color = this.color;\n+        if (color == null) {\n+            color = getBoolean(PROP_DUMB_COLOR, null);\n+        }\n+        if (dumb == null) {\n+            \/\/ detect emacs using the env variable\n+            if (color == null) {\n+                String emacs = System.getenv(\"INSIDE_EMACS\");\n+                if (emacs != null && emacs.contains(\"comint\")) {\n+                    color = true;\n+                }\n+            }\n+            \/\/ detect Intellij Idea\n+            if (color == null) {\n+                \/\/ using the env variable on windows\n+                String ideHome = System.getenv(\"IDE_HOME\");\n+                if (ideHome != null) {\n+                    color = true;\n+                } else {\n+                    \/\/ using the parent process command on unix\/mac\n+                    String command = getParentProcessCommand();\n+                    if (command != null && command.endsWith(\"\/idea\")) {\n+                        color = true;\n+                    }\n+                }\n+            }\n+            if (color == null) {\n+                color = systemStream != null && System.getenv(\"TERM\") != null;\n+            }\n+        } else {\n+            if (color == null) {\n+                color = false;\n+            }\n+        }\n+        return color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB;\n+    }\n+\n+    public SystemOutput computeSystemOutput() {\n+        SystemOutput systemOutput = null;\n+        if (out != null) {\n+            if (out.equals(System.out)) {\n+                systemOutput = SystemOutput.SysOut;\n+            } else if (out.equals(System.err)) {\n+                systemOutput = SystemOutput.SysErr;\n+            }\n+        }\n+        if (systemOutput == null) {\n+            systemOutput = this.systemOutput;\n+        }\n+        if (systemOutput == null) {\n+            String str = System.getProperty(PROP_OUTPUT);\n+            if (str != null) {\n+                switch (str.trim().toLowerCase(Locale.ROOT)) {\n+                    case PROP_OUTPUT_OUT:\n+                        systemOutput = SystemOutput.SysOut;\n+                        break;\n+                    case PROP_OUTPUT_ERR:\n+                        systemOutput = SystemOutput.SysErr;\n+                        break;\n+                    case PROP_OUTPUT_OUT_ERR:\n+                        systemOutput = SystemOutput.SysOutOrSysErr;\n+                        break;\n+                    case PROP_OUTPUT_ERR_OUT:\n+                        systemOutput = SystemOutput.SysErrOrSysOut;\n+                        break;\n+                    case PROP_OUTPUT_FORCED_OUT:\n+                        systemOutput = SystemOutput.ForcedSysOut;\n+                        break;\n+                    case PROP_OUTPUT_FORCED_ERR:\n+                        systemOutput = SystemOutput.ForcedSysErr;\n+                        break;\n+                    default:\n+                        Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n+                                + String.join(\n+                                        \", \",\n+                                        PROP_OUTPUT_OUT,\n+                                        PROP_OUTPUT_ERR,\n+                                        PROP_OUTPUT_OUT_ERR,\n+                                        PROP_OUTPUT_ERR_OUT)\n+                                + \".\");\n+                }\n+            }\n+        }\n+        if (systemOutput == null) {\n+            systemOutput = SystemOutput.SysOutOrSysErr;\n+        }\n+        return systemOutput;\n+    }\n+\n+    public String computeType() {\n+        String type = this.type;\n+        if (type == null) {\n+            type = System.getProperty(PROP_TYPE);\n+        }\n+        if (type == null) {\n+            type = System.getenv(\"TERM\");\n+        }\n+        return type;\n+    }\n+\n+    public Charset computeEncoding() {\n+        Charset encoding = this.encoding;\n+        if (encoding == null) {\n+            String charsetName = System.getProperty(PROP_ENCODING);\n+            if (charsetName != null && Charset.isSupported(charsetName)) {\n+                encoding = Charset.forName(charsetName);\n+            }\n+        }\n+        if (encoding == null) {\n+            int codepage = this.codepage;\n+            if (codepage <= 0) {\n+                String str = System.getProperty(PROP_CODEPAGE);\n+                if (str != null) {\n+                    codepage = Integer.parseInt(str);\n+                }\n+            }\n+            if (codepage >= 0) {\n+                encoding = getCodepageCharset(codepage);\n+            } else {\n+                encoding = StandardCharsets.UTF_8;\n+            }\n+        }\n+        return encoding;\n+    }\n+\n+    \/**\n+     * Get the list of available terminal providers.\n+     * This list is sorted according to the {@link #PROP_PROVIDERS} system property.\n+     * @param provider if not {@code null}, only this provider will be checked\n+     * @param exception if a provider throws an exception, it will be added to this exception as a suppressed exception\n+     * @return a list of terminal providers\n+     *\/\n+    public List<TerminalProvider> getProviders(String provider, IllegalStateException exception) {\n+        List<TerminalProvider> providers = new ArrayList<>();\n+        \/\/ Check ffm provider\n+        checkProvider(provider, exception, providers, ffm, PROP_FFM, PROP_PROVIDER_FFM);\n+        \/\/ Check jni provider\n+        checkProvider(provider, exception, providers, jni, PROP_JNI, PROP_PROVIDER_JNI);\n+        \/\/ Check jansi provider\n+        checkProvider(provider, exception, providers, jansi, PROP_JANSI, PROP_PROVIDER_JANSI);\n+        \/\/ Check jna provider\n+        checkProvider(provider, exception, providers, jna, PROP_JNA, PROP_PROVIDER_JNA);\n+        \/\/ Check exec provider\n+        checkProvider(provider, exception, providers, exec, PROP_EXEC, PROP_PROVIDER_EXEC);\n+        \/\/ Order providers\n+        List<String> order = Arrays.asList(\n+                (this.providers != null ? this.providers : System.getProperty(PROP_PROVIDERS, PROP_PROVIDERS_DEFAULT))\n+                        .split(\",\"));\n+        providers.sort(Comparator.comparing(l -> {\n+            int idx = order.indexOf(l.name());\n+            return idx >= 0 ? idx : Integer.MAX_VALUE;\n+        }));\n+        String names = providers.stream().map(TerminalProvider::name).collect(Collectors.joining(\", \"));\n+        Log.debug(\"Available providers: \" + names);\n+        return providers;\n+    }\n+\n+    private void checkProvider(\n+            String provider,\n+            IllegalStateException exception,\n+            List<TerminalProvider> providers,\n+            Boolean load,\n+            String property,\n+            String name) {\n+        Boolean doLoad = provider != null ? (Boolean) name.equals(provider) : load;\n+        if (doLoad == null) {\n+            doLoad = getBoolean(property, true);\n+        }\n+        if (doLoad) {\n+            try {\n+                TerminalProvider prov = TerminalProvider.load(name);\n+                prov.isSystemStream(SystemStream.Output);\n+                providers.add(prov);\n+            } catch (Throwable t) {\n+                Log.debug(\"Unable to load \" + name + \" provider: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+    }\n+\n+    private SystemStream select(Map<SystemStream, Boolean> system, SystemOutput systemOutput) {\n@@ -534,1 +725,1 @@\n-                return select(system, TerminalProvider.Stream.Output);\n+                return select(system, SystemStream.Output);\n@@ -536,1 +727,1 @@\n-                return select(system, TerminalProvider.Stream.Error);\n+                return select(system, SystemStream.Error);\n@@ -538,1 +729,1 @@\n-                return select(system, TerminalProvider.Stream.Output, TerminalProvider.Stream.Error);\n+                return select(system, SystemStream.Output, SystemStream.Error);\n@@ -540,1 +731,5 @@\n-                return select(system, TerminalProvider.Stream.Error, TerminalProvider.Stream.Output);\n+                return select(system, SystemStream.Error, SystemStream.Output);\n+            case ForcedSysOut:\n+                return SystemStream.Output;\n+            case ForcedSysErr:\n+                return SystemStream.Error;\n@@ -545,2 +740,2 @@\n-    private static TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, TerminalProvider.Stream... streams) {\n-        for (TerminalProvider.Stream s : streams) {\n+    private static SystemStream select(Map<SystemStream, Boolean> system, SystemStream... streams) {\n+        for (SystemStream s : streams) {\n@@ -561,1 +756,3 @@\n-            Object command = ((Optional<?>) infoMethod.getReturnType().getMethod(\"command\").invoke(info)).orElse(null);\n+            Object command = ((Optional<?>)\n+                            infoMethod.getReturnType().getMethod(\"command\").invoke(info))\n+                    .orElse(null);\n@@ -586,1 +783,1 @@\n-        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n+        \/\/ http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n@@ -633,1 +830,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":367,"deletions":171,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -21,0 +21,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -31,1 +33,2 @@\n-    public AbstractPosixTerminal(String name, String type, Pty pty, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    public AbstractPosixTerminal(String name, String type, Pty pty, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -85,0 +88,9 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return getPty().getProvider();\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return getPty().getSystemStream();\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPosixTerminal.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -11,4 +11,2 @@\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.NonBlockingInputStream;\n-\n+import java.io.FileDescriptor;\n+import java.io.FilterInputStream;\n@@ -19,0 +17,9 @@\n+import java.lang.reflect.Field;\n+\n+\/\/import jdk.internal.org.jline.nativ.JLineLibrary;\n+\/\/import jdk.internal.org.jline.nativ.JLineNativeLoader;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.NonBlockingInputStream;\n@@ -20,0 +27,4 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION;\n@@ -24,0 +35,2 @@\n+    protected final TerminalProvider provider;\n+    protected final SystemStream systemStream;\n@@ -25,0 +38,6 @@\n+    private boolean skipNextLf;\n+\n+    public AbstractPty(TerminalProvider provider, SystemStream systemStream) {\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n+    }\n@@ -35,0 +54,22 @@\n+        InputStream nsi = new FilterInputStream(si) {\n+            @Override\n+            public int read() throws IOException {\n+                for (; ; ) {\n+                    int c = super.read();\n+                    if (current.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+                        if (c == '\\r') {\n+                            skipNextLf = true;\n+                            c = '\\n';\n+                        } else if (c == '\\n') {\n+                            if (skipNextLf) {\n+                                skipNextLf = false;\n+                                continue;\n+                            }\n+                        } else {\n+                            skipNextLf = false;\n+                        }\n+                    }\n+                    return c;\n+                }\n+            }\n+        };\n@@ -36,1 +77,1 @@\n-            return new PtyInputStream(si);\n+            return new PtyInputStream(nsi);\n@@ -38,1 +79,1 @@\n-            return si;\n+            return nsi;\n@@ -52,0 +93,10 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n+\n@@ -105,0 +156,99 @@\n+    private static FileDescriptorCreator fileDescriptorCreator;\n+\n+    protected static FileDescriptor newDescriptor(int fd) {\n+        if (fileDescriptorCreator == null) {\n+            String str =\n+                    System.getProperty(PROP_FILE_DESCRIPTOR_CREATION_MODE, PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT);\n+            String[] modes = str.split(\",\");\n+            IllegalStateException ise = new IllegalStateException(\"Unable to create FileDescriptor\");\n+            for (String mode : modes) {\n+                try {\n+                    switch (mode) {\n+                        case PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE:\n+                            fileDescriptorCreator = null;\/\/new NativeFileDescriptorCreator();\n+                            break;\n+                        case PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION:\n+                            fileDescriptorCreator = new ReflectionFileDescriptorCreator();\n+                            break;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ ignore\n+                    ise.addSuppressed(t);\n+                }\n+                if (fileDescriptorCreator != null) {\n+                    break;\n+                }\n+            }\n+            if (fileDescriptorCreator == null) {\n+                throw ise;\n+            }\n+        }\n+        return fileDescriptorCreator.newDescriptor(fd);\n+    }\n+\n+    interface FileDescriptorCreator {\n+        FileDescriptor newDescriptor(int fd);\n+    }\n+\n+    \/*\n+     * Class that could be used on OpenJDK 17.  However, it requires the following JVM option\n+     *   --add-exports java.base\/jdk.internal.access=ALL-UNNAMED\n+     * so the benefit does not seem important enough to warrant the problems caused\n+     * by access the jdk.internal.access package at compile time, which itself requires\n+     * custom compiler options and a different maven module, or at least a different compile\n+     * phase with a JDK 17 compiler.\n+     * So, just keep the ReflectionFileDescriptorCreator for now.\n+     *\n+    static class Jdk17FileDescriptorCreator implements FileDescriptorCreator {\n+        private final jdk.internal.access.JavaIOFileDescriptorAccess fdAccess;\n+        Jdk17FileDescriptorCreator() {\n+            fdAccess = jdk.internal.access.SharedSecrets.getJavaIOFileDescriptorAccess();\n+        }\n+\n+        @Override\n+        public FileDescriptor newDescriptor(int fd) {\n+            FileDescriptor descriptor = new FileDescriptor();\n+            fdAccess.set(descriptor, fd);\n+            return descriptor;\n+        }\n+    }\n+     *\/\n+\n+    \/**\n+     * Reflection based file descriptor creator.\n+     * This requires the following option\n+     *   --add-opens java.base\/java.io=ALL-UNNAMED\n+     *\/\n+    static class ReflectionFileDescriptorCreator implements FileDescriptorCreator {\n+        private final Field fileDescriptorField;\n+\n+        ReflectionFileDescriptorCreator() throws Exception {\n+            Field field = FileDescriptor.class.getDeclaredField(\"fd\");\n+            field.setAccessible(true);\n+            fileDescriptorField = field;\n+        }\n+\n+        @Override\n+        public FileDescriptor newDescriptor(int fd) {\n+            FileDescriptor descriptor = new FileDescriptor();\n+            try {\n+                fileDescriptorField.set(descriptor, fd);\n+            } catch (IllegalAccessException e) {\n+                \/\/ This should not happen as the field has been set accessible\n+                throw new IllegalStateException(e);\n+            }\n+            return descriptor;\n+        }\n+    }\n+\n+\/\/    static class NativeFileDescriptorCreator implements FileDescriptorCreator {\n+\/\/        NativeFileDescriptorCreator() {\n+\/\/            \/\/ Force load the library\n+\/\/            JLineNativeLoader.initialize();\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public FileDescriptor newDescriptor(int fd) {\n+\/\/            return JLineLibrary.newFileDescriptor(fd);\n+\/\/        }\n+\/\/    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":157,"deletions":7,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -30,1 +30,1 @@\n-import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalExt;\n@@ -38,1 +38,1 @@\n-public abstract class AbstractTerminal implements Terminal {\n+public abstract class AbstractTerminal implements TerminalExt {\n@@ -47,1 +47,1 @@\n-    protected final ColorPalette palette = new ColorPalette(this);\n+    protected final ColorPalette palette;\n@@ -55,1 +55,3 @@\n-    public AbstractTerminal(String name, String type, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public AbstractTerminal(String name, String type, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -59,0 +61,1 @@\n+        this.palette = new ColorPalette(this);\n@@ -88,1 +91,5 @@\n-        if (handler != SignalHandler.SIG_DFL && handler != SignalHandler.SIG_IGN) {\n+        if (handler == SignalHandler.SIG_DFL) {\n+            if (status != null && signal == Signal.WINCH) {\n+                status.resize();\n+            }\n+        } else if (handler != SignalHandler.SIG_IGN) {\n@@ -91,3 +98,0 @@\n-        if (status != null && signal == Signal.WINCH) {\n-            status.resize();\n-        }\n@@ -108,2 +112,1 @@\n-            status.update(null);\n-            flush();\n+            status.close();\n@@ -129,1 +132,1 @@\n-                writer().write(new char[]{'^', (char) (vcc + '@')}, 0, 2);\n+                writer().write(new char[] {'^', (char) (vcc + '@')}, 0, 2);\n@@ -220,2 +223,1 @@\n-                MouseEvent.Type.Moved, MouseEvent.Button.NoButton,\n-                EnumSet.noneOf(MouseEvent.Modifier.class), 0, 0);\n+            MouseEvent.Type.Moved, MouseEvent.Button.NoButton, EnumSet.noneOf(MouseEvent.Modifier.class), 0, 0);\n@@ -271,2 +273,1 @@\n-    public void pause() {\n-    }\n+    public void pause() {}\n@@ -275,2 +276,1 @@\n-    public void pause(boolean wait) throws InterruptedException {\n-    }\n+    public void pause(boolean wait) throws InterruptedException {}\n@@ -279,2 +279,1 @@\n-    public void resume() {\n-    }\n+    public void resume() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractTerminal.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -32,2 +32,1 @@\n-    public void flush() {\n-    }\n+    public void flush() {}\n@@ -36,3 +35,1 @@\n-    public void close() {\n-    }\n-\n+    public void close() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsConsoleWriter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -11,0 +11,10 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n@@ -13,0 +23,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -24,11 +36,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Function;\n-\n@@ -47,1 +48,1 @@\n-public abstract class AbstractWindowsTerminal extends AbstractTerminal {\n+public abstract class AbstractWindowsTerminal<Console> extends AbstractTerminal {\n@@ -59,5 +60,5 @@\n-    protected static final int ENABLE_LINE_INPUT      = 0x0002;\n-    protected static final int ENABLE_ECHO_INPUT      = 0x0004;\n-    protected static final int ENABLE_WINDOW_INPUT    = 0x0008;\n-    protected static final int ENABLE_MOUSE_INPUT     = 0x0010;\n-    protected static final int ENABLE_INSERT_MODE     = 0x0020;\n+    protected static final int ENABLE_LINE_INPUT = 0x0002;\n+    protected static final int ENABLE_ECHO_INPUT = 0x0004;\n+    protected static final int ENABLE_WINDOW_INPUT = 0x0008;\n+    protected static final int ENABLE_MOUSE_INPUT = 0x0010;\n+    protected static final int ENABLE_INSERT_MODE = 0x0020;\n@@ -65,0 +66,1 @@\n+    protected static final int ENABLE_EXTENDED_FLAGS = 0x0080;\n@@ -74,1 +76,6 @@\n-    protected final int originalConsoleMode;\n+    protected final Console inConsole;\n+    protected final Console outConsole;\n+    protected final int originalInConsoleMode;\n+    protected final int originalOutConsoleMode;\n+    private final TerminalProvider provider;\n+    private final SystemStream systemStream;\n@@ -83,2 +90,18 @@\n-\n-    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    protected boolean skipNextLf;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public AbstractWindowsTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            Writer writer,\n+            String name,\n+            String type,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            Console inConsole,\n+            int inConsoleMode,\n+            Console outConsole,\n+            int outConsoleMode,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -86,0 +109,2 @@\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n@@ -92,0 +117,2 @@\n+        this.inConsole = inConsole;\n+        this.outConsole = outConsole;\n@@ -94,1 +121,2 @@\n-        originalConsoleMode = getConsoleMode();\n+        this.originalInConsoleMode = inConsoleMode;\n+        this.originalOutConsoleMode = outConsoleMode;\n@@ -97,1 +125,1 @@\n-        attributes.setControlChar(Attributes.ControlChar.VEOF,  ctrl('D'));\n+        attributes.setControlChar(Attributes.ControlChar.VEOF, ctrl('D'));\n@@ -151,1 +179,1 @@\n-        int mode = getConsoleMode();\n+        int mode = getConsoleMode(inConsole);\n@@ -176,0 +204,3 @@\n+            \/\/ mouse events not send with quick edit mode\n+            \/\/ to disable ENABLE_QUICK_EDIT_MODE just set extended flag\n+            mode |= ENABLE_EXTENDED_FLAGS;\n@@ -177,1 +208,1 @@\n-        setConsoleMode(mode);\n+        setConsoleMode(inConsole, mode);\n@@ -200,1 +231,2 @@\n-        setConsoleMode(originalConsoleMode);\n+        setConsoleMode(inConsole, originalInConsoleMode);\n+        setConsoleMode(outConsole, originalOutConsoleMode);\n@@ -204,13 +236,15 @@\n-    static final int ALT_FLAG =   0x02;\n-    static final int CTRL_FLAG =  0x04;\n-\n-    static final int RIGHT_ALT_PRESSED =   0x0001;\n-    static final int LEFT_ALT_PRESSED =    0x0002;\n-    static final int RIGHT_CTRL_PRESSED =  0x0004;\n-    static final int LEFT_CTRL_PRESSED =   0x0008;\n-    static final int SHIFT_PRESSED =       0x0010;\n-    static final int NUMLOCK_ON =          0x0020;\n-    static final int SCROLLLOCK_ON =       0x0040;\n-    static final int CAPSLOCK_ON =         0x0080;\n-\n-    protected void processKeyEvent(final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState) throws IOException {\n+    static final int ALT_FLAG = 0x02;\n+    static final int CTRL_FLAG = 0x04;\n+\n+    static final int RIGHT_ALT_PRESSED = 0x0001;\n+    static final int LEFT_ALT_PRESSED = 0x0002;\n+    static final int RIGHT_CTRL_PRESSED = 0x0004;\n+    static final int LEFT_CTRL_PRESSED = 0x0008;\n+    static final int SHIFT_PRESSED = 0x0010;\n+    static final int NUMLOCK_ON = 0x0020;\n+    static final int SCROLLLOCK_ON = 0x0040;\n+    static final int CAPSLOCK_ON = 0x0080;\n+\n+    protected void processKeyEvent(\n+            final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState)\n+            throws IOException {\n@@ -225,2 +259,3 @@\n-                    && (controlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | SHIFT_PRESSED))\n-                        == (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {\n+                    && (controlKeyState\n+                                    & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))\n+                            == (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {\n@@ -229,1 +264,2 @@\n-                final String keySeq = getEscapeSequence(virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));\n+                final String keySeq = getEscapeSequence(\n+                        virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));\n@@ -243,1 +279,1 @@\n-                *\/\n+                 *\/\n@@ -257,1 +293,1 @@\n-                } else if (isCtrl) { \/\/Handles the ctrl key events(uchar=0)\n+                } else if (isCtrl) { \/\/ Handles the ctrl key events(uchar=0)\n@@ -260,1 +296,1 @@\n-                    } else if (virtualKeyCode == 191) { \/\/?\n+                    } else if (virtualKeyCode == 191) { \/\/ ?\n@@ -278,1 +314,1 @@\n-                processInputChar(ch);  \/\/ no such combination in Windows\n+                processInputChar(ch); \/\/ no such combination in Windows\n@@ -471,1 +507,13 @@\n-        if (c == '\\r') {\n+        if (attributes.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+            if (c == '\\r') {\n+                skipNextLf = true;\n+                c = '\\n';\n+            } else if (c == '\\n') {\n+                if (skipNextLf) {\n+                    skipNextLf = false;\n+                    return;\n+                }\n+            } else {\n+                skipNextLf = false;\n+            }\n+        } else if (c == '\\r') {\n@@ -481,4 +529,4 @@\n-\/\/        if (attributes.getLocalFlag(Attributes.LocalFlag.ECHO)) {\n-\/\/            processOutputByte(c);\n-\/\/            masterOutput.flush();\n-\/\/        }\n+        \/\/        if (attributes.getLocalFlag(Attributes.LocalFlag.ECHO)) {\n+        \/\/            processOutputByte(c);\n+        \/\/            masterOutput.flush();\n+        \/\/        }\n@@ -495,1 +543,1 @@\n-    protected abstract int getConsoleMode();\n+    protected abstract int getConsoleMode(Console console);\n@@ -497,1 +545,1 @@\n-    protected abstract void setConsoleMode(int mode);\n+    protected abstract void setConsoleMode(Console console, int mode);\n@@ -507,1 +555,4 @@\n-}\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n@@ -509,0 +560,5 @@\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":110,"deletions":54,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,5 +11,0 @@\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.utils.Curses;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-\n@@ -22,0 +17,5 @@\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.Curses;\n+import jdk.internal.org.jline.utils.InfoCmp;\n+\n@@ -108,1 +108,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/CursorSupport.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -20,0 +20,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -29,1 +30,1 @@\n-    static void diag(PrintStream out) {\n+    public static void diag(PrintStream out) {\n@@ -53,0 +54,11 @@\n+        \/\/ FFM\n+        out.println(\"FFM Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"ffm\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"FFM support not available: \" + t);\n+        }\n+        out.println();\n+\n@@ -63,1 +75,1 @@\n-        out.println(\"JansiSupport\");\n+        out.println(\"Jansi2Support\");\n@@ -69,1 +81,11 @@\n-            out.println(\"Jansi support not available: \" + t);\n+            out.println(\"Jansi 2 support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JniSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jni\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNI support not available: \" + t);\n@@ -86,3 +108,3 @@\n-            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n-            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n-            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(SystemStream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(SystemStream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(SystemStream.Error));\n@@ -93,3 +115,3 @@\n-            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n-            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n-            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(SystemStream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(SystemStream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(SystemStream.Error));\n@@ -99,2 +121,10 @@\n-        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n-                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+        try (Terminal terminal = provider.sysTerminal(\n+                \"diag\",\n+                \"xterm\",\n+                false,\n+                StandardCharsets.UTF_8,\n+                false,\n+                Terminal.SignalHandler.SIG_DFL,\n+                false,\n+                SystemStream.Output,\n+                input -> input)) {\n@@ -105,1 +135,2 @@\n-                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    ForkJoinTask<Integer> t =\n+                            new ForkJoinPool(1).submit(() -> terminal.reader().read(1));\n@@ -111,1 +142,5 @@\n-                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                        sb.append(\" with pty \")\n+                                .append(((AbstractPosixTerminal) terminal)\n+                                        .getPty()\n+                                        .getClass()\n+                                        .getName());\n@@ -132,1 +167,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":49,"deletions":15,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -17,0 +17,1 @@\n+import java.util.function.Function;\n@@ -21,0 +22,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -27,0 +30,2 @@\n+    private final TerminalProvider provider;\n+    private final SystemStream systemStream;\n@@ -33,0 +38,1 @@\n+    private boolean skipNextLf;\n@@ -34,2 +40,2 @@\n-    public DumbTerminal(InputStream in, OutputStream out) throws IOException {\n-        this(TYPE_DUMB, TYPE_DUMB, in, out, null);\n+    public DumbTerminal(InputStream in, OutputStream out, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        this(TYPE_DUMB, TYPE_DUMB, in, out, null, inputStreamWrapper);\n@@ -38,2 +44,3 @@\n-    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding) throws IOException {\n-        this(name, type, in, out, encoding, SignalHandler.SIG_DFL);\n+    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding, Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        this(null, null, name, type, in, out, encoding, SignalHandler.SIG_DFL, inputStreamWrapper);\n@@ -42,1 +49,12 @@\n-    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public DumbTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -44,1 +62,3 @@\n-        NonBlockingInputStream nbis = NonBlocking.nonBlocking(getName(), in);\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n+        NonBlockingInputStream nbis = NonBlocking.nonBlocking(getName(), inputStreamWrapper.apply(in));\n@@ -48,1 +68,1 @@\n-                for (;;) {\n+                for (; ; ) {\n@@ -65,1 +85,13 @@\n-                    if (c == '\\r') {\n+                    if (attributes.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+                        if (c == '\\r') {\n+                            skipNextLf = true;\n+                            c = '\\n';\n+                        } else if (c == '\\n') {\n+                            if (skipNextLf) {\n+                                skipNextLf = false;\n+                                continue;\n+                            }\n+                        } else {\n+                            skipNextLf = false;\n+                        }\n+                    } else if (c == '\\r') {\n@@ -83,1 +115,1 @@\n-        this.attributes.setControlChar(ControlChar.VERASE,  (char) 127);\n+        this.attributes.setControlChar(ControlChar.VERASE, (char) 127);\n@@ -85,2 +117,2 @@\n-        this.attributes.setControlChar(ControlChar.VKILL,   (char) 21);\n-        this.attributes.setControlChar(ControlChar.VLNEXT,  (char) 22);\n+        this.attributes.setControlChar(ControlChar.VKILL, (char) 21);\n+        this.attributes.setControlChar(ControlChar.VLNEXT, (char) 22);\n@@ -110,3 +142,1 @@\n-        Attributes attr = new Attributes();\n-        attr.copy(attributes);\n-        return attr;\n+        return new Attributes(attributes);\n@@ -129,0 +159,9 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/DumbTerminal.java","additions":54,"deletions":15,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+public class DumbTerminalProvider implements TerminalProvider {\n+\n+    @Override\n+    public String name() {\n+        return TerminalBuilder.PROP_PROVIDER_DUMB;\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        return new DumbTerminal(\n+                this,\n+                systemStream,\n+                name,\n+                type,\n+                new FileInputStream(FileDescriptor.in),\n+                new FileOutputStream(systemStream == SystemStream.Error ? FileDescriptor.err : FileDescriptor.out),\n+                encoding,\n+                signalHandler,\n+                inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(SystemStream stream) {\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(SystemStream stream) {\n+        return null;\n+    }\n+\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/DumbTerminalProvider.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -1,296 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2016, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl;\n-\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.FileDescriptor;\n-import java.io.OutputStream;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import static jdk.internal.org.jline.utils.ExecHelper.exec;\n-\n-public class ExecPty extends AbstractPty implements Pty {\n-\n-    private final String name;\n-    private final TerminalProvider.Stream console;\n-\n-    public static Pty current(TerminalProvider.Stream console) throws IOException {\n-        try {\n-            String result = exec(true, OSUtils.TTY_COMMAND);\n-            if (console != TerminalProvider.Stream.Output && console != TerminalProvider.Stream.Error) {\n-                throw new IllegalArgumentException(\"console should be Output or Error: \" + console);\n-            }\n-            return new ExecPty(result.trim(), console);\n-        } catch (IOException e) {\n-            throw new IOException(\"Not a tty\", e);\n-        }\n-    }\n-\n-    protected ExecPty(String name, TerminalProvider.Stream console) {\n-        this.name = name;\n-        this.console = console;\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @Override\n-    public InputStream getMasterInput() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public OutputStream getMasterOutput() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected InputStream doGetSlaveInput() throws IOException {\n-        return console != null\n-                ? new FileInputStream(FileDescriptor.in)\n-                : new FileInputStream(getName());\n-    }\n-\n-    @Override\n-    public OutputStream getSlaveOutput() throws IOException {\n-        return console == TerminalProvider.Stream.Output\n-                ? new FileOutputStream(FileDescriptor.out)\n-                : console == TerminalProvider.Stream.Error\n-                    ? new FileOutputStream(FileDescriptor.err)\n-                    : new FileOutputStream(getName());\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        String cfg = doGetConfig();\n-        return doGetAttr(cfg);\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        List<String> commands = getFlagsToSet(attr, getAttr());\n-        if (!commands.isEmpty()) {\n-            commands.add(0, OSUtils.STTY_COMMAND);\n-            if (console == null) {\n-                commands.add(1, OSUtils.STTY_F_OPTION);\n-                commands.add(2, getName());\n-            }\n-            exec(console != null, commands.toArray(new String[0]));\n-        }\n-    }\n-\n-    protected List<String> getFlagsToSet(Attributes attr, Attributes current) {\n-        List<String> commands = new ArrayList<>();\n-        for (InputFlag flag : InputFlag.values()) {\n-            if (attr.getInputFlag(flag) != current.getInputFlag(flag)) {\n-                commands.add((attr.getInputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (OutputFlag flag : OutputFlag.values()) {\n-            if (attr.getOutputFlag(flag) != current.getOutputFlag(flag)) {\n-                commands.add((attr.getOutputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (ControlFlag flag : ControlFlag.values()) {\n-            if (attr.getControlFlag(flag) != current.getControlFlag(flag)) {\n-                commands.add((attr.getControlFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (LocalFlag flag : LocalFlag.values()) {\n-            if (attr.getLocalFlag(flag) != current.getLocalFlag(flag)) {\n-                commands.add((attr.getLocalFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        String undef = System.getProperty(\"os.name\").toLowerCase().startsWith(\"hp\") ? \"^-\" : \"undef\";\n-        for (ControlChar cchar : ControlChar.values()) {\n-            int v = attr.getControlChar(cchar);\n-            if (v >= 0 && v != current.getControlChar(cchar)) {\n-                String str = \"\";\n-                commands.add(cchar.name().toLowerCase().substring(1));\n-                if (cchar == ControlChar.VMIN || cchar == ControlChar.VTIME) {\n-                    commands.add(Integer.toString(v));\n-                }\n-                else if (v == 0) {\n-                    commands.add(undef);\n-                }\n-                else {\n-                    if (v >= 128) {\n-                        v -= 128;\n-                        str += \"M-\";\n-                    }\n-                    if (v < 32 || v == 127) {\n-                        v ^= 0x40;\n-                        str += \"^\";\n-                    }\n-                    str += (char) v;\n-                    commands.add(str);\n-                }\n-            }\n-        }\n-        return commands;\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        String cfg = doGetConfig();\n-        return doGetSize(cfg);\n-    }\n-\n-    protected String doGetConfig() throws IOException {\n-        return console != null\n-                ? exec(true,  OSUtils.STTY_COMMAND, \"-a\")\n-                : exec(false, OSUtils.STTY_COMMAND, OSUtils.STTY_F_OPTION, getName(), \"-a\");\n-    }\n-\n-    static Attributes doGetAttr(String cfg) throws IOException {\n-        Attributes attributes = new Attributes();\n-        for (InputFlag flag : InputFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setInputFlag(flag, value);\n-            }\n-        }\n-        for (OutputFlag flag : OutputFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setOutputFlag(flag, value);\n-            }\n-        }\n-        for (ControlFlag flag : ControlFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setControlFlag(flag, value);\n-            }\n-        }\n-        for (LocalFlag flag : LocalFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setLocalFlag(flag, value);\n-            }\n-        }\n-        for (ControlChar cchar : ControlChar.values()) {\n-            String name = cchar.name().toLowerCase().substring(1);\n-            if (\"reprint\".endsWith(name)) {\n-                name = \"(?:reprint|rprnt)\";\n-            }\n-            Matcher matcher = Pattern.compile(\"[\\\\s;]\" + name + \"\\\\s*=\\\\s*(.+?)[\\\\s;]\").matcher(cfg);\n-            if (matcher.find()) {\n-                attributes.setControlChar(cchar, parseControlChar(matcher.group(1).toUpperCase()));\n-            }\n-        }\n-        return attributes;\n-    }\n-\n-    private static Boolean doGetFlag(String cfg, Enum<?> flag) {\n-        Matcher matcher = Pattern.compile(\"(?:^|[\\\\s;])(\\\\-?\" + flag.name().toLowerCase() + \")(?:[\\\\s;]|$)\").matcher(cfg);\n-        return matcher.find() ? !matcher.group(1).startsWith(\"-\") : null;\n-    }\n-\n-    static int parseControlChar(String str) {\n-        \/\/ undef\n-        if (\"<UNDEF>\".equals(str)) {\n-            return -1;\n-        }\n-        \/\/ del\n-        if (\"DEL\".equalsIgnoreCase(str)) {\n-            return 127;\n-        }\n-        \/\/ octal\n-        if (str.charAt(0) == '0') {\n-            return Integer.parseInt(str, 8);\n-        }\n-        \/\/ decimal\n-        if (str.charAt(0) >= '1' && str.charAt(0) <= '9') {\n-            return Integer.parseInt(str, 10);\n-        }\n-        \/\/ control char\n-        if (str.charAt(0) == '^') {\n-            if (str.charAt(1) == '?') {\n-                return 127;\n-            } else {\n-                return str.charAt(1) - 64;\n-            }\n-        } else if (str.charAt(0) == 'M' && str.charAt(1) == '-') {\n-            if (str.charAt(2) == '^') {\n-                if (str.charAt(3) == '?') {\n-                    return 127 + 128;\n-                } else {\n-                    return str.charAt(3) - 64 + 128;\n-                }\n-            } else {\n-                return str.charAt(2) + 128;\n-            }\n-        } else {\n-            return str.charAt(0);\n-        }\n-    }\n-\n-    static Size doGetSize(String cfg) throws IOException {\n-        return new Size(doGetInt(\"columns\", cfg), doGetInt(\"rows\", cfg));\n-    }\n-\n-    static int doGetInt(String name, String cfg) throws IOException {\n-        String[] patterns = new String[] {\n-                \"\\\\b([0-9]+)\\\\s+\" + name + \"\\\\b\",\n-                \"\\\\b\" + name + \"\\\\s+([0-9]+)\\\\b\",\n-                \"\\\\b\" + name + \"\\\\s*=\\\\s*([0-9]+)\\\\b\"\n-        };\n-        for (String pattern : patterns) {\n-            Matcher matcher = Pattern.compile(pattern).matcher(cfg);\n-            if (matcher.find()) {\n-                return Integer.parseInt(matcher.group(1));\n-            }\n-        }\n-        throw new IOException(\"Unable to parse \" + name);\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        if (console != null) {\n-            exec(true,\n-                 OSUtils.STTY_COMMAND,\n-                 \"columns\", Integer.toString(size.getColumns()),\n-                 \"rows\", Integer.toString(size.getRows()));\n-        } else {\n-            exec(false,\n-                 OSUtils.STTY_COMMAND,\n-                 OSUtils.STTY_F_OPTION, getName(),\n-                 \"columns\", Integer.toString(size.getColumns()),\n-                 \"rows\", Integer.toString(size.getRows()));\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"ExecPty[\" + getName() + (console != null ? \", system]\" : \"]\");\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExecPty.java","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -11,4 +11,0 @@\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Size;\n-\n@@ -22,0 +18,5 @@\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n@@ -35,0 +36,1 @@\n+    private final TerminalProvider provider;\n@@ -41,5 +43,4 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, SignalHandler.SIG_DFL);\n+    public ExternalTerminal(\n+            String name, String type, InputStream masterInput, OutputStream masterOutput, Charset encoding)\n+            throws IOException {\n+        this(null, name, type, masterInput, masterOutput, encoding, SignalHandler.SIG_DFL);\n@@ -48,6 +49,10 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, signalHandler, false);\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler)\n+            throws IOException {\n+        this(provider, name, type, masterInput, masterOutput, encoding, signalHandler, false);\n@@ -56,7 +61,11 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler,\n-                            boolean paused) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, signalHandler, paused, null, null);\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused)\n+            throws IOException {\n+        this(provider, name, type, masterInput, masterOutput, encoding, signalHandler, paused, null, null);\n@@ -65,8 +74,13 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler,\n-                            boolean paused,\n-                            Attributes attributes,\n-                            Size size) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n@@ -74,0 +88,1 @@\n+        this.provider = provider;\n@@ -174,0 +189,4 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExternalTerminal.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -17,0 +17,1 @@\n+import java.util.EnumSet;\n@@ -26,0 +27,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -48,15 +51,0 @@\n-    private static final String DEFAULT_TERMINAL_ATTRIBUTES =\n-                    \"speed 9600 baud; 24 rows; 80 columns;\\n\" +\n-                    \"lflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl\\n\" +\n-                    \"\\t-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo\\n\" +\n-                    \"\\t-extproc\\n\" +\n-                    \"iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel iutf8\\n\" +\n-                    \"\\t-ignbrk brkint -inpck -ignpar -parmrk\\n\" +\n-                    \"oflags: opost onlcr -oxtabs -onocr -onlret\\n\" +\n-                    \"cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow\\n\" +\n-                    \"\\t-dtrflow -mdmbuf\\n\" +\n-                    \"cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = <undef>;\\n\" +\n-                    \"\\teol2 = <undef>; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;\\n\" +\n-                    \"\\tmin = 1; quit = ^\\\\; reprint = ^R; start = ^Q; status = ^T;\\n\" +\n-                    \"\\tstop = ^S; susp = ^Z; time = 0; werase = ^W;\\n\";\n-\n@@ -87,0 +75,1 @@\n+\n@@ -89,4 +78,4 @@\n-    public LineDisciplineTerminal(String name,\n-                                  String type,\n-                                  OutputStream masterOutput,\n-                                  Charset encoding) throws IOException {\n+    protected boolean skipNextLf;\n+\n+    public LineDisciplineTerminal(String name, String type, OutputStream masterOutput, Charset encoding)\n+            throws IOException {\n@@ -96,5 +85,4 @@\n-    public LineDisciplineTerminal(String name,\n-                                  String type,\n-                                  OutputStream masterOutput,\n-                                  Charset encoding,\n-                                  SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public LineDisciplineTerminal(\n+            String name, String type, OutputStream masterOutput, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -109,1 +97,1 @@\n-        this.attributes = ExecPty.doGetAttr(DEFAULT_TERMINAL_ATTRIBUTES);\n+        this.attributes = getDefaultTerminalAttributes();\n@@ -114,0 +102,55 @@\n+    private static Attributes getDefaultTerminalAttributes() {\n+        \/\/ speed 9600 baud; 24 rows; 80 columns;\n+        \/\/ lflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl\n+        \/\/     -echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo\n+        \/\/     -extproc\n+        \/\/ iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel iutf8\n+        \/\/     -ignbrk brkint -inpck -ignpar -parmrk\n+        \/\/ oflags: opost onlcr -oxtabs -onocr -onlret\n+        \/\/ cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow\n+        \/\/     -dtrflow -mdmbuf\n+        \/\/ cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = <undef>;\n+        \/\/     eol2 = <undef>; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;\n+        \/\/     min = 1; quit = ^\\\\; reprint = ^R; start = ^Q; status = ^T;\n+        \/\/     stop = ^S; susp = ^Z; time = 0; werase = ^W;\n+        Attributes attr = new Attributes();\n+        attr.setLocalFlags(EnumSet.of(\n+                LocalFlag.ICANON,\n+                LocalFlag.ISIG,\n+                LocalFlag.IEXTEN,\n+                LocalFlag.ECHO,\n+                LocalFlag.ECHOE,\n+                LocalFlag.ECHOKE,\n+                LocalFlag.ECHOCTL,\n+                LocalFlag.PENDIN));\n+        attr.setInputFlags(EnumSet.of(\n+                InputFlag.ICRNL,\n+                InputFlag.IXON,\n+                InputFlag.IXANY,\n+                InputFlag.IMAXBEL,\n+                InputFlag.IUTF8,\n+                InputFlag.BRKINT));\n+        attr.setOutputFlags(EnumSet.of(OutputFlag.OPOST, OutputFlag.ONLCR));\n+        attr.setControlChar(ControlChar.VDISCARD, ctrl('O'));\n+        attr.setControlChar(ControlChar.VDSUSP, ctrl('Y'));\n+        attr.setControlChar(ControlChar.VEOF, ctrl('D'));\n+        attr.setControlChar(ControlChar.VERASE, ctrl('?'));\n+        attr.setControlChar(ControlChar.VINTR, ctrl('C'));\n+        attr.setControlChar(ControlChar.VKILL, ctrl('U'));\n+        attr.setControlChar(ControlChar.VLNEXT, ctrl('V'));\n+        attr.setControlChar(ControlChar.VMIN, 1);\n+        attr.setControlChar(ControlChar.VQUIT, ctrl('\\\\'));\n+        attr.setControlChar(ControlChar.VREPRINT, ctrl('R'));\n+        attr.setControlChar(ControlChar.VSTART, ctrl('Q'));\n+        attr.setControlChar(ControlChar.VSTATUS, ctrl('T'));\n+        attr.setControlChar(ControlChar.VSTOP, ctrl('S'));\n+        attr.setControlChar(ControlChar.VSUSP, ctrl('Z'));\n+        attr.setControlChar(ControlChar.VTIME, 0);\n+        attr.setControlChar(ControlChar.VWERASE, ctrl('W'));\n+        return attr;\n+    }\n+\n+    private static int ctrl(char c) {\n+        return c == '?' ? 177 : c - 64;\n+    }\n+\n@@ -133,3 +176,1 @@\n-        Attributes attr = new Attributes();\n-        attr.copy(attributes);\n-        return attr;\n+        return new Attributes(attributes);\n@@ -152,1 +193,1 @@\n-   @Override\n+    @Override\n@@ -154,1 +195,1 @@\n-       Objects.requireNonNull(signal);\n+        Objects.requireNonNull(signal);\n@@ -217,1 +258,13 @@\n-        if (c == '\\r') {\n+        if (attributes.getInputFlag(InputFlag.INORMEOL)) {\n+            if (c == '\\r') {\n+                skipNextLf = true;\n+                c = '\\n';\n+            } else if (c == '\\n') {\n+                if (skipNextLf) {\n+                    skipNextLf = false;\n+                    return false;\n+                }\n+            } else {\n+                skipNextLf = false;\n+            }\n+        } else if (c == '\\r') {\n@@ -276,0 +329,10 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return null;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return null;\n+    }\n+\n@@ -287,2 +350,1 @@\n-            } else if ((off < 0) || (off > b.length) || (len < 0) ||\n-                    ((off + len) > b.length) || ((off + len) < 0)) {\n+            } else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {\n@@ -293,1 +355,1 @@\n-            for (int i = 0 ; i < len ; i++) {\n+            for (int i = 0; i < len; i++) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/LineDisciplineTerminal.java","additions":97,"deletions":35,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,5 +11,0 @@\n-import jdk.internal.org.jline.terminal.MouseEvent;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-import jdk.internal.org.jline.utils.InputStreamReader;\n-\n@@ -23,0 +18,5 @@\n+import jdk.internal.org.jline.terminal.MouseEvent;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.InfoCmp;\n+import jdk.internal.org.jline.utils.InputStreamReader;\n+\n@@ -81,1 +81,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -90,1 +91,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -99,1 +101,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -137,1 +140,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/MouseSupport.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -20,2 +20,1 @@\n-    private NativeSignalHandler() {\n-    }\n+    private NativeSignalHandler() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/NativeSignalHandler.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -41,1 +41,2 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding) throws IOException {\n+    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding)\n+            throws IOException {\n@@ -45,1 +46,9 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    public PosixPtyTerminal(\n+            String name,\n+            String type,\n+            Pty pty,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler)\n+            throws IOException {\n@@ -49,1 +58,11 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler, boolean paused) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public PosixPtyTerminal(\n+            String name,\n+            String type,\n+            Pty pty,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused)\n+            throws IOException {\n@@ -116,1 +135,1 @@\n-        if (p2 !=null) {\n+        if (p2 != null) {\n@@ -170,1 +189,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -196,1 +215,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -224,1 +243,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -21,1 +21,0 @@\n-import jdk.internal.org.jline.utils.NonBlocking;\n@@ -23,0 +22,2 @@\n+import jdk.internal.org.jline.utils.FastBufferedOutputStream;\n+import jdk.internal.org.jline.utils.NonBlocking;\n@@ -38,3 +39,5 @@\n-    public PosixSysTerminal(String name, String type, Pty pty, Charset encoding,\n-                            boolean nativeSignals, SignalHandler signalHandler,\n-                            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public PosixSysTerminal(\n+            String name, String type, Pty pty, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -43,1 +46,1 @@\n-        this.output = pty.getSlaveOutput();\n+        this.output = new FastBufferedOutputStream(pty.getSlaveOutput());\n@@ -101,1 +104,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2002-2016, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n+import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n+import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n+import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n+import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractPty;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import static jdk.internal.org.jline.utils.ExecHelper.exec;\n+\n+public class ExecPty extends AbstractPty implements Pty {\n+\n+    private final String name;\n+\n+    public static Pty current(TerminalProvider provider, SystemStream systemStream) throws IOException {\n+        try {\n+            String result = exec(true, OSUtils.TTY_COMMAND);\n+            if (systemStream != SystemStream.Output && systemStream != SystemStream.Error) {\n+                throw new IllegalArgumentException(\"systemStream should be Output or Error: \" + systemStream);\n+            }\n+            return new ExecPty(provider, systemStream, result.trim());\n+        } catch (IOException e) {\n+            throw new IOException(\"Not a tty\", e);\n+        }\n+    }\n+\n+    protected ExecPty(TerminalProvider provider, SystemStream systemStream, String name) {\n+        super(provider, systemStream);\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {}\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public InputStream getMasterInput() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public OutputStream getMasterOutput() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected InputStream doGetSlaveInput() throws IOException {\n+        return systemStream != null ? new FileInputStream(FileDescriptor.in) : new FileInputStream(getName());\n+    }\n+\n+    @Override\n+    public OutputStream getSlaveOutput() throws IOException {\n+        return systemStream == SystemStream.Output\n+                ? new FileOutputStream(FileDescriptor.out)\n+                : systemStream == SystemStream.Error\n+                        ? new FileOutputStream(FileDescriptor.err)\n+                        : new FileOutputStream(getName());\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        String cfg = doGetConfig();\n+        return doGetAttr(cfg);\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        List<String> commands = getFlagsToSet(attr, getAttr());\n+        if (!commands.isEmpty()) {\n+            commands.add(0, OSUtils.STTY_COMMAND);\n+            if (systemStream == null) {\n+                commands.add(1, OSUtils.STTY_F_OPTION);\n+                commands.add(2, getName());\n+            }\n+            try {\n+                exec(systemStream != null, commands.toArray(new String[0]));\n+            } catch (IOException e) {\n+                \/\/ Handle partial failures with GNU stty, see #97\n+                if (e.toString().contains(\"unable to perform all requested operations\")) {\n+                    commands = getFlagsToSet(attr, getAttr());\n+                    if (!commands.isEmpty()) {\n+                        throw new IOException(\"Could not set the following flags: \" + String.join(\", \", commands), e);\n+                    }\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+    }\n+\n+    protected List<String> getFlagsToSet(Attributes attr, Attributes current) {\n+        List<String> commands = new ArrayList<>();\n+        for (InputFlag flag : InputFlag.values()) {\n+            if (attr.getInputFlag(flag) != current.getInputFlag(flag) && flag != InputFlag.INORMEOL) {\n+                commands.add((attr.getInputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (OutputFlag flag : OutputFlag.values()) {\n+            if (attr.getOutputFlag(flag) != current.getOutputFlag(flag)) {\n+                commands.add((attr.getOutputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (ControlFlag flag : ControlFlag.values()) {\n+            if (attr.getControlFlag(flag) != current.getControlFlag(flag)) {\n+                commands.add((attr.getControlFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (LocalFlag flag : LocalFlag.values()) {\n+            if (attr.getLocalFlag(flag) != current.getLocalFlag(flag)) {\n+                commands.add((attr.getLocalFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        String undef = System.getProperty(\"os.name\").toLowerCase().startsWith(\"hp\") ? \"^-\" : \"undef\";\n+        for (ControlChar cchar : ControlChar.values()) {\n+            int v = attr.getControlChar(cchar);\n+            if (v >= 0 && v != current.getControlChar(cchar)) {\n+                String str = \"\";\n+                commands.add(cchar.name().toLowerCase().substring(1));\n+                if (cchar == ControlChar.VMIN || cchar == ControlChar.VTIME) {\n+                    commands.add(Integer.toString(v));\n+                } else if (v == 0) {\n+                    commands.add(undef);\n+                } else {\n+                    if (v >= 128) {\n+                        v -= 128;\n+                        str += \"M-\";\n+                    }\n+                    if (v < 32 || v == 127) {\n+                        v ^= 0x40;\n+                        str += \"^\";\n+                    }\n+                    str += (char) v;\n+                    commands.add(str);\n+                }\n+            }\n+        }\n+        return commands;\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        String cfg = doGetConfig();\n+        return doGetSize(cfg);\n+    }\n+\n+    protected String doGetConfig() throws IOException {\n+        return systemStream != null\n+                ? exec(true, OSUtils.STTY_COMMAND, \"-a\")\n+                : exec(false, OSUtils.STTY_COMMAND, OSUtils.STTY_F_OPTION, getName(), \"-a\");\n+    }\n+\n+    public static Attributes doGetAttr(String cfg) throws IOException {\n+        Attributes attributes = new Attributes();\n+        for (InputFlag flag : InputFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setInputFlag(flag, value);\n+            }\n+        }\n+        for (OutputFlag flag : OutputFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setOutputFlag(flag, value);\n+            }\n+        }\n+        for (ControlFlag flag : ControlFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setControlFlag(flag, value);\n+            }\n+        }\n+        for (LocalFlag flag : LocalFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setLocalFlag(flag, value);\n+            }\n+        }\n+        for (ControlChar cchar : ControlChar.values()) {\n+            String name = cchar.name().toLowerCase().substring(1);\n+            if (\"reprint\".endsWith(name)) {\n+                name = \"(?:reprint|rprnt)\";\n+            }\n+            Matcher matcher =\n+                    Pattern.compile(\"[\\\\s;]\" + name + \"\\\\s*=\\\\s*(.+?)[\\\\s;]\").matcher(cfg);\n+            if (matcher.find()) {\n+                attributes.setControlChar(\n+                        cchar, parseControlChar(matcher.group(1).toUpperCase()));\n+            }\n+        }\n+        return attributes;\n+    }\n+\n+    private static Boolean doGetFlag(String cfg, Enum<?> flag) {\n+        Matcher matcher = Pattern.compile(\"(?:^|[\\\\s;])(\\\\-?\" + flag.name().toLowerCase() + \")(?:[\\\\s;]|$)\")\n+                .matcher(cfg);\n+        return matcher.find() ? !matcher.group(1).startsWith(\"-\") : null;\n+    }\n+\n+    static int parseControlChar(String str) {\n+        \/\/ undef\n+        if (\"<UNDEF>\".equals(str)) {\n+            return -1;\n+        }\n+        \/\/ del\n+        if (\"DEL\".equalsIgnoreCase(str)) {\n+            return 127;\n+        }\n+        \/\/ octal\n+        if (str.charAt(0) == '0') {\n+            return Integer.parseInt(str, 8);\n+        }\n+        \/\/ decimal\n+        if (str.charAt(0) >= '1' && str.charAt(0) <= '9') {\n+            return Integer.parseInt(str, 10);\n+        }\n+        \/\/ control char\n+        if (str.charAt(0) == '^') {\n+            if (str.charAt(1) == '?') {\n+                return 127;\n+            } else {\n+                return str.charAt(1) - 64;\n+            }\n+        } else if (str.charAt(0) == 'M' && str.charAt(1) == '-') {\n+            if (str.charAt(2) == '^') {\n+                if (str.charAt(3) == '?') {\n+                    return 127 + 128;\n+                } else {\n+                    return str.charAt(3) - 64 + 128;\n+                }\n+            } else {\n+                return str.charAt(2) + 128;\n+            }\n+        } else {\n+            return str.charAt(0);\n+        }\n+    }\n+\n+    static Size doGetSize(String cfg) throws IOException {\n+        return new Size(doGetInt(\"columns\", cfg), doGetInt(\"rows\", cfg));\n+    }\n+\n+    static int doGetInt(String name, String cfg) throws IOException {\n+        String[] patterns = new String[] {\n+            \"\\\\b([0-9]+)\\\\s+\" + name + \"\\\\b\", \"\\\\b\" + name + \"\\\\s+([0-9]+)\\\\b\", \"\\\\b\" + name + \"\\\\s*=\\\\s*([0-9]+)\\\\b\"\n+        };\n+        for (String pattern : patterns) {\n+            Matcher matcher = Pattern.compile(pattern).matcher(cfg);\n+            if (matcher.find()) {\n+                return Integer.parseInt(matcher.group(1));\n+            }\n+        }\n+        throw new IOException(\"Unable to parse \" + name);\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        if (systemStream != null) {\n+            exec(\n+                    true,\n+                    OSUtils.STTY_COMMAND,\n+                    \"columns\",\n+                    Integer.toString(size.getColumns()),\n+                    \"rows\",\n+                    Integer.toString(size.getRows()));\n+        } else {\n+            exec(\n+                    false,\n+                    OSUtils.STTY_COMMAND,\n+                    OSUtils.STTY_F_OPTION,\n+                    getName(),\n+                    \"columns\",\n+                    Integer.toString(size.getColumns()),\n+                    \"rows\",\n+                    Integer.toString(size.getRows()));\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ExecPty[\" + getName() + (systemStream != null ? \", system]\" : \"]\");\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecPty.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -20,0 +20,2 @@\n+\/\/import jdk.internal.org.jline.nativ.JLineLibrary;\n+\/\/import jdk.internal.org.jline.nativ.JLineNativeLoader;\n@@ -23,1 +25,1 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n@@ -27,0 +29,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -29,0 +32,1 @@\n+import jdk.internal.org.jline.utils.Log;\n@@ -31,2 +35,8 @@\n-public class ExecTerminalProvider implements TerminalProvider\n-{\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION;\n+\n+public class ExecTerminalProvider implements TerminalProvider {\n+\n+    private static boolean warned;\n@@ -35,1 +45,1 @@\n-        return \"exec\";\n+        return TerminalBuilder.PROP_PROVIDER_EXEC;\n@@ -38,2 +48,2 @@\n-    public Pty current(Stream consoleStream) throws IOException {\n-        return ExecPty.current(consoleStream);\n+    public Pty current(SystemStream systemStream) throws IOException {\n+        return ExecPty.current(this, systemStream);\n@@ -43,3 +53,11 @@\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -47,1 +65,2 @@\n-            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+            return winSysTerminal(\n+                    name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n@@ -49,1 +68,2 @@\n-            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+            return posixSysTerminal(\n+                    name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n@@ -53,3 +73,11 @@\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+    public Terminal winSysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -57,1 +85,1 @@\n-            Pty pty = current(consoleStream);\n+            Pty pty = current(systemStream);\n@@ -64,4 +92,12 @@\n-    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        Pty pty = current(consoleStream);\n+    public Terminal posixSysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        Pty pty = current(systemStream);\n@@ -72,5 +108,12 @@\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        return new ExternalTerminal(this, name, type, in, out, encoding, signalHandler, paused, attributes, size);\n@@ -80,1 +123,1 @@\n-    public boolean isSystemStream(Stream stream) {\n+    public boolean isSystemStream(SystemStream stream) {\n@@ -82,1 +125,1 @@\n-            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+            return isPosixSystemStream(stream) || isWindowsSystemStream(stream);\n@@ -88,2 +131,2 @@\n-    public boolean isWindowsSystemStream(Stream stream) {\n-        return systemStreamName( stream ) != null;\n+    public boolean isWindowsSystemStream(SystemStream stream) {\n+        return systemStreamName(stream) != null;\n@@ -92,1 +135,1 @@\n-    public boolean isPosixSystemStream(Stream stream) {\n+    public boolean isPosixSystemStream(SystemStream stream) {\n@@ -95,1 +138,2 @@\n-                    .inheritIO().start();\n+                    .inheritIO()\n+                    .start();\n@@ -98,0 +142,1 @@\n+            Log.debug(\"ExecTerminalProvider failed 'test -t' for \" + stream, t);\n@@ -104,1 +149,1 @@\n-    public String systemStreamName(Stream stream) {\n+    public String systemStreamName(SystemStream stream) {\n@@ -106,4 +151,5 @@\n-            ProcessBuilder.Redirect input = stream == Stream.Input\n-                                ? ProcessBuilder.Redirect.INHERIT\n-                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n-            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            ProcessBuilder.Redirect input = stream == SystemStream.Input\n+                    ? ProcessBuilder.Redirect.INHERIT\n+                    : newDescriptor(stream == SystemStream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p =\n+                    new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n@@ -115,0 +161,7 @@\n+            if (\"java.lang.reflect.InaccessibleObjectException\"\n+                            .equals(t.getClass().getName())\n+                    && !warned) {\n+                Log.warn(\n+                        \"The ExecTerminalProvider requires the JVM options: '--add-opens java.base\/java.lang=ALL-UNNAMED'\");\n+                warned = true;\n+            }\n@@ -120,12 +173,91 @@\n-    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n-        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n-        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n-        \/\/ the `tty` utility, it provides a way to get\n-        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n-        Constructor<?> cns = rpi.getDeclaredConstructor();\n-        cns.setAccessible(true);\n-        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n-        Field f = rpi.getDeclaredField(\"fd\");\n-        f.setAccessible(true);\n-        f.set(input, fd);\n-        return input;\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        try (ExecPty pty = new ExecPty(this, stream, null)) {\n+            return pty.getSize().getColumns();\n+        } catch (Throwable t) {\n+            return -1;\n+        }\n+    }\n+\n+    private static RedirectPipeCreator redirectPipeCreator;\n+\n+    protected static ProcessBuilder.Redirect newDescriptor(FileDescriptor fd) {\n+        if (redirectPipeCreator == null) {\n+            String str = System.getProperty(PROP_REDIRECT_PIPE_CREATION_MODE, PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT);\n+            String[] modes = str.split(\",\");\n+            IllegalStateException ise = new IllegalStateException(\"Unable to create RedirectPipe\");\n+            for (String mode : modes) {\n+                try {\n+                    switch (mode) {\n+                        case PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE:\n+                            redirectPipeCreator = null;\/\/new NativeRedirectPipeCreator();\n+                            break;\n+                        case PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION:\n+                            redirectPipeCreator = new ReflectionRedirectPipeCreator();\n+                            break;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ ignore\n+                    ise.addSuppressed(t);\n+                }\n+                if (redirectPipeCreator != null) {\n+                    break;\n+                }\n+            }\n+            if (redirectPipeCreator == null) {\n+                throw ise;\n+            }\n+        }\n+        return redirectPipeCreator.newRedirectPipe(fd);\n+    }\n+\n+    interface RedirectPipeCreator {\n+        ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd);\n+    }\n+\n+    \/**\n+     * Reflection based file descriptor creator.\n+     * This requires the following option\n+     *   --add-opens java.base\/java.lang=ALL-UNNAMED\n+     *\/\n+    static class ReflectionRedirectPipeCreator implements RedirectPipeCreator {\n+        private final Constructor<ProcessBuilder.Redirect> constructor;\n+        private final Field fdField;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReflectionRedirectPipeCreator() throws Exception {\n+            Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+            constructor = (Constructor<ProcessBuilder.Redirect>) rpi.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            fdField = rpi.getDeclaredField(\"fd\");\n+            fdField.setAccessible(true);\n+        }\n+\n+        @Override\n+        public ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd) {\n+            try {\n+                ProcessBuilder.Redirect input = constructor.newInstance();\n+                fdField.set(input, fd);\n+                return input;\n+            } catch (ReflectiveOperationException e) {\n+                \/\/ This should not happen as the field has been set accessible\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+\n+\/\/    static class NativeRedirectPipeCreator implements RedirectPipeCreator {\n+\/\/        public NativeRedirectPipeCreator() {\n+\/\/            \/\/ Force load the library\n+\/\/            JLineNativeLoader.initialize();\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd) {\n+\/\/            return JLineLibrary.newRedirectPipe(fd);\n+\/\/        }\n+\/\/    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":180,"deletions":48,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -0,0 +1,1170 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+\/\/import java.util.logging.Level;\n+\/\/import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+@SuppressWarnings(\"restricted\")\n+class CLibrary {\n+\n+\/\/    private static final Logger logger = Logger.getLogger(\"org.jline\");\n+\n+    \/\/ Window sizes.\n+    \/\/ @see <a href=\"http:\/\/man7.org\/linux\/man-pages\/man4\/tty_ioctl.4.html\">IOCTL_TTY(2) man-page<\/a>\n+    static class winsize {\n+        static final GroupLayout LAYOUT;\n+        private static final VarHandle ws_col;\n+        private static final VarHandle ws_row;\n+\n+        static {\n+            LAYOUT = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_SHORT.withName(\"ws_row\"),\n+                    ValueLayout.JAVA_SHORT.withName(\"ws_col\"),\n+                    ValueLayout.JAVA_SHORT,\n+                    ValueLayout.JAVA_SHORT);\n+            ws_row = FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"ws_row\"));\n+            ws_col = FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"ws_col\"));\n+        }\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        winsize() {\n+            seg = java.lang.foreign.Arena.ofAuto().allocate(LAYOUT);\n+        }\n+\n+        winsize(short ws_col, short ws_row) {\n+            this();\n+            ws_col(ws_col);\n+            ws_row(ws_row);\n+        }\n+\n+        java.lang.foreign.MemorySegment segment() {\n+            return seg;\n+        }\n+\n+        short ws_col() {\n+            return (short) ws_col.get(seg);\n+        }\n+\n+        void ws_col(short col) {\n+            ws_col.set(seg, col);\n+        }\n+\n+        short ws_row() {\n+            return (short) ws_row.get(seg);\n+        }\n+\n+        void ws_row(short row) {\n+            ws_row.set(seg, row);\n+        }\n+    }\n+\n+    \/\/ termios structure for termios functions, describing a general terminal interface that is\n+    \/\/ provided to control asynchronous communications ports\n+    \/\/ @see <a href=\"http:\/\/man7.org\/linux\/man-pages\/man3\/termios.3.html\">TERMIOS(3) man-page<\/a>\n+    static class termios {\n+        static final GroupLayout LAYOUT;\n+        private static final VarHandle c_iflag;\n+        private static final VarHandle c_oflag;\n+        private static final VarHandle c_cflag;\n+        private static final VarHandle c_lflag;\n+        private static final long c_cc_offset;\n+        private static final VarHandle c_ispeed;\n+        private static final VarHandle c_ospeed;\n+\n+        static {\n+            if (OSUtils.IS_OSX) {\n+                LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_LONG.withName(\"c_iflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_oflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_cflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_lflag\"),\n+                        MemoryLayout.sequenceLayout(32, ValueLayout.JAVA_BYTE).withName(\"c_cc\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_ispeed\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_ospeed\"));\n+            } else if (OSUtils.IS_LINUX) {\n+                LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"c_iflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_oflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_cflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_lflag\"),\n+                        ValueLayout.JAVA_BYTE.withName(\"c_line\"),\n+                        MemoryLayout.sequenceLayout(32, ValueLayout.JAVA_BYTE).withName(\"c_cc\"),\n+                        MemoryLayout.paddingLayout(3),\n+                        ValueLayout.JAVA_INT.withName(\"c_ispeed\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_ospeed\"));\n+            } else {\n+                throw new IllegalStateException(\"Unsupported system!\");\n+            }\n+            c_iflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_iflag\")));\n+            c_oflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_oflag\")));\n+            c_cflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_cflag\")));\n+            c_lflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_lflag\")));\n+            c_cc_offset = LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(\"c_cc\"));\n+            c_ispeed = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_ispeed\")));\n+            c_ospeed = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_ospeed\")));\n+        }\n+\n+        private static VarHandle adjust2LinuxHandle(VarHandle v) {\n+            if (OSUtils.IS_LINUX) {\n+                MethodHandle id = MethodHandles.identity(int.class);\n+                v = MethodHandles.filterValue(\n+                        v,\n+                        MethodHandles.explicitCastArguments(id, MethodType.methodType(int.class, long.class)),\n+                        MethodHandles.explicitCastArguments(id, MethodType.methodType(long.class, int.class)));\n+            }\n+\n+            return v;\n+        }\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        termios() {\n+            seg = java.lang.foreign.Arena.ofAuto().allocate(LAYOUT);\n+        }\n+\n+        termios(Attributes t) {\n+            this();\n+            \/\/ Input flags\n+            long c_iflag = 0;\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNBRK), IGNBRK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.BRKINT), BRKINT, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNPAR), IGNPAR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.PARMRK), PARMRK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.INPCK), INPCK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.ISTRIP), ISTRIP, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.INLCR), INLCR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNCR), IGNCR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.ICRNL), ICRNL, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXON), IXON, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXOFF), IXOFF, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXANY), IXANY, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IMAXBEL), IMAXBEL, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IUTF8), IUTF8, c_iflag);\n+            c_iflag(c_iflag);\n+            \/\/ Output flags\n+            long c_oflag = 0;\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OPOST), OPOST, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONLCR), ONLCR, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OXTABS), OXTABS, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONOEOT), ONOEOT, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OCRNL), OCRNL, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONOCR), ONOCR, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONLRET), ONLRET, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OFILL), OFILL, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.NLDLY), NLDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.TABDLY), TABDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.CRDLY), CRDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.FFDLY), FFDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.BSDLY), BSDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.VTDLY), VTDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OFDEL), OFDEL, c_oflag);\n+            c_oflag(c_oflag);\n+            \/\/ Control flags\n+            long c_cflag = 0;\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CIGNORE), CIGNORE, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS5), CS5, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS6), CS6, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS7), CS7, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS8), CS8, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CSTOPB), CSTOPB, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CREAD), CREAD, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.PARENB), PARENB, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.PARODD), PARODD, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.HUPCL), HUPCL, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CLOCAL), CLOCAL, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CCTS_OFLOW), CCTS_OFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CRTS_IFLOW), CRTS_IFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CDTR_IFLOW), CDTR_IFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CDSR_OFLOW), CDSR_OFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CCAR_OFLOW), CCAR_OFLOW, c_cflag);\n+            c_cflag(c_cflag);\n+            \/\/ Local flags\n+            long c_lflag = 0;\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOKE), ECHOKE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOE), ECHOE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOK), ECHOK, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHO), ECHO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHONL), ECHONL, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOPRT), ECHOPRT, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOCTL), ECHOCTL, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ISIG), ISIG, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ICANON), ICANON, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ALTWERASE), ALTWERASE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.IEXTEN), IEXTEN, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.EXTPROC), EXTPROC, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.TOSTOP), TOSTOP, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.FLUSHO), FLUSHO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.NOKERNINFO), NOKERNINFO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.PENDIN), PENDIN, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.NOFLSH), NOFLSH, c_lflag);\n+            c_lflag(c_lflag);\n+            \/\/ Control chars\n+            byte[] c_cc = new byte[20];\n+            c_cc[VEOF] = (byte) t.getControlChar(Attributes.ControlChar.VEOF);\n+            c_cc[VEOL] = (byte) t.getControlChar(Attributes.ControlChar.VEOL);\n+            c_cc[VEOL2] = (byte) t.getControlChar(Attributes.ControlChar.VEOL2);\n+            c_cc[VERASE] = (byte) t.getControlChar(Attributes.ControlChar.VERASE);\n+            c_cc[VWERASE] = (byte) t.getControlChar(Attributes.ControlChar.VWERASE);\n+            c_cc[VKILL] = (byte) t.getControlChar(Attributes.ControlChar.VKILL);\n+            c_cc[VREPRINT] = (byte) t.getControlChar(Attributes.ControlChar.VREPRINT);\n+            c_cc[VINTR] = (byte) t.getControlChar(Attributes.ControlChar.VINTR);\n+            c_cc[VQUIT] = (byte) t.getControlChar(Attributes.ControlChar.VQUIT);\n+            c_cc[VSUSP] = (byte) t.getControlChar(Attributes.ControlChar.VSUSP);\n+            if (VDSUSP != (-1)) {\n+                c_cc[VDSUSP] = (byte) t.getControlChar(Attributes.ControlChar.VDSUSP);\n+            }\n+            c_cc[VSTART] = (byte) t.getControlChar(Attributes.ControlChar.VSTART);\n+            c_cc[VSTOP] = (byte) t.getControlChar(Attributes.ControlChar.VSTOP);\n+            c_cc[VLNEXT] = (byte) t.getControlChar(Attributes.ControlChar.VLNEXT);\n+            c_cc[VDISCARD] = (byte) t.getControlChar(Attributes.ControlChar.VDISCARD);\n+            c_cc[VMIN] = (byte) t.getControlChar(Attributes.ControlChar.VMIN);\n+            c_cc[VTIME] = (byte) t.getControlChar(Attributes.ControlChar.VTIME);\n+            if (VSTATUS != (-1)) {\n+                c_cc[VSTATUS] = (byte) t.getControlChar(Attributes.ControlChar.VSTATUS);\n+            }\n+            c_cc().copyFrom(java.lang.foreign.MemorySegment.ofArray(c_cc));\n+        }\n+\n+        java.lang.foreign.MemorySegment segment() {\n+            return seg;\n+        }\n+\n+        long c_iflag() {\n+            return (long) c_iflag.get(seg);\n+        }\n+\n+        void c_iflag(long f) {\n+            c_iflag.set(seg, f);\n+        }\n+\n+        long c_oflag() {\n+            return (long) c_oflag.get(seg);\n+        }\n+\n+        void c_oflag(long f) {\n+            c_oflag.set(seg, f);\n+        }\n+\n+        long c_cflag() {\n+            return (long) c_cflag.get(seg);\n+        }\n+\n+        void c_cflag(long f) {\n+            c_cflag.set(seg, f);\n+        }\n+\n+        long c_lflag() {\n+            return (long) c_lflag.get(seg);\n+        }\n+\n+        void c_lflag(long f) {\n+            c_lflag.set(seg, f);\n+        }\n+\n+        java.lang.foreign.MemorySegment c_cc() {\n+            return seg.asSlice(c_cc_offset, 20);\n+        }\n+\n+        long c_ispeed() {\n+            return (long) c_ispeed.get(seg);\n+        }\n+\n+        void c_ispeed(long f) {\n+            c_ispeed.set(seg, f);\n+        }\n+\n+        long c_ospeed() {\n+            return (long) c_ospeed.get(seg);\n+        }\n+\n+        void c_ospeed(long f) {\n+            c_ospeed.set(seg, f);\n+        }\n+\n+        private static long setFlag(boolean flag, long value, long org) {\n+            return flag ? org | value : org;\n+        }\n+\n+        private static <T extends Enum<T>> void addFlag(long value, EnumSet<T> flags, T flag, int v) {\n+            if ((value & v) != 0) {\n+                flags.add(flag);\n+            }\n+        }\n+\n+        public Attributes asAttributes() {\n+            Attributes attr = new Attributes();\n+            \/\/ Input flags\n+            long c_iflag = c_iflag();\n+            EnumSet<Attributes.InputFlag> iflag = attr.getInputFlags();\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.BRKINT, BRKINT);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNPAR, IGNPAR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.PARMRK, PARMRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.INPCK, INPCK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.ISTRIP, ISTRIP);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.INLCR, INLCR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNCR, IGNCR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.ICRNL, ICRNL);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXON, IXON);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXOFF, IXOFF);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXANY, IXANY);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IMAXBEL, IMAXBEL);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IUTF8, IUTF8);\n+            \/\/ Output flags\n+            long c_oflag = c_oflag();\n+            EnumSet<Attributes.OutputFlag> oflag = attr.getOutputFlags();\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OPOST, OPOST);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONLCR, ONLCR);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OXTABS, OXTABS);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONOEOT, ONOEOT);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OCRNL, OCRNL);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONOCR, ONOCR);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONLRET, ONLRET);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OFILL, OFILL);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.NLDLY, NLDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.TABDLY, TABDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.CRDLY, CRDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.FFDLY, FFDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.BSDLY, BSDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.VTDLY, VTDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OFDEL, OFDEL);\n+            \/\/ Control flags\n+            long c_cflag = c_cflag();\n+            EnumSet<Attributes.ControlFlag> cflag = attr.getControlFlags();\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CIGNORE, CIGNORE);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS5, CS5);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS6, CS6);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS7, CS7);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS8, CS8);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CSTOPB, CSTOPB);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CREAD, CREAD);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.PARENB, PARENB);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.PARODD, PARODD);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.HUPCL, HUPCL);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CLOCAL, CLOCAL);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CCTS_OFLOW, CCTS_OFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CRTS_IFLOW, CRTS_IFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CDSR_OFLOW, CDSR_OFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CCAR_OFLOW, CCAR_OFLOW);\n+            \/\/ Local flags\n+            long c_lflag = c_lflag();\n+            EnumSet<Attributes.LocalFlag> lflag = attr.getLocalFlags();\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOKE, ECHOKE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOE, ECHOE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOK, ECHOK);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHO, ECHO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHONL, ECHONL);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOPRT, ECHOPRT);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOCTL, ECHOCTL);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ISIG, ISIG);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ICANON, ICANON);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ALTWERASE, ALTWERASE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.IEXTEN, IEXTEN);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.EXTPROC, EXTPROC);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.TOSTOP, TOSTOP);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.FLUSHO, FLUSHO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.NOKERNINFO, NOKERNINFO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.PENDIN, PENDIN);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.NOFLSH, NOFLSH);\n+            \/\/ Control chars\n+            byte[] c_cc = c_cc().toArray(ValueLayout.JAVA_BYTE);\n+            EnumMap<Attributes.ControlChar, Integer> cc = attr.getControlChars();\n+            cc.put(Attributes.ControlChar.VEOF, (int) c_cc[VEOF]);\n+            cc.put(Attributes.ControlChar.VEOL, (int) c_cc[VEOL]);\n+            cc.put(Attributes.ControlChar.VEOL2, (int) c_cc[VEOL2]);\n+            cc.put(Attributes.ControlChar.VERASE, (int) c_cc[VERASE]);\n+            cc.put(Attributes.ControlChar.VWERASE, (int) c_cc[VWERASE]);\n+            cc.put(Attributes.ControlChar.VKILL, (int) c_cc[VKILL]);\n+            cc.put(Attributes.ControlChar.VREPRINT, (int) c_cc[VREPRINT]);\n+            cc.put(Attributes.ControlChar.VINTR, (int) c_cc[VINTR]);\n+            cc.put(Attributes.ControlChar.VQUIT, (int) c_cc[VQUIT]);\n+            cc.put(Attributes.ControlChar.VSUSP, (int) c_cc[VSUSP]);\n+            if (VDSUSP != (-1)) {\n+                cc.put(Attributes.ControlChar.VDSUSP, (int) c_cc[VDSUSP]);\n+            }\n+            cc.put(Attributes.ControlChar.VSTART, (int) c_cc[VSTART]);\n+            cc.put(Attributes.ControlChar.VSTOP, (int) c_cc[VSTOP]);\n+            cc.put(Attributes.ControlChar.VLNEXT, (int) c_cc[VLNEXT]);\n+            cc.put(Attributes.ControlChar.VDISCARD, (int) c_cc[VDISCARD]);\n+            cc.put(Attributes.ControlChar.VMIN, (int) c_cc[VMIN]);\n+            cc.put(Attributes.ControlChar.VTIME, (int) c_cc[VTIME]);\n+            if (VSTATUS != (-1)) {\n+                cc.put(Attributes.ControlChar.VSTATUS, (int) c_cc[VSTATUS]);\n+            }\n+            \/\/ Return\n+            return attr;\n+        }\n+    }\n+\n+    static MethodHandle ioctl;\n+    static MethodHandle isatty;\n+    static MethodHandle openpty;\n+    static MethodHandle tcsetattr;\n+    static MethodHandle tcgetattr;\n+    static MethodHandle ttyname_r;\n+    static LinkageError openptyError;\n+\n+    static {\n+        \/\/ methods\n+        Linker linker = Linker.nativeLinker();\n+        SymbolLookup lookup = SymbolLookup.loaderLookup().or(linker.defaultLookup());\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man2\/ioctl.2.html\n+        ioctl = linker.downcallHandle(\n+                lookup.find(\"ioctl\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.ADDRESS),\n+                Linker.Option.firstVariadicArg(2));\n+        \/\/ https:\/\/www.man7.org\/linux\/man-pages\/man3\/isatty.3.html\n+        isatty = linker.downcallHandle(\n+                lookup.find(\"isatty\").get(), FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/tcsetattr.3p.html\n+        tcsetattr = linker.downcallHandle(\n+                lookup.find(\"tcsetattr\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/tcgetattr.3p.html\n+        tcgetattr = linker.downcallHandle(\n+                lookup.find(\"tcgetattr\").get(),\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/ttyname.3.html\n+        ttyname_r = linker.downcallHandle(\n+                lookup.find(\"ttyname_r\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/openpty.3.html\n+        LinkageError error = null;\n+        Optional<MemorySegment> openPtyAddr = lookup.find(\"openpty\");\n+        if (openPtyAddr.isPresent()) {\n+            openpty = linker.downcallHandle(\n+                    openPtyAddr.get(),\n+                    FunctionDescriptor.of(\n+                            ValueLayout.JAVA_INT,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS));\n+            openptyError = null;\n+        } else {\n+            openpty = null;\n+            openptyError = error;\n+        }\n+    }\n+\n+    private static String readFully(InputStream in) throws IOException {\n+        int readLen = 0;\n+        ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        byte[] buf = new byte[32];\n+        while ((readLen = in.read(buf, 0, buf.length)) >= 0) {\n+            b.write(buf, 0, readLen);\n+        }\n+        return b.toString();\n+    }\n+\n+    static Size getTerminalSize(int fd) {\n+        try {\n+            winsize ws = new winsize();\n+            int res = (int) ioctl.invoke(fd, (long) TIOCGWINSZ, ws.segment());\n+            return new Size(ws.ws_col(), ws.ws_row());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ioctl(TIOCGWINSZ)\", e);\n+        }\n+    }\n+\n+    static void setTerminalSize(int fd, Size size) {\n+        try {\n+            winsize ws = new winsize();\n+            ws.ws_row((short) size.getRows());\n+            ws.ws_col((short) size.getColumns());\n+            int res = (int) ioctl.invoke(fd, TIOCSWINSZ, ws.segment());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ioctl(TIOCSWINSZ)\", e);\n+        }\n+    }\n+\n+    static Attributes getAttributes(int fd) {\n+        try {\n+            termios t = new termios();\n+            int res = (int) tcgetattr.invoke(fd, t.segment());\n+            return t.asAttributes();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call tcgetattr()\", e);\n+        }\n+    }\n+\n+    static void setAttributes(int fd, Attributes attr) {\n+        try {\n+            termios t = new termios(attr);\n+            int res = (int) tcsetattr.invoke(fd, TCSANOW, t.segment());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call tcsetattr()\", e);\n+        }\n+    }\n+\n+    static boolean isTty(int fd) {\n+        try {\n+            return (int) isatty.invoke(fd) == 1;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call isatty()\", e);\n+        }\n+    }\n+\n+    static String ttyName(int fd) {\n+        try {\n+            java.lang.foreign.MemorySegment buf =\n+                    java.lang.foreign.Arena.ofAuto().allocate(64);\n+            int res = (int) ttyname_r.invoke(fd, buf, buf.byteSize());\n+            byte[] data = buf.toArray(ValueLayout.JAVA_BYTE);\n+            int len = 0;\n+            while (data[len] != 0) {\n+                len++;\n+            }\n+            return new String(data, 0, len);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ttyname_r()\", e);\n+        }\n+    }\n+\n+    static Pty openpty(TerminalProvider provider, Attributes attr, Size size) {\n+        if (openptyError != null) {\n+            throw openptyError;\n+        }\n+        try {\n+            java.lang.foreign.MemorySegment buf =\n+                    java.lang.foreign.Arena.ofAuto().allocate(64);\n+            java.lang.foreign.MemorySegment master =\n+                    java.lang.foreign.Arena.ofAuto().allocate(ValueLayout.JAVA_INT);\n+            java.lang.foreign.MemorySegment slave =\n+                    java.lang.foreign.Arena.ofAuto().allocate(ValueLayout.JAVA_INT);\n+            int res = (int) openpty.invoke(\n+                    master,\n+                    slave,\n+                    buf,\n+                    attr != null ? new termios(attr).segment() : java.lang.foreign.MemorySegment.NULL,\n+                    size != null\n+                            ? new winsize((short) size.getRows(), (short) size.getColumns()).segment()\n+                            : java.lang.foreign.MemorySegment.NULL);\n+            byte[] str = buf.toArray(ValueLayout.JAVA_BYTE);\n+            int len = 0;\n+            while (str[len] != 0) {\n+                len++;\n+            }\n+            String device = new String(str, 0, len);\n+            return new FfmNativePty(\n+                    provider, null, master.get(ValueLayout.JAVA_INT, 0), slave.get(ValueLayout.JAVA_INT, 0), device);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call openpty()\", e);\n+        }\n+    }\n+\n+    \/\/ CONSTANTS\n+\n+    private static final int TIOCGWINSZ;\n+    private static final int TIOCSWINSZ;\n+\n+    private static final int TCSANOW;\n+    private static int TCSADRAIN;\n+    private static int TCSAFLUSH;\n+\n+    private static final int VEOF;\n+    private static final int VEOL;\n+    private static final int VEOL2;\n+    private static final int VERASE;\n+    private static final int VWERASE;\n+    private static final int VKILL;\n+    private static final int VREPRINT;\n+    private static final int VERASE2;\n+    private static final int VINTR;\n+    private static final int VQUIT;\n+    private static final int VSUSP;\n+    private static final int VDSUSP;\n+    private static final int VSTART;\n+    private static final int VSTOP;\n+    private static final int VLNEXT;\n+    private static final int VDISCARD;\n+    private static final int VMIN;\n+    private static final int VSWTC;\n+    private static final int VTIME;\n+    private static final int VSTATUS;\n+\n+    private static final int IGNBRK;\n+    private static final int BRKINT;\n+    private static final int IGNPAR;\n+    private static final int PARMRK;\n+    private static final int INPCK;\n+    private static final int ISTRIP;\n+    private static final int INLCR;\n+    private static final int IGNCR;\n+    private static final int ICRNL;\n+    private static int IUCLC;\n+    private static final int IXON;\n+    private static final int IXOFF;\n+    private static final int IXANY;\n+    private static final int IMAXBEL;\n+    private static int IUTF8;\n+\n+    private static final int OPOST;\n+    private static int OLCUC;\n+    private static final int ONLCR;\n+    private static int OXTABS;\n+    private static int NLDLY;\n+    private static int NL0;\n+    private static int NL1;\n+    private static final int TABDLY;\n+    private static int TAB0;\n+    private static int TAB1;\n+    private static int TAB2;\n+    private static int TAB3;\n+    private static int CRDLY;\n+    private static int CR0;\n+    private static int CR1;\n+    private static int CR2;\n+    private static int CR3;\n+    private static int FFDLY;\n+    private static int FF0;\n+    private static int FF1;\n+    private static int XTABS;\n+    private static int BSDLY;\n+    private static int BS0;\n+    private static int BS1;\n+    private static int VTDLY;\n+    private static int VT0;\n+    private static int VT1;\n+    private static int CBAUD;\n+    private static int B0;\n+    private static int B50;\n+    private static int B75;\n+    private static int B110;\n+    private static int B134;\n+    private static int B150;\n+    private static int B200;\n+    private static int B300;\n+    private static int B600;\n+    private static int B1200;\n+    private static int B1800;\n+    private static int B2400;\n+    private static int B4800;\n+    private static int B9600;\n+    private static int B19200;\n+    private static int B38400;\n+    private static int EXTA;\n+    private static int EXTB;\n+    private static int OFDEL;\n+    private static int ONOEOT;\n+    private static final int OCRNL;\n+    private static int ONOCR;\n+    private static final int ONLRET;\n+    private static int OFILL;\n+\n+    private static int CIGNORE;\n+    private static int CSIZE;\n+    private static final int CS5;\n+    private static final int CS6;\n+    private static final int CS7;\n+    private static final int CS8;\n+    private static final int CSTOPB;\n+    private static final int CREAD;\n+    private static final int PARENB;\n+    private static final int PARODD;\n+    private static final int HUPCL;\n+    private static final int CLOCAL;\n+    private static int CCTS_OFLOW;\n+    private static int CRTS_IFLOW;\n+    private static int CDTR_IFLOW;\n+    private static int CDSR_OFLOW;\n+    private static int CCAR_OFLOW;\n+\n+    private static final int ECHOKE;\n+    private static final int ECHOE;\n+    private static final int ECHOK;\n+    private static final int ECHO;\n+    private static final int ECHONL;\n+    private static final int ECHOPRT;\n+    private static final int ECHOCTL;\n+    private static final int ISIG;\n+    private static final int ICANON;\n+    private static int XCASE;\n+    private static int ALTWERASE;\n+    private static final int IEXTEN;\n+    private static final int EXTPROC;\n+    private static final int TOSTOP;\n+    private static final int FLUSHO;\n+    private static int NOKERNINFO;\n+    private static final int PENDIN;\n+    private static final int NOFLSH;\n+\n+    static {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName.startsWith(\"Linux\")) {\n+            String arch = System.getProperty(\"os.arch\");\n+            boolean isMipsPpcOrSparc = arch.equals(\"mips\")\n+                    || arch.equals(\"mips64\")\n+                    || arch.equals(\"mipsel\")\n+                    || arch.equals(\"mips64el\")\n+                    || arch.startsWith(\"ppc\")\n+                    || arch.startsWith(\"sparc\");\n+            TIOCGWINSZ = isMipsPpcOrSparc ? 0x40087468 : 0x00005413;\n+            TIOCSWINSZ = isMipsPpcOrSparc ? 0x80087467 : 0x00005414;\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VINTR = 0;\n+            VQUIT = 1;\n+            VERASE = 2;\n+            VKILL = 3;\n+            VEOF = 4;\n+            VTIME = 5;\n+            VMIN = 6;\n+            VSWTC = 7;\n+            VSTART = 8;\n+            VSTOP = 9;\n+            VSUSP = 10;\n+            VEOL = 11;\n+            VREPRINT = 12;\n+            VDISCARD = 13;\n+            VWERASE = 14;\n+            VLNEXT = 15;\n+            VEOL2 = 16;\n+            VERASE2 = -1;\n+            VDSUSP = -1;\n+            VSTATUS = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000008;\n+            INPCK = 0x0000010;\n+            ISTRIP = 0x0000020;\n+            INLCR = 0x0000040;\n+            IGNCR = 0x0000080;\n+            ICRNL = 0x0000100;\n+            IUCLC = 0x0000200;\n+            IXON = 0x0000400;\n+            IXANY = 0x0000800;\n+            IXOFF = 0x0001000;\n+            IMAXBEL = 0x0002000;\n+            IUTF8 = 0x0004000;\n+\n+            OPOST = 0x0000001;\n+            OLCUC = 0x0000002;\n+            ONLCR = 0x0000004;\n+            OCRNL = 0x0000008;\n+            ONOCR = 0x0000010;\n+            ONLRET = 0x0000020;\n+            OFILL = 0x0000040;\n+            OFDEL = 0x0000080;\n+            NLDLY = 0x0000100;\n+            NL0 = 0x0000000;\n+            NL1 = 0x0000100;\n+            CRDLY = 0x0000600;\n+            CR0 = 0x0000000;\n+            CR1 = 0x0000200;\n+            CR2 = 0x0000400;\n+            CR3 = 0x0000600;\n+            TABDLY = 0x0001800;\n+            TAB0 = 0x0000000;\n+            TAB1 = 0x0000800;\n+            TAB2 = 0x0001000;\n+            TAB3 = 0x0001800;\n+            XTABS = 0x0001800;\n+            BSDLY = 0x0002000;\n+            BS0 = 0x0000000;\n+            BS1 = 0x0002000;\n+            VTDLY = 0x0004000;\n+            VT0 = 0x0000000;\n+            VT1 = 0x0004000;\n+            FFDLY = 0x0008000;\n+            FF0 = 0x0000000;\n+            FF1 = 0x0008000;\n+\n+            CBAUD = 0x000100f;\n+            B0 = 0x0000000;\n+            B50 = 0x0000001;\n+            B75 = 0x0000002;\n+            B110 = 0x0000003;\n+            B134 = 0x0000004;\n+            B150 = 0x0000005;\n+            B200 = 0x0000006;\n+            B300 = 0x0000007;\n+            B600 = 0x0000008;\n+            B1200 = 0x0000009;\n+            B1800 = 0x000000a;\n+            B2400 = 0x000000b;\n+            B4800 = 0x000000c;\n+            B9600 = 0x000000d;\n+            B19200 = 0x000000e;\n+            B38400 = 0x000000f;\n+            EXTA = B19200;\n+            EXTB = B38400;\n+            CSIZE = 0x0000030;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000010;\n+            CS7 = 0x0000020;\n+            CS8 = 0x0000030;\n+            CSTOPB = 0x0000040;\n+            CREAD = 0x0000080;\n+            PARENB = 0x0000100;\n+            PARODD = 0x0000200;\n+            HUPCL = 0x0000400;\n+            CLOCAL = 0x0000800;\n+\n+            ISIG = 0x0000001;\n+            ICANON = 0x0000002;\n+            XCASE = 0x0000004;\n+            ECHO = 0x0000008;\n+            ECHOE = 0x0000010;\n+            ECHOK = 0x0000020;\n+            ECHONL = 0x0000040;\n+            NOFLSH = 0x0000080;\n+            TOSTOP = 0x0000100;\n+            ECHOCTL = 0x0000200;\n+            ECHOPRT = 0x0000400;\n+            ECHOKE = 0x0000800;\n+            FLUSHO = 0x0001000;\n+            PENDIN = 0x0002000;\n+            IEXTEN = 0x0008000;\n+            EXTPROC = 0x0010000;\n+        } else if (osName.startsWith(\"Solaris\") || osName.startsWith(\"SunOS\")) {\n+            int _TIOC = ('T' << 8);\n+            TIOCGWINSZ = (_TIOC | 104);\n+            TIOCSWINSZ = (_TIOC | 103);\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VINTR = 0;\n+            VQUIT = 1;\n+            VERASE = 2;\n+            VKILL = 3;\n+            VEOF = 4;\n+            VTIME = 5;\n+            VMIN = 6;\n+            VSWTC = 7;\n+            VSTART = 8;\n+            VSTOP = 9;\n+            VSUSP = 10;\n+            VEOL = 11;\n+            VREPRINT = 12;\n+            VDISCARD = 13;\n+            VWERASE = 14;\n+            VLNEXT = 15;\n+            VEOL2 = 16;\n+            VERASE2 = -1;\n+            VDSUSP = -1;\n+            VSTATUS = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000010;\n+            INPCK = 0x0000020;\n+            ISTRIP = 0x0000040;\n+            INLCR = 0x0000100;\n+            IGNCR = 0x0000200;\n+            ICRNL = 0x0000400;\n+            IUCLC = 0x0001000;\n+            IXON = 0x0002000;\n+            IXANY = 0x0004000;\n+            IXOFF = 0x0010000;\n+            IMAXBEL = 0x0020000;\n+            IUTF8 = 0x0040000;\n+\n+            OPOST = 0x0000001;\n+            OLCUC = 0x0000002;\n+            ONLCR = 0x0000004;\n+            OCRNL = 0x0000010;\n+            ONOCR = 0x0000020;\n+            ONLRET = 0x0000040;\n+            OFILL = 0x0000100;\n+            OFDEL = 0x0000200;\n+            NLDLY = 0x0000400;\n+            NL0 = 0x0000000;\n+            NL1 = 0x0000400;\n+            CRDLY = 0x0003000;\n+            CR0 = 0x0000000;\n+            CR1 = 0x0001000;\n+            CR2 = 0x0002000;\n+            CR3 = 0x0003000;\n+            TABDLY = 0x0014000;\n+            TAB0 = 0x0000000;\n+            TAB1 = 0x0004000;\n+            TAB2 = 0x0010000;\n+            TAB3 = 0x0014000;\n+            XTABS = 0x0014000;\n+            BSDLY = 0x0020000;\n+            BS0 = 0x0000000;\n+            BS1 = 0x0020000;\n+            VTDLY = 0x0040000;\n+            VT0 = 0x0000000;\n+            VT1 = 0x0040000;\n+            FFDLY = 0x0100000;\n+            FF0 = 0x0000000;\n+            FF1 = 0x0100000;\n+\n+            CBAUD = 0x0010017;\n+            B0 = 0x0000000;\n+            B50 = 0x0000001;\n+            B75 = 0x0000002;\n+            B110 = 0x0000003;\n+            B134 = 0x0000004;\n+            B150 = 0x0000005;\n+            B200 = 0x0000006;\n+            B300 = 0x0000007;\n+            B600 = 0x0000010;\n+            B1200 = 0x0000011;\n+            B1800 = 0x0000012;\n+            B2400 = 0x0000013;\n+            B4800 = 0x0000014;\n+            B9600 = 0x0000015;\n+            B19200 = 0x0000016;\n+            B38400 = 0x0000017;\n+            EXTA = 0xB19200;\n+            EXTB = 0xB38400;\n+            CSIZE = 0x0000060;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000020;\n+            CS7 = 0x0000040;\n+            CS8 = 0x0000060;\n+            CSTOPB = 0x0000100;\n+            CREAD = 0x0000200;\n+            PARENB = 0x0000400;\n+            PARODD = 0x0001000;\n+            HUPCL = 0x0002000;\n+            CLOCAL = 0x0004000;\n+\n+            ISIG = 0x0000001;\n+            ICANON = 0x0000002;\n+            XCASE = 0x0000004;\n+            ECHO = 0x0000010;\n+            ECHOE = 0x0000020;\n+            ECHOK = 0x0000040;\n+            ECHONL = 0x0000100;\n+            NOFLSH = 0x0000200;\n+            TOSTOP = 0x0000400;\n+            ECHOCTL = 0x0001000;\n+            ECHOPRT = 0x0002000;\n+            ECHOKE = 0x0004000;\n+            FLUSHO = 0x0010000;\n+            PENDIN = 0x0040000;\n+            IEXTEN = 0x0100000;\n+            EXTPROC = 0x0200000;\n+        } else if (osName.startsWith(\"Mac\") || osName.startsWith(\"Darwin\")) {\n+            TIOCGWINSZ = 0x40087468;\n+            TIOCSWINSZ = 0x80087467;\n+\n+            TCSANOW = 0x00000000;\n+\n+            VEOF = 0;\n+            VEOL = 1;\n+            VEOL2 = 2;\n+            VERASE = 3;\n+            VWERASE = 4;\n+            VKILL = 5;\n+            VREPRINT = 6;\n+            VINTR = 8;\n+            VQUIT = 9;\n+            VSUSP = 10;\n+            VDSUSP = 11;\n+            VSTART = 12;\n+            VSTOP = 13;\n+            VLNEXT = 14;\n+            VDISCARD = 15;\n+            VMIN = 16;\n+            VTIME = 17;\n+            VSTATUS = 18;\n+            VERASE2 = -1;\n+            VSWTC = -1;\n+\n+            IGNBRK = 0x00000001;\n+            BRKINT = 0x00000002;\n+            IGNPAR = 0x00000004;\n+            PARMRK = 0x00000008;\n+            INPCK = 0x00000010;\n+            ISTRIP = 0x00000020;\n+            INLCR = 0x00000040;\n+            IGNCR = 0x00000080;\n+            ICRNL = 0x00000100;\n+            IXON = 0x00000200;\n+            IXOFF = 0x00000400;\n+            IXANY = 0x00000800;\n+            IMAXBEL = 0x00002000;\n+            IUTF8 = 0x00004000;\n+\n+            OPOST = 0x00000001;\n+            ONLCR = 0x00000002;\n+            OXTABS = 0x00000004;\n+            ONOEOT = 0x00000008;\n+            OCRNL = 0x00000010;\n+            ONOCR = 0x00000020;\n+            ONLRET = 0x00000040;\n+            OFILL = 0x00000080;\n+            NLDLY = 0x00000300;\n+            TABDLY = 0x00000c04;\n+            CRDLY = 0x00003000;\n+            FFDLY = 0x00004000;\n+            BSDLY = 0x00008000;\n+            VTDLY = 0x00010000;\n+            OFDEL = 0x00020000;\n+\n+            CIGNORE = 0x00000001;\n+            CS5 = 0x00000000;\n+            CS6 = 0x00000100;\n+            CS7 = 0x00000200;\n+            CS8 = 0x00000300;\n+            CSTOPB = 0x00000400;\n+            CREAD = 0x00000800;\n+            PARENB = 0x00001000;\n+            PARODD = 0x00002000;\n+            HUPCL = 0x00004000;\n+            CLOCAL = 0x00008000;\n+            CCTS_OFLOW = 0x00010000;\n+            CRTS_IFLOW = 0x00020000;\n+            CDTR_IFLOW = 0x00040000;\n+            CDSR_OFLOW = 0x00080000;\n+            CCAR_OFLOW = 0x00100000;\n+\n+            ECHOKE = 0x00000001;\n+            ECHOE = 0x00000002;\n+            ECHOK = 0x00000004;\n+            ECHO = 0x00000008;\n+            ECHONL = 0x00000010;\n+            ECHOPRT = 0x00000020;\n+            ECHOCTL = 0x00000040;\n+            ISIG = 0x00000080;\n+            ICANON = 0x00000100;\n+            ALTWERASE = 0x00000200;\n+            IEXTEN = 0x00000400;\n+            EXTPROC = 0x00000800;\n+            TOSTOP = 0x00400000;\n+            FLUSHO = 0x00800000;\n+            NOKERNINFO = 0x02000000;\n+            PENDIN = 0x20000000;\n+            NOFLSH = 0x80000000;\n+        } else if (osName.startsWith(\"FreeBSD\")) {\n+            TIOCGWINSZ = 0x40087468;\n+            TIOCSWINSZ = 0x80087467;\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VEOF = 0;\n+            VEOL = 1;\n+            VEOL2 = 2;\n+            VERASE = 3;\n+            VWERASE = 4;\n+            VKILL = 5;\n+            VREPRINT = 6;\n+            VERASE2 = 7;\n+            VINTR = 8;\n+            VQUIT = 9;\n+            VSUSP = 10;\n+            VDSUSP = 11;\n+            VSTART = 12;\n+            VSTOP = 13;\n+            VLNEXT = 14;\n+            VDISCARD = 15;\n+            VMIN = 16;\n+            VTIME = 17;\n+            VSTATUS = 18;\n+            VSWTC = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000008;\n+            INPCK = 0x0000010;\n+            ISTRIP = 0x0000020;\n+            INLCR = 0x0000040;\n+            IGNCR = 0x0000080;\n+            ICRNL = 0x0000100;\n+            IXON = 0x0000200;\n+            IXOFF = 0x0000400;\n+            IXANY = 0x0000800;\n+            IMAXBEL = 0x0002000;\n+\n+            OPOST = 0x0000001;\n+            ONLCR = 0x0000002;\n+            TABDLY = 0x0000004;\n+            TAB0 = 0x0000000;\n+            TAB3 = 0x0000004;\n+            ONOEOT = 0x0000008;\n+            OCRNL = 0x0000010;\n+            ONLRET = 0x0000040;\n+\n+            CIGNORE = 0x0000001;\n+            CSIZE = 0x0000300;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000100;\n+            CS7 = 0x0000200;\n+            CS8 = 0x0000300;\n+            CSTOPB = 0x0000400;\n+            CREAD = 0x0000800;\n+            PARENB = 0x0001000;\n+            PARODD = 0x0002000;\n+            HUPCL = 0x0004000;\n+            CLOCAL = 0x0008000;\n+\n+            ECHOKE = 0x0000001;\n+            ECHOE = 0x0000002;\n+            ECHOK = 0x0000004;\n+            ECHO = 0x0000008;\n+            ECHONL = 0x0000010;\n+            ECHOPRT = 0x0000020;\n+            ECHOCTL = 0x0000040;\n+            ISIG = 0x0000080;\n+            ICANON = 0x0000100;\n+            ALTWERASE = 0x000200;\n+            IEXTEN = 0x0000400;\n+            EXTPROC = 0x0000800;\n+            TOSTOP = 0x0400000;\n+            FLUSHO = 0x0800000;\n+            PENDIN = 0x2000000;\n+            NOFLSH = 0x8000000;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/CLibrary.java","additions":1170,"deletions":0,"binary":false,"changes":1170,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractPty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+class FfmNativePty extends AbstractPty {\n+    private final int master;\n+    private final int slave;\n+    private final int slaveOut;\n+    private final String name;\n+    private final FileDescriptor masterFD;\n+    private final FileDescriptor slaveFD;\n+    private final FileDescriptor slaveOutFD;\n+\n+    public FfmNativePty(TerminalProvider provider, SystemStream systemStream, int master, int slave, String name) {\n+        this(\n+                provider,\n+                systemStream,\n+                master,\n+                newDescriptor(master),\n+                slave,\n+                newDescriptor(slave),\n+                slave,\n+                newDescriptor(slave),\n+                name);\n+    }\n+\n+    public FfmNativePty(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            int master,\n+            FileDescriptor masterFD,\n+            int slave,\n+            FileDescriptor slaveFD,\n+            int slaveOut,\n+            FileDescriptor slaveOutFD,\n+            String name) {\n+        super(provider, systemStream);\n+        this.master = master;\n+        this.slave = slave;\n+        this.slaveOut = slaveOut;\n+        this.name = name;\n+        this.masterFD = masterFD;\n+        this.slaveFD = slaveFD;\n+        this.slaveOutFD = slaveOutFD;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (master > 0) {\n+            getMasterInput().close();\n+        }\n+        if (slave > 0) {\n+            getSlaveInput().close();\n+        }\n+    }\n+\n+    public int getMaster() {\n+        return master;\n+    }\n+\n+    public int getSlave() {\n+        return slave;\n+    }\n+\n+    public int getSlaveOut() {\n+        return slaveOut;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public FileDescriptor getMasterFD() {\n+        return masterFD;\n+    }\n+\n+    public FileDescriptor getSlaveFD() {\n+        return slaveFD;\n+    }\n+\n+    public FileDescriptor getSlaveOutFD() {\n+        return slaveOutFD;\n+    }\n+\n+    public InputStream getMasterInput() {\n+        return new FileInputStream(getMasterFD());\n+    }\n+\n+    public OutputStream getMasterOutput() {\n+        return new FileOutputStream(getMasterFD());\n+    }\n+\n+    protected InputStream doGetSlaveInput() {\n+        return new FileInputStream(getSlaveFD());\n+    }\n+\n+    public OutputStream getSlaveOutput() {\n+        return new FileOutputStream(getSlaveOutFD());\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        return CLibrary.getAttributes(slave);\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        CLibrary.setAttributes(slave, attr);\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        return CLibrary.getTerminalSize(slave);\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        CLibrary.setTerminalSize(slave, size);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"FfmNativePty[\" + getName() + \"]\";\n+    }\n+\n+    public static boolean isPosixSystemStream(SystemStream stream) {\n+        switch (stream) {\n+            case Input:\n+                return CLibrary.isTty(0);\n+            case Output:\n+                return CLibrary.isTty(1);\n+            case Error:\n+                return CLibrary.isTty(2);\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public static String posixSystemStreamName(SystemStream stream) {\n+        switch (stream) {\n+            case Input:\n+                return CLibrary.ttyName(0);\n+            case Output:\n+                return CLibrary.ttyName(1);\n+            case Error:\n+                return CLibrary.ttyName(2);\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public static int systemStreamWidth(SystemStream systemStream) {\n+        int fd = systemStream == SystemStream.Output ? 1 : 2;\n+        return CLibrary.getTerminalSize(fd).getColumns();\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/FfmNativePty.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class FfmTerminalProvider implements TerminalProvider {\n+\n+    public FfmTerminalProvider() {\n+        if (!FfmTerminalProvider.class.getModule().isNativeAccessEnabled()) {\n+            throw new UnsupportedOperationException(\n+                    \"Native access is not enabled for the current module: \" + FfmTerminalProvider.class.getModule());\n+        }\n+    }\n+\n+    @Override\n+    public String name() {\n+        return TerminalBuilder.PROP_PROVIDER_FFM;\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return NativeWinSysTerminal.createTerminal(\n+                    this, systemStream, name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, inputStreamWrapper);\n+        } else {\n+            Pty pty = new FfmNativePty(\n+                    this,\n+                    systemStream,\n+                    -1,\n+                    null,\n+                    0,\n+                    FileDescriptor.in,\n+                    systemStream == SystemStream.Output ? 1 : 2,\n+                    systemStream == SystemStream.Output ? FileDescriptor.out : FileDescriptor.err,\n+                    CLibrary.ttyName(0));\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        }\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        Pty pty = CLibrary.openpty(this, attributes, size);\n+        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(SystemStream stream) {\n+        if (OSUtils.IS_WINDOWS) {\n+            return isWindowsSystemStream(stream);\n+        } else {\n+            return isPosixSystemStream(stream);\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(SystemStream stream) {\n+        return NativeWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+    public boolean isPosixSystemStream(SystemStream stream) {\n+        return FfmNativePty.isPosixSystemStream(stream);\n+    }\n+\n+    @Override\n+    public String systemStreamName(SystemStream stream) {\n+        return FfmNativePty.posixSystemStreamName(stream);\n+    }\n+\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        return FfmNativePty.systemStreamWidth(stream);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n+    }\n+\n+    static VarHandle lookupVarHandle(MemoryLayout layout, PathElement... element) {\n+        VarHandle h = layout.varHandle(element);\n+\n+        \/\/ the last parameter of the VarHandle is additional offset, hardcode zero:\n+        h = MethodHandles.insertCoordinates(h, h.coordinateTypes().size() - 1, 0L);\n+\n+        return h;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/FfmTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,927 @@\n+\/*\n+ * Copyright (c) 2009-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+@SuppressWarnings({\"unused\", \"restricted\"})\n+final class Kernel32 {\n+\n+    public static final int FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;\n+\n+    public static final int INVALID_HANDLE_VALUE = -1;\n+    public static final int STD_INPUT_HANDLE = -10;\n+    public static final int STD_OUTPUT_HANDLE = -11;\n+    public static final int STD_ERROR_HANDLE = -12;\n+\n+    public static final int ENABLE_PROCESSED_INPUT = 0x0001;\n+    public static final int ENABLE_LINE_INPUT = 0x0002;\n+    public static final int ENABLE_ECHO_INPUT = 0x0004;\n+    public static final int ENABLE_WINDOW_INPUT = 0x0008;\n+    public static final int ENABLE_MOUSE_INPUT = 0x0010;\n+    public static final int ENABLE_INSERT_MODE = 0x0020;\n+    public static final int ENABLE_QUICK_EDIT_MODE = 0x0040;\n+    public static final int ENABLE_EXTENDED_FLAGS = 0x0080;\n+\n+    public static final int RIGHT_ALT_PRESSED = 0x0001;\n+    public static final int LEFT_ALT_PRESSED = 0x0002;\n+    public static final int RIGHT_CTRL_PRESSED = 0x0004;\n+    public static final int LEFT_CTRL_PRESSED = 0x0008;\n+    public static final int SHIFT_PRESSED = 0x0010;\n+\n+    public static final int FOREGROUND_BLUE = 0x0001;\n+    public static final int FOREGROUND_GREEN = 0x0002;\n+    public static final int FOREGROUND_RED = 0x0004;\n+    public static final int FOREGROUND_INTENSITY = 0x0008;\n+    public static final int BACKGROUND_BLUE = 0x0010;\n+    public static final int BACKGROUND_GREEN = 0x0020;\n+    public static final int BACKGROUND_RED = 0x0040;\n+    public static final int BACKGROUND_INTENSITY = 0x0080;\n+\n+    \/\/ Button state\n+    public static final int FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;\n+    public static final int RIGHTMOST_BUTTON_PRESSED = 0x0002;\n+    public static final int FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;\n+    public static final int FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;\n+    public static final int FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;\n+\n+    \/\/ Event flags\n+    public static final int MOUSE_MOVED = 0x0001;\n+    public static final int DOUBLE_CLICK = 0x0002;\n+    public static final int MOUSE_WHEELED = 0x0004;\n+    public static final int MOUSE_HWHEELED = 0x0008;\n+\n+    \/\/ Event types\n+    public static final short KEY_EVENT = 0x0001;\n+    public static final short MOUSE_EVENT = 0x0002;\n+    public static final short WINDOW_BUFFER_SIZE_EVENT = 0x0004;\n+    public static final short MENU_EVENT = 0x0008;\n+    public static final short FOCUS_EVENT = 0x0010;\n+\n+    public static int WaitForSingleObject(java.lang.foreign.MemorySegment hHandle, int dwMilliseconds) {\n+        MethodHandle mh$ = requireNonNull(WaitForSingleObject$MH, \"WaitForSingleObject\");\n+        try {\n+            return (int) mh$.invokeExact(hHandle, dwMilliseconds);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static java.lang.foreign.MemorySegment GetStdHandle(int nStdHandle) {\n+        MethodHandle mh$ = requireNonNull(GetStdHandle$MH, \"GetStdHandle\");\n+        try {\n+            return (java.lang.foreign.MemorySegment) mh$.invokeExact(nStdHandle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FormatMessageW(\n+            int dwFlags,\n+            java.lang.foreign.MemorySegment lpSource,\n+            int dwMessageId,\n+            int dwLanguageId,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nSize,\n+            java.lang.foreign.MemorySegment Arguments) {\n+        MethodHandle mh$ = requireNonNull(FormatMessageW$MH, \"FormatMessageW\");\n+        try {\n+            return (int) mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleTextAttribute(java.lang.foreign.MemorySegment hConsoleOutput, short wAttributes) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleTextAttribute$MH, \"SetConsoleTextAttribute\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, wAttributes);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleMode(java.lang.foreign.MemorySegment hConsoleHandle, int dwMode) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleMode$MH, \"SetConsoleMode\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleHandle, dwMode);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetConsoleMode(\n+            java.lang.foreign.MemorySegment hConsoleHandle, java.lang.foreign.MemorySegment lpMode) {\n+        MethodHandle mh$ = requireNonNull(GetConsoleMode$MH, \"GetConsoleMode\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleHandle, lpMode);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleTitleW(java.lang.foreign.MemorySegment lpConsoleTitle) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleTitleW$MH, \"SetConsoleTitleW\");\n+        try {\n+            return (int) mh$.invokeExact(lpConsoleTitle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleCursorPosition(java.lang.foreign.MemorySegment hConsoleOutput, COORD dwCursorPosition) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleCursorPosition$MH, \"SetConsoleCursorPosition\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, dwCursorPosition.seg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FillConsoleOutputCharacterW(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            char cCharacter,\n+            int nLength,\n+            COORD dwWriteCoord,\n+            java.lang.foreign.MemorySegment lpNumberOfCharsWritten) {\n+        MethodHandle mh$ = requireNonNull(FillConsoleOutputCharacterW$MH, \"FillConsoleOutputCharacterW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord.seg, lpNumberOfCharsWritten);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FillConsoleOutputAttribute(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            short wAttribute,\n+            int nLength,\n+            COORD dwWriteCoord,\n+            java.lang.foreign.MemorySegment lpNumberOfAttrsWritten) {\n+        MethodHandle mh$ = requireNonNull(FillConsoleOutputAttribute$MH, \"FillConsoleOutputAttribute\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, wAttribute, nLength, dwWriteCoord.seg, lpNumberOfAttrsWritten);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int WriteConsoleW(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nNumberOfCharsToWrite,\n+            java.lang.foreign.MemorySegment lpNumberOfCharsWritten,\n+            java.lang.foreign.MemorySegment lpReserved) {\n+        MethodHandle mh$ = requireNonNull(WriteConsoleW$MH, \"WriteConsoleW\");\n+        try {\n+            return (int) mh$.invokeExact(\n+                    hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int ReadConsoleInputW(\n+            java.lang.foreign.MemorySegment hConsoleInput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nLength,\n+            java.lang.foreign.MemorySegment lpNumberOfEventsRead) {\n+        MethodHandle mh$ = requireNonNull(ReadConsoleInputW$MH, \"ReadConsoleInputW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int PeekConsoleInputW(\n+            java.lang.foreign.MemorySegment hConsoleInput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nLength,\n+            java.lang.foreign.MemorySegment lpNumberOfEventsRead) {\n+        MethodHandle mh$ = requireNonNull(PeekConsoleInputW$MH, \"PeekConsoleInputW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetConsoleScreenBufferInfo(\n+            java.lang.foreign.MemorySegment hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo) {\n+        MethodHandle mh$ = requireNonNull(GetConsoleScreenBufferInfo$MH, \"GetConsoleScreenBufferInfo\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfo.seg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int ScrollConsoleScreenBuffer(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            SMALL_RECT lpScrollRectangle,\n+            SMALL_RECT lpClipRectangle,\n+            COORD dwDestinationOrigin,\n+            CHAR_INFO lpFill) {\n+        MethodHandle mh$ = requireNonNull(ScrollConsoleScreenBufferW$MH, \"ScrollConsoleScreenBuffer\");\n+        try {\n+            return (int)\n+                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetLastError() {\n+        MethodHandle mh$ = requireNonNull(GetLastError$MH, \"GetLastError\");\n+        try {\n+            return (int) mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetFileType(java.lang.foreign.MemorySegment hFile) {\n+        MethodHandle mh$ = requireNonNull(GetFileType$MH, \"GetFileType\");\n+        try {\n+            return (int) mh$.invokeExact(hFile);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static java.lang.foreign.MemorySegment _get_osfhandle(int fd) {\n+        MethodHandle mh$ = requireNonNull(_get_osfhandle$MH, \"_get_osfhandle\");\n+        try {\n+            return (java.lang.foreign.MemorySegment) mh$.invokeExact(fd);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static INPUT_RECORD[] readConsoleInputHelper(java.lang.foreign.MemorySegment handle, int count, boolean peek)\n+            throws IOException {\n+        return readConsoleInputHelper(java.lang.foreign.Arena.ofAuto(), handle, count, peek);\n+    }\n+\n+    public static INPUT_RECORD[] readConsoleInputHelper(\n+            java.lang.foreign.Arena arena, java.lang.foreign.MemorySegment handle, int count, boolean peek)\n+            throws IOException {\n+        java.lang.foreign.MemorySegment inputRecordPtr = arena.allocate(INPUT_RECORD.LAYOUT, count);\n+        java.lang.foreign.MemorySegment length = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT, 1);\n+        int res = peek\n+                ? PeekConsoleInputW(handle, inputRecordPtr, count, length)\n+                : ReadConsoleInputW(handle, inputRecordPtr, count, length);\n+        if (res == 0) {\n+            throw new IOException(\"ReadConsoleInputW failed: \" + getLastErrorMessage());\n+        }\n+        int len = length.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+        return inputRecordPtr\n+                .elements(INPUT_RECORD.LAYOUT)\n+                .map(INPUT_RECORD::new)\n+                .limit(len)\n+                .toArray(INPUT_RECORD[]::new);\n+    }\n+\n+    public static String getLastErrorMessage() {\n+        int errorCode = GetLastError();\n+        return getErrorMessage(errorCode);\n+    }\n+\n+    public static String getErrorMessage(int errorCode) {\n+        int bufferSize = 160;\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment data = arena.allocate(bufferSize);\n+            FormatMessageW(\n+                    FORMAT_MESSAGE_FROM_SYSTEM,\n+                    java.lang.foreign.MemorySegment.NULL,\n+                    errorCode,\n+                    0,\n+                    data,\n+                    bufferSize,\n+                    java.lang.foreign.MemorySegment.NULL);\n+            return new String(data.toArray(java.lang.foreign.ValueLayout.JAVA_BYTE), StandardCharsets.UTF_16LE).trim();\n+        }\n+    }\n+\n+    private static final java.lang.foreign.SymbolLookup SYMBOL_LOOKUP;\n+\n+    static {\n+        System.loadLibrary(\"msvcrt\");\n+        System.loadLibrary(\"Kernel32\");\n+        SYMBOL_LOOKUP = java.lang.foreign.SymbolLookup.loaderLookup();\n+    }\n+\n+    static MethodHandle downcallHandle(String name, java.lang.foreign.FunctionDescriptor fdesc) {\n+        return SYMBOL_LOOKUP\n+                .find(name)\n+                .map(addr -> java.lang.foreign.Linker.nativeLinker().downcallHandle(addr, fdesc))\n+                .orElse(null);\n+    }\n+\n+    static final java.lang.foreign.ValueLayout.OfBoolean C_BOOL$LAYOUT = java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+    static final java.lang.foreign.ValueLayout.OfByte C_CHAR$LAYOUT = java.lang.foreign.ValueLayout.JAVA_BYTE;\n+    static final java.lang.foreign.ValueLayout.OfChar C_WCHAR$LAYOUT = java.lang.foreign.ValueLayout.JAVA_CHAR;\n+    static final java.lang.foreign.ValueLayout.OfShort C_SHORT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_SHORT;\n+    static final java.lang.foreign.ValueLayout.OfShort C_WORD$LAYOUT = java.lang.foreign.ValueLayout.JAVA_SHORT;\n+    static final java.lang.foreign.ValueLayout.OfInt C_DWORD$LAYOUT = java.lang.foreign.ValueLayout.JAVA_INT;\n+    static final java.lang.foreign.ValueLayout.OfInt C_INT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_INT;\n+    static final java.lang.foreign.ValueLayout.OfLong C_LONG$LAYOUT = java.lang.foreign.ValueLayout.JAVA_LONG;\n+    static final java.lang.foreign.ValueLayout.OfLong C_LONG_LONG$LAYOUT = java.lang.foreign.ValueLayout.JAVA_LONG;\n+    static final java.lang.foreign.ValueLayout.OfFloat C_FLOAT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+    static final java.lang.foreign.ValueLayout.OfDouble C_DOUBLE$LAYOUT = java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+    static final java.lang.foreign.AddressLayout C_POINTER$LAYOUT = java.lang.foreign.ValueLayout.ADDRESS;\n+\n+    static final MethodHandle WaitForSingleObject$MH = downcallHandle(\n+            \"WaitForSingleObject\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle GetStdHandle$MH =\n+            downcallHandle(\"GetStdHandle\", java.lang.foreign.FunctionDescriptor.of(C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle FormatMessageW$MH = downcallHandle(\n+            \"FormatMessageW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT));\n+    static final MethodHandle SetConsoleTextAttribute$MH = downcallHandle(\n+            \"SetConsoleTextAttribute\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_SHORT$LAYOUT));\n+    static final MethodHandle SetConsoleMode$MH = downcallHandle(\n+            \"SetConsoleMode\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle GetConsoleMode$MH = downcallHandle(\n+            \"GetConsoleMode\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle SetConsoleTitleW$MH =\n+            downcallHandle(\"SetConsoleTitleW\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle SetConsoleCursorPosition$MH = downcallHandle(\n+            \"SetConsoleCursorPosition\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, COORD.LAYOUT));\n+    static final MethodHandle FillConsoleOutputCharacterW$MH = downcallHandle(\n+            \"FillConsoleOutputCharacterW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_WCHAR$LAYOUT, C_INT$LAYOUT, COORD.LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle FillConsoleOutputAttribute$MH = downcallHandle(\n+            \"FillConsoleOutputAttribute\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_SHORT$LAYOUT, C_INT$LAYOUT, COORD.LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle WriteConsoleW$MH = downcallHandle(\n+            \"WriteConsoleW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT));\n+\n+    static final MethodHandle ReadConsoleInputW$MH = downcallHandle(\n+            \"ReadConsoleInputW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle PeekConsoleInputW$MH = downcallHandle(\n+            \"PeekConsoleInputW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle GetConsoleScreenBufferInfo$MH = downcallHandle(\n+            \"GetConsoleScreenBufferInfo\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle ScrollConsoleScreenBufferW$MH = downcallHandle(\n+            \"ScrollConsoleScreenBufferW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    COORD.LAYOUT,\n+                    C_POINTER$LAYOUT));\n+    static final MethodHandle GetLastError$MH =\n+            downcallHandle(\"GetLastError\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT));\n+    static final MethodHandle GetFileType$MH =\n+            downcallHandle(\"GetFileType\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle _get_osfhandle$MH =\n+            downcallHandle(\"_get_osfhandle\", java.lang.foreign.FunctionDescriptor.of(C_POINTER$LAYOUT, C_INT$LAYOUT));\n+\n+    public static final class INPUT_RECORD {\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"EventType\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT, \/\/ padding\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                KEY_EVENT_RECORD.LAYOUT.withName(\"KeyEvent\"),\n+                                MOUSE_EVENT_RECORD.LAYOUT.withName(\"MouseEvent\"),\n+                                WINDOW_BUFFER_SIZE_RECORD.LAYOUT.withName(\"WindowBufferSizeEvent\"),\n+                                MENU_EVENT_RECORD.LAYOUT.withName(\"MenuEvent\"),\n+                                FOCUS_EVENT_RECORD.LAYOUT.withName(\"FocusEvent\"))\n+                        .withName(\"Event\"));\n+        static final VarHandle EventType$VH = varHandle(LAYOUT, \"EventType\");\n+        static final long Event$OFFSET = byteOffset(LAYOUT, \"Event\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public INPUT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public INPUT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public INPUT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public short eventType() {\n+            return (short) EventType$VH.get(seg);\n+        }\n+\n+        public KEY_EVENT_RECORD keyEvent() {\n+            return new KEY_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+\n+        public MOUSE_EVENT_RECORD mouseEvent() {\n+            return new MOUSE_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+\n+        public FOCUS_EVENT_RECORD focusEvent() {\n+            return new FOCUS_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+    }\n+\n+    public static final class MENU_EVENT_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_DWORD$LAYOUT.withName(\"dwCommandId\"));\n+        static final VarHandle COMMAND_ID = varHandle(LAYOUT, \"dwCommandId\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public MENU_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public MENU_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public MENU_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public int commandId() {\n+            return (int) MENU_EVENT_RECORD.COMMAND_ID.get(seg);\n+        }\n+\n+        public void commandId(int commandId) {\n+            MENU_EVENT_RECORD.COMMAND_ID.set(seg, commandId);\n+        }\n+    }\n+\n+    public static final class FOCUS_EVENT_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_INT$LAYOUT.withName(\"bSetFocus\"));\n+        static final VarHandle SET_FOCUS = varHandle(LAYOUT, \"bSetFocus\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public FOCUS_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = Objects.requireNonNull(seg);\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public boolean setFocus() {\n+            return ((int) FOCUS_EVENT_RECORD.SET_FOCUS.get(seg) != 0);\n+        }\n+\n+        public void setFocus(boolean setFocus) {\n+            FOCUS_EVENT_RECORD.SET_FOCUS.set(seg, setFocus ? 1 : 0);\n+        }\n+    }\n+\n+    public static final class WINDOW_BUFFER_SIZE_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(COORD.LAYOUT.withName(\"size\"));\n+        static final long SIZE_OFFSET = byteOffset(LAYOUT, \"size\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public WINDOW_BUFFER_SIZE_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public WINDOW_BUFFER_SIZE_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public WINDOW_BUFFER_SIZE_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD size() {\n+            return new COORD(seg, SIZE_OFFSET);\n+        }\n+\n+        public String toString() {\n+            return \"WINDOW_BUFFER_SIZE_RECORD{size=\" + this.size() + '}';\n+        }\n+    }\n+\n+    public static final class MOUSE_EVENT_RECORD {\n+\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                COORD.LAYOUT.withName(\"dwMousePosition\"),\n+                C_DWORD$LAYOUT.withName(\"dwButtonState\"),\n+                C_DWORD$LAYOUT.withName(\"dwControlKeyState\"),\n+                C_DWORD$LAYOUT.withName(\"dwEventFlags\"));\n+        static final long MOUSE_POSITION_OFFSET = byteOffset(LAYOUT, \"dwMousePosition\");\n+        static final VarHandle BUTTON_STATE = varHandle(LAYOUT, \"dwButtonState\");\n+        static final VarHandle CONTROL_KEY_STATE = varHandle(LAYOUT, \"dwControlKeyState\");\n+        static final VarHandle EVENT_FLAGS = varHandle(LAYOUT, \"dwEventFlags\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public MOUSE_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = Objects.requireNonNull(seg);\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public COORD mousePosition() {\n+            return new COORD(seg, MOUSE_POSITION_OFFSET);\n+        }\n+\n+        public int buttonState() {\n+            return (int) BUTTON_STATE.get(seg);\n+        }\n+\n+        public int controlKeyState() {\n+            return (int) CONTROL_KEY_STATE.get(seg);\n+        }\n+\n+        public int eventFlags() {\n+            return (int) EVENT_FLAGS.get(seg);\n+        }\n+\n+        public String toString() {\n+            return \"MOUSE_EVENT_RECORD{mousePosition=\" + mousePosition() + \", buttonState=\" + buttonState()\n+                    + \", controlKeyState=\" + controlKeyState() + \", eventFlags=\" + eventFlags() + '}';\n+        }\n+    }\n+\n+    public static final class KEY_EVENT_RECORD {\n+\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.ValueLayout.JAVA_INT.withName(\"bKeyDown\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wRepeatCount\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wVirtualKeyCode\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wVirtualScanCode\"),\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                java.lang.foreign.ValueLayout.JAVA_CHAR.withName(\"UnicodeChar\"),\n+                                java.lang.foreign.ValueLayout.JAVA_BYTE.withName(\"AsciiChar\"))\n+                        .withName(\"uChar\"),\n+                java.lang.foreign.ValueLayout.JAVA_INT.withName(\"dwControlKeyState\"));\n+        static final VarHandle bKeyDown$VH = varHandle(LAYOUT, \"bKeyDown\");\n+        static final VarHandle wRepeatCount$VH = varHandle(LAYOUT, \"wRepeatCount\");\n+        static final VarHandle wVirtualKeyCode$VH = varHandle(LAYOUT, \"wVirtualKeyCode\");\n+        static final VarHandle wVirtualScanCode$VH = varHandle(LAYOUT, \"wVirtualScanCode\");\n+        static final VarHandle UnicodeChar$VH = varHandle(LAYOUT, \"uChar\", \"UnicodeChar\");\n+        static final VarHandle AsciiChar$VH = varHandle(LAYOUT, \"uChar\", \"AsciiChar\");\n+        static final VarHandle dwControlKeyState$VH = varHandle(LAYOUT, \"dwControlKeyState\");\n+\n+        final java.lang.foreign.MemorySegment seg;\n+\n+        public KEY_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public boolean keyDown() {\n+            return ((int) bKeyDown$VH.get(seg)) != 0;\n+        }\n+\n+        public int repeatCount() {\n+            return (int) wRepeatCount$VH.get(seg);\n+        }\n+\n+        public short keyCode() {\n+            return (short) wVirtualKeyCode$VH.get(seg);\n+        }\n+\n+        public short scanCode() {\n+            return (short) wVirtualScanCode$VH.get(seg);\n+        }\n+\n+        public char uchar() {\n+            return (char) UnicodeChar$VH.get(seg);\n+        }\n+\n+        public int controlKeyState() {\n+            return (int) dwControlKeyState$VH.get(seg);\n+        }\n+\n+        public String toString() {\n+            return \"KEY_EVENT_RECORD{keyDown=\" + this.keyDown() + \", repeatCount=\" + this.repeatCount() + \", keyCode=\"\n+                    + this.keyCode() + \", scanCode=\" + this.scanCode() + \", uchar=\" + this.uchar()\n+                    + \", controlKeyState=\"\n+                    + this.controlKeyState() + '}';\n+        }\n+    }\n+\n+    public static final class CHAR_INFO {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                C_WCHAR$LAYOUT.withName(\"UnicodeChar\"), C_CHAR$LAYOUT.withName(\"AsciiChar\"))\n+                        .withName(\"Char\"),\n+                C_WORD$LAYOUT.withName(\"Attributes\"));\n+        static final VarHandle UnicodeChar$VH = varHandle(LAYOUT, \"Char\", \"UnicodeChar\");\n+        static final VarHandle Attributes$VH = varHandle(LAYOUT, \"Attributes\");\n+\n+        final java.lang.foreign.MemorySegment seg;\n+\n+        public CHAR_INFO() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.Arena arena, char c, short a) {\n+            this(arena);\n+            UnicodeChar$VH.set(seg, c);\n+            Attributes$VH.set(seg, a);\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public char unicodeChar() {\n+            return (char) UnicodeChar$VH.get(seg);\n+        }\n+    }\n+\n+    public static final class CONSOLE_SCREEN_BUFFER_INFO {\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                COORD.LAYOUT.withName(\"dwSize\"),\n+                COORD.LAYOUT.withName(\"dwCursorPosition\"),\n+                C_WORD$LAYOUT.withName(\"wAttributes\"),\n+                SMALL_RECT.LAYOUT.withName(\"srWindow\"),\n+                COORD.LAYOUT.withName(\"dwMaximumWindowSize\"));\n+        static final long dwSize$OFFSET = byteOffset(LAYOUT, \"dwSize\");\n+        static final long dwCursorPosition$OFFSET = byteOffset(LAYOUT, \"dwCursorPosition\");\n+        static final VarHandle wAttributes$VH = varHandle(LAYOUT, \"wAttributes\");\n+        static final long srWindow$OFFSET = byteOffset(LAYOUT, \"srWindow\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD size() {\n+            return new COORD(seg, dwSize$OFFSET);\n+        }\n+\n+        public COORD cursorPosition() {\n+            return new COORD(seg, dwCursorPosition$OFFSET);\n+        }\n+\n+        public short attributes() {\n+            return (short) wAttributes$VH.get(seg);\n+        }\n+\n+        public SMALL_RECT window() {\n+            return new SMALL_RECT(seg, srWindow$OFFSET);\n+        }\n+\n+        public int windowWidth() {\n+            return this.window().width() + 1;\n+        }\n+\n+        public int windowHeight() {\n+            return this.window().height() + 1;\n+        }\n+\n+        public void attributes(short attr) {\n+            wAttributes$VH.set(seg, attr);\n+        }\n+    }\n+\n+    public static final class COORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_SHORT$LAYOUT.withName(\"x\"), C_SHORT$LAYOUT.withName(\"y\"));\n+        static final VarHandle x$VH = varHandle(LAYOUT, \"x\");\n+        static final VarHandle y$VH = varHandle(LAYOUT, \"y\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public COORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public COORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public COORD(java.lang.foreign.Arena arena, short x, short y) {\n+            this(arena.allocate(LAYOUT));\n+            x(x);\n+            y(y);\n+        }\n+\n+        public COORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public short x() {\n+            return (short) COORD.x$VH.get(seg);\n+        }\n+\n+        public void x(short x) {\n+            COORD.x$VH.set(seg, x);\n+        }\n+\n+        public short y() {\n+            return (short) COORD.y$VH.get(seg);\n+        }\n+\n+        public void y(short y) {\n+            COORD.y$VH.set(seg, y);\n+        }\n+\n+        public COORD copy(java.lang.foreign.Arena arena) {\n+            return new COORD(arena.allocate(LAYOUT).copyFrom(seg));\n+        }\n+    }\n+\n+    public static final class SMALL_RECT {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                C_SHORT$LAYOUT.withName(\"Left\"),\n+                C_SHORT$LAYOUT.withName(\"Top\"),\n+                C_SHORT$LAYOUT.withName(\"Right\"),\n+                C_SHORT$LAYOUT.withName(\"Bottom\"));\n+        static final VarHandle Left$VH = varHandle(LAYOUT, \"Left\");\n+        static final VarHandle Top$VH = varHandle(LAYOUT, \"Top\");\n+        static final VarHandle Right$VH = varHandle(LAYOUT, \"Right\");\n+        static final VarHandle Bottom$VH = varHandle(LAYOUT, \"Bottom\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public SMALL_RECT() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.Arena arena, SMALL_RECT rect) {\n+            this(arena);\n+            left(rect.left());\n+            right(rect.right());\n+            top(rect.top());\n+            bottom(rect.bottom());\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.MemorySegment seg, long offset) {\n+            this(seg.asSlice(offset, LAYOUT.byteSize()));\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public short left() {\n+            return (short) Left$VH.get(seg);\n+        }\n+\n+        public short top() {\n+            return (short) Top$VH.get(seg);\n+        }\n+\n+        public short right() {\n+            return (short) Right$VH.get(seg);\n+        }\n+\n+        public short bottom() {\n+            return (short) Bottom$VH.get(seg);\n+        }\n+\n+        public short width() {\n+            return (short) (this.right() - this.left());\n+        }\n+\n+        public short height() {\n+            return (short) (this.bottom() - this.top());\n+        }\n+\n+        public void left(short l) {\n+            Left$VH.set(seg, l);\n+        }\n+\n+        public void top(short t) {\n+            Top$VH.set(seg, t);\n+        }\n+\n+        public void right(short r) {\n+            Right$VH.set(seg, r);\n+        }\n+\n+        public void bottom(short b) {\n+            Bottom$VH.set(seg, b);\n+        }\n+\n+        public SMALL_RECT copy(java.lang.foreign.Arena arena) {\n+            return new SMALL_RECT(arena.allocate(LAYOUT).copyFrom(seg));\n+        }\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    static VarHandle varHandle(java.lang.foreign.MemoryLayout layout, String name) {\n+        return FfmTerminalProvider.lookupVarHandle(\n+                layout, java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+\n+    static VarHandle varHandle(java.lang.foreign.MemoryLayout layout, String e1, String name) {\n+        return FfmTerminalProvider.lookupVarHandle(\n+                layout,\n+                java.lang.foreign.MemoryLayout.PathElement.groupElement(e1),\n+                java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+\n+    static long byteOffset(java.lang.foreign.MemoryLayout layout, String name) {\n+        return layout.byteOffset(java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/Kernel32.java","additions":927,"deletions":0,"binary":false,"changes":927,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsConsoleWriter;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.WriteConsoleW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+\n+class NativeWinConsoleWriter extends AbstractWindowsConsoleWriter {\n+\n+    private final java.lang.foreign.MemorySegment console = GetStdHandle(STD_OUTPUT_HANDLE);\n+\n+    @Override\n+    protected void writeConsole(char[] text, int len) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment txt = arena.allocateFrom(ValueLayout.JAVA_CHAR, text);\n+            if (WriteConsoleW(console, txt, len, MemorySegment.NULL, MemorySegment.NULL) == 0) {\n+                throw new IOException(\"Failed to write to console: \" + getLastErrorMessage());\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/NativeWinConsoleWriter.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+import java.util.function.IntConsumer;\n+\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.*;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleMode;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleScreenBufferInfo;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.INPUT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.INVALID_HANDLE_VALUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.KEY_EVENT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.MOUSE_EVENT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_ERROR_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_INPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleMode;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.WaitForSingleObject;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.readConsoleInputHelper;\n+\n+public class NativeWinSysTerminal extends AbstractWindowsTerminal<java.lang.foreign.MemorySegment> {\n+\n+    public static NativeWinSysTerminal createTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            boolean paused,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            \/\/ Get input console mode\n+            java.lang.foreign.MemorySegment consoleIn = GetStdHandle(STD_INPUT_HANDLE);\n+            java.lang.foreign.MemorySegment inMode = allocateInt(arena);\n+            if (GetConsoleMode(consoleIn, inMode) == 0) {\n+                throw new IOException(\"Failed to get console mode: \" + getLastErrorMessage());\n+            }\n+            \/\/ Get output console and mode\n+            java.lang.foreign.MemorySegment console;\n+            switch (systemStream) {\n+                case Output:\n+                    console = GetStdHandle(STD_OUTPUT_HANDLE);\n+                    break;\n+                case Error:\n+                    console = GetStdHandle(STD_ERROR_HANDLE);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported stream for console: \" + systemStream);\n+            }\n+            java.lang.foreign.MemorySegment outMode = allocateInt(arena);\n+            if (GetConsoleMode(console, outMode) == 0) {\n+                throw new IOException(\"Failed to get console mode: \" + getLastErrorMessage());\n+            }\n+            \/\/ Create writer\n+            Writer writer;\n+            if (ansiPassThrough) {\n+                type = type != null ? type : OSUtils.IS_CONEMU ? TYPE_WINDOWS_CONEMU : TYPE_WINDOWS;\n+                writer = new NativeWinConsoleWriter();\n+            } else {\n+                int m = inMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+                if (enableVtp(console, m)) {\n+                    type = type != null ? type : TYPE_WINDOWS_VTP;\n+                    writer = new NativeWinConsoleWriter();\n+                } else if (OSUtils.IS_CONEMU) {\n+                    type = type != null ? type : TYPE_WINDOWS_CONEMU;\n+                    writer = new NativeWinConsoleWriter();\n+                } else {\n+                    type = type != null ? type : TYPE_WINDOWS;\n+                    writer = new WindowsAnsiWriter(new BufferedWriter(new NativeWinConsoleWriter()));\n+                }\n+            }\n+            \/\/ Create terminal\n+            NativeWinSysTerminal terminal = new NativeWinSysTerminal(\n+                    provider,\n+                    systemStream,\n+                    writer,\n+                    name,\n+                    type,\n+                    encoding,\n+                    nativeSignals,\n+                    signalHandler,\n+                    consoleIn,\n+                    inMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0),\n+                    console,\n+                    outMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0),\n+                    inputStreamWrapper);\n+            \/\/ Start input pump thread\n+            if (!paused) {\n+                terminal.resume();\n+            }\n+            return terminal;\n+        }\n+    }\n+\n+    private static boolean enableVtp(java.lang.foreign.MemorySegment console, int m) {\n+        return SetConsoleMode(console, m | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0;\n+    }\n+\n+    public static boolean isWindowsSystemStream(SystemStream stream) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment console;\n+            java.lang.foreign.MemorySegment mode = allocateInt(arena);\n+            switch (stream) {\n+                case Input:\n+                    console = GetStdHandle(STD_INPUT_HANDLE);\n+                    break;\n+                case Output:\n+                    console = GetStdHandle(STD_OUTPUT_HANDLE);\n+                    break;\n+                case Error:\n+                    console = GetStdHandle(STD_ERROR_HANDLE);\n+                    break;\n+                default:\n+                    return false;\n+            }\n+            return GetConsoleMode(console, mode) != 0;\n+        }\n+    }\n+\n+    private static java.lang.foreign.MemorySegment allocateInt(java.lang.foreign.Arena arena) {\n+        return arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+    }\n+\n+    NativeWinSysTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            Writer writer,\n+            String name,\n+            String type,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            java.lang.foreign.MemorySegment inConsole,\n+            int inConsoleMode,\n+            java.lang.foreign.MemorySegment outConsole,\n+            int outConsoleMode,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        super(\n+                provider,\n+                systemStream,\n+                writer,\n+                name,\n+                type,\n+                encoding,\n+                nativeSignals,\n+                signalHandler,\n+                inConsole,\n+                inConsoleMode,\n+                outConsole,\n+                outConsoleMode,\n+                inputStreamWrapper);\n+    }\n+\n+    @Override\n+    protected int getConsoleMode(java.lang.foreign.MemorySegment console) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment mode = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            if (GetConsoleMode(console, mode) == 0) {\n+                return -1;\n+            }\n+            return mode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+        }\n+    }\n+\n+    @Override\n+    protected void setConsoleMode(java.lang.foreign.MemorySegment console, int mode) {\n+        SetConsoleMode(console, mode);\n+    }\n+\n+    public Size getSize() {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            GetConsoleScreenBufferInfo(outConsole, info);\n+            return new Size(info.windowWidth(), info.windowHeight());\n+        }\n+    }\n+\n+    @Override\n+    public Size getBufferSize() {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            GetConsoleScreenBufferInfo(outConsole, info);\n+            return new Size(info.size().x(), info.size().y());\n+        }\n+    }\n+\n+    protected boolean processConsoleInput() throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            INPUT_RECORD[] events;\n+            if (inConsole != null\n+                    && inConsole.address() != INVALID_HANDLE_VALUE\n+                    && WaitForSingleObject(inConsole, 100) == 0) {\n+                events = readConsoleInputHelper(arena, inConsole, 1, false);\n+            } else {\n+                return false;\n+            }\n+\n+            boolean flush = false;\n+            for (INPUT_RECORD event : events) {\n+                int eventType = event.eventType();\n+                if (eventType == KEY_EVENT) {\n+                    KEY_EVENT_RECORD keyEvent = event.keyEvent();\n+                    processKeyEvent(\n+                            keyEvent.keyDown(), keyEvent.keyCode(), keyEvent.uchar(), keyEvent.controlKeyState());\n+                    flush = true;\n+                } else if (eventType == WINDOW_BUFFER_SIZE_EVENT) {\n+                    raise(Signal.WINCH);\n+                } else if (eventType == MOUSE_EVENT) {\n+                    processMouseEvent(event.mouseEvent());\n+                    flush = true;\n+                } else if (eventType == FOCUS_EVENT) {\n+                    processFocusEvent(event.focusEvent().setFocus());\n+                }\n+            }\n+\n+            return flush;\n+        }\n+    }\n+\n+    private final char[] focus = new char[] {'\\033', '[', ' '};\n+\n+    private void processFocusEvent(boolean hasFocus) throws IOException {\n+        if (focusTracking) {\n+            focus[2] = hasFocus ? 'I' : 'O';\n+            slaveInputPipe.write(focus);\n+        }\n+    }\n+\n+    private final char[] mouse = new char[] {'\\033', '[', 'M', ' ', ' ', ' '};\n+\n+    private void processMouseEvent(MOUSE_EVENT_RECORD mouseEvent) throws IOException {\n+        int dwEventFlags = mouseEvent.eventFlags();\n+        int dwButtonState = mouseEvent.buttonState();\n+        if (tracking == MouseTracking.Off\n+                || tracking == MouseTracking.Normal && dwEventFlags == MOUSE_MOVED\n+                || tracking == MouseTracking.Button && dwEventFlags == MOUSE_MOVED && dwButtonState == 0) {\n+            return;\n+        }\n+        int cb = 0;\n+        dwEventFlags &= ~DOUBLE_CLICK; \/\/ Treat double-clicks as normal\n+        if (dwEventFlags == MOUSE_WHEELED) {\n+            cb |= 64;\n+            if ((dwButtonState >> 16) < 0) {\n+                cb |= 1;\n+            }\n+        } else if (dwEventFlags == MOUSE_HWHEELED) {\n+            return;\n+        } else if ((dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED) != 0) {\n+            cb |= 0x00;\n+        } else if ((dwButtonState & RIGHTMOST_BUTTON_PRESSED) != 0) {\n+            cb |= 0x01;\n+        } else if ((dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED) != 0) {\n+            cb |= 0x02;\n+        } else {\n+            cb |= 0x03;\n+        }\n+        int cx = mouseEvent.mousePosition().x();\n+        int cy = mouseEvent.mousePosition().y();\n+        mouse[3] = (char) (' ' + cb);\n+        mouse[4] = (char) (' ' + cx + 1);\n+        mouse[5] = (char) (' ' + cy + 1);\n+        slaveInputPipe.write(mouse);\n+    }\n+\n+    @Override\n+    public Cursor getCursorPosition(IntConsumer discarded) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            if (GetConsoleScreenBufferInfo(outConsole, info) == 0) {\n+                throw new IOError(new IOException(\"Could not get the cursor position: \" + getLastErrorMessage()));\n+            }\n+            return new Cursor(info.cursorPosition().x(), info.cursorPosition().y());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/NativeWinSysTerminal.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import jdk.internal.org.jline.utils.AnsiWriter;\n+import jdk.internal.org.jline.utils.Colors;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_BLUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_GREEN;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_INTENSITY;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_RED;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.CHAR_INFO;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.CONSOLE_SCREEN_BUFFER_INFO;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.COORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_BLUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_GREEN;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_INTENSITY;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_RED;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FillConsoleOutputAttribute;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FillConsoleOutputCharacterW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleScreenBufferInfo;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SMALL_RECT;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.ScrollConsoleScreenBuffer;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleCursorPosition;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleTextAttribute;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleTitleW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+\n+class WindowsAnsiWriter extends AnsiWriter {\n+\n+    private static final java.lang.foreign.MemorySegment console = GetStdHandle(STD_OUTPUT_HANDLE);\n+\n+    private static final short FOREGROUND_BLACK = 0;\n+    private static final short FOREGROUND_YELLOW = (short) (FOREGROUND_RED | FOREGROUND_GREEN);\n+    private static final short FOREGROUND_MAGENTA = (short) (FOREGROUND_BLUE | FOREGROUND_RED);\n+    private static final short FOREGROUND_CYAN = (short) (FOREGROUND_BLUE | FOREGROUND_GREEN);\n+    private static final short FOREGROUND_WHITE = (short) (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\n+\n+    private static final short BACKGROUND_BLACK = 0;\n+    private static final short BACKGROUND_YELLOW = (short) (BACKGROUND_RED | BACKGROUND_GREEN);\n+    private static final short BACKGROUND_MAGENTA = (short) (BACKGROUND_BLUE | BACKGROUND_RED);\n+    private static final short BACKGROUND_CYAN = (short) (BACKGROUND_BLUE | BACKGROUND_GREEN);\n+    private static final short BACKGROUND_WHITE = (short) (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE);\n+\n+    private static final short[] ANSI_FOREGROUND_COLOR_MAP = {\n+        FOREGROUND_BLACK,\n+        FOREGROUND_RED,\n+        FOREGROUND_GREEN,\n+        FOREGROUND_YELLOW,\n+        FOREGROUND_BLUE,\n+        FOREGROUND_MAGENTA,\n+        FOREGROUND_CYAN,\n+        FOREGROUND_WHITE,\n+    };\n+\n+    private static final short[] ANSI_BACKGROUND_COLOR_MAP = {\n+        BACKGROUND_BLACK,\n+        BACKGROUND_RED,\n+        BACKGROUND_GREEN,\n+        BACKGROUND_YELLOW,\n+        BACKGROUND_BLUE,\n+        BACKGROUND_MAGENTA,\n+        BACKGROUND_CYAN,\n+        BACKGROUND_WHITE,\n+    };\n+\n+    private final CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.Arena.ofAuto());\n+    private final short originalColors;\n+\n+    private boolean negative;\n+    private boolean bold;\n+    private boolean underline;\n+    private short savedX = -1;\n+    private short savedY = -1;\n+\n+    public WindowsAnsiWriter(Writer out) throws IOException {\n+        super(out);\n+        getConsoleInfo();\n+        originalColors = info.attributes();\n+    }\n+\n+    private void getConsoleInfo() throws IOException {\n+        out.flush();\n+        if (GetConsoleScreenBufferInfo(console, info) == 0) {\n+            throw new IOException(\"Could not get the screen info: \" + getLastErrorMessage());\n+        }\n+        if (negative) {\n+            info.attributes(invertAttributeColors(info.attributes()));\n+        }\n+    }\n+\n+    private void applyAttribute() throws IOException {\n+        out.flush();\n+        short attributes = info.attributes();\n+        \/\/ bold is simulated by high foreground intensity\n+        if (bold) {\n+            attributes |= FOREGROUND_INTENSITY;\n+        }\n+        \/\/ underline is simulated by high foreground intensity\n+        if (underline) {\n+            attributes |= BACKGROUND_INTENSITY;\n+        }\n+        if (negative) {\n+            attributes = invertAttributeColors(attributes);\n+        }\n+        if (SetConsoleTextAttribute(console, attributes) == 0) {\n+            throw new IOException(getLastErrorMessage());\n+        }\n+    }\n+\n+    private short invertAttributeColors(short attributes) {\n+        \/\/ Swap the the Foreground and Background bits.\n+        int fg = 0x000F & attributes;\n+        fg <<= 4;\n+        int bg = 0X00F0 & attributes;\n+        bg >>= 4;\n+        attributes = (short) ((attributes & 0xFF00) | fg | bg);\n+        return attributes;\n+    }\n+\n+    private void applyCursorPosition() throws IOException {\n+        info.cursorPosition().x((short)\n+                Math.max(0, Math.min(info.size().x() - 1, info.cursorPosition().x())));\n+        info.cursorPosition().y((short)\n+                Math.max(0, Math.min(info.size().y() - 1, info.cursorPosition().y())));\n+        if (SetConsoleCursorPosition(console, info.cursorPosition()) == 0) {\n+            throw new IOException(getLastErrorMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void processEraseScreen(int eraseOption) throws IOException {\n+        getConsoleInfo();\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment written = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            switch (eraseOption) {\n+                case ERASE_SCREEN -> {\n+                    COORD topLeft = new COORD(arena, (short) 0, info.window().top());\n+                    int screenLength = info.window().height() * info.size().x();\n+                    FillConsoleOutputAttribute(console, originalColors, screenLength, topLeft, written);\n+                    FillConsoleOutputCharacterW(console, ' ', screenLength, topLeft, written);\n+                }\n+                case ERASE_SCREEN_TO_BEGINING -> {\n+                    COORD topLeft2 = new COORD(arena, (short) 0, info.window().top());\n+                    int lengthToCursor =\n+                            (info.cursorPosition().y() - info.window().top())\n+                                            * info.size().x()\n+                                    + info.cursorPosition().x();\n+                    FillConsoleOutputAttribute(console, originalColors, lengthToCursor, topLeft2, written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToCursor, topLeft2, written);\n+                }\n+                case ERASE_SCREEN_TO_END -> {\n+                    int lengthToEnd =\n+                            (info.window().bottom() - info.cursorPosition().y())\n+                                            * info.size().x()\n+                                    + (info.size().x() - info.cursorPosition().x());\n+                    FillConsoleOutputAttribute(console, originalColors, lengthToEnd, info.cursorPosition(), written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToEnd, info.cursorPosition(), written);\n+                }\n+                default -> {}\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processEraseLine(int eraseOption) throws IOException {\n+        getConsoleInfo();\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment written = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            switch (eraseOption) {\n+                case ERASE_LINE -> {\n+                    COORD leftColCurrRow =\n+                            new COORD(arena, (short) 0, info.cursorPosition().y());\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, info.size().x(), leftColCurrRow, written);\n+                    FillConsoleOutputCharacterW(console, ' ', info.size().x(), leftColCurrRow, written);\n+                }\n+                case ERASE_LINE_TO_BEGINING -> {\n+                    COORD leftColCurrRow2 =\n+                            new COORD(arena, (short) 0, info.cursorPosition().y());\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, info.cursorPosition().x(), leftColCurrRow2, written);\n+                    FillConsoleOutputCharacterW(\n+                            console, ' ', info.cursorPosition().x(), leftColCurrRow2, written);\n+                }\n+                case ERASE_LINE_TO_END -> {\n+                    int lengthToLastCol =\n+                            info.size().x() - info.cursorPosition().x();\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, lengthToLastCol, info.cursorPosition(), written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToLastCol, info.cursorPosition(), written);\n+                }\n+                default -> {}\n+            }\n+        }\n+    }\n+\n+    protected void processCursorUpLine(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) 0);\n+        info.cursorPosition().y((short) (info.cursorPosition().y() - count));\n+        applyCursorPosition();\n+    }\n+\n+    protected void processCursorDownLine(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) 0);\n+        info.cursorPosition().y((short) (info.cursorPosition().y() + count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorLeft(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (info.cursorPosition().x() - count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorRight(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (info.cursorPosition().x() + count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorDown(int count) throws IOException {\n+        getConsoleInfo();\n+        int nb = Math.max(0, info.cursorPosition().y() + count - info.size().y() + 1);\n+        if (nb != count) {\n+            info.cursorPosition().y((short) (info.cursorPosition().y() + count));\n+            applyCursorPosition();\n+        }\n+        if (nb > 0) {\n+            try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+                SMALL_RECT scroll = new SMALL_RECT(arena, info.window());\n+                scroll.top((short) 0);\n+                COORD org = new COORD(arena);\n+                org.x((short) 0);\n+                org.y((short) (-nb));\n+                CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+                ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processCursorUp(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().y((short) (info.cursorPosition().y() - count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorTo(int row, int col) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().y((short) (info.window().top() + row - 1));\n+        info.cursorPosition().x((short) (col - 1));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorToColumn(int x) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (x - 1));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n+        int color = Colors.roundColor(paletteIndex, 16);\n+        info.attributes((short) ((info.attributes() & ~0x0007) | ANSI_FOREGROUND_COLOR_MAP[color & 0x07]));\n+        info.attributes(\n+                (short) ((info.attributes() & ~FOREGROUND_INTENSITY) | (color >= 8 ? FOREGROUND_INTENSITY : 0)));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n+        int color = Colors.roundColor(paletteIndex, 16);\n+        info.attributes((short) ((info.attributes() & ~0x0070) | ANSI_BACKGROUND_COLOR_MAP[color & 0x07]));\n+        info.attributes(\n+                (short) ((info.attributes() & ~BACKGROUND_INTENSITY) | (color >= 8 ? BACKGROUND_INTENSITY : 0)));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processDefaultTextColor() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x000F) | (originalColors & 0xF)));\n+        info.attributes((short) (info.attributes() & ~FOREGROUND_INTENSITY));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processDefaultBackgroundColor() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x00F0) | (originalColors & 0xF0)));\n+        info.attributes((short) (info.attributes() & ~BACKGROUND_INTENSITY));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processAttributeRest() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x00FF) | originalColors));\n+        this.negative = false;\n+        this.bold = false;\n+        this.underline = false;\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processSetAttribute(int attribute) throws IOException {\n+        switch (attribute) {\n+            case ATTRIBUTE_INTENSITY_BOLD -> {\n+                bold = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_INTENSITY_NORMAL -> {\n+                bold = false;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_UNDERLINE -> {\n+                underline = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_UNDERLINE_OFF -> {\n+                underline = false;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_NEGATIVE_ON -> {\n+                negative = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_NEGATIVE_OFF -> {\n+                negative = false;\n+                applyAttribute();\n+            }\n+            default -> {}\n+        }\n+    }\n+\n+    @Override\n+    protected void processSaveCursorPosition() throws IOException {\n+        getConsoleInfo();\n+        savedX = info.cursorPosition().x();\n+        savedY = info.cursorPosition().y();\n+    }\n+\n+    @Override\n+    protected void processRestoreCursorPosition() throws IOException {\n+        \/\/ restore only if there was a save operation first\n+        if (savedX != -1 && savedY != -1) {\n+            out.flush();\n+            info.cursorPosition().x(savedX);\n+            info.cursorPosition().y(savedY);\n+            applyCursorPosition();\n+        }\n+    }\n+\n+    @Override\n+    protected void processInsertLine(int optionInt) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            getConsoleInfo();\n+            SMALL_RECT scroll = info.window().copy(arena);\n+            scroll.top(info.cursorPosition().y());\n+            COORD org =\n+                    new COORD(arena, (short) 0, (short) (info.cursorPosition().y() + optionInt));\n+            CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+            if (ScrollConsoleScreenBuffer(console, scroll, scroll, org, info) == 0) {\n+                throw new IOException(getLastErrorMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processDeleteLine(int optionInt) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            getConsoleInfo();\n+            SMALL_RECT scroll = info.window().copy(arena);\n+            scroll.top(info.cursorPosition().y());\n+            COORD org =\n+                    new COORD(arena, (short) 0, (short) (info.cursorPosition().y() - optionInt));\n+            CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+            if (ScrollConsoleScreenBuffer(console, scroll, scroll, org, info) == 0) {\n+                throw new IOException(getLastErrorMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processChangeWindowTitle(String title) {\n+        try (java.lang.foreign.Arena session = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment str = session.allocateFrom(title);\n+            SetConsoleTitleW(str);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/WindowsAnsiWriter.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-@SuppressWarnings(\"serial\")\n-public class LastErrorException extends RuntimeException{\n-\n-    public final long lastError;\n-\n-    public LastErrorException(long lastError) {\n-        this.lastError = lastError;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -37,0 +37,3 @@\n+    SystemStream getSystemStream();\n+\n+    TerminalProvider getProvider();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/Pty.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+public enum SystemStream {\n+    Input,\n+    Output,\n+    Error\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/SystemStream.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n+\/**\n+ * The {@code TerminalExt} interface is implemented by {@code Terminal}s\n+ * and provides access to the Terminal's internals.\n+ *\/\n+public interface TerminalExt extends Terminal {\n+\n+    \/**\n+     * Returns the {@code TerminalProvider} that created this terminal\n+     * or {@code null} if the terminal was created with no provider.\n+     *\/\n+    TerminalProvider getProvider();\n+\n+    \/**\n+     * The underlying system stream, may be {@link SystemStream#Output},\n+     * {@link SystemStream#Error}, or {@code null} if this terminal is not bound\n+     * to a system stream.\n+     *\/\n+    SystemStream getSystemStream();\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalExt.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -14,1 +14,0 @@\n-import java.net.URL;\n@@ -17,1 +16,0 @@\n-import java.util.ServiceLoader;\n@@ -24,0 +22,1 @@\n+import jdk.internal.org.jline.terminal.impl.ffm.FfmTerminalProvider;\n@@ -25,8 +24,1 @@\n-public interface TerminalProvider\n-{\n-\n-    enum Stream {\n-        Input,\n-        Output,\n-        Error\n-    }\n+public interface TerminalProvider {\n@@ -36,4 +28,23 @@\n-    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n-                         Charset encoding, boolean nativeSignals,\n-                         Terminal.SignalHandler signalHandler, boolean paused,\n-                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+    Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException;\n+\n+    Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException;\n@@ -41,4 +52,1 @@\n-    Terminal newTerminal(String name, String type,\n-                         InputStream masterInput, OutputStream masterOutput,\n-                         Charset encoding, Terminal.SignalHandler signalHandler,\n-                         boolean paused, Attributes attributes, Size size) throws IOException;\n+    boolean isSystemStream(SystemStream stream);\n@@ -46,1 +54,1 @@\n-    boolean isSystemStream(Stream stream);\n+    String systemStreamName(SystemStream stream);\n@@ -48,1 +56,1 @@\n-    String systemStreamName(Stream stream);\n+    int systemStreamWidth(SystemStream stream);\n@@ -53,7 +61,1 @@\n-            case \"jna\": {\n-                try {\n-                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n-                } catch (ReflectiveOperationException t) {\n-                    throw new IOException(t);\n-                }\n-            }\n+            case \"ffm\": return new FfmTerminalProvider();\n@@ -65,1 +67,1 @@\n-        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        InputStream is = cl.getResourceAsStream(\"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n@@ -74,1 +76,1 @@\n-                Class<?> clazz = cl.loadClass( className );\n+                Class<?> clazz = cl.loadClass(className);\n@@ -76,2 +78,2 @@\n-            } catch ( Exception e ) {\n-                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            } catch (Exception e) {\n+                throw new IOException(\"Unable to load terminal provider \" + name + \": \" + e.getMessage(), e);\n@@ -83,1 +85,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2009-2018 the original author(s).\n+ * Copyright (c) 2009-2018, the original author(s).\n@@ -4,3 +4,2 @@\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -8,7 +7,1 @@\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n@@ -255,3 +248,2 @@\n-        for (;;) {\n-            if (!optionsIterator.hasNext())\n-                throw new IllegalArgumentException();\n+        for (; ; ) {\n+            if (!optionsIterator.hasNext()) throw new IllegalArgumentException();\n@@ -259,2 +251,1 @@\n-            if (arg != null)\n-                return (Integer) arg;\n+            if (arg != null) return (Integer) arg;\n@@ -349,4 +340,2 @@\n-                                        if (value == 38)\n-                                            processSetForegroundColorExt(r, g, b);\n-                                        else\n-                                            processSetBackgroundColorExt(r, g, b);\n+                                        if (value == 38) processSetForegroundColorExt(r, g, b);\n+                                        else processSetBackgroundColorExt(r, g, b);\n@@ -356,2 +345,1 @@\n-                                }\n-                                else if (arg2or5 == 5) {\n+                                } else if (arg2or5 == 5) {\n@@ -361,4 +349,2 @@\n-                                        if (value == 38)\n-                                            processSetForegroundColorExt(paletteIndex);\n-                                        else\n-                                            processSetBackgroundColorExt(paletteIndex);\n+                                        if (value == 38) processSetForegroundColorExt(paletteIndex);\n+                                        else processSetBackgroundColorExt(paletteIndex);\n@@ -368,2 +354,1 @@\n-                                }\n-                                else {\n+                                } else {\n@@ -452,2 +437,1 @@\n-    protected void processRestoreCursorPosition() throws IOException {\n-    }\n+    protected void processRestoreCursorPosition() throws IOException {}\n@@ -459,2 +443,1 @@\n-    protected void processSaveCursorPosition() throws IOException {\n-    }\n+    protected void processSaveCursorPosition() throws IOException {}\n@@ -467,2 +450,1 @@\n-    protected void processInsertLine(int optionInt) throws IOException {\n-    }\n+    protected void processInsertLine(int optionInt) throws IOException {}\n@@ -475,2 +457,1 @@\n-    protected void processDeleteLine(int optionInt) throws IOException {\n-    }\n+    protected void processDeleteLine(int optionInt) throws IOException {}\n@@ -483,2 +464,1 @@\n-    protected void processScrollDown(int optionInt) throws IOException {\n-    }\n+    protected void processScrollDown(int optionInt) throws IOException {}\n@@ -491,2 +471,1 @@\n-    protected void processScrollUp(int optionInt) throws IOException {\n-    }\n+    protected void processScrollUp(int optionInt) throws IOException {}\n@@ -503,2 +482,1 @@\n-    protected void processEraseScreen(int eraseOption) throws IOException {\n-    }\n+    protected void processEraseScreen(int eraseOption) throws IOException {}\n@@ -515,2 +493,15 @@\n-    protected void processEraseLine(int eraseOption) throws IOException {\n-    }\n+    protected void processEraseLine(int eraseOption) throws IOException {}\n+\n+    protected static final int ATTRIBUTE_INTENSITY_BOLD = 1; \/\/  Intensity: Bold\n+    protected static final int ATTRIBUTE_INTENSITY_FAINT = 2; \/\/  Intensity; Faint  not widely supported\n+    protected static final int ATTRIBUTE_ITALIC = 3; \/\/  Italic; on  not widely supported. Sometimes treated as inverse.\n+    protected static final int ATTRIBUTE_UNDERLINE = 4; \/\/  Underline; Single\n+    protected static final int ATTRIBUTE_BLINK_SLOW = 5; \/\/  Blink; Slow  less than 150 per minute\n+    protected static final int ATTRIBUTE_BLINK_FAST = 6; \/\/  Blink; Rapid  MS-DOS ANSI.SYS; 150 per minute or more\n+    protected static final int ATTRIBUTE_NEGATIVE_ON =\n+            7; \/\/  Image; Negative  inverse or reverse; swap foreground and background\n+    protected static final int ATTRIBUTE_CONCEAL_ON = 8; \/\/  Conceal on\n+    protected static final int ATTRIBUTE_UNDERLINE_DOUBLE = 21; \/\/  Underline; Double  not widely supported\n+    protected static final int ATTRIBUTE_INTENSITY_NORMAL = 22; \/\/  Intensity; Normal  not bold and not faint\n+    protected static final int ATTRIBUTE_UNDERLINE_OFF = 24; \/\/  Underline; None\n+    protected static final int ATTRIBUTE_BLINK_OFF = 25; \/\/  Blink; off\n@@ -518,12 +509,0 @@\n-    protected static final int ATTRIBUTE_INTENSITY_BOLD = 1; \/\/         Intensity: Bold\n-    protected static final int ATTRIBUTE_INTENSITY_FAINT = 2; \/\/        Intensity; Faint        not widely supported\n-    protected static final int ATTRIBUTE_ITALIC = 3; \/\/         Italic; on      not widely supported. Sometimes treated as inverse.\n-    protected static final int ATTRIBUTE_UNDERLINE = 4; \/\/      Underline; Single\n-    protected static final int ATTRIBUTE_BLINK_SLOW = 5; \/\/     Blink; Slow     less than 150 per minute\n-    protected static final int ATTRIBUTE_BLINK_FAST = 6; \/\/     Blink; Rapid    MS-DOS ANSI.SYS; 150 per minute or more\n-    protected static final int ATTRIBUTE_NEGATIVE_ON = 7; \/\/    Image; Negative         inverse or reverse; swap foreground and background\n-    protected static final int ATTRIBUTE_CONCEAL_ON = 8; \/\/     Conceal on\n-    protected static final int ATTRIBUTE_UNDERLINE_DOUBLE = 21; \/\/      Underline; Double       not widely supported\n-    protected static final int ATTRIBUTE_INTENSITY_NORMAL = 22; \/\/      Intensity; Normal       not bold and not faint\n-    protected static final int ATTRIBUTE_UNDERLINE_OFF = 24; \/\/         Underline; None\n-    protected static final int ATTRIBUTE_BLINK_OFF = 25; \/\/     Blink; off\n@@ -532,0 +511,1 @@\n+\n@@ -533,1 +513,1 @@\n-    protected static final int ATTRIBUTE_CONCEAL_OFF = 28; \/\/   Reveal  conceal off\n+    protected static final int ATTRIBUTE_CONCEAL_OFF = 28; \/\/  Reveal  conceal off\n@@ -549,2 +529,1 @@\n-    protected void processSetAttribute(int attribute) throws IOException {\n-    }\n+    protected void processSetAttribute(int attribute) throws IOException {}\n@@ -587,2 +566,1 @@\n-    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n-    }\n+    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {}\n@@ -628,2 +606,1 @@\n-    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n-    }\n+    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {}\n@@ -647,2 +624,1 @@\n-    protected void processDefaultTextColor() throws IOException {\n-    }\n+    protected void processDefaultTextColor() throws IOException {}\n@@ -654,2 +630,1 @@\n-    protected void processDefaultBackgroundColor() throws IOException {\n-    }\n+    protected void processDefaultBackgroundColor() throws IOException {}\n@@ -661,2 +636,1 @@\n-    protected void processAttributeRest() throws IOException {\n-    }\n+    protected void processAttributeRest() throws IOException {}\n@@ -671,2 +645,1 @@\n-    protected void processCursorTo(int row, int col) throws IOException {\n-    }\n+    protected void processCursorTo(int row, int col) throws IOException {}\n@@ -679,2 +652,1 @@\n-    protected void processCursorToColumn(int x) throws IOException {\n-    }\n+    protected void processCursorToColumn(int x) throws IOException {}\n@@ -687,2 +659,1 @@\n-    protected void processCursorUpLine(int count) throws IOException {\n-    }\n+    protected void processCursorUpLine(int count) throws IOException {}\n@@ -707,2 +678,1 @@\n-    protected void processCursorLeft(int count) throws IOException {\n-    }\n+    protected void processCursorLeft(int count) throws IOException {}\n@@ -727,2 +697,1 @@\n-    protected void processCursorDown(int count) throws IOException {\n-    }\n+    protected void processCursorDown(int count) throws IOException {}\n@@ -735,2 +704,1 @@\n-    protected void processCursorUp(int count) throws IOException {\n-    }\n+    protected void processCursorUp(int count) throws IOException {}\n@@ -738,2 +706,1 @@\n-    protected void processUnknownExtension(ArrayList<Object> options, int command) {\n-    }\n+    protected void processUnknownExtension(ArrayList<Object> options, int command) {}\n@@ -754,2 +721,1 @@\n-    protected void processChangeIconName(String name) {\n-    }\n+    protected void processChangeIconName(String name) {}\n@@ -761,2 +727,1 @@\n-    protected void processChangeWindowTitle(String title) {\n-    }\n+    protected void processChangeWindowTitle(String title) {}\n@@ -769,2 +734,1 @@\n-    protected void processUnknownOperatingSystemCommand(int command, String param) {\n-    }\n+    protected void processUnknownOperatingSystemCommand(int command, String param) {}\n@@ -784,2 +748,1 @@\n-    protected void processCharsetSelect(int set, char seq) {\n-    }\n+    protected void processCharsetSelect(int set, char seq) {}\n@@ -788,2 +751,1 @@\n-        if (options.size() <= index)\n-            throw new IllegalArgumentException();\n+        if (options.size() <= index) throw new IllegalArgumentException();\n@@ -791,4 +753,2 @@\n-        if (value == null)\n-            throw new IllegalArgumentException();\n-        if (!value.getClass().equals(Integer.class))\n-            throw new IllegalArgumentException();\n+        if (value == null) throw new IllegalArgumentException();\n+        if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException();\n@@ -831,1 +791,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AnsiWriter.java","additions":57,"deletions":98,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -18,0 +18,1 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -33,0 +34,1 @@\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;\n@@ -36,1 +38,0 @@\n-import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;\n@@ -38,1 +39,0 @@\n-import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -123,0 +123,1 @@\n+                \/\/ @spotless:off\n@@ -136,0 +137,1 @@\n+                \/\/ @spotless:on\n@@ -142,1 +144,1 @@\n-            long  s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n+            long s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n@@ -144,1 +146,1 @@\n-                long  d = (style ^ s) & MASK;\n+                long d = (style ^ s) & MASK;\n@@ -175,3 +177,3 @@\n-                                int r = (int)(fg >> (FG_COLOR_EXP + 16)) & 0xFF;\n-                                int g = (int)(fg >> (FG_COLOR_EXP + 8)) & 0xFF;\n-                                int b = (int)(fg >> FG_COLOR_EXP) & 0xFF;\n+                                int r = (int) (fg >> (FG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int) (fg >> (FG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int) (fg >> FG_COLOR_EXP) & 0xFF;\n@@ -184,1 +186,1 @@\n-                                rounded = palette.round((int)(fg >> FG_COLOR_EXP) & 0xFF);\n+                                rounded = palette.round((int) (fg >> FG_COLOR_EXP) & 0xFF);\n@@ -214,3 +216,3 @@\n-                                int r = (int)(bg >> (BG_COLOR_EXP + 16)) & 0xFF;\n-                                int g = (int)(bg >> (BG_COLOR_EXP + 8)) & 0xFF;\n-                                int b = (int)(bg >> BG_COLOR_EXP) & 0xFF;\n+                                int r = (int) (bg >> (BG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int) (bg >> (BG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int) (bg >> BG_COLOR_EXP) & 0xFF;\n@@ -223,1 +225,1 @@\n-                                rounded = palette.round((int)(bg >> BG_COLOR_EXP) & 0xFF);\n+                                rounded = palette.round((int) (bg >> BG_COLOR_EXP) & 0xFF);\n@@ -246,2 +248,1 @@\n-                        if (    (d & F_BOLD)  != 0 && (s & F_BOLD)  == 0\n-                                || (d & F_FAINT) != 0 && (s & F_FAINT) == 0) {\n+                        if ((d & F_BOLD) != 0 && (s & F_BOLD) == 0 || (d & F_FAINT) != 0 && (s & F_FAINT) == 0) {\n@@ -363,2 +364,1 @@\n-            if (!isHidden(cur))\n-                cols += WCWidth.wcwidth(cp);\n+            if (!isHidden(cur)) cols += WCWidth.wcwidth(cp);\n@@ -385,2 +385,1 @@\n-            if (cp == '\\n')\n-                break;\n+            if (cp == '\\n') break;\n@@ -410,1 +409,1 @@\n-                strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));\n+                strings.add(subSequence(beg, includeNewlines ? cur + 1 : cur));\n@@ -432,1 +431,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedCharSequence.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -18,0 +18,2 @@\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n@@ -106,0 +108,16 @@\n+        return fromAnsi(ansi, tabs, null, null);\n+    }\n+\n+    public static AttributedString fromAnsi(String ansi, Terminal terminal) {\n+        String alternateIn, alternateOut;\n+        if (!DISABLE_ALTERNATE_CHARSET) {\n+            alternateIn = Curses.tputs(terminal.getStringCapability(InfoCmp.Capability.enter_alt_charset_mode));\n+            alternateOut = Curses.tputs(terminal.getStringCapability(InfoCmp.Capability.exit_alt_charset_mode));\n+        } else {\n+            alternateIn = null;\n+            alternateOut = null;\n+        }\n+        return fromAnsi(ansi, Arrays.asList(0), alternateIn, alternateOut);\n+    }\n+\n+    public static AttributedString fromAnsi(String ansi, List<Integer> tabs, String altIn, String altOut) {\n@@ -111,0 +129,1 @@\n+                .altCharset(altIn, altOut)\n@@ -119,3 +138,1 @@\n-        return new AttributedStringBuilder(ansi.length())\n-                .ansiAppend(ansi)\n-                .toString();\n+        return new AttributedStringBuilder(ansi.length()).ansiAppend(ansi).toString();\n@@ -165,1 +182,1 @@\n-            return new AttributedString(buffer, newstyle, start , end);\n+            return new AttributedString(buffer, newstyle, start, end);\n@@ -182,1 +199,1 @@\n-            if (a1[s1+i] != a2[s2+i]) {\n+            if (a1[s1 + i] != a2[s2 + i]) {\n@@ -188,0 +205,1 @@\n+\n@@ -190,1 +208,1 @@\n-            if (a1[s1+i] != a2[s2+i]) {\n+            if (a1[s1 + i] != a2[s2 + i]) {\n@@ -224,1 +242,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedString.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -30,0 +30,3 @@\n+    private char[] altIn;\n+    private char[] altOut;\n+    private boolean inAltCharset;\n@@ -84,4 +87,1 @@\n-                Arrays.copyOfRange(buffer, start, end),\n-                Arrays.copyOfRange(style, start, end),\n-                0,\n-                end - start);\n+                Arrays.copyOfRange(buffer, start, end), Arrays.copyOfRange(style, start, end), 0, end - start);\n@@ -111,0 +111,8 @@\n+    public AttributedStringBuilder append(char c, int repeat) {\n+        AttributedString s = new AttributedString(Character.toString(c), current);\n+        while (repeat-- > 0) {\n+            append(s);\n+        }\n+        return this;\n+    }\n+\n@@ -120,1 +128,1 @@\n-    public AttributedStringBuilder style(Function<AttributedStyle,AttributedStyle> style) {\n+    public AttributedStringBuilder style(Function<AttributedStyle, AttributedStyle> style) {\n@@ -125,1 +133,1 @@\n-    public AttributedStringBuilder styled(Function<AttributedStyle,AttributedStyle> style, CharSequence cs) {\n+    public AttributedStringBuilder styled(Function<AttributedStyle, AttributedStyle> style, CharSequence cs) {\n@@ -133,1 +141,2 @@\n-    public AttributedStringBuilder styled(Function<AttributedStyle,AttributedStyle> style, Consumer<AttributedStringBuilder> consumer) {\n+    public AttributedStringBuilder styled(\n+            Function<AttributedStyle, AttributedStyle> style, Consumer<AttributedStringBuilder> consumer) {\n@@ -341,2 +350,0 @@\n-            } else if (c == '\\t' && tabs.defined()) {\n-                insertTab(current);\n@@ -344,5 +351,11 @@\n-                ensureCapacity(length + 1);\n-                buffer[length] = c;\n-                style[length] = this.current.getStyle();\n-                if (c == '\\n') {\n-                    lastLineLength = 0;\n+                if (ansiState >= 1) {\n+                    ensureCapacity(length + 1);\n+                    buffer[length++] = 27;\n+                    if (ansiState >= 2) {\n+                        ensureCapacity(length + 1);\n+                        buffer[length++] = '[';\n+                    }\n+                    ansiState = 0;\n+                }\n+                if (c == '\\t' && tabs.defined()) {\n+                    insertTab(current);\n@@ -350,1 +363,53 @@\n-                    lastLineLength++;\n+                    ensureCapacity(length + 1);\n+                    if (inAltCharset) {\n+                        switch (c) {\n+                            case 'j':\n+                                c = '\\u2518';\n+                                break;\n+                            case 'k':\n+                                c = '\\u2510';\n+                                break;\n+                            case 'l':\n+                                c = '\\u250C';\n+                                break;\n+                            case 'm':\n+                                c = '\\u2514';\n+                                break;\n+                            case 'n':\n+                                c = '\\u253C';\n+                                break;\n+                            case 'q':\n+                                c = '\\u2500';\n+                                break;\n+                            case 't':\n+                                c = '\\u251C';\n+                                break;\n+                            case 'u':\n+                                c = '\\u2524';\n+                                break;\n+                            case 'v':\n+                                c = '\\u2534';\n+                                break;\n+                            case 'w':\n+                                c = '\\u252C';\n+                                break;\n+                            case 'x':\n+                                c = '\\u2502';\n+                                break;\n+                        }\n+                    }\n+                    buffer[length] = c;\n+                    style[length] = this.current.getStyle();\n+                    if (c == '\\n') {\n+                        lastLineLength = 0;\n+                    } else {\n+                        lastLineLength++;\n+                    }\n+                    length++;\n+                    if (altIn != null && altOut != null) {\n+                        char[] alt = inAltCharset ? altOut : altIn;\n+                        if (equals(buffer, length - alt.length, alt, 0, alt.length)) {\n+                            inAltCharset = !inAltCharset;\n+                            length -= alt.length;\n+                        }\n+                    }\n@@ -352,1 +417,0 @@\n-                length++;\n@@ -358,0 +422,12 @@\n+    private static boolean equals(char[] a, int aFromIndex, char[] b, int bFromIndex, int length) {\n+        if (aFromIndex < 0 || bFromIndex < 0 || aFromIndex + length > a.length || bFromIndex + length > b.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < length; i++) {\n+            if (a[aFromIndex + i] != b[bFromIndex + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -396,0 +472,9 @@\n+    public AttributedStringBuilder altCharset(String altIn, String altOut) {\n+        if (length > 0) {\n+            throw new IllegalStateException(\"Cannot change alternative charset after appending text\");\n+        }\n+        this.altIn = altIn != null ? altIn.toCharArray() : null;\n+        this.altOut = altOut != null ? altOut.toCharArray() : null;\n+        return this;\n+    }\n+\n@@ -419,1 +504,1 @@\n-    private class TabStops {\n+    private static class TabStops {\n@@ -431,1 +516,1 @@\n-            for (int s: tabs) {\n+            for (int s : tabs) {\n@@ -450,1 +535,1 @@\n-                for (int s: tabs) {\n+                for (int s : tabs) {\n@@ -459,1 +544,0 @@\n-\n@@ -461,1 +545,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStringBuilder.java","additions":105,"deletions":22,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -18,33 +18,33 @@\n-    public static final int BLACK =     0;\n-    public static final int RED =       1;\n-    public static final int GREEN =     2;\n-    public static final int YELLOW =    3;\n-    public static final int BLUE =      4;\n-    public static final int MAGENTA =   5;\n-    public static final int CYAN =      6;\n-    public static final int WHITE =     7;\n-\n-    public static final int BRIGHT =    8;\n-\n-    static final long F_BOLD            = 0x00000001;\n-    static final long F_FAINT           = 0x00000002;\n-    static final long F_ITALIC          = 0x00000004;\n-    static final long F_UNDERLINE       = 0x00000008;\n-    static final long F_BLINK           = 0x00000010;\n-    static final long F_INVERSE         = 0x00000020;\n-    static final long F_CONCEAL         = 0x00000040;\n-    static final long F_CROSSED_OUT     = 0x00000080;\n-    static final long F_FOREGROUND_IND  = 0x00000100;\n-    static final long F_FOREGROUND_RGB  = 0x00000200;\n-    static final long F_FOREGROUND      = F_FOREGROUND_IND | F_FOREGROUND_RGB;\n-    static final long F_BACKGROUND_IND  = 0x00000400;\n-    static final long F_BACKGROUND_RGB  = 0x00000800;\n-    static final long F_BACKGROUND      = F_BACKGROUND_IND | F_BACKGROUND_RGB;\n-    static final long F_HIDDEN          = 0x00001000;\n-\n-    static final long MASK           = 0x00001FFF;\n-\n-    static final int FG_COLOR_EXP    = 15;\n-    static final int BG_COLOR_EXP    = 39;\n-    static final long FG_COLOR        = 0xFFFFFFL << FG_COLOR_EXP;\n-    static final long BG_COLOR        = 0xFFFFFFL << BG_COLOR_EXP;\n+    public static final int BLACK = 0;\n+    public static final int RED = 1;\n+    public static final int GREEN = 2;\n+    public static final int YELLOW = 3;\n+    public static final int BLUE = 4;\n+    public static final int MAGENTA = 5;\n+    public static final int CYAN = 6;\n+    public static final int WHITE = 7;\n+\n+    public static final int BRIGHT = 8;\n+\n+    static final long F_BOLD = 0x00000001;\n+    static final long F_FAINT = 0x00000002;\n+    static final long F_ITALIC = 0x00000004;\n+    static final long F_UNDERLINE = 0x00000008;\n+    static final long F_BLINK = 0x00000010;\n+    static final long F_INVERSE = 0x00000020;\n+    static final long F_CONCEAL = 0x00000040;\n+    static final long F_CROSSED_OUT = 0x00000080;\n+    static final long F_FOREGROUND_IND = 0x00000100;\n+    static final long F_FOREGROUND_RGB = 0x00000200;\n+    static final long F_FOREGROUND = F_FOREGROUND_IND | F_FOREGROUND_RGB;\n+    static final long F_BACKGROUND_IND = 0x00000400;\n+    static final long F_BACKGROUND_RGB = 0x00000800;\n+    static final long F_BACKGROUND = F_BACKGROUND_IND | F_BACKGROUND_RGB;\n+    static final long F_HIDDEN = 0x00001000;\n+\n+    static final long MASK = 0x00001FFF;\n+\n+    static final int FG_COLOR_EXP = 15;\n+    static final int BG_COLOR_EXP = 39;\n+    static final long FG_COLOR = 0xFFFFFFL << FG_COLOR_EXP;\n+    static final long BG_COLOR = 0xFFFFFFL << BG_COLOR_EXP;\n@@ -73,2 +73,3 @@\n-        this.mask = mask & MASK | ((style & F_FOREGROUND) != 0 ? FG_COLOR : 0)\n-                                | ((style & F_BACKGROUND) != 0 ? BG_COLOR : 0);\n+        this.mask = mask & MASK\n+                | ((style & F_FOREGROUND) != 0 ? FG_COLOR : 0)\n+                | ((style & F_BACKGROUND) != 0 ? BG_COLOR : 0);\n@@ -179,1 +180,3 @@\n-        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_IND | (((long) color << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_IND);\n+        return new AttributedStyle(\n+                style & ~FG_COLOR | F_FOREGROUND_IND | (((long) color << FG_COLOR_EXP) & FG_COLOR),\n+                mask | F_FOREGROUND_IND);\n@@ -187,1 +190,3 @@\n-        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_RGB | ((((long) color & 0xFFFFFF) << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_RGB);\n+        return new AttributedStyle(\n+                style & ~FG_COLOR | F_FOREGROUND_RGB | ((((long) color & 0xFFFFFF) << FG_COLOR_EXP) & FG_COLOR),\n+                mask | F_FOREGROUND_RGB);\n@@ -199,1 +204,3 @@\n-        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_IND | (((long) color << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_IND);\n+        return new AttributedStyle(\n+                style & ~BG_COLOR | F_BACKGROUND_IND | (((long) color << BG_COLOR_EXP) & BG_COLOR),\n+                mask | F_BACKGROUND_IND);\n@@ -207,1 +214,3 @@\n-        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_RGB | ((((long) color & 0xFFFFFF) << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_RGB);\n+        return new AttributedStyle(\n+                style & ~BG_COLOR | F_BACKGROUND_RGB | ((((long) color & 0xFFFFFF) << BG_COLOR_EXP) & BG_COLOR),\n+                mask | F_BACKGROUND_RGB);\n@@ -252,1 +261,0 @@\n-\n@@ -269,5 +277,1 @@\n-        return \"AttributedStyle{\" +\n-                \"style=\" + style +\n-                \", mask=\" + mask +\n-                \", ansi=\" + toAnsi() +\n-                '}';\n+        return \"AttributedStyle{\" + \"style=\" + style + \", mask=\" + mask + \", ansi=\" + toAnsi() + '}';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStyle.java","additions":50,"deletions":46,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,2 +17,1 @@\n-    public ClosedException() {\n-    }\n+    public ClosedException() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ClosedException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,1 +24,2 @@\n-    public static final String XTERM_INITC = \"\\\\E]4;%p1%d;rgb\\\\:%p2%{255}%*%{1000}%\/%2.2X\/%p3%{255}%*%{1000}%\/%2.2X\/%p4%{255}%*%{1000}%\/%2.2X\\\\E\\\\\\\\\";\n+    public static final String XTERM_INITC =\n+            \"\\\\E]4;%p1%d;rgb\\\\:%p2%{255}%*%{1000}%\/%2.2X\/%p3%{255}%*%{1000}%\/%2.2X\/%p4%{255}%*%{1000}%\/%2.2X\\\\E\\\\\\\\\";\n@@ -44,0 +45,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -248,4 +250,7 @@\n-                double r = Integer.parseInt(rgb.get(0), 16) \/ ((1 << (4 * rgb.get(0).length())) - 1.0);\n-                double g = Integer.parseInt(rgb.get(1), 16) \/ ((1 << (4 * rgb.get(1).length())) - 1.0);\n-                double b = Integer.parseInt(rgb.get(2), 16) \/ ((1 << (4 * rgb.get(2).length())) - 1.0);\n-                palette[idx] = (int)((Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255));\n+                double r = Integer.parseInt(rgb.get(0), 16)\n+                        \/ ((1 << (4 * rgb.get(0).length())) - 1.0);\n+                double g = Integer.parseInt(rgb.get(1), 16)\n+                        \/ ((1 << (4 * rgb.get(1).length())) - 1.0);\n+                double b = Integer.parseInt(rgb.get(2), 16)\n+                        \/ ((1 << (4 * rgb.get(2).length())) - 1.0);\n+                palette[idx] = (int) ((Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255));\n@@ -259,1 +264,2 @@\n-        while (max > 0 && palette[--max] == 0);\n+        while (max > 0 && palette[--max] == 0)\n+            ;\n@@ -262,0 +268,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"ColorPalette[\" + \"length=\" + getLength() + \", \" + \"distance='\" + getDist() + \"\\']\";\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ColorPalette.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -24,0 +24,2 @@\n+    \/\/ @spotless:off\n+\n@@ -114,0 +116,2 @@\n+    \/\/ @spotless:on\n+\n@@ -115,1 +119,1 @@\n-    public static final double[] D50 = new double[] { 96.422f, 100.0f,  82.521f };\n+    public static final double[] D50 = new double[] {96.422f, 100.0f, 82.521f};\n@@ -117,1 +121,1 @@\n-    public static final double[] D65 = new double[] { 95.047, 100.0, 108.883 };\n+    public static final double[] D65 = new double[] {95.047, 100.0, 108.883};\n@@ -120,1 +124,1 @@\n-    public static final double[] averageSurrounding = new double[] { 1.0, 0.690, 1.0 };\n+    public static final double[] averageSurrounding = new double[] {1.0, 0.690, 1.0};\n@@ -122,1 +126,1 @@\n-    public static final double[] dimSurrounding =     new double[] { 0.9, 0.590, 0.9 };\n+    public static final double[] dimSurrounding = new double[] {0.9, 0.590, 0.9};\n@@ -124,1 +128,1 @@\n-    public static final double[] darkSurrounding =    new double[] { 0.8, 0.525, 0.8 };\n+    public static final double[] darkSurrounding = new double[] {0.8, 0.525, 0.8};\n@@ -127,1 +131,1 @@\n-    public static final double[] sRGB_encoding_environment = vc(D50,  64.0,  64.0\/5, dimSurrounding);\n+    public static final double[] sRGB_encoding_environment = vc(D50, 64.0, 64.0 \/ 5, dimSurrounding);\n@@ -129,1 +133,1 @@\n-    public static final double[] sRGB_typical_environment  = vc(D50, 200.0, 200.0\/5, averageSurrounding);\n+    public static final double[] sRGB_typical_environment = vc(D50, 200.0, 200.0 \/ 5, averageSurrounding);\n@@ -131,1 +135,1 @@\n-    public static final double[] AdobeRGB_environment      = vc(D65, 160.0, 160.0\/5, averageSurrounding);\n+    public static final double[] AdobeRGB_environment = vc(D65, 160.0, 160.0 \/ 5, averageSurrounding);\n@@ -152,2 +156,3 @@\n-                 BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n-                br.lines().map(String::trim)\n+                    BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+                br.lines()\n+                        .map(String::trim)\n@@ -209,1 +214,1 @@\n-        return doGetDistance(dist);\n+        return new NamedDistance(dist, doGetDistance(dist));\n@@ -219,1 +224,1 @@\n-                double[] w = { 2.0 + rmean, 4.0, 3.0 - rmean };\n+                double[] w = {2.0 + rmean, 4.0, 3.0 - rmean};\n@@ -231,1 +236,1 @@\n-            return (p1, p2) -> scalar(rgb2cielab(p1), rgb2cielab(p2), new double[] { w[0], w[1], w[1] });\n+            return (p1, p2) -> scalar(rgb2cielab(p1), rgb2cielab(p2), new double[] {w[0], w[1], w[1]});\n@@ -254,1 +259,1 @@\n-                return scalar(c1, c2, new double[] { w[0], w[1], w[1] });\n+                return scalar(c1, c2, new double[] {w[0], w[1], w[1]});\n@@ -276,1 +281,2 @@\n-        String[] weights = dist.substring(dist.indexOf('(') + 1, dist.length() - 1).split(\",\");\n+        String[] weights =\n+                dist.substring(dist.indexOf('(') + 1, dist.length() - 1).split(\",\");\n@@ -281,3 +287,1 @@\n-        return sqr((c1[0] - c2[0]) * w[0])\n-             + sqr((c1[1] - c2[1]) * w[1])\n-             + sqr((c1[2] - c2[2]) * w[2]);\n+        return sqr((c1[0] - c2[0]) * w[0]) + sqr((c1[1] - c2[1]) * w[1]) + sqr((c1[2] - c2[2]) * w[2]);\n@@ -287,3 +291,21 @@\n-        return sqr(c1[0] - c2[0])\n-             + sqr(c1[1] - c2[1])\n-             + sqr(c1[2] - c2[2]);\n+        return sqr(c1[0] - c2[0]) + sqr(c1[1] - c2[1]) + sqr(c1[2] - c2[2]);\n+    }\n+\n+    private static class NamedDistance implements Distance {\n+        private final String name;\n+        private final Distance delegate;\n+\n+        public NamedDistance(String name, Distance delegate) {\n+            this.name = name;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public double compute(int c1, int c2) {\n+            return delegate.compute(c1, c2);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n@@ -328,1 +350,1 @@\n-        double G = 0.5 * (1.0 - Math.sqrt(c_star_average_ab_pot_7 \/ (c_star_average_ab_pot_7 + 6103515625.0))); \/\/25^7\n+        double G = 0.5 * (1.0 - Math.sqrt(c_star_average_ab_pot_7 \/ (c_star_average_ab_pot_7 + 6103515625.0))); \/\/ 25^7\n@@ -368,1 +390,2 @@\n-        double S_L = 1.0 + ((0.015 * L_prime_average_minus_50_square) \/ Math.sqrt(20.0 + L_prime_average_minus_50_square));\n+        double S_L =\n+                1.0 + ((0.015 * L_prime_average_minus_50_square) \/ Math.sqrt(20.0 + L_prime_average_minus_50_square));\n@@ -372,1 +395,2 @@\n-        double h_prime_average_minus_275_div_25_square = h_prime_average_minus_275_div_25 * h_prime_average_minus_275_div_25;\n+        double h_prime_average_minus_275_div_25_square =\n+                h_prime_average_minus_275_div_25 * h_prime_average_minus_275_div_25;\n@@ -376,2 +400,2 @@\n-        double R_C = 2.0 * Math.sqrt(C_prime_average_pot_7 \/ (C_prime_average_pot_7 + 6103515625.0)); \/\/25^7\n-        double R_T = - Math.sin(Math.toRadians(2.0 * delta_theta)) * R_C;\n+        double R_C = 2.0 * Math.sqrt(C_prime_average_pot_7 \/ (C_prime_average_pot_7 + 6103515625.0)); \/\/ 25^7\n+        double R_T = -Math.sin(Math.toRadians(2.0 * delta_theta)) * R_C;\n@@ -395,1 +419,1 @@\n-        return new double[] {sJ, a, b };\n+        return new double[] {sJ, a, b};\n@@ -399,1 +423,1 @@\n-        return camlch(c1, c2, new double[] { 1.0, 1.0, 1.0 });\n+        return camlch(c1, c2, new double[] {1.0, 1.0, 1.0});\n@@ -417,4 +441,2 @@\n-        if (difference > ch)\n-            difference -= c;\n-        if (difference < -ch)\n-            difference += c;\n+        if (difference > ch) difference -= c;\n+        if (difference < -ch) difference += c;\n@@ -426,3 +448,3 @@\n-        int g = (color >>  8) & 0xFF;\n-        int b = (color >>  0) & 0xFF;\n-        return new double[] { r \/ 255.0, g \/ 255.0, b \/ 255.0 };\n+        int g = (color >> 8) & 0xFF;\n+        int b = (color >> 0) & 0xFF;\n+        return new double[] {r \/ 255.0, g \/ 255.0, b \/ 255.0};\n@@ -457,1 +479,1 @@\n-        return new double[] { lch[0], lch[1] * Math.cos(lch[2] * toRad), lch[1] * Math.sin(lch[2] * toRad) };\n+        return new double[] {lch[0], lch[1] * Math.cos(lch[2] * toRad), lch[1] * Math.sin(lch[2] * toRad)};\n@@ -463,1 +485,1 @@\n-        return new double[] { cam[J], cam[M], cam[h] };\n+        return new double[] {cam[J], cam[M], cam[h]};\n@@ -481,1 +503,0 @@\n-\n@@ -486,1 +507,2 @@\n-        \/\/ calculate corresponding (sharpened) cone response considering various luminance level and surround conditions in D\n+        \/\/ calculate corresponding (sharpened) cone response considering various luminance level and surround conditions\n+        \/\/ in D\n@@ -504,1 +526,3 @@\n-        double t = e * Math.sqrt(Math.pow(a, 2.0) + Math.pow(b, 2.0)) \/ (RGBPrime_a[0] + RGBPrime_a[1] + 1.05 * RGBPrime_a[2]);\n+        double t = e\n+                * Math.sqrt(Math.pow(a, 2.0) + Math.pow(b, 2.0))\n+                \/ (RGBPrime_a[0] + RGBPrime_a[1] + 1.05 * RGBPrime_a[2]);\n@@ -508,1 +532,4 @@\n-        double C = Math.signum(t) * Math.pow(Math.abs(t), 0.9) * Math.sqrt(J \/ 100.0) * Math.pow(1.64- Math.pow(0.29, vc[VC_N]), 0.73);\n+        double C = Math.signum(t)\n+                * Math.pow(Math.abs(t), 0.9)\n+                * Math.sqrt(J \/ 100.0)\n+                * Math.pow(1.64 - Math.pow(0.29, vc[VC_N]), 0.73);\n@@ -513,1 +540,1 @@\n-        return new double[] { J, Q, C, M, s, H, h };\n+        return new double[] {J, Q, C, M, s, H, h};\n@@ -517,2 +544,1 @@\n-        if (h < 20.14)\n-            h = h + 360;\n+        if (h < 20.14) h = h + 360;\n@@ -520,1 +546,1 @@\n-        if (h >= 20.14 && h < 90.0) {  \/\/ index i = 1\n+        if (h >= 20.14 && h < 90.0) { \/\/ index i = 1\n@@ -526,1 +552,1 @@\n-        } else if (h < 237.53) {  \/\/ index i = 3\n+        } else if (h < 237.53) { \/\/ index i = 3\n@@ -529,1 +555,1 @@\n-        } else if (h <= 380.14) {  \/\/ index i = 4\n+        } else if (h <= 380.14) { \/\/ index i = 4\n@@ -533,2 +559,1 @@\n-            if (H <= 400.0 && H >= 399.999)\n-                H = 0;\n+            if (H <= 400.0 && H >= 399.999) H = 0;\n@@ -543,2 +568,2 @@\n-        for(int channel = 0; channel < RGB.length; channel++) {\n-            if(RGB[channel] >= 0) {\n+        for (int channel = 0; channel < RGB.length; channel++) {\n+            if (RGB[channel] >= 0) {\n@@ -556,1 +581,1 @@\n-        return new double[] { vc[VC_D_RGB_R] * RGB[0], vc[VC_D_RGB_G] * RGB[1], vc[VC_D_RGB_B] * RGB[2] };\n+        return new double[] {vc[VC_D_RGB_R] * RGB[0], vc[VC_D_RGB_G] * RGB[1], vc[VC_D_RGB_B] * RGB[2]};\n@@ -561,2 +586,2 @@\n-        RGBPrime[0] =  0.7409792 * RGB[0] + 0.2180250 * RGB[1] + 0.0410058 * RGB[2];\n-        RGBPrime[1] =  0.2853532 * RGB[0] + 0.6242014 * RGB[1] + 0.0904454 * RGB[2];\n+        RGBPrime[0] = 0.7409792 * RGB[0] + 0.2180250 * RGB[1] + 0.0410058 * RGB[2];\n+        RGBPrime[1] = 0.2853532 * RGB[0] + 0.6242014 * RGB[1] + 0.0904454 * RGB[2];\n@@ -569,1 +594,1 @@\n-        RGB[0] =  0.7328 * XYZ[0] + 0.4296 * XYZ[1] - 0.1624 * XYZ[2];\n+        RGB[0] = 0.7328 * XYZ[0] + 0.4296 * XYZ[1] - 0.1624 * XYZ[2];\n@@ -571,1 +596,1 @@\n-        RGB[2] =  0.0030 * XYZ[0] + 0.0136 * XYZ[1] + 0.9834 * XYZ[2];\n+        RGB[2] = 0.0030 * XYZ[0] + 0.0136 * XYZ[1] + 0.9834 * XYZ[2];\n@@ -584,2 +609,2 @@\n-    static final int VC_F =   5;\n-    static final int VC_C =   6;\n+    static final int VC_F = 5;\n+    static final int VC_C = 6;\n@@ -610,1 +635,2 @@\n-        double D = Math.max(0.0, Math.min(1.0, vc[VC_F] * (1.0 - (1.0 \/ 3.6) * Math.pow(Math.E, (-L_A - 42.0) \/ 92.0))));\n+        double D =\n+                Math.max(0.0, Math.min(1.0, vc[VC_F] * (1.0 - (1.0 \/ 3.6) * Math.pow(Math.E, (-L_A - 42.0) \/ 92.0))));\n@@ -613,3 +639,1 @@\n-                (D * Yw \/ RGB_w[0]) + (1.0 - D),\n-                (D * Yw \/ RGB_w[1]) + (1.0 - D),\n-                (D * Yw \/ RGB_w[2]) + (1.0 - D),\n+            (D * Yw \/ RGB_w[0]) + (1.0 - D), (D * Yw \/ RGB_w[1]) + (1.0 - D), (D * Yw \/ RGB_w[2]) + (1.0 - D),\n@@ -622,1 +646,1 @@\n-        vc[VC_F_L] = 0.2 * kpow4 * (L_Ax5) + 0.1 * Math.pow(1.0 - kpow4, 2.0) * Math.pow(L_Ax5, 1.0\/3.0);\n+        vc[VC_F_L] = 0.2 * kpow4 * (L_Ax5) + 0.1 * Math.pow(1.0 - kpow4, 2.0) * Math.pow(L_Ax5, 1.0 \/ 3.0);\n@@ -629,1 +653,2 @@\n-        vc[VC_N_CB] = vc[VC_N_BB]; \/\/ chromatic contrast factors (calculate increase in J, Q, and C caused by dark backgrounds)\n+        vc[VC_N_CB] = vc[\n+                VC_N_BB]; \/\/ chromatic contrast factors (calculate increase in J, Q, and C caused by dark backgrounds)\n@@ -635,2 +660,2 @@\n-        for(int channel = 0; channel < RGBPrime_w.length; channel++) {\n-            if(RGBPrime_w[channel] >= 0) {\n+        for (int channel = 0; channel < RGBPrime_w.length; channel++) {\n+            if (RGBPrime_w[channel] >= 0) {\n@@ -663,1 +688,1 @@\n-        return new double[] { x, y, z };\n+        return new double[] {x, y, z};\n@@ -677,1 +702,1 @@\n-        return new double[] { l, a, b };\n+        return new double[] {l, a, b};\n@@ -682,0 +707,1 @@\n+\n@@ -689,1 +715,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":95,"deletions":70,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -32,2 +32,1 @@\n-    private Curses() {\n-    }\n+    private Curses() {}\n@@ -98,3 +97,3 @@\n-\/\/                        case 'l':\n-\/\/                            rawPrint('\\l');\n-\/\/                            break;\n+                                \/\/                        case 'l':\n+                                \/\/                            rawPrint('\\l');\n+                                \/\/                            break;\n@@ -141,1 +140,1 @@\n-                        out.append((char)(ch - '@'));\n+                        out.append((char) (ch - '@'));\n@@ -198,1 +197,2 @@\n-                            while (str.charAt(index++) != '}') ;\n+                            while (str.charAt(index++) != '}')\n+                                ;\n@@ -367,4 +367,12 @@\n-                                    case '-': left = true; break;\n-                                    case '+': plus = true; break;\n-                                    case '#': alternate = true; break;\n-                                    case ' ': space = true; break;\n+                                    case '-':\n+                                        left = true;\n+                                        break;\n+                                    case '+':\n+                                        plus = true;\n+                                        break;\n+                                    case '#':\n+                                        alternate = true;\n+                                        break;\n+                                    case ' ':\n+                                        space = true;\n+                                        break;\n@@ -476,1 +484,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -28,1 +28,3 @@\n-        DELETE, INSERT, EQUAL\n+        DELETE,\n+        INSERT,\n+        EQUAL\n@@ -89,4 +91,2 @@\n-                if (startHiddenRange < 0)\n-                    startHiddenRange = commonStart;\n-            } else\n-                startHiddenRange = -1;\n+                if (startHiddenRange < 0) startHiddenRange = commonStart;\n+            } else startHiddenRange = -1;\n@@ -96,3 +96,2 @@\n-            && ((l1 > commonStart && text1.isHidden(commonStart))\n-                || (l2 > commonStart && text2.isHidden(commonStart))))\n-            commonStart = startHiddenRange;\n+                && ((l1 > commonStart && text1.isHidden(commonStart))\n+                        || (l2 > commonStart && text2.isHidden(commonStart)))) commonStart = startHiddenRange;\n@@ -106,4 +105,2 @@\n-                if (startHiddenRange < 0)\n-                    startHiddenRange = commonEnd;\n-            } else\n-                startHiddenRange = -1;\n+                if (startHiddenRange < 0) startHiddenRange = commonEnd;\n+            } else startHiddenRange = -1;\n@@ -112,2 +109,1 @@\n-        if (startHiddenRange >= 0)\n-            commonEnd = startHiddenRange;\n+        if (startHiddenRange >= 0) commonEnd = startHiddenRange;\n@@ -116,2 +112,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.EQUAL,\n-                    text1.subSequence(0, commonStart)));\n+            diffs.add(new Diff(DiffHelper.Operation.EQUAL, text1.subSequence(0, commonStart)));\n@@ -120,2 +115,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.INSERT,\n-                    text2.subSequence(commonStart, l2 - commonEnd)));\n+            diffs.add(new Diff(DiffHelper.Operation.INSERT, text2.subSequence(commonStart, l2 - commonEnd)));\n@@ -124,2 +118,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.DELETE,\n-                    text1.subSequence(commonStart, l1 - commonEnd)));\n+            diffs.add(new Diff(DiffHelper.Operation.DELETE, text1.subSequence(commonStart, l1 - commonEnd)));\n@@ -128,2 +121,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.EQUAL,\n-                    text1.subSequence(l1 - commonEnd, l1)));\n+            diffs.add(new Diff(DiffHelper.Operation.EQUAL, text1.subSequence(l1 - commonEnd, l1)));\n@@ -133,1 +125,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/DiffHelper.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -40,2 +40,2 @@\n-    private int columns;\n-    private int columns1; \/\/ columns+1\n+    protected int columns;\n+    protected int columns1; \/\/ columns+1\n@@ -52,0 +52,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -57,1 +58,1 @@\n-                            && can(Capability.delete_line, Capability.parm_delete_line);\n+                && can(Capability.delete_line, Capability.parm_delete_line);\n@@ -59,2 +60,1 @@\n-        this.delayedWrapAtEol = this.wrapAtEol\n-            && terminal.getBooleanCapability(Capability.eat_newline_glitch);\n+        this.delayedWrapAtEol = this.wrapAtEol && terminal.getBooleanCapability(Capability.eat_newline_glitch);\n@@ -72,1 +72,4 @@\n-    public void setDelayLineWrap(boolean v) { delayLineWrap = v; }\n+\n+    public void setDelayLineWrap(boolean v) {\n+        delayLineWrap = v;\n+    }\n@@ -76,1 +79,1 @@\n-            columns = Integer.MAX_VALUE - 1;\n+            columns = 1;\n@@ -83,1 +86,2 @@\n-            oldLines = AttributedString.join(AttributedString.EMPTY, oldLines).columnSplitLength(columns, true, delayLineWrap());\n+            oldLines = AttributedString.join(AttributedString.EMPTY, oldLines)\n+                    .columnSplitLength(columns, true, delayLineWrap());\n@@ -131,1 +135,2 @@\n-            newLines = newLines.stream().map(s -> new AttributedString(s.toString()))\n+            newLines = newLines.stream()\n+                    .map(s -> new AttributedString(s.toString()))\n@@ -141,2 +146,1 @@\n-            while (nbHeaders < l\n-                   && Objects.equals(newLines.get(nbHeaders), oldLines.get(nbHeaders))) {\n+            while (nbHeaders < l && Objects.equals(newLines.get(nbHeaders), oldLines.get(nbHeaders))) {\n@@ -146,1 +150,3 @@\n-                    && Objects.equals(newLines.get(newLines.size() - nbFooters - 1), oldLines.get(oldLines.size() - nbFooters - 1))) {\n+                    && Objects.equals(\n+                            newLines.get(newLines.size() - nbFooters - 1),\n+                            oldLines.get(oldLines.size() - nbFooters - 1))) {\n@@ -193,6 +199,2 @@\n-            AttributedString oldLine =\n-                lineIndex < oldLines.size() ? oldLines.get(lineIndex)\n-                : AttributedString.NEWLINE;\n-            AttributedString newLine =\n-                 lineIndex < newLines.size() ? newLines.get(lineIndex)\n-                : AttributedString.NEWLINE;\n+            AttributedString oldLine = lineIndex < oldLines.size() ? oldLines.get(lineIndex) : AttributedString.NEWLINE;\n+            AttributedString newLine = lineIndex < newLines.size() ? newLines.get(lineIndex) : AttributedString.NEWLINE;\n@@ -203,2 +205,2 @@\n-            boolean oldNL = oldLength > 0 && oldLine.charAt(oldLength-1)=='\\n';\n-            boolean newNL = newLength > 0 && newLine.charAt(newLength-1)=='\\n';\n+            boolean oldNL = oldLength > 0 && oldLine.charAt(oldLength - 1) == '\\n';\n+            boolean newNL = newLength > 0 && newLine.charAt(newLength - 1) == '\\n';\n@@ -213,3 +215,1 @@\n-            if (wrapNeeded\n-                && lineIndex == (cursorPos + 1) \/ columns1\n-                && lineIndex < newLines.size()) {\n+            if (wrapNeeded && lineIndex == (cursorPos + 1) \/ columns1 && lineIndex < newLines.size()) {\n@@ -253,2 +253,1 @@\n-                        if (i <= diffs.size() - 2\n-                                && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n+                        if (i <= diffs.size() - 2 && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n@@ -285,2 +284,1 @@\n-                        if (i <= diffs.size() - 2\n-                                && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n+                        if (i <= diffs.size() - 2 && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n@@ -308,4 +306,2 @@\n-            boolean newWrap = ! newNL && lineIndex < newLines.size();\n-            if (targetCursorPos + 1 == lineIndex * columns1\n-                && (newWrap || ! delayLineWrap))\n-                targetCursorPos++;\n+            boolean newWrap = !newNL && lineIndex < newLines.size();\n+            if (targetCursorPos + 1 == lineIndex * columns1 && (newWrap || !delayLineWrap)) targetCursorPos++;\n@@ -315,7 +311,5 @@\n-                boolean oldWrap = ! oldNL && lineIndex < oldLines.size();\n-                if (newWrap != oldWrap && ! (oldWrap && cleared)) {\n-                    moveVisualCursorTo(lineIndex*columns1-1, newLines);\n-                    if (newWrap)\n-                        wrapNeeded = true;\n-                    else\n-                        terminal.puts(Capability.clr_eol);\n+                boolean oldWrap = !oldNL && lineIndex < oldLines.size();\n+                if (newWrap != oldWrap && !(oldWrap && cleared)) {\n+                    moveVisualCursorTo(lineIndex * columns1 - 1, newLines);\n+                    if (newWrap) wrapNeeded = true;\n+                    else terminal.puts(Capability.clr_eol);\n@@ -325,2 +319,4 @@\n-                    terminal.writer().write(\" \\b\");\n-                    cursorPos++;\n+                    if (!fullScreen || (fullScreen && lineIndex < numLines)) {\n+                        terminal.writer().write(\" \\b\");\n+                        cursorPos++;\n+                    }\n@@ -361,2 +357,1 @@\n-        return terminal.getStringCapability(single) != null\n-                || terminal.getStringCapability(multi) != null;\n+        return terminal.getStringCapability(single) != null || terminal.getStringCapability(multi) != null;\n@@ -408,1 +403,1 @@\n-        return max != 0 ? new int[] { start1, start2, max } : null;\n+        return max != 0 ? new int[] {start1, start2, max} : null;\n@@ -416,2 +411,1 @@\n-    protected void moveVisualCursorTo(int targetPos,\n-                                      List<AttributedString> newLines) {\n+    protected void moveVisualCursorTo(int targetPos, List<AttributedString> newLines) {\n@@ -425,6 +419,5 @@\n-                AttributedString lastChar = row >= newLines.size() ? AttributedString.EMPTY\n-                    : newLines.get(row).columnSubSequence(columns-1, columns);\n-                if (lastChar.length() == 0)\n-                    rawPrint((int) ' ');\n-                else\n-                    rawPrint(lastChar);\n+                AttributedString lastChar = row >= newLines.size()\n+                        ? AttributedString.EMPTY\n+                        : newLines.get(row).columnSubSequence(columns - 1, columns);\n+                if (lastChar.length() == 0) rawPrint((int) ' ');\n+                else rawPrint(lastChar);\n@@ -502,1 +495,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":45,"deletions":53,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,2 +25,1 @@\n-    private ExecHelper() {\n-    }\n+    private ExecHelper() {}\n@@ -34,1 +33,1 @@\n-                Map<String,String> env = pb.environment();\n+                Map<String, String> env = pb.environment();\n@@ -93,1 +92,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ExecHelper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2009-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+\/**\n+ * A simple buffering output stream with no synchronization.\n+ *\/\n+public class FastBufferedOutputStream extends FilterOutputStream {\n+\n+    protected final byte[] buf = new byte[8192];\n+    protected int count;\n+\n+    public FastBufferedOutputStream(OutputStream out) {\n+        super(out);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        if (count >= buf.length) {\n+            flushBuffer();\n+        }\n+        buf[count++] = (byte) b;\n+    }\n+\n+    @Override\n+    public void write(byte b[], int off, int len) throws IOException {\n+        if (len >= buf.length) {\n+            flushBuffer();\n+            out.write(b, off, len);\n+            return;\n+        }\n+        if (len > buf.length - count) {\n+            flushBuffer();\n+        }\n+        System.arraycopy(b, off, buf, count, len);\n+        count += len;\n+    }\n+\n+    private void flushBuffer() throws IOException {\n+        if (count > 0) {\n+            out.write(buf, 0, count);\n+            count = 0;\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        flushBuffer();\n+        out.flush();\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/FastBufferedOutputStream.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -31,2 +31,1 @@\n-    private InfoCmp() {\n-    }\n+    private InfoCmp() {}\n@@ -36,465 +35,464 @@\n-\n-        auto_left_margin,           \/\/ auto_left_margin, bw, bw\n-        auto_right_margin,          \/\/ auto_right_margin, am, am\n-        back_color_erase,           \/\/ back_color_erase, bce, ut\n-        can_change,                 \/\/ can_change, ccc, cc\n-        ceol_standout_glitch,       \/\/ ceol_standout_glitch, xhp, xs\n-        col_addr_glitch,            \/\/ col_addr_glitch, xhpa, YA\n-        cpi_changes_res,            \/\/ cpi_changes_res, cpix, YF\n-        cr_cancels_micro_mode,      \/\/ cr_cancels_micro_mode, crxm, YB\n-        dest_tabs_magic_smso,       \/\/ dest_tabs_magic_smso, xt, xt\n-        eat_newline_glitch,         \/\/ eat_newline_glitch, xenl, xn\n-        erase_overstrike,           \/\/ erase_overstrike, eo, eo\n-        generic_type,               \/\/ generic_type, gn, gn\n-        hard_copy,                  \/\/ hard_copy, hc, hc\n-        hard_cursor,                \/\/ hard_cursor, chts, HC\n-        has_meta_key,               \/\/ has_meta_key, km, km\n-        has_print_wheel,            \/\/ has_print_wheel, daisy, YC\n-        has_status_line,            \/\/ has_status_line, hs, hs\n-        hue_lightness_saturation,   \/\/ hue_lightness_saturation, hls, hl\n-        insert_null_glitch,         \/\/ insert_null_glitch, in, in\n-        lpi_changes_res,            \/\/ lpi_changes_res, lpix, YG\n-        memory_above,               \/\/ memory_above, da, da\n-        memory_below,               \/\/ memory_below, db, db\n-        move_insert_mode,           \/\/ move_insert_mode, mir, mi\n-        move_standout_mode,         \/\/ move_standout_mode, msgr, ms\n-        needs_xon_xoff,             \/\/ needs_xon_xoff, nxon, nx\n-        no_esc_ctlc,                \/\/ no_esc_ctlc, xsb, xb\n-        no_pad_char,                \/\/ no_pad_char, npc, NP\n-        non_dest_scroll_region,     \/\/ non_dest_scroll_region, ndscr, ND\n-        non_rev_rmcup,              \/\/ non_rev_rmcup, nrrmc, NR\n-        over_strike,                \/\/ over_strike, os, os\n-        prtr_silent,                \/\/ prtr_silent, mc5i, 5i\n-        row_addr_glitch,            \/\/ row_addr_glitch, xvpa, YD\n-        semi_auto_right_margin,     \/\/ semi_auto_right_margin, sam, YE\n-        status_line_esc_ok,         \/\/ status_line_esc_ok, eslok, es\n-        tilde_glitch,               \/\/ tilde_glitch, hz, hz\n-        transparent_underline,      \/\/ transparent_underline, ul, ul\n-        xon_xoff,                   \/\/ xon_xoff, xon, xo\n-        columns,                    \/\/ columns, cols, co\n-        init_tabs,                  \/\/ init_tabs, it, it\n-        label_height,               \/\/ label_height, lh, lh\n-        label_width,                \/\/ label_width, lw, lw\n-        lines,                      \/\/ lines, lines, li\n-        lines_of_memory,            \/\/ lines_of_memory, lm, lm\n-        magic_cookie_glitch,        \/\/ magic_cookie_glitch, xmc, sg\n-        max_attributes,             \/\/ max_attributes, ma, ma\n-        max_colors,                 \/\/ max_colors, colors, Co\n-        max_pairs,                  \/\/ max_pairs, pairs, pa\n-        maximum_windows,            \/\/ maximum_windows, wnum, MW\n-        no_color_video,             \/\/ no_color_video, ncv, NC\n-        num_labels,                 \/\/ num_labels, nlab, Nl\n-        padding_baud_rate,          \/\/ padding_baud_rate, pb, pb\n-        virtual_terminal,           \/\/ virtual_terminal, vt, vt\n-        width_status_line,          \/\/ width_status_line, wsl, ws\n-        bit_image_entwining,        \/\/ bit_image_entwining, bitwin, Yo\n-        bit_image_type,             \/\/ bit_image_type, bitype, Yp\n-        buffer_capacity,            \/\/ buffer_capacity, bufsz, Ya\n-        buttons,                    \/\/ buttons, btns, BT\n-        dot_horz_spacing,           \/\/ dot_horz_spacing, spinh, Yc\n-        dot_vert_spacing,           \/\/ dot_vert_spacing, spinv, Yb\n-        max_micro_address,          \/\/ max_micro_address, maddr, Yd\n-        max_micro_jump,             \/\/ max_micro_jump, mjump, Ye\n-        micro_col_size,             \/\/ micro_col_size, mcs, Yf\n-        micro_line_size,            \/\/ micro_line_size, mls, Yg\n-        number_of_pins,             \/\/ number_of_pins, npins, Yh\n-        output_res_char,            \/\/ output_res_char, orc, Yi\n-        output_res_horz_inch,       \/\/ output_res_horz_inch, orhi, Yk\n-        output_res_line,            \/\/ output_res_line, orl, Yj\n-        output_res_vert_inch,       \/\/ output_res_vert_inch, orvi, Yl\n-        print_rate,                 \/\/ print_rate, cps, Ym\n-        wide_char_size,             \/\/ wide_char_size, widcs, Yn\n-        acs_chars,                  \/\/ acs_chars, acsc, ac\n-        back_tab,                   \/\/ back_tab, cbt, bt\n-        bell,                       \/\/ bell, bel, bl\n-        carriage_return,            \/\/ carriage_return, cr, cr\n-        change_char_pitch,          \/\/ change_char_pitch, cpi, ZA\n-        change_line_pitch,          \/\/ change_line_pitch, lpi, ZB\n-        change_res_horz,            \/\/ change_res_horz, chr, ZC\n-        change_res_vert,            \/\/ change_res_vert, cvr, ZD\n-        change_scroll_region,       \/\/ change_scroll_region, csr, cs\n-        char_padding,               \/\/ char_padding, rmp, rP\n-        clear_all_tabs,             \/\/ clear_all_tabs, tbc, ct\n-        clear_margins,              \/\/ clear_margins, mgc, MC\n-        clear_screen,               \/\/ clear_screen, clear, cl\n-        clr_bol,                    \/\/ clr_bol, el1, cb\n-        clr_eol,                    \/\/ clr_eol, el, ce\n-        clr_eos,                    \/\/ clr_eos, ed, cd\n-        column_address,             \/\/ column_address, hpa, ch\n-        command_character,          \/\/ command_character, cmdch, CC\n-        create_window,              \/\/ create_window, cwin, CW\n-        cursor_address,             \/\/ cursor_address, cup, cm\n-        cursor_down,                \/\/ cursor_down, cud1, do\n-        cursor_home,                \/\/ cursor_home, home, ho\n-        cursor_invisible,           \/\/ cursor_invisible, civis, vi\n-        cursor_left,                \/\/ cursor_left, cub1, le\n-        cursor_mem_address,         \/\/ cursor_mem_address, mrcup, CM\n-        cursor_normal,              \/\/ cursor_normal, cnorm, ve\n-        cursor_right,               \/\/ cursor_right, cuf1, nd\n-        cursor_to_ll,               \/\/ cursor_to_ll, ll, ll\n-        cursor_up,                  \/\/ cursor_up, cuu1, up\n-        cursor_visible,             \/\/ cursor_visible, cvvis, vs\n-        define_char,                \/\/ define_char, defc, ZE\n-        delete_character,           \/\/ delete_character, dch1, dc\n-        delete_line,                \/\/ delete_line, dl1, dl\n-        dial_phone,                 \/\/ dial_phone, dial, DI\n-        dis_status_line,            \/\/ dis_status_line, dsl, ds\n-        display_clock,              \/\/ display_clock, dclk, DK\n-        down_half_line,             \/\/ down_half_line, hd, hd\n-        ena_acs,                    \/\/ ena_acs, enacs, eA\n-        enter_alt_charset_mode,     \/\/ enter_alt_charset_mode, smacs, as\n-        enter_am_mode,              \/\/ enter_am_mode, smam, SA\n-        enter_blink_mode,           \/\/ enter_blink_mode, blink, mb\n-        enter_bold_mode,            \/\/ enter_bold_mode, bold, md\n-        enter_ca_mode,              \/\/ enter_ca_mode, smcup, ti\n-        enter_delete_mode,          \/\/ enter_delete_mode, smdc, dm\n-        enter_dim_mode,             \/\/ enter_dim_mode, dim, mh\n-        enter_doublewide_mode,      \/\/ enter_doublewide_mode, swidm, ZF\n-        enter_draft_quality,        \/\/ enter_draft_quality, sdrfq, ZG\n-        enter_insert_mode,          \/\/ enter_insert_mode, smir, im\n-        enter_italics_mode,         \/\/ enter_italics_mode, sitm, ZH\n-        enter_leftward_mode,        \/\/ enter_leftward_mode, slm, ZI\n-        enter_micro_mode,           \/\/ enter_micro_mode, smicm, ZJ\n-        enter_near_letter_quality,  \/\/ enter_near_letter_quality, snlq, ZK\n-        enter_normal_quality,       \/\/ enter_normal_quality, snrmq, ZL\n-        enter_protected_mode,       \/\/ enter_protected_mode, prot, mp\n-        enter_reverse_mode,         \/\/ enter_reverse_mode, rev, mr\n-        enter_secure_mode,          \/\/ enter_secure_mode, invis, mk\n-        enter_shadow_mode,          \/\/ enter_shadow_mode, sshm, ZM\n-        enter_standout_mode,        \/\/ enter_standout_mode, smso, so\n-        enter_subscript_mode,       \/\/ enter_subscript_mode, ssubm, ZN\n-        enter_superscript_mode,     \/\/ enter_superscript_mode, ssupm, ZO\n-        enter_underline_mode,       \/\/ enter_underline_mode, smul, us\n-        enter_upward_mode,          \/\/ enter_upward_mode, sum, ZP\n-        enter_xon_mode,             \/\/ enter_xon_mode, smxon, SX\n-        erase_chars,                \/\/ erase_chars, ech, ec\n-        exit_alt_charset_mode,      \/\/ exit_alt_charset_mode, rmacs, ae\n-        exit_am_mode,               \/\/ exit_am_mode, rmam, RA\n-        exit_attribute_mode,        \/\/ exit_attribute_mode, sgr0, me\n-        exit_ca_mode,               \/\/ exit_ca_mode, rmcup, te\n-        exit_delete_mode,           \/\/ exit_delete_mode, rmdc, ed\n-        exit_doublewide_mode,       \/\/ exit_doublewide_mode, rwidm, ZQ\n-        exit_insert_mode,           \/\/ exit_insert_mode, rmir, ei\n-        exit_italics_mode,          \/\/ exit_italics_mode, ritm, ZR\n-        exit_leftward_mode,         \/\/ exit_leftward_mode, rlm, ZS\n-        exit_micro_mode,            \/\/ exit_micro_mode, rmicm, ZT\n-        exit_shadow_mode,           \/\/ exit_shadow_mode, rshm, ZU\n-        exit_standout_mode,         \/\/ exit_standout_mode, rmso, se\n-        exit_subscript_mode,        \/\/ exit_subscript_mode, rsubm, ZV\n-        exit_superscript_mode,      \/\/ exit_superscript_mode, rsupm, ZW\n-        exit_underline_mode,        \/\/ exit_underline_mode, rmul, ue\n-        exit_upward_mode,           \/\/ exit_upward_mode, rum, ZX\n-        exit_xon_mode,              \/\/ exit_xon_mode, rmxon, RX\n-        fixed_pause,                \/\/ fixed_pause, pause, PA\n-        flash_hook,                 \/\/ flash_hook, hook, fh\n-        flash_screen,               \/\/ flash_screen, flash, vb\n-        form_feed,                  \/\/ form_feed, ff, ff\n-        from_status_line,           \/\/ from_status_line, fsl, fs\n-        goto_window,                \/\/ goto_window, wingo, WG\n-        hangup,                     \/\/ hangup, hup, HU\n-        init_1string,               \/\/ init_1string, is1, i1\n-        init_2string,               \/\/ init_2string, is2, is\n-        init_3string,               \/\/ init_3string, is3, i3\n-        init_file,                  \/\/ init_file, if, if\n-        init_prog,                  \/\/ init_prog, iprog, iP\n-        initialize_color,           \/\/ initialize_color, initc, Ic\n-        initialize_pair,            \/\/ initialize_pair, initp, Ip\n-        insert_character,           \/\/ insert_character, ich1, ic\n-        insert_line,                \/\/ insert_line, il1, al\n-        insert_padding,             \/\/ insert_padding, ip, ip\n-        key_a1,                     \/\/ key_a1, ka1, K1\n-        key_a3,                     \/\/ key_a3, ka3, K3\n-        key_b2,                     \/\/ key_b2, kb2, K2\n-        key_backspace,              \/\/ key_backspace, kbs, kb\n-        key_beg,                    \/\/ key_beg, kbeg, @1\n-        key_btab,                   \/\/ key_btab, kcbt, kB\n-        key_c1,                     \/\/ key_c1, kc1, K4\n-        key_c3,                     \/\/ key_c3, kc3, K5\n-        key_cancel,                 \/\/ key_cancel, kcan, @2\n-        key_catab,                  \/\/ key_catab, ktbc, ka\n-        key_clear,                  \/\/ key_clear, kclr, kC\n-        key_close,                  \/\/ key_close, kclo, @3\n-        key_command,                \/\/ key_command, kcmd, @4\n-        key_copy,                   \/\/ key_copy, kcpy, @5\n-        key_create,                 \/\/ key_create, kcrt, @6\n-        key_ctab,                   \/\/ key_ctab, kctab, kt\n-        key_dc,                     \/\/ key_dc, kdch1, kD\n-        key_dl,                     \/\/ key_dl, kdl1, kL\n-        key_down,                   \/\/ key_down, kcud1, kd\n-        key_eic,                    \/\/ key_eic, krmir, kM\n-        key_end,                    \/\/ key_end, kend, @7\n-        key_enter,                  \/\/ key_enter, kent, @8\n-        key_eol,                    \/\/ key_eol, kel, kE\n-        key_eos,                    \/\/ key_eos, ked, kS\n-        key_exit,                   \/\/ key_exit, kext, @9\n-        key_f0,                     \/\/ key_f0, kf0, k0\n-        key_f1,                     \/\/ key_f1, kf1, k1\n-        key_f10,                    \/\/ key_f10, kf10, k;\n-        key_f11,                    \/\/ key_f11, kf11, F1\n-        key_f12,                    \/\/ key_f12, kf12, F2\n-        key_f13,                    \/\/ key_f13, kf13, F3\n-        key_f14,                    \/\/ key_f14, kf14, F4\n-        key_f15,                    \/\/ key_f15, kf15, F5\n-        key_f16,                    \/\/ key_f16, kf16, F6\n-        key_f17,                    \/\/ key_f17, kf17, F7\n-        key_f18,                    \/\/ key_f18, kf18, F8\n-        key_f19,                    \/\/ key_f19, kf19, F9\n-        key_f2,                     \/\/ key_f2, kf2, k2\n-        key_f20,                    \/\/ key_f20, kf20, FA\n-        key_f21,                    \/\/ key_f21, kf21, FB\n-        key_f22,                    \/\/ key_f22, kf22, FC\n-        key_f23,                    \/\/ key_f23, kf23, FD\n-        key_f24,                    \/\/ key_f24, kf24, FE\n-        key_f25,                    \/\/ key_f25, kf25, FF\n-        key_f26,                    \/\/ key_f26, kf26, FG\n-        key_f27,                    \/\/ key_f27, kf27, FH\n-        key_f28,                    \/\/ key_f28, kf28, FI\n-        key_f29,                    \/\/ key_f29, kf29, FJ\n-        key_f3,                     \/\/ key_f3, kf3, k3\n-        key_f30,                    \/\/ key_f30, kf30, FK\n-        key_f31,                    \/\/ key_f31, kf31, FL\n-        key_f32,                    \/\/ key_f32, kf32, FM\n-        key_f33,                    \/\/ key_f33, kf33, FN\n-        key_f34,                    \/\/ key_f34, kf34, FO\n-        key_f35,                    \/\/ key_f35, kf35, FP\n-        key_f36,                    \/\/ key_f36, kf36, FQ\n-        key_f37,                    \/\/ key_f37, kf37, FR\n-        key_f38,                    \/\/ key_f38, kf38, FS\n-        key_f39,                    \/\/ key_f39, kf39, FT\n-        key_f4,                     \/\/ key_f4, kf4, k4\n-        key_f40,                    \/\/ key_f40, kf40, FU\n-        key_f41,                    \/\/ key_f41, kf41, FV\n-        key_f42,                    \/\/ key_f42, kf42, FW\n-        key_f43,                    \/\/ key_f43, kf43, FX\n-        key_f44,                    \/\/ key_f44, kf44, FY\n-        key_f45,                    \/\/ key_f45, kf45, FZ\n-        key_f46,                    \/\/ key_f46, kf46, Fa\n-        key_f47,                    \/\/ key_f47, kf47, Fb\n-        key_f48,                    \/\/ key_f48, kf48, Fc\n-        key_f49,                    \/\/ key_f49, kf49, Fd\n-        key_f5,                     \/\/ key_f5, kf5, k5\n-        key_f50,                    \/\/ key_f50, kf50, Fe\n-        key_f51,                    \/\/ key_f51, kf51, Ff\n-        key_f52,                    \/\/ key_f52, kf52, Fg\n-        key_f53,                    \/\/ key_f53, kf53, Fh\n-        key_f54,                    \/\/ key_f54, kf54, Fi\n-        key_f55,                    \/\/ key_f55, kf55, Fj\n-        key_f56,                    \/\/ key_f56, kf56, Fk\n-        key_f57,                    \/\/ key_f57, kf57, Fl\n-        key_f58,                    \/\/ key_f58, kf58, Fm\n-        key_f59,                    \/\/ key_f59, kf59, Fn\n-        key_f6,                     \/\/ key_f6, kf6, k6\n-        key_f60,                    \/\/ key_f60, kf60, Fo\n-        key_f61,                    \/\/ key_f61, kf61, Fp\n-        key_f62,                    \/\/ key_f62, kf62, Fq\n-        key_f63,                    \/\/ key_f63, kf63, Fr\n-        key_f7,                     \/\/ key_f7, kf7, k7\n-        key_f8,                     \/\/ key_f8, kf8, k8\n-        key_f9,                     \/\/ key_f9, kf9, k9\n-        key_find,                   \/\/ key_find, kfnd, @0\n-        key_help,                   \/\/ key_help, khlp, %1\n-        key_home,                   \/\/ key_home, khome, kh\n-        key_ic,                     \/\/ key_ic, kich1, kI\n-        key_il,                     \/\/ key_il, kil1, kA\n-        key_left,                   \/\/ key_left, kcub1, kl\n-        key_ll,                     \/\/ key_ll, kll, kH\n-        key_mark,                   \/\/ key_mark, kmrk, %2\n-        key_message,                \/\/ key_message, kmsg, %3\n-        key_move,                   \/\/ key_move, kmov, %4\n-        key_next,                   \/\/ key_next, knxt, %5\n-        key_npage,                  \/\/ key_npage, knp, kN\n-        key_open,                   \/\/ key_open, kopn, %6\n-        key_options,                \/\/ key_options, kopt, %7\n-        key_ppage,                  \/\/ key_ppage, kpp, kP\n-        key_previous,               \/\/ key_previous, kprv, %8\n-        key_print,                  \/\/ key_print, kprt, %9\n-        key_redo,                   \/\/ key_redo, krdo, %0\n-        key_reference,              \/\/ key_reference, kref, &1\n-        key_refresh,                \/\/ key_refresh, krfr, &2\n-        key_replace,                \/\/ key_replace, krpl, &3\n-        key_restart,                \/\/ key_restart, krst, &4\n-        key_resume,                 \/\/ key_resume, kres, &5\n-        key_right,                  \/\/ key_right, kcuf1, kr\n-        key_save,                   \/\/ key_save, ksav, &6\n-        key_sbeg,                   \/\/ key_sbeg, kBEG, &9\n-        key_scancel,                \/\/ key_scancel, kCAN, &0\n-        key_scommand,               \/\/ key_scommand, kCMD, *1\n-        key_scopy,                  \/\/ key_scopy, kCPY, *2\n-        key_screate,                \/\/ key_screate, kCRT, *3\n-        key_sdc,                    \/\/ key_sdc, kDC, *4\n-        key_sdl,                    \/\/ key_sdl, kDL, *5\n-        key_select,                 \/\/ key_select, kslt, *6\n-        key_send,                   \/\/ key_send, kEND, *7\n-        key_seol,                   \/\/ key_seol, kEOL, *8\n-        key_sexit,                  \/\/ key_sexit, kEXT, *9\n-        key_sf,                     \/\/ key_sf, kind, kF\n-        key_sfind,                  \/\/ key_sfind, kFND, *0\n-        key_shelp,                  \/\/ key_shelp, kHLP, #1\n-        key_shome,                  \/\/ key_shome, kHOM, #2\n-        key_sic,                    \/\/ key_sic, kIC, #3\n-        key_sleft,                  \/\/ key_sleft, kLFT, #4\n-        key_smessage,               \/\/ key_smessage, kMSG, %a\n-        key_smove,                  \/\/ key_smove, kMOV, %b\n-        key_snext,                  \/\/ key_snext, kNXT, %c\n-        key_soptions,               \/\/ key_soptions, kOPT, %d\n-        key_sprevious,              \/\/ key_sprevious, kPRV, %e\n-        key_sprint,                 \/\/ key_sprint, kPRT, %f\n-        key_sr,                     \/\/ key_sr, kri, kR\n-        key_sredo,                  \/\/ key_sredo, kRDO, %g\n-        key_sreplace,               \/\/ key_sreplace, kRPL, %h\n-        key_sright,                 \/\/ key_sright, kRIT, %i\n-        key_srsume,                 \/\/ key_srsume, kRES, %j\n-        key_ssave,                  \/\/ key_ssave, kSAV, !1\n-        key_ssuspend,               \/\/ key_ssuspend, kSPD, !2\n-        key_stab,                   \/\/ key_stab, khts, kT\n-        key_sundo,                  \/\/ key_sundo, kUND, !3\n-        key_suspend,                \/\/ key_suspend, kspd, &7\n-        key_undo,                   \/\/ key_undo, kund, &8\n-        key_up,                     \/\/ key_up, kcuu1, ku\n-        keypad_local,               \/\/ keypad_local, rmkx, ke\n-        keypad_xmit,                \/\/ keypad_xmit, smkx, ks\n-        lab_f0,                     \/\/ lab_f0, lf0, l0\n-        lab_f1,                     \/\/ lab_f1, lf1, l1\n-        lab_f10,                    \/\/ lab_f10, lf10, la\n-        lab_f2,                     \/\/ lab_f2, lf2, l2\n-        lab_f3,                     \/\/ lab_f3, lf3, l3\n-        lab_f4,                     \/\/ lab_f4, lf4, l4\n-        lab_f5,                     \/\/ lab_f5, lf5, l5\n-        lab_f6,                     \/\/ lab_f6, lf6, l6\n-        lab_f7,                     \/\/ lab_f7, lf7, l7\n-        lab_f8,                     \/\/ lab_f8, lf8, l8\n-        lab_f9,                     \/\/ lab_f9, lf9, l9\n-        label_format,               \/\/ label_format, fln, Lf\n-        label_off,                  \/\/ label_off, rmln, LF\n-        label_on,                   \/\/ label_on, smln, LO\n-        meta_off,                   \/\/ meta_off, rmm, mo\n-        meta_on,                    \/\/ meta_on, smm, mm\n-        micro_column_address,       \/\/ micro_column_address, mhpa, ZY\n-        micro_down,                 \/\/ micro_down, mcud1, ZZ\n-        micro_left,                 \/\/ micro_left, mcub1, Za\n-        micro_right,                \/\/ micro_right, mcuf1, Zb\n-        micro_row_address,          \/\/ micro_row_address, mvpa, Zc\n-        micro_up,                   \/\/ micro_up, mcuu1, Zd\n-        newline,                    \/\/ newline, nel, nw\n-        order_of_pins,              \/\/ order_of_pins, porder, Ze\n-        orig_colors,                \/\/ orig_colors, oc, oc\n-        orig_pair,                  \/\/ orig_pair, op, op\n-        pad_char,                   \/\/ pad_char, pad, pc\n-        parm_dch,                   \/\/ parm_dch, dch, DC\n-        parm_delete_line,           \/\/ parm_delete_line, dl, DL\n-        parm_down_cursor,           \/\/ parm_down_cursor, cud, DO\n-        parm_down_micro,            \/\/ parm_down_micro, mcud, Zf\n-        parm_ich,                   \/\/ parm_ich, ich, IC\n-        parm_index,                 \/\/ parm_index, indn, SF\n-        parm_insert_line,           \/\/ parm_insert_line, il, AL\n-        parm_left_cursor,           \/\/ parm_left_cursor, cub, LE\n-        parm_left_micro,            \/\/ parm_left_micro, mcub, Zg\n-        parm_right_cursor,          \/\/ parm_right_cursor, cuf, RI\n-        parm_right_micro,           \/\/ parm_right_micro, mcuf, Zh\n-        parm_rindex,                \/\/ parm_rindex, rin, SR\n-        parm_up_cursor,             \/\/ parm_up_cursor, cuu, UP\n-        parm_up_micro,              \/\/ parm_up_micro, mcuu, Zi\n-        pkey_key,                   \/\/ pkey_key, pfkey, pk\n-        pkey_local,                 \/\/ pkey_local, pfloc, pl\n-        pkey_xmit,                  \/\/ pkey_xmit, pfx, px\n-        plab_norm,                  \/\/ plab_norm, pln, pn\n-        print_screen,               \/\/ print_screen, mc0, ps\n-        prtr_non,                   \/\/ prtr_non, mc5p, pO\n-        prtr_off,                   \/\/ prtr_off, mc4, pf\n-        prtr_on,                    \/\/ prtr_on, mc5, po\n-        pulse,                      \/\/ pulse, pulse, PU\n-        quick_dial,                 \/\/ quick_dial, qdial, QD\n-        remove_clock,               \/\/ remove_clock, rmclk, RC\n-        repeat_char,                \/\/ repeat_char, rep, rp\n-        req_for_input,              \/\/ req_for_input, rfi, RF\n-        reset_1string,              \/\/ reset_1string, rs1, r1\n-        reset_2string,              \/\/ reset_2string, rs2, r2\n-        reset_3string,              \/\/ reset_3string, rs3, r3\n-        reset_file,                 \/\/ reset_file, rf, rf\n-        restore_cursor,             \/\/ restore_cursor, rc, rc\n-        row_address,                \/\/ row_address, vpa, cv\n-        save_cursor,                \/\/ save_cursor, sc, sc\n-        scroll_forward,             \/\/ scroll_forward, ind, sf\n-        scroll_reverse,             \/\/ scroll_reverse, ri, sr\n-        select_char_set,            \/\/ select_char_set, scs, Zj\n-        set_attributes,             \/\/ set_attributes, sgr, sa\n-        set_background,             \/\/ set_background, setb, Sb\n-        set_bottom_margin,          \/\/ set_bottom_margin, smgb, Zk\n-        set_bottom_margin_parm,     \/\/ set_bottom_margin_parm, smgbp, Zl\n-        set_clock,                  \/\/ set_clock, sclk, SC\n-        set_color_pair,             \/\/ set_color_pair, scp, sp\n-        set_foreground,             \/\/ set_foreground, setf, Sf\n-        set_left_margin,            \/\/ set_left_margin, smgl, ML\n-        set_left_margin_parm,       \/\/ set_left_margin_parm, smglp, Zm\n-        set_right_margin,           \/\/ set_right_margin, smgr, MR\n-        set_right_margin_parm,      \/\/ set_right_margin_parm, smgrp, Zn\n-        set_tab,                    \/\/ set_tab, hts, st\n-        set_top_margin,             \/\/ set_top_margin, smgt, Zo\n-        set_top_margin_parm,        \/\/ set_top_margin_parm, smgtp, Zp\n-        set_window,                 \/\/ set_window, wind, wi\n-        start_bit_image,            \/\/ start_bit_image, sbim, Zq\n-        start_char_set_def,         \/\/ start_char_set_def, scsd, Zr\n-        stop_bit_image,             \/\/ stop_bit_image, rbim, Zs\n-        stop_char_set_def,          \/\/ stop_char_set_def, rcsd, Zt\n-        subscript_characters,       \/\/ subscript_characters, subcs, Zu\n-        superscript_characters,     \/\/ superscript_characters, supcs, Zv\n-        tab,                        \/\/ tab, ht, ta\n-        these_cause_cr,             \/\/ these_cause_cr, docr, Zw\n-        to_status_line,             \/\/ to_status_line, tsl, ts\n-        tone,                       \/\/ tone, tone, TO\n-        underline_char,             \/\/ underline_char, uc, uc\n-        up_half_line,               \/\/ up_half_line, hu, hu\n-        user0,                      \/\/ user0, u0, u0\n-        user1,                      \/\/ user1, u1, u1\n-        user2,                      \/\/ user2, u2, u2\n-        user3,                      \/\/ user3, u3, u3\n-        user4,                      \/\/ user4, u4, u4\n-        user5,                      \/\/ user5, u5, u5\n-        user6,                      \/\/ user6, u6, u6\n-        user7,                      \/\/ user7, u7, u7\n-        user8,                      \/\/ user8, u8, u8\n-        user9,                      \/\/ user9, u9, u9\n-        wait_tone,                  \/\/ wait_tone, wait, WA\n-        xoff_character,             \/\/ xoff_character, xoffc, XF\n-        xon_character,              \/\/ xon_character, xonc, XN\n-        zero_motion,                \/\/ zero_motion, zerom, Zx\n-        alt_scancode_esc,           \/\/ alt_scancode_esc, scesa, S8\n-        bit_image_carriage_return,  \/\/ bit_image_carriage_return, bicr, Yv\n-        bit_image_newline,          \/\/ bit_image_newline, binel, Zz\n-        bit_image_repeat,           \/\/ bit_image_repeat, birep, Xy\n-        char_set_names,             \/\/ char_set_names, csnm, Zy\n-        code_set_init,              \/\/ code_set_init, csin, ci\n-        color_names,                \/\/ color_names, colornm, Yw\n-        define_bit_image_region,    \/\/ define_bit_image_region, defbi, Yx\n-        device_type,                \/\/ device_type, devt, dv\n-        display_pc_char,            \/\/ display_pc_char, dispc, S1\n-        end_bit_image_region,       \/\/ end_bit_image_region, endbi, Yy\n-        enter_pc_charset_mode,      \/\/ enter_pc_charset_mode, smpch, S2\n-        enter_scancode_mode,        \/\/ enter_scancode_mode, smsc, S4\n-        exit_pc_charset_mode,       \/\/ exit_pc_charset_mode, rmpch, S3\n-        exit_scancode_mode,         \/\/ exit_scancode_mode, rmsc, S5\n-        get_mouse,                  \/\/ get_mouse, getm, Gm\n-        key_mouse,                  \/\/ key_mouse, kmous, Km\n-        mouse_info,                 \/\/ mouse_info, minfo, Mi\n-        pc_term_options,            \/\/ pc_term_options, pctrm, S6\n-        pkey_plab,                  \/\/ pkey_plab, pfxl, xl\n-        req_mouse_pos,              \/\/ req_mouse_pos, reqmp, RQ\n-        scancode_escape,            \/\/ scancode_escape, scesc, S7\n-        set0_des_seq,               \/\/ set0_des_seq, s0ds, s0\n-        set1_des_seq,               \/\/ set1_des_seq, s1ds, s1\n-        set2_des_seq,               \/\/ set2_des_seq, s2ds, s2\n-        set3_des_seq,               \/\/ set3_des_seq, s3ds, s3\n-        set_a_background,           \/\/ set_a_background, setab, AB\n-        set_a_foreground,           \/\/ set_a_foreground, setaf, AF\n-        set_color_band,             \/\/ set_color_band, setcolor, Yz\n-        set_lr_margin,              \/\/ set_lr_margin, smglr, ML\n-        set_page_length,            \/\/ set_page_length, slines, YZ\n-        set_tb_margin,              \/\/ set_tb_margin, smgtb, MT\n-        enter_horizontal_hl_mode,   \/\/ enter_horizontal_hl_mode, ehhlm, Xh\n-        enter_left_hl_mode,         \/\/ enter_left_hl_mode, elhlm, Xl\n-        enter_low_hl_mode,          \/\/ enter_low_hl_mode, elohlm, Xo\n-        enter_right_hl_mode,        \/\/ enter_right_hl_mode, erhlm, Xr\n-        enter_top_hl_mode,          \/\/ enter_top_hl_mode, ethlm, Xt\n-        enter_vertical_hl_mode,     \/\/ enter_vertical_hl_mode, evhlm, Xv\n-        set_a_attributes,           \/\/ set_a_attributes, sgr1, sA\n-        set_pglen_inch,             \/\/ set_pglen_inch, slength, sL)\n+        auto_left_margin, \/\/ auto_left_margin, bw, bw\n+        auto_right_margin, \/\/ auto_right_margin, am, am\n+        back_color_erase, \/\/ back_color_erase, bce, ut\n+        can_change, \/\/ can_change, ccc, cc\n+        ceol_standout_glitch, \/\/ ceol_standout_glitch, xhp, xs\n+        col_addr_glitch, \/\/ col_addr_glitch, xhpa, YA\n+        cpi_changes_res, \/\/ cpi_changes_res, cpix, YF\n+        cr_cancels_micro_mode, \/\/ cr_cancels_micro_mode, crxm, YB\n+        dest_tabs_magic_smso, \/\/ dest_tabs_magic_smso, xt, xt\n+        eat_newline_glitch, \/\/ eat_newline_glitch, xenl, xn\n+        erase_overstrike, \/\/ erase_overstrike, eo, eo\n+        generic_type, \/\/ generic_type, gn, gn\n+        hard_copy, \/\/ hard_copy, hc, hc\n+        hard_cursor, \/\/ hard_cursor, chts, HC\n+        has_meta_key, \/\/ has_meta_key, km, km\n+        has_print_wheel, \/\/ has_print_wheel, daisy, YC\n+        has_status_line, \/\/ has_status_line, hs, hs\n+        hue_lightness_saturation, \/\/ hue_lightness_saturation, hls, hl\n+        insert_null_glitch, \/\/ insert_null_glitch, in, in\n+        lpi_changes_res, \/\/ lpi_changes_res, lpix, YG\n+        memory_above, \/\/ memory_above, da, da\n+        memory_below, \/\/ memory_below, db, db\n+        move_insert_mode, \/\/ move_insert_mode, mir, mi\n+        move_standout_mode, \/\/ move_standout_mode, msgr, ms\n+        needs_xon_xoff, \/\/ needs_xon_xoff, nxon, nx\n+        no_esc_ctlc, \/\/ no_esc_ctlc, xsb, xb\n+        no_pad_char, \/\/ no_pad_char, npc, NP\n+        non_dest_scroll_region, \/\/ non_dest_scroll_region, ndscr, ND\n+        non_rev_rmcup, \/\/ non_rev_rmcup, nrrmc, NR\n+        over_strike, \/\/ over_strike, os, os\n+        prtr_silent, \/\/ prtr_silent, mc5i, 5i\n+        row_addr_glitch, \/\/ row_addr_glitch, xvpa, YD\n+        semi_auto_right_margin, \/\/ semi_auto_right_margin, sam, YE\n+        status_line_esc_ok, \/\/ status_line_esc_ok, eslok, es\n+        tilde_glitch, \/\/ tilde_glitch, hz, hz\n+        transparent_underline, \/\/ transparent_underline, ul, ul\n+        xon_xoff, \/\/ xon_xoff, xon, xo\n+        columns, \/\/ columns, cols, co\n+        init_tabs, \/\/ init_tabs, it, it\n+        label_height, \/\/ label_height, lh, lh\n+        label_width, \/\/ label_width, lw, lw\n+        lines, \/\/ lines, lines, li\n+        lines_of_memory, \/\/ lines_of_memory, lm, lm\n+        magic_cookie_glitch, \/\/ magic_cookie_glitch, xmc, sg\n+        max_attributes, \/\/ max_attributes, ma, ma\n+        max_colors, \/\/ max_colors, colors, Co\n+        max_pairs, \/\/ max_pairs, pairs, pa\n+        maximum_windows, \/\/ maximum_windows, wnum, MW\n+        no_color_video, \/\/ no_color_video, ncv, NC\n+        num_labels, \/\/ num_labels, nlab, Nl\n+        padding_baud_rate, \/\/ padding_baud_rate, pb, pb\n+        virtual_terminal, \/\/ virtual_terminal, vt, vt\n+        width_status_line, \/\/ width_status_line, wsl, ws\n+        bit_image_entwining, \/\/ bit_image_entwining, bitwin, Yo\n+        bit_image_type, \/\/ bit_image_type, bitype, Yp\n+        buffer_capacity, \/\/ buffer_capacity, bufsz, Ya\n+        buttons, \/\/ buttons, btns, BT\n+        dot_horz_spacing, \/\/ dot_horz_spacing, spinh, Yc\n+        dot_vert_spacing, \/\/ dot_vert_spacing, spinv, Yb\n+        max_micro_address, \/\/ max_micro_address, maddr, Yd\n+        max_micro_jump, \/\/ max_micro_jump, mjump, Ye\n+        micro_col_size, \/\/ micro_col_size, mcs, Yf\n+        micro_line_size, \/\/ micro_line_size, mls, Yg\n+        number_of_pins, \/\/ number_of_pins, npins, Yh\n+        output_res_char, \/\/ output_res_char, orc, Yi\n+        output_res_horz_inch, \/\/ output_res_horz_inch, orhi, Yk\n+        output_res_line, \/\/ output_res_line, orl, Yj\n+        output_res_vert_inch, \/\/ output_res_vert_inch, orvi, Yl\n+        print_rate, \/\/ print_rate, cps, Ym\n+        wide_char_size, \/\/ wide_char_size, widcs, Yn\n+        acs_chars, \/\/ acs_chars, acsc, ac\n+        back_tab, \/\/ back_tab, cbt, bt\n+        bell, \/\/ bell, bel, bl\n+        carriage_return, \/\/ carriage_return, cr, cr\n+        change_char_pitch, \/\/ change_char_pitch, cpi, ZA\n+        change_line_pitch, \/\/ change_line_pitch, lpi, ZB\n+        change_res_horz, \/\/ change_res_horz, chr, ZC\n+        change_res_vert, \/\/ change_res_vert, cvr, ZD\n+        change_scroll_region, \/\/ change_scroll_region, csr, cs\n+        char_padding, \/\/ char_padding, rmp, rP\n+        clear_all_tabs, \/\/ clear_all_tabs, tbc, ct\n+        clear_margins, \/\/ clear_margins, mgc, MC\n+        clear_screen, \/\/ clear_screen, clear, cl\n+        clr_bol, \/\/ clr_bol, el1, cb\n+        clr_eol, \/\/ clr_eol, el, ce\n+        clr_eos, \/\/ clr_eos, ed, cd\n+        column_address, \/\/ column_address, hpa, ch\n+        command_character, \/\/ command_character, cmdch, CC\n+        create_window, \/\/ create_window, cwin, CW\n+        cursor_address, \/\/ cursor_address, cup, cm\n+        cursor_down, \/\/ cursor_down, cud1, do\n+        cursor_home, \/\/ cursor_home, home, ho\n+        cursor_invisible, \/\/ cursor_invisible, civis, vi\n+        cursor_left, \/\/ cursor_left, cub1, le\n+        cursor_mem_address, \/\/ cursor_mem_address, mrcup, CM\n+        cursor_normal, \/\/ cursor_normal, cnorm, ve\n+        cursor_right, \/\/ cursor_right, cuf1, nd\n+        cursor_to_ll, \/\/ cursor_to_ll, ll, ll\n+        cursor_up, \/\/ cursor_up, cuu1, up\n+        cursor_visible, \/\/ cursor_visible, cvvis, vs\n+        define_char, \/\/ define_char, defc, ZE\n+        delete_character, \/\/ delete_character, dch1, dc\n+        delete_line, \/\/ delete_line, dl1, dl\n+        dial_phone, \/\/ dial_phone, dial, DI\n+        dis_status_line, \/\/ dis_status_line, dsl, ds\n+        display_clock, \/\/ display_clock, dclk, DK\n+        down_half_line, \/\/ down_half_line, hd, hd\n+        ena_acs, \/\/ ena_acs, enacs, eA\n+        enter_alt_charset_mode, \/\/ enter_alt_charset_mode, smacs, as\n+        enter_am_mode, \/\/ enter_am_mode, smam, SA\n+        enter_blink_mode, \/\/ enter_blink_mode, blink, mb\n+        enter_bold_mode, \/\/ enter_bold_mode, bold, md\n+        enter_ca_mode, \/\/ enter_ca_mode, smcup, ti\n+        enter_delete_mode, \/\/ enter_delete_mode, smdc, dm\n+        enter_dim_mode, \/\/ enter_dim_mode, dim, mh\n+        enter_doublewide_mode, \/\/ enter_doublewide_mode, swidm, ZF\n+        enter_draft_quality, \/\/ enter_draft_quality, sdrfq, ZG\n+        enter_insert_mode, \/\/ enter_insert_mode, smir, im\n+        enter_italics_mode, \/\/ enter_italics_mode, sitm, ZH\n+        enter_leftward_mode, \/\/ enter_leftward_mode, slm, ZI\n+        enter_micro_mode, \/\/ enter_micro_mode, smicm, ZJ\n+        enter_near_letter_quality, \/\/ enter_near_letter_quality, snlq, ZK\n+        enter_normal_quality, \/\/ enter_normal_quality, snrmq, ZL\n+        enter_protected_mode, \/\/ enter_protected_mode, prot, mp\n+        enter_reverse_mode, \/\/ enter_reverse_mode, rev, mr\n+        enter_secure_mode, \/\/ enter_secure_mode, invis, mk\n+        enter_shadow_mode, \/\/ enter_shadow_mode, sshm, ZM\n+        enter_standout_mode, \/\/ enter_standout_mode, smso, so\n+        enter_subscript_mode, \/\/ enter_subscript_mode, ssubm, ZN\n+        enter_superscript_mode, \/\/ enter_superscript_mode, ssupm, ZO\n+        enter_underline_mode, \/\/ enter_underline_mode, smul, us\n+        enter_upward_mode, \/\/ enter_upward_mode, sum, ZP\n+        enter_xon_mode, \/\/ enter_xon_mode, smxon, SX\n+        erase_chars, \/\/ erase_chars, ech, ec\n+        exit_alt_charset_mode, \/\/ exit_alt_charset_mode, rmacs, ae\n+        exit_am_mode, \/\/ exit_am_mode, rmam, RA\n+        exit_attribute_mode, \/\/ exit_attribute_mode, sgr0, me\n+        exit_ca_mode, \/\/ exit_ca_mode, rmcup, te\n+        exit_delete_mode, \/\/ exit_delete_mode, rmdc, ed\n+        exit_doublewide_mode, \/\/ exit_doublewide_mode, rwidm, ZQ\n+        exit_insert_mode, \/\/ exit_insert_mode, rmir, ei\n+        exit_italics_mode, \/\/ exit_italics_mode, ritm, ZR\n+        exit_leftward_mode, \/\/ exit_leftward_mode, rlm, ZS\n+        exit_micro_mode, \/\/ exit_micro_mode, rmicm, ZT\n+        exit_shadow_mode, \/\/ exit_shadow_mode, rshm, ZU\n+        exit_standout_mode, \/\/ exit_standout_mode, rmso, se\n+        exit_subscript_mode, \/\/ exit_subscript_mode, rsubm, ZV\n+        exit_superscript_mode, \/\/ exit_superscript_mode, rsupm, ZW\n+        exit_underline_mode, \/\/ exit_underline_mode, rmul, ue\n+        exit_upward_mode, \/\/ exit_upward_mode, rum, ZX\n+        exit_xon_mode, \/\/ exit_xon_mode, rmxon, RX\n+        fixed_pause, \/\/ fixed_pause, pause, PA\n+        flash_hook, \/\/ flash_hook, hook, fh\n+        flash_screen, \/\/ flash_screen, flash, vb\n+        form_feed, \/\/ form_feed, ff, ff\n+        from_status_line, \/\/ from_status_line, fsl, fs\n+        goto_window, \/\/ goto_window, wingo, WG\n+        hangup, \/\/ hangup, hup, HU\n+        init_1string, \/\/ init_1string, is1, i1\n+        init_2string, \/\/ init_2string, is2, is\n+        init_3string, \/\/ init_3string, is3, i3\n+        init_file, \/\/ init_file, if, if\n+        init_prog, \/\/ init_prog, iprog, iP\n+        initialize_color, \/\/ initialize_color, initc, Ic\n+        initialize_pair, \/\/ initialize_pair, initp, Ip\n+        insert_character, \/\/ insert_character, ich1, ic\n+        insert_line, \/\/ insert_line, il1, al\n+        insert_padding, \/\/ insert_padding, ip, ip\n+        key_a1, \/\/ key_a1, ka1, K1\n+        key_a3, \/\/ key_a3, ka3, K3\n+        key_b2, \/\/ key_b2, kb2, K2\n+        key_backspace, \/\/ key_backspace, kbs, kb\n+        key_beg, \/\/ key_beg, kbeg, @1\n+        key_btab, \/\/ key_btab, kcbt, kB\n+        key_c1, \/\/ key_c1, kc1, K4\n+        key_c3, \/\/ key_c3, kc3, K5\n+        key_cancel, \/\/ key_cancel, kcan, @2\n+        key_catab, \/\/ key_catab, ktbc, ka\n+        key_clear, \/\/ key_clear, kclr, kC\n+        key_close, \/\/ key_close, kclo, @3\n+        key_command, \/\/ key_command, kcmd, @4\n+        key_copy, \/\/ key_copy, kcpy, @5\n+        key_create, \/\/ key_create, kcrt, @6\n+        key_ctab, \/\/ key_ctab, kctab, kt\n+        key_dc, \/\/ key_dc, kdch1, kD\n+        key_dl, \/\/ key_dl, kdl1, kL\n+        key_down, \/\/ key_down, kcud1, kd\n+        key_eic, \/\/ key_eic, krmir, kM\n+        key_end, \/\/ key_end, kend, @7\n+        key_enter, \/\/ key_enter, kent, @8\n+        key_eol, \/\/ key_eol, kel, kE\n+        key_eos, \/\/ key_eos, ked, kS\n+        key_exit, \/\/ key_exit, kext, @9\n+        key_f0, \/\/ key_f0, kf0, k0\n+        key_f1, \/\/ key_f1, kf1, k1\n+        key_f10, \/\/ key_f10, kf10, k;\n+        key_f11, \/\/ key_f11, kf11, F1\n+        key_f12, \/\/ key_f12, kf12, F2\n+        key_f13, \/\/ key_f13, kf13, F3\n+        key_f14, \/\/ key_f14, kf14, F4\n+        key_f15, \/\/ key_f15, kf15, F5\n+        key_f16, \/\/ key_f16, kf16, F6\n+        key_f17, \/\/ key_f17, kf17, F7\n+        key_f18, \/\/ key_f18, kf18, F8\n+        key_f19, \/\/ key_f19, kf19, F9\n+        key_f2, \/\/ key_f2, kf2, k2\n+        key_f20, \/\/ key_f20, kf20, FA\n+        key_f21, \/\/ key_f21, kf21, FB\n+        key_f22, \/\/ key_f22, kf22, FC\n+        key_f23, \/\/ key_f23, kf23, FD\n+        key_f24, \/\/ key_f24, kf24, FE\n+        key_f25, \/\/ key_f25, kf25, FF\n+        key_f26, \/\/ key_f26, kf26, FG\n+        key_f27, \/\/ key_f27, kf27, FH\n+        key_f28, \/\/ key_f28, kf28, FI\n+        key_f29, \/\/ key_f29, kf29, FJ\n+        key_f3, \/\/ key_f3, kf3, k3\n+        key_f30, \/\/ key_f30, kf30, FK\n+        key_f31, \/\/ key_f31, kf31, FL\n+        key_f32, \/\/ key_f32, kf32, FM\n+        key_f33, \/\/ key_f33, kf33, FN\n+        key_f34, \/\/ key_f34, kf34, FO\n+        key_f35, \/\/ key_f35, kf35, FP\n+        key_f36, \/\/ key_f36, kf36, FQ\n+        key_f37, \/\/ key_f37, kf37, FR\n+        key_f38, \/\/ key_f38, kf38, FS\n+        key_f39, \/\/ key_f39, kf39, FT\n+        key_f4, \/\/ key_f4, kf4, k4\n+        key_f40, \/\/ key_f40, kf40, FU\n+        key_f41, \/\/ key_f41, kf41, FV\n+        key_f42, \/\/ key_f42, kf42, FW\n+        key_f43, \/\/ key_f43, kf43, FX\n+        key_f44, \/\/ key_f44, kf44, FY\n+        key_f45, \/\/ key_f45, kf45, FZ\n+        key_f46, \/\/ key_f46, kf46, Fa\n+        key_f47, \/\/ key_f47, kf47, Fb\n+        key_f48, \/\/ key_f48, kf48, Fc\n+        key_f49, \/\/ key_f49, kf49, Fd\n+        key_f5, \/\/ key_f5, kf5, k5\n+        key_f50, \/\/ key_f50, kf50, Fe\n+        key_f51, \/\/ key_f51, kf51, Ff\n+        key_f52, \/\/ key_f52, kf52, Fg\n+        key_f53, \/\/ key_f53, kf53, Fh\n+        key_f54, \/\/ key_f54, kf54, Fi\n+        key_f55, \/\/ key_f55, kf55, Fj\n+        key_f56, \/\/ key_f56, kf56, Fk\n+        key_f57, \/\/ key_f57, kf57, Fl\n+        key_f58, \/\/ key_f58, kf58, Fm\n+        key_f59, \/\/ key_f59, kf59, Fn\n+        key_f6, \/\/ key_f6, kf6, k6\n+        key_f60, \/\/ key_f60, kf60, Fo\n+        key_f61, \/\/ key_f61, kf61, Fp\n+        key_f62, \/\/ key_f62, kf62, Fq\n+        key_f63, \/\/ key_f63, kf63, Fr\n+        key_f7, \/\/ key_f7, kf7, k7\n+        key_f8, \/\/ key_f8, kf8, k8\n+        key_f9, \/\/ key_f9, kf9, k9\n+        key_find, \/\/ key_find, kfnd, @0\n+        key_help, \/\/ key_help, khlp, %1\n+        key_home, \/\/ key_home, khome, kh\n+        key_ic, \/\/ key_ic, kich1, kI\n+        key_il, \/\/ key_il, kil1, kA\n+        key_left, \/\/ key_left, kcub1, kl\n+        key_ll, \/\/ key_ll, kll, kH\n+        key_mark, \/\/ key_mark, kmrk, %2\n+        key_message, \/\/ key_message, kmsg, %3\n+        key_move, \/\/ key_move, kmov, %4\n+        key_next, \/\/ key_next, knxt, %5\n+        key_npage, \/\/ key_npage, knp, kN\n+        key_open, \/\/ key_open, kopn, %6\n+        key_options, \/\/ key_options, kopt, %7\n+        key_ppage, \/\/ key_ppage, kpp, kP\n+        key_previous, \/\/ key_previous, kprv, %8\n+        key_print, \/\/ key_print, kprt, %9\n+        key_redo, \/\/ key_redo, krdo, %0\n+        key_reference, \/\/ key_reference, kref, &1\n+        key_refresh, \/\/ key_refresh, krfr, &2\n+        key_replace, \/\/ key_replace, krpl, &3\n+        key_restart, \/\/ key_restart, krst, &4\n+        key_resume, \/\/ key_resume, kres, &5\n+        key_right, \/\/ key_right, kcuf1, kr\n+        key_save, \/\/ key_save, ksav, &6\n+        key_sbeg, \/\/ key_sbeg, kBEG, &9\n+        key_scancel, \/\/ key_scancel, kCAN, &0\n+        key_scommand, \/\/ key_scommand, kCMD, *1\n+        key_scopy, \/\/ key_scopy, kCPY, *2\n+        key_screate, \/\/ key_screate, kCRT, *3\n+        key_sdc, \/\/ key_sdc, kDC, *4\n+        key_sdl, \/\/ key_sdl, kDL, *5\n+        key_select, \/\/ key_select, kslt, *6\n+        key_send, \/\/ key_send, kEND, *7\n+        key_seol, \/\/ key_seol, kEOL, *8\n+        key_sexit, \/\/ key_sexit, kEXT, *9\n+        key_sf, \/\/ key_sf, kind, kF\n+        key_sfind, \/\/ key_sfind, kFND, *0\n+        key_shelp, \/\/ key_shelp, kHLP, #1\n+        key_shome, \/\/ key_shome, kHOM, #2\n+        key_sic, \/\/ key_sic, kIC, #3\n+        key_sleft, \/\/ key_sleft, kLFT, #4\n+        key_smessage, \/\/ key_smessage, kMSG, %a\n+        key_smove, \/\/ key_smove, kMOV, %b\n+        key_snext, \/\/ key_snext, kNXT, %c\n+        key_soptions, \/\/ key_soptions, kOPT, %d\n+        key_sprevious, \/\/ key_sprevious, kPRV, %e\n+        key_sprint, \/\/ key_sprint, kPRT, %f\n+        key_sr, \/\/ key_sr, kri, kR\n+        key_sredo, \/\/ key_sredo, kRDO, %g\n+        key_sreplace, \/\/ key_sreplace, kRPL, %h\n+        key_sright, \/\/ key_sright, kRIT, %i\n+        key_srsume, \/\/ key_srsume, kRES, %j\n+        key_ssave, \/\/ key_ssave, kSAV, !1\n+        key_ssuspend, \/\/ key_ssuspend, kSPD, !2\n+        key_stab, \/\/ key_stab, khts, kT\n+        key_sundo, \/\/ key_sundo, kUND, !3\n+        key_suspend, \/\/ key_suspend, kspd, &7\n+        key_undo, \/\/ key_undo, kund, &8\n+        key_up, \/\/ key_up, kcuu1, ku\n+        keypad_local, \/\/ keypad_local, rmkx, ke\n+        keypad_xmit, \/\/ keypad_xmit, smkx, ks\n+        lab_f0, \/\/ lab_f0, lf0, l0\n+        lab_f1, \/\/ lab_f1, lf1, l1\n+        lab_f10, \/\/ lab_f10, lf10, la\n+        lab_f2, \/\/ lab_f2, lf2, l2\n+        lab_f3, \/\/ lab_f3, lf3, l3\n+        lab_f4, \/\/ lab_f4, lf4, l4\n+        lab_f5, \/\/ lab_f5, lf5, l5\n+        lab_f6, \/\/ lab_f6, lf6, l6\n+        lab_f7, \/\/ lab_f7, lf7, l7\n+        lab_f8, \/\/ lab_f8, lf8, l8\n+        lab_f9, \/\/ lab_f9, lf9, l9\n+        label_format, \/\/ label_format, fln, Lf\n+        label_off, \/\/ label_off, rmln, LF\n+        label_on, \/\/ label_on, smln, LO\n+        meta_off, \/\/ meta_off, rmm, mo\n+        meta_on, \/\/ meta_on, smm, mm\n+        micro_column_address, \/\/ micro_column_address, mhpa, ZY\n+        micro_down, \/\/ micro_down, mcud1, ZZ\n+        micro_left, \/\/ micro_left, mcub1, Za\n+        micro_right, \/\/ micro_right, mcuf1, Zb\n+        micro_row_address, \/\/ micro_row_address, mvpa, Zc\n+        micro_up, \/\/ micro_up, mcuu1, Zd\n+        newline, \/\/ newline, nel, nw\n+        order_of_pins, \/\/ order_of_pins, porder, Ze\n+        orig_colors, \/\/ orig_colors, oc, oc\n+        orig_pair, \/\/ orig_pair, op, op\n+        pad_char, \/\/ pad_char, pad, pc\n+        parm_dch, \/\/ parm_dch, dch, DC\n+        parm_delete_line, \/\/ parm_delete_line, dl, DL\n+        parm_down_cursor, \/\/ parm_down_cursor, cud, DO\n+        parm_down_micro, \/\/ parm_down_micro, mcud, Zf\n+        parm_ich, \/\/ parm_ich, ich, IC\n+        parm_index, \/\/ parm_index, indn, SF\n+        parm_insert_line, \/\/ parm_insert_line, il, AL\n+        parm_left_cursor, \/\/ parm_left_cursor, cub, LE\n+        parm_left_micro, \/\/ parm_left_micro, mcub, Zg\n+        parm_right_cursor, \/\/ parm_right_cursor, cuf, RI\n+        parm_right_micro, \/\/ parm_right_micro, mcuf, Zh\n+        parm_rindex, \/\/ parm_rindex, rin, SR\n+        parm_up_cursor, \/\/ parm_up_cursor, cuu, UP\n+        parm_up_micro, \/\/ parm_up_micro, mcuu, Zi\n+        pkey_key, \/\/ pkey_key, pfkey, pk\n+        pkey_local, \/\/ pkey_local, pfloc, pl\n+        pkey_xmit, \/\/ pkey_xmit, pfx, px\n+        plab_norm, \/\/ plab_norm, pln, pn\n+        print_screen, \/\/ print_screen, mc0, ps\n+        prtr_non, \/\/ prtr_non, mc5p, pO\n+        prtr_off, \/\/ prtr_off, mc4, pf\n+        prtr_on, \/\/ prtr_on, mc5, po\n+        pulse, \/\/ pulse, pulse, PU\n+        quick_dial, \/\/ quick_dial, qdial, QD\n+        remove_clock, \/\/ remove_clock, rmclk, RC\n+        repeat_char, \/\/ repeat_char, rep, rp\n+        req_for_input, \/\/ req_for_input, rfi, RF\n+        reset_1string, \/\/ reset_1string, rs1, r1\n+        reset_2string, \/\/ reset_2string, rs2, r2\n+        reset_3string, \/\/ reset_3string, rs3, r3\n+        reset_file, \/\/ reset_file, rf, rf\n+        restore_cursor, \/\/ restore_cursor, rc, rc\n+        row_address, \/\/ row_address, vpa, cv\n+        save_cursor, \/\/ save_cursor, sc, sc\n+        scroll_forward, \/\/ scroll_forward, ind, sf\n+        scroll_reverse, \/\/ scroll_reverse, ri, sr\n+        select_char_set, \/\/ select_char_set, scs, Zj\n+        set_attributes, \/\/ set_attributes, sgr, sa\n+        set_background, \/\/ set_background, setb, Sb\n+        set_bottom_margin, \/\/ set_bottom_margin, smgb, Zk\n+        set_bottom_margin_parm, \/\/ set_bottom_margin_parm, smgbp, Zl\n+        set_clock, \/\/ set_clock, sclk, SC\n+        set_color_pair, \/\/ set_color_pair, scp, sp\n+        set_foreground, \/\/ set_foreground, setf, Sf\n+        set_left_margin, \/\/ set_left_margin, smgl, ML\n+        set_left_margin_parm, \/\/ set_left_margin_parm, smglp, Zm\n+        set_right_margin, \/\/ set_right_margin, smgr, MR\n+        set_right_margin_parm, \/\/ set_right_margin_parm, smgrp, Zn\n+        set_tab, \/\/ set_tab, hts, st\n+        set_top_margin, \/\/ set_top_margin, smgt, Zo\n+        set_top_margin_parm, \/\/ set_top_margin_parm, smgtp, Zp\n+        set_window, \/\/ set_window, wind, wi\n+        start_bit_image, \/\/ start_bit_image, sbim, Zq\n+        start_char_set_def, \/\/ start_char_set_def, scsd, Zr\n+        stop_bit_image, \/\/ stop_bit_image, rbim, Zs\n+        stop_char_set_def, \/\/ stop_char_set_def, rcsd, Zt\n+        subscript_characters, \/\/ subscript_characters, subcs, Zu\n+        superscript_characters, \/\/ superscript_characters, supcs, Zv\n+        tab, \/\/ tab, ht, ta\n+        these_cause_cr, \/\/ these_cause_cr, docr, Zw\n+        to_status_line, \/\/ to_status_line, tsl, ts\n+        tone, \/\/ tone, tone, TO\n+        underline_char, \/\/ underline_char, uc, uc\n+        up_half_line, \/\/ up_half_line, hu, hu\n+        user0, \/\/ user0, u0, u0\n+        user1, \/\/ user1, u1, u1\n+        user2, \/\/ user2, u2, u2\n+        user3, \/\/ user3, u3, u3\n+        user4, \/\/ user4, u4, u4\n+        user5, \/\/ user5, u5, u5\n+        user6, \/\/ user6, u6, u6\n+        user7, \/\/ user7, u7, u7\n+        user8, \/\/ user8, u8, u8\n+        user9, \/\/ user9, u9, u9\n+        wait_tone, \/\/ wait_tone, wait, WA\n+        xoff_character, \/\/ xoff_character, xoffc, XF\n+        xon_character, \/\/ xon_character, xonc, XN\n+        zero_motion, \/\/ zero_motion, zerom, Zx\n+        alt_scancode_esc, \/\/ alt_scancode_esc, scesa, S8\n+        bit_image_carriage_return, \/\/ bit_image_carriage_return, bicr, Yv\n+        bit_image_newline, \/\/ bit_image_newline, binel, Zz\n+        bit_image_repeat, \/\/ bit_image_repeat, birep, Xy\n+        char_set_names, \/\/ char_set_names, csnm, Zy\n+        code_set_init, \/\/ code_set_init, csin, ci\n+        color_names, \/\/ color_names, colornm, Yw\n+        define_bit_image_region, \/\/ define_bit_image_region, defbi, Yx\n+        device_type, \/\/ device_type, devt, dv\n+        display_pc_char, \/\/ display_pc_char, dispc, S1\n+        end_bit_image_region, \/\/ end_bit_image_region, endbi, Yy\n+        enter_pc_charset_mode, \/\/ enter_pc_charset_mode, smpch, S2\n+        enter_scancode_mode, \/\/ enter_scancode_mode, smsc, S4\n+        exit_pc_charset_mode, \/\/ exit_pc_charset_mode, rmpch, S3\n+        exit_scancode_mode, \/\/ exit_scancode_mode, rmsc, S5\n+        get_mouse, \/\/ get_mouse, getm, Gm\n+        key_mouse, \/\/ key_mouse, kmous, Km\n+        mouse_info, \/\/ mouse_info, minfo, Mi\n+        pc_term_options, \/\/ pc_term_options, pctrm, S6\n+        pkey_plab, \/\/ pkey_plab, pfxl, xl\n+        req_mouse_pos, \/\/ req_mouse_pos, reqmp, RQ\n+        scancode_escape, \/\/ scancode_escape, scesc, S7\n+        set0_des_seq, \/\/ set0_des_seq, s0ds, s0\n+        set1_des_seq, \/\/ set1_des_seq, s1ds, s1\n+        set2_des_seq, \/\/ set2_des_seq, s2ds, s2\n+        set3_des_seq, \/\/ set3_des_seq, s3ds, s3\n+        set_a_background, \/\/ set_a_background, setab, AB\n+        set_a_foreground, \/\/ set_a_foreground, setaf, AF\n+        set_color_band, \/\/ set_color_band, setcolor, Yz\n+        set_lr_margin, \/\/ set_lr_margin, smglr, ML\n+        set_page_length, \/\/ set_page_length, slines, YZ\n+        set_tb_margin, \/\/ set_tb_margin, smgtb, MT\n+        enter_horizontal_hl_mode, \/\/ enter_horizontal_hl_mode, ehhlm, Xh\n+        enter_left_hl_mode, \/\/ enter_left_hl_mode, elhlm, Xl\n+        enter_low_hl_mode, \/\/ enter_low_hl_mode, elohlm, Xo\n+        enter_right_hl_mode, \/\/ enter_right_hl_mode, erhlm, Xr\n+        enter_top_hl_mode, \/\/ enter_top_hl_mode, ethlm, Xt\n+        enter_vertical_hl_mode, \/\/ enter_vertical_hl_mode, evhlm, Xv\n+        set_a_attributes, \/\/ set_a_attributes, sgr1, sA\n+        set_pglen_inch, \/\/ set_pglen_inch, slength, sL)\n@@ -518,2 +516,3 @@\n-             BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n-            br.lines().map(String::trim)\n+                BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+            br.lines()\n+                    .map(String::trim)\n@@ -542,3 +541,1 @@\n-    public static String getInfoCmp(\n-            String terminal\n-    ) throws IOException, InterruptedException {\n+    public static String getInfoCmp(String terminal) throws IOException, InterruptedException {\n@@ -566,2 +563,1 @@\n-            Map<Capability, String> strings\n-    ) {\n+            Map<Capability, String> strings) {\n@@ -612,1 +608,1 @@\n-             BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+                BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n@@ -620,3 +616,16 @@\n-        for (String s : Arrays.asList(\"dumb\", \"dumb-color\", \"ansi\", \"xterm\", \"xterm-256color\",\n-                \"windows\", \"windows-256color\", \"windows-conemu\", \"windows-vtp\",\n-                \"screen\", \"screen-256color\", \"rxvt-unicode\", \"rxvt-unicode-256color\", \"rxvt-basic\", \"rxvt\")) {\n+        for (String s : Arrays.asList(\n+                \"dumb\",\n+                \"dumb-color\",\n+                \"ansi\",\n+                \"xterm\",\n+                \"xterm-256color\",\n+                \"windows\",\n+                \"windows-256color\",\n+                \"windows-conemu\",\n+                \"windows-vtp\",\n+                \"screen\",\n+                \"screen-256color\",\n+                \"rxvt-unicode\",\n+                \"rxvt-unicode-256color\",\n+                \"rxvt-basic\",\n+                \"rxvt\")) {\n@@ -626,1 +635,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":488,"deletions":480,"binary":false,"changes":968,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,1 +25,0 @@\n-\n@@ -69,3 +68,4 @@\n-        decoder = Charset.defaultCharset().newDecoder().onMalformedInput(\n-                CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                CodingErrorAction.REPLACE);\n+        decoder = Charset.defaultCharset()\n+                .newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -90,2 +90,1 @@\n-    public InputStreamReader(InputStream in, final String enc)\n-            throws UnsupportedEncodingException {\n+    public InputStreamReader(InputStream in, final String enc) throws UnsupportedEncodingException {\n@@ -98,3 +97,4 @@\n-            decoder = Charset.forName(enc).newDecoder().onMalformedInput(\n-                    CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                    CodingErrorAction.REPLACE);\n+            decoder = Charset.forName(enc)\n+                    .newDecoder()\n+                    .onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -102,2 +102,1 @@\n-            throw (UnsupportedEncodingException)\n-                    new UnsupportedEncodingException(enc).initCause(e);\n+            throw (UnsupportedEncodingException) new UnsupportedEncodingException(enc).initCause(e);\n@@ -137,3 +136,3 @@\n-        decoder = charset.newDecoder().onMalformedInput(\n-                CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                CodingErrorAction.REPLACE);\n+        decoder = charset.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -260,2 +259,1 @@\n-                        if ((in.available() == 0)\n-                            && (out.position() > offset)) {\n+                        if ((in.available() == 0) && (out.position() > offset)) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InputStreamReader.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -52,3 +52,2 @@\n-    public static int distance(CharSequence source, CharSequence target,\n-                               int deleteCost, int insertCost,\n-                               int replaceCost, int swapCost) {\n+    public static int distance(\n+            CharSequence source, CharSequence target, int deleteCost, int insertCost, int replaceCost, int swapCost) {\n@@ -118,1 +117,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Levenshtein.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -76,2 +76,1 @@\n-        }\n-        else {\n+        } else {\n@@ -87,1 +86,1 @@\n-\/\/            \/\/ Special handling for the last message if its a throwable, render its stack on the next line\n+\/\/            \/\/ Special handling for the last message if it's a throwable, render its stack on the next line\n@@ -90,2 +89,1 @@\n-\/\/            }\n-\/\/            else {\n+\/\/            } else {\n@@ -125,1 +123,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Log.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -87,2 +87,1 @@\n-            return (int) (reader.available() * this.encoder.averageBytesPerChar())\n-                    + bytes.remaining();\n+            return (int) (reader.available() * this.encoder.averageBytesPerChar()) + bytes.remaining();\n@@ -127,1 +126,0 @@\n-\n@@ -138,4 +136,6 @@\n-            this(inputStream,\n-                (encoding != null ? encoding : Charset.defaultCharset()).newDecoder()\n-                    .onMalformedInput(CodingErrorAction.REPLACE)\n-                    .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+            this(\n+                    inputStream,\n+                    (encoding != null ? encoding : Charset.defaultCharset())\n+                            .newDecoder()\n+                            .onMalformedInput(CodingErrorAction.REPLACE)\n+                            .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -204,2 +204,2 @@\n-                    int nb = input.readBuffered(bytes.array(), bytes.limit(),\n-                                            bytes.capacity() - bytes.limit(), t.timeout());\n+                    int nb = input.readBuffered(\n+                            bytes.array(), bytes.limit(), bytes.capacity() - bytes.limit(), t.timeout());\n@@ -230,1 +230,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -77,1 +77,1 @@\n-        b[off] = (byte)c;\n+        b[off] = (byte) c;\n@@ -118,2 +118,1 @@\n-    public void shutdown() {\n-    }\n+    public void shutdown() {}\n@@ -122,1 +121,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -29,11 +29,9 @@\n-public class NonBlockingInputStreamImpl\n-    extends NonBlockingInputStream\n-{\n-    private InputStream in;                  \/\/ The actual input stream\n-    private int         b = READ_EXPIRED;    \/\/ Recently read byte\n-\n-    private String      name;\n-    private boolean     threadIsReading      = false;\n-    private IOException exception            = null;\n-    private long        threadDelay          = 60 * 1000;\n-    private Thread      thread;\n+public class NonBlockingInputStreamImpl extends NonBlockingInputStream {\n+    private InputStream in; \/\/ The actual input stream\n+    private int b = READ_EXPIRED; \/\/ Recently read byte\n+\n+    private String name;\n+    private boolean threadIsReading = false;\n+    private IOException exception = null;\n+    private long threadDelay = 60 * 1000;\n+    private Thread thread;\n@@ -100,2 +98,1 @@\n-            if (!isPeek)\n-                exception = null;\n+            if (!isPeek) exception = null;\n@@ -112,2 +109,1 @@\n-        }\n-        else if (!isPeek && timeout <= 0L && !threadIsReading) {\n+        } else if (!isPeek && timeout <= 0L && !threadIsReading) {\n@@ -115,2 +111,1 @@\n-        }\n-        else {\n+        } else {\n@@ -131,1 +126,1 @@\n-            while (!t.elapsed())  {\n+            while (!t.elapsed()) {\n@@ -137,2 +132,1 @@\n-                }\n-                catch (InterruptedException e) {\n+                } catch (InterruptedException e) {\n@@ -146,2 +140,1 @@\n-                    if (!isPeek)\n-                        exception = null;\n+                    if (!isPeek) exception = null;\n@@ -171,1 +164,1 @@\n-    private void run () {\n+    private void run() {\n@@ -239,1 +232,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStreamImpl.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -60,5 +60,1 @@\n-        return buffer.hasRemaining()\n-                ? 0\n-                : closed\n-                    ? EOF\n-                    : READ_EXPIRED;\n+        return buffer.hasRemaining() ? 0 : closed ? EOF : READ_EXPIRED;\n@@ -170,1 +166,1 @@\n-            NonBlockingPumpInputStream.this.write(new byte[] { (byte) b }, 0, 1);\n+            NonBlockingPumpInputStream.this.write(new byte[] {(byte) b}, 0, 1);\n@@ -187,1 +183,0 @@\n-\n@@ -189,1 +184,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -124,1 +124,1 @@\n-                                throw new IOException( \"Timeout reading\" );\n+                                throw new IOException(\"Timeout reading\");\n@@ -210,2 +210,1 @@\n-        public void flush() throws IOException {\n-        }\n+        public void flush() throws IOException {}\n@@ -217,1 +216,0 @@\n-\n@@ -219,1 +217,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -26,2 +26,1 @@\n-    public void shutdown() {\n-    }\n+    public void shutdown() {}\n@@ -112,1 +111,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -31,3 +31,1 @@\n-public class NonBlockingReaderImpl\n-    extends NonBlockingReader\n-{\n+public class NonBlockingReaderImpl extends NonBlockingReader {\n@@ -36,2 +34,2 @@\n-    private Reader in;                  \/\/ The actual input stream\n-    private int    ch   = READ_EXPIRED; \/\/ Recently read character\n+    private Reader in; \/\/ The actual input stream\n+    private int ch = READ_EXPIRED; \/\/ Recently read character\n@@ -39,5 +37,5 @@\n-    private String      name;\n-    private boolean     threadIsReading      = false;\n-    private IOException exception            = null;\n-    private long        threadDelay          = 60 * 1000;\n-    private Thread      thread;\n+    private String name;\n+    private boolean threadIsReading = false;\n+    private IOException exception = null;\n+    private long threadDelay = 60 * 1000;\n+    private Thread thread;\n@@ -138,2 +136,1 @@\n-            if (!isPeek)\n-                exception = null;\n+            if (!isPeek) exception = null;\n@@ -150,2 +147,1 @@\n-        }\n-        else if (!isPeek && timeout <= 0L && !threadIsReading) {\n+        } else if (!isPeek && timeout <= 0L && !threadIsReading) {\n@@ -153,2 +149,1 @@\n-        }\n-        else {\n+        } else {\n@@ -169,1 +164,1 @@\n-            while (!t.elapsed())  {\n+            while (!t.elapsed()) {\n@@ -175,2 +170,1 @@\n-                }\n-                catch (InterruptedException e) {\n+                } catch (InterruptedException e) {\n@@ -184,2 +178,1 @@\n-                    if (!isPeek)\n-                        exception = null;\n+                    if (!isPeek) exception = null;\n@@ -209,1 +202,1 @@\n-    private void run () {\n+    private void run() {\n@@ -248,3 +241,3 @@\n-\/\/                    if (charRead < 0) {\n-\/\/                        continue;\n-\/\/                    }\n+                    \/\/                    if (charRead < 0) {\n+                    \/\/                        continue;\n+                    \/\/                    }\n@@ -253,1 +246,1 @@\n-\/\/                    charRead = -1;\n+                    \/\/                    charRead = -1;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -12,2 +12,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n@@ -17,1 +15,2 @@\n-    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n+    public static final boolean IS_LINUX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n@@ -19,3 +18,11 @@\n-    public static final boolean IS_CYGWIN = IS_WINDOWS\n-            && System.getenv(\"PWD\") != null\n-            && System.getenv(\"PWD\").startsWith(\"\/\");\n+    public static final boolean IS_WINDOWS =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n+\n+    public static final boolean IS_OSX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n+\n+    public static final boolean IS_AIX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"aix\");\n+\n+    public static final boolean IS_CYGWIN =\n+            IS_WINDOWS && System.getenv(\"PWD\") != null && System.getenv(\"PWD\").startsWith(\"\/\");\n@@ -31,1 +38,1 @@\n-                || System.getenv(\"MSYSTEM\").equals(\"MSYS\"));\n+                    || System.getenv(\"MSYSTEM\").equals(\"MSYS\"));\n@@ -39,5 +46,1 @@\n-    public static final boolean IS_CONEMU = IS_WINDOWS\n-            && System.getenv(\"ConEmuPID\") != null;\n-\n-    public static final boolean IS_OSX = System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n-    public static final boolean IS_AIX = System.getProperty(\"os.name\").equals(\"AIX\");\n+    public static final boolean IS_CONEMU = IS_WINDOWS && System.getenv(\"ConEmuPID\") != null;\n@@ -51,0 +54,4 @@\n+    private static boolean isExecutable(File f) {\n+        return f.canExecute() && !f.isDirectory();\n+    }\n+\n@@ -52,27 +59,26 @@\n-        String tty;\n-        String stty;\n-        String sttyfopt;\n-        String infocmp;\n-        String test;\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            tty = null;\n-            stty = null;\n-            sttyfopt = null;\n-            infocmp = null;\n-            test = null;\n-            String path = System.getenv(\"PATH\");\n-            if (path != null) {\n-                String[] paths = path.split(\";\");\n-                for (String p : paths) {\n-                    if (tty == null && new File(p, \"tty.exe\").exists()) {\n-                        tty = new File(p, \"tty.exe\").getAbsolutePath();\n-                    }\n-                    if (stty == null && new File(p, \"stty.exe\").exists()) {\n-                        stty = new File(p, \"stty.exe\").getAbsolutePath();\n-                    }\n-                    if (infocmp == null && new File(p, \"infocmp.exe\").exists()) {\n-                        infocmp = new File(p, \"infocmp.exe\").getAbsolutePath();\n-                    }\n-                    if (test == null && new File(p, \"test.exe\").exists()) {\n-                        test = new File(p, \"test.exe\").getAbsolutePath();\n-                    }\n+        boolean cygwinOrMsys = OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM;\n+        String suffix = cygwinOrMsys ? \".exe\" : \"\";\n+        String tty = null;\n+        String stty = null;\n+        String sttyfopt = null;\n+        String infocmp = null;\n+        String test = null;\n+        String path = System.getenv(\"PATH\");\n+        if (path != null) {\n+            String[] paths = path.split(File.pathSeparator);\n+            for (String p : paths) {\n+                File ttyFile = new File(p, \"tty\" + suffix);\n+                if (tty == null && isExecutable(ttyFile)) {\n+                    tty = ttyFile.getAbsolutePath();\n+                }\n+                File sttyFile = new File(p, \"stty\" + suffix);\n+                if (stty == null && isExecutable(sttyFile)) {\n+                    stty = sttyFile.getAbsolutePath();\n+                }\n+                File infocmpFile = new File(p, \"infocmp\" + suffix);\n+                if (infocmp == null && isExecutable(infocmpFile)) {\n+                    infocmp = infocmpFile.getAbsolutePath();\n+                }\n+                File testFile = new File(p, \"test\" + suffix);\n+                if (test == null && isExecutable(testFile)) {\n+                    test = testFile.getAbsolutePath();\n@@ -81,19 +87,0 @@\n-            if (tty == null) {\n-                tty = \"tty.exe\";\n-            }\n-            if (stty == null) {\n-                stty = \"stty.exe\";\n-            }\n-            if (infocmp == null) {\n-                infocmp = \"infocmp.exe\";\n-            }\n-            if (test == null) {\n-                test = \"test.exe\";\n-            }\n-        } else {\n-            tty = \"tty\";\n-            stty = IS_OSX ? \"\/bin\/stty\" : \"stty\";\n-            sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n-            infocmp = \"infocmp\";\n-            test = isTestCommandValid(\"\/usr\/bin\/test\") ? \"\/usr\/bin\/test\"\n-                                                       : \"\/bin\/test\";\n@@ -101,0 +88,13 @@\n+        if (tty == null) {\n+            tty = \"tty\" + suffix;\n+        }\n+        if (stty == null) {\n+            stty = \"stty\" + suffix;\n+        }\n+        if (infocmp == null) {\n+            infocmp = \"infocmp\" + suffix;\n+        }\n+        if (test == null) {\n+            test = \"test\" + suffix;\n+        }\n+        sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n@@ -107,4 +107,0 @@\n-\n-    private static boolean isTestCommandValid(String command) {\n-        return Files.isExecutable(Paths.get(command));\n-    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":59,"deletions":63,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -381,1 +381,0 @@\n-\n@@ -467,1 +466,0 @@\n-\n@@ -469,1 +467,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -21,2 +21,1 @@\n-public final class ShutdownHooks\n-{\n+public final class ShutdownHooks {\n@@ -32,2 +31,1 @@\n-            hook = addHook(new Thread(\"JLine Shutdown Hook\")\n-            {\n+            hook = addHook(new Thread(\"JLine Shutdown Hook\") {\n@@ -56,2 +54,1 @@\n-            }\n-            catch (Throwable e) {\n+            } catch (Throwable e) {\n@@ -94,2 +91,1 @@\n-        }\n-        catch (IllegalStateException e) {\n+        } catch (IllegalStateException e) {\n@@ -103,2 +99,1 @@\n-    public interface Task\n-    {\n+    public interface Task {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ShutdownHooks.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,2 +24,1 @@\n-    private Signals() {\n-    }\n+    private Signals() {}\n@@ -44,2 +43,2 @@\n-            Object signalHandler = Proxy.newProxyInstance(loader,\n-                    new Class<?>[]{signalHandlerClass}, (proxy, method, args) -> {\n+            Object signalHandler =\n+                    Proxy.newProxyInstance(loader, new Class<?>[] {signalHandlerClass}, (proxy, method, args) -> {\n@@ -104,2 +103,1 @@\n-        return signalClass.getMethod(\"handle\", signalClass, signalHandlerClass)\n-                .invoke(null, signal, handler);\n+        return signalClass.getMethod(\"handle\", signalClass, signalHandlerClass).invoke(null, signal, handler);\n@@ -123,1 +121,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Signals.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -11,2 +11,0 @@\n-import java.util.Objects;\n-import java.util.Collections;\n@@ -14,0 +12,1 @@\n+import java.util.Collections;\n@@ -15,0 +14,4 @@\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.internal.org.jline.terminal.Size;\n@@ -18,1 +21,0 @@\n-import jdk.internal.org.jline.terminal.Size;\n@@ -22,1 +24,1 @@\n-    protected final AbstractTerminal terminal;\n+    protected final Terminal terminal;\n@@ -24,5 +26,0 @@\n-    protected List<AttributedString> oldLines = Collections.emptyList();\n-    protected List<AttributedString> linesToRestore = Collections.emptyList();\n-    protected int rows;\n-    protected int columns;\n-    protected boolean force;\n@@ -32,0 +29,3 @@\n+    protected Display display;\n+    protected List<AttributedString> lines = Collections.emptyList();\n+    protected int scrollRegion;\n@@ -37,4 +37,2 @@\n-    public static Status getStatus(Terminal terminal, boolean create) {\n-        return terminal instanceof AbstractTerminal\n-                ? ((AbstractTerminal) terminal).getStatus(create)\n-                : null;\n+    public static Optional<Status> getExistingStatus(Terminal terminal) {\n+        return Optional.ofNullable(getStatus(terminal, false));\n@@ -43,0 +41,3 @@\n+    public static Status getStatus(Terminal terminal, boolean create) {\n+        return terminal instanceof AbstractTerminal ? ((AbstractTerminal) terminal).getStatus(create) : null;\n+    }\n@@ -44,1 +45,2 @@\n-    public Status(AbstractTerminal terminal) {\n+    @SuppressWarnings(\"this-escape\")\n+    public Status(Terminal terminal) {\n@@ -47,3 +49,3 @@\n-            && terminal.getStringCapability(Capability.save_cursor) != null\n-            && terminal.getStringCapability(Capability.restore_cursor) != null\n-            && terminal.getStringCapability(Capability.cursor_address) != null;\n+                && terminal.getStringCapability(Capability.save_cursor) != null\n+                && terminal.getStringCapability(Capability.restore_cursor) != null\n+                && terminal.getStringCapability(Capability.cursor_address) != null;\n@@ -51,6 +53,1 @@\n-            char borderChar = '\\u2700';\n-            AttributedStringBuilder bb = new AttributedStringBuilder();\n-            for (int i = 0; i < 200; i++) {\n-                bb.append(borderChar);\n-            }\n-            borderString = bb.toAttributedString();\n+            display = new MovingCursorDisplay(terminal);\n@@ -58,0 +55,2 @@\n+            display.reset();\n+            scrollRegion = display.rows - 1;\n@@ -61,0 +60,7 @@\n+    public void close() {\n+        terminal.puts(Capability.save_cursor);\n+        terminal.puts(Capability.change_scroll_region, 0, display.rows - 1);\n+        terminal.puts(Capability.restore_cursor);\n+        terminal.flush();\n+    }\n+\n@@ -66,4 +72,1 @@\n-        Size size = terminal.getSize();\n-        this.rows = size.getRows();\n-        this.columns = size.getColumns();\n-        this.force = true;\n+        resize(terminal.getSize());\n@@ -72,2 +75,2 @@\n-    public void reset() {\n-        this.force = true;\n+    public void resize(Size size) {\n+        display.resize(size.getRows(), size.getColumns());\n@@ -76,3 +79,5 @@\n-    public void hardReset() {\n-        if (suspended) {\n-            return;\n+    public void reset() {\n+        if (supported) {\n+            display.reset();\n+            scrollRegion = display.rows;\n+            terminal.puts(Capability.change_scroll_region, 0, scrollRegion);\n@@ -80,5 +85,0 @@\n-        List<AttributedString> lines = new ArrayList<>(oldLines);\n-        int b = border;\n-        update(null);\n-        border = b;\n-        update(lines);\n@@ -91,1 +91,1 @@\n-        update(oldLines);\n+        update(lines);\n@@ -94,2 +94,2 @@\n-    public void clear() {\n-        privateClear(oldLines.size());\n+    public void hide() {\n+        update(Collections.emptyList());\n@@ -98,4 +98,2 @@\n-    private void clearAll() {\n-        int b = border;\n-        border = 0;\n-        privateClear(oldLines.size() + b);\n+    public void update(List<AttributedString> lines) {\n+        update(lines, true);\n@@ -104,9 +102,2 @@\n-    private void privateClear(int statusSize) {\n-        List<AttributedString> as = new ArrayList<>();\n-        for (int i = 0; i < statusSize; i++) {\n-            as.add(new AttributedString(\"\"));\n-        }\n-        if (!as.isEmpty()) {\n-            update(as);\n-        }\n-    }\n+    private final AttributedString ellipsis =\n+            new AttributedStringBuilder().append(\"\\u2026\", AttributedStyle.INVERSE).toAttributedString();\n@@ -114,1 +105,5 @@\n-    public void update(List<AttributedString> lines) {\n+    \/**\n+     * Returns <code>true<\/code> if the cursor may be misplaced and should\n+     * be updated.\n+     *\/\n+    public void update(List<AttributedString> lines, boolean flush) {\n@@ -118,3 +113,1 @@\n-        if (lines == null) {\n-            lines = Collections.emptyList();\n-        }\n+        this.lines = new ArrayList<>(lines);\n@@ -122,1 +115,0 @@\n-            linesToRestore = new ArrayList<>(lines);\n@@ -125,2 +117,7 @@\n-        if (lines.isEmpty()) {\n-            clearAll();\n+\n+        lines = new ArrayList<>(lines);\n+        \/\/ add border\n+        int rows = display.rows;\n+        int columns = display.columns;\n+        if (border == 1 && !lines.isEmpty() && rows > 1) {\n+            lines.add(0, getBorderString(columns));\n@@ -128,2 +125,15 @@\n-        if (oldLines.equals(lines) && !force) {\n-            return;\n+        \/\/ trim or complete lines to the full width\n+        for (int i = 0; i < lines.size(); i++) {\n+            AttributedString str = lines.get(i);\n+            if (str.columnLength() > columns) {\n+                str = new AttributedStringBuilder(columns)\n+                        .append(lines.get(i).columnSubSequence(0, columns - ellipsis.columnLength()))\n+                        .append(ellipsis)\n+                        .toAttributedString();\n+            } else if (str.columnLength() < columns) {\n+                str = new AttributedStringBuilder(columns)\n+                        .append(str)\n+                        .append(' ', columns - str.columnLength())\n+                        .toAttributedString();\n+            }\n+            lines.set(i, str);\n@@ -131,4 +141,10 @@\n-        int statusSize = lines.size() + (lines.size() == 0 ? 0 : border);\n-        int nb = statusSize - oldLines.size() - (oldLines.size() == 0 ? 0 : border);\n-        if (nb > 0) {\n-            for (int i = 0; i < nb; i++) {\n+\n+        List<AttributedString> oldLines = this.display.oldLines;\n+\n+        int newScrollRegion = display.rows - 1 - lines.size();\n+        \/\/ Update the scroll region if needed.\n+        \/\/ Note that settings the scroll region usually moves the cursor, so we need to get ready for that.\n+        if (newScrollRegion < scrollRegion) {\n+            \/\/ We need to scroll up to grow the status bar\n+            terminal.puts(Capability.save_cursor);\n+            for (int i = newScrollRegion; i < scrollRegion; i++) {\n@@ -137,1 +153,3 @@\n-            for (int i = 0; i < nb; i++) {\n+            terminal.puts(Capability.change_scroll_region, 0, newScrollRegion);\n+            terminal.puts(Capability.restore_cursor);\n+            for (int i = newScrollRegion; i < scrollRegion; i++) {\n@@ -140,0 +158,6 @@\n+            scrollRegion = newScrollRegion;\n+        } else if (newScrollRegion > scrollRegion) {\n+            terminal.puts(Capability.save_cursor);\n+            terminal.puts(Capability.change_scroll_region, 0, newScrollRegion);\n+            terminal.puts(Capability.restore_cursor);\n+            scrollRegion = newScrollRegion;\n@@ -141,5 +165,9 @@\n-        terminal.puts(Capability.save_cursor);\n-        terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n-        if (!terminal.puts(Capability.clr_eos)) {\n-            for (int i = rows - statusSize; i < rows; i++) {\n-                terminal.puts(Capability.cursor_address, i, 0);\n+\n+        \/\/ if the display has more lines, we need to add empty ones to make sure they will be erased\n+        List<AttributedString> toDraw = new ArrayList<>(lines);\n+        int nbToDraw = toDraw.size();\n+        int nbOldLines = oldLines.size();\n+        if (nbOldLines > nbToDraw) {\n+            terminal.puts(Capability.save_cursor);\n+            terminal.puts(Capability.cursor_address, display.rows - nbOldLines, 0);\n+            for (int i = 0; i < nbOldLines - nbToDraw; i++) {\n@@ -147,0 +175,4 @@\n+                if (i < nbOldLines - nbToDraw - 1) {\n+                    terminal.puts(Capability.cursor_down);\n+                }\n+                oldLines.remove(0);\n@@ -148,0 +180,1 @@\n+            terminal.puts(Capability.restore_cursor);\n@@ -149,12 +182,10 @@\n-        if (border == 1 && lines.size() > 0) {\n-            terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n-            borderString.columnSubSequence(0, columns).print(terminal);\n-        }\n-        for (int i = 0; i < lines.size(); i++) {\n-            terminal.puts(Capability.cursor_address, rows - lines.size() + i, 0);\n-            if (lines.get(i).length() > columns) {\n-                AttributedStringBuilder asb = new AttributedStringBuilder();\n-                asb.append(lines.get(i).substring(0, columns - 3)).append(\"...\", new AttributedStyle(AttributedStyle.INVERSE));\n-                asb.toAttributedString().columnSubSequence(0, columns).print(terminal);\n-            } else {\n-                lines.get(i).columnSubSequence(0, columns).print(terminal);\n+        \/\/ update display\n+        display.update(lines, -1, flush);\n+    }\n+\n+    private AttributedString getBorderString(int columns) {\n+        if (borderString == null || borderString.length() != columns) {\n+            char borderChar = '\\u2700';\n+            AttributedStringBuilder bb = new AttributedStringBuilder();\n+            for (int i = 0; i < columns; i++) {\n+                bb.append(borderChar);\n@@ -162,0 +193,1 @@\n+            borderString = bb.toAttributedString();\n@@ -163,5 +195,1 @@\n-        terminal.puts(Capability.change_scroll_region, 0, rows - 1 - statusSize);\n-        terminal.puts(Capability.restore_cursor);\n-        terminal.flush();\n-        oldLines = new ArrayList<>(lines);\n-        force = false;\n+        return borderString;\n@@ -170,0 +198,5 @@\n+    \/**\n+     * The {@code suspend} method is used when a full-screen.\n+     * If the status was not already suspended, the lines\n+     * used by the status are cleared during this call.\n+     *\/\n@@ -171,2 +204,2 @@\n-        if (suspended) {\n-            return;\n+        if (!suspended) {\n+            suspended = true;\n@@ -174,5 +207,0 @@\n-        linesToRestore = new ArrayList<>(oldLines);\n-        int b = border;\n-        update(null);\n-        border = b;\n-        suspended = true;\n@@ -181,0 +209,6 @@\n+    \/**\n+     * The {@code restore()} call is the opposite of {@code suspend()} and\n+     * will make the status bar be updated again.\n+     * If the status was suspended, the lines\n+     * used by the status will be drawn during this call.\n+     *\/\n@@ -182,2 +216,3 @@\n-        if (!suspended) {\n-            return;\n+        if (suspended) {\n+            suspended = false;\n+            update(this.lines);\n@@ -185,3 +220,0 @@\n-        suspended = false;\n-        update(linesToRestore);\n-        linesToRestore = Collections.emptyList();\n@@ -191,1 +223,11 @@\n-        return oldLines.size() + border;\n+        return size(this.lines);\n+    }\n+\n+    private int size(List<?> lines) {\n+        int l = lines.size();\n+        return l > 0 ? l + border : 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Status[\" + \"supported=\" + supported + ']';\n@@ -194,0 +236,37 @@\n+    static class MovingCursorDisplay extends Display {\n+        protected int firstLine;\n+\n+        public MovingCursorDisplay(Terminal terminal) {\n+            super(terminal, false);\n+        }\n+\n+        @Override\n+        public void update(List<AttributedString> newLines, int targetCursorPos, boolean flush) {\n+            cursorPos = -1;\n+            firstLine = rows - newLines.size();\n+            super.update(newLines, targetCursorPos, flush);\n+            if (cursorPos != -1) {\n+                terminal.puts(Capability.restore_cursor);\n+            }\n+        }\n+\n+        @Override\n+        protected void moveVisualCursorTo(int targetPos, List<AttributedString> newLines) {\n+            initCursor();\n+            super.moveVisualCursorTo(targetPos, newLines);\n+        }\n+\n+        @Override\n+        protected int moveVisualCursorTo(int i1) {\n+            initCursor();\n+            return super.moveVisualCursorTo(i1);\n+        }\n+\n+        void initCursor() {\n+            if (cursorPos == -1) {\n+                terminal.puts(Capability.save_cursor);\n+                terminal.puts(Capability.cursor_address, firstLine, 0);\n+                cursorPos = 0;\n+            }\n+        }\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Status.java","additions":182,"deletions":103,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -58,6 +58,6 @@\n-           \/\/ load indexed color\n-           Integer color = color(name);\n-           if (color != null && color != -1) {\n-               color = Colors.DEFAULT_COLORS_256[color];\n-           }\n-           return color;\n+            \/\/ load indexed color\n+            Integer color = color(name);\n+            if (color != null && color != -1) {\n+                color = Colors.DEFAULT_COLORS_256[color];\n+            }\n+            return color;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -47,1 +47,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -13,2 +13,1 @@\n-    private WCWidth() {\n-    }\n+    private WCWidth() {}\n@@ -47,2 +46,1 @@\n-    public static int wcwidth(int ucs)\n-    {\n+    public static int wcwidth(int ucs) {\n@@ -51,4 +49,2 @@\n-        if (ucs == 0)\n-            return 0;\n-        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))\n-            return -1;\n+        if (ucs == 0) return 0;\n+        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return -1;\n@@ -57,2 +53,1 @@\n-        if (bisearch(ucs, combining, combining.length - 1))\n-            return 0;\n+        if (bisearch(ucs, combining, combining.length - 1)) return 0;\n@@ -61,15 +56,17 @@\n-        return 1 +\n-                ((ucs >= 0x1100 &&\n-                        (ucs <= 0x115f ||                           \/* Hangul Jamo init. consonants *\/\n-                                ucs == 0x2329 || ucs == 0x232a ||\n-                                (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n-                                        ucs != 0x303f) ||           \/* CJK ... Yi *\/\n-                                (ucs >= 0xac00 && ucs <= 0xd7a3) || \/* Hangul Syllables *\/\n-                                (ucs >= 0xf900 && ucs <= 0xfaff) || \/* CJK Compatibility Ideographs *\/\n-                                (ucs >= 0xfe10 && ucs <= 0xfe19) || \/* Vertical forms *\/\n-                                (ucs >= 0xfe30 && ucs <= 0xfe6f) || \/* CJK Compatibility Forms *\/\n-                                (ucs >= 0xff00 && ucs <= 0xff60) || \/* Fullwidth Forms *\/\n-                                (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n-                                (ucs >= 0x1f000 && ucs <= 0x1feee) ||\n-                                (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n-                                (ucs >= 0x30000 && ucs <= 0x3fffd))) ? 1 : 0);\n+        return 1\n+                + ((ucs >= 0x1100\n+                                && (ucs <= 0x115f\n+                                        || \/* Hangul Jamo init. consonants *\/ ucs == 0x2329\n+                                        || ucs == 0x232a\n+                                        || (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f)\n+                                        || \/* CJK ... Yi *\/ (ucs >= 0xac00 && ucs <= 0xd7a3)\n+                                        || \/* Hangul Syllables *\/ (ucs >= 0xf900 && ucs <= 0xfaff)\n+                                        || \/* CJK Compatibility Ideographs *\/ (ucs >= 0xfe10 && ucs <= 0xfe19)\n+                                        || \/* Vertical forms *\/ (ucs >= 0xfe30 && ucs <= 0xfe6f)\n+                                        || \/* CJK Compatibility Forms *\/ (ucs >= 0xff00 && ucs <= 0xff60)\n+                                        || \/* Fullwidth Forms *\/ (ucs >= 0xffe0 && ucs <= 0xffe6)\n+                                        || (ucs >= 0x1f000 && ucs <= 0x1feee)\n+                                        || (ucs >= 0x20000 && ucs <= 0x2fffd)\n+                                        || (ucs >= 0x30000 && ucs <= 0x3fffd)))\n+                        ? 1\n+                        : 0);\n@@ -81,48 +78,48 @@\n-            new Interval( 0x0300, 0x036F ), new Interval( 0x0483, 0x0486 ), new Interval( 0x0488, 0x0489 ),\n-            new Interval( 0x0591, 0x05BD ), new Interval( 0x05BF, 0x05BF ), new Interval( 0x05C1, 0x05C2 ),\n-            new Interval( 0x05C4, 0x05C5 ), new Interval( 0x05C7, 0x05C7 ), new Interval( 0x0600, 0x0603 ),\n-            new Interval( 0x0610, 0x0615 ), new Interval( 0x064B, 0x065E ), new Interval( 0x0670, 0x0670 ),\n-            new Interval( 0x06D6, 0x06E4 ), new Interval( 0x06E7, 0x06E8 ), new Interval( 0x06EA, 0x06ED ),\n-            new Interval( 0x070F, 0x070F ), new Interval( 0x0711, 0x0711 ), new Interval( 0x0730, 0x074A ),\n-            new Interval( 0x07A6, 0x07B0 ), new Interval( 0x07EB, 0x07F3 ), new Interval( 0x0901, 0x0902 ),\n-            new Interval( 0x093C, 0x093C ), new Interval( 0x0941, 0x0948 ), new Interval( 0x094D, 0x094D ),\n-            new Interval( 0x0951, 0x0954 ), new Interval( 0x0962, 0x0963 ), new Interval( 0x0981, 0x0981 ),\n-            new Interval( 0x09BC, 0x09BC ), new Interval( 0x09C1, 0x09C4 ), new Interval( 0x09CD, 0x09CD ),\n-            new Interval( 0x09E2, 0x09E3 ), new Interval( 0x0A01, 0x0A02 ), new Interval( 0x0A3C, 0x0A3C ),\n-            new Interval( 0x0A41, 0x0A42 ), new Interval( 0x0A47, 0x0A48 ), new Interval( 0x0A4B, 0x0A4D ),\n-            new Interval( 0x0A70, 0x0A71 ), new Interval( 0x0A81, 0x0A82 ), new Interval( 0x0ABC, 0x0ABC ),\n-            new Interval( 0x0AC1, 0x0AC5 ), new Interval( 0x0AC7, 0x0AC8 ), new Interval( 0x0ACD, 0x0ACD ),\n-            new Interval( 0x0AE2, 0x0AE3 ), new Interval( 0x0B01, 0x0B01 ), new Interval( 0x0B3C, 0x0B3C ),\n-            new Interval( 0x0B3F, 0x0B3F ), new Interval( 0x0B41, 0x0B43 ), new Interval( 0x0B4D, 0x0B4D ),\n-            new Interval( 0x0B56, 0x0B56 ), new Interval( 0x0B82, 0x0B82 ), new Interval( 0x0BC0, 0x0BC0 ),\n-            new Interval( 0x0BCD, 0x0BCD ), new Interval( 0x0C3E, 0x0C40 ), new Interval( 0x0C46, 0x0C48 ),\n-            new Interval( 0x0C4A, 0x0C4D ), new Interval( 0x0C55, 0x0C56 ), new Interval( 0x0CBC, 0x0CBC ),\n-            new Interval( 0x0CBF, 0x0CBF ), new Interval( 0x0CC6, 0x0CC6 ), new Interval( 0x0CCC, 0x0CCD ),\n-            new Interval( 0x0CE2, 0x0CE3 ), new Interval( 0x0D41, 0x0D43 ), new Interval( 0x0D4D, 0x0D4D ),\n-            new Interval( 0x0DCA, 0x0DCA ), new Interval( 0x0DD2, 0x0DD4 ), new Interval( 0x0DD6, 0x0DD6 ),\n-            new Interval( 0x0E31, 0x0E31 ), new Interval( 0x0E34, 0x0E3A ), new Interval( 0x0E47, 0x0E4E ),\n-            new Interval( 0x0EB1, 0x0EB1 ), new Interval( 0x0EB4, 0x0EB9 ), new Interval( 0x0EBB, 0x0EBC ),\n-            new Interval( 0x0EC8, 0x0ECD ), new Interval( 0x0F18, 0x0F19 ), new Interval( 0x0F35, 0x0F35 ),\n-            new Interval( 0x0F37, 0x0F37 ), new Interval( 0x0F39, 0x0F39 ), new Interval( 0x0F71, 0x0F7E ),\n-            new Interval( 0x0F80, 0x0F84 ), new Interval( 0x0F86, 0x0F87 ), new Interval( 0x0F90, 0x0F97 ),\n-            new Interval( 0x0F99, 0x0FBC ), new Interval( 0x0FC6, 0x0FC6 ), new Interval( 0x102D, 0x1030 ),\n-            new Interval( 0x1032, 0x1032 ), new Interval( 0x1036, 0x1037 ), new Interval( 0x1039, 0x1039 ),\n-            new Interval( 0x1058, 0x1059 ), new Interval( 0x1160, 0x11FF ), new Interval( 0x135F, 0x135F ),\n-            new Interval( 0x1712, 0x1714 ), new Interval( 0x1732, 0x1734 ), new Interval( 0x1752, 0x1753 ),\n-            new Interval( 0x1772, 0x1773 ), new Interval( 0x17B4, 0x17B5 ), new Interval( 0x17B7, 0x17BD ),\n-            new Interval( 0x17C6, 0x17C6 ), new Interval( 0x17C9, 0x17D3 ), new Interval( 0x17DD, 0x17DD ),\n-            new Interval( 0x180B, 0x180D ), new Interval( 0x18A9, 0x18A9 ), new Interval( 0x1920, 0x1922 ),\n-            new Interval( 0x1927, 0x1928 ), new Interval( 0x1932, 0x1932 ), new Interval( 0x1939, 0x193B ),\n-            new Interval( 0x1A17, 0x1A18 ), new Interval( 0x1B00, 0x1B03 ), new Interval( 0x1B34, 0x1B34 ),\n-            new Interval( 0x1B36, 0x1B3A ), new Interval( 0x1B3C, 0x1B3C ), new Interval( 0x1B42, 0x1B42 ),\n-            new Interval( 0x1B6B, 0x1B73 ), new Interval( 0x1DC0, 0x1DCA ), new Interval( 0x1DFE, 0x1DFF ),\n-            new Interval( 0x200B, 0x200F ), new Interval( 0x202A, 0x202E ), new Interval( 0x2060, 0x2063 ),\n-            new Interval( 0x206A, 0x206F ), new Interval( 0x20D0, 0x20EF ), new Interval( 0x302A, 0x302F ),\n-            new Interval( 0x3099, 0x309A ), new Interval( 0xA806, 0xA806 ), new Interval( 0xA80B, 0xA80B ),\n-            new Interval( 0xA825, 0xA826 ), new Interval( 0xFB1E, 0xFB1E ), new Interval( 0xFE00, 0xFE0F ),\n-            new Interval( 0xFE20, 0xFE23 ), new Interval( 0xFEFF, 0xFEFF ), new Interval( 0xFFF9, 0xFFFB ),\n-            new Interval( 0x10A01, 0x10A03 ), new Interval( 0x10A05, 0x10A06 ), new Interval( 0x10A0C, 0x10A0F ),\n-            new Interval( 0x10A38, 0x10A3A ), new Interval( 0x10A3F, 0x10A3F ), new Interval( 0x1D167, 0x1D169 ),\n-            new Interval( 0x1D173, 0x1D182 ), new Interval( 0x1D185, 0x1D18B ), new Interval( 0x1D1AA, 0x1D1AD ),\n-            new Interval( 0x1D242, 0x1D244 ), new Interval( 0x1F3FB, 0x1F3FF ), new Interval( 0xE0001, 0xE0001 ),\n-            new Interval( 0xE0020, 0xE007F ), new Interval( 0xE0100, 0xE01EF )\n+        new Interval(0x0300, 0x036F), new Interval(0x0483, 0x0486), new Interval(0x0488, 0x0489),\n+        new Interval(0x0591, 0x05BD), new Interval(0x05BF, 0x05BF), new Interval(0x05C1, 0x05C2),\n+        new Interval(0x05C4, 0x05C5), new Interval(0x05C7, 0x05C7), new Interval(0x0600, 0x0603),\n+        new Interval(0x0610, 0x0615), new Interval(0x064B, 0x065E), new Interval(0x0670, 0x0670),\n+        new Interval(0x06D6, 0x06E4), new Interval(0x06E7, 0x06E8), new Interval(0x06EA, 0x06ED),\n+        new Interval(0x070F, 0x070F), new Interval(0x0711, 0x0711), new Interval(0x0730, 0x074A),\n+        new Interval(0x07A6, 0x07B0), new Interval(0x07EB, 0x07F3), new Interval(0x0901, 0x0902),\n+        new Interval(0x093C, 0x093C), new Interval(0x0941, 0x0948), new Interval(0x094D, 0x094D),\n+        new Interval(0x0951, 0x0954), new Interval(0x0962, 0x0963), new Interval(0x0981, 0x0981),\n+        new Interval(0x09BC, 0x09BC), new Interval(0x09C1, 0x09C4), new Interval(0x09CD, 0x09CD),\n+        new Interval(0x09E2, 0x09E3), new Interval(0x0A01, 0x0A02), new Interval(0x0A3C, 0x0A3C),\n+        new Interval(0x0A41, 0x0A42), new Interval(0x0A47, 0x0A48), new Interval(0x0A4B, 0x0A4D),\n+        new Interval(0x0A70, 0x0A71), new Interval(0x0A81, 0x0A82), new Interval(0x0ABC, 0x0ABC),\n+        new Interval(0x0AC1, 0x0AC5), new Interval(0x0AC7, 0x0AC8), new Interval(0x0ACD, 0x0ACD),\n+        new Interval(0x0AE2, 0x0AE3), new Interval(0x0B01, 0x0B01), new Interval(0x0B3C, 0x0B3C),\n+        new Interval(0x0B3F, 0x0B3F), new Interval(0x0B41, 0x0B43), new Interval(0x0B4D, 0x0B4D),\n+        new Interval(0x0B56, 0x0B56), new Interval(0x0B82, 0x0B82), new Interval(0x0BC0, 0x0BC0),\n+        new Interval(0x0BCD, 0x0BCD), new Interval(0x0C3E, 0x0C40), new Interval(0x0C46, 0x0C48),\n+        new Interval(0x0C4A, 0x0C4D), new Interval(0x0C55, 0x0C56), new Interval(0x0CBC, 0x0CBC),\n+        new Interval(0x0CBF, 0x0CBF), new Interval(0x0CC6, 0x0CC6), new Interval(0x0CCC, 0x0CCD),\n+        new Interval(0x0CE2, 0x0CE3), new Interval(0x0D41, 0x0D43), new Interval(0x0D4D, 0x0D4D),\n+        new Interval(0x0DCA, 0x0DCA), new Interval(0x0DD2, 0x0DD4), new Interval(0x0DD6, 0x0DD6),\n+        new Interval(0x0E31, 0x0E31), new Interval(0x0E34, 0x0E3A), new Interval(0x0E47, 0x0E4E),\n+        new Interval(0x0EB1, 0x0EB1), new Interval(0x0EB4, 0x0EB9), new Interval(0x0EBB, 0x0EBC),\n+        new Interval(0x0EC8, 0x0ECD), new Interval(0x0F18, 0x0F19), new Interval(0x0F35, 0x0F35),\n+        new Interval(0x0F37, 0x0F37), new Interval(0x0F39, 0x0F39), new Interval(0x0F71, 0x0F7E),\n+        new Interval(0x0F80, 0x0F84), new Interval(0x0F86, 0x0F87), new Interval(0x0F90, 0x0F97),\n+        new Interval(0x0F99, 0x0FBC), new Interval(0x0FC6, 0x0FC6), new Interval(0x102D, 0x1030),\n+        new Interval(0x1032, 0x1032), new Interval(0x1036, 0x1037), new Interval(0x1039, 0x1039),\n+        new Interval(0x1058, 0x1059), new Interval(0x1160, 0x11FF), new Interval(0x135F, 0x135F),\n+        new Interval(0x1712, 0x1714), new Interval(0x1732, 0x1734), new Interval(0x1752, 0x1753),\n+        new Interval(0x1772, 0x1773), new Interval(0x17B4, 0x17B5), new Interval(0x17B7, 0x17BD),\n+        new Interval(0x17C6, 0x17C6), new Interval(0x17C9, 0x17D3), new Interval(0x17DD, 0x17DD),\n+        new Interval(0x180B, 0x180D), new Interval(0x18A9, 0x18A9), new Interval(0x1920, 0x1922),\n+        new Interval(0x1927, 0x1928), new Interval(0x1932, 0x1932), new Interval(0x1939, 0x193B),\n+        new Interval(0x1A17, 0x1A18), new Interval(0x1B00, 0x1B03), new Interval(0x1B34, 0x1B34),\n+        new Interval(0x1B36, 0x1B3A), new Interval(0x1B3C, 0x1B3C), new Interval(0x1B42, 0x1B42),\n+        new Interval(0x1B6B, 0x1B73), new Interval(0x1DC0, 0x1DCA), new Interval(0x1DFE, 0x1DFF),\n+        new Interval(0x200B, 0x200F), new Interval(0x202A, 0x202E), new Interval(0x2060, 0x2063),\n+        new Interval(0x206A, 0x206F), new Interval(0x20D0, 0x20EF), new Interval(0x302A, 0x302F),\n+        new Interval(0x3099, 0x309A), new Interval(0xA806, 0xA806), new Interval(0xA80B, 0xA80B),\n+        new Interval(0xA825, 0xA826), new Interval(0xFB1E, 0xFB1E), new Interval(0xFE00, 0xFE0F),\n+        new Interval(0xFE20, 0xFE23), new Interval(0xFEFF, 0xFEFF), new Interval(0xFFF9, 0xFFFB),\n+        new Interval(0x10A01, 0x10A03), new Interval(0x10A05, 0x10A06), new Interval(0x10A0C, 0x10A0F),\n+        new Interval(0x10A38, 0x10A3A), new Interval(0x10A3F, 0x10A3F), new Interval(0x1D167, 0x1D169),\n+        new Interval(0x1D173, 0x1D182), new Interval(0x1D185, 0x1D18B), new Interval(0x1D1AA, 0x1D1AD),\n+        new Interval(0x1D242, 0x1D244), new Interval(0x1F3FB, 0x1F3FF), new Interval(0xE0001, 0xE0001),\n+        new Interval(0xE0020, 0xE007F), new Interval(0xE0100, 0xE01EF)\n@@ -146,2 +143,1 @@\n-        if (ucs < table[0].first || ucs > table[max].last)\n-            return false;\n+        if (ucs < table[0].first || ucs > table[max].last) return false;\n@@ -150,6 +146,3 @@\n-            if (ucs > table[mid].last)\n-                min = mid + 1;\n-            else if (ucs < table[mid].first)\n-                max = mid - 1;\n-            else\n-                return true;\n+            if (ucs > table[mid].last) min = mid + 1;\n+            else if (ucs < table[mid].first) max = mid - 1;\n+            else return true;\n@@ -160,2 +153,0 @@\n-\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WCWidth.java","additions":75,"deletions":84,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -38,3 +38,5 @@\n-        this(out, charset.newDecoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+        this(\n+                out,\n+                charset.newDecoder()\n+                        .onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -50,1 +52,1 @@\n-        write(new byte[] { (byte)b }, 0, 1);\n+        write(new byte[] {(byte) b}, 0, 1);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WriterOutputStream.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,0 +8,3 @@\n+\tcivis=\\E[?25l, cvvis=\\E[?25h,\n+\tsmcup=\\E[?1049h, rmcup=\\E[?1049l,\n+\trc=\\E8, sc=\\E7,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-conemu.caps","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.22.0\n+## JLine v3.26.1\n@@ -6,1 +6,1 @@\n-Copyright (c) 2002-2018, the original author or authors.\n+Copyright (c) 2002-2023, the original author or authors.\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.lang.reflect.Constructor;\n-\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.AbstractPty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.freebsd.FreeBsdNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.solaris.SolarisNativePty;\n-\n-public abstract class JnaNativePty extends AbstractPty implements Pty {\n-\n-    private final int master;\n-    private final int slave;\n-    private final int slaveOut;\n-    private final String name;\n-    private final FileDescriptor masterFD;\n-    private final FileDescriptor slaveFD;\n-    private final FileDescriptor slaveOutFD;\n-\n-    public static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-\/\/        if (Platform.isMac()) {\n-\/\/            if (Platform.is64Bit() && Platform.isARM()) {\n-\/\/                throw new UnsupportedOperationException();\n-\/\/            }\n-\/\/            return OsXNativePty.current(console);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.current(console);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.current(console);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.current(console);\n-\/\/        } else {\n-\/\/            throw new UnsupportedOperationException();\n-\/\/        }\n-        return JDKNativePty.current(console);\n-    }\n-\n-    public static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.open(attr, size);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.open(attr, size);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.open(attr, size);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.open(attr, size);\n-\/\/        } else {\n-\/\/            throw new UnsupportedOperationException();\n-\/\/        }\n-        return JDKNativePty.open(attr, size);\n-    }\n-\n-    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        this(master, masterFD, slave, slaveFD, slave, slaveFD, name);\n-    }\n-\n-    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        this.master = master;\n-        this.slave = slave;\n-        this.slaveOut = slaveOut;\n-        this.name = name;\n-        this.masterFD = masterFD;\n-        this.slaveFD = slaveFD;\n-        this.slaveOutFD = slaveOutFD;\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        if (master > 0) {\n-            getMasterInput().close();\n-        }\n-        if (slave > 0) {\n-            getSlaveInput().close();\n-        }\n-    }\n-\n-    public int getMaster() {\n-        return master;\n-    }\n-\n-    public int getSlave() {\n-        return slave;\n-    }\n-\n-    public int getSlaveOut() {\n-        return slaveOut;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public FileDescriptor getMasterFD() {\n-        return masterFD;\n-    }\n-\n-    public FileDescriptor getSlaveFD() {\n-        return slaveFD;\n-    }\n-\n-    public FileDescriptor getSlaveOutFD() {\n-        return slaveOutFD;\n-    }\n-\n-    public InputStream getMasterInput() {\n-        return new FileInputStream(getMasterFD());\n-    }\n-\n-    public OutputStream getMasterOutput() {\n-        return new FileOutputStream(getMasterFD());\n-    }\n-\n-    protected InputStream doGetSlaveInput() {\n-        return new FileInputStream(getSlaveFD());\n-    }\n-\n-    public OutputStream getSlaveOutput() {\n-        return new FileOutputStream(getSlaveOutFD());\n-    }\n-\n-    protected static FileDescriptor newDescriptor(int fd) {\n-        try {\n-            Constructor<FileDescriptor> cns = FileDescriptor.class.getDeclaredConstructor(int.class);\n-            cns.setAccessible(true);\n-            return cns.newInstance(fd);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(\"Unable to create FileDescriptor\", e);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"JnaNativePty[\" + getName() + \"]\";\n-    }\n-\n-    public static boolean isPosixSystemStream(TerminalProvider.Stream stream) {\n-        switch (stream) {\n-            case Input: return isatty(0);\n-            case Output: return isatty(1);\n-            case Error: return isatty(2);\n-            default: return false;\n-        }\n-    }\n-\n-    public static String posixSystemStreamName(TerminalProvider.Stream stream) {\n-        switch (stream) {\n-            case Input: return ttyname(0);\n-            case Output: return ttyname(1);\n-            case Error: return ttyname(2);\n-            default: return null;\n-        }\n-    }\n-\n-    private static boolean isatty(int fd) {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.isatty(fd) == 1;\n-\/\/        } else {\n-\/\/            return false;\n-\/\/        }\n-        return JDKNativePty.isatty(fd) == 1;\n-    }\n-\n-    private static String ttyname(int fd) {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.ttyname(fd);\n-\/\/        } else {\n-\/\/            return null;\n-\/\/        }\n-        return JDKNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaNativePty.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaTerminalProvider implements TerminalProvider\n-{\n-    @Override\n-    public String name() {\n-        return \"jna\";\n-    }\n-\n-    public Pty current(TerminalProvider.Stream console) throws IOException {\n-        return JnaNativePty.current(console);\n-    }\n-\n-    public Pty open(Attributes attributes, Size size) throws IOException {\n-        return JnaNativePty.open(attributes, size);\n-    }\n-\n-    @Override\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        if (OSUtils.IS_WINDOWS) {\n-\/\/            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream );\n-\/\/        } else {\n-            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n-\/\/        }\n-    }\n-\n-\/\/    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-\/\/                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-\/\/                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console);\n-\/\/    }\n-\/\/\n-    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        Pty pty = jdk.internal.org.jline.terminal.impl.ExecPty.current(consoleStream);\n-        Pty pty = current(consoleStream);\n-        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-    }\n-\n-    @Override\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-        Pty pty = open(attributes, size);\n-        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n-    }\n-\n-    @Override\n-    public boolean isSystemStream(Stream stream) {\n-        try {\n-\/\/            if (OSUtils.IS_WINDOWS) {\n-\/\/                return isWindowsSystemStream(stream);\n-\/\/            } else {\n-                return isPosixSystemStream(stream);\n-\/\/            }\n-        } catch (Throwable t) {\n-            return false;\n-        }\n-    }\n-\n-\/\/    public boolean isWindowsSystemStream(Stream stream) {\n-\/\/        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n-\/\/    }\n-\n-    public boolean isPosixSystemStream(Stream stream) {\n-        return JnaNativePty.isPosixSystemStream(stream);\n-    }\n-\n-    @Override\n-    public String systemStreamName(Stream stream) {\n-        if (OSUtils.IS_WINDOWS) {\n-            return null;\n-        } else {\n-            return JnaNativePty.posixSystemStreamName(stream);\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaTerminalProvider implements TerminalProvider\n-{\n-    @Override\n-    public String name() {\n-        return \"jna\";\n-    }\n-\n-\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n-\/\/        return JnaNativePty.current(console);\n-\/\/    }\n-\/\/\n-\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n-\/\/        return JnaNativePty.open(attributes, size);\n-\/\/    }\n-\n-    @Override\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        if (OSUtils.IS_WINDOWS) {\n-            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n-    }\n-\n-\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-\/\/                                     Stream consoleStream) throws IOException {\n-\/\/        Pty pty = current(consoleStream);\n-\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n-\/\/    }\n-\n-    @Override\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-\/\/        Pty pty = open(attributes, size);\n-\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isSystemStream(Stream stream) {\n-        try {\n-            if (OSUtils.IS_WINDOWS) {\n-                return isWindowsSystemStream(stream);\n-            } else {\n-\/\/                return isPosixSystemStream(stream);\n-                return false;\n-            }\n-        } catch (Throwable t) {\n-            return false;\n-        }\n-    }\n-\n-    public boolean isWindowsSystemStream(Stream stream) {\n-        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n-    }\n-\n-\/\/    public boolean isPosixSystemStream(Stream stream) {\n-\/\/        return JnaNativePty.isPosixSystemStream(stream);\n-\/\/    }\n-\n-    @Override\n-    public String systemStreamName(Stream stream) {\n-\/\/        if (OSUtils.IS_WINDOWS) {\n-            return null;\n-\/\/        } else {\n-\/\/            return JnaNativePty.posixSystemStreamName(stream);\n-\/\/        }\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-class IntByReference {\n-\n-    public int value;\n-\n-    public int getValue() {\n-        return value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2017, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsConsoleWriter;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-import java.io.IOException;\n-\n-class JnaWinConsoleWriter extends AbstractWindowsConsoleWriter {\n-\n-    private final Pointer console;\n-    private final IntByReference writtenChars = new IntByReference();\n-\n-    JnaWinConsoleWriter(Pointer console) {\n-        this.console = console;\n-    }\n-\n-    @Override\n-    protected void writeConsole(char[] text, int len) throws IOException {\n-        try {\n-            Kernel32.INSTANCE.WriteConsoleW(this.console, text, len, this.writtenChars, null);\n-        } catch (LastErrorException e) {\n-            throw new IOException(\"Failed to write to console\", e);\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-import java.util.function.IntConsumer;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-public class JnaWinSysTerminal extends AbstractWindowsTerminal {\n-\n-    private static final Pointer consoleIn = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);\n-    private static final Pointer consoleOut = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);\n-    private static final Pointer consoleErr = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n-\n-    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, boolean paused, TerminalProvider.Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        Pointer console;\n-        switch (consoleStream) {\n-            case Output:\n-                console = JnaWinSysTerminal.consoleOut;\n-                break;\n-            case Error:\n-                console = JnaWinSysTerminal.consoleErr;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-        Writer writer;\n-        if (ansiPassThrough) {\n-            if (type == null) {\n-                type = OSUtils.IS_CONEMU ? TYPE_WINDOWS_CONEMU : TYPE_WINDOWS;\n-            }\n-            writer = new JnaWinConsoleWriter(console);\n-        } else {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n-            try {\n-                Kernel32.INSTANCE.SetConsoleMode(console, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n-                if (type == null) {\n-                    type = TYPE_WINDOWS_VTP;\n-                }\n-                writer = new JnaWinConsoleWriter(console);\n-            } catch (LastErrorException e) {\n-                if (OSUtils.IS_CONEMU) {\n-                    if (type == null) {\n-                        type = TYPE_WINDOWS_CONEMU;\n-                    }\n-                    writer = new JnaWinConsoleWriter(console);\n-                } else {\n-                    if (type == null) {\n-                        type = TYPE_WINDOWS;\n-                    }\n-                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(console)), console);\n-                }\n-            }\n-        }\n-        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-        \/\/ Start input pump thread\n-        if (!paused) {\n-            terminal.resume();\n-        }\n-        return terminal;\n-    }\n-\n-    public static boolean isWindowsSystemStream(TerminalProvider.Stream stream) {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Pointer console;\n-            switch (stream) {\n-                case Input: console = consoleIn; break;\n-                case Output: console = consoleOut; break;\n-                case Error: console = consoleErr; break;\n-                default: return false;\n-            }\n-            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n-            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-        strings.put(InfoCmp.Capability.key_mouse, \"\\\\E[M\");\n-    }\n-\n-    @Override\n-    protected int getConsoleMode() {\n-        IntByReference mode = new IntByReference();\n-        Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n-        return mode.getValue();\n-    }\n-\n-    @Override\n-    protected void setConsoleMode(int mode) {\n-        Kernel32.INSTANCE.SetConsoleMode(consoleIn, mode);\n-    }\n-\n-    public Size getSize() {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Size(info.windowWidth(), info.windowHeight());\n-    }\n-\n-    public Size getBufferSize() {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Size(info.dwSize.X, info.dwSize.Y);\n-    }\n-\n-    protected boolean processConsoleInput() throws IOException {\n-        Kernel32.INPUT_RECORD event = readConsoleInput(100);\n-        if (event == null) {\n-            return false;\n-        }\n-\n-        switch (event.EventType) {\n-            case Kernel32.INPUT_RECORD.KEY_EVENT:\n-                processKeyEvent(event.Event.KeyEvent);\n-                return true;\n-            case Kernel32.INPUT_RECORD.WINDOW_BUFFER_SIZE_EVENT:\n-                raise(Signal.WINCH);\n-                return false;\n-            case Kernel32.INPUT_RECORD.MOUSE_EVENT:\n-                processMouseEvent(event.Event.MouseEvent);\n-                return true;\n-            case Kernel32.INPUT_RECORD.FOCUS_EVENT:\n-                processFocusEvent(event.Event.FocusEvent.bSetFocus);\n-                return true;\n-            default:\n-                \/\/ Skip event\n-                return false;\n-        }\n-    }\n-\n-    private void processKeyEvent(Kernel32.KEY_EVENT_RECORD keyEvent) throws IOException {\n-        processKeyEvent(keyEvent.bKeyDown, keyEvent.wVirtualKeyCode, keyEvent.uChar.UnicodeChar, keyEvent.dwControlKeyState);\n-    }\n-\n-    private char[] focus = new char[] { '\\033', '[', ' ' };\n-\n-    private void processFocusEvent(boolean hasFocus) throws IOException {\n-        if (focusTracking) {\n-            focus[2] = hasFocus ? 'I' : 'O';\n-            slaveInputPipe.write(focus);\n-        }\n-    }\n-\n-    private char[] mouse = new char[] { '\\033', '[', 'M', ' ', ' ', ' ' };\n-\n-    private void processMouseEvent(Kernel32.MOUSE_EVENT_RECORD mouseEvent) throws IOException {\n-        int dwEventFlags = mouseEvent.dwEventFlags;\n-        int dwButtonState = mouseEvent.dwButtonState;\n-        if (tracking == MouseTracking.Off\n-                || tracking == MouseTracking.Normal && dwEventFlags == Kernel32.MOUSE_MOVED\n-                || tracking == MouseTracking.Button && dwEventFlags == Kernel32.MOUSE_MOVED && dwButtonState == 0) {\n-            return;\n-        }\n-        int cb = 0;\n-        dwEventFlags &= ~ Kernel32.DOUBLE_CLICK; \/\/ Treat double-clicks as normal\n-        if (dwEventFlags == Kernel32.MOUSE_WHEELED) {\n-            cb |= 64;\n-            if ((dwButtonState >> 16) < 0) {\n-                cb |= 1;\n-            }\n-        } else if (dwEventFlags == Kernel32.MOUSE_HWHEELED) {\n-            return;\n-        } else if ((dwButtonState & Kernel32.FROM_LEFT_1ST_BUTTON_PRESSED) != 0) {\n-            cb |= 0x00;\n-        } else if ((dwButtonState & Kernel32.RIGHTMOST_BUTTON_PRESSED) != 0) {\n-            cb |= 0x01;\n-        } else if ((dwButtonState & Kernel32.FROM_LEFT_2ND_BUTTON_PRESSED) != 0) {\n-            cb |= 0x02;\n-        } else {\n-            cb |= 0x03;\n-        }\n-        int cx = mouseEvent.dwMousePosition.X;\n-        int cy = mouseEvent.dwMousePosition.Y;\n-        mouse[3] = (char) (' ' + cb);\n-        mouse[4] = (char) (' ' + cx + 1);\n-        mouse[5] = (char) (' ' + cy + 1);\n-        slaveInputPipe.write(mouse);\n-    }\n-\n-    private final Kernel32.INPUT_RECORD[] inputEvents = new Kernel32.INPUT_RECORD[1];\n-    private final IntByReference eventsRead = new IntByReference();\n-\n-    private Kernel32.INPUT_RECORD readConsoleInput(int dwMilliseconds) throws IOException {\n-        if (Kernel32.INSTANCE.WaitForSingleObject(consoleIn, dwMilliseconds) != 0) {\n-            return null;\n-        }\n-        Kernel32.INSTANCE.ReadConsoleInput(consoleIn, inputEvents, 1, eventsRead);\n-        if (eventsRead.getValue() == 1) {\n-            return inputEvents[0];\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public Cursor getCursorPosition(IntConsumer discarded) {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Cursor(info.dwCursorPosition.X, info.dwCursorPosition.Y);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,634 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2018, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-\/\/OpenJDK changes:\n-\/\/-references to JNA types commented out\n-\/\/-replacement types provided where needed (IntByReference, LastErrorException, Pointer)\n-\/\/-methods not used by JLine commented out\n-\/\/-provided an implementation of the interface (Kernel32Impl), backed by a native implementation (Kernel32.cpp)\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.Structure;\n-\/\/import com.sun.jna.Union;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-\/\/import com.sun.jna.win32.StdCallLibrary;\n-\/\/import com.sun.jna.win32.W32APIOptions;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-interface Kernel32 {\/\/extends StdCallLibrary {\n-\n-    Kernel32 INSTANCE = new Kernel32Impl();\n-\/\/    Kernel32 INSTANCE = Native.load(\"kernel32\", Kernel32.class, W32APIOptions.UNICODE_OPTIONS);\n-\n-\/\/    Pointer INVALID_HANDLE_VALUE = Pointer.createConstant(-1L);\n-\n-    int STD_INPUT_HANDLE =  -10;\n-    int STD_OUTPUT_HANDLE = -11;\n-    int STD_ERROR_HANDLE =  -12;\n-\n-    int ENABLE_PROCESSED_INPUT =    0x0001;\n-    int ENABLE_LINE_INPUT =         0x0002;\n-    int ENABLE_ECHO_INPUT =         0x0004;\n-    int ENABLE_WINDOW_INPUT =       0x0008;\n-    int ENABLE_MOUSE_INPUT =        0x0010;\n-    int ENABLE_INSERT_MODE =        0x0020;\n-    int ENABLE_QUICK_EDIT_MODE =    0x0040;\n-    int ENABLE_EXTENDED_FLAGS =     0x0080;\n-\n-    int RIGHT_ALT_PRESSED =     0x0001;\n-    int LEFT_ALT_PRESSED =      0x0002;\n-    int RIGHT_CTRL_PRESSED =    0x0004;\n-    int LEFT_CTRL_PRESSED =     0x0008;\n-    int SHIFT_PRESSED =         0x0010;\n-\n-    int FOREGROUND_BLUE =       0x0001;\n-    int FOREGROUND_GREEN =      0x0002;\n-    int FOREGROUND_RED =        0x0004;\n-    int FOREGROUND_INTENSITY =  0x0008;\n-    int BACKGROUND_BLUE =       0x0010;\n-    int BACKGROUND_GREEN =      0x0020;\n-    int BACKGROUND_RED =        0x0040;\n-    int BACKGROUND_INTENSITY =  0x0080;\n-\n-    \/\/ Button state\n-    int FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;\n-    int RIGHTMOST_BUTTON_PRESSED     = 0x0002;\n-    int FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;\n-    int FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;\n-    int FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;\n-\n-    \/\/ Event flags\n-    int MOUSE_MOVED                  = 0x0001;\n-    int DOUBLE_CLICK                 = 0x0002;\n-    int MOUSE_WHEELED                = 0x0004;\n-    int MOUSE_HWHEELED               = 0x0008;\n-\n-    \/\/ DWORD WINAPI WaitForSingleObject(\n-    \/\/  _In_ HANDLE hHandle,\n-    \/\/  _In_ DWORD  dwMilliseconds\n-    \/\/ );\n-    int WaitForSingleObject(Pointer in_hHandle, int in_dwMilliseconds);\n-\n-    \/\/ HANDLE WINAPI GetStdHandle(\n-    \/\/ __in DWORD nStdHandle\n-    \/\/ );\n-    Pointer GetStdHandle(int nStdHandle);\n-\n-\/\/    \/\/ BOOL WINAPI AllocConsole(void);\n-\/\/    void AllocConsole() throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI FreeConsole(void);\n-\/\/    void FreeConsole() throws LastErrorException;\n-\/\/\n-\/\/    \/\/ HWND WINAPI GetConsoleWindow(void);\n-\/\/    Pointer GetConsoleWindow();\n-\/\/\n-\/\/    \/\/ UINT WINAPI GetConsoleCP(void)\n-\/\/    int GetConsoleCP();\n-\/\/\n-    \/\/ UINT WINAPI GetConsoleOutputCP(void)\n-    int GetConsoleOutputCP();\n-\n-    \/\/ BOOL WINAPI FillConsoleOutputCharacter(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ TCHAR cCharacter,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _In_ COORD dwWriteCoord,\n-    \/\/ _Out_ LPDWORD lpNumberOfCharsWritten);\n-    void FillConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-                                    char in_cCharacter, int in_nLength, COORD in_dwWriteCoord,\n-                                    IntByReference out_lpNumberOfCharsWritten)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI FillConsoleOutputAttribute(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ WORD wAttribute,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _In_ COORD dwWriteCoord,\n-    \/\/ _Out_ LPDWORD lpNumberOfAttrsWritten);\n-    void FillConsoleOutputAttribute(Pointer in_hConsoleOutput,\n-                                    short in_wAttribute, int in_nLength, COORD in_dwWriteCoord,\n-                                    IntByReference out_lpNumberOfAttrsWritten)\n-            throws LastErrorException;\n-\/\/\n-\/\/\/\/    \/\/ BOOL WINAPI GetConsoleCursorInfo(\n-\/\/\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/\/\/    \/\/ _Out_ PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);\n-\/\/\/\/    void GetConsoleCursorInfo(Pointer in_hConsoleOutput,\n-\/\/\/\/                              CONSOLE_CURSOR_INFO.ByReference out_lpConsoleCursorInfo)\n-\/\/\/\/            throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI GetConsoleMode(\n-    \/\/   _In_   HANDLE hConsoleHandle,\n-    \/\/   _Out_  LPDWORD lpMode);\n-    void GetConsoleMode(\n-            Pointer in_hConsoleOutput,\n-            IntByReference out_lpMode)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI GetConsoleScreenBufferInfo(\n-    \/\/ _In_   HANDLE hConsoleOutput,\n-    \/\/ _Out_  PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);\n-    void GetConsoleScreenBufferInfo(\n-            Pointer in_hConsoleOutput,\n-            CONSOLE_SCREEN_BUFFER_INFO out_lpConsoleScreenBufferInfo)\n-            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI GetNumberOfConsoleInputEvents(\n-\/\/    \/\/ _In_ HANDLE hConsoleInput,\n-\/\/    \/\/ _Out_ LPDWORD lpcNumberOfEvents);\n-\/\/    void GetNumberOfConsoleInputEvents(Pointer in_hConsoleOutput,\n-\/\/                                       IntByReference out_lpcNumberOfEvents) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI ReadConsoleInput(\n-    \/\/ _In_ HANDLE hConsoleInput,\n-    \/\/ _Out_ PINPUT_RECORD lpBuffer,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _Out_ LPDWORD lpNumberOfEventsRead);\n-    void ReadConsoleInput(Pointer in_hConsoleOutput,\n-                          INPUT_RECORD[] out_lpBuffer, int in_nLength,\n-                          IntByReference out_lpNumberOfEventsRead) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleCtrlHandler(\n-\/\/    \/\/ _In_opt_  PHANDLER_ROUTINE HandlerRoutine,\n-\/\/    \/\/ _In_      BOOL Add);\n-\/\/    void SetConsoleCtrlHandler(\n-\/\/            Pointer in_opt_HandlerRoutine,\n-\/\/            boolean in_Add)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI ReadConsoleOutput(\n-\/\/    \/\/ _In_     HANDLE hConsoleOutput,\n-\/\/    \/\/ _Out_    PCHAR_INFO lpBuffer,\n-\/\/    \/\/ _In_     COORD dwBufferSize,\n-\/\/    \/\/ _In_     COORD dwBufferCoord,\n-\/\/    \/\/ _Inout_  PSMALL_RECT lpReadRegion);\n-\/\/\/\/    void ReadConsoleOutput(Pointer in_hConsoleOutput, CHAR_INFO[] out_lpBuffer,\n-\/\/\/\/                           COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                           SMALL_RECT inout_lpReadRegion) throws LastErrorException;\n-\/\/\/\/    void ReadConsoleOutputA(Pointer in_hConsoleOutput, CHAR_INFO[] out_lpBuffer,\n-\/\/\/\/                            COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                            SMALL_RECT inout_lpReadRegion) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI ReadConsoleOutputCharacter(\n-\/\/    \/\/ _In_   HANDLE hConsoleOutput,\n-\/\/    \/\/ _Out_  LPTSTR lpCharacter,\n-\/\/    \/\/ _In_   DWORD nLength,\n-\/\/    \/\/ _In_   COORD dwReadCoord,\n-\/\/    \/\/ _Out_  LPDWORD lpNumberOfCharsRead);\n-\/\/    void ReadConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-\/\/                                    char[] ouy_lpCharacter, int in_nLength, COORD in_dwReadCoord,\n-\/\/                                    IntByReference out_lpNumberOfCharsRead)\n-\/\/            throws LastErrorException;\n-\/\/    void ReadConsoleOutputCharacterA(Pointer in_hConsoleOutput,\n-\/\/                                     byte[] ouy_lpCharacter, int in_nLength, COORD in_dwReadCoord,\n-\/\/                                     IntByReference out_lpNumberOfCharsRead)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleCursorInfo(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);\n-\/\/    void SetConsoleCursorInfo(Pointer in_hConsoleOutput,\n-\/\/                              CONSOLE_CURSOR_INFO in_lpConsoleCursorInfo)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleCP(\n-\/\/    \/\/ _In_ UINT wCodePageID);\n-\/\/    void SetConsoleCP(int in_wCodePageID) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleOutputCP(\n-\/\/    \/\/ _In_ UINT wCodePageID);\n-\/\/    void SetConsoleOutputCP(int in_wCodePageID) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI SetConsoleCursorPosition(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ COORD dwCursorPosition);\n-    void SetConsoleCursorPosition(Pointer in_hConsoleOutput,\n-                                  COORD in_dwCursorPosition) throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI SetConsoleMode(\n-    \/\/   _In_  HANDLE hConsoleHandle,\n-    \/\/   _In_  DWORD dwMode);\n-    void SetConsoleMode(\n-            Pointer in_hConsoleOutput,\n-            int in_dwMode) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleScreenBufferSize(\n-\/\/    \/\/ __in HANDLE hConsoleOutput,\n-\/\/    \/\/ __in COORD dwSize\n-\/\/    \/\/ );\n-\/\/    void SetConsoleScreenBufferSize(Pointer in_hConsoleOutput,\n-\/\/                                    COORD in_dwSize) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI SetConsoleTextAttribute(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ WORD   wAttributes\n-    \/\/ );\n-    void SetConsoleTextAttribute(Pointer in_hConsoleOutput,\n-                                 short in_wAttributes)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI SetConsoleTitle(\n-    \/\/ _In_ LPCTSTR lpConsoleTitle\n-    \/\/ );\n-    void SetConsoleTitle(String in_lpConsoleTitle)\n-            throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleWindowInfo(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ BOOL bAbsolute,\n-\/\/    \/\/ _In_ const SMALL_RECT *lpConsoleWindow);\n-\/\/    void SetConsoleWindowInfo(Pointer in_hConsoleOutput,\n-\/\/                              boolean in_bAbsolute, SMALL_RECT in_lpConsoleWindow)\n-\/\/            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI WriteConsole(\n-    \/\/  _In_             HANDLE  hConsoleOutput,\n-    \/\/  _In_       const VOID    *lpBuffer,\n-    \/\/  _In_             DWORD   nNumberOfCharsToWrite,\n-    \/\/  _Out_            LPDWORD lpNumberOfCharsWritten,\n-    \/\/  _Reserved_       LPVOID  lpReserved\n-    \/\/ );\n-    void WriteConsoleW(Pointer in_hConsoleOutput, char[] in_lpBuffer, int in_nNumberOfCharsToWrite,\n-                          IntByReference out_lpNumberOfCharsWritten, Pointer reserved_lpReserved) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI WriteConsoleOutput(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ const CHAR_INFO *lpBuffer,\n-\/\/    \/\/ _In_ COORD dwBufferSize,\n-\/\/    \/\/ _In_ COORD dwBufferCoord,\n-\/\/    \/\/ _Inout_ PSMALL_RECT lpWriteRegion);\n-\/\/\/\/    void WriteConsoleOutput(Pointer in_hConsoleOutput, CHAR_INFO[] in_lpBuffer,\n-\/\/\/\/                            COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                            SMALL_RECT inout_lpWriteRegion) throws LastErrorException;\n-\/\/\/\/    void WriteConsoleOutputA(Pointer in_hConsoleOutput, CHAR_INFO[] in_lpBuffer,\n-\/\/\/\/                             COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                             SMALL_RECT inout_lpWriteRegion) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI WriteConsoleOutputCharacter(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ LPCTSTR lpCharacter,\n-\/\/    \/\/ _In_ DWORD nLength,\n-\/\/    \/\/ _In_ COORD dwWriteCoord,\n-\/\/    \/\/ _Out_ LPDWORD lpNumberOfCharsWritten);\n-\/\/    void WriteConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-\/\/                                     char[] in_lpCharacter, int in_nLength, COORD in_dwWriteCoord,\n-\/\/                                     IntByReference out_lpNumberOfCharsWritten)\n-\/\/            throws LastErrorException;\n-\/\/    void WriteConsoleOutputCharacterA(Pointer in_hConsoleOutput,\n-\/\/                                      byte[] in_lpCharacter, int in_nLength, COORD in_dwWriteCoord,\n-\/\/                                      IntByReference out_lpNumberOfCharsWritten)\n-\/\/            throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI ScrollConsoleScreenBuffer(\n-    \/\/     _In_           HANDLE     hConsoleOutput,\n-    \/\/     _In_     const SMALL_RECT *lpScrollRectangle,\n-    \/\/     _In_opt_ const SMALL_RECT *lpClipRectangle,\n-    \/\/     _In_           COORD      dwDestinationOrigin,\n-    \/\/     _In_     const CHAR_INFO  *lpFill);\n-    void ScrollConsoleScreenBuffer(Pointer in_hConsoleOutput,\n-                                   SMALL_RECT in_lpScrollRectangle,\n-                                   SMALL_RECT in_lpClipRectangle,\n-                                   COORD in_dwDestinationOrigin,\n-                                   CHAR_INFO in_lpFill)\n-            throws LastErrorException;\n-\n-    \/\/ typedef struct _CHAR_INFO {\n-    \/\/   union {\n-    \/\/     WCHAR UnicodeChar;\n-    \/\/     CHAR  AsciiChar;\n-    \/\/   } Char;\n-    \/\/   WORD  Attributes;\n-    \/\/ } CHAR_INFO, *PCHAR_INFO;\n-    class CHAR_INFO {\/\/extends Structure {\n-        public CHAR_INFO() {\n-        }\n-\n-        public CHAR_INFO(char c, short attr) {\n-            uChar = new UnionChar(c);\n-            Attributes = attr;\n-        }\n-\n-\/\/        public CHAR_INFO(byte c, short attr) {\n-\/\/            uChar = new UnionChar(c);\n-\/\/            Attributes = attr;\n-\/\/        }\n-\n-        public UnionChar uChar;\n-        public short Attributes;\n-\n-\/\/        public static CHAR_INFO[] createArray(int size) {\n-\/\/            return (CHAR_INFO[]) new CHAR_INFO().toArray(size);\n-\/\/        }\n-\/\/\n-\/\/        private static String[] fieldOrder = { \"uChar\", \"Attributes\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _CONSOLE_CURSOR_INFO {\n-    \/\/   DWORD dwSize;\n-    \/\/   BOOL  bVisible;\n-    \/\/ } CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;\n-    class CONSOLE_CURSOR_INFO {\/\/extends Structure {\n-        public int dwSize;\n-        public boolean bVisible;\n-\n-\/\/        public static class ByReference extends CONSOLE_CURSOR_INFO implements\n-\/\/                Structure.ByReference {\n-\/\/        }\n-\/\/\n-\/\/        private static String[] fieldOrder = { \"dwSize\", \"bVisible\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _CONSOLE_SCREEN_BUFFER_INFO {\n-    \/\/   COORD      dwSize;\n-    \/\/   COORD      dwCursorPosition;\n-    \/\/   WORD       wAttributes;\n-    \/\/   SMALL_RECT srWindow;\n-    \/\/   COORD      dwMaximumWindowSize;\n-    \/\/ } CONSOLE_SCREEN_BUFFER_INFO;\n-    class CONSOLE_SCREEN_BUFFER_INFO {\/\/extends Structure {\n-        public COORD      dwSize;\n-        public COORD      dwCursorPosition;\n-        public short      wAttributes;\n-        public SMALL_RECT srWindow;\n-        public COORD      dwMaximumWindowSize;\n-\n-\/\/        private static String[] fieldOrder = { \"dwSize\", \"dwCursorPosition\", \"wAttributes\", \"srWindow\", \"dwMaximumWindowSize\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-\n-        public int windowWidth() {\n-            return this.srWindow.width() + 1;\n-        }\n-\n-        public int windowHeight() {\n-            return this.srWindow.height() + 1;\n-        }\n-    }\n-\n-    \/\/ typedef struct _COORD {\n-    \/\/    SHORT X;\n-    \/\/    SHORT Y;\n-    \/\/  } COORD, *PCOORD;\n-    class COORD {\/\/extends Structure implements Structure.ByValue {\n-        public COORD() {\n-        }\n-\n-        public COORD(short X, short Y) {\n-            this.X = X;\n-            this.Y = Y;\n-        }\n-\n-        public short X;\n-        public short Y;\n-\n-\/\/        private static String[] fieldOrder = { \"X\", \"Y\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _INPUT_RECORD {\n-    \/\/   WORD  EventType;\n-    \/\/   union {\n-    \/\/     KEY_EVENT_RECORD          KeyEvent;\n-    \/\/     MOUSE_EVENT_RECORD        MouseEvent;\n-    \/\/     WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\n-    \/\/     MENU_EVENT_RECORD         MenuEvent;\n-    \/\/     FOCUS_EVENT_RECORD        FocusEvent;\n-    \/\/   } Event;\n-    \/\/ } INPUT_RECORD;\n-    class INPUT_RECORD {\/\/extends Structure {\n-        public static final short KEY_EVENT = 0x0001;\n-        public static final short MOUSE_EVENT = 0x0002;\n-        public static final short WINDOW_BUFFER_SIZE_EVENT = 0x0004;\n-        public static final short MENU_EVENT = 0x0008;\n-        public static final short FOCUS_EVENT = 0x0010;\n-\n-        public short EventType;\n-        public EventUnion Event;\n-\n-        public static class EventUnion {\/\/extends Union {\n-            public KEY_EVENT_RECORD KeyEvent;\n-            public MOUSE_EVENT_RECORD MouseEvent;\n-            public WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\n-            public MENU_EVENT_RECORD MenuEvent;\n-            public FOCUS_EVENT_RECORD FocusEvent;\n-        }\n-\n-\/\/        @Override\n-\/\/        public void read() {\n-\/\/            readField(\"EventType\");\n-\/\/            switch (EventType) {\n-\/\/                case KEY_EVENT:\n-\/\/                    Event.setType(KEY_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case MOUSE_EVENT:\n-\/\/                    Event.setType(MOUSE_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case WINDOW_BUFFER_SIZE_EVENT:\n-\/\/                    Event.setType(WINDOW_BUFFER_SIZE_RECORD.class);\n-\/\/                    break;\n-\/\/                case MENU_EVENT:\n-\/\/                    Event.setType(MENU_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case FOCUS_EVENT:\n-\/\/                    Event.setType(MENU_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/            }\n-\/\/            super.read();\n-\/\/        }\n-\n-\/\/        private static String[] fieldOrder = {\"EventType\", \"Event\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _KEY_EVENT_RECORD {\n-    \/\/   BOOL  bKeyDown;\n-    \/\/   WORD  wRepeatCount;\n-    \/\/   WORD  wVirtualKeyCode;\n-    \/\/   WORD  wVirtualScanCode;\n-    \/\/   union {\n-    \/\/     WCHAR UnicodeChar;\n-    \/\/     CHAR  AsciiChar;\n-    \/\/   } uChar;\n-    \/\/   DWORD dwControlKeyState;\n-    \/\/ } KEY_EVENT_RECORD;\n-    class KEY_EVENT_RECORD {\/\/extends Structure {\n-        public boolean bKeyDown;\n-        public short wRepeatCount;\n-        public short wVirtualKeyCode;\n-        public short wVirtualScanCode;\n-        public UnionChar uChar;\n-        public int dwControlKeyState;\n-\n-\/\/        private static String[] fieldOrder = {\"bKeyDown\", \"wRepeatCount\", \"wVirtualKeyCode\", \"wVirtualScanCode\", \"uChar\", \"dwControlKeyState\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _MOUSE_EVENT_RECORD {\n-    \/\/   COORD dwMousePosition;\n-    \/\/   DWORD dwButtonState;\n-    \/\/   DWORD dwControlKeyState;\n-    \/\/   DWORD dwEventFlags;\n-    \/\/ } MOUSE_EVENT_RECORD;\n-    class MOUSE_EVENT_RECORD {\/\/extends Structure {\n-        public COORD dwMousePosition;\n-        public int dwButtonState;\n-        public int dwControlKeyState;\n-        public int dwEventFlags;\n-\n-\/\/        private static String[] fieldOrder = { \"dwMousePosition\", \"dwButtonState\", \"dwControlKeyState\", \"dwEventFlags\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _WINDOW_BUFFER_SIZE_RECORD {\n-    \/\/   COORD dwSize;\n-    \/\/ } WINDOW_BUFFER_SIZE_RECORD;\n-    class WINDOW_BUFFER_SIZE_RECORD {\/\/extends Structure {\n-        public COORD dwSize;\n-\n-\/\/        private static String[] fieldOrder = {\"dwSize\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _MENU_EVENT_RECORD {\n-    \/\/   UINT dwCommandId;\n-    \/\/ } MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;\n-    class MENU_EVENT_RECORD {\/\/extends Structure {\n-\n-        public int dwCommandId;\n-\n-\/\/        private static String[] fieldOrder = {\"dwCommandId\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _FOCUS_EVENT_RECORD {\n-    \/\/  BOOL bSetFocus;\n-    \/\/} FOCUS_EVENT_RECORD;\n-    class FOCUS_EVENT_RECORD {\/\/extends Structure {\n-        public boolean bSetFocus;\n-\n-\/\/        private static String[] fieldOrder = {\"bSetFocus\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _SMALL_RECT {\n-    \/\/    SHORT Left;\n-    \/\/    SHORT Top;\n-    \/\/    SHORT Right;\n-    \/\/    SHORT Bottom;\n-    \/\/  } SMALL_RECT;\n-    class SMALL_RECT {\/\/extends Structure {\n-        public SMALL_RECT() {\n-        }\n-\n-        public SMALL_RECT(SMALL_RECT org) {\n-            this(org.Top, org.Left, org.Bottom, org.Right);\n-        }\n-\n-        public SMALL_RECT(short Top, short Left, short Bottom, short Right) {\n-            this.Top = Top;\n-            this.Left = Left;\n-            this.Bottom = Bottom;\n-            this.Right = Right;\n-        }\n-\n-        public short Left;\n-        public short Top;\n-        public short Right;\n-        public short Bottom;\n-\n-\/\/        private static String[] fieldOrder = { \"Left\", \"Top\", \"Right\", \"Bottom\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-\n-        public short width() {\n-            return (short)(this.Right - this.Left);\n-        }\n-\n-        public short height() {\n-            return (short)(this.Bottom - this.Top);\n-        }\n-\n-    }\n-\n-    class UnionChar {\/\/extends Union {\n-        public UnionChar() {\n-        }\n-\n-        public UnionChar(char c) {\n-\/\/            setType(char.class);\n-            UnicodeChar = c;\n-        }\n-\n-\/\/        public UnionChar(byte c) {\n-\/\/            setType(byte.class);\n-\/\/            AsciiChar = c;\n-\/\/        }\n-\n-        public void set(char c) {\n-\/\/            setType(char.class);\n-            UnicodeChar = c;\n-        }\n-\n-\/\/        public void set(byte c) {\n-\/\/            setType(byte.class);\n-\/\/            AsciiChar = c;\n-\/\/        }\n-\n-        public char UnicodeChar;\n-\/\/        public byte AsciiChar;\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32.java","additions":0,"deletions":634,"binary":false,"changes":634,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT;\n-\n-public class Kernel32Impl implements Kernel32 {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native int WaitForSingleObject(Pointer in_hHandle, int in_dwMilliseconds);\n-\n-    @Override\n-    public native Pointer GetStdHandle(int nStdHandle);\n-\n-    @Override\n-    public native int GetConsoleOutputCP();\n-\n-    @Override\n-    public native void FillConsoleOutputCharacter(Pointer in_hConsoleOutput, char in_cCharacter, int in_nLength, COORD in_dwWriteCoord, IntByReference out_lpNumberOfCharsWritten) throws LastErrorException;\n-\n-    @Override\n-    public native void FillConsoleOutputAttribute(Pointer in_hConsoleOutput, short in_wAttribute, int in_nLength, COORD in_dwWriteCoord, IntByReference out_lpNumberOfAttrsWritten) throws LastErrorException;\n-\n-    @Override\n-    public native void GetConsoleMode(Pointer in_hConsoleOutput, IntByReference out_lpMode) throws LastErrorException;\n-\n-    @Override\n-    public native void GetConsoleScreenBufferInfo(Pointer in_hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO out_lpConsoleScreenBufferInfo) throws LastErrorException;\n-\n-    @Override\n-    public native void ReadConsoleInput(Pointer in_hConsoleOutput, INPUT_RECORD[] out_lpBuffer, int in_nLength, IntByReference out_lpNumberOfEventsRead) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleCursorPosition(Pointer in_hConsoleOutput, COORD in_dwCursorPosition) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleMode(Pointer in_hConsoleOutput, int in_dwMode) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleTextAttribute(Pointer in_hConsoleOutput, short in_wAttributes) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleTitle(String in_lpConsoleTitle) throws LastErrorException;\n-\n-    @Override\n-    public native void WriteConsoleW(Pointer in_hConsoleOutput, char[] in_lpBuffer, int in_nNumberOfCharsToWrite, IntByReference out_lpNumberOfCharsWritten, Pointer reserved_lpReserved) throws LastErrorException;\n-\n-    @Override\n-    public native void ScrollConsoleScreenBuffer(Pointer in_hConsoleOutput, SMALL_RECT in_lpScrollRectangle, SMALL_RECT in_lpClipRectangle, COORD in_dwDestinationOrigin, CHAR_INFO in_lpFill) throws LastErrorException;\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32Impl.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-class Pointer {\n-    public final long value;\n-\n-    public Pointer(long value) {\n-        this.value = value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,353 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2016, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import java.io.IOException;\n-import java.io.Writer;\n-\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.utils.AnsiWriter;\n-import jdk.internal.org.jline.utils.Colors;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_BLUE;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_GREEN;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_INTENSITY;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_RED;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_BLUE;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_GREEN;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_INTENSITY;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_RED;\n-\n-\n-\/**\n- * A Windows ANSI escape processor, uses JNA to access native platform\n- * API's to change the console attributes.\n- *\n- * @since 1.0\n- * @author <a href=\"http:\/\/hiramchirino.com\">Hiram Chirino<\/a>\n- * @author Joris Kuipers\n- *\/\n-public final class WindowsAnsiWriter extends AnsiWriter {\n-\n-    private static final short FOREGROUND_BLACK   = 0;\n-    private static final short FOREGROUND_YELLOW  = (short) (FOREGROUND_RED|FOREGROUND_GREEN);\n-    private static final short FOREGROUND_MAGENTA = (short) (FOREGROUND_BLUE|FOREGROUND_RED);\n-    private static final short FOREGROUND_CYAN    = (short) (FOREGROUND_BLUE|FOREGROUND_GREEN);\n-    private static final short FOREGROUND_WHITE   = (short) (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);\n-\n-    private static final short BACKGROUND_BLACK   = 0;\n-    private static final short BACKGROUND_YELLOW  = (short) (BACKGROUND_RED|BACKGROUND_GREEN);\n-    private static final short BACKGROUND_MAGENTA = (short) (BACKGROUND_BLUE|BACKGROUND_RED);\n-    private static final short BACKGROUND_CYAN    = (short) (BACKGROUND_BLUE|BACKGROUND_GREEN);\n-    private static final short BACKGROUND_WHITE   = (short) (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);\n-\n-    private static final short ANSI_FOREGROUND_COLOR_MAP[] = {\n-            FOREGROUND_BLACK,\n-            FOREGROUND_RED,\n-            FOREGROUND_GREEN,\n-            FOREGROUND_YELLOW,\n-            FOREGROUND_BLUE,\n-            FOREGROUND_MAGENTA,\n-            FOREGROUND_CYAN,\n-            FOREGROUND_WHITE,\n-    };\n-\n-    private static final short ANSI_BACKGROUND_COLOR_MAP[] = {\n-            BACKGROUND_BLACK,\n-            BACKGROUND_RED,\n-            BACKGROUND_GREEN,\n-            BACKGROUND_YELLOW,\n-            BACKGROUND_BLUE,\n-            BACKGROUND_MAGENTA,\n-            BACKGROUND_CYAN,\n-            BACKGROUND_WHITE,\n-    };\n-\n-    private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n-\n-    private final Pointer console;\n-\n-    private final Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-    private final short originalColors;\n-\n-    private boolean negative;\n-    private boolean bold;\n-    private boolean underline;\n-    private short savedX = -1;\n-    private short savedY = -1;\n-\n-    public WindowsAnsiWriter(Writer out, Pointer console) throws IOException {\n-        super(out);\n-        this.console = console;\n-        getConsoleInfo();\n-        originalColors = info.wAttributes;\n-    }\n-\n-    private void getConsoleInfo() throws IOException {\n-        out.flush();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(console, info);\n-        if (negative) {\n-            info.wAttributes = invertAttributeColors(info.wAttributes);\n-        }\n-    }\n-\n-    private void applyAttribute() throws IOException {\n-        out.flush();\n-        short attributes = info.wAttributes;\n-        \/\/ bold is simulated by high foreground intensity\n-        if (bold) {\n-            attributes |= FOREGROUND_INTENSITY;\n-        }\n-        \/\/ underline is simulated by high foreground intensity\n-        if (underline) {\n-            attributes |= BACKGROUND_INTENSITY;\n-        }\n-        if (negative) {\n-            attributes = invertAttributeColors(attributes);\n-        }\n-        Kernel32.INSTANCE.SetConsoleTextAttribute(console, attributes);\n-    }\n-\n-    private short invertAttributeColors(short attributes) {\n-        \/\/ Swap the the Foreground and Background bits.\n-        int fg = 0x000F & attributes;\n-        fg <<= 4;\n-        int bg = 0X00F0 & attributes;\n-        bg >>= 4;\n-        attributes = (short) ((attributes & 0xFF00) | fg | bg);\n-        return attributes;\n-    }\n-\n-    private void applyCursorPosition() throws IOException {\n-        info.dwCursorPosition.X = (short) Math.max(0, Math.min(info.dwSize.X - 1, info.dwCursorPosition.X));\n-        info.dwCursorPosition.Y = (short) Math.max(0, Math.min(info.dwSize.Y - 1, info.dwCursorPosition.Y));\n-        Kernel32.INSTANCE.SetConsoleCursorPosition(console, info.dwCursorPosition);\n-    }\n-\n-    protected void processEraseScreen(int eraseOption) throws IOException {\n-        getConsoleInfo();\n-        IntByReference written = new IntByReference();\n-        switch(eraseOption) {\n-            case ERASE_SCREEN:\n-                Kernel32.COORD topLeft = new Kernel32.COORD();\n-                topLeft.X = 0;\n-                topLeft.Y = info.srWindow.Top;\n-                int screenLength = info.srWindow.height() * info.dwSize.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', screenLength, topLeft, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, screenLength, topLeft, written);\n-                break;\n-            case ERASE_SCREEN_TO_BEGINING:\n-                Kernel32.COORD topLeft2 = new Kernel32.COORD();\n-                topLeft2.X = 0;\n-                topLeft2.Y = info.srWindow.Top;\n-                int lengthToCursor = (info.dwCursorPosition.Y - info.srWindow.Top) * info.dwSize.X + info.dwCursorPosition.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToCursor, topLeft2, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToCursor, topLeft2, written);\n-                break;\n-            case ERASE_SCREEN_TO_END:\n-                int lengthToEnd = (info.srWindow.Bottom - info.dwCursorPosition.Y) * info.dwSize.X +\n-                        (info.dwSize.X - info.dwCursorPosition.X);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToEnd, info.dwCursorPosition, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToEnd, info.dwCursorPosition, written);\n-        }\n-    }\n-\n-    protected void processEraseLine(int eraseOption) throws IOException {\n-        getConsoleInfo();\n-        IntByReference written = new IntByReference();\n-        switch(eraseOption) {\n-            case ERASE_LINE:\n-                Kernel32.COORD leftColCurrRow = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', info.dwSize.X, leftColCurrRow, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwSize.X, leftColCurrRow, written);\n-                break;\n-            case ERASE_LINE_TO_BEGINING:\n-                Kernel32.COORD leftColCurrRow2 = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', info.dwCursorPosition.X, leftColCurrRow2, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwCursorPosition.X, leftColCurrRow2, written);\n-                break;\n-            case ERASE_LINE_TO_END:\n-                int lengthToLastCol = info.dwSize.X - info.dwCursorPosition.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToLastCol, info.dwCursorPosition, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToLastCol, info.dwCursorPosition, written);\n-        }\n-    }\n-\n-    protected void processCursorUpLine(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = 0;\n-        info.dwCursorPosition.Y -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorDownLine(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = 0;\n-        info.dwCursorPosition.Y += (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorLeft(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorRight(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X += (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorDown(int count) throws IOException {\n-        getConsoleInfo();\n-        int nb = Math.max(0, info.dwCursorPosition.Y + count - info.dwSize.Y + 1);\n-        if (nb != count) {\n-            info.dwCursorPosition.Y += (short) count;\n-            applyCursorPosition();\n-        }\n-        if (nb > 0) {\n-            Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-            scroll.Top = 0;\n-            Kernel32.COORD org = new Kernel32.COORD();\n-            org.X = 0;\n-            org.Y = (short)(- nb);\n-            Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-            Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-        }\n-    }\n-\n-    protected void processCursorUp(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.Y -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorTo(int row, int col) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.Y = (short) (info.srWindow.Top + row - 1);\n-        info.dwCursorPosition.X = (short) (col - 1);\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorToColumn(int x) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = (short) (x - 1);\n-        applyCursorPosition();\n-    }\n-\n-    @Override\n-    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n-        int color = Colors.roundColor(paletteIndex, 16);\n-        info.wAttributes = (short) ((info.wAttributes & ~0x0007) | ANSI_FOREGROUND_COLOR_MAP[color & 0x07]);\n-        info.wAttributes = (short) ((info.wAttributes & ~FOREGROUND_INTENSITY) | (color >= 8 ? FOREGROUND_INTENSITY : 0));\n-        applyAttribute();\n-    }\n-\n-    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n-        int color = Colors.roundColor(paletteIndex, 16);\n-        info.wAttributes = (short)((info.wAttributes & ~0x0070 ) | ANSI_BACKGROUND_COLOR_MAP[color & 0x07]);\n-        info.wAttributes = (short) ((info.wAttributes & ~BACKGROUND_INTENSITY) | (color >= 8 ? BACKGROUND_INTENSITY : 0));\n-        applyAttribute();\n-    }\n-\n-    protected void processDefaultTextColor() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x000F ) | (originalColors & 0x000F));\n-        applyAttribute();\n-    }\n-\n-    protected void processDefaultBackgroundColor() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x00F0 ) | (originalColors & 0x00F0));\n-        applyAttribute();\n-    }\n-\n-    protected void processAttributeRest() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x00FF ) | originalColors);\n-        this.negative = false;\n-        this.bold = false;\n-        this.underline = false;\n-        applyAttribute();\n-    }\n-\n-    protected void processSetAttribute(int attribute) throws IOException {\n-        switch(attribute) {\n-            case ATTRIBUTE_INTENSITY_BOLD:\n-                bold = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_INTENSITY_NORMAL:\n-                bold = false;\n-                applyAttribute();\n-                break;\n-\n-            case ATTRIBUTE_UNDERLINE:\n-                underline = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_UNDERLINE_OFF:\n-                underline = false;\n-                applyAttribute();\n-                break;\n-\n-            case ATTRIBUTE_NEGATIVE_ON:\n-                negative = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_NEGATIVE_OFF:\n-                negative = false;\n-                applyAttribute();\n-                break;\n-        }\n-    }\n-\n-    protected void processSaveCursorPosition() throws IOException {\n-        getConsoleInfo();\n-        savedX = info.dwCursorPosition.X;\n-        savedY = info.dwCursorPosition.Y;\n-    }\n-\n-    protected void processRestoreCursorPosition() throws IOException {\n-        \/\/ restore only if there was a save operation first\n-        if (savedX != -1 && savedY != -1) {\n-            out.flush();\n-            info.dwCursorPosition.X = savedX;\n-            info.dwCursorPosition.Y = savedY;\n-            applyCursorPosition();\n-        }\n-    }\n-\n-    @Override\n-    protected void processInsertLine(int optionInt) throws IOException {\n-        getConsoleInfo();\n-        Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-        scroll.Top = info.dwCursorPosition.Y;\n-        Kernel32.COORD org = new Kernel32.COORD();\n-        org.X = 0;\n-        org.Y = (short)(info.dwCursorPosition.Y + optionInt);\n-        Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-        Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-    }\n-\n-    @Override\n-    protected void processDeleteLine(int optionInt) throws IOException {\n-        getConsoleInfo();\n-        Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-        scroll.Top = info.dwCursorPosition.Y;\n-        Kernel32.COORD org = new Kernel32.COORD();\n-        org.X = 0;\n-        org.Y = (short)(info.dwCursorPosition.Y - optionInt);\n-        Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-        Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-    }\n-\n-    protected void processChangeWindowTitle(String label) {\n-        Kernel32.INSTANCE.SetConsoleTitle(label);\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/WindowsAnsiWriter.java","additions":0,"deletions":353,"binary":false,"changes":353,"status":"deleted"},{"patch":"@@ -1,710 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl.h\"\n-\n-#include <stdlib.h>\n-#include <wincon.h>\n-#include <winuser.h>\n-\n-static jclass pointerClass;\n-static jmethodID pointerConstructor;\n-static jfieldID pointerValue;\n-\n-static jclass intByReferenceClass;\n-static jfieldID intByReferenceValue;\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO\n-static jclass CHAR_INFO_Class;\n-static jmethodID CHAR_INFO_Constructor;\n-static jfieldID CHAR_INFO_uChar;\n-static jfieldID CHAR_INFO_Attributes;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_CURSOR_INFO\n-static jclass CONSOLE_CURSOR_INFO_Class;\n-static jmethodID CONSOLE_CURSOR_INFO_Constructor;\n-static jfieldID CONSOLE_CURSOR_INFO_dwSize;\n-static jfieldID CONSOLE_CURSOR_INFO_bVisible;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO\n-static jclass CONSOLE_SCREEN_BUFFER_INFO_Class;\n-static jmethodID CONSOLE_SCREEN_BUFFER_INFO_Constructor;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwSize;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_wAttributes;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_srWindow;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD\n-static jclass COORD_Class;\n-static jmethodID COORD_Constructor;\n-static jfieldID COORD_X;\n-static jfieldID COORD_Y;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD\n-static jclass INPUT_RECORD_Class;\n-static jmethodID INPUT_RECORD_Constructor;\n-static jfieldID INPUT_RECORD_EventType;\n-static jfieldID INPUT_RECORD_Event;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD.EventUnion\n-static jclass EventUnion_Class;\n-static jmethodID EventUnion_Constructor;\n-static jfieldID EventUnion_KeyEvent;\n-static jfieldID EventUnion_MouseEvent;\n-static jfieldID EventUnion_WindowBufferSizeEvent;\n-static jfieldID EventUnion_MenuEvent;\n-static jfieldID EventUnion_FocusEvent;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.KEY_EVENT_RECORD\n-static jclass KEY_EVENT_RECORD_Class;\n-static jmethodID KEY_EVENT_RECORD_Constructor;\n-static jfieldID KEY_EVENT_RECORD_bKeyDown;\n-static jfieldID KEY_EVENT_RECORD_wRepeatCount;\n-static jfieldID KEY_EVENT_RECORD_wVirtualKeyCode;\n-static jfieldID KEY_EVENT_RECORD_wVirtualScanCode;\n-static jfieldID KEY_EVENT_RECORD_uChar;\n-static jfieldID KEY_EVENT_RECORD_dwControlKeyState;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MOUSE_EVENT_RECORD\n-static jclass MOUSE_EVENT_RECORD_Class;\n-static jmethodID MOUSE_EVENT_RECORD_Constructor;\n-static jfieldID MOUSE_EVENT_RECORD_dwMousePosition;\n-static jfieldID MOUSE_EVENT_RECORD_dwButtonState;\n-static jfieldID MOUSE_EVENT_RECORD_dwControlKeyState;\n-static jfieldID MOUSE_EVENT_RECORD_dwEventFlags;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.WINDOW_BUFFER_SIZE_RECORD\n-static jclass WINDOW_BUFFER_SIZE_RECORD_Class;\n-static jmethodID WINDOW_BUFFER_SIZE_RECORD_Constructor;\n-static jfieldID WINDOW_BUFFER_SIZE_RECORD_dwSize;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MENU_EVENT_RECORD\n-static jclass MENU_EVENT_RECORD_Class;\n-static jmethodID MENU_EVENT_RECORD_Constructor;\n-static jfieldID MENU_EVENT_RECORD_dwCommandId;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOCUS_EVENT_RECORD\n-static jclass FOCUS_EVENT_RECORD_Class;\n-static jmethodID FOCUS_EVENT_RECORD_Constructor;\n-static jfieldID FOCUS_EVENT_RECORD_bSetFocus;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT\n-static jclass SMALL_RECT_Class;\n-static jmethodID SMALL_RECT_Constructor;\n-static jfieldID SMALL_RECT_Left;\n-static jfieldID SMALL_RECT_Top;\n-static jfieldID SMALL_RECT_Right;\n-static jfieldID SMALL_RECT_Bottom;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.UnionChar\n-static jclass UnionChar_Class;\n-static jmethodID UnionChar_Constructor;\n-static jfieldID UnionChar_UnicodeChar;\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_initIDs\n-  (JNIEnv *env, jclass) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer\");\n-    CHECK_NULL(cls);\n-    pointerClass = (jclass) env->NewGlobalRef(cls);\n-    pointerConstructor = env->GetMethodID(cls, \"<init>\", \"(J)V\");\n-    CHECK_NULL(pointerConstructor);\n-    pointerValue  = env->GetFieldID(cls, \"value\", \"J\");\n-    CHECK_NULL(pointerValue);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(cls, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference\");\n-    CHECK_NULL(cls);\n-    intByReferenceClass = (jclass) env->NewGlobalRef(cls);\n-    intByReferenceValue = env->GetFieldID(cls, \"value\", \"I\");\n-    CHECK_NULL(intByReferenceValue);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO\n-    CHAR_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CHAR_INFO\"));\n-    CHECK_NULL(CHAR_INFO_Class);\n-    CHAR_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CHAR_INFO_Constructor);\n-    CHAR_INFO_uChar = env->GetFieldID(CHAR_INFO_Class, \"uChar\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar;\");\n-    CHECK_NULL(CHAR_INFO_uChar);\n-    CHAR_INFO_Attributes = env->GetFieldID(CHAR_INFO_Class, \"Attributes\", \"S\");\n-    CHECK_NULL(CHAR_INFO_Attributes);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_CURSOR_INFO\n-    CONSOLE_CURSOR_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CONSOLE_CURSOR_INFO\"));\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_Class);\n-    CONSOLE_CURSOR_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_Constructor);\n-    CONSOLE_CURSOR_INFO_dwSize = env->GetFieldID(CONSOLE_CURSOR_INFO_Class, \"dwSize\", \"I\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_dwSize);\n-    CONSOLE_CURSOR_INFO_bVisible = env->GetFieldID(CONSOLE_CURSOR_INFO_Class, \"bVisible\", \"Z\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_bVisible);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO\n-    CONSOLE_SCREEN_BUFFER_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CONSOLE_SCREEN_BUFFER_INFO\"));\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_Class);\n-    CONSOLE_SCREEN_BUFFER_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_Constructor);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwSize = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwSize);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwCursorPosition\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition);\n-    CONSOLE_SCREEN_BUFFER_INFO_wAttributes = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"wAttributes\", \"S\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_wAttributes);\n-    CONSOLE_SCREEN_BUFFER_INFO_srWindow = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"srWindow\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$SMALL_RECT;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_srWindow);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwMaximumWindowSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD\n-    COORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD\"));\n-    CHECK_NULL(COORD_Class);\n-    COORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(COORD_Constructor);\n-    COORD_X = env->GetFieldID(COORD_Class, \"X\", \"S\");\n-    CHECK_NULL(COORD_X);\n-    COORD_Y = env->GetFieldID(COORD_Class, \"Y\", \"S\");\n-    CHECK_NULL(COORD_Y);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD\n-    INPUT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD\"));\n-    CHECK_NULL(INPUT_RECORD_Class);\n-    INPUT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(INPUT_RECORD_Constructor);\n-    INPUT_RECORD_EventType = env->GetFieldID(INPUT_RECORD_Class, \"EventType\", \"S\");\n-    CHECK_NULL(INPUT_RECORD_EventType);\n-    INPUT_RECORD_Event = env->GetFieldID(INPUT_RECORD_Class, \"Event\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD$EventUnion;\");\n-    CHECK_NULL(INPUT_RECORD_Event);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD.EventUnion\n-    EventUnion_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD$EventUnion\"));\n-    CHECK_NULL(EventUnion_Class);\n-    EventUnion_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(EventUnion_Constructor);\n-    EventUnion_KeyEvent = env->GetFieldID(EventUnion_Class, \"KeyEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$KEY_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_KeyEvent);\n-    EventUnion_MouseEvent = env->GetFieldID(EventUnion_Class, \"MouseEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MOUSE_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_MouseEvent);\n-    EventUnion_WindowBufferSizeEvent = env->GetFieldID(EventUnion_Class, \"WindowBufferSizeEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$WINDOW_BUFFER_SIZE_RECORD;\");\n-    CHECK_NULL(EventUnion_WindowBufferSizeEvent);\n-    EventUnion_MenuEvent = env->GetFieldID(EventUnion_Class, \"MenuEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MENU_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_MenuEvent);\n-    EventUnion_FocusEvent = env->GetFieldID(EventUnion_Class, \"FocusEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$FOCUS_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_FocusEvent);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.KEY_EVENT_RECORD\n-    KEY_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$KEY_EVENT_RECORD\"));\n-    CHECK_NULL(KEY_EVENT_RECORD_Class);\n-    KEY_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(KEY_EVENT_RECORD_Constructor);\n-    KEY_EVENT_RECORD_bKeyDown = env->GetFieldID(KEY_EVENT_RECORD_Class, \"bKeyDown\", \"Z\");\n-    CHECK_NULL(KEY_EVENT_RECORD_bKeyDown);\n-    KEY_EVENT_RECORD_wRepeatCount = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wRepeatCount\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wRepeatCount);\n-    KEY_EVENT_RECORD_wVirtualKeyCode = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wVirtualKeyCode\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wVirtualKeyCode);\n-    KEY_EVENT_RECORD_wVirtualScanCode = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wVirtualScanCode\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wVirtualScanCode);\n-    KEY_EVENT_RECORD_uChar = env->GetFieldID(KEY_EVENT_RECORD_Class, \"uChar\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar;\");\n-    CHECK_NULL(KEY_EVENT_RECORD_uChar);\n-    KEY_EVENT_RECORD_dwControlKeyState = env->GetFieldID(KEY_EVENT_RECORD_Class, \"dwControlKeyState\", \"I\");\n-    CHECK_NULL(KEY_EVENT_RECORD_dwControlKeyState);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MOUSE_EVENT_RECORD\n-    MOUSE_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MOUSE_EVENT_RECORD\"));\n-    CHECK_NULL(MOUSE_EVENT_RECORD_Class);\n-    MOUSE_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_Constructor);\n-    MOUSE_EVENT_RECORD_dwMousePosition = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwMousePosition\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwMousePosition);\n-    MOUSE_EVENT_RECORD_dwButtonState = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwButtonState\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwButtonState);\n-    MOUSE_EVENT_RECORD_dwControlKeyState = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwControlKeyState\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwControlKeyState);\n-    MOUSE_EVENT_RECORD_dwEventFlags = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwEventFlags\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwEventFlags);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.WINDOW_BUFFER_SIZE_RECORD\n-    WINDOW_BUFFER_SIZE_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$WINDOW_BUFFER_SIZE_RECORD\"));\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_Class);\n-    WINDOW_BUFFER_SIZE_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_Constructor);\n-    WINDOW_BUFFER_SIZE_RECORD_dwSize = env->GetFieldID(WINDOW_BUFFER_SIZE_RECORD_Class, \"dwSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_dwSize);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MENU_EVENT_RECORD\n-    MENU_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MENU_EVENT_RECORD\"));\n-    CHECK_NULL(MENU_EVENT_RECORD_Class);\n-    MENU_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(MENU_EVENT_RECORD_Constructor);\n-    MENU_EVENT_RECORD_dwCommandId = env->GetFieldID(MENU_EVENT_RECORD_Class, \"dwCommandId\", \"I\");\n-    CHECK_NULL(MENU_EVENT_RECORD_dwCommandId);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOCUS_EVENT_RECORD\n-    FOCUS_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$FOCUS_EVENT_RECORD\"));\n-    CHECK_NULL(FOCUS_EVENT_RECORD_Class);\n-    FOCUS_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(FOCUS_EVENT_RECORD_Constructor);\n-    FOCUS_EVENT_RECORD_bSetFocus = env->GetFieldID(FOCUS_EVENT_RECORD_Class, \"bSetFocus\", \"Z\");\n-    CHECK_NULL(FOCUS_EVENT_RECORD_bSetFocus);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT\n-    SMALL_RECT_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$SMALL_RECT\"));\n-    CHECK_NULL(SMALL_RECT_Class);\n-    SMALL_RECT_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(SMALL_RECT_Constructor);\n-    SMALL_RECT_Left = env->GetFieldID(SMALL_RECT_Class, \"Left\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Left);\n-    SMALL_RECT_Top = env->GetFieldID(SMALL_RECT_Class, \"Top\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Top);\n-    SMALL_RECT_Right = env->GetFieldID(SMALL_RECT_Class, \"Right\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Right);\n-    SMALL_RECT_Bottom = env->GetFieldID(SMALL_RECT_Class, \"Bottom\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Bottom);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.UnionChar\n-    UnionChar_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar\"));\n-    CHECK_NULL(UnionChar_Class);\n-    UnionChar_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(UnionChar_Constructor);\n-    UnionChar_UnicodeChar = env->GetFieldID(UnionChar_Class, \"UnicodeChar\", \"C\");\n-    CHECK_NULL(UnionChar_UnicodeChar);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    WaitForSingleObject\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_WaitForSingleObject\n-  (JNIEnv *env, jobject kernel, jobject in_hHandle, jint in_dwMilliseconds) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hHandle, pointerValue));\n-    return WaitForSingleObject(h, in_dwMilliseconds);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetStdHandle\n- * Signature: (I)Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;\n- *\/\n-JNIEXPORT jobject JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetStdHandle\n-  (JNIEnv *env, jobject, jint nStdHandle) {\n-    return env->NewObject(pointerClass,\n-                          pointerConstructor,\n-                          nStdHandle);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleOutputCP\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleOutputCP\n-  (JNIEnv *, jobject) {\n-    return GetConsoleOutputCP();\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    FillConsoleOutputCharacter\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;CILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_FillConsoleOutputCharacter\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jchar in_cCharacter, jint in_nLength, jobject in_dwWriteCoord, jobject out_lpNumberOfCharsWritten) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD written;\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_Y);\n-    if (!FillConsoleOutputCharacter(h, (CHAR) in_cCharacter, in_nLength, coord, &written)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpNumberOfCharsWritten, intByReferenceValue, written);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    FillConsoleOutputAttribute\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;SILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_FillConsoleOutputAttribute\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jshort in_wAttribute, jint in_nLength, jobject in_dwWriteCoord, jobject out_lpNumberOfAttrsWritten) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD written;\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_Y);\n-    if (!FillConsoleOutputAttribute(h, in_wAttribute, in_nLength, coord, &written)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpNumberOfAttrsWritten, intByReferenceValue, written);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleMode\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleMode\n-  (JNIEnv *env, jobject, jobject in_hConsoleOutput, jobject out_lpMode) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD mode;\n-    if (!GetConsoleMode(h, &mode)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpMode, intByReferenceValue, mode);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleScreenBufferInfo\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/CONSOLE_SCREEN_BUFFER_INFO;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleScreenBufferInfo\n-  (JNIEnv *env, jobject, jobject in_hConsoleOutput, jobject\/*CONSOLE_SCREEN_BUFFER_INFO*\/ out_lpConsoleScreenBufferInfo) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    CONSOLE_SCREEN_BUFFER_INFO buffer;\n-    if (!GetConsoleScreenBufferInfo(h, &buffer)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-\n-    jobject dwSize = env->NewObject(COORD_Class,\n-                                    COORD_Constructor);\n-    env->SetIntField(dwSize, COORD_X, buffer.dwSize.X);\n-    env->SetIntField(dwSize, COORD_Y, buffer.dwSize.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwSize, dwSize);\n-\n-    jobject dwCursorPosition = env->NewObject(COORD_Class,\n-                                              COORD_Constructor);\n-    env->SetIntField(dwCursorPosition, COORD_X, buffer.dwCursorPosition.X);\n-    env->SetIntField(dwCursorPosition, COORD_Y, buffer.dwCursorPosition.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition, dwCursorPosition);\n-\n-    env->SetIntField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_wAttributes, buffer.wAttributes);\n-\n-    jobject srWindow = env->NewObject(SMALL_RECT_Class,\n-                                      SMALL_RECT_Constructor);\n-    env->SetIntField(srWindow, SMALL_RECT_Left, buffer.srWindow.Left);\n-    env->SetIntField(srWindow, SMALL_RECT_Top, buffer.srWindow.Top);\n-    env->SetIntField(srWindow, SMALL_RECT_Right, buffer.srWindow.Right);\n-    env->SetIntField(srWindow, SMALL_RECT_Bottom, buffer.srWindow.Bottom);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_srWindow, srWindow);\n-\n-    jobject dwMaximumWindowSize = env->NewObject(COORD_Class,\n-                                                 COORD_Constructor);\n-    env->SetIntField(dwMaximumWindowSize, COORD_X, buffer.dwMaximumWindowSize.X);\n-    env->SetIntField(dwMaximumWindowSize, COORD_Y, buffer.dwMaximumWindowSize.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize, dwMaximumWindowSize);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    ReadConsoleInput\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;[Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/INPUT_RECORD;ILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_ReadConsoleInput\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobjectArray\/*INPUT_RECORD[]*\/ out_lpBuffer, jint in_nLength, jobject out_lpNumberOfEventsRead) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    INPUT_RECORD *buffer = new INPUT_RECORD[in_nLength];\n-    DWORD numberOfEventsRead;\n-    if (!ReadConsoleInputW(h, buffer, in_nLength, &numberOfEventsRead)) {\n-        delete[] buffer;\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    for (unsigned int i = 0; i < numberOfEventsRead; i++) {\n-        jobject record = env->NewObject(INPUT_RECORD_Class,\n-                                        INPUT_RECORD_Constructor);\n-        env->SetShortField(record, INPUT_RECORD_EventType, buffer[i].EventType);\n-        switch (buffer[i].EventType) {\n-            case KEY_EVENT: {\n-                jobject keyEvent = env->NewObject(KEY_EVENT_RECORD_Class,\n-                                                  KEY_EVENT_RECORD_Constructor);\n-                env->SetBooleanField(keyEvent, KEY_EVENT_RECORD_bKeyDown, buffer[i].Event.KeyEvent.bKeyDown);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wRepeatCount, buffer[i].Event.KeyEvent.wRepeatCount);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wVirtualKeyCode, buffer[i].Event.KeyEvent.wVirtualKeyCode);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wVirtualScanCode, buffer[i].Event.KeyEvent.wVirtualScanCode);\n-\n-                jobject unionChar = env->NewObject(UnionChar_Class,\n-                                                   UnionChar_Constructor);\n-\n-                env->SetIntField(unionChar, UnionChar_UnicodeChar, buffer[i].Event.KeyEvent.uChar.UnicodeChar);\n-\n-                env->SetObjectField(keyEvent, KEY_EVENT_RECORD_uChar, unionChar);\n-\n-                env->SetIntField(keyEvent, KEY_EVENT_RECORD_dwControlKeyState, buffer[i].Event.KeyEvent.dwControlKeyState);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_KeyEvent, keyEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case MOUSE_EVENT: {\n-                jobject mouseEvent = env->NewObject(MOUSE_EVENT_RECORD_Class,\n-                                                    MOUSE_EVENT_RECORD_Constructor);\n-\n-                jobject dwMousePosition = env->NewObject(COORD_Class,\n-                                                         COORD_Constructor);\n-                env->SetIntField(dwMousePosition, COORD_X, buffer[i].Event.MouseEvent.dwMousePosition.X);\n-                env->SetIntField(dwMousePosition, COORD_Y, buffer[i].Event.MouseEvent.dwMousePosition.Y);\n-                env->SetObjectField(mouseEvent, MOUSE_EVENT_RECORD_dwMousePosition, dwMousePosition);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwButtonState, buffer[i].Event.MouseEvent.dwButtonState);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwControlKeyState, buffer[i].Event.MouseEvent.dwControlKeyState);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwEventFlags, buffer[i].Event.MouseEvent.dwEventFlags);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_MouseEvent, mouseEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case WINDOW_BUFFER_SIZE_EVENT: {\n-                jobject windowBufferSize = env->NewObject(WINDOW_BUFFER_SIZE_RECORD_Class,\n-                                                          WINDOW_BUFFER_SIZE_RECORD_Constructor);\n-\n-                jobject dwSize = env->NewObject(COORD_Class,\n-                                                COORD_Constructor);\n-                env->SetIntField(dwSize, COORD_X, buffer[i].Event.WindowBufferSizeEvent.dwSize.X);\n-                env->SetIntField(dwSize, COORD_Y, buffer[i].Event.WindowBufferSizeEvent.dwSize.Y);\n-                env->SetObjectField(windowBufferSize, WINDOW_BUFFER_SIZE_RECORD_dwSize, dwSize);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_WindowBufferSizeEvent, windowBufferSize);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case MENU_EVENT: {\n-                jobject menuEvent = env->NewObject(MENU_EVENT_RECORD_Class,\n-                                                          MENU_EVENT_RECORD_Constructor);\n-\n-                env->SetBooleanField(menuEvent, MENU_EVENT_RECORD_dwCommandId, buffer[i].Event.MenuEvent.dwCommandId);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_MenuEvent, menuEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case FOCUS_EVENT: {\n-                jobject focusEvent = env->NewObject(FOCUS_EVENT_RECORD_Class,\n-                                                    FOCUS_EVENT_RECORD_Constructor);\n-\n-                env->SetIntField(focusEvent, FOCUS_EVENT_RECORD_bSetFocus, buffer[i].Event.FocusEvent.bSetFocus);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_FocusEvent, focusEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-        }\n-        env->SetObjectArrayElement(out_lpBuffer, i, record);\n-    }\n-    env->SetIntField(out_lpNumberOfEventsRead, intByReferenceValue, numberOfEventsRead);\n-    delete[] buffer;\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleCursorPosition\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleCursorPosition\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobject in_dwCursorPosition) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwCursorPosition, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwCursorPosition, COORD_Y);\n-    if (!SetConsoleCursorPosition(h, coord)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleMode\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleMode\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jint in_dwMode) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    if (!SetConsoleMode(h, in_dwMode)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleTextAttribute\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;S)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleTextAttribute\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jshort in_wAttributes) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    if (!SetConsoleTextAttribute(h, in_wAttributes)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleTitle\n- * Signature: (Ljava\/lang\/String;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleTitle\n-  (JNIEnv *env, jobject, jstring in_lpConsoleTitle) {\n-    const char *chars = env->GetStringUTFChars(in_lpConsoleTitle, NULL);\n-    if (!SetConsoleTitle(chars)) {\n-        env->ReleaseStringUTFChars(in_lpConsoleTitle, chars);\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->ReleaseStringUTFChars(in_lpConsoleTitle, chars);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    WriteConsoleW\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;[CILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_WriteConsoleW\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jcharArray in_lpBuffer, jint in_nNumberOfCharsToWrite, jobject out_lpNumberOfCharsWritten, jobject) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    jchar *chars = new jchar[in_nNumberOfCharsToWrite];\n-    env->GetCharArrayRegion(in_lpBuffer, 0, in_nNumberOfCharsToWrite, chars);\n-    DWORD written;\n-    if (!WriteConsoleW(h, chars, in_nNumberOfCharsToWrite, &written, NULL)) {\n-        delete[] chars;\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-\n-    env->SetIntField(out_lpNumberOfCharsWritten, intByReferenceValue, written);\n-    delete[] chars;\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    ScrollConsoleScreenBuffer\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/SMALL_RECT;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/SMALL_RECT;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/CHAR_INFO;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_ScrollConsoleScreenBuffer\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobject in_lpScrollRectangle, jobject in_lpClipRectangle, jobject in_dwDestinationOrigin, jobject in_lpFill) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-\n-    SMALL_RECT scrollRectangle;\n-    scrollRectangle.Left = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Left);\n-    scrollRectangle.Top = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Top);\n-    scrollRectangle.Right = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Right);\n-    scrollRectangle.Bottom = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Bottom);\n-\n-    SMALL_RECT clipRectangle;\n-    clipRectangle.Left = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Left);\n-    clipRectangle.Top = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Top);\n-    clipRectangle.Right = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Right);\n-    clipRectangle.Bottom = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Bottom);\n-\n-    COORD destinationOrigin;\n-    destinationOrigin.X = (SHORT) env->GetLongField(in_dwDestinationOrigin, COORD_X);\n-    destinationOrigin.Y = (SHORT) env->GetLongField(in_dwDestinationOrigin, COORD_Y);\n-\n-    CHAR_INFO charInfo;\n-    charInfo.Char.UnicodeChar = env->GetCharField(env->GetObjectField(in_lpFill, CHAR_INFO_uChar), UnionChar_UnicodeChar);\n-    charInfo.Attributes = env->GetShortField(in_lpFill, CHAR_INFO_Attributes);\n-\n-    if (!ScrollConsoleScreenBuffer(h, &scrollRectangle, &clipRectangle, destinationOrigin, &charInfo)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/native\/lible\/Kernel32.cpp","additions":0,"deletions":710,"binary":false,"changes":710,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @since 9\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/package-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-Within a source file, you may use suppress any warnings generated by\n-these options by using\n+Within a source file, you may suppress any warnings generated by these\n+options by using\n@@ -923,0 +923,5 @@\n+\\f[V]--no-fonts\\f[R]\n+Prevents inclusion of font files in the generated documentation.\n+This can be useful if the documentation uses a custom stylesheet which\n+does not use the default fonts.\n+.TP\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,1 +290,1 @@\n-        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath(), \"*.jfc\"))) {\n+        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath()))) {\n@@ -293,1 +293,2 @@\n-                if (!SecuritySupport.isDirectory(s)) {\n+                String text = s.toString();\n+                if (text.endsWith(\".jfc\") && !SecuritySupport.isDirectory(s)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-            return in.readLine(prompt, mask);\n+            return in.readLine(prompt.replace(\"%\", \"%%\"), mask);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,4 +44,1 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n+import java.nio.file.*;\n@@ -51,0 +48,3 @@\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipInputStream;\n@@ -54,0 +54,1 @@\n+import javax.swing.filechooser.FileNameExtensionFilter;\n@@ -69,0 +70,3 @@\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+\n@@ -79,11 +83,1 @@\n-    private static final FileFilter xmlFileFilter = new FileFilter() {\n-        @Override\n-        public boolean accept(File f) {\n-            return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n-        }\n-\n-        @Override\n-        public String getDescription() {\n-            return \"Graph files (*.xml)\";\n-        }\n-    };\n+    private static final FileFilter graphFileFilter = new FileNameExtensionFilter(\"Graph files (*.xml, *.igv)\", \"xml\", \"igv\");\n@@ -164,2 +158,20 @@\n-        try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n-            Printer.exportGraphDocument(writer, doc, saveContexts);\n+        if (path.endsWith(\".igv\")) {\n+            File zipFile = new File(path);\n+            String fileName = zipFile.getName();\n+            try (FileOutputStream fos = new FileOutputStream(zipFile);\n+                 ZipOutputStream zos = new ZipOutputStream(fos);\n+                 Writer writer = new OutputStreamWriter(zos)) {\n+\n+                \/\/ Replace the '.igv' extension with '.xml's\n+                String zipEntryName = fileName.substring(0, fileName.length() - 4) + \".xml\";\n+                ZipEntry zipEntry = new ZipEntry(zipEntryName);\n+                zos.putNextEntry(zipEntry);\n+\n+                Printer.exportGraphDocument(writer, doc, saveContexts);\n+\n+                zos.closeEntry();\n+            }\n+        } else {\n+            try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n+                Printer.exportGraphDocument(writer, doc, saveContexts);\n+            }\n@@ -361,1 +373,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -406,1 +418,14 @@\n-        JFileChooser fc = new JFileChooser();\n+        JFileChooser fc = new JFileChooser() {\n+            @Override\n+            public void approveSelection() {\n+                File selectedFile = getSelectedFile();\n+                if (selectedFile != null) {\n+                    String fileName = selectedFile.getName().toLowerCase();\n+                    if (!fileName.endsWith(\".xml\") && !fileName.endsWith(\".igv\")) {\n+                        JOptionPane.showMessageDialog(this, \"Please select a graph file with .xml or .igv extension.\", \"Invalid File\", JOptionPane.ERROR_MESSAGE);\n+                        return;\n+                    }\n+                }\n+                super.approveSelection();\n+            }\n+        };\n@@ -408,1 +433,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -435,1 +460,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -485,2 +510,2 @@\n-     * Loads a graph document from the given file path, updating progress via a ProgressHandle.\n-     * Parse the XML file, add the parsed document to the workspace, and load associated contexts if specified.\n+     * Loads a graph document from the specified path, either as an XML file or from a ZIP archive.\n+     * If loading the context is requested, it loads the context along with the document.\n@@ -493,8 +518,11 @@\n-        final FileChannel channel;\n-        final long start;\n-        try {\n-            channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n-            start = channel.size();\n-        } catch (Exception ex) {\n-            Exceptions.printStackTrace(ex);\n-            return;\n+        if (file.getName().endsWith(\".xml\")) {\n+            try (FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ)) {\n+                loadFile(channel, file, loadContext);\n+            }\n+        } else if (file.getName().endsWith(\".igv\")) {\n+            try (ZipInputStream zis = new ZipInputStream(new FileInputStream(file))) {\n+                ZipEntry entry = zis.getNextEntry();\n+                if (entry != null && entry.getName().endsWith(\".xml\")) {\n+                    loadFile(Channels.newChannel(zis), file, loadContext);\n+                }\n+            }\n@@ -502,0 +530,1 @@\n+    }\n@@ -503,0 +532,4 @@\n+    \/**\n+     * Loads an XML or ZIP document from the provided channel, while monitoring the progress of the operation.\n+     *\/\n+    private void loadFile(ReadableByteChannel channel,  File file, boolean loadContext) throws IOException {\n@@ -506,7 +539,10 @@\n-        ParseMonitor monitor = new ParseMonitor() {\n-            @Override\n-            public void updateProgress() {\n-                try {\n-                    int prog = (int) (WORK_UNITS * (double) channel.position() \/ (double) start);\n-                    handle.progress(prog);\n-                } catch (IOException ignored) {\n+        ParseMonitor monitor;\n+        if (channel instanceof FileChannel fileChannel) {\n+            final long start = fileChannel.size();\n+            monitor = new ParseMonitor() {\n+                @Override\n+                public void updateProgress() {\n+                    try {\n+                        int prog = (int) (WORK_UNITS * (double) fileChannel.position() \/ (double) start);\n+                        handle.progress(prog);\n+                    } catch (IOException ignored) {}\n@@ -514,1 +550,0 @@\n-            }\n@@ -516,6 +551,21 @@\n-            @Override\n-            public void setState(String state) {\n-                updateProgress();\n-                handle.progress(state);\n-            }\n-        };\n+                @Override\n+                public void setState(String state) {\n+                    updateProgress();\n+                    handle.progress(state);\n+                }\n+            };\n+        } else {\n+            monitor = new ParseMonitor() {\n+                @Override\n+                public void updateProgress() {\n+                    handle.progress(\"Processing...\");\n+                }\n+\n+                @Override\n+                public void setState(String state) {\n+                    updateProgress();\n+                    handle.progress(state);\n+                }\n+            };\n+        }\n+\n@@ -523,12 +573,10 @@\n-            if (file.getName().endsWith(\".xml\")) {\n-                ArrayList<GraphContext> contexts = new ArrayList<>();\n-                final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n-                parser.parse();\n-                SwingUtilities.invokeLater(() -> {\n-                    for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n-                        \/\/ Nodes are lazily created. By expanding and collapsing they are all initialized\n-                        ((BeanTreeView) this.treeView).expandNode(child);\n-                        ((BeanTreeView) this.treeView).collapseNode(child);\n-                    }\n-                    requestActive();\n-                });\n+            ArrayList<GraphContext> contexts = new ArrayList<>();\n+            final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n+            parser.parse();\n+            SwingUtilities.invokeLater(() -> {\n+                for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n+                    \/\/ Nodes are lazily created. By expanding and collapsing they are all initialized\n+                    ((BeanTreeView) this.treeView).expandNode(child);\n+                    ((BeanTreeView) this.treeView).collapseNode(child);\n+                }\n+                requestActive();\n@@ -538,1 +586,1 @@\n-            }\n+            });\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":106,"deletions":58,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Objects;\n+\n@@ -52,2 +54,5 @@\n-    public boolean equals(Object o) {\n-        if (!(o instanceof InputNode)) {\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n@@ -56,2 +61,3 @@\n-        InputNode n = (InputNode) o;\n-        return n.id == id;\n+        InputNode other = (InputNode) obj;\n+        return id == other.id &&\n+                Objects.equals(getProperties(), other.getProperties());\n@@ -62,1 +68,1 @@\n-        return id * 13;\n+        return Objects.hash(id, getProperties());\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,4 +106,9 @@\n-        }\n-\n-        for (InputNode n : graph.getNodes()) {\n-            if (!difference || !equal.contains(n)) {\n+            for (InputNode n : graph.getNodes()) {\n+                if (!equal.contains(n)) {\n+                    writer.startTag(Parser.NODE_ELEMENT, new Properties(Parser.NODE_ID_PROPERTY, Integer.toString(n.getId())));\n+                    writer.writeProperties(n.getProperties());\n+                    writer.endTag(); \/\/ Parser.NODE_ELEMENT\n+                }\n+            }\n+        } else {\n+            for (InputNode n : graph.getNodes()) {\n@@ -230,0 +235,4 @@\n+            b.append(\" \");\n+            b.append(code.getOperands());\n+            b.append(\" \");\n+            b.append(code.getComment());\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename BlockClass>\n+class BlockInputStream : public inputStream {\n+  BlockClass _input;\n+ public:\n+  template<typename... Arg>\n+  BlockInputStream(Arg... arg)\n+    : _input(arg...) {\n+    set_input(&_input);\n+  }\n+};\n+\n+#define EXPECT_MEMEQ(s1, s2, len) \\\n+  EXPECT_PRED_FORMAT3(CmpHelperMEMEQ, s1, s2, len)\n+\/\/ cf. ::testing::internal::CmpHelperSTREQ\n+\n+testing::AssertionResult CmpHelperMEMEQ(const char* s1_expression,\n+                                        const char* s2_expression,\n+                                        const char* len_expression,\n+                                        const char* s1, const char* s2,\n+                                        size_t len) {\n+  if (s1 == nullptr || s2 == nullptr) {\n+    return testing::internal::CmpHelperEQ(s1_expression, s2_expression,\n+                                          s1, s2);\n+  }\n+  int c = ::memcmp(s1, s2, len);\n+  if (c == 0) {\n+    return testing::AssertionSuccess();\n+  }\n+  ::std::string str1, str2;\n+  for (auto which = 0; which <= 1; which++) {\n+    auto  s   = which ? s1   : s2;\n+    auto &str = which ? str1 : str2;\n+    std::stringstream buf;\n+    buf << \"{\";\n+    for (size_t i = 0; i < len; i++) {\n+      char c = s[i];\n+      switch (c) {\n+      case '\\0':  buf << \"\\\\0\"; break;\n+      case '\\n':  buf << \"\\\\n\"; break;\n+      case '\\\\':  buf << \"\\\\\\\\\"; break;\n+      default:    buf << c; break;\n+      }\n+    }\n+    buf << \"}[\" << len_expression << \"=\" << len << \"]\";\n+    str = buf.str();\n+  }\n+  return testing::internal::CmpHelperSTREQ(s1_expression, s2_expression,\n+                                           str1.c_str(), str2.c_str());\n+}\n+\n+static int firstdiff(char* b1, char* b2, int blen) {\n+  for (int i = 0; i < blen; i++) {\n+    if (b1[i] != b2[i])  return i;\n+  }\n+  return -1;\n+}\n+\n+static char* get_temp_file(bool VERBOSE, const char* filename) {\n+  const char* tmp_dir = os::get_temp_directory();\n+  const char* file_sep = os::file_separator();\n+  size_t temp_file_len = strlen(tmp_dir) + strlen(file_sep) + strlen(filename) + 28;\n+  char* temp_file = NEW_C_HEAP_ARRAY(char, temp_file_len, mtInternal);\n+  int ret = jio_snprintf(temp_file, temp_file_len, \"%s%spid%d.%s\",\n+                         tmp_dir, file_sep,\n+                         os::current_process_id(), filename);\n+  if (VERBOSE)  tty->print_cr(\"temp_file = %s\", temp_file);\n+  return temp_file;\n+}\n+\n+static const char* get_temp_file(bool VERBOSE) {\n+  static const char* temp_file = get_temp_file(VERBOSE, \"test_istream\");\n+  return temp_file;\n+}\n+\n+#define EIGHTY 80\n+#define LC0(x)     ('\/' + (((unsigned)(x)+1) % EIGHTY))\n+#define LC(line,col)  LC0((col) * (line))\n+\n+#define COLS 30\n+\n+static int cases, total, zeroes;\n+#ifdef ASSERT\n+#define istream_coverage_mode(mode, a,b,c) \\\n+  inputStream::coverage_mode(mode, a,b,c)\n+#else\n+#define istream_coverage_mode(mode, a,b,c)\n+#endif\n+\n+\/\/ Fill in a test pattern of ascii characters.\n+\/\/ Each line is ncols long, plus a line termination of lelen (1 or 2).\n+\/\/ Each character is a fixed, static function of the line and column.\n+\/\/ This enables test logic to predict exactly what will be read in each line.\n+static void fill_pattern(bool VERBOSE,\n+                         char* pat, int patlen, int ncols, int lelen,\n+                         int& full_lines, int& partial_line,\n+                         const char* &line_end,\n+                         const char* &partial_line_end) {\n+  full_lines = partial_line = 0;\n+  for (int i = 0; i < patlen; i++) {\n+    int line = (i \/ (ncols+lelen)) + 1;  \/\/ 1-based line number\n+    int col  = (i % (ncols+lelen)) + 1;  \/\/ 1-based column number\n+    if (col <= ncols) {\n+      pat[i] = LC(line, col);\n+      partial_line = 1;\n+    } else if (col < ncols+lelen) {\n+      pat[i] = i == patlen - 1 ? '!' : '%';\n+      partial_line = 1;\n+    } else {\n+      assert(col == ncols+lelen, \"\");\n+      pat[i] = '!';\n+      full_lines++;\n+      partial_line = 0;\n+    }\n+  }\n+  pat[patlen] = '\\0';\n+  if (VERBOSE)  tty->print_cr(\"PATTERN=%d+%d[%s]\",\n+                              full_lines, partial_line, pat);\n+  for (int i = 0; i < patlen; i++) {\n+    assert(pat[i] != '%' || (i+1 < patlen && pat[i+1] == '!'), \"\");\n+    if (pat[i] == '!')  pat[i] = '\\n';\n+    if (pat[i] == '%')  pat[i] = '\\r';\n+  }\n+  assert(pat[patlen-1] != '\\r', \"\");\n+\n+  line_end = (lelen == 2 ? \"\\r\\n\" : \"\\n\");\n+  int partial_line_bytes = patlen - (full_lines * (ncols + lelen));\n+  assert(partial_line_bytes < ncols + lelen, \"\");\n+  partial_line_end = (partial_line_bytes == ncols + 1) ? \"\\n\" : \"\";\n+}\n+\n+static const int MAX_PATLEN = COLS * (COLS-1);\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const int patlen,\n+                                const int ncols,\n+                                const int lelen,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  DEBUG_ONLY( istream_coverage_mode(VERBOSE ? 2 : 1, cases, total, zeroes) );\n+  const char* temp_file = get_temp_file(VERBOSE);\n+  unlink(temp_file);\n+  char pat[MAX_PATLEN+1];\n+  int full_lines = 0, partial_line = 0;\n+  const char* line_end = \"\\n\";\n+  const char* partial_line_end = \"\";\n+  fill_pattern(VERBOSE, pat, patlen, ncols, lelen,\n+               full_lines, partial_line,\n+               line_end, partial_line_end);\n+\n+  char pat2[sizeof(pat)];  \/\/ copy of pat to help detect scribbling\n+  memcpy(pat2, pat, sizeof(pat));\n+  \/\/ Make three kinds of stream and test them all.\n+  MemoryInput _min(pat2, patlen);\n+  inputStream sin(&_min);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&sin);\n+    sin.dump(\"sin\");\n+  }\n+  {\n+    fileStream tfs(temp_file);\n+    guarantee(tfs.is_open(), \"cannot open temp file\");\n+    tfs.write(pat, patlen);\n+  }\n+  BlockInputStream<FileInput> fin(temp_file);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&fin);\n+    fin.dump(\"fin\");\n+  }\n+  BlockInputStream<MemoryInput> min(&pat2[0], patlen);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&min);\n+    sin.dump(\"min\");\n+  }\n+  inputStream* ins[] = { &sin, &fin, &min };\n+  const char* in_names[] = { \"sin\", \"fin\", \"min\" };\n+  const char* test_mode = (TEST_SET_POSITION\n+                           ? (!TEST_PUSH_BACK ? \"(seek)\" : \"(seek\/push)\")\n+                           : TEST_EXPAND_REDUCE\n+                           ? (!TEST_PUSH_BACK ? \"(exp\/red)\" : \"(exp\/red\/push)\")\n+                           : (!TEST_PUSH_BACK ? \"(plain)\" : \"(push)\"));\n+  for (int which = 0; which < 3; which++) {\n+    inputStream& in = *ins[which];\n+    const char* in_name = in_names[which];\n+    int lineno;\n+    char* lp = (char*)\"--\";\n+#define LPEQ                                                    \\\n+    in_name << test_mode                                        \\\n+            << \" ncols=\" << ncols << \" lelen=\" << lelen         \\\n+            << \" full=\" << full_lines << \" lineno=\" << lineno   \\\n+            << \" [\" << lp << \"]\" << (in.dump(\"expect\"), \"\")\n+    if (VERBOSE)\n+      tty->print_cr(\"testing %s%s patlen=%d ncols=%d full_lines=%d partial_line=%d\",\n+                    in_name, test_mode,\n+                    patlen, ncols, full_lines, partial_line);\n+    int pos_to_set = 0, line_to_set = 1;  \/\/ for TEST_SET_POSITION only\n+    for (int phase = 0; phase <= (TEST_SET_POSITION ? 1 : 0); phase++) {\n+      lineno = 1;\n+      for (; lineno <= full_lines + partial_line; lineno++) {\n+        EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+        if (VERBOSE)  in.dump(\"!done?\");\n+        bool done = in.done();\n+        EXPECT_TRUE(!done)  <<LPEQ;\n+        if (done)  break;\n+        lp = in.current_line();\n+        const char* expect_endl =\n+          (lineno <= full_lines) ? line_end : partial_line_end;\n+\n+        bool verify_lp = true;\n+        if (verify_lp) {\n+          int actual_lineno = (int) in.lineno();\n+          if (VERBOSE)  in.dump(\"CL    \");\n+          EXPECT_EQ(actual_lineno, lineno)  <<LPEQ;\n+          int len = (int) in.current_line_length();\n+          EXPECT_EQ(len, (int) strlen(lp))  <<LPEQ;\n+          int expect_len = ncols;\n+          if (lineno > full_lines)\n+            expect_len = MIN2(ncols, patlen % (ncols+lelen));\n+          EXPECT_EQ(len, expect_len)  <<LPEQ;\n+          for (int j = 0; j < len; j++) {\n+            int lc = LC(lineno, j+1);   \/\/ 1-based column\n+            EXPECT_EQ(lc, lp[j])  <<LPEQ;\n+          }\n+          if (len != expect_len || len != (int)strlen(lp)) {\n+            return;  \/\/ no error cascades please\n+          }\n+        }\n+        if (VERBOSE)  in.dump(\"next  \");\n+        in.next();\n+      }\n+\n+      for (int done_test = 0; done_test <= 3; done_test++) {\n+        if (done_test == 2)  in.set_done();\n+        lp = in.current_line();  \/\/ should be empty line\n+        if (VERBOSE)  in.dump(\"done!!\");\n+        EXPECT_TRUE(lp != nullptr);\n+        EXPECT_TRUE(in.done())  <<LPEQ;\n+        if (!in.done())  break;\n+        EXPECT_EQ((int)in.current_line_length(), 0)   <<LPEQ;\n+        EXPECT_EQ(strlen(lp), in.current_line_length())  <<LPEQ;\n+        bool extra_next = in.next();\n+        EXPECT_TRUE(!extra_next)  <<LPEQ;\n+      }\n+\n+      \/\/ no memory side effects\n+      EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+    }\n+  }\n+  unlink(temp_file);\n+}\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  ResourceMark rm;\n+  int patlen = MAX_PATLEN;\n+  const bool SHORT_TEST = false;\n+  const int SHORT_NCOLS = 1, SHORT_PATLEN = 37;\n+  if (SHORT_TEST)  patlen = SHORT_PATLEN;\n+  for (int ncols = 0; ncols <= patlen; ncols++) {\n+    if (SHORT_TEST) {\n+      if (ncols < SHORT_NCOLS)  ncols = SHORT_NCOLS;\n+      if (ncols > SHORT_NCOLS)  break;\n+    } else if (ncols > COLS && ncols < patlen - COLS) {\n+      ncols += ncols \/ 7;\n+      if (ncols > patlen - COLS)  ncols = (patlen - COLS);\n+    }\n+    for (int lelen = 1; lelen <= 2; lelen++) {  \/\/ try both kinds of newline\n+      istream_test_driver(VERBOSE,\n+                          patlen, ncols, lelen,\n+                          TEST_SET_POSITION, TEST_PUSH_BACK, TEST_EXPAND_REDUCE);\n+    }\n+  }\n+}\n+\n+TEST_VM(istream, basic) {\n+  const bool VERBOSE = false;\n+  istream_test_driver(VERBOSE, false, false, false);\n+}\n+\n+TEST_VM(istream, coverage) {\n+  const bool VERBOSE = false;\n+#ifdef ASSERT\n+  istream_coverage_mode(0, cases, total, zeroes);\n+  if (cases == 0)  return;\n+  if (VERBOSE || zeroes != 0)\n+    istream_coverage_mode(-1, cases, total, zeroes);\n+  EXPECT_EQ(zeroes, 0) << \"zeroes: \" << zeroes << \"\/\" << cases;\n+#endif \/\/ASSERT\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_istream.cpp","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -119,1 +119,0 @@\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8298302 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8298302 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64,aix-ppc64\n+serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,7 @@\n+hotspot_runtime_non_cds_mode = \\\n+  runtime \\\n+  -runtime\/cds\/CheckSharingWithDefaultArchive.java \\\n+  -runtime\/cds\/appcds\/dynamicArchive\/DynamicSharedSymbols.java \\\n+  -runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java \\\n+  -runtime\/cds\/appcds\/jcmd\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302850\n+ * @summary Tests that an array clone call that has been compiled with C1\n+ *          handles null values correctly.\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileOnly=compiler.c1.TestNullArrayClone::testClone* -XX:+UnlockExperimentalVMOptions\n+ *                   compiler.c1.TestNullArrayClone\n+ *\/\n+package compiler.c1;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TestNullArrayClone {\n+    static final int ITER = 2000; \/\/ ~ Tier3CompileThreshold\n+    static final int ARRAY_SIZE = 999;\n+\n+    public static void main(String[] args) {\n+        testInts();\n+        testLongs();\n+        testBytes();\n+    }\n+\n+    private static void testInts() {\n+        final int[] arr = new int[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int[] result = testClonePrimitiveInt(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveInt(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testLongs() {\n+        final long[] arr = new long[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextLong();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            long[] result = testClonePrimitiveLong(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveLong(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testBytes() {\n+        final byte[] arr = new byte[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte) ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            byte[] result = testClonePrimitiveBytes(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveBytes(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    static int[] testClonePrimitiveInt(int[] ints) {\n+        return ints.clone();\n+    }\n+\n+    static long[] testClonePrimitiveLong(long[] longs) {\n+        return longs.clone();\n+    }\n+\n+    static byte[] testClonePrimitiveBytes(byte[] bytes) {\n+        return bytes.clone();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330795\n+ * @summary Check that Reduce Allocation Merges doesn't crash when CompressedClassPointers\n+ *          is disabled and there is an access to Klass \"field\" through the phi.\n+ * @requires vm.bits == 64 & vm.flagless & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndLoadKlass*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndLoadKlass*::test\n+ *                   -XX:CompileCommand=compileonly,*Shape*::*init*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*init*\n+ *                   -XX:CompileCommand=exclude,*TestReduceAllocationAndLoadKlass*::dummy\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:-UseCompressedClassPointers\n+ *                   -Xbatch\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.c2.TestReduceAllocationAndLoadKlass\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestReduceAllocationAndLoadKlass {\n+    public static void main(String[] args) {\n+        Point p = new Point();\n+        Line q = new Line();\n+\n+        test(true);\n+        test(false);\n+    }\n+\n+    static Class test(boolean cond) {\n+        Object p = cond ? dummy() : new Line();\n+        return p.getClass();\n+    }\n+\n+    static Point dummy() { return new Point(); }\n+\n+    static class Shape { }\n+    static class Point extends Shape { }\n+    static class Line extends Shape { }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReduceAllocationAndLoadKlass.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -120,1 +120,1 @@\n-    @IR(failOn = {IRNode.COUNTTRAILINGZEROS_VL})\n+    @IR(failOn = {IRNode.COUNT_TRAILING_ZEROS_VL})\n@@ -128,1 +128,1 @@\n-    @IR(failOn = {IRNode.COUNTLEADINGZEROS_VL})\n+    @IR(failOn = {IRNode.COUNT_LEADING_ZEROS_VL})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires vm.debug == true & vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.UseCompressedOops & vm.opt.final.EliminateAllocations\n+ * @requires vm.debug == true & vm.flagless & vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n@@ -42,9 +42,38 @@\n-        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\",\n-                                   \"-XX:+ReduceAllocationMerges\",\n-                                   \"-XX:+TraceReduceAllocationMerges\",\n-                                   \"-XX:+DeoptimizeALot\",\n-                                   \"-XX:CompileCommand=inline,*::charAt*\",\n-                                   \"-XX:CompileCommand=inline,*PicturePositions::*\",\n-                                   \"-XX:CompileCommand=inline,*Point::*\",\n-                                   \"-XX:CompileCommand=inline,*Nested::*\",\n-                                   \"-XX:CompileCommand=exclude,*::dummy*\");\n+        TestFramework framework = new TestFramework();\n+\n+        Scenario scenario0 = new Scenario(0, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:+UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario1 = new Scenario(1, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:-UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario2 = new Scenario(2, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:-UseCompressedOops\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        framework.addScenarios(scenario0, scenario1, scenario2).start();\n@@ -97,1 +126,2 @@\n-                 \"testLoadNarrowKlass_C2\",\n+                 \"testLoadKlassFromCast_C2\",\n+                 \"testLoadKlassFromPhi_C2\",\n@@ -153,1 +183,2 @@\n-        Asserts.assertEQ(testLoadNarrowKlass_Interp(cond1),                         testLoadNarrowKlass_C2(cond1));\n+        Asserts.assertEQ(testLoadKlassFromCast_Interp(cond1),                       testLoadKlassFromCast_C2(cond1));\n+        Asserts.assertEQ(testLoadKlassFromPhi_Interp(cond1),                        testLoadKlassFromPhi_C2(cond1));\n@@ -774,1 +805,2 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" } )\n+    @IR(counts = { IRNode.ALLOC, \"2\" }, applyIf = {\"UseCompressedOops\", \"true\"} )\n+    @IR(failOn = { IRNode.ALLOC }, applyIf = {\"UseCompressedOops\", \"false\"} )\n@@ -776,2 +808,2 @@\n-    \/\/ be removed because the Phi merging them will have a DecodeN user - which\n-    \/\/ currently isn't supported.\n+    \/\/ be removed, if CompressedOops is enabled, because the Phi merging them will\n+    \/\/ have a DecodeN user - which currently isn't supported.\n@@ -1261,1 +1293,1 @@\n-    Class testLoadNarrowKlass(boolean cond1) {\n+    Class testLoadKlassFromCast(boolean cond1) {\n@@ -1273,3 +1305,2 @@\n-    \/\/ The allocation won't be reduced because we don't support NarrowKlass\n-    \/\/ loads under CastPPs.\n-    Class testLoadNarrowKlass_C2(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+    \/\/ The allocation won't be reduced because we don't support [Narrow]Klass loads\n+    Class testLoadKlassFromCast_C2(boolean cond1) { return testLoadKlassFromCast(cond1); }\n@@ -1278,1 +1309,22 @@\n-    Class testLoadNarrowKlass_Interp(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+    Class testLoadKlassFromCast_Interp(boolean cond1) { return testLoadKlassFromCast(cond1); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Class testLoadKlassFromPhi(boolean cond1) {\n+        Shape p = new Square(20);\n+\n+        if (cond1) {\n+            p = new Circle(10);\n+        }\n+\n+        return p.getClass();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The allocation won't be reduced because we don't support [Narrow]Klass loads\n+    Class testLoadKlassFromPhi_C2(boolean cond1) { return testLoadKlassFromPhi(cond1); }\n+\n+    @DontCompile\n+    Class testLoadKlassFromPhi_Interp(boolean cond1) { return testLoadKlassFromPhi(cond1); }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":72,"deletions":20,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331033\n+ * @summary EA fails with \"EA unexpected CallLeaf unsafe_setmemory\" after JDK-8329331\n+ * @requires vm.compMode != \"Xint\"\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation  Test8331033\n+ *\n+ *\/\n+import java.lang.foreign.*;\n+\n+class MyClass {\n+  public int field1;\n+  public int field2;\n+  public int field3;\n+  public int field4;\n+\n+  public MyClass(int field1, int field2, int field3, int field4) {\n+    this.field1 = field1;\n+    this.field2 = field2;\n+    this.field3 = field3;\n+    this.field4 = field4;\n+  }\n+}\n+\n+public class Test8331033 {\n+\n+  public static int micro1(int ctr) {\n+    \/\/ non-escaping object, EA sweepable, values are forwarded to users, additional\n+    \/\/ bookeeping (SafepointScalarObjectNode) for eliminated objects at SafePoints\n+    \/\/ With -XX:-Inline, constructor will not be inlined and hence AllocateNode are\n+    \/\/ considered escapable.\n+    MyClass obj = new MyClass(10, 20, 30, 40);\n+    return obj.field1 * ctr + obj.field2 + obj.field3 + obj.field4;\n+  }\n+\n+  public static int micro2(int ctr) {\n+    \/\/ small known length arrays of size less than\n+    \/\/ -XX:+EliminateAllocationArraySizeLimit are eliminatable if non-escaping.\n+    int[] arr = new int[5];\n+    arr[0] = 10;\n+    arr[1] = 10;\n+    arr[2] = 10;\n+    arr[3] = 10;\n+    arr[4] = 10;\n+    \/\/ value forwarding will forward constants to expressions.\n+    return ctr * arr[0] + arr[1] + arr[2] + arr[3] + arr[4];\n+  }\n+\n+  public static int micro3(int ctr) {\n+    int[] arr = new int[8];\n+    MemorySegment ms = MemorySegment.ofArray(arr);\n+    ms.fill((byte) 10);\n+    return ctr * ms.get(ValueLayout.JAVA_INT, 12) +\n+        ms.get(ValueLayout.JAVA_INT, 16) +\n+        ms.get(ValueLayout.JAVA_INT, 20) +\n+        ms.get(ValueLayout.JAVA_INT, 24);\n+  }\n+\n+  public static void main(String[] args) {\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro1(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro2(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro3(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/Test8331033.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1167,1 +1167,1 @@\n-    public static final String COUNTTRAILINGZEROS_VL = VECTOR_PREFIX + \"COUNTTRAILINGZEROS_VL\" + POSTFIX;\n+    public static final String COUNT_TRAILING_ZEROS_VL = VECTOR_PREFIX + \"COUNT_TRAILING_ZEROS_VL\" + POSTFIX;\n@@ -1169,1 +1169,1 @@\n-        vectorNode(COUNTTRAILINGZEROS_VL, \"CountTrailingZerosV\", TYPE_LONG);\n+        vectorNode(COUNT_TRAILING_ZEROS_VL, \"CountTrailingZerosV\", TYPE_LONG);\n@@ -1172,1 +1172,1 @@\n-    public static final String COUNTLEADINGZEROS_VL = VECTOR_PREFIX + \"COUNTLEADINGZEROS_VL\" + POSTFIX;\n+    public static final String COUNT_TRAILING_ZEROS_VI = VECTOR_PREFIX + \"COUNT_TRAILING_ZEROS_VI\" + POSTFIX;\n@@ -1174,1 +1174,11 @@\n-        vectorNode(COUNTLEADINGZEROS_VL, \"CountLeadingZerosV\", TYPE_LONG);\n+        vectorNode(COUNT_TRAILING_ZEROS_VI, \"CountTrailingZerosV\", TYPE_INT);\n+    }\n+\n+    public static final String COUNT_LEADING_ZEROS_VL = VECTOR_PREFIX + \"COUNT_LEADING_ZEROS_VL\" + POSTFIX;\n+    static {\n+        vectorNode(COUNT_LEADING_ZEROS_VL, \"CountLeadingZerosV\", TYPE_LONG);\n+    }\n+\n+    public static final String COUNT_LEADING_ZEROS_VI = VECTOR_PREFIX + \"COUNT_LEADING_ZEROS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COUNT_LEADING_ZEROS_VI, \"CountLeadingZerosV\", TYPE_INT);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\")\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\") |\n+*           (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n@@ -42,2 +43,4 @@\n-    private long[] input;\n-    private int[] output;\n+    private long[] inputLong;\n+    private int[] outputLong;\n+    private int[] inputInt;\n+    private int[] outputInt;\n@@ -52,2 +55,4 @@\n-        input = new long[LEN];\n-        output = new int[LEN];\n+        inputLong = new long[LEN];\n+        outputLong = new int[LEN];\n+        inputInt = new int[LEN];\n+        outputInt = new int[LEN];\n@@ -56,1 +61,2 @@\n-            input[i] = rng.nextLong();\n+            inputLong[i] = rng.nextLong();\n+            inputInt[i] = rng.nextInt();\n@@ -61,2 +67,2 @@\n-    @IR(counts = {IRNode.COUNTTRAILINGZEROS_VL, \"> 0\"})\n-    public void vectorizeNumberOfTrailingZeros() {\n+    @IR(counts = {IRNode.COUNT_TRAILING_ZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZerosLong() {\n@@ -64,1 +70,1 @@\n-            output[i] = Long.numberOfTrailingZeros(input[i]);\n+            outputLong[i] = Long.numberOfTrailingZeros(inputLong[i]);\n@@ -69,2 +75,2 @@\n-    @IR(counts = {IRNode.COUNTLEADINGZEROS_VL, \"> 0\"})\n-    public void vectorizeNumberOfLeadingZeros() {\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZerosLong() {\n@@ -72,1 +78,1 @@\n-            output[i] = Long.numberOfLeadingZeros(input[i]);\n+            outputLong[i] = Long.numberOfLeadingZeros(inputLong[i]);\n@@ -76,3 +82,3 @@\n-    @Run(test = {\"vectorizeNumberOfTrailingZeros\", \"vectorizeNumberOfLeadingZeros\"})\n-    public void checkResult() {\n-        vectorizeNumberOfTrailingZeros();\n+    @Run(test = {\"vectorizeNumberOfTrailingZerosLong\", \"vectorizeNumberOfLeadingZerosLong\"})\n+    public void checkResultLong() {\n+        vectorizeNumberOfTrailingZerosLong();\n@@ -80,1 +86,1 @@\n-            Asserts.assertEquals(output[i], Long.numberOfTrailingZeros(input[i]));\n+            Asserts.assertEquals(outputLong[i], Long.numberOfTrailingZeros(inputLong[i]));\n@@ -82,1 +88,1 @@\n-        vectorizeNumberOfLeadingZeros();\n+        vectorizeNumberOfLeadingZerosLong();\n@@ -84,1 +90,30 @@\n-            Asserts.assertEquals(output[i], Long.numberOfLeadingZeros(input[i]));\n+            Asserts.assertEquals(outputLong[i], Long.numberOfLeadingZeros(inputLong[i]));\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_TRAILING_ZEROS_VI, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZerosInt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            outputInt[i] = Integer.numberOfTrailingZeros(inputInt[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VI, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZerosInt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            outputInt[i] = Integer.numberOfLeadingZeros(inputInt[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"vectorizeNumberOfTrailingZerosInt\", \"vectorizeNumberOfLeadingZerosInt\"})\n+    public void checkResultInt() {\n+        vectorizeNumberOfTrailingZerosInt();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(outputInt[i], Integer.numberOfTrailingZeros(inputInt[i]));\n+        }\n+        vectorizeNumberOfLeadingZerosInt();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(outputInt[i], Integer.numberOfLeadingZeros(inputInt[i]));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":53,"deletions":18,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @key cgroups\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestContainerInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.x;\n+\n+\/*\n+ * @test TestDeprecated\n+ * @requires vm.gc.ZSinglegen\n+ * @summary Test ZGenerational Deprecated\n+ * @library \/test\/lib\n+ * @run driver gc.x.TestDeprecated\n+ *\/\n+\n+import java.util.LinkedList;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestDeprecated {\n+    static class Test {\n+        public static void main(String[] args) throws Exception {}\n+    }\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeLimitedTestJava(\"-XX:+UseZGC\",\n+                                            \"-XX:-ZGenerational\",\n+                                            \"-Xlog:gc+init\",\n+                                            Test.class.getName())\n+                    .shouldContain(\"Option ZGenerational was deprecated\")\n+                    .shouldContain(\"Using deprecated non-generational mode\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestDeprecated.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test TestDefault\n+ * @requires vm.gc.ZGenerational\n+ * @summary Test that ZGC Generational Mode is Default\n+ * @library \/test\/lib\n+ * @run driver gc.z.TestDefault\n+ *\/\n+\n+import java.util.LinkedList;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestDefault {\n+    static class Test {\n+        public static void main(String[] args) throws Exception {}\n+    }\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeLimitedTestJava(\"-XX:+UseZGC\",\n+                                            \"-Xlog:gc+init\",\n+                                            Test.class.getName())\n+                    .shouldNotContain(\"Option ZGenerational was deprecated\")\n+                    .shouldNotContain(\"Using deprecated non-generational mode\")\n+                    .shouldContain(\"GC Workers for Old Generation\")\n+                    .shouldContain(\"GC Workers for Young Generation\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestDefault.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -64,0 +64,1 @@\n+            {\"ZGenerational\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test the NMT scale parameter\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary JcmdSummaryStatistics\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class JcmdSummaryStatistics {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        OutputAnalyzer output;\n+        \/\/ Grab my own PID\n+        String pid = Long.toString(jdk.test.lib.process.ProcessTools.getProcessId());\n+\n+        \/\/ Run 'jcmd <pid> VM.native_memory statistics=true'\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"statistics=true\"});\n+        output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContainMultiLinePattern(\n+                \"Native Memory Tracking Statistics:\",\n+                \"State: summary\",\n+                \"Preinit state:\",\n+                \"entries:\",\n+                \"pre-init mallocs:\",\n+                \"MallocLimit:\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/JcmdSummaryStatistics.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8216184\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LongClassListPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,6 @@\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n@@ -97,1 +103,1 @@\n-            \"TESTCASE A6: extraneous spaces, tab characters and trailing new line characters\",\n+            \"TESTCASE A6: extraneous spaces, tab characters, trailing new line characters, and trailing comment line\",\n@@ -104,1 +110,2 @@\n-                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath      \/\/ preceding spaces\n+                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath,      \/\/ preceding spaces\n+                \"#last line is a comment\"\n@@ -107,5 +114,6 @@\n-        int _max_allowed_line = 4096; \/\/ Must match ClassListParser::_max_allowed_line in C code.\n-        int _line_buf_extra = 10;     \/\/ Must match ClassListParser::_line_buf_extra in C code.\n-        StringBuffer sbuf = new StringBuffer();\n-        for (int i=0; i<_max_allowed_line+1; i++) {\n-          sbuf.append(\"x\");\n+        \/\/ Tests for corner cases in the C++ class LineReader, or invalid UTF8. These can't\n+        \/\/ be tested with dumpShouldPass\/dumpShouldFail as we need to prepare a special class\n+        \/\/ list file.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 6500; i++) {\n+            sb.append(\"X123456789\");\n@@ -114,6 +122,12 @@\n-        dumpShouldFail(\n-            \"TESTCASE A7: bad input - line too long\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.1: Long line (65000 chars)\");\n+            String longName = sb.toString(); \/\/ 65000 chars long\n+            String classList = \"LongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(longName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find \" + longName);\n+        }\n@@ -121,2 +135,13 @@\n-        for (int i=0; i<_line_buf_extra + 1000; i++) {\n-          sbuf.append(\"X\");\n+        {\n+            System.out.println(\"TESTCASE A7.2: Name Length > Symbol::max_length()\");\n+            String tooLongName = sb.toString() + sb.toString();\n+            String classList = \"TooLongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"java\/lang\/Object\\n\");\n+                fw.write(tooLongName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":2 class name too long\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n@@ -125,6 +150,24 @@\n-        dumpShouldFail(\n-            \"TESTCASE A8: bad input - line too long: try to overflow C buffer\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.3: File doesn't end with newline\");\n+            String classList = \"NoTrailingNewLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"No\/Such\/ClassABCD\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        }\n+        {\n+            System.out.println(\"TESTCASE A7.4: invalid UTF8 character\");\n+            String classList = \"BadUTF8.classlist\";\n+            try (FileOutputStream fos = new FileOutputStream(classList)) {\n+                byte chars[] = new byte[] { (byte)0xa0, (byte)0xa1, '\\n'};\n+                fos.write(chars);\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":1 class name is not valid UTF8\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":65,"deletions":22,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+\/**\n+ * This is launched from TestLambdaInvokers.\n+ *\/\n@@ -47,0 +50,4 @@\n+\n+        mh = MethodHandles.dropArguments(MethodHandles.zero(Object.class), 0, Object.class, int.class);\n+        MethodHandle inv = MethodHandles.invoker(mh.type());\n+        invoke(inv, mh, args, 3);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSLambdaInvoker.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8280767\n+ * @bug 8280767 8327499\n@@ -62,0 +62,1 @@\n+             \"-Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true\",\n@@ -72,0 +73,4 @@\n+\n+                 \/\/ java.lang.invoke.Invokers$Holder has invoker(Object,Object,Object,int)Object available\n+                 \/\/ from the archives\n+                 output.shouldContain(\"[LF_RESOLVE] java.lang.invoke.Invokers$Holder invoker L3I_L (success)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestLambdaInvokers.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8144100\n+ * @summary checking token sent by client should be done in case-insensitive manner\n+ * @run main BasicAuthToken\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Base64;\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.BasicAuthenticator;\n+import com.sun.net.httpserver.HttpServer;\n+\n+public class BasicAuthToken {\n+    private static final String CRLF = \"\\r\\n\";\n+    private static final String someContext = \"\/test\";\n+\n+    public static void main(String[] args) throws Exception {\n+        HttpServer server = server();\n+        try {\n+            client(server.getAddress().getPort());\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static HttpServer server() throws Exception {\n+        String realm = \"someRealm\";\n+        ServerAuthenticator authenticator = new ServerAuthenticator(realm);\n+        HttpServer server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        server.createContext(someContext, exchange -> {\n+            if (authenticator.authenticate(exchange) instanceof Authenticator.Failure) {\n+                exchange.sendResponseHeaders(401, -1);\n+                exchange.close();\n+                return;\n+            }\n+            exchange.sendResponseHeaders(200, -1);\n+            exchange.close();\n+        }).setAuthenticator(authenticator);\n+        server.start();\n+        return server;\n+    }\n+\n+    static void client(int port) throws Exception {\n+        try (Socket socket = new Socket(InetAddress.getLoopbackAddress(), port)) {\n+            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            String credentials = \"username:password\";\n+            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes());\n+            writer.write(\"GET \" + someContext + \" HTTP\/1.1\" + CRLF);\n+            writer.write(\"Host: localhost:\" + port + CRLF);\n+            writer.write(\"User-Agent: Java\/\" + System.getProperty(\"java.version\") + CRLF);\n+            writer.write(\"Authorization: BAsIc \" + encodedCredentials + CRLF);\n+            writer.write(CRLF);\n+            writer.flush();\n+\n+            System.err.println(\"Server response\");\n+            String statusLine = reader.readLine();\n+            System.err.println(statusLine);\n+\n+            if (!statusLine.startsWith(\"HTTP\/1.1 200\")) {\n+                throw new RuntimeException(\"unexpected status line: \" + statusLine);\n+            }\n+            if (!ServerAuthenticator.wasChecked()) {\n+                throw new RuntimeException(\"Authenticator wasn't invoked\");\n+            }\n+        }\n+    }\n+\n+\n+    static class ServerAuthenticator extends BasicAuthenticator {\n+        private static volatile boolean invoked = false;\n+\n+        ServerAuthenticator(String realm) {\n+            super(realm);\n+        }\n+\n+        public static boolean wasChecked() {\n+            return invoked;\n+        }\n+\n+        @Override\n+        public boolean checkCredentials(String username, String password) {\n+            String validUsername = \"username\", validPassword = \"password\";\n+            invoked = true;\n+            return username.equals(validUsername) && password.equals(validPassword);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/BasicAuthToken.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/TcpNoDelayNotRequired.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8332020\n+ * @summary verifies that when jwebserver is launched with a IPv6 bind address\n+ *          then the URL printed contains the correct host literal\n+ * @modules jdk.httpserver java.base\/jdk.internal.util\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.IPSupport\n+ * @run driver IPv6BoundHost\n+ *\/\n+public class IPv6BoundHost {\n+\n+    private static final Path JDK_BIN_DIR = Path.of(System.getProperty(\"java.home\")).resolve(\"bin\");\n+    private static final Path JWEBSERVER_BINARY = OperatingSystem.isWindows()\n+            ? JDK_BIN_DIR.resolve(\"jwebserver.exe\") : JDK_BIN_DIR.resolve(\"jwebserver\");\n+\n+    public static void main(final String[] args) throws Exception {\n+        IPSupport.printPlatformSupport(System.err); \/\/ for debug purposes\n+        if (!IPSupport.hasIPv6()) {\n+            throw new SkippedException(\"Skipping test - IPv6 is not supported\");\n+        }\n+        final String output = launchJwebserverAndExit(List.of(\"-b\", \"::1\", \"-p\", \"0\"));\n+        if (output.contains(\"URL http:\/\/[::1]:\")\n+                || output.contains(\"URL http:\/\/[0:0:0:0:0:0:0:1]:\")) {\n+            \/\/ found expected content\n+            System.out.println(\"found expected URL in jwebserver output\");\n+        } else {\n+            throw new AssertionError(\"missing IPv6 address in jwebserver process output\");\n+        }\n+    }\n+\n+    private static String launchJwebserverAndExit(final List<String> args) throws Exception {\n+        final Predicate<String> waitForLine = (s) -> s.startsWith(\"URL http:\/\/\");\n+        final StringBuilder sb = new StringBuilder();  \/\/ stdout & stderr\n+        final List<String> cmd = new ArrayList<>();\n+        cmd.add(JWEBSERVER_BINARY.toString());\n+        cmd.addAll(args);\n+        \/\/ start the process and await the waitForLine before returning\n+        final Process p = ProcessTools.startProcess(\"8332020-test\", new ProcessBuilder(cmd),\n+                line -> sb.append(line).append(\"\\n\"),\n+                waitForLine,\n+                30,  \/\/ suitably high default timeout, not expected to timeout\n+                TimeUnit.SECONDS);\n+        System.out.println(sb.toString()); \/\/ print the process' stdout\/stderr\n+        \/\/ the process has started and it is confirmed that the process output has the line\n+        \/\/ we were waiting for. now kill the process.\n+        p.destroy();\n+        final int exitCode = p.waitFor();\n+        if (!isNormalExitCode(exitCode)) {\n+            throw new AssertionError(\"jwebserver exited with unexpected exit code: \" + exitCode);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static boolean isNormalExitCode(final int exitCode) {\n+        final int SIGTERM = 15;\n+        if (OperatingSystem.isWindows()) {\n+            return exitCode == 1; \/\/ we expect exit code == 1 on Windows for Process.destroy()\n+        } else {\n+            \/\/ signal terminated exit code on Unix is 128 + signal value\n+            return exitCode == (128 + SIGTERM);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/IPv6BoundHost.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,1 @@\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -53,2 +49,4 @@\n-    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n-        VarHandle varHandle = layout.varHandle();\n+    public void testAccessModes(MemorySegment segment, MemoryLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout instanceof ValueLayout ?\n+                layout.varHandle() :\n+                layout.varHandle(MemoryLayout.PathElement.groupElement(0));\n@@ -56,1 +54,1 @@\n-        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        boolean compatible = AccessModeKind.supportedModes(accessLayout(layout)).contains(AccessModeKind.of(mode));\n@@ -64,1 +62,2 @@\n-            assertTrue(compatible);\n+            assertTrue(compatible ||\n+                    (layout instanceof GroupLayout && segment.maxByteAlignment() < layout.byteAlignment()));\n@@ -68,0 +67,8 @@\n+    static ValueLayout accessLayout(MemoryLayout layout) {\n+        return switch (layout) {\n+            case ValueLayout vl -> vl;\n+            case GroupLayout gl -> accessLayout(gl.memberLayouts().get(0));\n+            default -> throw new IllegalStateException();\n+        };\n+    }\n+\n@@ -148,0 +155,1 @@\n+                layouts.add(MemoryLayout.structLayout(layout.withByteAlignment(align)));\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331681\n+ * @summary Verify the java.base's console provider handles the prompt correctly.\n+ * @library \/test\/lib\n+ * @run main\/othervm --limit-modules java.base ConsolePromptTest\n+ * @run main\/othervm -Djdk.console=java.base ConsolePromptTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ConsolePromptTest {\n+\n+    public static void main(String... args) throws Throwable {\n+        for (Method m : ConsolePromptTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                m.invoke(new ConsolePromptTest());\n+            }\n+        }\n+    }\n+\n+    void testCorrectOutputReadLine() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadLine\", \"inp\", \"%s\");\n+    }\n+\n+    void testCorrectOutputReadPassword() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\", \"%s\");\n+    }\n+\n+    void doRunConsoleTest(String testName,\n+                          String input,\n+                          String expectedOut) throws Exception {\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName(),\n+                                                          testName);\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder, input);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            switch (args[0]) {\n+                case \"testCorrectOutputReadLine\" ->\n+                    System.console().readLine(\"%%s\");\n+                case \"testCorrectOutputReadPassword\" ->\n+                    System.console().readPassword(\"%%s\");\n+                default -> throw new UnsupportedOperationException(args[0]);\n+            }\n+\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/ConsolePromptTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @summary Block devices should not report size=0 on Linux\n- * @run main\/manual BlockDeviceSize\n+ * @summary FileChannel.size() should be equal to RandomAccessFile.size() and > 0 for block devs on Linux\n+ * @library \/test\/lib\n@@ -33,1 +33,0 @@\n-import java.nio.file.Paths;\n@@ -37,0 +36,2 @@\n+import java.util.List;\n+\n@@ -39,0 +40,1 @@\n+import jtreg.SkippedException;\n@@ -41,2 +43,1 @@\n-    private static final String BLK_FNAME = \"\/dev\/sda1\";\n-    private static final Path BLK_PATH = Paths.get(BLK_FNAME);\n+    private static final List<String> BLK_FNAMES = List.of(\"\/dev\/sda1\", \"\/dev\/nvme0n1\", \"\/dev\/xvda1\") ;\n@@ -45,2 +46,15 @@\n-        try (FileChannel ch = FileChannel.open(BLK_PATH, READ);\n-             RandomAccessFile file = new RandomAccessFile(BLK_FNAME, \"r\")) {\n+        for (String blkFname: BLK_FNAMES) {\n+            Path blkPath = Path.of(blkFname);\n+            try (FileChannel ch = FileChannel.open(blkPath, READ);\n+                 RandomAccessFile file = new RandomAccessFile(blkFname, \"r\")) {\n+\n+                long size1 = ch.size();\n+                long size2 = file.length();\n+                if (size1 != size2) {\n+                    throw new RuntimeException(\"size differs when retrieved\" +\n+                            \" in different ways: \" + size1 + \" != \" + size2);\n+                }\n+                if (size1 <= 0) {\n+                    throw new RuntimeException(\"size() for a block device size returns zero or a negative value\");\n+                }\n+                System.out.println(\"OK\");\n@@ -48,5 +62,6 @@\n-            long size1 = ch.size();\n-            long size2 = file.length();\n-            if (size1 != size2) {\n-                throw new RuntimeException(\"size differs when retrieved\" +\n-                        \" in different ways: \" + size1 + \" != \" + size2);\n+            } catch (NoSuchFileException nsfe) {\n+                System.err.println(\"File \" + blkFname + \" not found.\" +\n+                        \" Skipping test\");\n+            } catch (AccessDeniedException ade) {\n+                throw new SkippedException(\"Access to \" + blkFname + \" is denied.\"\n+                        + \" Run test as root.\", ade);\n@@ -54,1 +69,0 @@\n-            System.out.println(\"OK\");\n@@ -56,6 +70,0 @@\n-        } catch (NoSuchFileException nsfe) {\n-            System.err.println(\"File \" + BLK_FNAME + \" not found.\" +\n-                    \" Skipping test\");\n-        } catch (AccessDeniedException ade) {\n-            throw new RuntimeException(\"Access to \" + BLK_FNAME + \" is denied.\"\n-                    + \" Run test as root.\", ade);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/BlockDeviceSize.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331646\n+ * @summary confirm that Calendar.add() works correctly with leap year calculations\n+ * @run junit CalendarLeapYearAddTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static java.util.Calendar.APRIL;\n+import static java.util.Calendar.DATE;\n+import static java.util.Calendar.DAY_OF_MONTH;\n+import static java.util.Calendar.DAY_OF_WEEK;\n+import static java.util.Calendar.DAY_OF_WEEK_IN_MONTH;\n+import static java.util.Calendar.DAY_OF_YEAR;\n+import static java.util.Calendar.FEBRUARY;\n+import static java.util.Calendar.LONG;\n+import static java.util.Calendar.MARCH;\n+import static java.util.Calendar.MONTH;\n+import static java.util.Calendar.WEEK_OF_YEAR;\n+import static java.util.Calendar.YEAR;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CalendarLeapYearAddTest {\n+\n+    \/**\n+     * 8331646 Calendar add for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarAddSource\")\n+    public void testAddLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                int value, int calendarField, int expectedDate, int expectedMonth,\n+                                int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.add(calendarField, value);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    \/**\n+     * 8331646 Calendar month and year add\/subtract for leap\/non-leap year\n+     *\/\n+    @Test\n+    public void testMonthYearAddSubtractNonLeapYear() {\n+        Calendar calendar = new GregorianCalendar(2024, FEBRUARY, 29);\n+        calendar.add(MONTH, 1);\n+        calendar.add(YEAR, -1);\n+        calendar.add(MONTH, -1);\n+        \/* When month added date jumps to 29th of March 2024, after year subtracted date jumps to 29th of March 2023\n+           after month subtracted date jumps to 28th of Feb 2023 as non leap year\n+         *\/\n+        assertEquals(28, calendar.get(DATE),\n+                \"testMonthYearAddSubtractNonLeapYear Expected 28th of February 2024 but got \" + calendar.getTime());\n+        assertEquals(FEBRUARY, calendar.get(MONTH),\n+                \" testMonthYearAddSubtractNonLeapYear Expected February but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    \/**\n+     * 8331646 Calendar add\/subtract for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarAddSubtractSource\")\n+    public void testAddSubtractLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                        int firstValue, int secondValue, int calendarField, int expectedDate,\n+                                        int expectedMonth, int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.add(calendarField, firstValue);\n+        calendar.add(calendarField, secondValue);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    private static Stream<Arguments> calendarAddSubtractSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthAddSubtractLeapYearReversed\", 31, MARCH, 2024, -1, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 1, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 1, -1, YEAR, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 365, -365, DAY_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDateAddSubtractLeapYear\", 29, FEBRUARY, 2024, 365, -365, DATE, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testWeekOfYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 52, -52, WEEK_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 31, -31, DAY_OF_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekInMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK_IN_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekAddSubtractLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK, 29, FEBRUARY, 2024)\n+        );\n+    }\n+\n+    private static Stream<Arguments> calendarAddSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthAddLeapYear\", 29, FEBRUARY, 2024, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testOneMonthSubtractLeapYear\", 31, MARCH, 2024, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testTwoMonthSubtractLeapYear\", 30, APRIL, 2024, -2, MONTH, 29, FEBRUARY, 2024)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarLeapYearAddTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.GridLayout;\n+import javax.swing.AbstractAction;\n+import javax.swing.AbstractButton;\n+import javax.swing.JButton;\n+import javax.swing.JCheckBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @bug 4690946 8226990 6462396\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"windows\" | os.family == \"linux\")\n+ * @summary Test JTabbedPane's contentarea, tab area and tab color\n+ *          for different LAFs when opacity is enabled or disabled.\n+ * @run main\/manual TestJTabbedPaneOpaqueColor\n+ *\/\n+\n+public class TestJTabbedPaneOpaqueColor {\n+    private static JFrame frame;\n+    private static JTabbedPane tabPane;\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The background color of panel which contains the tabbed pane is green.\n+            The background color of the tabbed pane is red.\n+            The TabbedPane is not opaque initially.\n+            For 'Content Opaque' and 'Tabs Opaque' to have effect, tab pane opacity should\n+            be set to false i.e. Opaque checkbox should be unchecked.\n+            NOTE: For Nimbus LAF, tabs color are specific to nimbus style.\n+\n+            Check the default behaviour of the tabbed pane:\n+              - the area behind tabs is transparent (it must be green).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+\n+            Test Case 1 - Test TabPane Opacity:\n+            NOTE: For Nimbus LAF, tabs color are always gray in color.\n+\n+            Verify the following with 'opaque' option:\n+            when checked:\n+              - the area behind tabs is opaque (it must be red).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+            when unchecked:\n+              - the area behind tabs is transparent (it must be green).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\n+\n+            Test Case 2 - Test Content pane opacity:\n+            To test Content pane opacity, make sure \"Opaque checkbox\" is UNCHECKED.\n+\n+            Verify the following with 'content opaque' option:\n+            when checked:\n+              - the content area should be opaque (it must be gray).\n+            when unchecked:\n+              - the content area should be transparent (it must be green).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\n+\n+            Test Case 3 - Test Tabs opacity:\n+            To test Tabs opacity, make sure \"Opaque checkbox\" is UNCHECKED.\n+            NOTE: For Nimbus LAF, tabs color are specific to nimbus style.\n+                  All tabs are gray in color if tabs opaque is checked.\n+\n+            Verify the following with 'tabs opaque' option:\n+            when checked:\n+              - the tabs are opaque (it must be red, except the selected tab which must be gray).\n+            when unchecked:\n+              - the tabs are transparent (it must be green).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+            .title(\"JTabbedPane Tab and Content Area Color Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .testTimeOut(10)\n+            .rows(25)\n+            .columns(60)\n+            .testUI(TestJTabbedPaneOpaqueColor::createAndShowUI)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static JFrame createAndShowUI() {\n+        int NUM_TABS = 15;\n+        frame = new JFrame(\"Test JTabbedPane Opaque Color\");\n+        JTabbedPane tabPane = new JTabbedPane();\n+        tabPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n+        tabPane.setTabPlacement(JTabbedPane.TOP);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        for (int i = 0; i < NUM_TABS; ++i) {\n+            tabPane.addTab(\"Tab \" + i , new JLabel(\"Content Area\"));\n+        }\n+        JPanel panel = new JPanel(new BorderLayout());\n+        panel.add(tabPane, BorderLayout.CENTER);\n+        panel.setBackground(Color.green);\n+        tabPane.setBackground(Color.red);\n+\n+        UIManager.LookAndFeelInfo[] laf = UIManager.getInstalledLookAndFeels();\n+        JPanel lafButtonPanel = new JPanel(new GridLayout(1, 3));\n+        for (int i = 0; i < laf.length; ++i) {\n+            if (laf[i].getName().contains(\"Motif\")\n+                || laf[i].getName().contains(\"Windows\")) {\n+                continue;\n+            }\n+            JButton button = new JButton(laf[i].getName());\n+            button.setText(laf[i].getName());\n+            button.addActionListener(new MyAction());\n+            lafButtonPanel.add(button);\n+        }\n+\n+        JButton scrollButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n+            }\n+        });\n+        scrollButton.setText(\"SCROLL layout\");\n+\n+        JPanel layoutButtonPanel = new JPanel(new GridLayout(1, 2));\n+        JButton wrapButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabLayoutPolicy(JTabbedPane.WRAP_TAB_LAYOUT);\n+            }\n+        });\n+        wrapButton.setText(\"WRAP layout\");\n+\n+        layoutButtonPanel.add(scrollButton);\n+        layoutButtonPanel.add(wrapButton);\n+\n+        JCheckBox contentOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                if (((AbstractButton)e.getSource()).isSelected()) {\n+                    UIManager.put(\"TabbedPane.contentOpaque\", Boolean.TRUE);\n+                } else {\n+                    UIManager.put(\"TabbedPane.contentOpaque\", Boolean.FALSE);\n+                }\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        contentOpaqueChkBox.setText(\"Content Opaque\");\n+        contentOpaqueChkBox.setSelected(true);\n+        contentOpaqueChkBox.setEnabled(true);\n+\n+        JCheckBox tabOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                if (((AbstractButton)e.getSource()).isSelected()) {\n+                    UIManager.put(\"TabbedPane.tabsOpaque\", Boolean.TRUE);\n+                } else {\n+                    UIManager.put(\"TabbedPane.tabsOpaque\", Boolean.FALSE);\n+                }\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        tabOpaqueChkBox.setText(\"Tabs Opaque\");\n+        tabOpaqueChkBox.setSelected(true);\n+        tabOpaqueChkBox.setEnabled(true);\n+\n+        JCheckBox tabPaneOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setOpaque(((AbstractButton)e.getSource()).isSelected());\n+                contentOpaqueChkBox.setEnabled(!((AbstractButton)e.getSource()).isSelected());\n+                tabOpaqueChkBox.setEnabled(!((AbstractButton)e.getSource()).isSelected());\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        tabPaneOpaqueChkBox.setText(\"Opaque\");\n+\n+        JPanel checkBoxPanel = new JPanel();\n+        checkBoxPanel.add(tabPaneOpaqueChkBox);\n+        checkBoxPanel.add(contentOpaqueChkBox);\n+        checkBoxPanel.add(tabOpaqueChkBox);\n+\n+        JPanel nestedPanels = new JPanel(new GridLayout(2, 1));\n+        nestedPanels.add(lafButtonPanel);\n+        nestedPanels.add(layoutButtonPanel);\n+        panel.add(checkBoxPanel, BorderLayout.NORTH);\n+        panel.add(nestedPanels, BorderLayout.SOUTH);\n+        frame.add(panel);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+        return frame;\n+    }\n+\n+    public static class MyAction implements ActionListener {\n+        public void actionPerformed(ActionEvent ae) {\n+            String lafClassName = null;\n+            UIManager.LookAndFeelInfo lafs[] = UIManager.getInstalledLookAndFeels();\n+            for (int i = 0; i < lafs.length; i++) {\n+                if (ae.getActionCommand().equals(lafs[i].getName())) {\n+                    lafClassName = lafs[i].getClassName();\n+                    break;\n+                }\n+            }\n+            try {\n+                UIManager.setLookAndFeel(lafClassName);\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+                createAndShowUI();\n+            } catch (UnsupportedLookAndFeelException ignored) {\n+                System.out.println(\"Unsupported LAF: \" + lafClassName);\n+            } catch (ClassNotFoundException | InstantiationException\n+                     | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/TestJTabbedPaneOpaqueColor.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.swing.SwingUtilities;\n@@ -37,1 +36,0 @@\n-import javax.swing.table.TableCellRenderer;\n@@ -52,46 +50,1 @@\n-    static JFrame frame;\n-    public static PassFailJFrame passFailJFrame;\n-\n-    static void initTest() throws Exception {\n-        final String INSTRUCTIONS = \"\"\"\n-                Instructions to Test:\n-                1. Refer the below keyboard navigation specs\n-                 (referenced from bug report 4112270).\n-                2. Check all combinations of navigational keys in all four modes\n-                  shift and control verifying each change to the selection against\n-                  the spec. If it does, press \"pass\", otherwise press \"fail\".\n-\n-                  Navigate In - Tab, shift-tab, control-tab, shift-control-tab\n-                  Return\/shift-return - move focus one cell down\/up.\n-                  Tab\/shift-tab - move focus one cell right\/left.\n-                  Up\/down arrow - deselect current selection; move focus one cell up\/down\n-                  Left\/right arrow - deselect current selection; move focus one cell\n-                                             left\/right\n-                  PageUp\/PageDown - deselect current selection; scroll up\/down one\n-                                    JViewport view; first visible cell in current\n-                                    column gets focus\n-                  Control-PageUp\/PageDown - deselect current selection; scroll\n-                                            left\/right one JViewport view; first\n-                                            visible cell in current row gets\n-                                            focus\n-                  Home\/end - deselect current selection; move focus and view to\n-                                     first\/last cell in current row\n-                  Control-home\/end - deselect current selection; move focus and view to\n-                                             upper-left\/lower-right cell in table\n-                  F2 - Allows editing in a cell containing information without\n-                               overwriting the information\n-                  Esc - Resets the cell content back to the state it was in before\n-                                editing started\n-                  Ctrl+A, Ctrl+\/ = Select all\n-                  Ctrl+\\\\ = De-select all\n-                  Shift-up\/down arrow - extend selection up\/down one row\n-                  Shift-left\/right arrow - extend selection left\/right one column\n-                  Control-shift up\/down arrow - extend selection to top\/bottom of column\n-                  Shift-home\/end - extend selection to left\/right end of row\n-                  Control-shift-home\/end - extend selection to beginning\/end of data\n-                  Shift-PageUp\/PageDown - extend selection up\/down one view and scroll\n-                                          table\n-                  Control-shift-PageUp\/PageDown - extend selection left\/right one view\n-                                                          and scroll table\n-                \"\"\";\n-\n+    static JFrame initTest() {\n@@ -124,6 +77,1 @@\n-        frame = new JFrame(\"JTable Keyboard Navigation Test\");\n-        passFailJFrame = new PassFailJFrame(\"Test Instructions\",\n-                INSTRUCTIONS, 5L, 15, 50);\n-\n-        PassFailJFrame.addTestWindow(frame);\n-        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.VERTICAL);\n+        JFrame frame = new JFrame(\"JTable Keyboard Navigation Test\");\n@@ -154,3 +102,3 @@\n-        TableCellRenderer headerRenderer = colorColumn.getHeaderRenderer();\n-        if (headerRenderer instanceof DefaultTableCellRenderer)\n-            ((DefaultTableCellRenderer) headerRenderer).setToolTipText(\"Hi Mom!\");\n+        if (colorColumn.getHeaderRenderer() instanceof DefaultTableCellRenderer headerRenderer) {\n+            headerRenderer.setToolTipText(\"Hi Mom!\");\n+        }\n@@ -166,1 +114,1 @@\n-                int cellValue = (value instanceof Number) ? ((Number) value).intValue() : 0;\n+                int cellValue = (value instanceof Number number) ? number.intValue() : 0;\n@@ -175,0 +123,1 @@\n+        tableView.setColumnSelectionAllowed(true);\n@@ -181,1 +130,1 @@\n-        frame.setVisible(true);\n+        return frame;\n@@ -227,8 +176,123 @@\n-        SwingUtilities.invokeAndWait(() -> {\n-            try {\n-                initTest();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-        passFailJFrame.awaitAndCheck();\n+        String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Refer the below keyboard navigation specs\n+                 (referenced from bug report 4112270).\n+                2. Check all combinations of navigational keys mentioned below\n+                 and verifying each key combinations against the spec defined.\n+                 If it does, press \"pass\", otherwise press \"fail\".\n+\n+                \"\"\";\n+\n+        INSTRUCTIONS += getOSSpecificInstructions();\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows(30)\n+                .columns(50)\n+                .testUI(KeyBoardNavigation::initTest)\n+                .testTimeOut(10)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static String getOSSpecificInstructions() {\n+        final String WINDOWS_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection; move focus one\n+                                cell up\/down\n+                Left\/Right Arrow - Deselect current selection; move focus\n+                                   one cell left\/right\n+                PageUp\/PageDown - Deselect current selection; scroll up\/down\n+                                  one JViewport view; first visible cell in\n+                                  current column gets focus\n+                Control-PageUp\/PageDown - Deselect current selection;\n+                                          move focus and view to\n+                                          first\/last cell in current row\n+                Home\/End - Deselect current selection; move focus and view to\n+                           first\/last cell in current row\n+                Control-Home\/End - Deselect current selection;\n+                                   scroll up\/down one  JViewport view;\n+                                   first\/last visible row of the table\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one\n+                                         column\n+                Control-shift Up\/Down Arrow -  Extend selection to top\/bottom\n+                                                of column\n+                Shift-Home\/End -  Extend selection to left\/right end of row\n+                Control-Shift-Home\/End  - Extend selection to beginning\/end\n+                                          of data\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view\n+                                        and scroll table\n+                Control-Shift-PageUp\/PageDown - Extend selection left\/right\n+                                                end of row\n+                \"\"\";\n+\n+        final String LINUX_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection;\n+                                move focus one cell up\/down\n+                Left\/Right Arrow - Deselect current selection;\n+                                   move focus one cell left\/right\n+                PageUp\/PageDown - Deselect current selection;\n+                                  scroll up\/down one  JViewport view;\n+                                  first visible cell in current column gets focus\n+                Home\/End - Deselect current selection; move focus and view to\n+                                     first\/last cell in current row\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one column\n+                Control-Shift Up\/Down Arrow -  Extend selection to top\/bottom of\n+                                               column\n+                Shift-Home\/End -  Extend selection to left\/right end of row\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view and\n+                                        scroll  table\n+                \"\"\";\n+\n+        final String MAC_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection; move focus one cell\n+                                up\/down\n+                Left\/Right Arrow - Deselect current selection;\n+                                   move focus one cell left\/right\n+                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                                   scroll up\/down one JViewport view;\n+                                   first visible cell in current column gets focus\n+                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                                                    move focus and view to\n+                                                    first\/last cell in current row\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one column\n+                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n+                                        table\n+                                \"\"\";\n+        String osName = System.getProperty(\"os.name\").toLowerCase();\n+        if (osName.startsWith(\"mac\")) {\n+            return MAC_SPECIFIC;\n+        } else if (osName.startsWith(\"win\")) {\n+            return WINDOWS_SPECIFIC;\n+        } else {\n+            return LINUX_SPECIFIC;\n+        }\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":131,"deletions":67,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-            if (count > 0) {\n+            if (count > loaderCount.size() \/ 2) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/LoaderThreadCount.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing TypeKind.\n+ * @bug 8331744\n+ * @run junit TypeKindTest\n+ *\/\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.TypeKind;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+class TypeKindTest {\n+    @Test\n+    void testContracts() {\n+        assertThrows(NullPointerException.class, () -> TypeKind.from(null));\n+\n+        assertThrows(NullPointerException.class, () -> TypeKind.fromDescriptor(null));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"\"));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"int\"));\n+\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(21));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TypeKindTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -28,1 +28,2 @@\n- * @modules jdk.internal.le\/jdk.internal.org.jline.terminal\n+ * @modules jdk.internal.le\/jdk.internal.org.jline\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal\n@@ -30,0 +31,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -42,0 +44,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -59,1 +62,4 @@\n-        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, false, SignalHandler.SIG_DFL, isWrapper) {\n+        var t = new AbstractWindowsTerminal<String>(null, SystemStream.Output, out,\n+                                                    \"test\", \"vt100\", null, false,\n+                                                    SignalHandler.SIG_DFL, \"\", 0,\n+                                                    \"\", 0, isWrapper) {\n@@ -61,1 +67,1 @@\n-            protected int getConsoleMode() {\n+            protected int getConsoleMode(String console) {\n@@ -66,1 +72,1 @@\n-            protected void setConsoleMode(int mode) {\n+            protected void setConsoleMode(String console, int mode) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331535\n+ * @summary Verify the jdk.internal.le's console provider works properly.\n+ * @modules jdk.internal.le\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djdk.console=jdk.internal.le JLineConsoleProviderTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class JLineConsoleProviderTest {\n+\n+    public static void main(String... args) throws Throwable {\n+        for (Method m : JLineConsoleProviderTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                m.invoke(new JLineConsoleProviderTest());\n+            }\n+        }\n+    }\n+\n+    void testCorrectOutputReadLine() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadLine\", \"inp\", \"%s\");\n+    }\n+\n+    void testCorrectOutputReadPassword() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\", \"%s\");\n+    }\n+\n+    void doRunConsoleTest(String testName,\n+                          String input,\n+                          String expectedOut) throws Exception {\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName(),\n+                                                          testName);\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder, input);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            switch (args[0]) {\n+                case \"testCorrectOutputReadLine\" ->\n+                    System.console().readLine(\"%%s\");\n+                case \"testCorrectOutputReadPassword\" ->\n+                    System.console().readPassword(\"%%s\");\n+                default -> throw new UnsupportedOperationException(args[0]);\n+            }\n+\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -39,0 +40,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -61,2 +63,5 @@\n-        new AbstractWindowsTerminal(new StringWriter(), \"\", \"windows\", Charset.forName(\"UTF-8\"),\n-                                    true, SignalHandler.SIG_DFL, in -> in) {\n+        new AbstractWindowsTerminal<String>(null, SystemStream.Output,\n+                                            new StringWriter(), \"\", \"windows\",\n+                                            Charset.forName(\"UTF-8\"), true,\n+                                            SignalHandler.SIG_DFL, \"\", 0,\n+                                            \"\", 0, in -> in) {\n@@ -64,1 +69,1 @@\n-            protected int getConsoleMode() {\n+            protected int getConsoleMode(String console) {\n@@ -68,1 +73,1 @@\n-            protected void setConsoleMode(int mode) {\n+            protected void setConsoleMode(String console, int mode) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329691\n+ * @modules java.base\/sun.util.locale.provider\n+ *          java.base\/sun.util.cldr\n+ * @summary Tests CLDR's `nonlikelyScript` attribute is correctly implemented\n+ *      with the CLDRLocaleProviderAdapter\n+ * @run junit NonLikelyScriptTest\n+ *\/\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import sun.util.cldr.CLDRLocaleProviderAdapter;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class NonLikelyScriptTest {\n+    private static final CLDRLocaleProviderAdapter CLDR_LOCALE_PROVIDER_ADAPTER\n+        = (CLDRLocaleProviderAdapter) LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.CLDR);\n+    private static final Locale AZ_ARAB = Locale.forLanguageTag(\"az-Arab\");\n+    private static final Locale AZ_CYRL = Locale.forLanguageTag(\"az-Cyrl\");\n+    private static final Locale AZ_LATN = Locale.forLanguageTag(\"az-Latn\");\n+    private static final Locale AZ_XXXX = Locale.forLanguageTag(\"az-Xxxx\");\n+    private static final Locale RU_LATN = Locale.forLanguageTag(\"ru-Latn\");\n+    private static final Locale RU_CYRL = Locale.forLanguageTag(\"ru-Cyrl\");\n+    private static final Locale RU_XXXX = Locale.forLanguageTag(\"ru-Xxxx\");\n+    private static final Locale EN_LATN = Locale.forLanguageTag(\"en-Latn\");\n+    private static final Locale EN_DSRT = Locale.forLanguageTag(\"en-Dsrt\");\n+    private static final Locale EN_XXXX = Locale.forLanguageTag(\"en-Xxxx\");\n+    private static final Locale ZH_HANT_MO = Locale.forLanguageTag(\"zh-Hant-MO\");\n+    private static final Locale ZH_HANS_SG = Locale.forLanguageTag(\"zh-Hans-SG\");\n+    private static final Locale ZH_HANS = Locale.forLanguageTag(\"zh-Hans\");\n+    private static final Locale ZH_HANT = Locale.forLanguageTag(\"zh-Hant\");\n+    private static final Locale ZH_XXXX = Locale.forLanguageTag(\"zh-Xxxx\");\n+\n+    private static Stream<Arguments> parentLocales() {\n+\n+        return Stream.of(\n+            \/\/ likely script\n+            Arguments.of(AZ_LATN, List.of(AZ_LATN, Locale.of(\"az\"), Locale.ROOT)),\n+            Arguments.of(RU_CYRL, List.of(RU_CYRL, Locale.of(\"ru\"), Locale.ROOT)),\n+            Arguments.of(EN_LATN, List.of(EN_LATN, Locale.ENGLISH, Locale.ROOT)),\n+            Arguments.of(ZH_HANS, List.of(ZH_HANS, Locale.CHINA, Locale.CHINESE, Locale.ROOT)),\n+            Arguments.of(Locale.CHINA, List.of(Locale.forLanguageTag(\"zh-Hans-CN\"), ZH_HANS, Locale.CHINA, Locale.CHINESE, Locale.ROOT)),\n+            Arguments.of(ZH_HANS_SG, List.of(ZH_HANS_SG, ZH_HANS, Locale.forLanguageTag(\"zh-SG\"), Locale.CHINESE, Locale.ROOT)),\n+\n+            \/\/ non-likely script, explicit (as of CLDR 45)\n+            Arguments.of(AZ_ARAB, List.of(AZ_ARAB, Locale.ROOT)),\n+            Arguments.of(AZ_CYRL, List.of(AZ_CYRL, Locale.ROOT)),\n+            Arguments.of(EN_DSRT, List.of(EN_DSRT, Locale.ROOT)),\n+            Arguments.of(ZH_HANT, List.of(ZH_HANT, Locale.ROOT)),\n+            Arguments.of(Locale.TAIWAN, List.of(Locale.forLanguageTag(\"zh-Hant-TW\"), ZH_HANT, Locale.ROOT)),\n+            Arguments.of(ZH_HANT_MO, List.of(ZH_HANT_MO, Locale.forLanguageTag(\"zh-Hant-HK\"), ZH_HANT, Locale.ROOT)),\n+\n+            \/\/ non-likely script, implicit\n+            Arguments.of(AZ_XXXX, List.of(AZ_XXXX, Locale.ROOT)),\n+            Arguments.of(RU_LATN, List.of(RU_LATN, Locale.ROOT)),\n+            Arguments.of(RU_XXXX, List.of(RU_XXXX, Locale.ROOT)),\n+            Arguments.of(EN_XXXX, List.of(EN_XXXX, Locale.ROOT)),\n+            Arguments.of(ZH_XXXX, List.of(ZH_XXXX, Locale.ROOT))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentLocales\")\n+    public void checkParentLocales(Locale locale, List<Locale> expected) {\n+        var actual = CLDR_LOCALE_PROVIDER_ADAPTER.getCandidateLocales(\"\", locale);\n+        assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/sun\/util\/locale\/provider\/NonLikelyScriptTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +34,1 @@\n+import org.testng.Assert;\n@@ -40,1 +43,4 @@\n- \/*\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+\n+\/*\n@@ -42,1 +48,1 @@\n- * @bug 8252919\n+ * @bug 8252919 8327499\n@@ -125,0 +131,41 @@\n+    @Test\n+    public static void testInvokers() throws IOException {\n+        var fileString = \"[LF_RESOLVE] java.lang.invoke.Invokers$Holder invoker L3I_L (fail)\";\n+        Path invokersTrace = Files.createTempFile(\"invokers\", \"trace\");\n+        Files.writeString(invokersTrace, fileString, Charset.defaultCharset());\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"jli-invokers\"))\n+                .option(\"--generate-jli-classes=@\" + invokersTrace.toString())\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        var image = result.assertSuccess();\n+        var targetMtd = MethodTypeDesc.of(CD_Object, CD_Object, CD_Object, CD_Object, CD_int);\n+\n+        validateHolderClasses(image);\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(), List.of(), bytes -> {\n+                    var cf = ClassFile.of().parse(bytes);\n+                    if (!cf.thisClass().name().equalsString(\"java\/lang\/invoke\/Invokers$Holder\")) {\n+                        return;\n+                    }\n+\n+                    boolean found = false;\n+                    for (var m : cf.methods()) {\n+                        \/\/ LambdaForm.Kind\n+                        if (m.methodName().equalsString(\"invoker\") && m.methodTypeSymbol().equals(targetMtd)) {\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!found) {\n+                        var methodsInfo = cf.methods().stream()\n+                                .map(m -> m.methodName() + m.methodTypeSymbol().displayDescriptor())\n+                                .collect(Collectors.joining(\"\\n\"));\n+\n+                        Assert.fail(\"Missing invoker L3I_L in java.lang.invoke.Invokers$Holder, found:\\n\" + methodsInfo);\n+                    }\n+                });\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -175,0 +176,5 @@\n+        validate(jimage, expectedLocations, unexpectedPaths, _ -> {});\n+    }\n+\n+    public static void validate(Path jimage, List<String> expectedLocations,\n+            List<String> unexpectedPaths, Consumer<byte[]> classChecker) throws IOException {\n@@ -198,0 +204,1 @@\n+                    classChecker.accept(r);\n@@ -225,1 +232,1 @@\n-    public static void readClass(byte[] clazz) throws IOException{\n+    public static void readClass(byte[] clazz) throws IOException {\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageValidator.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    List<String> MISSING_IN_MAN_PAGE = List.of(\"--no-fonts\");\n+    List<String> MISSING_IN_MAN_PAGE = List.of();\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckManPageOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331535\n+ * @summary Test the JShell tool Console handling\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ *          jdk.jshell\/jdk.internal.jshell.tool:+open\n+ * @build ConsoleToolTest ReplToolTesting\n+ * @run testng ConsoleToolTest\n+ *\/\n+\n+\n+import org.testng.annotations.Test;\n+\n+public class ConsoleToolTest extends ReplToolTesting {\n+\n+    @Test\n+    public void testOutput() {\n+        test(\n+             a -> {assertCommandWithOutputAndTerminal(a,\n+                                                      \"System.console().readLine(\\\"%%s\\\");\\ninput\", \/\/newline automatically appended\n+                                                      \"$1 ==> \\\"input\\\"\",\n+                                                      \"\"\"\n+                                                      \\u0005System.console().readLine(\\\"%%s\\\");\n+                                                      %sinput\n+                                                      \"\"\");},\n+             a -> {assertCommandWithOutputAndTerminal(a,\n+                                                      \"System.console().readPassword(\\\"%%s\\\");\\ninput!\", \/\/newline automatically appended\n+                                                      \"$2 ==> char[6] { 'i', 'n', 'p', 'u', 't', '!' }\",\n+                                                      \"\"\"\n+                                                      \\u0005System.console().readPassword(\\\"%%s\\\");\n+                                                      %s\n+                                                      \"\"\");}\n+            );\n+    }\n+\n+    void assertCommandWithOutputAndTerminal(boolean a, String command, String out, String terminalOut) {\n+        assertCommand(a, command, out, null, null, null, null, terminalOut);\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ConsoleToolTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- *          jdk.internal.le\/jdk.internal.org.jline.terminal.impl\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.impl.exec\n@@ -38,1 +38,2 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecPty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -42,2 +43,2 @@\n-    public ExecPtyGetFlagsToSetTest(String name, TerminalProvider.Stream stream) {\n-        super(name, stream);\n+    public ExecPtyGetFlagsToSetTest(TerminalProvider provider, SystemStream stream, String name) {\n+        super(provider, stream, name);\n@@ -53,1 +54,1 @@\n-            new ExecPtyGetFlagsToSetTest(\"stty\", TerminalProvider.Stream.Output);\n+            new ExecPtyGetFlagsToSetTest(null, SystemStream.Output, \"stty\");\n","filename":"test\/langtools\/jdk\/jshell\/ExecPtyGetFlagsToSetTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+    public String getTerminalOutput() {\n+        String s = normalizeLineEndings(\"\\r\\n\", console.data.toString());\n+        console.data.reset();\n+        return s;\n+    }\n+\n@@ -479,0 +485,1 @@\n+\n@@ -535,0 +542,5 @@\n+        assertCommand(after, cmd, out, err, userinput, print, usererr, null);\n+    }\n+\n+    public void assertCommand(boolean after, String cmd, String out, String err,\n+            String userinput, String print, String usererr, String terminalOut) {\n@@ -549,0 +561,1 @@\n+            assertOutput(getTerminalOutput(), terminalOut, \"terminal output: \" + cmd);\n@@ -568,1 +581,5 @@\n-        return ANSI_CODE_PATTERN.matcher(text.replace(System.getProperty(\"line.separator\"), \"\\n\")).replaceAll(\"\");\n+        return normalizeLineEndings(System.getProperty(\"line.separator\"), text);\n+    }\n+\n+    private String normalizeLineEndings(String lineSeparator, String text) {\n+        return ANSI_CODE_PATTERN.matcher(text.replace(lineSeparator, \"\\n\")).replaceAll(\"\");\n@@ -849,0 +866,1 @@\n+        private final ByteArrayOutputStream data = new ByteArrayOutputStream();\n@@ -864,1 +882,2 @@\n-            } \/\/ For now, anything else is thrown away\n+            }\n+            data.write(b);\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8328481\n+ * @bug 8328481 8332236\n@@ -722,0 +722,22 @@\n+    @Test\n+    public void testImplicitlyDeclaredClass(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     import module java.base;\n+                     void main() {\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487\n+ * @bug 8304487 8327683 8330387\n@@ -45,0 +45,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3());\n@@ -117,0 +118,5 @@\n+    public static boolean wideningReferenceConversionUnboxing3() {\n+        R_generic<Integer> i = new R_generic<Integer>(0x1000000);\n+        return i instanceof R_generic(float _);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithRecordPatterns.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257\n+ * @bug 8304487 8325257 8327683 8330387\n@@ -47,0 +47,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3(0x1000000));\n@@ -124,0 +125,4 @@\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing3(T i) {\n+        return i instanceof float ff;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257\n+ * @bug 8304487 8325257 8327683 8330387\n@@ -47,0 +47,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3(0x1000000));\n@@ -124,0 +125,4 @@\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing3(T i) {\n+        return i instanceof float;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -264,0 +264,4 @@\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte b;  \/\/ not allowed as a conversion\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+PrimitivePatternsSwitchErrors.java:266:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n@@ -46,1 +47,1 @@\n-43 errors\n\\ No newline at end of file\n+44 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8326404\n+ * @summary Assertion error when trying to compile switch with fallthrough with pattern\n+ * @compile T8326404.java\n+ * @run main T8326404\n+ *\/\n+public class T8326404 {\n+    private static final record R<T>(T a) {}\n+\n+    public static void main(String[] args) {\n+        assertEquals(4, run1(\"\"));\n+        assertEquals(3, run1(new R(\"\")));\n+        assertEquals(2, run1(new R(42)));\n+\n+        assertEquals(2, run1_break1(\"\"));\n+        assertEquals(1, run1_break1(new R(\"\")));\n+        assertEquals(2, run1_break1(new R(42)));\n+\n+        assertEquals(3, run2(\"\"));\n+        assertEquals(4, run2(new R(\"\")));\n+        assertEquals(2, run2(new R(42)));\n+\n+        assertEquals(1, run2_break1(\"\"));\n+        assertEquals(2, run2_break1(new R(\"\")));\n+        assertEquals(2, run2_break1(new R(42)));\n+\n+        assertEquals(2, run3(\"\"));\n+        assertEquals(4, run3(new R(\"\")));\n+        assertEquals(3, run3(new R(42)));\n+\n+        assertEquals(2, run3_break1(\"\"));\n+        assertEquals(2, run3_break1(new R(\"\")));\n+        assertEquals(1, run3_break1(new R(42)));\n+    }\n+\n+    private static int run1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case String _:\n+                i++;\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run1_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case String s:\n+                i++;\n+            case R(String _):\n+                i++;\n+                break;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run2(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case String _:\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run2_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case String _:\n+                i++;\n+                break;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run3(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            case String _:\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run3_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+                break;\n+            case String _:\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8326404.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of conversion from type descriptor objects to type kind.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@State(Scope.Thread)\n+public class TypeKindBench {\n+\n+    public enum ClassType {\n+        PRIMITIVE, REFERENCE, MIXED;\n+    }\n+\n+    @Param\n+    ClassType type;\n+    Class<?>[] classes;\n+    ClassDesc[] classDescs;\n+\n+    @Setup\n+    public void setup() {\n+        var references = List.of(Character.class, String.class, Integer.class,\n+                Long.class, Object.class, int[].class, TypeKindBench.class,\n+                Byte[].class, boolean[][].class);\n+        var primitives = List.of(int.class, long.class, void.class, double.class,\n+                float.class, boolean.class, char.class, short.class, byte.class);\n+        final List<Class<?>> candidates = switch (type) {\n+            case REFERENCE -> references;\n+            case PRIMITIVE -> primitives;\n+            case MIXED -> {\n+                var list = new ArrayList<Class<?>>(references.size() + primitives.size());\n+                list.addAll(references);\n+                list.addAll(primitives);\n+                yield list;\n+            }\n+        };\n+\n+        \/\/ Use fixed seed to ensure results are comparable across\n+        \/\/ different JVMs\n+        classes = new Random(0xbf5fe40dd887d9e2L)\n+                .ints(100, 0, candidates.size())\n+                .mapToObj(candidates::get)\n+                .toArray(Class<?>[]::new);\n+        classDescs = Arrays.stream(classes)\n+                .map(cl -> cl.describeConstable().orElseThrow())\n+                .toArray(ClassDesc[]::new);\n+    }\n+\n+    @Benchmark\n+    public void fromClasses(Blackhole bh) {\n+        for (var clz : classes) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fromClassDescs(Blackhole bh) {\n+        for (var clz : classDescs) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/classfile\/TypeKindBench.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -40,0 +41,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -60,0 +63,7 @@\n+    static final VarHandle VH_SEQ_INT = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT).varHandle(PathElement.sequenceElement()));\n+    static final VarHandle VH_SEQ_INT_UNALIGNED = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT.withByteAlignment(1)).varHandle(PathElement.sequenceElement()));\n+\n+    static VarHandle bindToZeroOffset(VarHandle varHandle) {\n+        return MethodHandles.insertCoordinates(varHandle, 1, 0L);\n+    }\n+\n@@ -135,0 +145,18 @@\n+    @Benchmark\n+    public int segment_loop_nested() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_nested_unaligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT_UNALIGNED.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,9 +136,0 @@\n-    \/** Invokes the toString method of BigDecimal with various different values. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toString());\n-        }\n-    }\n-\n@@ -197,1 +188,1 @@\n-    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n+    \/** Test divide with huge\/small numbers *\/\n@@ -199,5 +190,6 @@\n-    @OperationsPerInvocation(TEST_SIZE - 1)\n-    public void testCompareTo(Blackhole bh) {\n-        BigDecimal c = bigDecimals[0];\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(c.compareTo(s));\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -207,1 +199,1 @@\n-    \/** Test BigDecimal.toString() with huge numbers larger than MAX_LONG *\/\n+    \/** Test divide with large\/small numbers *\/\n@@ -209,4 +201,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testHugeToString(Blackhole bh) {\n-        for (BigDecimal s : hugeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -216,1 +210,1 @@\n-    \/** Test BigDecimal.toString() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test divide with huge\/large numbers *\/\n@@ -218,4 +212,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testLargeToString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : largeArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -225,1 +221,1 @@\n-    \/** Test BigDecimal.toString() with small numbers less than MAX_INT *\/\n+    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n@@ -227,4 +223,5 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testSmallToString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE - 1)\n+    public void testCompareTo(Blackhole bh) {\n+        BigDecimal c = bigDecimals[0];\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(c.compareTo(s));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,33 @@\n+    \/** Test divide with huge\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with large\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with huge\/large numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : largeArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}