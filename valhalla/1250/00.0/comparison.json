{"files":[{"patch":"@@ -686,22 +686,19 @@\n-    $(eval MAN_$m := $(call FindModuleManDirs, $m)) \\\n-    $(foreach d, $(MAN_$m), \\\n-      $(foreach f, $(call ApplySpecFilter, $(filter %.md, $(call FindFiles, $d))), \\\n-        $(eval $m_$f_NAME := MAN_TO_HTML_$m_$(strip $(call RelativePath, $f, $(TOPDIR)))) \\\n-        $(eval $(call SetupProcessMarkdown, $($m_$f_NAME), \\\n-            SRC := $d, \\\n-            FILES := $f, \\\n-            DEST := $(DOCS_OUTPUTDIR)\/specs\/man, \\\n-            FILTER := $(PANDOC_HTML_MANPAGE_FILTER), \\\n-            CSS := $(GLOBAL_SPECS_DEFAULT_CSS_FILE), \\\n-            REPLACEMENTS := \\\n-\t\t@@COPYRIGHT_YEAR@@ => $(COPYRIGHT_YEAR) ; \\\n-\t\t@@VERSION_SHORT@@ => $(VERSION_SHORT) ; \\\n-\t\t@@VERSION_SPECIFICATION@@ => $(VERSION_SPECIFICATION), \\\n-            OPTIONS := --toc -V include-before='$(SPECS_TOP)' -V include-after='$(SPECS_BOTTOM_1)', \\\n-            POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n-                --nav-subdirs 1 --nav-link-guides, \\\n-            EXTRA_DEPS := $(PANDOC_HTML_MANPAGE_FILTER) \\\n-                $(PANDOC_HTML_MANPAGE_FILTER_SOURCE), \\\n-        )) \\\n-        $(eval JDK_SPECS_TARGETS += $($($m_$f_NAME))) \\\n-      ) \\\n+    $(eval MAN_$m := $(call ApplySpecFilter, $(filter %.md, $(call FindFiles, \\\n+          $(call FindModuleManDirs, $m))))) \\\n+    $(if $(MAN_$m), \\\n+      $(eval $(call SetupProcessMarkdown, MAN_TO_HTML_$m, \\\n+        FILES := $(MAN_$m), \\\n+        DEST := $(DOCS_OUTPUTDIR)\/specs\/man, \\\n+        FILTER := $(PANDOC_HTML_MANPAGE_FILTER), \\\n+        CSS := $(GLOBAL_SPECS_DEFAULT_CSS_FILE), \\\n+        REPLACEMENTS := \\\n+            @@COPYRIGHT_YEAR@@ => $(COPYRIGHT_YEAR) ; \\\n+            @@VERSION_SHORT@@ => $(VERSION_SHORT) ; \\\n+            @@VERSION_SPECIFICATION@@ => $(VERSION_SPECIFICATION), \\\n+        OPTIONS := --toc -V include-before='$(SPECS_TOP)' -V include-after='$(SPECS_BOTTOM_1)', \\\n+        POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n+            --nav-subdirs 1 --nav-link-guides, \\\n+        EXTRA_DEPS := $(PANDOC_HTML_MANPAGE_FILTER) \\\n+            $(PANDOC_HTML_MANPAGE_FILTER_SOURCE), \\\n+      )) \\\n+      $(eval JDK_SPECS_TARGETS += $(MAN_TO_HTML_$m)) \\\n","filename":"make\/Docs.gmk","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -978,1 +978,1 @@\n-            int targetIdx = addString(cp, header.moduleMainClass);\n+            int targetIdx = addClassName(cp, header.moduleMainClass);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -697,0 +697,5 @@\n+\/\/ Class for all non_special pointer registers (excluding rfp)\n+reg_class no_special_no_rfp_ptr_reg %{\n+  return _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n+%}\n+\n@@ -1128,0 +1133,1 @@\n+extern RegMask _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n@@ -1216,0 +1222,1 @@\n+  RegMask _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n@@ -1252,0 +1259,3 @@\n+\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -4716,0 +4726,12 @@\n+\/\/ This operand is not allowed to use rfp even if\n+\/\/ rfp is not used to hold the frame pointer.\n+operand iRegPNoSpNoRfp()\n+%{\n+  constraint(ALLOC_IN_RC(no_special_no_rfp_ptr_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16165,1 +16187,3 @@\n-instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_ptr)\n+\/\/ Don't use rfp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset rfp to the caller state.\n+instruct TailCalljmpInd(iRegPNoSpNoRfp jump_target, inline_cache_RegP method_ptr)\n@@ -16178,1 +16202,1 @@\n-instruct TailjmpInd(iRegPNoSp jump_target, iRegP_R0 ex_oop)\n+instruct TailjmpInd(iRegPNoSpNoRfp jump_target, iRegP_R0 ex_oop)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  RegMaskIterator rmi(stub->live());\n+  RegMaskIterator rmi(stub->preserve_set());\n@@ -522,1 +522,1 @@\n-      \/\/ We have size encoding in OptoReg of stub->live()\n+      \/\/ We have size encoding in OptoReg of stub->preserve_set()\n@@ -563,6 +563,2 @@\n-  \/\/ Remove C-ABI SOE registers, scratch regs and _ref register that will be updated\n-  if (stub->result() != noreg) {\n-    _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9, stub->result());\n-  } else {\n-    _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9);\n-  }\n+  \/\/ Remove C-ABI SOE registers and scratch regs\n+  _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -631,7 +631,0 @@\n-  if (stub->result() != noreg) {\n-    caller_saved.Remove(OptoReg::as_OptoReg(stub->result()->as_VMReg()));\n-  }\n-\n-  \/\/ Create mask of live registers\n-  RegMask live = stub->live();\n-\n@@ -643,1 +636,1 @@\n-  RegMaskIterator rmi(live);\n+  RegMaskIterator rmi(stub->preserve_set());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -13558,0 +13558,2 @@\n+\/\/ Don't use ebp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset ebp to the caller state.\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12739,0 +12739,2 @@\n+\/\/ Don't use rbp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset rbp to the caller state.\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,0 +437,3 @@\n+  \/\/ Size of code without stubs generated at the end of instructions section\n+  csize_t      _main_code_size;\n+\n@@ -467,0 +470,1 @@\n+    _main_code_size  = 0;\n@@ -640,0 +644,3 @@\n+  \/\/ size of code without stubs in instruction section\n+  csize_t main_code_size() const         { return _main_code_size; }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1187,1 +1187,2 @@\n-\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n+\/\/ heuristic (e.g. post call nop instructions and GC barriers;\n+\/\/ see InlineSkippedInstructionsCounter).\n@@ -1193,1 +1194,1 @@\n-        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n+        int isize = code->inline_insts_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-  template(argsize_name,                              \"argsize\")                                  \\\n+  template(bottom_name,                               \"bottom\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  uint inline_insts_size;\n@@ -154,0 +155,1 @@\n+    inline_insts_size   += nm->inline_insts_size();\n@@ -188,0 +190,3 @@\n+    if (inline_insts_size != 0) {\n+      tty->print_cr(\"     inline code = %u (%f%%)\", inline_insts_size, (inline_insts_size * 100.0f)\/total_nm_size);\n+    }\n@@ -1267,1 +1272,9 @@\n-  CHECKED_CAST(_skipped_instructions_size, uint16_t, (code_buffer->total_skipped_instructions_size()));\n+\n+  int size = code_buffer->main_code_size();\n+  assert(size >= 0, \"should be initialized\");\n+  \/\/ Use instructions section size if it is 0 (e.g. native wrapper)\n+  if (size == 0) size = code_size(); \/\/ requires _stub_offset to be set\n+  assert(size <= code_size(), \"incorrect size: %d > %d\", size, code_size());\n+  _inline_insts_size = size - _verified_entry_offset\n+                     - code_buffer->total_skipped_instructions_size();\n+  assert(_inline_insts_size >= 0, \"sanity\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -226,0 +226,2 @@\n+  int _inline_insts_size;\n+\n@@ -240,1 +242,0 @@\n-  uint16_t _skipped_instructions_size;\n@@ -597,1 +598,1 @@\n-  int skipped_instructions_size () const { return _skipped_instructions_size; }\n+  int inline_insts_size() const { return _inline_insts_size; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1399,0 +1400,1 @@\n+    InternalOOMEMark iom(THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -646,1 +647,1 @@\n-      _g1h->hr_printer()->evac_failure(r);\n+      G1HeapRegionPrinter::evac_failure(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -1273,1 +1274,1 @@\n-  assert(!heap->is_gc_active(), \"not reentrant\");\n+  assert(!heap->is_stw_gc_active(), \"not reentrant\");\n@@ -1275,1 +1276,1 @@\n-  IsGCActiveMark mark;\n+  IsSTWGCActiveMark mark;\n@@ -1496,1 +1497,1 @@\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+    assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -1513,1 +1514,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -1990,1 +1991,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-BarrierStubC2::BarrierStubC2(const MachNode* node)\n-  : _node(node),\n-    _entry(),\n-    _continuation() {}\n-\n@@ -103,0 +98,6 @@\n+BarrierStubC2::BarrierStubC2(const MachNode* node)\n+  : _node(node),\n+    _entry(),\n+    _continuation(),\n+    _preserve(live()) {}\n+\n@@ -115,0 +116,21 @@\n+void BarrierStubC2::preserve(Register r) {\n+  const VMReg vm_reg = r->as_VMReg();\n+  assert(vm_reg->is_Register(), \"r must be a general-purpose register\");\n+  _preserve.Insert(OptoReg::as_OptoReg(vm_reg));\n+}\n+\n+void BarrierStubC2::dont_preserve(Register r) {\n+  VMReg vm_reg = r->as_VMReg();\n+  assert(vm_reg->is_Register(), \"r must be a general-purpose register\");\n+  \/\/ Subtract the given register and all its sub-registers (e.g. {R11, R11_H}\n+  \/\/ for r11 in aarch64).\n+  do {\n+    _preserve.Remove(OptoReg::as_OptoReg(vm_reg));\n+    vm_reg = vm_reg->next();\n+  } while (vm_reg->is_Register() && !vm_reg->is_concrete());\n+}\n+\n+const RegMask& BarrierStubC2::preserve_set() const {\n+  return _preserve;\n+}\n+\n@@ -835,0 +857,1 @@\n+  BarrierSetC2State* bs_state = barrier_set_state();\n@@ -857,0 +880,8 @@\n+      \/\/ If this node tracks out-liveness, update it\n+      if (!bs_state->needs_livein_data()) {\n+        RegMask* const regs = bs_state->live(node);\n+        if (regs != nullptr) {\n+          regs->OR(new_live);\n+        }\n+      }\n+\n@@ -880,4 +911,6 @@\n-       \/\/ If this node tracks liveness, update it\n-      RegMask* const regs = barrier_set_state()->live(node);\n-      if (regs != NULL) {\n-        regs->OR(new_live);\n+      \/\/ If this node tracks in-liveness, update it\n+      if (bs_state->needs_livein_data()) {\n+        RegMask* const regs = bs_state->live(node);\n+        if (regs != nullptr) {\n+          regs->OR(new_live);\n+        }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  virtual bool needs_livein_data() const = 0;\n@@ -245,0 +246,7 @@\n+  RegMask         _preserve;\n+\n+  \/\/ Registers that are live-in\/live-out of the entire memory access\n+  \/\/ implementation (possibly including multiple barriers). Whether live-in or\n+  \/\/ live-out registers are returned depends on\n+  \/\/ BarrierSetC2State::needs_livein_data().\n+  RegMask& live() const;\n@@ -248,1 +256,2 @@\n-  RegMask& live() const;\n+\n+  \/\/ Entry point to the stub.\n@@ -250,0 +259,1 @@\n+  \/\/ Return point from the stub (typically end of barrier).\n@@ -252,1 +262,6 @@\n-  virtual Register result() const = 0;\n+  \/\/ Preserve the value in reg across runtime calls in this barrier.\n+  void preserve(Register reg);\n+  \/\/ Do not preserve the value in reg across runtime calls in this barrier.\n+  void dont_preserve(Register reg);\n+  \/\/ Set of registers whose value needs to be preserved across runtime calls in this barrier.\n+  const RegMask& preserve_set() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -93,2 +93,1 @@\n-  friend class IsGCActiveMark; \/\/ Block structured external access to _is_gc_active\n-  friend class DisableIsGCActiveMark; \/\/ Disable current IsGCActiveMark\n+  friend class IsSTWGCActiveMark; \/\/ Block structured external access to _is_stw_gc_active\n@@ -96,1 +95,0 @@\n-  friend class ParallelObjectIterator;\n@@ -115,1 +113,1 @@\n-  bool _is_gc_active;\n+  bool _is_stw_gc_active;\n@@ -378,4 +376,2 @@\n-  \/\/ Returns \"true\" iff there is a stop-world GC in progress.  (I assume\n-  \/\/ that it should answer \"false\" for the concurrent part of a concurrent\n-  \/\/ collector -- dld).\n-  bool is_gc_active() const { return _is_gc_active; }\n+  \/\/ Returns \"true\" iff there is a stop-world GC in progress.\n+  bool is_stw_gc_active() const { return _is_stw_gc_active; }\n@@ -407,1 +403,0 @@\n- protected:\n@@ -412,1 +407,0 @@\n- public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  if (!_thread->in_retryable_allocation()) {\n+  if (!_thread->is_in_internal_oome_mark()) {\n@@ -129,1 +129,0 @@\n-\n@@ -135,0 +134,1 @@\n+\n@@ -140,1 +140,1 @@\n-    THROW_OOP_(Universe::out_of_memory_error_retry(), true);\n+    THROW_OOP_(Universe::out_of_memory_error_java_heap_without_backtrace(), true);\n@@ -150,1 +150,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"Allocation during gc not allowed\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"Allocation during GC pause not allowed\");\n@@ -321,4 +321,1 @@\n-HeapWord* MemAllocator::mem_allocate_slow(Allocation& allocation) const {\n-  \/\/ Allocation of an oop can always invoke a safepoint.\n-  debug_only(allocation._thread->check_for_valid_safepoint_state());\n-\n+HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n@@ -326,2 +323,2 @@\n-    \/\/ Try refilling the TLAB and allocating the object in it.\n-    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n+    \/\/ Try allocating from an existing TLAB.\n+    HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -333,2 +330,2 @@\n-  return mem_allocate_outside_tlab(allocation);\n-}\n+  \/\/ Allocation of an oop can always invoke a safepoint.\n+  debug_only(allocation._thread->check_for_valid_safepoint_state());\n@@ -336,3 +333,2 @@\n-HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n-    \/\/ Try allocating from an existing TLAB.\n-    HeapWord* mem = mem_allocate_inside_tlab_fast();\n+    \/\/ Try refilling the TLAB and allocating the object in it.\n+    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n@@ -345,1 +341,1 @@\n-  return mem_allocate_slow(allocation);\n+  return mem_allocate_outside_tlab(allocation);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -55,3 +55,0 @@\n-  \/\/ Fast-path TLAB allocation failed. Takes a slow-path and potentially safepoint.\n-  HeapWord* mem_allocate_slow(Allocation& allocation) const;\n-\n@@ -128,0 +125,33 @@\n+\/\/ Manages a scope where a failed heap allocation results in\n+\/\/ suppression of JVMTI \"resource exhausted\" events and\n+\/\/ throwing a shared, backtrace-less OOME instance.\n+\/\/ Used for OOMEs that will not be propagated to user code.\n+class InternalOOMEMark: public StackObj {\n+ private:\n+  bool _outer;\n+  JavaThread* _thread;\n+\n+ public:\n+  explicit InternalOOMEMark(JavaThread* thread) {\n+    if (thread != nullptr) {\n+      _outer = thread->is_in_internal_oome_mark();\n+      thread->set_is_in_internal_oome_mark(true);\n+      _thread = thread;\n+    } else {\n+      _outer = false;\n+      _thread = nullptr;\n+    }\n+  }\n+\n+  ~InternalOOMEMark() {\n+    if (_thread != nullptr) {\n+      \/\/ Check that only InternalOOMEMark sets\n+      \/\/ JavaThread::_is_in_internal_oome_mark\n+      assert(_thread->is_in_internal_oome_mark(), \"must be\");\n+      _thread->set_is_in_internal_oome_mark(_outer);\n+    }\n+  }\n+\n+  JavaThread* thread() const  { return _thread; }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+  bool needs_livein_data() const {\n+    return true;\n+  }\n+\n@@ -203,0 +207,3 @@\n+  \/\/ The runtime call updates the value of ref, so we should not spill and\n+  \/\/ reload its outdated value.\n+  dont_preserve(ref);\n@@ -213,4 +220,0 @@\n-Register ZLoadBarrierStubC2::result() const {\n-  return ref();\n-}\n-\n@@ -275,4 +278,0 @@\n-Register ZStoreBarrierStubC2::result() const {\n-  return noreg;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  virtual Register result() const = 0;\n@@ -73,1 +72,0 @@\n-  virtual Register result() const;\n@@ -97,1 +95,0 @@\n-  virtual Register result() const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -774,5 +774,2 @@\n-    \/\/ We would like to be strict about the nmethod entry barrier but there are various test\n-    \/\/ configurations which generate assembly without being a full compiler. So for now we enforce\n-    \/\/ that JIT compiled methods must have an nmethod barrier.\n-    bool install_default = JVMCIENV->get_HotSpotNmethod_isDefault(installed_code) != 0;\n-    if (_nmethod_entry_patch_offset == -1 && install_default) {\n+    \/\/ Enforce that compiled methods have an nmethod barrier.\n+    if (_nmethod_entry_patch_offset == -1) {\n@@ -819,2 +816,1 @@\n-      if (_nmethod_entry_patch_offset != -1) {\n-        BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n@@ -822,5 +818,4 @@\n-        \/\/ an empty error buffer for use by the verify_barrier code\n-        err_msg msg(\"\");\n-        if (!bs_nm->verify_barrier(nm, msg)) {\n-          JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n-        }\n+      \/\/ an empty error buffer for use by the verify_barrier code\n+      err_msg msg(\"\");\n+      if (!bs_nm->verify_barrier(nm, msg)) {\n+        JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-                           _oom_retry,\n@@ -661,0 +660,4 @@\n+oop Universe::out_of_memory_error_java_heap_without_backtrace() {\n+  return out_of_memory_errors()->obj_at(_oom_java_heap);\n+}\n+\n@@ -685,3 +688,0 @@\n-\/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()->obj_at(_oom_retry);  }\n-\n@@ -791,3 +791,0 @@\n-  msg = java_lang_String::create_from_str(\"Java heap space: failed retryable allocation\", CHECK);\n-  java_lang_Throwable::set_message(oom_array->obj_at(_oom_retry), msg());\n-\n@@ -1360,2 +1357,2 @@\n-bool Universe::is_gc_active() {\n-  return heap()->is_gc_active();\n+bool Universe::is_stw_gc_active() {\n+  return heap()->is_stw_gc_active();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+  static oop out_of_memory_error_java_heap_without_backtrace();\n@@ -286,2 +287,0 @@\n-  \/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-  static oop out_of_memory_error_retry();\n@@ -302,1 +301,1 @@\n-  DEBUG_ONLY(static bool is_gc_active();)\n+  DEBUG_ONLY(static bool is_stw_gc_active();)\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1861,2 +1861,2 @@\n-  \/\/ Lazily create the _oop_map_cache at first request\n-  \/\/ Lock-free access requires load_acquire.\n+  \/\/ Lazily create the _oop_map_cache at first request.\n+  \/\/ Load_acquire is needed to safely get instance published with CAS by another thread.\n@@ -1865,6 +1865,7 @@\n-    MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);\n-    \/\/ Check if _oop_map_cache was allocated while we were waiting for this lock\n-    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n-      oop_map_cache = new OopMapCache();\n-      \/\/ Ensure _oop_map_cache is stable, since it is examined without a lock\n-      Atomic::release_store(&_oop_map_cache, oop_map_cache);\n+    \/\/ Try to install new instance atomically.\n+    oop_map_cache = new OopMapCache();\n+    OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n+    if (other != nullptr) {\n+      \/\/ Someone else managed to install before us, ditch local copy and use the existing one.\n+      delete oop_map_cache;\n+      oop_map_cache = other;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -877,1 +877,1 @@\n-    if (!THREAD->in_retryable_allocation()) {\n+    if (!THREAD->is_in_internal_oome_mark()) {\n@@ -882,1 +882,1 @@\n-      THROW_OOP(Universe::out_of_memory_error_retry());\n+      THROW_OOP(Universe::out_of_memory_error_java_heap_without_backtrace());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-  if (Universe::heap()->is_gc_active()) {\n+  if (Universe::heap()->is_stw_gc_active()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  return Universe::heap()->is_gc_active() && is_objArray() && is_forwarded() && (UseParallelGC || UseG1GC);\n+  return Universe::heap()->is_stw_gc_active() && is_objArray() && is_forwarded() && (UseParallelGC || UseG1GC);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+  jint int_field_relaxed(int offset) const;\n+  void int_field_put_relaxed(int offset, jint contents);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,2 @@\n+inline jint oopDesc::int_field_relaxed(int offset) const            { return Atomic::load(field_addr<jint>(offset)); }\n+inline void oopDesc::int_field_put_relaxed(int offset, jint value)  { Atomic::store(field_addr<jint>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1168,15 +1168,0 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n-  PhaseGVN& gvn = kit.gvn();\n-  Node* arg = kit.argument(arg_nb);\n-  const Type* arg_type = arg->bottom_type();\n-  const Type* sig_type = TypeOopPtr::make_from_klass(t->as_klass());\n-  if (arg_type->isa_oopptr() && !arg_type->higher_equal(sig_type)) {\n-    const Type* narrowed_arg_type = arg_type->filter_speculative(sig_type); \/\/ keep speculative part\n-    arg = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));\n-    kit.set_argument(arg_nb, arg);\n-  }\n-  if (sig_type->is_inlinetypeptr()) {\n-    arg = InlineTypeNode::make_from_oop(&kit, arg, sig_type->inline_klass(), !kit.gvn().type(arg)->maybe_null());\n-    kit.set_argument(arg_nb, arg);\n-  }\n-}\n@@ -1257,1 +1242,9 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n+          Node* recv = kit.argument(0);\n+          Node* casted_recv = kit.maybe_narrow_object_type(recv, signature->accessing_klass());\n+          if (casted_recv->is_top()) {\n+            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                                   \"argument types mismatch\");\n+            return nullptr; \/\/ FIXME: effectively dead; issue a halt node instead\n+          } else if (casted_recv != recv) {\n+            kit.set_argument(0, casted_recv);\n+          }\n@@ -1263,1 +1256,9 @@\n-            cast_argument(nargs, receiver_skip + j, t, kit);\n+            Node* arg = kit.argument(receiver_skip + j);\n+            Node* casted_arg = kit.maybe_narrow_object_type(arg, t->as_klass());\n+            if (casted_arg->is_top()) {\n+              print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                                     \"argument types mismatch\");\n+              return nullptr; \/\/ FIXME: effectively dead; issue a halt node instead\n+            } else if (casted_arg != arg) {\n+              kit.set_argument(receiver_skip + j, casted_arg);\n+            }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -507,0 +507,5 @@\n+  \/\/ Return the uncommon trap If projection of this Parse Predicate.\n+  ParsePredicateUncommonProj* uncommon_proj() const {\n+    return proj_out(0)->as_IfFalse();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -860,2 +860,0 @@\n-  \/\/ If any phase is randomized for stress testing, seed random number\n-  \/\/ generation and log the seed for repeatability.\n@@ -864,9 +862,1 @@\n-    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n-      _stress_seed = static_cast<uint>(Ticks::now().nanoseconds());\n-      FLAG_SET_ERGO(StressSeed, _stress_seed);\n-    } else {\n-      _stress_seed = StressSeed;\n-    }\n-    if (_log != nullptr) {\n-      _log->elem(\"stress_test seed='%u'\", _stress_seed);\n-    }\n+    initialize_stress_seed(directive);\n@@ -1010,0 +1000,5 @@\n+\n+  if (StressLCM || StressGCM) {\n+    initialize_stress_seed(directive);\n+  }\n+\n@@ -5620,0 +5615,12 @@\n+void Compile::initialize_stress_seed(const DirectiveSet* directive) {\n+  if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n+    _stress_seed = static_cast<uint>(Ticks::now().nanoseconds());\n+    FLAG_SET_ERGO(StressSeed, _stress_seed);\n+  } else {\n+    _stress_seed = StressSeed;\n+  }\n+  if (_log != nullptr) {\n+    _log->elem(\"stress_test seed='%u'\", _stress_seed);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1309,0 +1309,3 @@\n+  \/\/ seed random number generation and log the seed for repeatability.\n+  void initialize_stress_seed(const DirectiveSet* directive);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4757,0 +4757,14 @@\n+\n+Node* GraphKit::maybe_narrow_object_type(Node* obj, ciKlass* type) {\n+  const Type* obj_type = obj->bottom_type();\n+  const TypeOopPtr* sig_type = TypeOopPtr::make_from_klass(type);\n+  if (obj_type->isa_oopptr() && sig_type->is_loaded() && !obj_type->higher_equal(sig_type)) {\n+    const Type* narrow_obj_type = obj_type->filter_speculative(sig_type); \/\/ keep speculative part\n+    Node* casted_obj = gvn().transform(new CheckCastPPNode(control(), obj, narrow_obj_type));\n+    obj = casted_obj;\n+  }\n+  if (sig_type->is_inlinetypeptr()) {\n+    obj = InlineTypeNode::make_from_oop(this, obj, sig_type->inline_klass(), !gvn().type(obj)->maybe_null());\n+  }\n+  return obj;\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -455,0 +455,2 @@\n+  Node* maybe_narrow_object_type(Node* obj, ciKlass* type);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1345,1 +1345,1 @@\n-  IfProjNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n@@ -1368,1 +1368,1 @@\n-  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+  BoolNode* rc_predicate(Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -635,0 +635,3 @@\n+    } else if (!res_type->klass_is_exact()) {\n+      NOT_PRODUCT(fail_eliminate = \"Not an exact type.\";)\n+      can_eliminate = false;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3024,1 +3024,5 @@\n-  const TypeAryPtr* aryptr_t = _store->adr_type()->isa_aryptr();\n+  const TypePtr* ptr_t = _store->adr_type();\n+  if (ptr_t == nullptr) {\n+    return nullptr;\n+  }\n+  const TypeAryPtr* aryptr_t = ptr_t->isa_aryptr();\n@@ -3069,0 +3073,1 @@\n+      other_store->adr_type() == nullptr ||\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1586,1 +1586,1 @@\n-  DUIterator_Fast i;\n+  DUIterator_Fast i;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1350,1 +1350,0 @@\n-  _method_size = 0;\n@@ -1394,0 +1393,1 @@\n+  \/\/ GC barrier stubs are generated in code section\n@@ -1395,1 +1395,1 @@\n-  stub_req += bs->estimate_stub_size();\n+  code_req += bs->estimate_stub_size();\n@@ -1404,1 +1404,1 @@\n-  if (StressCodeBuffers)\n+  if (StressCodeBuffers) {\n@@ -1406,1 +1406,1 @@\n-\n+  }\n@@ -1415,3 +1415,4 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n+  if (C->has_method_handle_invokes()) {\n+    total_req += deopt_handler_req;        \/\/ deopt MH handler\n+    stub_req  += deopt_handler_req;\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,7 +163,3 @@\n-  jlong byte_offset = field_offset_to_byte_offset(field_offset);\n-\n-  if (sizeof(char*) == sizeof(jint)) {   \/\/ (this constant folds!)\n-    return cast_from_oop<address>(p) + (jint) byte_offset;\n-  } else {\n-    return cast_from_oop<address>(p) +        byte_offset;\n-  }\n+  uintptr_t base_address = cast_from_oop<uintptr_t>(p);\n+  uintptr_t byte_offset  = (uintptr_t)field_offset_to_byte_offset(field_offset);\n+  return (void*)(base_address + byte_offset);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -506,0 +506,1 @@\n+  { \"OldSize\",                      JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -565,1 +566,1 @@\n-    bool unused;\n+    bool unused = false;\n@@ -1276,0 +1277,1 @@\n+        InternalOOMEMark iom(THREAD);\n@@ -1294,0 +1296,1 @@\n+      InternalOOMEMark iom(THREAD);\n@@ -1297,0 +1300,1 @@\n+      InternalOOMEMark iom(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -460,0 +460,1 @@\n+  _is_in_internal_oome_mark(false),\n@@ -464,1 +465,0 @@\n-  _in_retryable_allocation(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class InternalOOMEMark;\n@@ -339,0 +340,2 @@\n+  \/\/ In scope of an InternalOOMEMark?\n+  bool _is_in_internal_oome_mark;\n@@ -354,4 +357,0 @@\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n@@ -725,0 +724,4 @@\n+  \/\/ Is thread in scope of an InternalOOMEMark?\n+  bool is_in_internal_oome_mark() const          { return _is_in_internal_oome_mark; }\n+  void set_is_in_internal_oome_mark(bool b)      { _is_in_internal_oome_mark = b;    }\n+\n@@ -734,3 +737,0 @@\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"can't extend the root set during GC\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"can't extend the root set during GC pause\");\n@@ -110,1 +110,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"can't extend the root set during GC\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"can't extend the root set during GC pause\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1122,3 +1122,5 @@\n-    \/\/ An async deflation can race after the inflate() call and before we\n-    \/\/ can update the ObjectMonitor's header with the hash value below.\n-    monitor = inflate(current, obj, inflate_cause_hash_code);\n+    \/\/ There's no need to inflate if the mark has already got a monitor.\n+    \/\/ NOTE: an async deflation can race after we get the monitor and\n+    \/\/ before we can update the ObjectMonitor's header with the hash\n+    \/\/ value below.\n+    monitor = mark.has_monitor() ? mark.monitor() : inflate(current, obj, inflate_cause_hash_code);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3127,0 +3127,12 @@\n+\n+  if (_oome && num_dump_threads > 1) {\n+    \/\/ Each additional parallel writer requires several MB of internal memory\n+    \/\/ (DumpWriter buffer, DumperClassCacheTable, GZipCompressor buffers).\n+    \/\/ For the OOM handling we may already be limited in memory.\n+    \/\/ Lets ensure we have at least 20MB per thread.\n+    julong max_threads = os::free_memory() \/ (20 * M);\n+    if (num_dump_threads > max_threads) {\n+      num_dump_threads = MAX2<uint>(1, (uint)max_threads);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n- * java.lang.classfile.CodeBuilder#invokeInstruction(java.lang.classfile.Opcode,\n+ * java.lang.classfile.CodeBuilder#invoke(java.lang.classfile.Opcode,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                cob.constantInstruction(ifaceDesc);\n+                cob.loadConstant(ifaceDesc);\n@@ -410,1 +410,1 @@\n-                    cob.constantInstruction(mi.desc);\n+                    cob.loadConstant(mi.desc);\n@@ -427,1 +427,1 @@\n-                cob.constantInstruction(proxyDesc);\n+                cob.loadConstant(proxyDesc);\n@@ -432,1 +432,1 @@\n-                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.loadConstant(Lookup.ORIGINAL);\n@@ -456,1 +456,1 @@\n-                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)),\n+                                        bcb.loadLocal(TypeKind.from(mi.desc.parameterType(j)),\n@@ -460,1 +460,1 @@\n-                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                    bcb.return_(TypeKind.from(mi.desc.returnType()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -698,1 +698,1 @@\n-                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .ldc(CD_Proxy)\n@@ -772,1 +772,1 @@\n-                            cob.constantInstruction(parameterTypes.length)\n+                            cob.loadConstant(parameterTypes.length)\n@@ -776,1 +776,1 @@\n-                                   .constantInstruction(i);\n+                                   .loadConstant(i);\n@@ -820,1 +820,1 @@\n-                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n+                cob.loadLocal(TypeKind.from(type).asLoadable(), slot);\n@@ -839,1 +839,1 @@\n-                   .returnInstruction(TypeKind.from(type).asLoadable());\n+                   .return_(TypeKind.from(type).asLoadable());\n@@ -856,1 +856,1 @@\n-               .constantInstruction(parameterTypes.length)\n+               .loadConstant(parameterTypes.length)\n@@ -862,1 +862,1 @@\n-                   .constantInstruction(i);\n+                   .loadConstant(i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-                cb.constantInstruction(0)\n+                cb.loadConstant(0)\n@@ -457,1 +457,1 @@\n-                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                            cb.instanceOf(Wrapper.forBasicType(classLabel)\n@@ -467,1 +467,1 @@\n-                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.instanceOf(ConstantDescs.CD_Number);\n@@ -496,1 +496,1 @@\n-                                cb.instanceof_(ConstantDescs.CD_Character);\n+                                cb.instanceOf(ConstantDescs.CD_Character);\n@@ -517,1 +517,1 @@\n-                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                            cb.instanceOf(classLabelConstableOpt.orElseThrow());\n@@ -521,1 +521,1 @@\n-                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.loadConstant(extraClassLabels.size());\n@@ -540,1 +540,1 @@\n-                    cb.constantInstruction(enumIdx);\n+                    cb.loadConstant(enumIdx);\n@@ -564,1 +564,1 @@\n-                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.instanceOf(ConstantDescs.CD_Number);\n@@ -574,1 +574,1 @@\n-                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.instanceOf(ConstantDescs.CD_Character);\n@@ -590,1 +590,1 @@\n-                        cb.constantInstruction(c ? 1 : 0);\n+                        cb.loadConstant(c ? 1 : 0);\n@@ -592,1 +592,1 @@\n-                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) element.caseLabel());\n@@ -608,1 +608,1 @@\n-                cb.constantInstruction(idx);\n+                cb.loadConstant(idx);\n@@ -612,1 +612,1 @@\n-            cb.constantInstruction(cases.size());\n+            cb.loadConstant(cases.size());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-                    cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n+                    cob.fieldAccess(fai.opcode(), map(fai.owner().asSymbol()),\n@@ -240,1 +240,1 @@\n-                    cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n+                    cob.invoke(ii.opcode(), map(ii.owner().asSymbol()),\n@@ -244,1 +244,1 @@\n-                    cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(\n@@ -249,1 +249,1 @@\n-                    cob.newObjectInstruction(map(c.className().asSymbol()));\n+                    cob.new_(map(c.className().asSymbol()));\n@@ -255,1 +255,1 @@\n-                    cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n+                    cob.with(TypeCheckInstruction.of(c.opcode(), map(c.type().asSymbol())));\n@@ -266,1 +266,1 @@\n-                    cob.constantInstruction(ldc.opcode(),\n+                    cob.loadConstant(ldc.opcode(),\n@@ -375,5 +375,5 @@\n-                        cts.typeArgs().stream()\n-                                .map(ta -> Signature.TypeArg.of(\n-                                        ta.wildcardIndicator(),\n-                                        ta.boundType().map(this::mapSignature)))\n-                                .toArray(Signature.TypeArg[]::new));\n+                        cts.typeArgs().stream().map(ta -> switch (ta) {\n+                            case Signature.TypeArg.Unbounded u -> u;\n+                            case Signature.TypeArg.Bounded bta -> Signature.TypeArg.bounded(\n+                                    bta.wildcardIndicator(), mapSignature(bta.boundType()));\n+                        }).toArray(Signature.TypeArg[]::new));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+        @JEP(number=476, title=\"Module Import Declarations\", status=\"Preview\")\n+        MODULE_IMPORTS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,2 +270,0 @@\n-    exports jdk.internal.util.random to\n-        jdk.random;\n@@ -400,1 +398,0 @@\n-    uses java.util.random.RandomGenerator;\n@@ -429,1 +426,11 @@\n-        java.util.SplittableRandom;\n+        java.util.SplittableRandom,\n+        jdk.internal.random.L32X64MixRandom,\n+        jdk.internal.random.L64X128MixRandom,\n+        jdk.internal.random.L64X128StarStarRandom,\n+        jdk.internal.random.L64X256MixRandom,\n+        jdk.internal.random.L64X1024MixRandom,\n+        jdk.internal.random.L128X128MixRandom,\n+        jdk.internal.random.L128X256MixRandom,\n+        jdk.internal.random.L128X1024MixRandom,\n+        jdk.internal.random.Xoroshiro128PlusPlus,\n+        jdk.internal.random.Xoshiro256PlusPlus;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,0 +214,1 @@\n+            case MODULE_IMPORTS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4495,1 +4495,3 @@\n-        for (final JCImport imp : toplevel.getImports()) {\n+        for (final JCImportBase impBase : toplevel.getImports()) {\n+            if (!(impBase instanceof JCImport imp))\n+                continue;\n@@ -4519,2 +4521,3 @@\n-        OUTER: for (JCImport imp : toplevel.getImports()) {\n-            if (!imp.staticImport && TreeInfo.name(imp.qualid) == names.asterisk) {\n+        OUTER: for (JCImportBase impBase : toplevel.getImports()) {\n+            if (impBase instanceof JCImport imp && !imp.staticImport &&\n+                TreeInfo.name(imp.qualid) == names.asterisk) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import com.sun.tools.javac.code.Directive.ExportsDirective;\n+import com.sun.tools.javac.code.Directive.RequiresDirective;\n@@ -42,2 +44,0 @@\n-import com.sun.tools.javac.parser.Parser;\n-import com.sun.tools.javac.parser.ParserFactory;\n@@ -116,2 +116,0 @@\n-    private final ParserFactory parserFactory;\n-    private final Preview preview;\n@@ -145,2 +143,0 @@\n-        parserFactory = ParserFactory.instance(context);\n-        preview = Preview.instance(context);\n@@ -372,3 +368,1 @@\n-                for (JCImport imp : tree.getImports()) {\n-                    doImport(imp);\n-                }\n+                handleImports(tree.getImports());\n@@ -396,0 +390,10 @@\n+        private void handleImports(List<JCImportBase> imports) {\n+            for (JCImportBase imp : imports) {\n+                if (imp instanceof JCModuleImport mimp) {\n+                    doModuleImport(mimp);\n+                } else {\n+                    doImport((JCImport) imp);\n+                }\n+            }\n+        }\n+\n@@ -447,0 +451,51 @@\n+        private void doModuleImport(JCModuleImport tree) {\n+            Name moduleName = TreeInfo.fullName(tree.module);\n+            ModuleSymbol module = syms.getModule(moduleName);\n+\n+            if (module != null) {\n+                if (!env.toplevel.modle.readModules.contains(module)) {\n+                    if (env.toplevel.modle.isUnnamed()) {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotReadUnnamed(module));\n+                    } else {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotRead(env.toplevel.modle,\n+                                                                           module));\n+                    }\n+                    \/\/error recovery, make sure the module is completed:\n+                    module.getDirectives();\n+                }\n+\n+                List<ModuleSymbol> todo = List.of(module);\n+                Set<ModuleSymbol> seenModules = new HashSet<>();\n+\n+                while (!todo.isEmpty()) {\n+                    ModuleSymbol currentModule = todo.head;\n+\n+                    todo = todo.tail;\n+\n+                    if (!seenModules.add(currentModule)) {\n+                        continue;\n+                    }\n+\n+                    for (ExportsDirective export : currentModule.exports) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                            continue;\n+                        }\n+\n+                        PackageSymbol pkg = export.getPackage();\n+                        JCImport nestedImport = make.at(tree.pos)\n+                                .Import(make.Select(make.QualIdent(pkg), names.asterisk), false);\n+\n+                        doImport(nestedImport);\n+                    }\n+\n+                    for (RequiresDirective requires : currentModule.requires) {\n+                        if (requires.isTransitive()) {\n+                            todo = todo.prepend(requires.module);\n+                        }\n+                    }\n+                }\n+            } else {\n+                log.error(tree.pos, Errors.ImportModuleNotFound(moduleName));\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":64,"deletions":9,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -4295,0 +4295,7 @@\n+        } else if (token.kind == IDENTIFIER && token.name() == names.module &&\n+                   peekToken(TokenKind.IDENTIFIER)) {\n+            checkSourceLevel(Feature.MODULE_IMPORTS);\n+            nextToken();\n+            JCExpression moduleName = qualident(false);\n+            accept(SEMI);\n+            return toP(F.at(pos).ModuleImport(moduleName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3230,0 +3230,3 @@\n+compiler.misc.feature.module.imports=\\\n+    module imports\n+\n@@ -3540,0 +3543,12 @@\n+# 0: name\n+compiler.err.import.module.not.found=\\\n+    imported module not found: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=\\\n+    unnamed module does not read: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read=\\\n+    module {0} does not read: {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -371,10 +371,14 @@\n-            switch (ta.wildcardIndicator()) {\n-                case DEFAULT -> print(sb, ta.boundType().get());\n-                case UNBOUNDED -> sb.append('?');\n-                case EXTENDS -> {\n-                    sb.append(\"? extends \");\n-                    print(sb, ta.boundType().get());\n-                }\n-                case SUPER -> {\n-                    sb.append(\"? super \");\n-                    print(sb, ta.boundType().get());\n+            switch (ta) {\n+                case Signature.TypeArg.Unbounded _ -> sb.append('?');\n+                case Signature.TypeArg.Bounded bta -> {\n+                    switch (bta.wildcardIndicator()) {\n+                        case NONE -> print(sb, bta.boundType());\n+                        case EXTENDS -> {\n+                            sb.append(\"? extends \");\n+                            print(sb, bta.boundType());\n+                        }\n+                        case SUPER -> {\n+                            sb.append(\"? super \");\n+                            print(sb, bta.boundType());\n+                        }\n+                    }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -338,1 +338,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n@@ -411,1 +411,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -414,1 +414,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n@@ -494,1 +494,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -497,1 +497,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-sun\/tools\/jcmd\/JcmdOutputEncodingTest.java 8308033 generic-all\n-sun\/tools\/jstack\/BasicJStackTest.java 8308033 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                cob.constantInstruction(CD_Comparator);\n+                cob.loadConstant(CD_Comparator);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n+                    cob.return_(TypeKind.from(returnType));\n@@ -408,2 +408,2 @@\n-                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n+                    cob.return_(TypeKind.from(returnType));\n@@ -420,2 +420,2 @@\n-                    cob.constantInstruction(dynamic);\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(dynamic);\n+                    cob.return_(TypeKind.from(returnType));\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                                            codeBuilder.loadInstruction(TypeKind.from(type.parameterType(i)), i);\n+                                            codeBuilder.loadLocal(TypeKind.from(type.parameterType(i)), i);\n@@ -78,1 +78,1 @@\n-                                        codeBuilder.returnInstruction(TypeKind.from(type.returnType()));\n+                                        codeBuilder.return_(TypeKind.from(type.returnType()));\n@@ -120,1 +120,1 @@\n-                                    .returnInstruction(TypeKind.fromDescriptor(type))));\n+                                    .return_(TypeKind.fromDescriptor(type))));\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-                cob.constantInstruction(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MTD_int));\n+                cob.loadConstant(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MTD_int));\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/SpecialStatic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-                        else cob.constantInstruction(null);\n+                        else cob.loadConstant(null);\n@@ -286,1 +286,1 @@\n-                            else cob.constantInstruction(iVal);\n+                            else cob.loadConstant(iVal);\n@@ -291,1 +291,1 @@\n-                            else cob.constantInstruction(lVal);\n+                            else cob.loadConstant(lVal);\n@@ -297,1 +297,1 @@\n-                            else cob.constantInstruction(fVal);\n+                            else cob.loadConstant(fVal);\n@@ -302,1 +302,1 @@\n-                            else cob.constantInstruction(dVal);\n+                            else cob.loadConstant(dVal);\n@@ -304,1 +304,1 @@\n-                        default -> cob.constantInstruction(i.constantValue());\n+                        default -> cob.loadConstant(i.constantValue());\n@@ -553,1 +553,1 @@\n-                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n+                            case INSTANCEOF -> cob.instanceOf(i.type().asSymbol());\n@@ -559,1 +559,1 @@\n-                            case INSTANCEOF -> cob.instanceof_(i.type());\n+                            case INSTANCEOF -> cob.instanceOf(i.type());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.constant.PackageDesc;\n@@ -61,8 +66,5 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -984,0 +986,5 @@\n+        return prepareVersionedCTSym(code7, code8, _ -> {});\n+    }\n+\n+    Path prepareVersionedCTSym(String[] code7, String[] code8,\n+                               Consumer<Path> adjustClassFiles) throws Exception {\n@@ -989,1 +996,1 @@\n-        compileAndPack(output, ver7Jar, code7);\n+        compileAndPack(output, ver7Jar, adjustClassFiles, code7);\n@@ -991,1 +998,1 @@\n-        compileAndPack(output, ver8Jar, code8);\n+        compileAndPack(output, ver8Jar, adjustClassFiles, code8);\n@@ -1051,0 +1058,100 @@\n+    @Test\n+    void testModuleMainClass() throws Exception {\n+        ClassFile cf = ClassFile.of();\n+        ToolBox tb = new ToolBox();\n+        String testClasses = System.getProperty(\"test.classes\");\n+        Path output = Paths.get(testClasses, \"test-data\" + i++);\n+        deleteRecursively(output);\n+        Files.createDirectories(output);\n+        Path ver9Jar = output.resolve(\"9.jar\");\n+        compileAndPack(output,\n+                       ver9Jar,\n+                       classesDir -> {\n+                           try {\n+                               Path moduleInfo = classesDir.resolve(\"module-info.class\");\n+                               byte[] newClassData =\n+                                       cf.transform(cf.parse(moduleInfo),\n+                                                    (builder, element) -> {\n+                                                        builder.with(element);\n+                                                        if (element instanceof ModuleAttribute) {\n+                                                            builder.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Main\")));\n+                                                        }\n+                                                    });\n+                               try (OutputStream out = Files.newOutputStream(moduleInfo)) {\n+                                   out.write(newClassData);\n+                               }\n+                           } catch (IOException ex) {\n+                               throw new UncheckedIOException(ex);\n+                           }\n+                       },\n+                       \"\"\"\n+                       module m {\n+                       }\n+                       \"\"\",\n+                       \"\"\"\n+                       package main;\n+                       public class Main {}\n+                       \"\"\");\n+\n+\n+        Path ctSym = output.resolve(\"ct.sym\");\n+\n+        deleteRecursively(ctSym);\n+\n+        CreateSymbols.ALLOW_NON_EXISTING_CLASSES = true;\n+        CreateSymbols.EXTENSION = \".class\";\n+\n+        List<VersionDescription> versions =\n+                Arrays.asList(new VersionDescription(ver9Jar.toAbsolutePath().toString(), \"9\", null));\n+\n+        ExcludeIncludeList acceptAll = new ExcludeIncludeList(null, null) {\n+            @Override public boolean accepts(String className, boolean includePrivateClasses) {\n+                return true;\n+            }\n+        };\n+        new CreateSymbols().createBaseLine(versions, acceptAll, ctSym, new String[0]);\n+        Path symbolsDesc = ctSym.resolve(\"symbols\");\n+        Path modules = ctSym.resolve(\"modules\");\n+        Path modulesList = ctSym.resolve(\"modules-list\");\n+\n+        Files.createDirectories(modules);\n+        try (Writer w = Files.newBufferedWriter(modulesList)) {}\n+\n+        Path classesZip = output.resolve(\"classes.zip\");\n+        Path classesDir = output.resolve(\"classes\");\n+\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString(), modulesList.toString());\n+\n+        try (JarFile jf = new JarFile(classesZip.toFile())) {\n+            Enumeration<JarEntry> en = jf.entries();\n+\n+            while (en.hasMoreElements()) {\n+                JarEntry je = en.nextElement();\n+                if (je.isDirectory()) continue;\n+                Path target = classesDir.resolve(je.getName());\n+                Files.createDirectories(target.getParent());\n+                Files.copy(jf.getInputStream(je), target);\n+            }\n+        }\n+\n+        Path moduleInfo = classesDir.resolve(\"9\")\n+                                    .resolve(\"m\")\n+                                    .resolve(\"module-info.class\");\n+\n+        cf.parse(moduleInfo)\n+          .attributes()\n+          .stream()\n+          .filter(attr -> attr instanceof ModuleMainClassAttribute)\n+          .forEach(attr -> {\n+              String expectedMain = \"Lmain\/Main;\";\n+              String mainClass =\n+                      ((ModuleMainClassAttribute) attr).mainClass()\n+                                                       .asSymbol()\n+                                                       .descriptorString();\n+              if (!Objects.equals(expectedMain, mainClass)) {\n+                  throw new AssertionError(\"Expected \" + expectedMain + \" as a main class, \" +\n+                                           \"but got: \" + mainClass);\n+              }\n+          });\n+    }\n+\n@@ -1052,0 +1159,5 @@\n+        compileAndPack(output, outputFile, _ -> {}, code);\n+    }\n+\n+    void compileAndPack(Path output, Path outputFile,\n+                        Consumer<Path> adjustClassFiles, String... code) throws Exception {\n@@ -1068,17 +1180,10 @@\n-            ClassFile cf = ClassFile.read(moduleInfo);\n-            List<CPInfo> cp = new ArrayList<>();\n-            cp.add(null);\n-            cf.constant_pool.entries().forEach(cp::add);\n-            Map<String, Attribute> attrs = new HashMap<>(cf.attributes.map);\n-            int[] encodedPackages = new int[packages.size()];\n-            int i = 0;\n-            for (String p : packages) {\n-                int nameIndex = cp.size();\n-                cp.add(new CONSTANT_Utf8_info(p));\n-                encodedPackages[i++] = cp.size();\n-                cp.add(new ConstantPool.CONSTANT_Package_info(null, nameIndex));\n-            }\n-            int attrName = cp.size();\n-            cp.add(new CONSTANT_Utf8_info(Attribute.ModulePackages));\n-            attrs.put(Attribute.ModulePackages, new ModulePackages_attribute(attrName, encodedPackages));\n-            ClassFile newFile = new ClassFile(cf.magic, cf.minor_version, cf.major_version, new ConstantPool(cp.toArray(new CPInfo[0])), cf.access_flags, cf.this_class, cf.super_class, cf.interfaces, cf.fields, cf.methods, new Attributes(attrs));\n+            ClassFile cf = ClassFile.of();\n+            ClassModel cm = cf.parse(moduleInfo);\n+            byte[] newData = cf.transform(cm, (builder, element) -> {\n+                builder.with(element);\n+                if (element instanceof ModuleAttribute) {\n+                    builder.with(ModulePackagesAttribute.ofNames(packages.stream()\n+                                                                         .map(pack -> PackageDesc.of(pack))\n+                                                                         .toList()));\n+                }\n+            });\n@@ -1086,1 +1191,1 @@\n-                new ClassWriter().write(newFile, out);\n+                out.write(newData);\n@@ -1089,0 +1194,1 @@\n+        adjustClassFiles.accept(scratch);\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":134,"deletions":28,"binary":false,"changes":162,"status":"modified"}]}