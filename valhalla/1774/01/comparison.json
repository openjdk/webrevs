{"files":[{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Are arrays containing this inline type flat arrays?\n+\/\/ Could any array containing an instance of this value class ever be flat?\n@@ -40,0 +40,5 @@\n+\/\/ Are arrays containing an instance of this value class always flat?\n+bool ciInlineKlass::is_always_flat_in_array() const {\n+  GUARDED_VM_ENTRY(return to_InlineKlass()->is_always_flat_in_array();)\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  bool is_always_flat_in_array() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -708,2 +708,3 @@\n-    VM_ENTRY_MARK;\n-    return !get_instanceKlass()->access_flags().is_identity_class() || is_java_lang_Object() ;\n+    GUARDED_VM_ENTRY(\n+      return !get_instanceKlass()->access_flags().is_identity_class() || is_java_lang_Object();\n+    )\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -301,0 +301,13 @@\n+bool InlineKlass::is_always_flat_in_array() {\n+  if (!UseArrayFlattening) {\n+    return false;\n+  }\n+  \/\/ Too many embedded oops\n+  if ((FlatArrayElementMaxOops >= 0) && (nonstatic_oop_count() > FlatArrayElementMaxOops)) {\n+    return false;\n+  }\n+\n+  \/\/ An instance is always flat in an array if we have all layouts.\n+  return has_nullable_atomic_layout() && has_atomic_layout() && has_non_atomic_layout();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+  bool is_always_flat_in_array();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1493,0 +1493,1 @@\n+    tj = to = to->cast_to_maybe_flat_in_array(); \/\/ flatten to maybe flat in array\n@@ -1546,1 +1547,2 @@\n-        assert(tj == TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id), \"exact type should be canonical type\");\n+        assert(tj == TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id,\n+                                       TypePtr::MaybeFlat), \"exact type should be canonical type\");\n@@ -1549,1 +1551,2 @@\n-        tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id);\n+        tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id,\n+                                    TypePtr::MaybeFlat);\n@@ -1564,1 +1567,2 @@\n-                                       Type::Offset(offset));\n+                                       Type::Offset(offset),\n+                                       TypePtr::MaybeFlat);\n@@ -1570,1 +1574,1 @@\n-        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), Type::Offset(offset));\n+        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), Type::Offset(offset), TypePtr::MaybeFlat);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1105,2 +1105,2 @@\n-      if ((r0->flat_in_array() && r1->not_flat_in_array()) ||\n-          (r1->flat_in_array() && r0->not_flat_in_array())) {\n+      if ((r0->is_flat_in_array() && r1->is_not_flat_in_array()) ||\n+          (r1->is_flat_in_array() && r0->is_not_flat_in_array())) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  const TypeKlassPtr* superk = super_t->isa_klassptr();\n+  const TypeKlassPtr* super_klass_type = super_t->isa_klassptr();\n@@ -37,1 +37,1 @@\n-  const TypeKlassPtr* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr() : sub_t->is_oopptr()->as_klass_type();\n+  const TypeKlassPtr* sub_klass_type = sub_t->isa_klassptr() ? sub_t->is_klassptr() : sub_t->is_oopptr()->as_klass_type();\n@@ -40,2 +40,2 @@\n-  if (sub_t->isa_oopptr() && superk->isa_instklassptr() && superk->klass_is_exact()) {\n-    ciKlass* superklass = superk->exact_klass();\n+  if (sub_t->isa_oopptr() && super_klass_type->isa_instklassptr() && super_klass_type->klass_is_exact()) {\n+    ciKlass* superklass = super_klass_type->exact_klass();\n@@ -52,0 +52,1 @@\n+\n@@ -53,1 +54,17 @@\n-  if (subk->flat_in_array() && superk->not_flat_in_array_inexact()) {\n+  \/\/\n+  \/\/ The super klass can be an exact non-array klass constant which is known to be not flat in array (e.g. Object)\n+  \/\/ while the sub klass could very well be flat in array:\n+  \/\/\n+  \/\/           MyValue       <:       Object:exact\n+  \/\/        flat in array          not flat in array\n+  \/\/\n+  \/\/ We therefore first cast the super klass to inexact (if the class is not final itself) and recompute the flat in\n+  \/\/ array property for the super klass (all done in cast_to_exactness()) in order to check whether the sub klass is\n+  \/\/ flat in array and the super klass is not flat in array. If that's the case, the classes must be unrelated.\n+  const TypeKlassPtr* super_klass_type_for_flat_in_array = super_klass_type;\n+  if (super_klass_type->isa_instklassptr()) {\n+    \/\/ Only relevant for TypeInstKlassPtr. TypeAryKlassPtr will always be not flat in array.\n+    super_klass_type_for_flat_in_array = super_klass_type->cast_to_exactness(false);\n+  }\n+\n+  if (sub_klass_type->is_flat_in_array() && super_klass_type_for_flat_in_array->is_not_flat_in_array()) {\n@@ -56,1 +73,1 @@\n-  } else if (subk->is_not_flat() && superk->is_flat()) {\n+  } else if (sub_klass_type->is_not_flat() && super_klass_type->is_flat()) {\n@@ -59,1 +76,1 @@\n-  } else if (subk->is_not_null_free() && superk->is_null_free()) {\n+  } else if (sub_klass_type->is_not_null_free() && super_klass_type->is_null_free()) {\n@@ -70,1 +87,1 @@\n-  switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n+  switch (Compile::current()->static_subtype_check(super_klass_type, sub_klass_type, false)) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1054,5 +1054,0 @@\n-  \/\/ TODO 8332406 Fix this\n-  if ((   isa_instptr() != nullptr &&    is_instptr()->flat_in_array()) ||\n-      (t->isa_instptr() != nullptr && t->is_instptr()->flat_in_array())) {\n-    return;\n-  }\n@@ -1073,0 +1068,9 @@\n+    tty->cr();\n+    tty->print_cr(\"Fail: \");\n+    if (t2t != t->_dual) {\n+      tty->print_cr(\"- mt_dual meet t_dual != t_dual\");\n+    }\n+    if (t2this != this->_dual) {\n+      tty->print_cr(\"- mt_dual meet this_dual != this_dual\");\n+    }\n+    tty->cr();\n@@ -2834,0 +2838,12 @@\n+\n+const TypePtr::FlatInArray TypePtr::flat_in_array_dual[Uninitialized] = {\n+  \/* TopFlat   -> *\/ MaybeFlat,\n+  \/* Flat      -> *\/ NotFlat,\n+  \/* NotFlat   -> *\/ Flat,\n+  \/* MaybeFlat -> *\/ TopFlat\n+};\n+\n+const char *const TypePtr::flat_in_array_msg[Uninitialized] = {\n+  \"TOP flat in array\", \"flat in array\", \"not flat in array\", \"maybe flat in array\"\n+};\n+\n@@ -3119,0 +3135,33 @@\n+TypePtr::FlatInArray TypePtr::compute_flat_in_array(ciInstanceKlass* instance_klass, bool is_exact) {\n+  if (!instance_klass->can_be_inline_klass(is_exact)) {\n+    \/\/ Definitely not a value class and thus never flat in an array.\n+    return NotFlat;\n+  }\n+  if (instance_klass->is_inlinetype() && instance_klass->as_inline_klass()->is_always_flat_in_array()) {\n+    return Flat;\n+  }\n+  \/\/ We don't know.\n+  return MaybeFlat;\n+}\n+\n+\/\/ Compute flat in array property if we don't know anything about it (i.e. old_flat_in_array == MaybeFlat).\n+TypePtr::FlatInArray TypePtr::compute_flat_in_array_if_unknown(ciInstanceKlass* instance_klass, bool is_exact,\n+  FlatInArray old_flat_in_array) const {\n+  switch (old_flat_in_array) {\n+    case Flat:\n+      assert(can_be_inline_type(), \"only value objects can be flat in array\");\n+      assert(!instance_klass->is_inlinetype() || instance_klass->as_inline_klass()->is_always_flat_in_array(),\n+             \"a value object is only marked flat in array if it proven to be always flat in array\");\n+      break;\n+    case NotFlat:\n+      assert(!instance_klass->maybe_flat_in_array(), \"cannot be flat\");\n+      break;\n+    case MaybeFlat:\n+      return compute_flat_in_array(instance_klass, is_exact);\n+      break;\n+    default:\n+      break;\n+  }\n+  return old_flat_in_array;\n+}\n+\n@@ -3156,0 +3205,16 @@\n+\n+void TypePtr::dump_flat_in_array(FlatInArray flat_in_array, outputStream* st) {\n+  switch (flat_in_array) {\n+    case MaybeFlat:\n+    case NotFlat:\n+      if (!Verbose) {\n+        break;\n+      }\n+    case TopFlat:\n+    case Flat:\n+      st->print(\" (%s)\", flat_in_array_msg[flat_in_array]);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -3815,0 +3880,1 @@\n+    ciInstanceKlass* ik = klass->as_instance_klass();\n@@ -3817,1 +3883,0 @@\n-      ciInstanceKlass* ik = klass->as_instance_klass();\n@@ -3835,0 +3900,1 @@\n+    FlatInArray flat_in_array = compute_flat_in_array(ik, klass_is_exact);\n@@ -3836,1 +3902,1 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, nullptr, Offset(0));\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, nullptr, Offset(0), flat_in_array);\n@@ -4161,1 +4227,1 @@\n-                         bool flat_in_array, int instance_id, const TypePtr* speculative, int inline_depth)\n+                         FlatInArray flat_in_array, int instance_id, const TypePtr* speculative, int inline_depth)\n@@ -4164,0 +4230,2 @@\n+\n+  assert(flat_in_array != Uninitialized, \"must be set now\");\n@@ -4168,2 +4236,0 @@\n-  assert(!klass()->maybe_flat_in_array() || flat_in_array, \"Should be flat in array\");\n-  assert(!flat_in_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n@@ -4179,1 +4245,1 @@\n-                                     bool flat_in_array,\n+                                     FlatInArray flat_in_array,\n@@ -4191,0 +4257,1 @@\n+  ciInstanceKlass* ik = k->as_instance_klass();\n@@ -4195,1 +4262,0 @@\n-    ciInstanceKlass* ik = k->as_instance_klass();\n@@ -4201,3 +4267,3 @@\n-  \/\/ Check if this type is known to be flat in arrays\n-  flat_in_array = flat_in_array || k->maybe_flat_in_array();\n-\n+  if (flat_in_array == Uninitialized) {\n+    flat_in_array = compute_flat_in_array(ik, xk);\n+  }\n@@ -4283,1 +4349,2 @@\n-  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _flat_in_array, _instance_id, _speculative, _inline_depth);\n+  FlatInArray flat_in_array = compute_flat_in_array(ik, klass_is_exact);\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, flat_in_array, _instance_id, _speculative, _inline_depth);\n@@ -4321,1 +4388,5 @@\n-    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, nullptr, off, false, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  {\n+      FlatInArray flat_in_array = meet_flat_in_array(_flat_in_array, tinst->flat_in_array());\n+      return make(ptr, unloaded->klass(), interfaces, false, nullptr, off, flat_in_array, instance_id,\n+                  speculative, depth);\n+    }\n@@ -4462,1 +4533,0 @@\n-    bool res_flat_in_array = false;\n@@ -4464,1 +4534,1 @@\n-    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk, res_flat_in_array);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n@@ -4484,0 +4554,1 @@\n+      FlatInArray flat_in_array = meet_flat_in_array(_flat_in_array, tinst->flat_in_array());\n@@ -4505,1 +4576,1 @@\n-      res = make(ptr, res_klass, interfaces, res_xk, o, off, res_flat_in_array, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, flat_in_array, instance_id, speculative, depth);\n@@ -4517,1 +4588,1 @@\n-                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flat_in_array) {\n+                                                            ciKlass*& res_klass, bool& res_xk) {\n@@ -4520,4 +4591,0 @@\n-  const bool this_flat_in_array = this_type->flat_in_array();\n-  const bool other_flat_in_array = other_type->flat_in_array();\n-  const bool this_not_flat_in_array = this_type->not_flat_in_array();\n-  const bool other_not_flat_in_array = other_type->not_flat_in_array();\n@@ -4535,1 +4602,1 @@\n-  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk && this_flat_in_array == other_flat_in_array) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n@@ -4538,1 +4605,0 @@\n-    res_flat_in_array = this_flat_in_array;\n@@ -4571,57 +4637,0 @@\n-  \/\/ Flat in Array property _flat_in_array.\n-  \/\/ For simplicity, _flat_in_array is a boolean but we actually have a tri state:\n-  \/\/ - Flat in array       -> flat_in_array()\n-  \/\/ - Not flat in array   -> not_flat_in_array()\n-  \/\/ - Maybe flat in array -> !not_flat_in_array()\n-  \/\/\n-  \/\/ Maybe we should convert _flat_in_array to a proper lattice with four elements at some point:\n-  \/\/\n-  \/\/                  Top\n-  \/\/    Flat in Array     Not Flat in Array\n-  \/\/          Maybe Flat in Array\n-  \/\/\n-  \/\/ where\n-  \/\/     Top = dual(maybe Flat In Array) = \"Flat in Array AND Not Flat in Array\"\n-  \/\/\n-  \/\/ But for now we stick with the current model with _flat_in_array as a boolean.\n-  \/\/\n-  \/\/ When meeting two InstPtr types, we want to have the following behavior:\n-  \/\/\n-  \/\/ (FiA-M) Meet(this, other):\n-  \/\/     'this' and 'other' are either the same klass OR sub klasses:\n-  \/\/\n-  \/\/                yes maybe no\n-  \/\/           yes   y    m    m                      y = Flat in Array\n-  \/\/         maybe   m    m    m                      n = Not Flat in Array\n-  \/\/            no   m    m    n                      m = Maybe Flat in Array\n-  \/\/\n-  \/\/  Join(this, other):\n-  \/\/     (FiA-J-Same) 'this' and 'other' are the SAME klass:\n-  \/\/\n-  \/\/                yes maybe no                      E = Empty set\n-  \/\/           yes   y    y    E                      y = Flat in Array\n-  \/\/         maybe   y    m    m                      n = Not Flat in Array\n-  \/\/            no   E    m    n                      m = Maybe Flat in Array\n-  \/\/\n-  \/\/     (FiA-J-Sub) 'this' and 'other' are SUB klasses:\n-  \/\/\n-  \/\/               yes maybe no   -> Super Klass      E = Empty set\n-  \/\/          yes   y    y    y                       y = Flat in Array\n-  \/\/        maybe   y    m    m                       n = Not Flat in Array\n-  \/\/           no   E    m    n                       m = Maybe Flat in Array\n-  \/\/           |\n-  \/\/           v\n-  \/\/       Sub Klass\n-  \/\/\n-  \/\/     Note the difference when joining a super klass that is not flat in array with a sub klass that is compared to\n-  \/\/     the same klass case. We will take over the flat in array property of the sub klass. This can be done because\n-  \/\/     the super klass could be Object (i.e. not an inline type and thus not flat in array) while the sub klass is a\n-  \/\/     value class which can be flat in array.\n-  \/\/\n-  \/\/     The empty set is only a possible result when matching 'ptr' above the center line (i.e. joining). In this case,\n-  \/\/     we can \"fall hard\" by setting 'ptr' to NotNull such that when we take the dual of that meet above the center\n-  \/\/     line, we get an empty set again.\n-  \/\/\n-  \/\/     Note: When changing to a separate lattice with _flat_in_array we may want to add TypeInst(Klass)Ptr::empty()\n-  \/\/           that returns true when the meet result is FlatInArray::Top (i.e. dual(maybe flat in array)).\n-\n@@ -4630,2 +4639,0 @@\n-  bool flat_in_array = false;\n-  bool is_empty = false;\n@@ -4636,6 +4643,1 @@\n-    if (above_centerline(ptr)) {\n-      \/\/ Case (FiA-J-Same)\n-      \/\/ One is flat in array and the other not? Result is empty\/\"fall hard\".\n-      is_empty = (this_flat_in_array && other_not_flat_in_array) || (this_not_flat_in_array && other_flat_in_array);\n-    }\n-  } else if (!other_xk && is_meet_subtype_of(this_type, other_type)) {\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n@@ -4644,9 +4646,1 @@\n-    if (above_centerline(ptr)) {\n-      \/\/ Case (FiA-J-Sub)\n-      is_empty = this_not_flat_in_array && other_flat_in_array;\n-      if (!is_empty) {\n-        bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n-        flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n-      }\n-    }\n-  } else if (!this_xk && is_meet_subtype_of(other_type, this_type)) {\n+  } else if (!this_xk && other_type->is_meet_subtype_of(this_type)) {\n@@ -4655,8 +4649,0 @@\n-    if (above_centerline(ptr)) {\n-      \/\/ Case (FiA-J-Sub)\n-      is_empty = this_flat_in_array && other_not_flat_in_array;\n-      if (!is_empty) {\n-        bool this_flat_other_maybe_flat = this_flat_in_array && (!other_flat_in_array && !other_not_flat_in_array);\n-        flat_in_array = other_flat_in_array || this_flat_other_maybe_flat;\n-      }\n-    }\n@@ -4665,2 +4651,1 @@\n-\n-  if (subtype && !is_empty) {\n+  if (subtype != nullptr) {\n@@ -4671,5 +4656,0 @@\n-      \/\/ Case (FiA-J-Sub)\n-      bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n-      flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n-      \/\/ One is flat in array and the other not? Result is empty\/\"fall hard\".\n-      is_empty = (this_flat_in_array && other_not_flat_in_array) || (this_not_flat_in_array && other_flat_in_array);\n@@ -4680,1 +4660,0 @@\n-      flat_in_array = other_flat_in_array;\n@@ -4684,1 +4663,0 @@\n-      flat_in_array = this_flat_in_array;\n@@ -4688,3 +4666,0 @@\n-      \/\/ Case (FiA-M)\n-      \/\/ Meeting two types below the center line: Only flat in array if both are.\n-      flat_in_array = this_flat_in_array && other_flat_in_array;\n@@ -4695,1 +4670,1 @@\n-  if (this_type->is_same_java_type_as(other_type) && !is_empty) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4701,1 +4676,0 @@\n-    res_flat_in_array = flat_in_array;\n@@ -4718,2 +4692,0 @@\n-  res_flat_in_array = this_flat_in_array && other_flat_in_array;\n-\n@@ -4723,2 +4695,32 @@\n-template<class T> bool TypePtr::is_meet_subtype_of(const T* sub_type, const T* super_type) {\n-  return sub_type->is_meet_subtype_of(super_type) && !(super_type->flat_in_array() && sub_type->not_flat_in_array());\n+\/\/                Top-Flat    Flat        Not-Flat    Maybe-Flat\n+\/\/ -------------------------------------------------------------\n+\/\/    Top-Flat    Top-Flat    Flat        Not-Flat    Maybe-Flat\n+\/\/        Flat    Flat        Flat        Maybe-Flat  Maybe-Flat\n+\/\/    Not-Flat    Not-Flat    Maybe-Flat  Not-Flat    Maybe-Flat\n+\/\/  Maybe-Flat    Maybe-Flat  Maybe-Flat  Maybe-Flat  Maybe-flat\n+TypePtr::FlatInArray TypePtr::meet_flat_in_array(const FlatInArray left, const FlatInArray right) {\n+  if (left == TopFlat) {\n+    return right;\n+  }\n+  if (right == TopFlat) {\n+    return left;\n+  }\n+  if (left == MaybeFlat || right == MaybeFlat) {\n+    return MaybeFlat;\n+  }\n+\n+  switch (left) {\n+    case Flat:\n+      if (right == Flat) {\n+        return Flat;\n+      }\n+      return MaybeFlat;\n+    case NotFlat:\n+      if (right == NotFlat) {\n+        return NotFlat;\n+      }\n+      return MaybeFlat;\n+    default:\n+      ShouldNotReachHere();\n+      return Uninitialized;\n+  }\n@@ -4741,2 +4743,3 @@\n-const Type *TypeInstPtr::xdual() const {\n-  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), flat_in_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+const Type* TypeInstPtr::xdual() const {\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(),\n+                         dual_flat_in_array(_flat_in_array), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4751,1 +4754,1 @@\n-    flat_in_array() == p->flat_in_array() &&\n+    _flat_in_array == p->_flat_in_array &&\n@@ -4758,2 +4761,2 @@\n-uint TypeInstPtr::hash(void) const {\n-  return klass()->hash() + TypeOopPtr::hash() + _interfaces->hash() + (uint)flat_in_array();\n+uint TypeInstPtr::hash() const {\n+  return klass()->hash() + TypeOopPtr::hash() + _interfaces->hash() + static_cast<uint>(_flat_in_array);\n@@ -4817,3 +4820,1 @@\n-  if (flat_in_array() && !klass()->is_inlinetype()) {\n-    st->print(\" (flat in array)\");\n-  }\n+  dump_flat_in_array(_flat_in_array, st);\n@@ -4831,0 +4832,7 @@\n+bool TypeInstPtr::empty() const {\n+  if (_flat_in_array == TopFlat) {\n+    return true;\n+  }\n+  return TypeOopPtr::empty();\n+}\n+\n@@ -4833,1 +4841,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset), flat_in_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset), _flat_in_array,\n@@ -4838,1 +4846,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), Offset(offset), flat_in_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), Offset(offset), _flat_in_array,\n@@ -4847,1 +4855,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_in_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _flat_in_array,\n@@ -4852,1 +4860,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_in_array(), _instance_id, speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _flat_in_array, _instance_id, speculative, _inline_depth);\n@@ -4859,1 +4867,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_in_array(), _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _flat_in_array, _instance_id, _speculative, depth);\n@@ -4864,1 +4872,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_in_array(), instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _flat_in_array, instance_id, _speculative, _inline_depth);\n@@ -4868,1 +4876,5 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, Flat, _instance_id, _speculative, _inline_depth);\n+}\n+\n+const TypeInstPtr *TypeInstPtr::cast_to_maybe_flat_in_array() const {\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, MaybeFlat, _instance_id, _speculative, _inline_depth);\n@@ -4882,1 +4894,2 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, Offset(0), flat_in_array());\n+  FlatInArray flat_in_array = compute_flat_in_array_if_unknown(ik, xk, _flat_in_array);\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, Offset(0), flat_in_array);\n@@ -5359,1 +5372,13 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flat_in_array()) {\n+      \/\/\n+      \/\/ Flat in array:\n+      \/\/ We do\n+      \/\/   dual(TypeAryPtr) MEET dual(TypeInstPtr)\n+      \/\/ If TypeInstPtr is anything else than Object, then the result of the meet is bottom Object (i.e. we could have\n+      \/\/ instances or arrays).\n+      \/\/ If TypeInstPtr is an Object and either\n+      \/\/ - exact\n+      \/\/ - inexact AND flat in array == dual(not flat in array) (i.e. not an array type)\n+      \/\/ then the result of the meet is bottom Object (i.e. we could have instances or arrays).\n+      \/\/ Otherwise, we meet two array pointers and create a new TypeAryPtr.\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) &&\n+          !tp->klass_is_exact() && !tp->is_not_flat_in_array()) {\n@@ -5366,1 +5391,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset, false, instance_id, speculative, depth);\n+        FlatInArray flat_in_array = meet_flat_in_array(NotFlat, tp->flat_in_array());\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset, flat_in_array, instance_id, speculative, depth);\n@@ -5370,1 +5396,1 @@\n-    case BotPTR:                \/\/ Fall down to object klass\n+    case BotPTR: { \/\/ Fall down to object klass\n@@ -5378,1 +5404,4 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flat_in_array()) {\n+        \/\/\n+        \/\/ Flat in array: We do TypeAryPtr MEET dual(TypeInstPtr), same applies as above in TopPTR\/AnyNull case.\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) &&\n+            !tp->klass_is_exact() && !tp->is_not_flat_in_array()) {\n@@ -5387,1 +5416,1 @@\n-         ptr = NotNull;\n+        ptr = NotNull;\n@@ -5392,0 +5421,2 @@\n+\n+      FlatInArray flat_in_array = meet_flat_in_array(NotFlat, tp->flat_in_array());\n@@ -5393,1 +5424,3 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset, false, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset,\n+                               flat_in_array, instance_id, speculative, depth);\n+    }\n@@ -6217,3 +6250,1 @@\n-  if (Verbose) {\n-    if (isa_instklassptr() && is_instklassptr()->flat_in_array()) st->print(\":flat in array\");\n-  }\n+\n@@ -6222,4 +6253,0 @@\n-\n-  if (flat_in_array() && !klass()->is_inlinetype()) {\n-    st->print(\" (flat in array)\");\n-  }\n@@ -6237,1 +6264,1 @@\n-  const TypeKlassPtr *p = t->is_klassptr();\n+  const TypeInstKlassPtr* p = t->is_instklassptr();\n@@ -6240,1 +6267,1 @@\n-    flat_in_array() == p->flat_in_array() &&\n+    _flat_in_array == p->_flat_in_array &&\n@@ -6245,1 +6272,1 @@\n-  return klass()->hash() + TypeKlassPtr::hash() + (uint)flat_in_array();\n+  return klass()->hash() + TypeKlassPtr::hash() + (uint)_flat_in_array;\n@@ -6248,3 +6275,4 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, Offset offset, bool flat_in_array) {\n-  flat_in_array = flat_in_array || k->maybe_flat_in_array();\n-\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, Offset offset, FlatInArray flat_in_array) {\n+  if (flat_in_array == Uninitialized) {\n+    flat_in_array = compute_flat_in_array(k->as_instance_klass(), ptr == Constant);\n+  }\n@@ -6257,0 +6285,7 @@\n+bool TypeInstKlassPtr::empty() const {\n+  if (_flat_in_array == TopFlat) {\n+    return true;\n+  }\n+  return TypeKlassPtr::empty();\n+}\n+\n@@ -6260,1 +6295,1 @@\n-  return make(_ptr, klass(), _interfaces, xadd_offset(offset), flat_in_array());\n+  return make(_ptr, klass(), _interfaces, xadd_offset(offset), _flat_in_array);\n@@ -6264,1 +6299,1 @@\n-  return make(_ptr, klass(), _interfaces, Offset(offset), flat_in_array());\n+  return make(_ptr, klass(), _interfaces, Offset(offset), _flat_in_array);\n@@ -6271,1 +6306,1 @@\n-  return make(ptr, _klass, _interfaces, _offset, flat_in_array());\n+  return make(ptr, _klass, _interfaces, _offset, _flat_in_array);\n@@ -6287,1 +6322,2 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset, flat_in_array());\n+  FlatInArray flat_in_array = compute_flat_in_array(k->as_instance_klass(), klass_is_exact);\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset, flat_in_array);\n@@ -6303,0 +6339,1 @@\n+  ciInstanceKlass* ik = k->as_instance_klass();\n@@ -6305,1 +6342,0 @@\n-    ciInstanceKlass* ik = k->as_instance_klass();\n@@ -6319,1 +6355,3 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, nullptr, Offset(0), flat_in_array() && !klass()->is_inlinetype());\n+\n+  FlatInArray flat_in_array = compute_flat_in_array_if_unknown(ik, xk, _flat_in_array);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, nullptr, Offset(0), flat_in_array);\n@@ -6363,1 +6401,1 @@\n-      return make(ptr, klass(), _interfaces, offset, flat_in_array());\n+      return make(ptr, klass(), _interfaces, offset, _flat_in_array);\n@@ -6402,2 +6440,2 @@\n-    bool res_flat_in_array = false;\n-    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk, res_flat_in_array)) {\n+    const FlatInArray flat_in_array = meet_flat_in_array(_flat_in_array, tkls->flat_in_array());\n+    switch (meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n@@ -6411,1 +6449,1 @@\n-        const Type* res = make(ptr, res_klass, interfaces, off, res_flat_in_array);\n+        const Type* res = make(ptr, res_klass, interfaces, off, flat_in_array);\n@@ -6432,1 +6470,4 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) && !klass_is_exact()) {\n+      \/\/\n+      \/\/ Flat in array: See explanation for meet with TypeInstPtr in TypeAryPtr::xmeet_helper().\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) &&\n+          !klass_is_exact() && !is_not_flat_in_array()) {\n@@ -6438,1 +6479,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n+        FlatInArray flat_in_array = meet_flat_in_array(_flat_in_array, NotFlat);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, flat_in_array);\n@@ -6442,1 +6484,1 @@\n-    case BotPTR:                \/\/ Fall down to object klass\n+    case BotPTR: { \/\/ Fall down to object klass\n@@ -6450,1 +6492,4 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) && !klass_is_exact()) {\n+        \/\/\n+        \/\/ Flat in array: See explanation for meet with TypeInstPtr in TypeAryPtr::xmeet_helper().\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) &&\n+            !klass_is_exact() && !is_not_flat_in_array()) {\n@@ -6458,1 +6503,1 @@\n-         ptr = NotNull;\n+        ptr = NotNull;\n@@ -6460,1 +6505,3 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n+      FlatInArray flat_in_array = meet_flat_in_array(_flat_in_array, NotFlat);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, flat_in_array);\n+    }\n@@ -6472,1 +6519,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset(), flat_in_array());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset(), dual_flat_in_array(_flat_in_array));\n@@ -6981,0 +7028,2 @@\n+      \/\/\n+      \/\/ Flat in array: See explanation for meet with TypeInstPtr in TypeAryPtr::xmeet_helper().\n@@ -6982,1 +7031,1 @@\n-          !tp->klass_is_exact()) {\n+          !tp->klass_is_exact() && !tp->is_not_flat_in_array()) {\n@@ -6988,1 +7037,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n+        FlatInArray flat_in_array = meet_flat_in_array(NotFlat, tp->flat_in_array());\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, flat_in_array);\n@@ -6992,1 +7042,1 @@\n-    case BotPTR:                \/\/ Fall down to object klass\n+    case BotPTR: { \/\/ Fall down to object klass\n@@ -7000,0 +7050,2 @@\n+        \/\/\n+        \/\/ Flat in array: See explanation for meet with TypeInstPtr in TypeAryPtr::xmeet_helper().\n@@ -7001,1 +7053,1 @@\n-            !tp->klass_is_exact()) {\n+            !tp->klass_is_exact() && !tp->is_not_flat_in_array()) {\n@@ -7009,1 +7061,1 @@\n-         ptr = NotNull;\n+        ptr = NotNull;\n@@ -7011,1 +7063,3 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n+      FlatInArray flat_in_array = meet_flat_in_array(NotFlat, tp->flat_in_array());\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, tp->flat_in_array());\n+    }\n@@ -7180,0 +7234,7 @@\n+void TypeInstKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+  klass()->print_name_on(st);\n+  _interfaces->dump(st);\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  dump_flat_in_array(_flat_in_array, st);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":246,"deletions":185,"binary":false,"changes":431,"status":"modified"},{"patch":"@@ -1181,0 +1181,19 @@\n+\n+  \/\/ Only applies to TypeInstPtr and TypeInstKlassPtr. Since the common super class is TypePtr, it is defined here.\n+  \/\/\n+  \/\/ FlatInArray defines the following Boolean Lattice structure\n+  \/\/\n+  \/\/     TopFlat\n+  \/\/    \/      \\\n+  \/\/  Flat   NotFlat\n+  \/\/    \\      \/\n+  \/\/   MaybeFlat\n+  \/\/\n+  \/\/ with meet (see TypePtr::meet_flat_in_array()) and join (implemented over dual, see TypePtr::flat_in_array_dual)\n+  enum FlatInArray {\n+    TopFlat,        \/\/ Dedicated top element and dual of MaybeFlat. Result when joining Flat and NotFlat.\n+    Flat,           \/\/ An instance is always flat in an array.\n+    NotFlat,        \/\/ An instance is never flat in an array.\n+    MaybeFlat,      \/\/ We don't know whether an instance is flat in an array.\n+    Uninitialized   \/\/ Used when the flat in array property was not computed, yet - should never actually end up in a type.\n+  };\n@@ -1191,0 +1210,3 @@\n+  static const FlatInArray flat_in_array_dual[Uninitialized];\n+  static const char* const flat_in_array_msg[Uninitialized];\n+\n@@ -1238,3 +1260,1 @@\n-                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk, bool& res_flat_array);\n- private:\n-  template<class T> static bool is_meet_subtype_of(const T* sub_type, const T* super_type);\n+                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n@@ -1242,0 +1262,1 @@\n+  static FlatInArray meet_flat_in_array(FlatInArray left, FlatInArray other);\n@@ -1310,0 +1331,9 @@\n+  static FlatInArray dual_flat_in_array(FlatInArray flat_in_array) {\n+    return flat_in_array_dual[flat_in_array];\n+  }\n+  NOT_PRODUCT(static void dump_flat_in_array(FlatInArray flat_in_array, outputStream* st);)\n+\n+  static FlatInArray compute_flat_in_array(ciInstanceKlass* instance_klass, bool is_exact);\n+  FlatInArray compute_flat_in_array_if_unknown(ciInstanceKlass* instance_klass, bool is_exact,\n+                                               FlatInArray old_flat_in_array) const;\n+\n@@ -1311,2 +1341,3 @@\n-  virtual bool flat_in_array()      const { return false; }\n-  virtual bool not_flat_in_array()  const { return true; }\n+  virtual bool is_flat_in_array()     const { return flat_in_array() == Flat; }\n+  virtual bool is_not_flat_in_array() const { return flat_in_array() == NotFlat; }\n+  virtual FlatInArray flat_in_array() const { return NotFlat; }\n@@ -1547,0 +1578,3 @@\n+  \/\/ Can this instance be in a flat array?\n+  FlatInArray _flat_in_array;\n+\n@@ -1548,1 +1582,1 @@\n-              bool flat_in_array, int instance_id, const TypePtr* speculative,\n+              FlatInArray flat_in_array, int instance_id, const TypePtr* speculative,\n@@ -1552,1 +1586,0 @@\n-  bool _flat_in_array; \/\/ Type is flat in arrays\n@@ -1600,1 +1633,1 @@\n-                                 bool flat_in_array = false,\n+                                 FlatInArray flat_in_array = Uninitialized,\n@@ -1605,1 +1638,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, int instance_id = InstanceBot) {\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, int instance_id = InstanceBot,\n+                                 FlatInArray flat_in_array = Uninitialized) {\n@@ -1607,1 +1641,1 @@\n-    return make(ptr, k, interfaces, xk, o, offset, false, instance_id);\n+    return make(ptr, k, interfaces, xk, o, offset, flat_in_array, instance_id);\n@@ -1624,0 +1658,1 @@\n+  virtual bool empty() const;\n@@ -1634,2 +1669,2 @@\n-  virtual bool flat_in_array() const { return _flat_in_array; }\n-  virtual bool not_flat_in_array() const { return !can_be_inline_type() || (_klass->is_inlinetype() && !flat_in_array()); }\n+  virtual const TypeInstPtr* cast_to_maybe_flat_in_array() const;\n+  virtual FlatInArray flat_in_array() const { return _flat_in_array; }\n@@ -1934,4 +1969,0 @@\n-  virtual bool not_flat_in_array_inexact() const {\n-    return true;\n-  }\n-\n@@ -1971,0 +2002,2 @@\n+  \/\/ Can an instance of this class be in a flat array?\n+  const FlatInArray _flat_in_array;\n@@ -1972,1 +2005,1 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const TypeInterfaces* interfaces, Offset offset, bool flat_in_array)\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const TypeInterfaces* interfaces, Offset offset, FlatInArray flat_in_array)\n@@ -1974,0 +2007,1 @@\n+    assert(flat_in_array != Uninitialized, \"must be set now\");\n@@ -1979,2 +2013,0 @@\n-  const bool _flat_in_array; \/\/ Type is flat in arrays\n-\n@@ -2000,1 +2032,0 @@\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, Offset offset, bool flat_in_array = false);\n@@ -2002,1 +2033,4 @@\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, Offset offset) {\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, Offset offset,\n+                                      FlatInArray flat_in_array = Uninitialized);\n+\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, FlatInArray flat_in_array = Uninitialized) {\n@@ -2004,1 +2038,1 @@\n-    return make(ptr, k, interfaces, offset);\n+    return make(ptr, k, interfaces, offset, flat_in_array);\n@@ -2016,0 +2050,2 @@\n+\n+  virtual bool empty() const;\n@@ -2023,18 +2059,1 @@\n-  virtual bool flat_in_array() const { return _flat_in_array; }\n-\n-  \/\/ Checks if this klass pointer is not flat in array by also considering exactness information.\n-  virtual bool not_flat_in_array() const {\n-    return !_klass->can_be_inline_klass(klass_is_exact()) || (_klass->is_inlinetype() && !flat_in_array());\n-  }\n-\n-  \/\/ not_flat_in_array() version that assumes that the klass is inexact. This is used for sub type checks where the\n-  \/\/ super klass is always an exact klass constant (and thus possibly known to be not flat in array), while a sub\n-  \/\/ klass could very well be flat in array:\n-  \/\/\n-  \/\/           MyValue       <:       Object\n-  \/\/        flat in array       not flat in array\n-  \/\/\n-  \/\/ Thus, this version checks if we know that the klass is not flat in array even if it's not exact.\n-  virtual bool not_flat_in_array_inexact() const {\n-    return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flat_in_array());\n-  }\n+  virtual FlatInArray flat_in_array() const { return _flat_in_array; }\n@@ -2049,0 +2068,2 @@\n+\n+  NOT_PRODUCT(virtual void dump2(Dict& d, uint depth, outputStream* st) const;) \/\/ Specialized per-Type dumping\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":61,"deletions":40,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+            \/\/ Pre-8332406:\n@@ -225,0 +226,5 @@\n+            \/\/\n+            \/\/ Post-8332406:\n+            \/\/ We now directly cast the klass pointer in SubTypeCheckNode::sub() to inexact which triggers a\n+            \/\/ recomputation of the flat in array property. This will turn an exact TypeInstKlassPtr such as Object,\n+            \/\/ which is not flat in array, into an inexact maybe flat in array TypeInstKlassPtr.\n@@ -317,0 +323,11 @@\n+\n+    @Test\n+    public static Object test8332406(boolean b, Object[] array, int i) {\n+        return b ? array[i] : OBJ;\n+    }\n+\n+    @Run(test = \"test8332406\")\n+    public static void runTest8332406() {\n+        test8332406(true, new Object[1], 0);\n+        test8332406(false, new Object[1], 0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}