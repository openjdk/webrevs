{"files":[{"patch":"@@ -120,3 +120,0 @@\n-          if (vk->is_naturally_atomic()) {\n-            atomic = vk->has_atomic_layout();\n-          }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,0 +254,5 @@\n+  GUARDED_VM_ENTRY(\n+    if (is_flat_array_klass()) {\n+      st->print(\" layout_kind=%d\", (int)((FlatArrayKlass*)get_Klass())->layout_kind());\n+    }\n+  )\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1230,1 +1230,1 @@\n-Node* GraphKit::load_object_klass(Node* obj) {\n+Node* GraphKit::load_object_klass(Node* obj, bool fold_for_arrays) {\n@@ -1235,1 +1235,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT, fold_for_arrays));\n@@ -3790,1 +3790,2 @@\n-  Node* array_klass = load_object_klass(array);\n+  \/\/ TODO 8350865 Don't fold this klass load because atomicity is currently not included in the typesystem\n+  Node* array_klass = load_object_klass(array, \/* fold_for_arrays = *\/ false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-  Node* load_object_klass(Node* object);\n+  Node* load_object_klass(Node* object, bool fold_for_arrays = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1305,0 +1305,1 @@\n+  bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n@@ -1307,1 +1308,0 @@\n-    bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n@@ -1345,3 +1345,0 @@\n-      kit->set_control(kit->IfFalse(iff));\n-      region->init_req(1, kit->control());\n-\n@@ -1349,0 +1346,1 @@\n+      kit->set_control(kit->IfFalse(iff));\n@@ -1351,1 +1349,4 @@\n-        Node* load = kit->access_load_at(obj, ptr, TypeRawPtr::BOTTOM, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n+\n+        Node* cast = obj;\n+        Node* adr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ false, \/* not_null_free *\/ true, \/* atomic *\/ true);\n+        Node* load = kit->access_load_at(cast, adr, TypeRawPtr::BOTTOM, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n@@ -1356,2 +1357,1 @@\n-\n-      kit->set_control(kit->IfTrue(iff));\n+      region->init_req(1, kit->control());\n@@ -1360,0 +1360,1 @@\n+      kit->set_control(kit->IfTrue(iff));\n@@ -1449,1 +1450,0 @@\n-    bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4602,1 +4602,1 @@\n-          const TypeAryKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces)->is_aryklassptr();\n+          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -5668,0 +5668,1 @@\n+    \/\/ TODO 8350865 For arrays, this might be folded and then not account for atomic arrays\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2622,1 +2622,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, bool fold_for_arrays) {\n@@ -2629,1 +2629,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered, fold_for_arrays));\n@@ -2634,1 +2634,1 @@\n-  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered, fold_for_arrays);\n@@ -2639,1 +2639,1 @@\n-  return klass_value_common(phase);\n+  return klass_value_common(phase, _fold_for_arrays);\n@@ -2642,1 +2642,1 @@\n-const Type* LoadNode::klass_value_common(PhaseGVN* phase) const {\n+const Type* LoadNode::klass_value_common(PhaseGVN* phase, bool fold_for_arrays) const {\n@@ -2702,1 +2702,1 @@\n-  if (tary != nullptr &&\n+  if (tary != nullptr && fold_for_arrays &&\n@@ -2817,1 +2817,1 @@\n-  const Type *t = klass_value_common(phase);\n+  const Type *t = klass_value_common(phase, _fold_for_arrays);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-  const Type* klass_value_common(PhaseGVN* phase) const;\n+  const Type* klass_value_common(PhaseGVN* phase, bool fold_for_arrays) const;\n@@ -530,0 +530,8 @@\n+  bool _fold_for_arrays;\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual uint hash() const { return LoadNode::hash() + _fold_for_arrays; }\n+  virtual bool cmp( const Node &n ) const {\n+    return _fold_for_arrays == ((LoadKlassNode&)n)._fold_for_arrays && LoadNode::cmp(n);\n+  }\n+\n@@ -531,2 +539,2 @@\n-  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo)\n-    : LoadPNode(nullptr, mem, adr, at, tk, mo) {}\n+  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo, bool fold_for_arrays)\n+    : LoadPNode(nullptr, mem, adr, at, tk, mo), _fold_for_arrays(fold_for_arrays) {}\n@@ -542,1 +550,1 @@\n-                    const TypeKlassPtr* tk = TypeInstKlassPtr::OBJECT);\n+                    const TypeKlassPtr* tk = TypeInstKlassPtr::OBJECT, bool fold_for_arrays = true);\n@@ -554,0 +562,8 @@\n+  bool _fold_for_arrays;\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual uint hash() const { return LoadNode::hash() + _fold_for_arrays; }\n+  virtual bool cmp( const Node &n ) const {\n+    return _fold_for_arrays == ((LoadNKlassNode&)n)._fold_for_arrays && LoadNode::cmp(n);\n+  }\n+\n@@ -555,3 +571,3 @@\n-  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*);\n-  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo)\n-    : LoadNNode(nullptr, mem, adr, at, tk, mo) {}\n+  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*, bool fold_for_arrays);\n+  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo, bool fold_for_arrays)\n+    : LoadNNode(nullptr, mem, adr, at, tk, mo), _fold_for_arrays(fold_for_arrays) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -5194,3 +5194,0 @@\n-  if (k != nullptr && k->is_flat_array_klass() && !ary->_flat) {\n-    k = nullptr;\n-  }\n@@ -5213,3 +5210,0 @@\n-  if (k != nullptr && k->is_flat_array_klass() && !ary->_flat) {\n-    k = nullptr;\n-  }\n@@ -6807,1 +6801,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free);\n@@ -6923,3 +6917,1 @@\n-    \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n-    bool atomic = k->is_inlinetype() && (is_null_free() ? k->as_inline_klass()->has_atomic_layout() : k->as_inline_klass()->has_nullable_atomic_layout());\n-    k = ciArrayKlass::make(k, is_flat(), is_null_free(), atomic);\n+    k = ciArrayKlass::make(k, is_flat(), is_null_free());\n@@ -7323,3 +7315,6 @@\n-    \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n-    bool atomic = k->is_inlinetype() && (is_null_free() ? k->as_inline_klass()->has_atomic_layout() : k->as_inline_klass()->has_nullable_atomic_layout());\n-    k = ciArrayKlass::make(k, is_flat(), is_null_free(), atomic);\n+    \/\/ TODO 8350865 LibraryCallKit::inline_newArray passes a constant TypeAryKlassPtr to GraphKit::new_array\n+    \/\/ As long as atomicity is not tracked by TypeAryKlassPtr, don't re-compute it here to avoid loosing atomicity information\n+    if (k->is_inlinetype() && _klass != nullptr) {\n+      return _klass;\n+    }\n+    k = ciArrayKlass::make(k, is_flat(), is_null_free());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.debug == true\n@@ -103,0 +104,1 @@\n+            oa.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayAccessDeopt.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -297,0 +297,1 @@\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -313,0 +314,1 @@\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -325,0 +327,1 @@\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -339,0 +342,1 @@\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -351,0 +355,1 @@\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n@@ -363,0 +368,1 @@\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n@@ -375,0 +381,1 @@\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n@@ -387,0 +394,1 @@\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n@@ -399,0 +407,1 @@\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullableAtomicArray));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+    \/\/ Final arrays\n@@ -143,0 +144,24 @@\n+    \/\/ Non-final arrays\n+    static MyValue[] array4 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+    static MyValue[] array5 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+    static {\n+        array5[0] = new MyValue((short)0, (short)0);\n+    }\n+    static MyValue[] array6 = new MyValue[] { new MyValue((short)0, (short)0) };\n+\n+    \/\/ Object arrays\n+    static Object[] array7 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+    static Object[] array8 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+    static {\n+        array8[0] = new MyValue((short)0, (short)0);\n+    }\n+    static Object[] array9 = new MyValue[] { new MyValue((short)0, (short)0) };\n+\n+    \/\/ Object arrays stored in volatile fields (for safe publication)\n+    static volatile Object[] array10 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+    static volatile Object[] array11 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+    static {\n+        array11[0] = new MyValue((short)0, (short)0);\n+    }\n+    static volatile Object[] array12 = new MyValue[] { new MyValue((short)0, (short)0) };\n+\n@@ -167,0 +192,22 @@\n+                \/\/ Create \"local\" arrays so that C2 has full type info\n+                MyValue[] localArray1 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+                MyValue[] localArray2 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+                localArray2[0] = new MyValue((short)0, (short)0);\n+                MyValue[] localArray3 = new MyValue[] { new MyValue((short)0, (short)0) };\n+\n+                Asserts.assertTrue(ValueClass.isAtomicArray(localArray1));\n+                Asserts.assertTrue(ValueClass.isAtomicArray(localArray2));\n+                Asserts.assertTrue(ValueClass.isAtomicArray(localArray3));\n+                Asserts.assertTrue(ValueClass.isNullRestrictedArray(localArray1));\n+                Asserts.assertFalse(ValueClass.isNullRestrictedArray(localArray2));\n+                Asserts.assertFalse(ValueClass.isNullRestrictedArray(localArray3));\n+\n+                \/\/ Let them escape safely via a volatile field\n+                array10 = localArray1;\n+                array11 = localArray2;\n+                array12 = localArray3;\n+\n+                localArray1[0] = localArray1[0].incrementAndCheck();\n+                localArray2[0] = localArray2[0].incrementAndCheck();\n+                localArray3[0] = localArray3[0].incrementAndCheck();\n+\n@@ -174,0 +221,9 @@\n+                array4[0] = array4[0].incrementAndCheck();\n+                array5[0] = array5[0].incrementAndCheck();\n+                array6[0] = array6[0].incrementAndCheck();\n+                array7[0] = ((MyValue)array7[0]).incrementAndCheck();\n+                array8[0] = ((MyValue)array8[0]).incrementAndCheck();\n+                array9[0] = ((MyValue)array9[0]).incrementAndCheck();\n+                array10[0] = ((MyValue)array10[0]).incrementAndCheck();\n+                array11[0] = ((MyValue)array11[0]).incrementAndCheck();\n+                array12[0] = ((MyValue)array12[0]).incrementAndCheck();\n@@ -182,0 +238,9 @@\n+                array4[0] = array4[0].incrementAndCheckUnsafe();\n+                array5[0] = array5[0].incrementAndCheckUnsafe();\n+                array6[0] = array6[0].incrementAndCheckUnsafe();\n+                array7[0] = ((MyValue)array7[0]).incrementAndCheckUnsafe();\n+                array8[0] = ((MyValue)array8[0]).incrementAndCheckUnsafe();\n+                array9[0] = ((MyValue)array9[0]).incrementAndCheckUnsafe();\n+                array10[0] = ((MyValue)array10[0]).incrementAndCheckUnsafe();\n+                array11[0] = ((MyValue)array11[0]).incrementAndCheckUnsafe();\n+                array12[0] = ((MyValue)array12[0]).incrementAndCheckUnsafe();\n@@ -191,0 +256,9 @@\n+                    array4[0] = (MyValue)incrementAndCheck_mh.invokeExact(array4[0]);\n+                    array5[0] = (MyValue)incrementAndCheck_mh.invokeExact(array5[0]);\n+                    array6[0] = (MyValue)incrementAndCheck_mh.invokeExact(array6[0]);\n+                    array7[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array7[0]);\n+                    array8[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array8[0]);\n+                    array9[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array9[0]);\n+                    array10[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array10[0]);\n+                    array11[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array11[0]);\n+                    array12[0] = (MyValue)incrementAndCheck_mh.invokeExact((MyValue)array12[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array0)));\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(array0));\n@@ -74,1 +74,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array1)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array1));\n@@ -79,1 +79,1 @@\n-        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array2)));\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(array2));\n@@ -84,1 +84,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array3)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array3));\n@@ -89,1 +89,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array4)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array4));\n@@ -94,1 +94,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array5)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array5));\n@@ -99,1 +99,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array6)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array6));\n@@ -104,1 +104,1 @@\n-        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array7)));\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(array7));\n@@ -109,1 +109,1 @@\n-        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array8)));\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(array8));\n@@ -114,1 +114,1 @@\n- }\n\\ No newline at end of file\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ArrayQueryTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}