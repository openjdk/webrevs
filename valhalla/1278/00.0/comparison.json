{"files":[{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -719,1 +719,1 @@\n-        <li><a href=\"PATH_TO_SPECS\/index.html\">OTHER SPECIFICATIONS \\\n+        <li><a href=\"PATH_TO_SPECS\/index.html\">OTHER SPECIFICATIONS<\/a> \\\n","filename":"make\/Docs.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -875,0 +875,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n@@ -1514,0 +1515,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2740,4 +2740,1 @@\n-      \/* If we get an out-of-range offset it is a bug in the compiler,\n-         so we assert here. *\/\n-      assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), \"c2 compiler bug\");\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -3343,1 +3340,5 @@\n-      __ prfm(Address(base, disp), PSTL1KEEP);\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, 8, rscratch1);\n+      __ prfm(addr, PSTL1KEEP);\n@@ -3355,1 +3356,1 @@\n-  \/\/\/ mov envcodings\n+  \/\/ mov encodings\n@@ -4255,1 +4256,1 @@\n-operand immLoffset()\n+operand immLOffset()\n@@ -4257,1 +4258,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n+  predicate(n->get_long() >= -256 && n->get_long() <= 65520);\n@@ -5367,0 +5368,28 @@\n+operand indirectX2P(iRegL reg)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(CastX2P reg);\n+  op_cost(0);\n+  format %{ \"[$reg]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+operand indOffX2P(iRegL reg, immLOffset off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (CastX2P reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n@@ -5457,1 +5486,1 @@\n-operand indOffLN(iRegN reg, immLoffset off)\n+operand indOffLN(iRegN reg, immLOffset off)\n@@ -5690,0 +5719,11 @@\n+operand iRegL2P(iRegL reg) %{\n+\n+  op_cost(0);\n+\n+  match(CastX2P reg);\n+\n+  format %{ \"l2p($reg)\" %}\n+\n+  interface(REG_INTER)\n+%}\n+\n@@ -5706,1 +5746,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5709,1 +5749,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5712,1 +5752,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5715,1 +5755,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5720,1 +5760,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5737,0 +5777,1 @@\n+opclass iRegPorL2P(iRegP, iRegL2P);\n@@ -9852,1 +9893,1 @@\n-instruct addP_reg_reg(iRegPNoSp dst, iRegP src1, iRegL src2) %{\n+instruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n@@ -9867,1 +9908,1 @@\n-instruct addP_reg_reg_ext(iRegPNoSp dst, iRegP src1, iRegIorL2I src2) %{\n+instruct addP_reg_reg_ext(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2) %{\n@@ -9882,1 +9923,1 @@\n-instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegP src1, iRegL src2, immIScale scale) %{\n+instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegPorL2P src1, iRegL src2, immIScale scale) %{\n@@ -9897,1 +9938,1 @@\n-instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegP src1, iRegIorL2I src2, immIScale scale) %{\n+instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2, immIScale scale) %{\n@@ -9930,1 +9971,1 @@\n-instruct addP_reg_imm(iRegPNoSp dst, iRegP src1, immLAddSub src2) %{\n+instruct addP_reg_imm(iRegPNoSp dst, iRegPorL2P src1, immLAddSub src2) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":60,"deletions":19,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n- protected:\n-\n@@ -115,2 +113,0 @@\n-  \/\/ Helpers for runtime call arguments\/results\n-\n@@ -206,1 +202,1 @@\n-\/\/ Load float value from 'address'. The value is loaded onto the FPU register v0.\n+  \/\/ Load float value from 'address'. The value is loaded onto the FPU register v0.\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+    has_scoped_access(),\n@@ -581,0 +582,1 @@\n+, _has_scoped_access(method->is_scoped())\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  bool               _has_scoped_access; \/\/ For shared scope closure\n@@ -148,0 +149,1 @@\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n@@ -180,0 +182,1 @@\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3794,0 +3794,3 @@\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+  unsigned int _flags;                           \/\/ Flag bits\n@@ -307,1 +308,0 @@\n-  unsigned int _flags;                           \/\/ Flag bits\n@@ -427,0 +427,1 @@\n+  , _flags(0)\n@@ -431,1 +432,0 @@\n-  , _flags(0)\n@@ -1591,0 +1591,1 @@\n+  ArgsNonNullState _nonnull_state;\n@@ -1593,1 +1594,0 @@\n-  ArgsNonNullState _nonnull_state;\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-  , _fast_check(fast_check)\n@@ -307,0 +306,1 @@\n+  , _fast_check(fast_check)\n@@ -328,1 +328,0 @@\n-  , _fast_check(false)\n@@ -335,0 +334,1 @@\n+  , _fast_check(false)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-  Scale     _scale;\n+  Scale     _scale;\n@@ -539,1 +539,1 @@\n-     , _scale(times_1)\n+     , _scale(times_1)\n@@ -546,1 +546,1 @@\n-     , _scale(times_1)\n+     , _scale(times_1)\n@@ -553,1 +553,1 @@\n-     , _scale(times_1)\n+     , _scale(times_1)\n@@ -560,1 +560,1 @@\n-     , _scale(times_1)\n+     , _scale(times_1)\n@@ -567,1 +567,1 @@\n-     , _scale(scale)\n+     , _scale(scale)\n@@ -1571,1 +1571,0 @@\n-  bool          _fast_check;\n@@ -1578,0 +1577,1 @@\n+  bool          _fast_check;\n@@ -1697,1 +1697,0 @@\n-  BasicType _type;\n@@ -1704,0 +1703,1 @@\n+  BasicType _type;\n@@ -1713,1 +1713,0 @@\n-    , _type(type)\n@@ -1719,1 +1718,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n@@ -1728,1 +1728,0 @@\n-    , _type(type)\n@@ -1734,1 +1733,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n@@ -1745,1 +1745,0 @@\n-    , _type(type)\n@@ -1751,1 +1750,2 @@\n-    , _condition(lir_cond_unknown) {\n+    , _condition(lir_cond_unknown)\n+    , _type(type) {\n@@ -1761,1 +1761,0 @@\n-    , _type(T_ILLEGAL)\n@@ -1767,1 +1766,2 @@\n-    , _condition(lir_cond_unknown) {\n+    , _condition(lir_cond_unknown)\n+    , _type(T_ILLEGAL)    {\n@@ -1852,1 +1852,1 @@\n-  BasicType _type;\n+  BasicType _type;\n@@ -1866,1 +1866,1 @@\n-    , _type(type)\n+    , _type(type)\n@@ -1918,1 +1918,0 @@\n-  BasicType _type;\n@@ -1925,0 +1924,1 @@\n+  BasicType _type;\n@@ -1934,1 +1934,0 @@\n-    , _type(type)\n@@ -1940,1 +1939,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1323,1 +1323,1 @@\n-  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));\n+  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(nullptr));\n@@ -1366,1 +1366,1 @@\n-  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(0));\n+  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(nullptr));\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    _mapped_base_address = 0;\n+    _mapped_base_address = nullptr;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1041,0 +1041,1 @@\n+                            bool has_scoped_access,\n@@ -1133,0 +1134,1 @@\n+      nm->set_has_scoped_access(has_scoped_access);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+                       bool                      has_scoped_access,\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    MutexLocker locker(Compile_lock);\n+    bool should_take_Compile_lock = !Compile_lock->owned_by_self();\n+    ConditionalMutexLocker locker(Compile_lock, should_take_Compile_lock, Mutex::_safepoint_check_flag);\n@@ -1020,0 +1021,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::is_scoped\n+\/\/\n+\/\/ Return true for methods annotated with @Scoped\n+bool ciMethod::is_scoped() const {\n+   return get_Method()->is_scoped();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+  bool is_scoped() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n@@ -605,0 +606,1 @@\n+        _nesting.check(); \/\/ Check if a reallocation in the resource arena is safe\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1233,2 +1233,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -1237,2 +1235,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -1321,5 +1317,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -1345,5 +1336,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n-        }\n@@ -1362,1 +1348,1 @@\n-  AnnotationArray* a = assemble_annotations(runtime_visible_annotations,\n+  AnnotationArray* a = allocate_annotations(runtime_visible_annotations,\n@@ -1364,2 +1350,0 @@\n-                                            runtime_invisible_annotations,\n-                                            runtime_invisible_annotations_length,\n@@ -1368,1 +1352,1 @@\n-  a = assemble_annotations(runtime_visible_type_annotations,\n+  a = allocate_annotations(runtime_visible_type_annotations,\n@@ -1370,2 +1354,0 @@\n-                           runtime_invisible_type_annotations,\n-                           runtime_invisible_type_annotations_length,\n@@ -2258,2 +2240,0 @@\n-                                       const u1* runtime_invisible_annotations,\n-                                       int runtime_invisible_annotations_length,\n@@ -2262,2 +2242,0 @@\n-                                       const u1* runtime_invisible_parameter_annotations,\n-                                       int runtime_invisible_parameter_annotations_length,\n@@ -2266,2 +2244,0 @@\n-                                       const u1* runtime_invisible_type_annotations,\n-                                       int runtime_invisible_type_annotations_length,\n@@ -2274,3 +2250,2 @@\n-  if (runtime_visible_annotations_length +\n-      runtime_invisible_annotations_length > 0) {\n-     a = assemble_annotations(runtime_visible_annotations,\n+  if (runtime_visible_annotations_length > 0) {\n+     a = allocate_annotations(runtime_visible_annotations,\n@@ -2278,2 +2253,0 @@\n-                              runtime_invisible_annotations,\n-                              runtime_invisible_annotations_length,\n@@ -2284,3 +2257,2 @@\n-  if (runtime_visible_parameter_annotations_length +\n-      runtime_invisible_parameter_annotations_length > 0) {\n-    a = assemble_annotations(runtime_visible_parameter_annotations,\n+  if (runtime_visible_parameter_annotations_length > 0) {\n+    a = allocate_annotations(runtime_visible_parameter_annotations,\n@@ -2288,2 +2260,0 @@\n-                             runtime_invisible_parameter_annotations,\n-                             runtime_invisible_parameter_annotations_length,\n@@ -2295,1 +2265,1 @@\n-    a = assemble_annotations(annotation_default,\n+    a = allocate_annotations(annotation_default,\n@@ -2297,2 +2267,0 @@\n-                             nullptr,\n-                             0,\n@@ -2303,3 +2271,2 @@\n-  if (runtime_visible_type_annotations_length +\n-      runtime_invisible_type_annotations_length > 0) {\n-    a = assemble_annotations(runtime_visible_type_annotations,\n+  if (runtime_visible_type_annotations_length > 0) {\n+    a = allocate_annotations(runtime_visible_type_annotations,\n@@ -2307,2 +2274,0 @@\n-                             runtime_invisible_type_annotations,\n-                             runtime_invisible_type_annotations_length,\n@@ -2401,1 +2366,1 @@\n-  const u1* code_start = 0;\n+  const u1* code_start = nullptr;\n@@ -2432,2 +2397,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -2436,2 +2399,0 @@\n-  const u1* runtime_invisible_parameter_annotations = nullptr;\n-  int runtime_invisible_parameter_annotations_length = 0;\n@@ -2440,2 +2401,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -2712,5 +2671,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = method_attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -2737,6 +2691,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_parameter_annotations_length = method_attribute_length;\n-          runtime_invisible_parameter_annotations = cfs->current();\n-          assert(runtime_invisible_parameter_annotations != nullptr,\n-            \"null invisible parameter annotations\");\n-        }\n@@ -2773,7 +2721,1 @@\n-        } else {\n-          runtime_invisible_type_annotations_exists = true;\n-        }\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = method_attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n+        runtime_invisible_type_annotations_exists = true;\n@@ -2814,6 +2756,3 @@\n-      runtime_visible_annotations_length +\n-           runtime_invisible_annotations_length,\n-      runtime_visible_parameter_annotations_length +\n-           runtime_invisible_parameter_annotations_length,\n-      runtime_visible_type_annotations_length +\n-           runtime_invisible_type_annotations_length,\n+      runtime_visible_annotations_length,\n+      runtime_visible_parameter_annotations_length,\n+      runtime_visible_type_annotations_length,\n@@ -2911,2 +2850,0 @@\n-                          runtime_invisible_annotations,\n-                          runtime_invisible_annotations_length,\n@@ -2915,2 +2852,0 @@\n-                          runtime_invisible_parameter_annotations,\n-                          runtime_invisible_parameter_annotations_length,\n@@ -2919,2 +2854,0 @@\n-                          runtime_invisible_type_annotations,\n-                          runtime_invisible_type_annotations_length,\n@@ -3459,2 +3392,0 @@\n-    const u1* runtime_invisible_annotations = nullptr;\n-    int runtime_invisible_annotations_length = 0;\n@@ -3464,2 +3395,0 @@\n-    const u1* runtime_invisible_type_annotations = nullptr;\n-    int runtime_invisible_type_annotations_length = 0;\n@@ -3516,5 +3445,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null record component invisible annotation\");\n-        }\n@@ -3543,5 +3467,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null record component invisible type annotation\");\n-        }\n@@ -3557,1 +3476,1 @@\n-    AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,\n+    AnnotationArray* annotations = allocate_annotations(runtime_visible_annotations,\n@@ -3559,3 +3478,1 @@\n-                                                        runtime_invisible_annotations,\n-                                                        runtime_invisible_annotations_length,\n-    AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,\n+    AnnotationArray* type_annotations = allocate_annotations(runtime_visible_type_annotations,\n@@ -3564,2 +3481,0 @@\n-                                                             runtime_invisible_type_annotations,\n-                                                             runtime_invisible_type_annotations_length,\n@@ -3705,2 +3620,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -3709,2 +3622,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -3825,5 +3736,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -3881,7 +3787,1 @@\n-        } else {\n-          runtime_invisible_type_annotations_exists = true;\n-        }\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n+        runtime_invisible_type_annotations_exists = true;\n@@ -3977,1 +3877,1 @@\n-  _class_annotations = assemble_annotations(runtime_visible_annotations,\n+  _class_annotations = allocate_annotations(runtime_visible_annotations,\n@@ -3979,3 +3879,1 @@\n-                                            runtime_invisible_annotations,\n-                                            runtime_invisible_annotations_length,\n-  _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,\n+  _class_type_annotations = allocate_annotations(runtime_visible_type_annotations,\n@@ -3984,2 +3882,0 @@\n-                                                 runtime_invisible_type_annotations,\n-                                                 runtime_invisible_type_annotations_length,\n@@ -4136,4 +4032,2 @@\n-AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,\n-                                                       int runtime_visible_annotations_length,\n-                                                       const u1* const runtime_invisible_annotations,\n-                                                       int runtime_invisible_annotations_length,\n+AnnotationArray* ClassFileParser::allocate_annotations(const u1* const anno,\n+                                                       int anno_length,\n@@ -4142,2 +4036,1 @@\n-  if (runtime_visible_annotations != nullptr ||\n-      runtime_invisible_annotations != nullptr) {\n+  if (anno != nullptr) {\n@@ -4145,13 +4038,4 @@\n-                                          runtime_visible_annotations_length +\n-                                          runtime_invisible_annotations_length,\n-                                          CHECK_(annotations));\n-    if (runtime_visible_annotations != nullptr) {\n-      for (int i = 0; i < runtime_visible_annotations_length; i++) {\n-        annotations->at_put(i, runtime_visible_annotations[i]);\n-      }\n-    }\n-    if (runtime_invisible_annotations != nullptr) {\n-      for (int i = 0; i < runtime_invisible_annotations_length; i++) {\n-        int append = runtime_visible_annotations_length+i;\n-        annotations->at_put(append, runtime_invisible_annotations[i]);\n-      }\n+                                                 anno_length,\n+                                                 CHECK_(annotations));\n+    for (int i = 0; i < anno_length; i++) {\n+      annotations->at_put(i, anno[i]);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":26,"deletions":142,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,4 +380,2 @@\n-  AnnotationArray* assemble_annotations(const u1* const runtime_visible_annotations,\n-                                        int runtime_visible_annotations_length,\n-                                        const u1* const runtime_invisible_annotations,\n-                                        int runtime_invisible_annotations_length,\n+  AnnotationArray* allocate_annotations(const u1* const anno,\n+                                        int anno_length,\n@@ -551,2 +549,0 @@\n-                               const u1* runtime_invisible_annotations,\n-                               int runtime_invisible_annotations_length,\n@@ -555,2 +551,0 @@\n-                               const u1* runtime_invisible_parameter_annotations,\n-                               int runtime_invisible_parameter_annotations_length,\n@@ -559,2 +553,0 @@\n-                               const u1* runtime_invisible_type_annotations,\n-                               int runtime_invisible_type_annotations_length,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -756,1 +756,6 @@\n-void java_lang_String::print(oop java_string, outputStream* st) {\n+\/\/ Print the given string to the given outputStream, limiting the output to\n+\/\/ at most max_length of the string's characters. If the length exceeds the\n+\/\/ limit we print an abridged version of the string with the \"middle\" elided\n+\/\/ and replaced by \" ... (N characters ommitted) ... \". If max_length is odd\n+\/\/ it is treated as max_length-1.\n+void java_lang_String::print(oop java_string, outputStream* st, int max_length) {\n@@ -758,0 +763,3 @@\n+  \/\/ We need at least two characters to print A ... B\n+  assert(max_length > 1, \"invalid max_length: %d\", max_length);\n+\n@@ -770,0 +778,2 @@\n+  bool abridge = length > max_length;\n+\n@@ -772,0 +782,7 @@\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n@@ -781,0 +798,4 @@\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n@@ -1235,4 +1256,0 @@\n-void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {\n-  assert(_signers_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_signers_offset, signers);\n-}\n@@ -1439,6 +1456,7 @@\n-  macro(_classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,         false); \\\n-  macro(_class_loader_offset,        k, \"classLoader\",         classloader_signature, false); \\\n-  macro(_component_mirror_offset,    k, \"componentType\",       class_signature,       false); \\\n-  macro(_module_offset,              k, \"module\",              module_signature,      false); \\\n-  macro(_name_offset,                k, \"name\",                string_signature,      false); \\\n-  macro(_classData_offset,           k, \"classData\",           object_signature,      false);\n+  macro(_classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,          false); \\\n+  macro(_class_loader_offset,        k, \"classLoader\",         classloader_signature,  false); \\\n+  macro(_component_mirror_offset,    k, \"componentType\",       class_signature,        false); \\\n+  macro(_module_offset,              k, \"module\",              module_signature,       false); \\\n+  macro(_name_offset,                k, \"name\",                string_signature,       false); \\\n+  macro(_classData_offset,           k, \"classData\",           object_signature,       false); \\\n+  macro(_signers_offset,             k, \"signers\",             object_array_signature, false);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  static void print(oop java_string, outputStream* st);\n+  static void print(oop java_string, outputStream* st, int max_length = MaxStringPrintSize);\n@@ -211,1 +211,0 @@\n-  macro(java_lang_Class, signers,                object_signature,  false) \\\n@@ -306,3 +305,1 @@\n-\n-  static objArrayOop  signers(oop java_class);\n-  static void set_signers(oop java_class, objArrayOop signers);\n+  static objArrayOop signers(oop java_class);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    _deps[i] = new(arena) GrowableArray<ciBaseObject*>(arena, 10, 0, 0);\n+    _deps[i] = new(arena) GrowableArray<ciBaseObject*>(arena, 10, 0, nullptr);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1248,0 +1248,1 @@\n+  _has_scoped_access          = 0;\n@@ -3290,1 +3291,1 @@\n-    if (value == 0) {\n+    if (value == nullptr) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+          _has_scoped_access:1,        \/\/ used by for shared scope closure (scopedMemoryAccess.cpp)\n@@ -675,0 +676,3 @@\n+  bool  has_scoped_access() const                 { return _has_scoped_access; }\n+  void  set_has_scoped_access(bool z)             { _has_scoped_access = z; }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,1 +269,2 @@\n-  int vtable_index;\n+  short vtable_index;\n+  static_assert(sizeof(VtableStub::_index) == sizeof(vtable_index), \"precondition\");\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,3 @@\n-ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks) {\n+ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks,\n+                                           ReferenceProcessor* ref_processor)\n+  : _mark_and_push_closure(this, ref_processor) {\n@@ -70,2 +72,3 @@\n-  assert(ParallelScavengeHeap::heap() != nullptr,\n-    \"Needed for initialization\");\n+  assert(ParallelScavengeHeap::heap() != nullptr, \"Needed for initialization\");\n+  assert(PSParallelCompact::ref_processor() != nullptr, \"precondition\");\n+  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0, \"Not initialized?\");\n@@ -89,1 +92,2 @@\n-    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i));\n+    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i),\n+                                                 PSParallelCompact::ref_processor());\n@@ -95,3 +99,0 @@\n-  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0,\n-    \"Not initialized?\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -972,0 +973,1 @@\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n@@ -1190,2 +1192,3 @@\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    MarkingNMethodClosure mark_and_push_in_blobs(&mark_and_push_closure, !NMethodToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+    MarkingNMethodClosure mark_and_push_in_blobs(&cm->_mark_and_push_closure,\n+                                                 !NMethodToOopClosure::FixRelocations,\n+                                                 true \/* keepalive nmethods *\/);\n@@ -1193,1 +1196,1 @@\n-    thread->oops_do(&mark_and_push_closure, &mark_and_push_in_blobs);\n+    thread->oops_do(&cm->_mark_and_push_closure, &mark_and_push_in_blobs);\n@@ -1234,3 +1237,1 @@\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-\n-      CLDToOopClosure cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n+      CLDToOopClosure cld_closure(&cm->_mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -1244,2 +1245,4 @@\n-    PCAddThreadRootsMarkingTaskClosure closure(worker_id);\n-    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &closure);\n+    {\n+      PCAddThreadRootsMarkingTaskClosure closure(worker_id);\n+      Threads::possibly_parallel_threads_do(_active_workers > 1 \/* is_par *\/, &closure);\n+    }\n@@ -1249,1 +1252,1 @@\n-      _oop_storage_set_par_state.oops_do(&mark_and_push_closure);\n+      _oop_storage_set_par_state.oops_do(&cm->_mark_and_push_closure);\n@@ -1271,1 +1274,0 @@\n-    PCMarkAndPushClosure keep_alive(cm);\n@@ -1274,1 +1276,1 @@\n-    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &enqueue, &complete_gc);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &cm->_mark_and_push_closure, &enqueue, &complete_gc);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  BasicType         _type;\n@@ -109,0 +108,1 @@\n+  BasicType         _type;\n@@ -117,1 +117,0 @@\n-    _type(type),\n@@ -121,0 +120,1 @@\n+    _type(type),\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,19 +51,1 @@\n-  : _iu_barriers(new (comp_arena) GrowableArray<ShenandoahIUBarrierNode*>(comp_arena, 8,  0, nullptr)),\n-    _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, nullptr)) {\n-}\n-\n-int ShenandoahBarrierSetC2State::iu_barriers_count() const {\n-  return _iu_barriers->length();\n-}\n-\n-ShenandoahIUBarrierNode* ShenandoahBarrierSetC2State::iu_barrier(int idx) const {\n-  return _iu_barriers->at(idx);\n-}\n-\n-void ShenandoahBarrierSetC2State::add_iu_barrier(ShenandoahIUBarrierNode* n) {\n-  assert(!_iu_barriers->contains(n), \"duplicate entry in barrier list\");\n-  _iu_barriers->append(n);\n-}\n-\n-void ShenandoahBarrierSetC2State::remove_iu_barrier(ShenandoahIUBarrierNode* n) {\n-  _iu_barriers->remove_if_existing(n);\n+  : _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, nullptr)) {\n@@ -91,7 +73,0 @@\n-Node* ShenandoahBarrierSetC2::shenandoah_iu_barrier(GraphKit* kit, Node* obj) const {\n-  if (ShenandoahIUBarrier) {\n-    return kit->gvn().transform(new ShenandoahIUBarrierNode(obj));\n-  }\n-  return obj;\n-}\n-\n@@ -511,3 +486,0 @@\n-    Node* value = val.node();\n-    value = shenandoah_iu_barrier(kit, value);\n-    val.set_node(value);\n@@ -516,10 +488,0 @@\n-  } else {\n-    assert(access.is_opt_access(), \"only for optimization passes\");\n-    assert(((decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) && (decorators & C2_ARRAY_COPY) != 0, \"unexpected caller of this code\");\n-    C2OptAccess& opt_access = static_cast<C2OptAccess&>(access);\n-    PhaseGVN& gvn =  opt_access.gvn();\n-\n-    if (ShenandoahIUBarrier) {\n-      Node* enqueue = gvn.transform(new ShenandoahIUBarrierNode(val.node()));\n-      val.set_node(enqueue);\n-    }\n@@ -601,1 +563,0 @@\n-    new_val = shenandoah_iu_barrier(kit, new_val);\n@@ -649,1 +610,0 @@\n-    new_val = shenandoah_iu_barrier(kit, new_val);\n@@ -702,3 +662,0 @@\n-  if (access.is_oop()) {\n-    val = shenandoah_iu_barrier(kit, val);\n-  }\n@@ -722,1 +679,1 @@\n-  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier || node->Opcode() == Op_ShenandoahIUBarrier) return true;\n+  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;\n@@ -743,3 +700,0 @@\n-  if (c->Opcode() == Op_ShenandoahIUBarrier) {\n-    c = c->in(1);\n-  }\n@@ -778,3 +732,0 @@\n-  if (phase == Optimization) {\n-    return !ShenandoahIUBarrier;\n-  }\n@@ -839,5 +790,1 @@\n-    int flags = ShenandoahHeap::HAS_FORWARDED;\n-    if (ShenandoahIUBarrier) {\n-      flags |= ShenandoahHeap::MARKING;\n-    }\n-    Node* stable_and  = phase->transform_later(new AndINode(gc_state, phase->igvn().intcon(flags)));\n+    Node* stable_and  = phase->transform_later(new AndINode(gc_state, phase->igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));\n@@ -892,3 +839,0 @@\n-  if (node->Opcode() == Op_ShenandoahIUBarrier) {\n-    state()->add_iu_barrier((ShenandoahIUBarrierNode*) node);\n-  }\n@@ -901,3 +845,0 @@\n-  if (node->Opcode() == Op_ShenandoahIUBarrier) {\n-    state()->remove_iu_barrier((ShenandoahIUBarrierNode*) node);\n-  }\n@@ -951,6 +892,1 @@\n-  for (int i = state()->iu_barriers_count() - 1; i >= 0; i--) {\n-    ShenandoahIUBarrierNode* n = state()->iu_barrier(i);\n-    if (!useful.member(n)) {\n-      state()->remove_iu_barrier(n);\n-    }\n-  }\n+\n@@ -1193,3 +1129,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), delayed_worklist);\n-      break;\n@@ -1219,3 +1152,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), nullptr);\n-      return true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":4,"deletions":74,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  GrowableArray<ShenandoahIUBarrierNode*>* _iu_barriers;\n@@ -40,5 +39,0 @@\n-  int iu_barriers_count() const;\n-  ShenandoahIUBarrierNode* iu_barrier(int idx) const;\n-  void add_iu_barrier(ShenandoahIUBarrierNode* n);\n-  void remove_iu_barrier(ShenandoahIUBarrierNode * n);\n-\n@@ -76,2 +70,0 @@\n-  Node* shenandoah_iu_barrier(GraphKit* kit, Node* obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  if ((state->iu_barriers_count() +\n-       state->load_reference_barriers_count()) > 0) {\n+  if (state->load_reference_barriers_count() > 0) {\n@@ -189,10 +188,1 @@\n-          uint i = 0;\n-          for (; i < phis.size(); i++) {\n-            Node* n = phis.node_at(i);\n-            if (n->Opcode() == Op_ShenandoahIUBarrier) {\n-              break;\n-            }\n-          }\n-          if (i == phis.size()) {\n-            return false;\n-          }\n+          return false;\n@@ -202,9 +192,0 @@\n-      } else if (in->Opcode() == Op_ShenandoahIUBarrier) {\n-        if (t != ShenandoahOopStore) {\n-          in = in->in(1);\n-          continue;\n-        }\n-        if (trace) {tty->print(\"Found enqueue barrier\"); in->dump();}\n-        phis.push(in, in->req());\n-        in = in->in(1);\n-        continue;\n@@ -329,1 +310,1 @@\n-        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -371,1 +352,1 @@\n-          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -535,1 +516,1 @@\n-    } else if (n->Opcode() == Op_ShenandoahIUBarrier || n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n+    } else if (n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n@@ -1115,14 +1096,0 @@\n-  for (int i = 0; i < state->iu_barriers_count(); i++) {\n-    Node* barrier = state->iu_barrier(i);\n-    Node* ctrl = phase->get_ctrl(barrier);\n-    IdealLoopTree* loop = phase->get_loop(ctrl);\n-    Node* head = loop->head();\n-    if (head->is_OuterStripMinedLoop()) {\n-      \/\/ Expanding a barrier here will break loop strip mining\n-      \/\/ verification. Transform the loop so the loop nest doesn't\n-      \/\/ appear as strip mined.\n-      OuterStripMinedLoopNode* outer = head->as_OuterStripMinedLoop();\n-      hide_strip_mined_loop(outer, outer->unique_ctrl_out()->as_CountedLoop(), phase);\n-    }\n-  }\n-\n@@ -1459,151 +1426,0 @@\n-\n-  for (int i = state->iu_barriers_count() - 1; i >= 0; i--) {\n-    Node* barrier = state->iu_barrier(i);\n-    Node* pre_val = barrier->in(1);\n-\n-    if (phase->igvn().type(pre_val)->higher_equal(TypePtr::NULL_PTR)) {\n-      ShouldNotReachHere();\n-      continue;\n-    }\n-\n-    Node* ctrl = phase->get_ctrl(barrier);\n-\n-    if (ctrl->is_Proj() && ctrl->in(0)->is_CallJava()) {\n-      assert(is_dominator(phase->get_ctrl(pre_val), ctrl->in(0)->in(0), pre_val, ctrl->in(0), phase), \"can't move\");\n-      ctrl = ctrl->in(0)->in(0);\n-      phase->set_ctrl(barrier, ctrl);\n-    } else if (ctrl->is_CallRuntime()) {\n-      assert(is_dominator(phase->get_ctrl(pre_val), ctrl->in(0), pre_val, ctrl, phase), \"can't move\");\n-      ctrl = ctrl->in(0);\n-      phase->set_ctrl(barrier, ctrl);\n-    }\n-\n-    Node* init_ctrl = ctrl;\n-    IdealLoopTree* loop = phase->get_loop(ctrl);\n-    Node* raw_mem = fixer.find_mem(ctrl, barrier);\n-    Node* init_raw_mem = raw_mem;\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, nullptr);\n-    Node* heap_stable_ctrl = nullptr;\n-    Node* null_ctrl = nullptr;\n-    uint last = phase->C->unique();\n-\n-    enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };\n-    Node* region = new RegionNode(PATH_LIMIT);\n-    Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };\n-    Node* region2 = new RegionNode(PATH_LIMIT2);\n-    Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Stable path.\n-    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::MARKING);\n-    region->init_req(_heap_stable, heap_stable_ctrl);\n-    phi->init_req(_heap_stable, raw_mem);\n-\n-    \/\/ Null path\n-    Node* reg2_ctrl = nullptr;\n-    test_null(ctrl, pre_val, null_ctrl, phase);\n-    if (null_ctrl != nullptr) {\n-      reg2_ctrl = null_ctrl->in(0);\n-      region2->init_req(_null_path, null_ctrl);\n-      phi2->init_req(_null_path, raw_mem);\n-    } else {\n-      region2->del_req(_null_path);\n-      phi2->del_req(_null_path);\n-    }\n-\n-    const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());\n-    const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());\n-    Node* thread = new ThreadLocalNode();\n-    phase->register_new_node(thread, ctrl);\n-    Node* buffer_adr = new AddPNode(phase->C->top(), thread, phase->igvn().MakeConX(buffer_offset));\n-    phase->register_new_node(buffer_adr, ctrl);\n-    Node* index_adr = new AddPNode(phase->C->top(), thread, phase->igvn().MakeConX(index_offset));\n-    phase->register_new_node(index_adr, ctrl);\n-\n-    BasicType index_bt = TypeX_X->basic_type();\n-    assert(sizeof(size_t) == type2aelembytes(index_bt), \"Loading Shenandoah SATBMarkQueue::_index with wrong size.\");\n-    const TypePtr* adr_type = TypeRawPtr::BOTTOM;\n-    Node* index = new LoadXNode(ctrl, raw_mem, index_adr, adr_type, TypeX_X, MemNode::unordered);\n-    phase->register_new_node(index, ctrl);\n-    Node* index_cmp = new CmpXNode(index, phase->igvn().MakeConX(0));\n-    phase->register_new_node(index_cmp, ctrl);\n-    Node* index_test = new BoolNode(index_cmp, BoolTest::ne);\n-    phase->register_new_node(index_test, ctrl);\n-    IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);\n-    if (reg2_ctrl == nullptr) reg2_ctrl = queue_full_iff;\n-    phase->register_control(queue_full_iff, loop, ctrl);\n-    Node* not_full = new IfTrueNode(queue_full_iff);\n-    phase->register_control(not_full, loop, queue_full_iff);\n-    Node* full = new IfFalseNode(queue_full_iff);\n-    phase->register_control(full, loop, queue_full_iff);\n-\n-    ctrl = not_full;\n-\n-    Node* next_index = new SubXNode(index, phase->igvn().MakeConX(sizeof(intptr_t)));\n-    phase->register_new_node(next_index, ctrl);\n-\n-    Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);\n-    phase->register_new_node(buffer, ctrl);\n-    Node *log_addr = new AddPNode(phase->C->top(), buffer, next_index);\n-    phase->register_new_node(log_addr, ctrl);\n-    Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);\n-    phase->register_new_node(log_store, ctrl);\n-    \/\/ update the index\n-    Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);\n-    phase->register_new_node(index_update, ctrl);\n-\n-    \/\/ Fast-path case\n-    region2->init_req(_fast_path, ctrl);\n-    phi2->init_req(_fast_path, index_update);\n-\n-    ctrl = full;\n-\n-    Node* base = find_bottom_mem(ctrl, phase);\n-\n-    MergeMemNode* mm = MergeMemNode::make(base);\n-    mm->set_memory_at(Compile::AliasIdxRaw, raw_mem);\n-    phase->register_new_node(mm, ctrl);\n-\n-    Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), \"shenandoah_wb_pre\", TypeRawPtr::BOTTOM);\n-    call->init_req(TypeFunc::Control, ctrl);\n-    call->init_req(TypeFunc::I_O, phase->C->top());\n-    call->init_req(TypeFunc::Memory, mm);\n-    call->init_req(TypeFunc::FramePtr, phase->C->top());\n-    call->init_req(TypeFunc::ReturnAdr, phase->C->top());\n-    call->init_req(TypeFunc::Parms, pre_val);\n-    call->init_req(TypeFunc::Parms+1, thread);\n-    phase->register_control(call, loop, ctrl);\n-\n-    Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);\n-    phase->register_control(ctrl_proj, loop, call);\n-    Node* mem_proj = new ProjNode(call, TypeFunc::Memory);\n-    phase->register_new_node(mem_proj, call);\n-\n-    \/\/ Slow-path case\n-    region2->init_req(_slow_path, ctrl_proj);\n-    phi2->init_req(_slow_path, mem_proj);\n-\n-    phase->register_control(region2, loop, reg2_ctrl);\n-    phase->register_new_node(phi2, region2);\n-\n-    region->init_req(_heap_unstable, region2);\n-    phi->init_req(_heap_unstable, phi2);\n-\n-    phase->register_control(region, loop, heap_stable_ctrl->in(0));\n-    phase->register_new_node(phi, region);\n-\n-    fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);\n-    for(uint next = 0; next < uses.size(); next++ ) {\n-      Node *n = uses.at(next);\n-      assert(phase->get_ctrl(n) == init_ctrl, \"bad control\");\n-      assert(n != init_raw_mem, \"should leave input raw mem above the barrier\");\n-      phase->set_ctrl(n, region);\n-      follow_barrier_uses(n, init_ctrl, uses, phase);\n-    }\n-    fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);\n-\n-    phase->igvn().replace_node(barrier, pre_val);\n-  }\n-  assert(state->iu_barriers_count() == 0, \"all enqueue barrier nodes should have been replaced\");\n-\n@@ -1662,2 +1478,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return get_load_addr(phase, visited, in->in(1));\n@@ -1911,120 +1725,0 @@\n-ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(nullptr, val) {\n-  ShenandoahBarrierSetC2::bsc2()->state()->add_iu_barrier(this);\n-}\n-\n-const Type* ShenandoahIUBarrierNode::bottom_type() const {\n-  if (in(1) == nullptr || in(1)->is_top()) {\n-    return Type::TOP;\n-  }\n-  const Type* t = in(1)->bottom_type();\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-const Type* ShenandoahIUBarrierNode::Value(PhaseGVN* phase) const {\n-  if (in(1) == nullptr) {\n-    return Type::TOP;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-int ShenandoahIUBarrierNode::needed(Node* n) {\n-  if (n == nullptr ||\n-      n->is_Allocate() ||\n-      n->Opcode() == Op_ShenandoahIUBarrier ||\n-      n->bottom_type() == TypePtr::NULL_PTR ||\n-      (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr)) {\n-    return NotNeeded;\n-  }\n-  if (n->is_Phi() ||\n-      n->is_CMove()) {\n-    return MaybeNeeded;\n-  }\n-  return Needed;\n-}\n-\n-Node* ShenandoahIUBarrierNode::next(Node* n) {\n-  for (;;) {\n-    if (n == nullptr) {\n-      return n;\n-    } else if (n->bottom_type() == TypePtr::NULL_PTR) {\n-      return n;\n-    } else if (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr) {\n-      return n;\n-    } else if (n->is_ConstraintCast() ||\n-               n->Opcode() == Op_DecodeN ||\n-               n->Opcode() == Op_EncodeP) {\n-      n = n->in(1);\n-    } else if (n->is_Proj()) {\n-      n = n->in(0);\n-    } else {\n-      return n;\n-    }\n-  }\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n-\n-Node* ShenandoahIUBarrierNode::Identity(PhaseGVN* phase) {\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  Node* n = next(in(1));\n-\n-  int cont = needed(n);\n-\n-  if (cont == NotNeeded) {\n-    return in(1);\n-  } else if (cont == MaybeNeeded) {\n-    if (igvn == nullptr) {\n-      phase->record_for_igvn(this);\n-      return this;\n-    } else {\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-      uint wq_i = 0;\n-\n-      for (;;) {\n-        if (n->is_Phi()) {\n-          for (uint i = 1; i < n->req(); i++) {\n-            Node* m = n->in(i);\n-            if (m != nullptr) {\n-              wq.push(m);\n-            }\n-          }\n-        } else {\n-          assert(n->is_CMove(), \"nothing else here\");\n-          Node* m = n->in(CMoveNode::IfFalse);\n-          wq.push(m);\n-          m = n->in(CMoveNode::IfTrue);\n-          wq.push(m);\n-        }\n-        Node* orig_n = nullptr;\n-        do {\n-          if (wq_i >= wq.size()) {\n-            return in(1);\n-          }\n-          n = wq.at(wq_i);\n-          wq_i++;\n-          orig_n = n;\n-          n = next(n);\n-          cont = needed(n);\n-          if (cont == Needed) {\n-            return this;\n-          }\n-        } while (cont != MaybeNeeded || (orig_n != n && wq.member(n)));\n-      }\n-    }\n-  }\n-\n-  return this;\n-}\n-\n@@ -3013,2 +2707,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return needs_barrier_impl(phase, n->in(1), visited);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":5,"deletions":313,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  inline void iu_barrier(oop obj);\n@@ -123,1 +122,0 @@\n-  inline void clone_marking(oop src);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,6 +167,0 @@\n-inline void ShenandoahBarrierSet::iu_barrier(oop obj) {\n-  if (ShenandoahIUBarrier && obj != nullptr && _heap->is_concurrent_mark_in_progress()) {\n-    enqueue(obj);\n-  }\n-}\n-\n@@ -192,1 +186,0 @@\n-  iu_barrier(new_value);\n@@ -210,1 +203,0 @@\n-  iu_barrier(new_value);\n@@ -248,1 +240,0 @@\n-  bs->iu_barrier(value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -301,3 +301,0 @@\n-JNIEXPORT void JNICALL\n-JVM_DumpAllStacks(JNIEnv *env, jclass unused);\n-\n@@ -558,6 +555,0 @@\n-JNIEXPORT jobjectArray JNICALL\n-JVM_GetClassSigners(JNIEnv *env, jclass cls);\n-\n-JNIEXPORT void JNICALL\n-JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -667,1 +667,1 @@\n-  if (val != nullptr && strstr(name , val) != 0) {\n+  if (val != nullptr && strstr(name , val) != nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,6 @@\n+static void requireNotInHotSpot(const char* caller, JVMCI_TRAPS) {\n+    if (JVMCIENV->is_hotspot()) {\n+        JVMCI_THROW_MSG(IllegalStateException, err_msg(\"Cannot call %s from HotSpot\", caller));\n+    }\n+}\n+\n@@ -421,1 +427,1 @@\n-  if (UNPACK_PAIR(address, klass_or_method) == 0) {\n+  if (UNPACK_PAIR(address, klass_or_method) == nullptr) {\n@@ -705,0 +711,11 @@\n+C2V_VMENTRY_0(jlong, getJObjectValue, (JNIEnv* env, jobject, jobject constant_jobject))\n+    requireNotInHotSpot(\"getJObjectValue\", JVMCI_CHECK_0);\n+    if (!THREAD->has_last_Java_frame()) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    }\n+    JVMCIObject constant = JVMCIENV->wrap(constant_jobject);\n+    Handle constant_value = JVMCIENV->asConstant(constant, JVMCI_CHECK_0);\n+    jobject jni_handle = JNIHandles::make_local(THREAD, constant_value());\n+    return reinterpret_cast<jlong>(jni_handle);\n+C2V_END\n+\n@@ -760,0 +777,29 @@\n+#ifdef ASSERT\n+  \/\/ Support for testing an OOME raised in a context where the current thread cannot call Java\n+  \/\/ 1. Put -Dtest.jvmci.oome_in_lookupConstantInPool=<trace> on the command line to\n+  \/\/    discover possible values for step 2.\n+  \/\/    Example output:\n+  \/\/\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Overflow: String length out of range\"{0x00000007ffeb2960}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"null\"{0x00000007ffebdfe8}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Maximum lock count exceeded\"{0x00000007ffec4f90}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Negative length\"{0x00000007ffec4468}\n+  \/\/\n+  \/\/ 2. Choose a value shown in step 1.\n+  \/\/    Example: -Dtest.jvmci.oome_in_lookupConstantInPool=Negative\n+  const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.oome_in_lookupConstantInPool\");\n+  if (val != nullptr) {\n+    const char* str = obj->print_value_string();\n+    if (strstr(val, \"<trace>\") != nullptr) {\n+      tty->print_cr(\"CompilerToVM.lookupConstantInPool: %s\", str);\n+    } else if (strstr(str, val) != nullptr) {\n+      Handle garbage;\n+      while (true) {\n+        \/\/ Trigger an OutOfMemoryError\n+        objArrayOop next = oopFactory::new_objectArray(0x7FFFFFFF, CHECK_NULL);\n+        next->obj_at_put(0, garbage());\n+        garbage = Handle(THREAD, next);\n+      }\n+    }\n+  }\n+#endif\n@@ -1055,1 +1101,1 @@\n-  if (target_addr != 0x0) {\n+  if (target_addr != nullptr) {\n@@ -3228,0 +3274,1 @@\n+  {CC \"getJObjectValue\",                              CC \"(\" OBJECTCONSTANT \")J\",                                                           FN_PTR(getJObjectValue)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  static_field(CompilerToVM::Data,             _should_notify_object_alloc,            int*)                                         \\\n+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2095,1 +2095,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3022,1 +3022,1 @@\n-  if (breakpoints() != 0x0) {\n+  if (breakpoints() != nullptr) {\n@@ -3024,1 +3024,1 @@\n-    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n+    assert(breakpoints() == nullptr, \"should have cleared breakpoints\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-  if (is_native() && bcp == 0) {\n+  if (is_native() && bcp == nullptr) {\n@@ -358,1 +358,1 @@\n-  if (bcp == 0 || bcp == code_base()) {\n+  if (bcp == nullptr || bcp == code_base()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  assert(length <= max_length(), \"SymbolTable should have caught this!\");\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+  \/\/ Constructor is private for use only by SymbolTable.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -492,1 +492,1 @@\n-          assert(def != 0, \"input edge required\");\n+          assert(def != nullptr, \"input edge required\");\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,4 @@\n+    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n+      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+                        \"late method handle call resolution\");\n+    }\n@@ -586,1 +590,1 @@\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-  if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n+  if (_name != nullptr && strstr(_name, \"arraycopy\") != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+  ciMethod* _method;               \/\/ Method being direct called\n@@ -779,1 +780,0 @@\n-  ciMethod* _method;               \/\/ Method being direct called\n@@ -784,0 +784,1 @@\n+      _method(method),\n@@ -787,1 +788,0 @@\n-      _method(method),\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n-    : ConstraintCastNode(nullptr, n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n-    init_class_id(Class_CastII);\n-  }\n@@ -110,0 +106,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -137,0 +134,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -150,0 +148,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -160,0 +159,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -170,0 +170,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -195,0 +196,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  else if( _def == 0 ) tty->print(\"Dead \");\n+  else if( _def == nullptr ) tty->print(\"Dead \");\n@@ -206,1 +206,1 @@\n-  , _live(0)\n+  , _live(nullptr)\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-shmacro(ShenandoahIUBarrier)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1092,0 +1092,1 @@\n+  set_has_scoped_access(false);\n@@ -1097,1 +1098,1 @@\n-    } else if (has_method() && method()->name() != 0 &&\n+    } else if (has_method() && method()->name() != nullptr &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  bool                  _has_scoped_access;     \/\/ For shared scope closure\n@@ -694,0 +695,2 @@\n+  bool              has_scoped_access() const    { return _has_scoped_access; }\n+  void          set_has_scoped_access(bool v)    { _has_scoped_access = v; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3973,1 +3973,1 @@\n-PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *>  &orig_phi_worklist) {\n+PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *> &orig_phi_worklist, uint rec_depth) {\n@@ -3989,1 +3989,1 @@\n-      Node *mem = find_inst_mem(phi->in(idx), alias_idx, orig_phi_worklist);\n+      Node *mem = find_inst_mem(phi->in(idx), alias_idx, orig_phi_worklist, rec_depth + 1);\n@@ -4131,1 +4131,6 @@\n-Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis) {\n+#define FIND_INST_MEM_RECURSION_DEPTH_LIMIT 1000\n+Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis, uint rec_depth) {\n+  if (rec_depth > FIND_INST_MEM_RECURSION_DEPTH_LIMIT) {\n+    _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n+    return nullptr;\n+  }\n@@ -4205,1 +4210,1 @@\n-        result = find_inst_mem(result, alias_idx, orig_phis);\n+        result = find_inst_mem(result, alias_idx, orig_phis, rec_depth + 1);\n@@ -4273,1 +4278,1 @@\n-      result = split_memory_phi(mphi, alias_idx, orig_phis);\n+      result = split_memory_phi(mphi, alias_idx, orig_phis, rec_depth + 1);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1243,1 +1243,1 @@\n-    alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));\n+    alen = _gvn.transform( new LoadRangeNode(nullptr, immutable_memory(), r_adr, TypeInt::POS));\n@@ -2562,1 +2562,1 @@\n-      return _gvn.transform(new RoundFloatNode(0, n));\n+      return _gvn.transform(new RoundFloatNode(nullptr, n));\n@@ -2576,1 +2576,1 @@\n-      return _gvn.transform(new RoundDoubleNode(0, n));\n+      return _gvn.transform(new RoundDoubleNode(nullptr, n));\n@@ -3896,1 +3896,1 @@\n-  FastLockNode * flock = _gvn.transform(new FastLockNode(0, obj, box) )->as_FastLock();\n+  FastLockNode * flock = _gvn.transform(new FastLockNode(nullptr, obj, box) )->as_FastLock();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, 0);\n+  _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, nullptr);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+    ctrl->outcnt() == 1 && \/\/ No side-effects\n@@ -1366,1 +1367,1 @@\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2148,6 +2148,6 @@\n-  case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;\n-  case vmIntrinsics::_reverse_i:                n = new ReverseINode(0, arg); break;\n-  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(0, arg); break;\n+  case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverse_i:                n = new ReverseINode(nullptr, arg); break;\n+  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(nullptr, arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -618,0 +618,1 @@\n+      _body(Compile::current()->comp_arena()),\n@@ -848,0 +849,2 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n+\n@@ -860,0 +863,1 @@\n+    _nesting.check(); \/\/ Check if a potential re-allocation in the resource arena is safe\n@@ -870,0 +874,1 @@\n+    _nesting.check(); \/\/ Check if a potential re-allocation in the resource arena is safe\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4853,0 +4853,3 @@\n+  if (node->is_CastII()) {\n+    clone->set_req(0, new_ctrl);\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -398,1 +398,8 @@\n-  if (t->isa_intptr_t() && offset != 0 && offset != Type::OffsetBot) {\n+\n+  if (t->isa_intptr_t() &&\n+#if !defined(AARCH64)\n+      \/\/ AArch64 supports the addressing mode:\n+      \/\/ [base, 0], in which [base] is converted from a long value\n+      offset != 0 &&\n+#endif\n+      offset != Type::OffsetBot) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -906,0 +906,4 @@\n+  Node* scalarized_obj(const JVMState* jvms, uint idx) const {\n+    assert(verify_jvms(jvms), \"jvms must match\");\n+    return in(_jvmadj + jvms->scloff() + idx);\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1856,1 +1856,1 @@\n-    mach->add_req(0);             \/\/ Set initial control to none\n+    mach->add_req(nullptr);     \/\/ Set initial control to none\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2776,1 +2776,0 @@\n-  const bool _is_valid;          \/\/ The parsing succeeded\n@@ -2781,1 +2780,2 @@\n-  const jint  _int_offset_shift; \/\/ (optional) Shift value for int_offset\n+  const jint _int_offset_shift; \/\/ (optional) Shift value for int_offset\n+  const bool _is_valid;          \/\/ The parsing succeeded\n@@ -2791,1 +2791,0 @@\n-      _is_valid(is_valid),\n@@ -2796,0 +2795,1 @@\n+      _other_offsets(other_offsets),\n@@ -2797,1 +2797,1 @@\n-      _other_offsets(other_offsets)\n+      _is_valid(is_valid)\n@@ -2915,1 +2915,1 @@\n-    if (_int_offset != 0) {\n+    if (_int_offset != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1111,1 +1111,1 @@\n-const Node *Node::is_block_proj() const { return 0; }\n+const Node *Node::is_block_proj() const { return nullptr; }\n@@ -2776,0 +2776,4 @@\n+  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+  if (i < _max) {\n+    return; \/\/ No need to grow\n+  }\n@@ -2983,0 +2987,4 @@\n+  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+  if (_inode_top < _inode_max) {\n+    return; \/\/ No need to grow\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1613,0 +1613,2 @@\n+  ReallocMark _nesting;         \/\/ Safety checks for arena reallocation\n+\n@@ -1631,1 +1633,1 @@\n-  void map( uint i, Node *n ) { if( i>=_max ) grow(i); _nodes[i] = n; }\n+  void map( uint i, Node *n ) { grow(i); _nodes[i] = n; }\n@@ -1861,0 +1863,1 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n@@ -1884,1 +1887,1 @@\n-    if (_inode_top >= _inode_max) grow();\n+    grow();\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1039,0 +1039,21 @@\n+\/\/ Determine if there is a scalar replaced object description represented by 'ov'.\n+bool PhaseOutput::contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                             GrowableArray<ScopeValue*>* objs,\n+                                             ObjectValue* ov) const {\n+  for (int i = 0; i < jvms->scl_size(); i++) {\n+    Node* n = sfn->scalarized_obj(jvms, i);\n+    \/\/ Other kinds of nodes that we may encounter here, for instance constants\n+    \/\/ representing values of fields of objects scalarized, aren't relevant for\n+    \/\/ us, since they don't map to ObjectValue.\n+    if (!n->is_SafePointScalarObject()) {\n+      continue;\n+    }\n+\n+    ObjectValue* other = (ObjectValue*) sv_for_node_id(objs, n->_idx);\n+    if (ov == other) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1206,1 +1227,4 @@\n-          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          bool is_root = locarray->contains(ov) ||\n+                         exparray->contains(ov) ||\n+                         contains_as_owner(monarray, ov) ||\n+                         contains_as_scalarized_obj(jvms, sfn, objs, ov);\n@@ -2971,1 +2995,1 @@\n-      assert(def != 0, \"input edge required\");\n+      assert(def != nullptr, \"input edge required\");\n@@ -2994,1 +3018,1 @@\n-    assert( from->req() == 1 && (from->len() == 1 || from->in(1)==0), \"no precedence edges on projections\" );\n+    assert( from->req() == 1 && (from->len() == 1 || from->in(1) == nullptr), \"no precedence edges on projections\" );\n@@ -3542,0 +3566,1 @@\n+                              C->has_scoped_access(),\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    const FastLockNode *flock = _gvn.transform(new FastLockNode( 0, lock_object, box ))->as_FastLock();\n+    const FastLockNode *flock = _gvn.transform(new FastLockNode( nullptr, lock_object, box ))->as_FastLock();\n@@ -445,0 +445,4 @@\n+  if (parse_method->is_scoped()) {\n+    C->set_has_scoped_access(true);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3032,1 +3032,1 @@\n-    c = _gvn.transform( new DivFNode(0,a,b) );\n+    c = _gvn.transform( new DivFNode(nullptr,a,b) );\n@@ -3042,1 +3042,1 @@\n-      c = _gvn.transform( new ModFNode(0,a,b) );\n+      c = _gvn.transform( new ModFNode(nullptr,a,b) );\n@@ -3093,1 +3093,1 @@\n-    \/\/b = _gvn.transform(new RoundFloatNode(0, b) );\n+    \/\/b = _gvn.transform(new RoundFloatNode(nullptr, b) );\n@@ -3159,1 +3159,1 @@\n-    c = _gvn.transform( new DivDNode(0,a,b) );\n+    c = _gvn.transform( new DivDNode(nullptr,a,b) );\n@@ -3177,1 +3177,1 @@\n-      c = _gvn.transform( new ModDNode(0,a,b) );\n+      c = _gvn.transform( new ModDNode(nullptr,a,b) );\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,1 +783,1 @@\n-    if (!no_dead_loop) n->dump_bfs(100,0,\"#\");\n+    if (!no_dead_loop) n->dump_bfs(100,nullptr,\"#\");\n@@ -1138,1 +1138,1 @@\n-  n->dump_bfs(3, 0, \"\");\n+  n->dump_bfs(3, nullptr, \"\");\n@@ -2417,0 +2417,1 @@\n+  assert(_a == Compile::current()->comp_arena(), \"Should be allocated in comp_arena\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-                                           false, 0, Offset(oopDesc::mark_offset_in_bytes()));\n+                                           false, nullptr, Offset(oopDesc::mark_offset_in_bytes()));\n@@ -610,1 +610,1 @@\n-                                           false, 0, Offset(oopDesc::klass_offset_in_bytes()));\n+                                           false, nullptr, Offset(oopDesc::klass_offset_in_bytes()));\n@@ -621,1 +621,1 @@\n-  mreg2type[Op_Set ] = 0;\n+  mreg2type[Op_Set ] = nullptr;\n@@ -3244,1 +3244,1 @@\n-  return (TypeRawPtr*)(new TypeRawPtr(ptr,0))->hashcons();\n+  return (TypeRawPtr*)(new TypeRawPtr(ptr,nullptr))->hashcons();\n@@ -3256,1 +3256,1 @@\n-  assert( _bits==0, \"Why cast a constant address?\");\n+  assert( _bits == nullptr, \"Why cast a constant address?\");\n@@ -3640,1 +3640,1 @@\n-      (offset.get() > 0) && xk && (k != 0) && k->is_instance_klass()) {\n+      (offset.get() > 0) && xk && (k != nullptr) && k->is_instance_klass()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    Unique_Node_List calls(C->comp_arena());\n+    Unique_Node_List calls;\n@@ -241,1 +241,1 @@\n-  Unique_Node_List safepoints(C->comp_arena());\n+  Unique_Node_List safepoints;\n@@ -243,1 +243,1 @@\n-  Unique_Node_List worklist(C->comp_arena());\n+  Unique_Node_List worklist;\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1240,1 +1240,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1291,1 +1291,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1583,1 +1583,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1638,1 +1638,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1694,1 +1694,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1787,1 +1787,1 @@\n-  jfieldID ret = 0;\n+  jfieldID ret = nullptr;\n@@ -3132,1 +3132,1 @@\n-      return 0;\n+      return nullptr;\n@@ -3137,1 +3137,1 @@\n-    return 0;\n+    return nullptr;\n@@ -3744,2 +3744,2 @@\n-    *vm = 0;\n-    *(JNIEnv**)penv = 0;\n+    *vm = nullptr;\n+    *(JNIEnv**)penv = nullptr;\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1326,39 +1326,0 @@\n-JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))\n-  JvmtiVMObjectAllocEventCollector oam;\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ There are no signers for primitive types\n-    return nullptr;\n-  }\n-\n-  objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));\n-\n-  \/\/ If there are no signers set in the class, or if the class\n-  \/\/ is an array, return null.\n-  if (signers == nullptr) return nullptr;\n-\n-  \/\/ copy of the signers array\n-  Klass* element = ObjArrayKlass::cast(signers->klass())->element_klass();\n-  objArrayOop signers_copy = oopFactory::new_objArray(element, signers->length(), CHECK_NULL);\n-  for (int index = 0; index < signers->length(); index++) {\n-    signers_copy->obj_at_put(index, signers->obj_at(index));\n-  }\n-\n-  \/\/ return the copy\n-  return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);\n-JVM_END\n-\n-\n-JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (!java_lang_Class::is_primitive(mirror)) {\n-    \/\/ This call is ignored for primitive types and arrays.\n-    \/\/ Signers are only set once, ClassLoader.java, and thus shouldn't\n-    \/\/ be called with an array.  Only the bootstrap loader creates arrays.\n-    Klass* k = java_lang_Class::as_Klass(mirror);\n-    if (k->is_instance_klass()) {\n-      java_lang_Class::set_signers(k->java_mirror(), objArrayOop(JNIHandles::resolve(signers)));\n-    }\n-  }\n-JVM_END\n-\n@@ -3273,8 +3234,0 @@\n-JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))\n-  VM_PrintThreads op;\n-  VMThread::execute(&op);\n-  if (JvmtiExport::should_post_data_dump()) {\n-    JvmtiExport::post_data_dump();\n-  }\n-JVM_END\n-\n@@ -3913,1 +3866,1 @@\n-    THROW_(vmSymbols::java_lang_NullPointerException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n@@ -3921,1 +3874,1 @@\n-    THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n@@ -3927,1 +3880,1 @@\n-    THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":50,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -126,1 +126,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n@@ -384,14 +384,0 @@\n-void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,\n-                                                              const char* fallback_attr_name,\n-                                                              AnnotationArray* annos) {\n-  TempNewSymbol sym = SymbolTable::probe(attr_name, (int)strlen(attr_name));\n-  if (sym != nullptr) {\n-    if (symbol_to_cpool_index(sym) != 0) {\n-      write_annotations_attribute(attr_name, annos);\n-      return;\n-    }\n-  }\n-  \/\/ use fallback name\n-  write_annotations_attribute(fallback_attr_name, annos);\n-}\n-\n@@ -557,1 +543,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", component->annotations());\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", component->annotations());\n@@ -560,1 +546,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", component->type_annotations());\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", component->type_annotations());\n@@ -799,1 +785,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -802,1 +788,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", param_anno);\n+    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", param_anno);\n@@ -805,1 +791,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n@@ -868,1 +854,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -871,1 +857,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -120,7 +120,0 @@\n-  \/\/ With PreserveAllAnnotations option \"runtime invisible\" annotations\n-  \/\/ (RuntimeInvisibleAnnotations\/RuntimeInvisibleTypeAnnotations\/RuntimeInvisibleParameterAnnotations)\n-  \/\/ are considered \"runtime visible\" and ClassFileReconstituter writes them as\n-  \/\/ RuntimeVisibleAnnotations\/RuntimeVisibleTypeAnnotations\/RuntimeVisibleParameterAnnotations.\n-  \/\/ This helper method is for the corner case when \"runtime visible\" attribute name is not presents\n-  \/\/ in the class constant pool and the annotations are written with fallback \"runtime invisible\" name.\n-  void write_annotations_attribute(const char* attr_name, const char* fallback_attr_name, AnnotationArray* annos);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1176,1 +1176,1 @@\n-      JFR_ONLY(k_new_method->copy_trace_flags(*k_old_method->trace_flags_addr());)\n+      JFR_ONLY(k_new_method->copy_trace_flags(k_old_method->trace_flags());)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-    return 0;\n@@ -456,1 +455,0 @@\n-      return Bytecodes::_illegal;\n@@ -470,1 +468,0 @@\n-    return 0;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -813,1 +813,1 @@\n-  jclass result = 0;\n+  jclass result = nullptr;\n@@ -826,1 +826,1 @@\n-    return 0;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,8 @@\n+WB_ENTRY(jstring, WB_PrintString(JNIEnv* env, jobject wb, jstring str, jint max_length))\n+  ResourceMark rm(THREAD);\n+  stringStream sb;\n+  java_lang_String::print(JNIHandles::resolve(str), &sb, max_length);\n+  oop result = java_lang_String::create_oop_from_str(sb.as_string(), THREAD);\n+  return (jstring) JNIHandles::make_local(THREAD, result);\n+WB_END\n+\n@@ -3056,0 +3064,1 @@\n+  {CC\"printString\", CC\"(Ljava\/lang\/String;I)Ljava\/lang\/String;\", (void*)&WB_PrintString},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-LegacyGCLogging Arguments::_legacyGCLogging     = { 0, 0 };\n+LegacyGCLogging Arguments::_legacyGCLogging     = { nullptr, 0 };\n@@ -507,1 +507,0 @@\n-  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -517,0 +516,1 @@\n+  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -525,0 +525,2 @@\n+\n+  { \"BaseFootPrintEstimate\",           JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -1657,3 +1659,0 @@\n-  if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {\n-    return JNI_EINVAL;\n-  }\n@@ -1863,1 +1862,1 @@\n-  \"-da\", \"-ea\", \"-disableassertions\", \"-enableassertions\", 0\n+  \"-da\", \"-ea\", \"-disableassertions\", \"-enableassertions\", nullptr\n@@ -1867,1 +1866,1 @@\n-  \"-dsa\", \"-esa\", \"-disablesystemassertions\", \"-enablesystemassertions\", 0\n+  \"-dsa\", \"-esa\", \"-disablesystemassertions\", \"-enablesystemassertions\", nullptr\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -798,4 +798,0 @@\n-  product(bool, PreserveAllAnnotations, false,                              \\\n-          \"(Deprecated) Preserve RuntimeInvisibleAnnotations as well \"      \\\n-          \"as RuntimeVisibleAnnotations\")                                   \\\n-                                                                            \\\n@@ -1328,0 +1324,6 @@\n+  develop(int, MaxStringPrintSize, 256,                                     \\\n+          \"maximum number of characters to print for a java.lang.String \"   \\\n+          \"in the VM. If exceeded, an abridged version of the string is \"   \\\n+          \"printed with the middle of the string elided.\")                  \\\n+          range(2, O_BUFLEN)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -474,2 +474,2 @@\n-  _exception_pc(0),\n-  _exception_handler_pc(0),\n+  _exception_pc(nullptr),\n+  _exception_handler_pc(nullptr),\n@@ -487,1 +487,1 @@\n-  _cont_fastpath(0),\n+  _cont_fastpath(nullptr),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2125,1 +2125,1 @@\n-    out->print_cr(\"In-use monitor info:\");\n+    out->print_cr(\"In-use monitor info%s:\", log_all ? \"\" : \" (eliding idle monitors)\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  template(ParallelGCFailedAllocation)            \\\n-  template(ParallelGCSystemGC)                    \\\n+  template(ParallelCollectForAllocation)          \\\n+  template(ParallelGCCollect)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-  _filename(\"filename\",\"Name of the dump file\", \"STRING\",true),\n+  _filename(\"filename\",\"Name of the dump file\", \"FILE\",true),\n@@ -855,2 +855,0 @@\n-#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-<pid>.map\"\n-\n@@ -859,1 +857,1 @@\n-  _filename(\"filename\", \"Name of the map file\", \"STRING\", false, DEFAULT_PERFMAP_FILENAME)\n+  _filename(\"filename\", \"Name of the map file\", \"FILE\", false, DEFAULT_PERFMAP_FILENAME)\n@@ -865,4 +863,1 @@\n-  \/\/ The check for _filename.is_set() is because we don't want to use\n-  \/\/ DEFAULT_PERFMAP_FILENAME, since it is meant as a description\n-  \/\/ of the default, not the actual default.\n-  CodeCache::write_perf_map(_filename.is_set() ? _filename.value() : nullptr);\n+  CodeCache::write_perf_map(_filename.value(), output());\n@@ -1024,1 +1019,1 @@\n-#define DEFAULT_CDS_ARCHIVE_FILENAME \"java_pid<pid>_<subcmd>.jsa\"\n+#define DEFAULT_CDS_ARCHIVE_FILENAME \"java_pid%p_<subcmd>.jsa\"\n@@ -1029,1 +1024,1 @@\n-  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false,\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"FILE\", false,\n@@ -1067,1 +1062,1 @@\n-    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+    fileh = java_lang_String::create_from_str(file, CHECK);\n@@ -1132,1 +1127,1 @@\n-  _filepath(\"filepath\", \"The file path to the output file\", \"STRING\", true) {\n+  _filepath(\"filepath\", \"The file path to the output file\", \"FILE\", true) {\n@@ -1213,1 +1208,1 @@\n-static constexpr char default_filename[] = \"vm_memory_map_<pid>.txt\";\n+static constexpr char default_filename[] = \"vm_memory_map_%p.txt\";\n@@ -1217,1 +1212,1 @@\n-  _filename(\"-F\", \"file path\", \"STRING\", false, default_filename) {\n+  _filename(\"-F\", \"file path\", \"FILE\", false, default_filename) {\n@@ -1222,8 +1217,1 @@\n-  stringStream defaultname;\n-  const char* name = nullptr;\n-  if (_filename.is_set()) {\n-    name = _filename.value();\n-  } else {\n-    defaultname.print(\"vm_memory_map_%d.txt\", os::current_process_id());\n-    name = defaultname.base();\n-  }\n+  const char* name = _filename.value();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-const int LogBytesPerWord    = 3;\n+constexpr int LogBytesPerWord    = 3;\n@@ -227,1 +227,1 @@\n-const int LogBytesPerWord    = 2;\n+constexpr int LogBytesPerWord    = 2;\n@@ -236,1 +236,1 @@\n-const int LogBitsPerByte     = 3;\n+constexpr int LogBitsPerByte     = 3;\n@@ -239,1 +239,1 @@\n-const int LogBitsPerWord     = LogBitsPerByte + LogBytesPerWord;\n+constexpr int LogBitsPerWord     = LogBitsPerByte + LogBytesPerWord;\n@@ -245,1 +245,1 @@\n-const int BitsPerWord        = 1 << LogBitsPerWord;\n+constexpr int BitsPerWord        = 1 << LogBitsPerWord;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.security.Permissions;\n@@ -60,0 +61,1 @@\n+import java.security.ProtectionDomain;\n@@ -1152,2 +1154,2 @@\n-    \/\/ Set by VM\n-    private transient Object classData;\n+    private transient Object classData; \/\/ Set by VM\n+    private transient Object[] signers; \/\/ Read by VM, mutable\n@@ -1562,1 +1564,5 @@\n-    public native Object[] getSigners();\n+\n+    public Object[] getSigners() {\n+        var signers = this.signers;\n+        return signers == null ? null : signers.clone();\n+    }\n@@ -1567,1 +1573,5 @@\n-    native void setSigners(Object[] signers);\n+    void setSigners(Object[] signers) {\n+        if (!isPrimitive() && !isArray()) {\n+            this.signers = signers;\n+        }\n+    }\n@@ -3265,4 +3275,0 @@\n-\n-    \/** protection domain returned when the internal domain is null *\/\n-    private static java.security.ProtectionDomain allPermDomain;\n-\n@@ -3289,1 +3295,1 @@\n-    public java.security.ProtectionDomain getProtectionDomain() {\n+    public ProtectionDomain getProtectionDomain() {\n@@ -3298,0 +3304,10 @@\n+    \/** Holder for the protection domain returned when the internal domain is null *\/\n+    private static class Holder {\n+        private static final ProtectionDomain allPermDomain;\n+        static {\n+            Permissions perms = new Permissions();\n+            perms.add(SecurityConstants.ALL_PERMISSION);\n+            allPermDomain = new ProtectionDomain(null, perms);\n+        }\n+    }\n+\n@@ -3299,2 +3315,2 @@\n-    java.security.ProtectionDomain protectionDomain() {\n-        java.security.ProtectionDomain pd = getProtectionDomain0();\n+    ProtectionDomain protectionDomain() {\n+        ProtectionDomain pd = getProtectionDomain0();\n@@ -3302,8 +3318,3 @@\n-            if (allPermDomain == null) {\n-                java.security.Permissions perms =\n-                    new java.security.Permissions();\n-                perms.add(SecurityConstants.ALL_PERMISSION);\n-                allPermDomain =\n-                    new java.security.ProtectionDomain(null, perms);\n-            }\n-            pd = allPermDomain;\n+            return Holder.allPermDomain;\n+        } else {\n+            return pd;\n@@ -3311,1 +3322,0 @@\n-        return pd;\n@@ -3317,1 +3327,1 @@\n-    private native java.security.ProtectionDomain getProtectionDomain0();\n+    private native ProtectionDomain getProtectionDomain0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n- * Double#equals equals} uses <a href=#repEquivalence> representation\n- * equivalence<\/a>, defining NaN arguments to be equal to each other,\n+ * Double#equals equals} uses {@linkplain ##repEquivalence representation\n+ * equivalence}, defining NaN arguments to be equal to each other,\n@@ -595,0 +595,17 @@\n+     * @apiNote\n+     * This method corresponds to the general functionality of the\n+     * convertToDecimalCharacter operation defined in IEEE 754;\n+     * however, that operation is defined in terms of specifying the\n+     * number of significand digits used in the conversion.\n+     * Code to do such a conversion in the Java platform includes\n+     * converting the {@code double} to a {@link java.math.BigDecimal\n+     * BigDecimal} exactly and then rounding the {@code BigDecimal} to\n+     * the desired number of digits; sample code:\n+     * {@snippet lang=java :\n+     * double d = 0.1;\n+     * int digits = 25;\n+     * BigDecimal bd = new BigDecimal(d);\n+     * String result = bd.round(new MathContext(digits,  RoundingMode.HALF_UP));\n+     * \/\/ 0.1000000000000000055511151\n+     * }\n+     *\n@@ -675,0 +692,5 @@\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n@@ -901,0 +923,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n+     *\n@@ -1091,0 +1117,1 @@\n+    @Override\n@@ -1104,0 +1131,1 @@\n+    @Override\n@@ -1113,0 +1141,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -1116,0 +1148,1 @@\n+    @Override\n@@ -1124,0 +1157,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -1128,0 +1165,1 @@\n+    @Override\n@@ -1145,0 +1183,1 @@\n+    @Override\n@@ -1154,0 +1193,1 @@\n+    @Override\n@@ -1214,3 +1254,2 @@\n-     * relation must be implemented; see <a\n-     * href=\"#equivalenceRelation\">this discussion<\/a> for details of\n-     * floating-point equality and equivalence.\n+     * relation must be implemented; see {@linkplain ##equivalenceRelation\n+     * this discussion for details of floating-point equality and equivalence}.\n@@ -1393,3 +1432,3 @@\n-     * equals<\/i>; see <a href=\"#equivalenceRelation\">this\n-     * discussion<\/a> for details of floating-point comparison and\n-     * ordering.\n+     * equals<\/i>; see {@linkplain ##equivalenceRelation this\n+     * discussion for details of floating-point comparison and\n+     * ordering}.\n@@ -1409,0 +1448,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -311,0 +311,17 @@\n+     * @apiNote\n+     * This method corresponds to the general functionality of the\n+     * convertToDecimalCharacter operation defined in IEEE 754;\n+     * however, that operation is defined in terms of specifying the\n+     * number of significand digits used in the conversion.\n+     * Code to do such a conversion in the Java platform includes\n+     * converting the {@code float} to a {@link java.math.BigDecimal\n+     * BigDecimal} exactly and then rounding the {@code BigDecimal} to\n+     * the desired number of digits; sample code:\n+     * {@snippet lang=java :\n+     * floatf = 0.1f;\n+     * int digits = 15;\n+     * BigDecimal bd = new BigDecimal(f);\n+     * String result = bd.round(new MathContext(digits,  RoundingMode.HALF_UP));\n+     * \/\/ 0.100000001490116\n+     * }\n+     *\n@@ -391,0 +408,5 @@\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n@@ -528,0 +550,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n+     *\n@@ -733,0 +759,1 @@\n+    @Override\n@@ -746,0 +773,1 @@\n+    @Override\n@@ -754,0 +782,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -758,0 +790,1 @@\n+    @Override\n@@ -766,0 +799,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -770,0 +807,1 @@\n+    @Override\n@@ -779,0 +817,1 @@\n+    @Override\n@@ -796,0 +835,1 @@\n+    @Override\n@@ -843,3 +883,2 @@\n-     * relation must be implemented; see <a\n-     * href=\"Double.html#equivalenceRelation\">this discussion<\/a> for\n-     * details of floating-point equality and equivalence.\n+     * relation must be implemented; see {@linkplain Double##equivalenceRelation\n+     * this discussion for details of floating-point equality and equivalence}.\n@@ -1096,1 +1135,1 @@\n-     * The <a href=\"#binary16Format\">binary16 format<\/a> is discussed in\n+     * The {@linkplain ##binary16Format binary16 format} is discussed in\n@@ -1212,3 +1251,3 @@\n-     * equals<\/i>; see <a href=\"Double.html#equivalenceRelation\">this\n-     * discussion<\/a> for details of floating-point comparison and\n-     * ordering.\n+     * equals<\/i>; see {@linkplain Double##equivalenceRelation this\n+     * discussion for details of floating-point comparison and\n+     * ordering}.\n@@ -1229,0 +1268,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -431,1 +432,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -461,26 +462,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -461,1 +462,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -491,26 +492,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-import java.util.concurrent.Callable;\n@@ -2268,0 +2267,1 @@\n+        @Override\n@@ -2615,4 +2615,0 @@\n-            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n-                return StringConcatHelper.prepend(indexCoder, buf, value);\n-            }\n-\n@@ -2631,4 +2627,0 @@\n-            public int stringSize(long i) {\n-                return Long.stringSize(i);\n-            }\n-\n@@ -2685,8 +2677,0 @@\n-            public <V> V executeOnCarrierThread(Callable<V> task) throws Exception {\n-                if (Thread.currentThread() instanceof VirtualThread vthread) {\n-                    return vthread.executeOnCarrierThread(task);\n-                } else {\n-                    return task.call();\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        extends WritableElement<A>\n+        extends ClassFileElement\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * <p>\n+ *\n@@ -40,1 +40,1 @@\n- * <p>\n+ *\n@@ -380,1 +380,1 @@\n- * <p>\n+ *\n@@ -446,1 +446,1 @@\n- * <p>\n+ *\n@@ -472,1 +472,1 @@\n- *<p>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,1 +402,1 @@\n-            names[arity] = zero.newIndex(arity);\n+            names[arity] = zero.withIndex(arity);\n@@ -502,1 +502,1 @@\n-        Name[] oldNames = null;\n+        Name[] oldNames = names.clone();\n@@ -504,1 +504,0 @@\n-        int changesStart = 0;\n@@ -507,7 +506,1 @@\n-            if (!n.initIndex(i)) {\n-                if (oldNames == null) {\n-                    oldNames = names.clone();\n-                    changesStart = i;\n-                }\n-                names[i] = n.cloneWithIndex(i);\n-            }\n+            names[i] = n.withIndex(i);\n@@ -518,6 +511,3 @@\n-            int startFixing = arity;\n-            if (startFixing <= changesStart)\n-                startFixing = changesStart+1;\n-            for (int i = startFixing; i < names.length; i++) {\n-                Name fixed = names[i].replaceNames(oldNames, names, changesStart, i);\n-                names[i] = fixed.newIndex(i);\n+            for (int i = Math.max(1, arity); i < names.length; i++) {\n+                Name fixed = names[i].replaceNames(oldNames, names, 0, i);\n+                names[i] = fixed.withIndex(i);\n@@ -1346,1 +1336,1 @@\n-        @Stable short index;\n+        final short index;\n@@ -1353,1 +1343,1 @@\n-        private Name(int index, BasicType type, NamedFunction function, Object[] arguments) {\n+        private Name(int index, BasicType type, NamedFunction function, Object[] arguments, Object constraint) {\n@@ -1358,8 +1348,1 @@\n-            this.constraint = null;\n-            assert(this.index == index && typesMatch(function, this.arguments));\n-        }\n-        private Name(Name that, Object constraint) {\n-            this.index = that.index;\n-            this.type = that.type;\n-            this.function = that.function;\n-            this.arguments = that.arguments;\n+            assert(this.index == index && typesMatch(function, arguments));\n@@ -1370,0 +1353,1 @@\n+\n@@ -1381,1 +1365,1 @@\n-            this(-1, function.returnType(), function, EMPTY_ARGS);\n+            this(-1, function.returnType(), function, EMPTY_ARGS, null);\n@@ -1384,1 +1368,1 @@\n-            this(-1, function.returnType(), function, new Object[] { arg });\n+            this(-1, function.returnType(), function, new Object[] { arg }, null);\n@@ -1387,1 +1371,1 @@\n-            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 }, null);\n@@ -1390,1 +1374,1 @@\n-            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class), null);\n@@ -1394,1 +1378,1 @@\n-            this(index, type, null, null);\n+            this(index, type, null, null, null);\n@@ -1401,7 +1385,1 @@\n-        boolean initIndex(int i) {\n-            if (index != i) {\n-                if (index != -1)  return false;\n-                index = (short)i;\n-            }\n-            return true;\n-        }\n+\n@@ -1412,7 +1390,3 @@\n-        Name newIndex(int i) {\n-            if (initIndex(i))  return this;\n-            return cloneWithIndex(i);\n-        }\n-        Name cloneWithIndex(int i) {\n-            Object[] newArguments = (arguments == null) ? null : arguments.clone();\n-            return new Name(i, type, function, newArguments).withConstraint(constraint);\n+        Name withIndex(int i) {\n+            if (i == this.index) return this;\n+            return new Name(i, type, function, arguments, constraint);\n@@ -1420,0 +1394,1 @@\n+\n@@ -1422,1 +1397,1 @@\n-            return new Name(this, constraint);\n+            return new Name(index, type, function, arguments, constraint);\n@@ -1424,0 +1399,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":23,"deletions":47,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2151,0 +2151,10 @@\n+        var buf = new StringBuilder(10);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     * Requires extra capacity of 10 to avoid StringBuilder reallocation.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -2155,1 +2165,0 @@\n-        StringBuilder buf = new StringBuilder(10);\n@@ -2158,3 +2167,1 @@\n-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+                buf.append('-');\n@@ -2162,0 +2169,2 @@\n+            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n+            buf.append(absYear);\n@@ -2168,5 +2177,4 @@\n-        return buf.append(monthValue < 10 ? \"-0\" : \"-\")\n-            .append(monthValue)\n-            .append(dayValue < 10 ? \"-0\" : \"-\")\n-            .append(dayValue)\n-            .toString();\n+        buf.append(monthValue < 10 ? \"-0\" : \"-\")\n+           .append(monthValue)\n+           .append(dayValue < 10 ? \"-0\" : \"-\")\n+           .append(dayValue);\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1969,1 +1969,5 @@\n-        return date.toString() + 'T' + time.toString();\n+        var buf = new StringBuilder(29);\n+        date.formatTo(buf);\n+        buf.append('T');\n+        time.formatTo(buf);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -1633,1 +1635,10 @@\n-        StringBuilder buf = new StringBuilder(18);\n+        var buf = new StringBuilder(18);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     * Requires extra capacity of 18 to avoid StringBuilder reallocation.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1644,2 +1655,7 @@\n-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000_000) + 1000).substring(1));\n+                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n+                if (zeros > 0) {\n+                    buf.repeat('0', zeros);\n+                }\n+                int digits;\n+                if (nanoValue % 1_000_000 == 0) {\n+                    digits = nanoValue \/ 1_000_000;\n@@ -1647,1 +1663,1 @@\n-                    buf.append(Integer.toString((nanoValue \/ 1000) + 1000_000).substring(1));\n+                    digits = nanoValue \/ 1000;\n@@ -1649,1 +1665,1 @@\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n+                    digits = nanoValue;\n@@ -1651,0 +1667,1 @@\n+                buf.append(digits);\n@@ -1653,1 +1670,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import java.util.concurrent.Callable;\n@@ -436,6 +435,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\/\n-    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n-\n@@ -469,2 +462,0 @@\n-    int stringSize(long i);\n-\n@@ -514,5 +505,0 @@\n-    \/**\n-     * Executes the given value returning task on the current carrier thread.\n-     *\/\n-    <V> V executeOnCarrierThread(Callable<V> task) throws Exception;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-            attr.defaultValue().writeTo(buf);\n+            AnnotationReader.writeAnnotationValue((BufWriterImpl) buf, attr.defaultValue());\n@@ -122,1 +122,5 @@\n-            buf.writeList(attr.bootstrapMethods());\n+            var b = (BufWriterImpl) buf;\n+            b.writeU2(attr.bootstrapMethodsSize());\n+            for (var bsm : attr.bootstrapMethods()) {\n+                ((BootstrapMethodEntryImpl) bsm).writeTo(b);\n+            }\n@@ -257,1 +261,1 @@\n-            buf.writeListIndices(attr.exceptions());\n+            Util.writeListIndices(buf, attr.exceptions());\n@@ -323,1 +327,1 @@\n-            buf.writeListIndices(attr.loadableDescriptors());\n+            Util.writeListIndices(buf, attr.loadableDescriptors());\n@@ -429,1 +433,1 @@\n-                buf.writeListIndices(export.exportsTo());\n+                Util.writeListIndices(buf, export.exportsTo());\n@@ -435,1 +439,1 @@\n-                buf.writeListIndices(open.opensTo());\n+                Util.writeListIndices(buf, open.opensTo());\n@@ -437,1 +441,1 @@\n-            buf.writeListIndices(attr.uses());\n+            Util.writeListIndices(buf, attr.uses());\n@@ -441,1 +445,1 @@\n-                buf.writeListIndices(provide.providesWith());\n+                Util.writeListIndices(buf, provide.providesWith());\n@@ -503,1 +507,1 @@\n-            buf.writeListIndices(attr.packages());\n+            Util.writeListIndices(buf, attr.packages());\n@@ -575,1 +579,1 @@\n-            buf.writeListIndices(attr.nestMembers());\n+            Util.writeListIndices(buf, attr.nestMembers());\n@@ -593,1 +597,1 @@\n-            buf.writeListIndices(attr.permittedSubclasses());\n+            Util.writeListIndices(buf, attr.permittedSubclasses());\n@@ -616,1 +620,1 @@\n-                buf.writeList(info.attributes());\n+                Util.writeAttributes((BufWriterImpl) buf, info.attributes());\n@@ -635,1 +639,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -656,1 +660,1 @@\n-                buf.writeList(list);\n+                AnnotationReader.writeAnnotations(buf, list);\n@@ -674,1 +678,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -692,1 +696,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -713,1 +717,1 @@\n-                buf.writeList(list);\n+                AnnotationReader.writeAnnotations(buf, list);\n@@ -731,1 +735,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-\n@@ -43,0 +37,1 @@\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -44,0 +39,7 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -50,1 +52,1 @@\n-        implements Attribute<T> {\n+        implements Attribute<T>, Util.Writable {\n@@ -103,1 +105,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -119,1 +121,1 @@\n-    <E> List<E> readEntryList(int p) {\n+    <E extends PoolEntry> List<E> readEntryList(int p, Class<E> type) {\n@@ -125,1 +127,1 @@\n-            entries[i] = classReader.readEntry(p);\n+            entries[i] = classReader.readEntry(p, type);\n@@ -136,1 +138,0 @@\n-        var apo = ((ClassReaderImpl)reader).context().attributesProcessingOption();\n@@ -150,1 +151,1 @@\n-                filled.add((Attribute)mapper.readAttribute(enclosing, reader, p));\n+                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n@@ -288,1 +289,5 @@\n-            codeAttribute = (CodeImpl) enclosing;\n+            if (enclosing instanceof CodeImpl ci) {\n+                this.codeAttribute = ci;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid LocalVariableTable attribute location\");\n+            }\n@@ -315,1 +320,5 @@\n-            this.codeAttribute = (CodeImpl) enclosing;\n+            if (enclosing instanceof CodeImpl ci) {\n+                this.codeAttribute = ci;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid LocalVariableTypeTable attribute location\");\n+            }\n@@ -552,1 +561,1 @@\n-                exceptions = readEntryList(payloadStart);\n+                exceptions = readEntryList(payloadStart, ClassEntry.class);\n@@ -648,1 +657,1 @@\n-                    List<ModuleEntry> exportsTo = readEntryList(p);\n+                    List<ModuleEntry> exportsTo = readEntryList(p, ModuleEntry.class);\n@@ -663,1 +672,1 @@\n-                    List<ModuleEntry> opensTo = readEntryList(p);\n+                    List<ModuleEntry> opensTo = readEntryList(p, ModuleEntry.class);\n@@ -671,1 +680,1 @@\n-                uses = readEntryList(p);\n+                uses = readEntryList(p, ClassEntry.class);\n@@ -680,1 +689,1 @@\n-                    List<ClassEntry> providesWith = readEntryList(p);\n+                    List<ClassEntry> providesWith = readEntryList(p, ClassEntry.class);\n@@ -700,1 +709,1 @@\n-                packages = readEntryList(payloadStart);\n+                packages = readEntryList(payloadStart, PackageEntry.class);\n@@ -718,1 +727,1 @@\n-                members = readEntryList(payloadStart);\n+                members = readEntryList(payloadStart, ClassEntry.class);\n@@ -747,1 +756,1 @@\n-                    final List<LoadableConstantEntry> args = readEntryList(p + 2);\n+                    final List<LoadableConstantEntry> args = readEntryList(p + 2, LoadableConstantEntry.class);\n@@ -927,1 +936,1 @@\n-                permittedSubclasses = readEntryList(payloadStart);\n+                permittedSubclasses = readEntryList(payloadStart, ClassEntry.class);\n@@ -944,1 +953,1 @@\n-                loadableDescriptors = readEntryList(payloadStart);\n+                loadableDescriptors = readEntryList(payloadStart, Utf8Entry.class);\n@@ -1007,1 +1016,1 @@\n-            case 0x78147009 ->\n+            case 0x46699ff2 ->\n@@ -1009,1 +1018,1 @@\n-            case 0x665e3a3a ->\n+            case 0x5208e184 ->\n@@ -1011,1 +1020,1 @@\n-            case 0xcb7e162 ->\n+            case 0xcb60907a ->\n@@ -1013,1 +1022,1 @@\n-            case 0x21e41e7e ->\n+            case 0x4020220d ->\n@@ -1015,1 +1024,1 @@\n-            case 0x5a306b41 ->\n+            case 0xc20dd1fe ->\n@@ -1017,1 +1026,1 @@\n-            case 0x3e191c7c ->\n+            case 0xcab1940d ->\n@@ -1019,1 +1028,1 @@\n-            case 0x5e88ed0c ->\n+            case 0x558641d3 ->\n@@ -1021,1 +1030,1 @@\n-            case 0x7284695e ->\n+            case 0x51d443cd ->\n@@ -1023,1 +1032,1 @@\n-            case 0x21df25db ->\n+            case 0x687c1624 ->\n@@ -1025,1 +1034,1 @@\n-            case 0x11392da9 ->\n+            case 0x7adb2910 ->\n@@ -1027,1 +1036,1 @@\n-            case 0x167536fc ->\n+            case 0x653f0551 ->\n@@ -1029,1 +1038,1 @@\n-            case 0x4d56b212 ->\n+           case 0x5f348b64 ->\n@@ -1031,1 +1040,1 @@\n-            case 0x46939abc ->\n+            case 0x64c75927 ->\n@@ -1033,1 +1042,1 @@\n-            case 0x63ee67f4 ->\n+            case 0x6697f98d ->\n@@ -1035,1 +1044,1 @@\n-            case 0x2b597e15 ->\n+            case 0xdbb0cdcb ->\n@@ -1037,1 +1046,1 @@\n-            case 0x19f20ade ->\n+            case 0xc9b0928c ->\n@@ -1039,1 +1048,1 @@\n-            case 0x47f6395e ->\n+            case 0x41cd27e8 ->\n@@ -1041,1 +1050,1 @@\n-            case 0x54db809 ->\n+            case 0x7deb0a13 ->\n@@ -1043,1 +1052,1 @@\n-            case 0x1abd1c2c ->\n+            case 0x6706ff99 ->\n@@ -1045,1 +1054,1 @@\n-            case 0x6ba46dd ->\n+            case 0x60272858 ->\n@@ -1047,1 +1056,1 @@\n-            case 0x46f7d91d ->\n+            case 0x5646d73d ->\n@@ -1049,1 +1058,1 @@\n-            case 0x5137f53 ->\n+            case 0x50336c40 ->\n@@ -1051,1 +1060,1 @@\n-            case 0x4a8fa3b6 ->\n+            case 0x4735ab81 ->\n@@ -1053,1 +1062,1 @@\n-            case 0x55c73cb6 ->\n+            case 0x7100d9fe ->\n@@ -1055,1 +1064,1 @@\n-            case 0x3fe76d4e ->\n+            case 0xd1ab5871 ->\n@@ -1057,1 +1066,1 @@\n-            case 0x180d6925 ->\n+            case 0x7588550f ->\n@@ -1059,1 +1068,1 @@\n-            case 0x7be22752 ->\n+            case 0xcc74da30 ->\n@@ -1061,1 +1070,1 @@\n-            case 0x5299824 ->\n+            case 0xf67697f5 ->\n@@ -1063,1 +1072,1 @@\n-            case 0x3534786e ->\n+            case 0xe0837d2a ->\n@@ -1065,1 +1074,1 @@\n-            case 0xb4b4ac6 ->\n+            case 0xc945a075 ->\n@@ -1067,1 +1076,1 @@\n-            case 0x6926482 ->\n+            case 0x611a3a90 ->\n@@ -1069,1 +1078,1 @@\n-            case 0x16a42b7c ->\n+            case 0xf76fb898 ->\n@@ -1071,1 +1080,1 @@\n-            case 0x400ab245 ->\n+            case 0x6b41b047 ->\n@@ -1073,1 +1082,1 @@\n-            case 0x2af490d4 ->\n+            case 0x748c2857 ->\n@@ -1075,1 +1084,1 @@\n-            case 0x303e0c58 ->\n+            case 0x6bf13a96 ->\n@@ -1077,1 +1086,1 @@\n-            case 0x19c7d0cd ->\n+            case 0xfa85ee5a ->\n@@ -1079,1 +1088,1 @@\n-            case 0x3dc79b7a ->\n+            case 0xf2670725 ->\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":70,"deletions":61,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-                        fm.fieldTypeSymbol()), fb ->\n-                                fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+                        fm.fieldTypeSymbol()), fb -> fb.transform(fm, asFieldTransform()));\n@@ -105,2 +104,1 @@\n-                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n-                                mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb -> mb.transform(mm, asMethodTransform()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -97,0 +96,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -99,1 +100,1 @@\n-        implements Attribute<T> {\n+        implements Attribute<T>, Util.Writable {\n@@ -118,1 +119,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -648,1 +649,7 @@\n-            this.elements = List.copyOf(elements);\n+            \/\/ deep copy\n+            var array = elements.toArray().clone();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = List.copyOf((List<?>) array[i]);\n+            }\n+\n+            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n@@ -772,1 +779,1 @@\n-                                        List<AnnotationElement> elements) implements TypeAnnotation {\n+                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n@@ -789,2 +796,2 @@\n-        public void writeTo(BufWriter buf) {\n-            LabelContext lr = ((BufWriterImpl) buf).labelContext();\n+        public void writeTo(BufWriterImpl buf) {\n+            LabelContext lr = buf.labelContext();\n@@ -838,1 +845,1 @@\n-                pair.value().writeTo(buf);\n+                AnnotationReader.writeAnnotationValue(buf, pair.value());\n@@ -924,1 +931,1 @@\n-        public abstract void writeBody(BufWriter b);\n+        public abstract void writeBody(BufWriterImpl b);\n@@ -927,1 +934,1 @@\n-        public void writeTo(BufWriter b) {\n+        public void writeTo(BufWriterImpl b) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-    {\"getSigners\",       \"()[\" OBJ,         (void *)&JVM_GetClassSigners},\n-    {\"setSigners\",       \"([\" OBJ \")V\",     (void *)&JVM_SetClassSigners},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -516,1 +516,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n@@ -1558,15 +1574,0 @@\n-        public RecordComponent findRecordComponentToRemove(JCVariableDecl var) {\n-            RecordComponent toRemove = null;\n-            for (RecordComponent rc : recordComponents) {\n-                \/* it could be that a record erroneously declares two record components with the same name, in that\n-                 * case we need to use the position to disambiguate, but if we loaded the record from a class file\n-                 * all positions will be -1, in that case we have to ignore the position and match only based on the\n-                 * name\n-                 *\/\n-                if (rc.name == var.name && (var.pos == rc.pos || rc.pos == -1)) {\n-                    toRemove = rc;\n-                }\n-            }\n-            return toRemove;\n-        }\n-\n@@ -1578,3 +1579,10 @@\n-            if (existing != null) {\n-                recordComponents = List.filter(recordComponents, existing);\n-                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+            if (existing != null && !recordComponents.isEmpty()) {\n+                ListBuffer<RecordComponent> newRComps = new ListBuffer<>();\n+                for (RecordComponent rcomp : recordComponents) {\n+                    if (existing == rcomp) {\n+                        newRComps.add(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+                    } else {\n+                        newRComps.add(rcomp);\n+                    }\n+                }\n+                recordComponents = newRComps.toList();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n+\n@@ -102,0 +104,1 @@\n+    public final boolean dumpStacktraceOnError;\n@@ -128,0 +131,2 @@\n+        Options options = Options.instance(context);\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -642,1 +647,1 @@\n-    public static class FunctionDescriptorLookupError extends RuntimeException {\n+    public static class FunctionDescriptorLookupError extends CompilerInternalException {\n@@ -647,1 +652,2 @@\n-        FunctionDescriptorLookupError() {\n+        FunctionDescriptorLookupError(boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -659,6 +665,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n@@ -817,1 +817,1 @@\n-            return new FunctionDescriptorLookupError().setMessage(diag);\n+            return new FunctionDescriptorLookupError(Types.this.dumpStacktraceOnError).setMessage(diag);\n@@ -5133,1 +5133,1 @@\n-    public abstract static class SignatureGenerator {\n+    public abstract class SignatureGenerator {\n@@ -5135,1 +5135,1 @@\n-        public static class InvalidSignatureException extends RuntimeException {\n+        public class InvalidSignatureException extends CompilerInternalException {\n@@ -5140,1 +5140,2 @@\n-            InvalidSignatureException(Type type) {\n+            InvalidSignatureException(Type type, boolean dumpStackTraceOnError) {\n+                super(dumpStackTraceOnError);\n@@ -5147,6 +5148,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -5155,2 +5150,0 @@\n-        private final Types types;\n-\n@@ -5162,5 +5155,1 @@\n-        protected SignatureGenerator(Types types) {\n-            this.types = types;\n-        }\n-\n-            throw new InvalidSignatureException(t);\n+            throw new InvalidSignatureException(t, Types.this.dumpStacktraceOnError);\n@@ -5283,1 +5272,1 @@\n-                        c.name == types.names.empty; \/\/ or anonymous\n+                        c.name == Types.this.names.empty; \/\/ or anonymous\n@@ -5285,1 +5274,1 @@\n-                        ? types.erasure(outer)\n+                        ? Types.this.erasure(outer)\n@@ -5307,1 +5296,1 @@\n-                List<Type> bounds = types.getBounds(tvar);\n+                List<Type> bounds = Types.this.getBounds(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -961,1 +961,7 @@\n-        Scope scope = targetContainerType.tsym.members();\n+        Scope scope = null;\n+        try {\n+            scope = targetContainerType.tsym.members();\n+        } catch (CompletionFailure ex) {\n+            chk.completionError(pos, ex);\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5273,8 +5273,1 @@\n-        Type underlyingType =\n-                attribTree(tree.underlyingType, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (underlyingType.hasTag(PACKAGE)) {\n-            \/\/ Type annotations are not admissible on packages, but we handle packages here to\n-            \/\/ report better diagnostics later in validateAnnotatedType.\n-            result = tree.type = underlyingType;\n-            return;\n-        }\n+        Type underlyingType = attribType(tree.underlyingType, env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -42,1 +41,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -67,0 +65,1 @@\n+\n@@ -70,2 +69,0 @@\n-import javax.lang.model.type.TypeKind;\n-\n@@ -380,4 +377,0 @@\n-                } else {\n-                    if (outerThisStack.head != null &&\n-                        outerThisStack.head != _sym)\n-                        visitSymbol(outerThisStack.head);\n@@ -387,40 +380,0 @@\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            if (tree.encl == null &&\n-                c.hasOuterInstance() &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitNewClass(tree);\n-        }\n-\n-        \/** If tree refers to a qualified this or super expression\n-         *  for anything but the current class, add the outer this\n-         *  stack as a free variable.\n-         *\/\n-        public void visitSelect(JCFieldAccess tree) {\n-            if ((tree.name == names._this || tree.name == names._super) &&\n-                tree.selected.type.tsym != clazz &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitSelect(tree);\n-        }\n-\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                Symbol constructor = TreeInfo.symbol(tree.meth);\n-                ClassSymbol c = (ClassSymbol)constructor.owner;\n-                if (c.hasOuterInstance() &&\n-                    !tree.meth.hasTag(SELECT) &&\n-                    outerThisStack.head != null)\n-                    visitSymbol(outerThisStack.head);\n-            }\n-            super.visitApply(tree);\n-        }\n-\n@@ -1599,1 +1552,1 @@\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n+        Type target = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -1885,1 +1838,0 @@\n-        Symbol c = sym.owner;\n@@ -1889,1 +1841,1 @@\n-            return make.at(pos).This(c.erasure(types));\n+            return make.at(pos).This(currentClass.erasure(types));\n@@ -2689,1 +2641,1 @@\n-            super(types);\n+            types.super();\n@@ -3118,1 +3070,1 @@\n-                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);\n+                thisArg = makeThis(tree.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3335,1 +3287,1 @@\n-                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);\n+                    thisArg = makeThis(tree.meth.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3406,0 +3358,3 @@\n+        Assert.check(!type.hasTag(VOID));\n+        if (type.hasTag(NONE))\n+            return tree;\n@@ -3922,0 +3877,3 @@\n+            \/\/ represent void results as NO_TYPE, to avoid unnecessary boxing in boxIfNeeded\n+            if (currentRestype.hasTag(VOID))\n+                currentRestype = Type.noType;\n@@ -3931,331 +3889,0 @@\n-    @Override\n-    public void visitReference(JCMemberReference tree) {\n-        if (needsConversionToLambda(tree)) {\n-            \/\/ Convert to a lambda, and process as such\n-            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n-            result = translate(conv.lambda());\n-        } else {\n-            super.visitReference(tree);\n-        }\n-    }\n-    \/\/ where\n-        boolean needsVarArgsConversion(JCMemberReference tree) {\n-            return tree.varargsElement != null;\n-        }\n-\n-        \/**\n-         * @return Is this an array operation like clone()\n-         *\/\n-        boolean isArrayOp(JCMemberReference tree) {\n-            return tree.sym.owner == syms.arrayClass;\n-        }\n-\n-        boolean receiverAccessible(JCMemberReference tree) {\n-            \/\/hack needed to workaround 292 bug (7087658)\n-            \/\/when 292 issue is fixed we should remove this and change the backend\n-            \/\/code to always generate a method handle to an accessible method\n-            return tree.ownerAccessible;\n-        }\n-\n-        \/**\n-         * Erasure destroys the implementation parameter subtype\n-         * relationship for intersection types.\n-         * Have similar problems for union types too.\n-         *\/\n-        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n-            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-            for (; tl.nonEmpty(); tl = tl.tail) {\n-                Type pt = tl.head;\n-                if (isIntersectionOrUnionType(pt))\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        boolean isIntersectionOrUnionType(Type t) {\n-            switch (t.getKind()) {\n-                case INTERSECTION:\n-                case UNION:\n-                    return true;\n-                case TYPEVAR:\n-                    TypeVar tv = (TypeVar) t;\n-                    return isIntersectionOrUnionType(tv.getUpperBound());\n-            }\n-            return false;\n-        }\n-\n-        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                              Symbol currentClass) {\n-            return ((targetReference.flags() & PROTECTED) != 0 &&\n-                    targetReference.packge() != currentClass.packge());\n-        }\n-\n-        \/**\n-         * This method should be called only when target release <= 14\n-         * where LambdaMetaFactory does not spin nestmate classes.\n-         *\n-         * This method should be removed when --release 14 is not supported.\n-         *\/\n-        boolean isPrivateInOtherClass(JCMemberReference tree) {\n-            assert !target.runtimeUseNestAccess();\n-            return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                    !types.isSameType(\n-                            types.erasure(tree.sym.enclClass().asType()),\n-                            types.erasure(currentClass.asType()));\n-        }\n-\n-        \/**\n-         * Does this reference need to be converted to a lambda\n-         * (i.e. var args need to be expanded or \"super\" is used)\n-         *\/\n-        boolean needsConversionToLambda(JCMemberReference tree) {\n-            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n-                    tree.hasKind(ReferenceKind.SUPER) ||\n-                    needsVarArgsConversion(tree) ||\n-                    isArrayOp(tree) ||\n-                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n-                    !receiverAccessible(tree) ||\n-                    (tree.getMode() == ReferenceMode.NEW &&\n-                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-        }\n-\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree) {\n-            this.tree = tree;\n-        }\n-\n-        JCExpression lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                slam.wasMethodReference = true;\n-                if (receiverExpression != null) {\n-                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n-                    return make.at(tree.pos).LetExpr(\n-                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n-                } else {\n-                    return slam;\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n-                    rcvr.pos = tree.pos;\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                    : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                            makeReceiver(rcvr) :\n-                            tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-        Assert.check(meth.kind == MTH);\n-        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-        if (varargsElement != null) {\n-            Assert.check((meth.flags() & VARARGS) != 0);\n-        }\n-        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":12,"deletions":385,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n@@ -115,0 +116,1 @@\n+    final boolean dumpStacktraceOnError;\n@@ -152,0 +154,1 @@\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -592,1 +595,1 @@\n-                throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));\n+                throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))), dumpStacktraceOnError);\n@@ -601,1 +604,1 @@\n-                        throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));\n+                        throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)), dumpStacktraceOnError);\n@@ -838,1 +841,1 @@\n-                methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));\n+                getMethodCheckFailure().setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));\n@@ -850,1 +853,1 @@\n-                super(null);\n+                super(null, Resolve.this.dumpStacktraceOnError);\n@@ -859,1 +862,1 @@\n-        SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();\n+        private SharedInapplicableMethodException methodCheckFailure;\n@@ -865,0 +868,3 @@\n+        private SharedInapplicableMethodException getMethodCheckFailure() {\n+            return methodCheckFailure == null ? methodCheckFailure = new SharedInapplicableMethodException() : methodCheckFailure;\n+        }\n@@ -1044,1 +1050,1 @@\n-            throw new InapplicableMethodException(details);\n+            throw new InapplicableMethodException(details, Resolve.this.dumpStacktraceOnError);\n@@ -1400,1 +1406,1 @@\n-    public static class InapplicableMethodException extends RuntimeException {\n+    public static class InapplicableMethodException extends CompilerInternalException {\n@@ -1405,1 +1411,2 @@\n-        InapplicableMethodException(JCDiagnostic diag) {\n+        InapplicableMethodException(JCDiagnostic diag, boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -1412,6 +1419,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1052,0 +1052,1 @@\n+                int fieldPos = 0;\n@@ -1067,2 +1068,2 @@\n-                     *  First, we find the record component by comparing its name and position with current field,\n-                     *  if any, and we mark it. Then we copy the annotations to the field so that annotations applicable only to the record component\n+                     *  First, we get the record component matching the field position. Then we copy the annotations\n+                     *  to the field so that annotations applicable only to the record component\n@@ -1073,1 +1074,1 @@\n-                    RecordComponent rc = sym.findRecordComponentToRemove(field);\n+                    RecordComponent rc = getRecordComponentAt(sym, fieldPos);\n@@ -1077,2 +1078,1 @@\n-                        List<JCAnnotation> originalAnnos = tc.copy(rc.getOriginalAnnos());\n-                        field.mods.annotations = originalAnnos;\n+                        field.mods.annotations = tc.copy(rc.getOriginalAnnos());\n@@ -1085,0 +1085,1 @@\n+                    fieldPos++;\n@@ -1099,0 +1100,12 @@\n+    \/\/ where\n+        private RecordComponent getRecordComponentAt(ClassSymbol sym, int componentPos) {\n+            int i = 0;\n+            for (RecordComponent rc : sym.getRecordComponents()) {\n+                if (i == componentPos) {\n+                    return rc;\n+                }\n+                i++;\n+            }\n+            return null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        this.signatureGen = new SharedSignatureGenerator(types);\n+        this.signatureGen = new SharedSignatureGenerator();\n@@ -295,2 +295,2 @@\n-        SharedSignatureGenerator(Types types) {\n-            super(types);\n+        SharedSignatureGenerator() {\n+            types.super();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,1 +324,1 @@\n-        String nl = String.format(\"%n\");\n+        String nl = System.lineSeparator();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -154,1 +156,1 @@\n-        writeModifiers(getClassModifiers(cm.flags().flagsMask(), classModel.majorVersion(), classModel.minorVersion()));\n+        writeModifiers(getClassModifiers(cm.flags(), classModel.majorVersion(), classModel.minorVersion()));\n@@ -215,1 +217,1 @@\n-                    getClassFlags(cm.flags().flagsMask()), \"\\n\");\n+                    getClassFlags(cm.flags()), \"\\n\");\n@@ -421,1 +423,1 @@\n-        var flags = AccessFlags.ofField(f.flags().flagsMask());\n+        var flags = f.flags();\n@@ -799,3 +801,10 @@\n-    private Set<String> getClassModifiers(int mask) {\n-        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask)));\n+    private Set<String> getClassModifiers(AccessFlags flags) {\n+        var flagSet = flagsReportUnknown(flags);\n+        Set<AccessFlag> set;\n+        if (flagSet.contains(AccessFlag.INTERFACE)) {\n+            set = EnumSet.copyOf(flagSet);\n+            set.remove(AccessFlag.ABSTRACT);\n+        } else {\n+            set = flagSet;\n+        }\n+        return getModifiers(set);\n@@ -804,1 +813,1 @@\n-    private static Set<String> getClassModifiers(int mask, int majorVersion, int minorVersion) {\n+    private static Set<String> getClassModifiers(AccessFlags flags, int majorVersion, int minorVersion) {\n@@ -806,4 +815,8 @@\n-        Set<String> result = getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-        if ((mask & ACC_INTERFACE) == 0 && Source.isSupported(Source.Feature.VALUE_CLASSES, majorVersion) && previewClassFile) {\n-            result.add(\"value\");\n+        Set<AccessFlag> flagSet = flags.flags();\n+        if (flagSet.contains(AccessFlag.INTERFACE)) {\n+            flagSet = EnumSet.copyOf(flagSet);\n+            flagSet.remove(AccessFlag.ABSTRACT);\n+        } else if (Source.isSupported(Source.Feature.VALUE_CLASSES, majorVersion) && previewClassFile) {\n+          Set<String> classModifers = getModifiers(flagSet);\n+          classModifers.add(\"value\");\n+          return classModifers;\n@@ -811,1 +824,1 @@\n-        return result;\n+        return getModifiers(flagSet);\n@@ -821,10 +834,2 @@\n-    private Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n-    }\n-\n-    private Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n-    }\n-\n-    private Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n+    private Set<String> getClassFlags(AccessFlags flags) {\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-compiler\/vectorization\/TestFloat16VectorConvChain.java 8335860 generic-all\n+compiler\/interpreter\/Test6833129.java 8335266 generic-i586\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=23m -XX:MaxMetaspaceSize=23m RedefineLeakThrowable\n+ * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=25m -XX:MaxMetaspaceSize=25m RedefineLeakThrowable\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -534,2 +534,0 @@\n-javax\/management\/remote\/mandatory\/connection\/RMIConnector_NPETest.java 8267887 generic-all\n-\n@@ -614,1 +612,0 @@\n-com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java         8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -632,1 +632,0 @@\n-    com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                                                com.forEachElement(cob4::with);\n+                                                com.forEach(cob4::with);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339 8335896\n@@ -280,0 +280,21 @@\n+    @Test\n+    public void testThreadContextClassLoader(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \/\/language=java\n+                \"\"\"\n+                class ThreadContextClassLoader {\n+                    public static void main(String... args) {\n+                        var expected = ThreadContextClassLoader.class.getClassLoader();\n+                        var actual = Thread.currentThread().getContextClassLoader();\n+                        System.out.println(expected == actual);\n+                    }\n+                }\n+                \"\"\");\n+\n+        Path file = base.resolve(\"ThreadContextClassLoader.java\");\n+        String log = new JavaTask(tb)\n+                .className(file.toString())\n+                .run(Task.Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDOUT);\n+        checkEqual(\"stdout\", log.trim(), \"true\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -102,1 +102,5 @@\n-  \/\/ Make sure class name is in the correct format\n+\n+  \/\/ Returns the potentially abridged form of `str` as it would be\n+  \/\/ printed by the VM.\n+  public native String printString(String str, int maxLength);\n+\n@@ -104,0 +108,1 @@\n+    \/\/ Make sure class name is in the correct format\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}