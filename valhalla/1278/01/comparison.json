{"files":[{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -719,1 +719,1 @@\n-        <li><a href=\"PATH_TO_SPECS\/index.html\">OTHER SPECIFICATIONS \\\n+        <li><a href=\"PATH_TO_SPECS\/index.html\">OTHER SPECIFICATIONS<\/a> \\\n","filename":"make\/Docs.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-  # The '\\#' <=> '\\ 'dance is needed to keep values with space in them connected.\n-  COMMAND_LINE_VARIABLES := $(subst \\#,\\ , $(call reverse, $(subst \\ ,\\#,$(MAKEOVERRIDES))))\n+  # The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n+  COMMAND_LINE_VARIABLES := $(subst §,\\ , $(call reverse, $(subst \\ ,§,$(MAKEOVERRIDES))))\n@@ -71,3 +71,3 @@\n-  # The '\\#' <=> '\\ 'dance is needed to keep values with space in them connected.\n-  USER_MAKE_VARS := $(subst \\#,\\ , $(filter-out $(addsuffix =%, $(INIT_CONTROL_VARIABLES)), \\\n-      $(subst \\ ,\\#,$(MAKEOVERRIDES))))\n+  # The '§' <=> '\\ 'dance is needed to keep values with space in them connected.\n+  USER_MAKE_VARS := $(subst §,\\ , $(filter-out $(addsuffix =%, $(INIT_CONTROL_VARIABLES)), \\\n+      $(subst \\ ,§,$(MAKEOVERRIDES))))\n","filename":"make\/InitSupport.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,0 +73,19 @@\n+    if test \"x$ALSA_FOUND\" = xno; then\n+      # If we have sysroot set, and no explicit library location is set,\n+      # look at known locations in sysroot.\n+      if test \"x$SYSROOT\" != \"x\" && test \"x${with_alsa_lib}\" == x; then\n+        if test -f \"$SYSROOT\/usr\/lib64\/libasound.so\" && test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib64 -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI -lasound\"\n+          ALSA_FOUND=yes\n+        fi\n+      fi\n+    fi\n","filename":"make\/autoconf\/lib-alsa.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libX11.so\"\n+            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\"\n@@ -76,1 +76,1 @@\n-            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libX11.so\"\n+            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\"\n","filename":"make\/autoconf\/lib-x11.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -641,1 +641,1 @@\n-            Pattern styleAttr = Pattern.compile(\"(?<before>.*style=\\\")(?<style>[^\\\"]*)(?<after>\\\".*)\");\n+            Pattern styleAttr = Pattern.compile(\"(?s)(?<before>.*style=\\\")(?<style>[^\\\"]*)(?<after>\\\".*)\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/fixuppandoc\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-        String simpleTypeName = element.getSimpleName().toString();\n+        String simpleTypeName = packagelessCanonicalName(typeElement).replace('.', '\/');\n@@ -318,0 +318,1 @@\n+    }\n@@ -319,7 +320,5 @@\n-        private static String packagelessCanonicalName(TypeElement element) {\n-            String result = element.getSimpleName().toString();\n-            while (element.getNestingKind() == NestingKind.MEMBER) {\n-                element = (TypeElement) element.getEnclosingElement();\n-                result = element.getSimpleName().toString() + '.' + result;\n-            }\n-            return result;\n+    private static String packagelessCanonicalName(TypeElement element) {\n+        String result = element.getSimpleName().toString();\n+        while (element.getNestingKind() == NestingKind.MEMBER) {\n+            element = (TypeElement) element.getEnclosingElement();\n+            result = element.getSimpleName().toString() + '.' + result;\n@@ -327,0 +326,1 @@\n+        return result;\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/SealedGraph.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -875,0 +875,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n@@ -1514,0 +1515,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -851,0 +851,6 @@\n+            if (currentLookAndFeel.name.contains(\"GTK\")) {\n+                this.setPreferredSize(new Dimension(PREFERRED_WIDTH + 260, PREFERRED_HEIGHT + 80));\n+            } else {\n+                this.setPreferredSize(new Dimension(PREFERRED_WIDTH, PREFERRED_HEIGHT));\n+            }\n+\n@@ -852,0 +858,1 @@\n+            frame.pack();\n","filename":"src\/demo\/share\/jfc\/SwingSet2\/SwingSet2.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2740,4 +2740,1 @@\n-      \/* If we get an out-of-range offset it is a bug in the compiler,\n-         so we assert here. *\/\n-      assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), \"c2 compiler bug\");\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -3343,1 +3340,5 @@\n-      __ prfm(Address(base, disp), PSTL1KEEP);\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, 8, rscratch1);\n+      __ prfm(addr, PSTL1KEEP);\n@@ -3355,1 +3356,1 @@\n-  \/\/\/ mov envcodings\n+  \/\/ mov encodings\n@@ -4255,1 +4256,1 @@\n-operand immLoffset()\n+operand immLOffset()\n@@ -4257,1 +4258,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n+  predicate(n->get_long() >= -256 && n->get_long() <= 65520);\n@@ -5367,0 +5368,28 @@\n+operand indirectX2P(iRegL reg)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(CastX2P reg);\n+  op_cost(0);\n+  format %{ \"[$reg]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+operand indOffX2P(iRegL reg, immLOffset off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (CastX2P reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n@@ -5457,1 +5486,1 @@\n-operand indOffLN(iRegN reg, immLoffset off)\n+operand indOffLN(iRegN reg, immLOffset off)\n@@ -5690,0 +5719,11 @@\n+operand iRegL2P(iRegL reg) %{\n+\n+  op_cost(0);\n+\n+  match(CastX2P reg);\n+\n+  format %{ \"l2p($reg)\" %}\n+\n+  interface(REG_INTER)\n+%}\n+\n@@ -5706,1 +5746,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5709,1 +5749,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5712,1 +5752,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5715,1 +5755,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5720,1 +5760,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5737,0 +5777,1 @@\n+opclass iRegPorL2P(iRegP, iRegL2P);\n@@ -9852,1 +9893,1 @@\n-instruct addP_reg_reg(iRegPNoSp dst, iRegP src1, iRegL src2) %{\n+instruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n@@ -9867,1 +9908,1 @@\n-instruct addP_reg_reg_ext(iRegPNoSp dst, iRegP src1, iRegIorL2I src2) %{\n+instruct addP_reg_reg_ext(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2) %{\n@@ -9882,1 +9923,1 @@\n-instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegP src1, iRegL src2, immIScale scale) %{\n+instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegPorL2P src1, iRegL src2, immIScale scale) %{\n@@ -9897,1 +9938,1 @@\n-instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegP src1, iRegIorL2I src2, immIScale scale) %{\n+instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2, immIScale scale) %{\n@@ -9930,1 +9971,1 @@\n-instruct addP_reg_imm(iRegPNoSp dst, iRegP src1, immLAddSub src2) %{\n+instruct addP_reg_imm(iRegPNoSp dst, iRegPorL2P src1, immLAddSub src2) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":60,"deletions":19,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  ShenandoahBarrierSet::assembler()->iu_barrier(masm->masm(), newval, rscratch2);\n-\n@@ -105,4 +103,0 @@\n-  if (access.is_oop()) {\n-    value_opr = iu_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahIUBarrier || ShenandoahLoadRefBarrier) {\n+    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahLoadRefBarrier) {\n@@ -303,8 +303,0 @@\n-void ShenandoahBarrierSetAssembler::iu_barrier(MacroAssembler* masm, Register dst, Register tmp) {\n-  if (ShenandoahIUBarrier) {\n-    __ push_call_clobbered_registers();\n-    satb_write_barrier_pre(masm, noreg, dst, rthread, tmp, rscratch1, true, false);\n-    __ pop_call_clobbered_registers();\n-  }\n-}\n-\n@@ -401,2 +393,1 @@\n-    iu_barrier(masm, val, tmp1);\n-    \/\/ G1 barrier needs uncompressed oop for region cross check.\n+    \/\/ Barrier needs uncompressed oop for region cross check.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-\n-  void iu_barrier(MacroAssembler* masm, Register dst, Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,7 @@\n-    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    if (ref_addr.getMode() == Address::base_plus_offset) {\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, as_Register($mem$$base));\n+      assert_different_registers(rscratch1, $dst$$Register);\n+      ref_addr = __ legitimize_address(ref_addr, 8, rscratch1);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,7 @@\n-    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    if (ref_addr.getMode() == Address::base_plus_offset) {\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch2, as_Register($mem$$base));\n+      assert_different_registers(rscratch2, $dst$$Register);\n+      ref_addr = __ legitimize_address(ref_addr, 8, rscratch2);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,2 @@\n+#define USE_TRAMPOLINE_STUB_FIX_OWNER\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n- protected:\n-\n@@ -115,2 +113,0 @@\n-  \/\/ Helpers for runtime call arguments\/results\n-\n@@ -206,1 +202,1 @@\n-\/\/ Load float value from 'address'. The value is loaded onto the FPU register v0.\n+  \/\/ Load float value from 'address'. The value is loaded onto the FPU register v0.\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,7 @@\n-  address addr = (address)this;\n-  address destination = instruction_address() + displacement();\n+  address addr = instruction_address();\n+  address destination = addr + displacement();\n+\n+  \/\/ Performance optimization: no need to call find_blob() if it is a self-call\n+  if (destination == addr) {\n+    return destination;\n+  }\n@@ -59,2 +64,2 @@\n-  assert(cb && cb->is_nmethod(), \"sanity\");\n-  nmethod *nm = (nmethod *)cb;\n+  assert(cb != nullptr && cb->is_nmethod(), \"nmethod expected\");\n+  nmethod *nm = cb->as_nmethod();\n@@ -75,6 +80,2 @@\n-\/\/\n-\/\/ Add parameter assert_lock to switch off assertion\n-\/\/ during code generation, where no patching lock is needed.\n-void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n-  assert(!assert_lock ||\n-         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+void NativeCall::set_destination_mt_safe(address dest) {\n+  assert((Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n@@ -107,1 +108,1 @@\n-  address call_addr = addr_at(0);\n+  address call_addr = instruction_address();\n@@ -110,1 +111,2 @@\n-  assert(code != nullptr, \"Could not find the containing code blob\");\n+  assert(code != nullptr && code->is_nmethod(), \"nmethod expected\");\n+  nmethod* nm = code->as_nmethod();\n@@ -112,3 +114,2 @@\n-  address bl_destination\n-    = MacroAssembler::pd_call_destination(call_addr);\n-  if (code->contains(bl_destination) &&\n+  address bl_destination = call_addr + displacement();\n+  if (nm->stub_contains(bl_destination) &&\n@@ -118,5 +119,1 @@\n-  if (code->is_nmethod()) {\n-    return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n-  }\n-\n-  return nullptr;\n+  return trampoline_stub_Relocation::get_trampoline_for(call_addr, nm);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,0 +177,1 @@\n+  address raw_destination() const { return instruction_address() + displacement(); }\n@@ -216,3 +217,1 @@\n-\n-  \/\/ The parameter assert_lock disables the assertion during code generation.\n-  void set_destination_mt_safe(address dest, bool assert_lock = true);\n+  void set_destination_mt_safe(address dest);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,4 +63,4 @@\n-  if (NativeCall::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline) {\n-      return nativeCallTrampolineStub_at(trampoline)->destination();\n+  if (orig_addr == nullptr) {\n+    if (NativeCall::is_call_at(addr())) {\n+      NativeCall* call = nativeCall_at(addr());\n+      return call->destination();\n@@ -68,2 +68,1 @@\n-  }\n-  if (orig_addr != nullptr) {\n+  } else {\n@@ -85,5 +84,4 @@\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline) {\n-      nativeCall_at(addr())->set_destination_mt_safe(x, \/* assert_lock *\/false);\n-      return;\n-    }\n+    NativeCall* call = nativeCall_at(addr());\n+    call->set_destination(x);\n+  } else {\n+    MacroAssembler::pd_patch_instruction(addr(), x);\n@@ -91,1 +89,0 @@\n-  MacroAssembler::pd_patch_instruction(addr(), x);\n@@ -95,0 +92,12 @@\n+void trampoline_stub_Relocation::pd_fix_owner_after_move() {\n+  NativeCall* call = nativeCall_at(owner());\n+  assert(call->raw_destination() == owner(), \"destination should be empty\");\n+  address trampoline = addr();\n+  address dest = nativeCallTrampolineStub_at(trampoline)->destination();\n+  if (!Assembler::reachable_from_branch_at(owner(), dest)) {\n+    dest = trampoline;\n+  }\n+  call->set_destination(dest);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -51,11 +58,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rfp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/smallRegisterMap_aarch64.inline.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,5 +46,0 @@\n-  if (ShenandoahIUBarrier) {\n-    ShenandoahBarrierSet::assembler()->iu_barrier(masm->masm(), new_val, tmp1, tmp2,\n-                                                  MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS);\n-  }\n-\n@@ -125,4 +120,0 @@\n-  if (access.is_oop()) {\n-    value_opr = iu_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_ppc.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,14 +64,0 @@\n-void ShenandoahBarrierSetAssembler::iu_barrier(MacroAssembler *masm,\n-                                               Register val,\n-                                               Register tmp1, Register tmp2,\n-                                               MacroAssembler::PreservationLevel preservation_level,\n-                                               DecoratorSet decorators) {\n-  \/\/ IU barriers are also employed to avoid resurrection of weak references,\n-  \/\/ even if Shenandoah does not operate in incremental update mode.\n-  if (ShenandoahIUBarrier || ShenandoahSATBBarrier) {\n-    __ block_comment(\"iu_barrier (shenandoahgc) {\");\n-    satb_write_barrier_impl(masm, decorators, noreg, noreg, val, tmp1, tmp2, preservation_level);\n-    __ block_comment(\"} iu_barrier (shenandoahgc)\");\n-  }\n-}\n-\n@@ -113,1 +99,1 @@\n-  if ((!ShenandoahSATBBarrier || dest_uninitialized) && !ShenandoahIUBarrier && !ShenandoahLoadRefBarrier) {\n+  if ((!ShenandoahSATBBarrier || dest_uninitialized) && !ShenandoahLoadRefBarrier) {\n@@ -585,1 +571,5 @@\n-    iu_barrier(masm, dst, tmp1, tmp2, preservation_level);\n+    if (ShenandoahSATBBarrier) {\n+      __ block_comment(\"keep_alive_barrier (shenandoahgc) {\");\n+      satb_write_barrier_impl(masm, 0, noreg, noreg, dst, tmp1, tmp2, preservation_level);\n+      __ block_comment(\"} keep_alive_barrier (shenandoahgc)\");\n+    }\n@@ -600,4 +590,0 @@\n-\n-    if (ShenandoahIUBarrier && val != noreg) {\n-      iu_barrier(masm, val, tmp1, tmp2, preservation_level, decorators);\n-    }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -85,5 +85,0 @@\n-  void iu_barrier(MacroAssembler* masm,\n-                        Register val,\n-                        Register tmp1, Register tmp2,\n-                        MacroAssembler::PreservationLevel preservation_level, DecoratorSet decorators = 0);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,2 +38,5 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-public:\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n+\n@@ -47,13 +54,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-#ifdef ASSERT\n-  for(int i = 0; i < RegisterMap::reg_count; i++) {\n-    VMReg r = VMRegImpl::as_VMReg(i);\n-    if (map->location(r, (intptr_t*)nullptr) != nullptr) {\n-      assert(false, \"Reg: %s\", r->name()); \/\/ Should not reach here\n-    }\n-  }\n-#endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1418,0 +1418,4 @@\n+  \/\/ Vector Widening Integer Reduction Instructions\n+  INSN(vwredsum_vs,    0b1010111, 0b000, 0b110001);\n+  INSN(vwredsumu_vs,   0b1010111, 0b000, 0b110000);\n+\n@@ -1456,0 +1460,4 @@\n+  \/\/ Vector Widening Integer Multiply Instructions\n+  INSN(vwmul_vv,    0b1010111, 0b010, 0b111011);\n+  INSN(vwmulu_vv,   0b1010111, 0b010, 0b111000);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  address call = __ trampoline_call(resolve);\n+  address call = __ reloc_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-  address call = __ trampoline_call(Address(op->addr(), rtype));\n+  address call = __ reloc_call(Address(op->addr(), rtype));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    _call_stub_size = 14 * NativeInstruction::instruction_size +\n-                      (NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size),\n+    _call_stub_size = 14 * MacroAssembler::instruction_size +\n+                      (MacroAssembler::instruction_size + MacroAssembler::NativeShortCall::trampoline_size),\n@@ -79,2 +79,2 @@\n-    _deopt_handler_size = 1 * NativeInstruction::instruction_size +\n-                          6 * NativeInstruction::instruction_size \/\/ or smaller\n+    _deopt_handler_size = 1 * MacroAssembler::instruction_size +\n+                          6 * MacroAssembler::instruction_size \/\/ or smaller\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1043,1 +1043,1 @@\n-  address call = trampoline_call(stub);\n+  address call = reloc_call(stub);\n@@ -1481,1 +1481,1 @@\n-  address call = trampoline_call(stub);\n+  address call = reloc_call(stub);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  assert(UseTrampolines, \"We are not using trampolines\");\n@@ -57,1 +58,1 @@\n-    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_reloc_call_stub_size(), \"pre-allocated trampolines\");\n@@ -63,1 +64,1 @@\n-    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    address reloc_pc = cb->stubs()->end() - MacroAssembler::NativeShortCall::trampoline_size;\n@@ -73,1 +74,1 @@\n-  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  const int total_requested_size = MacroAssembler::max_reloc_call_stub_size() * requests->number_of_entries();\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static constexpr bool supports_shared_stubs() { return true; }\n+  static bool supports_shared_stubs() { return UseTrampolines; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-  \/\/ Somewhat pessimistically, we count 4 instructions here (although\n-  \/\/ there are only 3) because we sometimes emit an alignment nop.\n+  \/\/ We count instructions and an additional alignment nop.\n@@ -75,1 +74,1 @@\n-  return MacroAssembler::max_trampoline_stub_size();\n+  return MacroAssembler::max_reloc_call_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  ShenandoahBarrierSet::assembler()->iu_barrier(masm->masm(), newval, t1);\n-\n@@ -97,4 +95,0 @@\n-  if (access.is_oop()) {\n-    value_opr = iu_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_riscv.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahIUBarrier || ShenandoahLoadRefBarrier) {\n+    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahLoadRefBarrier) {\n@@ -311,10 +311,0 @@\n-void ShenandoahBarrierSetAssembler::iu_barrier(MacroAssembler* masm, Register dst, Register tmp) {\n-  if (ShenandoahIUBarrier) {\n-    __ push_call_clobbered_registers();\n-\n-    satb_write_barrier_pre(masm, noreg, dst, xthread, tmp, t0, true, false);\n-\n-    __ pop_call_clobbered_registers();\n-  }\n-}\n-\n@@ -423,2 +413,1 @@\n-    iu_barrier(masm, val, tmp1);\n-    \/\/ G1 barrier needs uncompressed oop for region cross check.\n+    \/\/ Barrier needs uncompressed oop for region cross check.\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -66,2 +66,0 @@\n-  void iu_barrier(MacroAssembler* masm, Register dst, Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,3 @@\n-          \"Use RVV instructions for left\/right shift of BigInteger\")\n+          \"Use RVV instructions for left\/right shift of BigInteger\")             \\\n+  product(bool, UseTrampolines, false, EXPERIMENTAL,                             \\\n+          \"Far calls uses jal to trampoline.\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    return pc_offset + NativeCall::instruction_size;\n+    return pc_offset + NativeCall::byte_size();\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -981,0 +981,10 @@\n+void MacroAssembler::load_link_jump(const address source, Register temp) {\n+  assert(temp != noreg && temp != x0, \"expecting a register\");\n+  assert_cond(source != nullptr);\n+  int64_t distance = source - pc();\n+  assert(is_simm32(distance), \"Must be\");\n+  auipc(temp, (int32_t)distance + 0x800);\n+  ld(temp, Address(temp, ((int32_t)distance << 20) >> 20));\n+  jalr(temp);\n+}\n+\n@@ -982,0 +992,1 @@\n+  assert(UseTrampolines, \"Must be\");\n@@ -984,27 +995,3 @@\n-  if (is_simm21(distance) && ((distance % 2) == 0)) {\n-    Assembler::jal(x1, distance);\n-  } else {\n-    assert(temp != noreg && temp != x0, \"expecting a register\");\n-    int32_t offset = 0;\n-    la(temp, dest, offset);\n-    jalr(temp, offset);\n-  }\n-}\n-\n-void MacroAssembler::jump_link(const Address &adr, Register temp) {\n-  switch (adr.getMode()) {\n-    case Address::literal: {\n-      relocate(adr.rspec(), [&] {\n-        jump_link(adr.target(), temp);\n-      });\n-      break;\n-    }\n-    case Address::base_plus_offset: {\n-      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n-      la(temp, Address(adr.base(), adr.offset() - offset));\n-      jalr(temp, offset);\n-      break;\n-    }\n-    default:\n-      ShouldNotReachHere();\n-  }\n+  assert(is_simm21(distance), \"Must be\");\n+  assert((distance % 2) == 0, \"Must be\");\n+  jal(x1, distance);\n@@ -3944,9 +3931,1 @@\n-  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n-  if (stub_is_near) {\n-    jump_link(stub, t0);\n-  } else {\n-    address call = trampoline_call(stub);\n-    if (call == nullptr) {\n-      return false; \/\/ trampoline allocation failed\n-    }\n-  }\n+  rt_call(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n@@ -4261,0 +4240,30 @@\n+address MacroAssembler::load_and_call(Address entry) {\n+  assert(entry.rspec().type() == relocInfo::runtime_call_type ||\n+         entry.rspec().type() == relocInfo::opt_virtual_call_type ||\n+         entry.rspec().type() == relocInfo::static_call_type ||\n+         entry.rspec().type() == relocInfo::virtual_call_type, \"wrong reloc type\");\n+\n+  address target = entry.target();\n+\n+  if (!in_scratch_emit_size()) {\n+    address stub = emit_address_stub(offset(), target);\n+    if (stub == nullptr) {\n+      postcond(pc() == badAddress);\n+      return nullptr; \/\/ CodeCache is full\n+    }\n+  }\n+\n+  address call_pc = pc();\n+#ifdef ASSERT\n+  if (entry.rspec().type() != relocInfo::runtime_call_type) {\n+    assert_alignment(call_pc);\n+  }\n+#endif\n+  relocate(entry.rspec(), [&] {\n+    load_link_jump(target);\n+  });\n+\n+  postcond(pc() != badAddress);\n+  return call_pc;\n+}\n+\n@@ -4266,1 +4275,1 @@\n-  return trampoline_call(Address(entry, rh));\n+  return reloc_call(Address(entry, rh));\n@@ -4311,0 +4320,28 @@\n+address MacroAssembler::emit_address_stub(int insts_call_instruction_offset, address dest) {\n+  address stub = start_a_stub(max_reloc_call_stub_size());\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n+  }\n+\n+  \/\/ We are always 4-byte aligned here.\n+  assert_alignment(pc());\n+\n+  \/\/ Make sure the address of destination 8-byte aligned.\n+  align(wordSize, 0);\n+\n+  RelocationHolder rh = trampoline_stub_Relocation::spec(code()->insts()->start() +\n+                                                         insts_call_instruction_offset);\n+  const int stub_start_offset = offset();\n+  relocate(rh, [&] {\n+    assert(offset() - stub_start_offset == 0,\n+           \"%ld - %ld == %ld : should be\", (long)offset(), (long)stub_start_offset, (long)0);\n+    assert(offset() % wordSize == 0, \"bad alignment\");\n+    emit_int64((int64_t)dest);\n+  });\n+\n+  const address stub_start_addr = addr_at(stub_start_offset);\n+  end_a_stub();\n+\n+  return stub_start_addr;\n+}\n+\n@@ -4325,1 +4362,1 @@\n-  address stub = start_a_stub(max_trampoline_stub_size());\n+  address stub = start_a_stub(max_reloc_call_stub_size());\n@@ -4330,0 +4367,2 @@\n+  assert(UseTrampolines, \"Must be using trampos.\");\n+\n@@ -4338,1 +4377,1 @@\n-  align(wordSize, MacroAssembler::trampoline_stub_data_offset);\n+  align(wordSize, MacroAssembler::NativeShortCall::trampoline_data_offset);\n@@ -4351,1 +4390,1 @@\n-    assert(offset() - stub_start_offset == MacroAssembler::trampoline_stub_data_offset,\n+    assert(offset() - stub_start_offset == MacroAssembler::NativeShortCall::trampoline_data_offset,\n@@ -4359,2 +4398,0 @@\n-  assert(MacroAssembler::is_trampoline_stub_at(stub_start_addr), \"doesn't look like a trampoline\");\n-\n@@ -4362,0 +4399,1 @@\n+\n@@ -4365,1 +4403,1 @@\n-int MacroAssembler::max_trampoline_stub_size() {\n+int MacroAssembler::max_reloc_call_stub_size() {\n@@ -4367,1 +4405,4 @@\n-  return MacroAssembler::instruction_size + MacroAssembler::trampoline_stub_instruction_size;\n+  if (UseTrampolines) {\n+    return instruction_size + MacroAssembler::NativeShortCall::trampoline_size;\n+  }\n+  return instruction_size + wordSize;\n@@ -5086,1 +5127,1 @@\n-      address tpc = trampoline_call(zero_blocks);\n+      address tpc = reloc_call(zero_blocks);\n@@ -5093,1 +5134,1 @@\n-      jump_link(zero_blocks, t0);\n+      rt_call(zero_blocks.target());\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":87,"deletions":46,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -469,0 +469,1 @@\n+  address emit_address_stub(int insts_call_instruction_offset, address target);\n@@ -470,1 +471,2 @@\n-  static int max_trampoline_stub_size();\n+  static int max_reloc_call_stub_size();\n+\n@@ -626,0 +628,1 @@\n+  void load_link_jump(const address source, Register temp = t0);\n@@ -627,1 +630,0 @@\n-  void jump_link(const Address &adr, Register temp);\n@@ -1208,1 +1210,21 @@\n-  \/\/   - trampoline call:\n+  \/\/   - indirect call: movptr + jalr\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/   - reloc call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod).\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       auipc\n+  \/\/       ld <address_from_stub_section>\n+  \/\/       jalr\n+  \/\/     [Stub section]\n+  \/\/     trampoline:\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/    To change the destination we simply atomically store the new\n+  \/\/    address in the stub section.\n+  \/\/\n+  \/\/ - trampoline call (old reloc call \/ -XX:+UseTrampolines):\n@@ -1227,1 +1249,1 @@\n-\n+  \/\/\n@@ -1232,7 +1254,0 @@\n-  \/\/   - indirect call: movptr + jalr\n-  \/\/     This too can reach anywhere in the address space, but it cannot be\n-  \/\/     patched while code is running, so it must only be modified at a safepoint.\n-  \/\/     This form of call is most suitable for targets at fixed addresses, which\n-  \/\/     will never be patched.\n-  \/\/\n-  \/\/\n@@ -1251,0 +1266,1 @@\n+  \/\/ --\n@@ -1253,1 +1269,1 @@\n-  \/\/ otherwise a trampoline call.\n+  \/\/ otherwise a reloc call.\n@@ -1261,0 +1277,4 @@\n+  address reloc_call(Address entry) {\n+    return UseTrampolines ? trampoline_call(entry) : load_and_call(entry);\n+  }\n+ private:\n@@ -1262,0 +1282,2 @@\n+  address load_and_call(Address entry);\n+ public:\n@@ -1588,4 +1610,0 @@\n-    \/\/ Refer to function emit_trampoline_stub.\n-    trampoline_stub_instruction_size = 3 * instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    trampoline_stub_data_offset      = 3 * instruction_size,            \/\/ auipc + ld + jr\n-\n@@ -1598,0 +1616,5 @@\n+  enum NativeShortCall {\n+    trampoline_size        = 3 * instruction_size + wordSize,\n+    trampoline_data_offset = 3 * instruction_size\n+  };\n+\n@@ -1601,32 +1624,0 @@\n-  static bool is_trampoline_stub_at(address addr) {\n-    \/\/ Ensure that the stub is exactly\n-    \/\/      ld   t0, L--->auipc + ld\n-    \/\/      jr   t0\n-    \/\/ L:\n-\n-    \/\/ judge inst + register + imm\n-    \/\/ 1). check the instructions: auipc + ld + jalr\n-    \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-    \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-    assert_cond(addr != nullptr);\n-    const int instr_size = instruction_size;\n-    if (is_auipc_at(addr) &&\n-        is_ld_at(addr + instr_size) &&\n-        is_jalr_at(addr + 2 * instr_size) &&\n-        (extract_rd(addr)                    == x5) &&\n-        (extract_rd(addr + instr_size)       == x5) &&\n-        (extract_rs1(addr + instr_size)      == x5) &&\n-        (extract_rs1(addr + 2 * instr_size)  == x5) &&\n-        (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_stub_data_offset)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_call_at(address instr) {\n-    if (is_jal_at(instr) || is_jalr_at(instr)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n@@ -1667,1 +1658,0 @@\n-private:\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":39,"deletions":49,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -42,2 +42,5 @@\n-void NativeCall::verify() {\n-  assert(MacroAssembler::is_call_at((address)this), \"unexpected code at call site\");\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeInstruction\n+\n+bool NativeInstruction::is_call_at(address addr) {\n+  return NativeCall::is_at(addr);\n@@ -46,2 +49,99 @@\n-address NativeCall::destination() const {\n-  address addr = (address)this;\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCallTrampoline\n+\/\/\n+\/\/ Implements the trampoline part of reloc call - trampoline call.\n+\n+class NativeShortCall;\n+\n+class NativeShortCallTrampolineStub : public NativeInstruction {\n+ private:\n+  friend NativeShortCall;\n+  enum RISCV_specific_constants {\n+    trampoline_data_offset = 3 * NativeInstruction::instruction_size \/\/ auipc + ld + jr\n+  };\n+\n+  address destination() const;\n+  void set_destination(address new_destination);\n+\n+  static bool is_at(address addr);\n+  static NativeShortCallTrampolineStub* at(address addr);\n+};\n+\n+address NativeShortCallTrampolineStub::destination() const {\n+  return ptr_at(trampoline_data_offset);\n+}\n+\n+void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n+  set_ptr_at(trampoline_data_offset, new_destination);\n+  OrderAccess::release();\n+}\n+\n+bool NativeShortCallTrampolineStub::is_at(address addr) {\n+  \/\/ Ensure that the stub is exactly\n+  \/\/      ld   t0, L--->auipc + ld\n+  \/\/      jr   t0\n+  \/\/ L:\n+\n+  \/\/ judge inst + register + imm\n+  \/\/ 1). check the instructions: auipc + ld + jalr\n+  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x5) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_data_offset)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n+  return (NativeShortCallTrampolineStub*)addr;\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCall\n+\/\/\n+\/\/ Implements the trampoline call, a short call with a trampoline, version of reloc call.\n+\/\/ Enabled by setting the experimental UseTrampolines to true.\n+\n+class NativeShortCall: private NativeInstruction {\n+ public:\n+  enum RISCV_specific_constants {\n+    return_address_offset       =    1 * NativeInstruction::instruction_size \/\/ jal\n+  };\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address get_trampoline();\n+  bool has_trampoline();\n+  address trampoline_destination();\n+ public:\n+\n+  static NativeShortCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+};\n+\n+address NativeShortCall::destination() const {\n+  address addr = instruction_address();\n@@ -49,0 +149,1 @@\n+\n@@ -55,1 +156,1 @@\n-  if (nm != nullptr && nm->stub_contains(destination) && MacroAssembler::is_trampoline_stub_at(destination)) {\n+  if (nm != nullptr && nm->stub_contains(destination) && NativeShortCallTrampolineStub::is_at(destination)) {\n@@ -58,1 +159,1 @@\n-    destination = nativeCallTrampolineStub_at(trampoline_stub_addr)->destination();\n+    destination = NativeShortCallTrampolineStub::at(trampoline_stub_addr)->destination();\n@@ -64,3 +165,49 @@\n-\/\/ Similar to replace_mt_safe, but just changes the destination. The\n-\/\/ important thing is that free-running threads are able to execute this\n-\/\/ call instruction at all times.\n+address NativeShortCall::reloc_destination(address orig_address) {\n+  address addr = instruction_address();\n+  if (NativeShortCall::is_at(addr)) {\n+    NativeShortCall* call = NativeShortCall::at(addr);\n+    if (call->has_trampoline()) {\n+      return call->trampoline_destination();\n+    }\n+  }\n+  if (orig_address != nullptr) {\n+    \/\/ the extracted address from the instructions in address orig_addr\n+    address new_addr = MacroAssembler::pd_call_destination(orig_address);\n+    \/\/ If call is branch to self, don't try to relocate it, just leave it\n+    \/\/ as branch to self. This happens during code generation if the code\n+    \/\/ buffer expands. It will be relocated to the trampoline above once\n+    \/\/ code generation is complete.\n+    new_addr = (new_addr == orig_address) ? addr : new_addr;\n+    return new_addr;\n+  }\n+  return MacroAssembler::pd_call_destination(addr);\n+}\n+\n+void NativeShortCall::set_destination(address dest) {\n+  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  assert(is_jal(), \"Should be jal instruction!\");\n+  intptr_t offset = (intptr_t)(dest - instruction_address());\n+  assert((offset & 0x1) == 0, \"bad alignment\");\n+  assert(Assembler::is_simm21(offset), \"encoding constraint\");\n+  unsigned int insn = 0b1101111; \/\/ jal\n+  address pInsn = (address)(&insn);\n+  Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n+  Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n+  Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n+  Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n+  Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n+  set_int_at(0, insn);\n+}\n+\n+void NativeShortCall::verify() {\n+  assert(NativeShortCall::is_at(instruction_address()),\n+         \"unexpected code at call site: %p\", instruction_address());\n+}\n+\n+void NativeShortCall::print() {\n+  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": jal\/auipc,ld,jalr x1, offset\/reg\", p2i(instruction_address()));\n+}\n+\n+\/\/ The important thing is that threads are able to execute this\n+\/\/ call instruction at all times. (cmodx)\n@@ -72,1 +219,1 @@\n-void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+bool NativeShortCall::set_destination_mt_safe(address dest, bool assert_lock) {\n@@ -75,1 +222,1 @@\n-         CompiledICLocker::is_safe(addr_at(0)),\n+         CompiledICLocker::is_safe(instruction_address()),\n@@ -78,2 +225,12 @@\n-  address addr_call = addr_at(0);\n-  assert(MacroAssembler::is_call_at(addr_call), \"unexpected code at call site\");\n+  address call_addr = instruction_address();\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  reloc_set_destination(dest);\n+\n+  ICache::invalidate_range(call_addr, instruction_size);\n+  return true;\n+}\n+\n+bool NativeShortCall::reloc_set_destination(address dest) {\n+  address call_addr = instruction_address();\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n@@ -84,2 +241,2 @@\n-    assert (!MacroAssembler::is_trampoline_stub_at(dest), \"chained trampolines\");\n-    nativeCallTrampolineStub_at(trampoline_stub_addr)->set_destination(dest);\n+    assert(!NativeShortCallTrampolineStub::is_at(dest), \"chained trampolines\");\n+    NativeShortCallTrampolineStub::at(trampoline_stub_addr)->set_destination(dest);\n@@ -89,1 +246,1 @@\n-  if (Assembler::reachable_from_branch_at(addr_call, dest)) {\n+  if (Assembler::reachable_from_branch_at(call_addr, dest)) {\n@@ -96,1 +253,1 @@\n-  ICache::invalidate_range(addr_call, instruction_size);\n+  return true;\n@@ -99,2 +256,2 @@\n-address NativeCall::get_trampoline() {\n-  address call_addr = addr_at(0);\n+address NativeShortCall::get_trampoline() {\n+  address call_addr = instruction_address();\n@@ -106,1 +263,1 @@\n-  if (code != nullptr && code->contains(jal_destination) && MacroAssembler::is_trampoline_stub_at(jal_destination)) {\n+  if (code != nullptr && code->contains(jal_destination) && NativeShortCallTrampolineStub::is_at(jal_destination)) {\n@@ -117,2 +274,320 @@\n-\/\/ Inserts a native call instruction at a given pc\n-void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }\n+bool NativeShortCall::has_trampoline() {\n+  return NativeShortCall::get_trampoline() != nullptr;\n+}\n+\n+address NativeShortCall::trampoline_destination() {\n+  return NativeShortCallTrampolineStub::at(get_trampoline())->destination();\n+}\n+\n+NativeShortCall* NativeShortCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeShortCall* call = (NativeShortCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeShortCall::is_at(address addr) {\n+  if (MacroAssembler::is_jal_at(addr)) {\n+    if (MacroAssembler::extract_rd(addr)  == x1) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool NativeShortCall::is_call_before(address return_address) {\n+  return NativeShortCall::is_at(return_address - instruction_size);\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeFarCall\n+\/\/\n+\/\/ Implements direct far calling loading an address from the stub section version of reloc call.\n+\/\/ This is the default (experimental flag UseTrampolines, default false).\n+\n+class NativeFarCall: public NativeInstruction {\n+ public:\n+  enum RISCV_specific_constants {\n+    return_address_offset       =    3 * NativeInstruction::instruction_size, \/\/ auipc + ld + jalr\n+  };\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address stub_address();\n+\n+  static void set_stub_address_destination_at(address dest, address value);\n+  static address stub_address_destination_at(address src);\n+ public:\n+\n+  static NativeFarCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+};\n+\n+address NativeFarCall::destination() const {\n+  address addr = instruction_address();\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+\n+  address destination = MacroAssembler::target_addr_for_insn(addr);\n+\n+  CodeBlob* cb = CodeCache::find_blob(addr);\n+  assert(cb && cb->is_nmethod(), \"sanity\");\n+  nmethod *nm = (nmethod *)cb;\n+  assert(nm != nullptr, \"Sanity\");\n+  assert(nm->stub_contains(destination), \"Sanity\");\n+  assert(destination != nullptr, \"Sanity\");\n+  return stub_address_destination_at(destination);\n+}\n+\n+address NativeFarCall::reloc_destination(address orig_address) {\n+  address call_addr = instruction_address();\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address stub_addr = nullptr;\n+  if (code != nullptr && code->is_nmethod()) {\n+    stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+  }\n+\n+  if (stub_addr != nullptr) {\n+    stub_addr = MacroAssembler::target_addr_for_insn(call_addr);\n+  }\n+  return stub_addr;\n+}\n+\n+void NativeFarCall::set_destination(address dest) {\n+  address addr = instruction_address();\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+  Unimplemented();\n+}\n+\n+void NativeFarCall::verify() {\n+  assert(NativeFarCall::is_at(instruction_address()), \"unexpected code at call site\");\n+}\n+\n+void NativeFarCall::print() {\n+  assert(NativeFarCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": auipc,ld,jalr x1, offset\/reg, \", p2i(addr_at(0)));\n+}\n+\n+bool NativeFarCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  assert(NativeFarCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  assert(!assert_lock ||\n+         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         CompiledICLocker::is_safe(addr_at(0)),\n+         \"concurrent code patching\");\n+\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  address stub_addr = stub_address();\n+\n+  if (stub_addr != nullptr) {\n+    set_stub_address_destination_at(stub_addr, dest);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool NativeFarCall::reloc_set_destination(address dest) {\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address stub_addr = nullptr;\n+  if (code != nullptr && code->is_nmethod()) {\n+    stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+  }\n+\n+  if (stub_addr != nullptr) {\n+    MacroAssembler::pd_patch_instruction_size(call_addr, stub_addr);\n+  }\n+\n+  return true;\n+}\n+\n+void NativeFarCall::set_stub_address_destination_at(address dest, address value) {\n+  assert_cond(dest != nullptr);\n+  assert_cond(value != nullptr);\n+\n+  set_data64_at(dest, (uint64_t)value);\n+  OrderAccess::release();\n+}\n+\n+address NativeFarCall::stub_address_destination_at(address src) {\n+  assert_cond(src != nullptr);\n+  address dest = (address)get_data64_at(src);\n+  return dest;\n+}\n+\n+address NativeFarCall::stub_address() {\n+  address call_addr = addr_at(0);\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address dest = MacroAssembler::pd_call_destination(call_addr);\n+  assert(code->contains(dest), \"Sanity\");\n+  return dest;\n+}\n+\n+NativeFarCall* NativeFarCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeFarCall* call = (NativeFarCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeFarCall::is_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x5) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (MacroAssembler::extract_rd(addr + 2 * instr_size)  == x1)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool NativeFarCall::is_call_before(address return_address) {\n+  return NativeFarCall::is_at(return_address - return_address_offset);\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeCall\n+\n+address NativeCall::instruction_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->instruction_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->instruction_address();\n+  }\n+}\n+\n+address NativeCall::next_instruction_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->next_instruction_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->next_instruction_address();\n+  }\n+}\n+\n+address NativeCall::return_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->return_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->return_address();\n+  }\n+}\n+\n+address NativeCall::destination() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->destination();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->destination();\n+  }\n+}\n+\n+address NativeCall::reloc_destination(address orig_address) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->reloc_destination(orig_address);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->reloc_destination(orig_address);\n+  }\n+}\n+\n+void NativeCall::set_destination(address dest) {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->set_destination(dest);\n+  } else {\n+    NativeFarCall::at(addr_at(0))->set_destination(dest);\n+  }\n+}\n+\n+void NativeCall::verify() {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->verify();\n+  } else {\n+    NativeFarCall::at(addr_at(0))->verify();;\n+  }\n+}\n+\n+void NativeCall::print() {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->print();\n+  } else {\n+    NativeFarCall::at(addr_at(0))->print();;\n+  }\n+}\n+\n+bool NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  }\n+}\n+\n+bool NativeCall::reloc_set_destination(address dest) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->reloc_set_destination(dest);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->reloc_set_destination(dest);\n+  }\n+}\n+\n+bool NativeCall::is_at(address addr) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::is_at(addr);\n+  } else {\n+    return NativeFarCall::is_at(addr);\n+  }\n+}\n+\n+bool NativeCall::is_call_before(address return_address) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::is_call_before(return_address);\n+  } else {\n+    return NativeFarCall::is_call_before(return_address);\n+  }\n+}\n+\n+NativeCall* nativeCall_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  NativeCall* call = (NativeCall*)(addr);\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n+\n+NativeCall* nativeCall_before(address return_address) {\n+  assert_cond(return_address != nullptr);\n+  NativeCall* call = nullptr;\n+  if (UseTrampolines) {\n+    call = (NativeCall*)(return_address - NativeShortCall::return_address_offset);\n+  } else {\n+    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n+  }\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n@@ -330,9 +805,0 @@\n-address NativeCallTrampolineStub::destination(nmethod *nm) const {\n-  return ptr_at(data_offset);\n-}\n-\n-void NativeCallTrampolineStub::set_destination(address new_destination) {\n-  set_ptr_at(data_offset, new_destination);\n-  OrderAccess::release();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":497,"deletions":31,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\/\/ - - NativeCallTrampolineStub\n-\/\/ - - NativeMembar\n@@ -72,1 +70,0 @@\n-  bool is_call()                            const { return MacroAssembler::is_call_at(addr_at(0));        }\n@@ -74,0 +71,2 @@\n+  bool is_call()                            const { return is_call_at(addr_at(0));                        }\n+  static bool is_call_at(address addr);\n@@ -75,2 +74,2 @@\n-  inline bool is_nop() const;\n-  inline bool is_jump_or_nop();\n+  bool is_nop() const;\n+  bool is_jump_or_nop();\n@@ -82,1 +81,5 @@\n-  address addr_at(int offset) const    { return address(this) + offset; }\n+  address addr_at(int offset) const { return address(this) + offset; }\n+  jint     int_at(int offset) const { return (jint)      Bytes::get_native_u4(addr_at(offset));  }\n+  juint   uint_at(int offset) const { return             Bytes::get_native_u4(addr_at(offset));  }\n+  address  ptr_at(int offset) const { return (address)   Bytes::get_native_u8(addr_at(offset));  }\n+  oop      oop_at(int offset) const { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n@@ -84,2 +87,0 @@\n-  jint int_at(int offset) const        { return (jint)Bytes::get_native_u4(addr_at(offset)); }\n-  juint uint_at(int offset) const      { return Bytes::get_native_u4(addr_at(offset)); }\n@@ -87,1 +88,4 @@\n-  address ptr_at(int offset) const     { return (address)Bytes::get_native_u8(addr_at(offset)); }\n+  void  set_int_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void set_uint_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void  set_ptr_at(int offset, address ptr) { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n+  void  set_oop_at(int offset, oop o)       { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n@@ -89,7 +93,2 @@\n-  oop  oop_at (int offset) const       { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n-\n-\n-  void set_int_at(int offset, jint i)        { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_uint_at(int offset, jint i)       { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_ptr_at (int offset, address ptr)  { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n-  void set_oop_at (int offset, oop o)        { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n+  static void     set_data64_at(address dest, uint64_t data) { Bytes::put_native_u8(dest, (u8)data); }\n+  static uint64_t get_data64_at(address src)                 { return Bytes::get_native_u8(src); }\n@@ -106,1 +105,1 @@\n-inline NativeInstruction* nativeInstruction_at(address addr) {\n+NativeInstruction* nativeInstruction_at(address addr) {\n@@ -110,4 +109,2 @@\n-\/\/ The natural type of an RISCV instruction is uint32_t\n-inline NativeInstruction* nativeInstruction_at(uint32_t *addr) {\n-  return (NativeInstruction*)addr;\n-}\n+NativeCall* nativeCall_at(address addr);\n+NativeCall* nativeCall_before(address return_address);\n@@ -115,1 +112,0 @@\n-inline NativeCall* nativeCall_at(address addr);\n@@ -119,8 +115,8 @@\n-\n-class NativeCall: public NativeInstruction {\n- public:\n-  enum RISCV_specific_constants {\n-    instruction_size            =    4,\n-    instruction_offset          =    0,\n-    displacement_offset         =    0,\n-    return_address_offset       =    4\n+class NativeCall: private NativeInstruction {\n+ \/\/ private: when common code is using byte_size()\n+ private:\n+  enum {\n+    \/\/ Use byte_size() as it can be changed in runtime\n+    \/\/ Since instruction_size exists on NativeInstruction we need\n+    \/\/ to overload and hide it.\n+    instruction_size = 3 * Assembler::instruction_size \/\/ auipc + ld + jalr\n@@ -128,0 +124,1 @@\n+ public:\n@@ -129,19 +126,6 @@\n-  static int byte_size()                    { return instruction_size; }\n-  address instruction_address() const       { return addr_at(instruction_offset); }\n-  address next_instruction_address() const  { return addr_at(return_address_offset); }\n-  address return_address() const            { return addr_at(return_address_offset); }\n-  address destination() const;\n-\n-  void set_destination(address dest) {\n-    assert(is_jal(), \"Should be jal instruction!\");\n-    intptr_t offset = (intptr_t)(dest - instruction_address());\n-    assert((offset & 0x1) == 0, \"bad alignment\");\n-    assert(Assembler::is_simm21(offset), \"encoding constraint\");\n-    unsigned int insn = 0b1101111; \/\/ jal\n-    address pInsn = (address)(&insn);\n-    Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n-    Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n-    Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n-    Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n-    Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n-    set_int_at(displacement_offset, insn);\n+  static int byte_size() {\n+    if (UseTrampolines) {\n+      return NativeInstruction::instruction_size; \/\/ jal\n+    } else {\n+      return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n+    }\n@@ -149,0 +133,9 @@\n+  \/\/ Creation\n+  friend NativeCall* nativeCall_at(address addr);\n+  friend NativeCall* nativeCall_before(address return_address);\n+\n+  address instruction_address() const;\n+  address next_instruction_address() const;\n+  address return_address() const;\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n@@ -154,3 +147,3 @@\n-  \/\/ Creation\n-  inline friend NativeCall* nativeCall_at(address addr);\n-  inline friend NativeCall* nativeCall_before(address return_address);\n+  void set_destination(address dest);\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n@@ -158,25 +151,2 @@\n-  static bool is_call_before(address return_address) {\n-    return MacroAssembler::is_call_at(return_address - NativeCall::return_address_offset);\n-  }\n-\n-  \/\/ MT-safe patching of a call instruction.\n-  static void insert(address code_pos, address entry);\n-\n-  static void replace_mt_safe(address instr_addr, address code_buffer);\n-\n-  \/\/ Similar to replace_mt_safe, but just changes the destination.  The\n-  \/\/ important thing is that free-running threads are able to execute\n-  \/\/ this call instruction at all times.  If the call is an immediate BL\n-  \/\/ instruction we can simply rely on atomicity of 32-bit writes to\n-  \/\/ make sure other threads will see no intermediate states.\n-\n-  \/\/ We cannot rely on locks here, since the free-running threads must run at\n-  \/\/ full speed.\n-  \/\/\n-  \/\/ Used in the runtime linkage of calls; see class CompiledIC.\n-  \/\/ (Cf. 4506997 and 4479829, where threads witnessed garbage displacements.)\n-\n-  \/\/ The parameter assert_lock disables the assertion during code generation.\n-  void set_destination_mt_safe(address dest, bool assert_lock = true);\n-\n-  address get_trampoline();\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n@@ -185,14 +155,0 @@\n-inline NativeCall* nativeCall_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  NativeCall* call = (NativeCall*)(addr - NativeCall::instruction_offset);\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n-inline NativeCall* nativeCall_before(address return_address) {\n-  assert_cond(return_address != nullptr);\n-  NativeCall* call = (NativeCall*)(return_address - NativeCall::return_address_offset);\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n@@ -369,21 +325,0 @@\n-\/\/ Call trampoline stubs.\n-class NativeCallTrampolineStub : public NativeInstruction {\n- public:\n-\n-  enum RISCV_specific_constants {\n-    \/\/ Refer to function emit_trampoline_stub.\n-    instruction_size = MacroAssembler::trampoline_stub_instruction_size, \/\/ auipc + ld + jr + target address\n-    data_offset      = MacroAssembler::trampoline_stub_data_offset,      \/\/ auipc + ld + jr\n-  };\n-\n-  address destination(nmethod *nm = nullptr) const;\n-  void set_destination(address new_destination);\n-  ptrdiff_t destination_offset() const;\n-};\n-\n-inline NativeCallTrampolineStub* nativeCallTrampolineStub_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(MacroAssembler::is_trampoline_stub_at(addr), \"no call trampoline found\");\n-  return (NativeCallTrampolineStub*)addr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":47,"deletions":112,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -63,5 +63,2 @@\n-  if (MacroAssembler::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      return nativeCallTrampolineStub_at(trampoline)->destination();\n-    }\n+  if (NativeCall::is_at(addr())) {\n+    return nativeCall_at(addr())->reloc_destination(orig_addr);\n@@ -69,0 +66,1 @@\n+  \/\/ Non call reloc\n@@ -84,4 +82,3 @@\n-  if (MacroAssembler::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      nativeCall_at(addr())->set_destination_mt_safe(x, \/* assert_lock *\/false);\n+  if (NativeCall::is_at(addr())) {\n+    NativeCall* nc = nativeCall_at(addr());\n+    if (nc->reloc_set_destination(x)) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1241,2 +1241,4 @@\n-  \/\/ jal\n-  return 1 * NativeInstruction::instruction_size;\n+  if (UseTrampolines) {\n+    return 1 * NativeInstruction::instruction_size; \/\/ jal\n+  }\n+  return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n@@ -1247,1 +1249,4 @@\n-  return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  if (UseTrampolines) {\n+    return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  }\n+  return NativeMovConstReg::movptr2_instruction_size + (3 * NativeInstruction::instruction_size); \/\/ movptr2, auipc + ld + jal\n@@ -1251,1 +1256,3 @@\n-  \/\/ for generated stubs the call will be\n+  \/\/ For generated stubs the call will be:\n+  \/\/   auipc + ld + jalr\n+  \/\/ Using trampos:\n@@ -1264,1 +1271,4 @@\n-    return 1 * NativeInstruction::instruction_size;\n+    if (UseTrampolines) {\n+      return 1 * NativeInstruction::instruction_size;\n+    }\n+    return 3 * NativeInstruction::instruction_size;\n@@ -2406,1 +2416,1 @@\n-      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));\n+      call = __ reloc_call(Address(addr, relocInfo::runtime_call_type));\n@@ -2415,0 +2425,4 @@\n+      if (!UseTrampolines) {\n+        __ nop();\n+        __ nop();\n+      }\n@@ -2420,1 +2434,1 @@\n-      call = __ trampoline_call(Address(addr, rspec));\n+      call = __ reloc_call(Address(addr, rspec));\n@@ -2472,1 +2486,1 @@\n-      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));\n+      address call = __ reloc_call(Address(entry, relocInfo::runtime_call_type));\n@@ -10101,1 +10115,1 @@\n-      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      address call = __ reloc_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1008,1 +1008,1 @@\n-    const address tr_call = __ trampoline_call(resolve);\n+    const address tr_call = __ reloc_call(resolve);\n@@ -1040,1 +1040,1 @@\n-  const address tr_call = __ trampoline_call(resolve);\n+  const address tr_call = __ reloc_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -51,11 +58,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_fp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5106,0 +5106,256 @@\n+  void adler32_process_bytes(Register buff, Register s1, Register s2, VectorRegister vtable,\n+    VectorRegister vzero, VectorRegister vbytes, VectorRegister vs1acc, VectorRegister vs2acc,\n+    Register temp0, Register temp1, Register temp2,  Register temp3,\n+    VectorRegister vtemp1, VectorRegister vtemp2, int step, Assembler::LMUL lmul) {\n+\n+    assert((lmul == Assembler::m4 && step == 64) ||\n+           (lmul == Assembler::m2 && step == 32) ||\n+           (lmul == Assembler::m1 && step == 16),\n+           \"LMUL should be aligned with step: m4 and 64, m2 and 32 or m1 and 16\");\n+    \/\/ Below is function for calculating Adler32 checksum with 64-, 32- or 16-byte step. LMUL=m4, m2 or m1 is used.\n+    \/\/ The results are in v12, v13, ..., v22, v23. Example below is for 64-byte step case.\n+    \/\/ We use b1, b2, ..., b64 to denote the 64 bytes loaded in each iteration.\n+    \/\/ In non-vectorized code, we update s1 and s2 as:\n+    \/\/   s1 <- s1 + b1\n+    \/\/   s2 <- s2 + s1\n+    \/\/   s1 <- s1 + b2\n+    \/\/   s2 <- s2 + b1\n+    \/\/   ...\n+    \/\/   s1 <- s1 + b64\n+    \/\/   s2 <- s2 + s1\n+    \/\/ Putting above assignments together, we have:\n+    \/\/   s1_new = s1 + b1 + b2 + ... + b64\n+    \/\/   s2_new = s2 + (s1 + b1) + (s1 + b1 + b2) + ... + (s1 + b1 + b2 + ... + b64) =\n+    \/\/          = s2 + s1 * 64 + (b1 * 64 + b2 * 63 + ... + b64 * 1) =\n+    \/\/          = s2 + s1 * 64 + (b1, b2, ... b64) dot (64, 63, ... 1)\n+\n+    __ mv(temp3, step);\n+    \/\/ Load data\n+    __ vsetvli(temp0, temp3, Assembler::e8, lmul);\n+    __ vle8_v(vbytes, buff);\n+    __ addi(buff, buff, step);\n+\n+    \/\/ Upper bound reduction sum for s1_new:\n+    \/\/ 0xFF * 64 = 0x3FC0, so:\n+    \/\/ 1. Need to do vector-widening reduction sum\n+    \/\/ 2. It is safe to perform sign-extension during vmv.x.s with 16-bits elements\n+    __ vwredsumu_vs(vs1acc, vbytes, vzero);\n+    \/\/ Multiplication for s2_new\n+    __ vwmulu_vv(vs2acc, vtable, vbytes);\n+\n+    \/\/ s2 = s2 + s1 * log2(step)\n+    __ slli(temp1, s1, exact_log2(step));\n+    __ add(s2, s2, temp1);\n+\n+    \/\/ Summing up calculated results for s2_new\n+    if (MaxVectorSize > 16) {\n+      __ vsetvli(temp0, temp3, Assembler::e16, lmul);\n+    } else {\n+      \/\/ Half of vector-widening multiplication result is in successor of vs2acc\n+      \/\/ group for vlen == 16, in which case we need to double vector register\n+      \/\/ group width in order to reduction sum all of them\n+      Assembler::LMUL lmulx2 = (lmul == Assembler::m1) ? Assembler::m2 :\n+                               (lmul == Assembler::m2) ? Assembler::m4 : Assembler::m8;\n+      __ vsetvli(temp0, temp3, Assembler::e16, lmulx2);\n+    }\n+    \/\/ Upper bound for reduction sum:\n+    \/\/ 0xFF * (64 + 63 + ... + 2 + 1) = 0x817E0 max for whole register group, so:\n+    \/\/ 1. Need to do vector-widening reduction sum\n+    \/\/ 2. It is safe to perform sign-extension during vmv.x.s with 32-bits elements\n+    __ vwredsumu_vs(vtemp1, vs2acc, vzero);\n+\n+    \/\/ Extracting results for:\n+    \/\/ s1_new\n+    __ vmv_x_s(temp0, vs1acc);\n+    __ add(s1, s1, temp0);\n+    \/\/ s2_new\n+    __ vsetvli(temp0, temp3, Assembler::e32, Assembler::m1);\n+    __ vmv_x_s(temp1, vtemp1);\n+    __ add(s2, s2, temp1);\n+  }\n+\n+  \/***\n+   *  int java.util.zip.Adler32.updateBytes(int adler, byte[] b, int off, int len)\n+   *\n+   *  Arguments:\n+   *\n+   *  Inputs:\n+   *   c_rarg0   - int   adler\n+   *   c_rarg1   - byte* buff (b + off)\n+   *   c_rarg2   - int   len\n+   *\n+   *  Output:\n+   *   c_rarg0   - int adler result\n+   *\/\n+  address generate_updateBytesAdler32() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    address start = __ pc();\n+\n+    Label L_nmax, L_nmax_loop, L_nmax_loop_entry, L_by16, L_by16_loop,\n+      L_by16_loop_unroll, L_by1_loop, L_do_mod, L_combine, L_by1;\n+\n+    \/\/ Aliases\n+    Register adler  = c_rarg0;\n+    Register s1     = c_rarg0;\n+    Register s2     = c_rarg3;\n+    Register buff   = c_rarg1;\n+    Register len    = c_rarg2;\n+    Register nmax  = c_rarg4;\n+    Register base  = c_rarg5;\n+    Register count = c_rarg6;\n+    Register temp0 = x28; \/\/ t3\n+    Register temp1 = x29; \/\/ t4\n+    Register temp2 = x30; \/\/ t5\n+    Register temp3 = x31; \/\/ t6\n+\n+    VectorRegister vzero = v31;\n+    VectorRegister vbytes = v8; \/\/ group: v8, v9, v10, v11\n+    VectorRegister vs1acc = v12; \/\/ group: v12, v13, v14, v15\n+    VectorRegister vs2acc = v16; \/\/ group: v16, v17, v18, v19, v20, v21, v22, v23\n+    VectorRegister vtable_64 = v24; \/\/ group: v24, v25, v26, v27\n+    VectorRegister vtable_32 = v4; \/\/ group: v4, v5\n+    VectorRegister vtable_16 = v30;\n+    VectorRegister vtemp1 = v28;\n+    VectorRegister vtemp2 = v29;\n+\n+    \/\/ Max number of bytes we can process before having to take the mod\n+    \/\/ 0x15B0 is 5552 in decimal, the largest n such that 255n(n+1)\/2 + (n+1)(BASE-1) <= 2^32-1\n+    const uint64_t BASE = 0xfff1;\n+    const uint64_t NMAX = 0x15B0;\n+\n+    \/\/ Loops steps\n+    int step_64 = 64;\n+    int step_32 = 32;\n+    int step_16 = 16;\n+    int step_1  = 1;\n+\n+    __ enter(); \/\/ Required for proper stackwalking of RuntimeStub frame\n+    __ mv(temp1, 64);\n+    __ vsetvli(temp0, temp1, Assembler::e8, Assembler::m4);\n+\n+    \/\/ Generating accumulation coefficients for further calculations\n+    \/\/ vtable_64:\n+    __ vid_v(vtemp1);\n+    __ vrsub_vx(vtable_64, vtemp1, temp1);\n+    \/\/ vtable_64 group now contains { 0x40, 0x3f, 0x3e, ..., 0x3, 0x2, 0x1 }\n+\n+    \/\/ vtable_32:\n+    __ mv(temp1, 32);\n+    __ vsetvli(temp0, temp1, Assembler::e8, Assembler::m2);\n+    __ vid_v(vtemp1);\n+    __ vrsub_vx(vtable_32, vtemp1, temp1);\n+    \/\/ vtable_32 group now contains { 0x20, 0x1f, 0x1e, ..., 0x3, 0x2, 0x1 }\n+\n+    __ vsetivli(temp0, 16, Assembler::e8, Assembler::m1);\n+    \/\/ vtable_16:\n+    __ mv(temp1, 16);\n+    __ vid_v(vtemp1);\n+    __ vrsub_vx(vtable_16, vtemp1, temp1);\n+    \/\/ vtable_16 now contains { 0x10, 0xf, 0xe, ..., 0x3, 0x2, 0x1 }\n+\n+    __ vmv_v_i(vzero, 0);\n+\n+    __ mv(base, BASE);\n+    __ mv(nmax, NMAX);\n+\n+    \/\/ s1 is initialized to the lower 16 bits of adler\n+    \/\/ s2 is initialized to the upper 16 bits of adler\n+    __ srliw(s2, adler, 16); \/\/ s2 = ((adler >> 16) & 0xffff)\n+    __ zero_extend(s1, adler, 16); \/\/ s1 = (adler & 0xffff)\n+\n+    \/\/ The pipelined loop needs at least 16 elements for 1 iteration\n+    \/\/ It does check this, but it is more effective to skip to the cleanup loop\n+    __ mv(temp0, step_16);\n+    __ bgeu(len, temp0, L_nmax);\n+    __ beqz(len, L_combine);\n+\n+    \/\/ Jumping to L_by1_loop\n+    __ sub(len, len, step_1);\n+    __ j(L_by1_loop);\n+\n+  __ bind(L_nmax);\n+    __ sub(len, len, nmax);\n+    __ sub(count, nmax, 16);\n+    __ bltz(len, L_by16);\n+\n+  \/\/ Align L_nmax loop by 64\n+  __ bind(L_nmax_loop_entry);\n+    __ sub(count, count, 32);\n+\n+  __ bind(L_nmax_loop);\n+    adler32_process_bytes(buff, s1, s2, vtable_64, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, temp3,\n+      vtemp1, vtemp2, step_64, Assembler::m4);\n+    __ sub(count, count, step_64);\n+    __ bgtz(count, L_nmax_loop);\n+\n+    \/\/ There are three iterations left to do\n+    adler32_process_bytes(buff, s1, s2, vtable_32, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, temp3,\n+      vtemp1, vtemp2, step_32, Assembler::m2);\n+    adler32_process_bytes(buff, s1, s2, vtable_16, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, temp3,\n+      vtemp1, vtemp2, step_16, Assembler::m1);\n+\n+    \/\/ s1 = s1 % BASE\n+    __ remuw(s1, s1, base);\n+    \/\/ s2 = s2 % BASE\n+    __ remuw(s2, s2, base);\n+\n+    __ sub(len, len, nmax);\n+    __ sub(count, nmax, 16);\n+    __ bgez(len, L_nmax_loop_entry);\n+\n+  __ bind(L_by16);\n+    __ add(len, len, count);\n+    __ bltz(len, L_by1);\n+    \/\/ Trying to unroll\n+    __ mv(temp3, step_64);\n+    __ blt(len, temp3, L_by16_loop);\n+\n+  __ bind(L_by16_loop_unroll);\n+    adler32_process_bytes(buff, s1, s2, vtable_64, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, temp3,\n+      vtemp1, vtemp2, step_64, Assembler::m4);\n+    __ sub(len, len, step_64);\n+    \/\/ By now the temp3 should still be 64\n+    __ bge(len, temp3, L_by16_loop_unroll);\n+\n+  __ bind(L_by16_loop);\n+    adler32_process_bytes(buff, s1, s2, vtable_16, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, temp3,\n+      vtemp1, vtemp2, step_16, Assembler::m1);\n+    __ sub(len, len, step_16);\n+    __ bgez(len, L_by16_loop);\n+\n+  __ bind(L_by1);\n+    __ add(len, len, 15);\n+    __ bltz(len, L_do_mod);\n+\n+  __ bind(L_by1_loop);\n+    __ lbu(temp0, Address(buff, 0));\n+    __ addi(buff, buff, step_1);\n+    __ add(s1, temp0, s1);\n+    __ add(s2, s2, s1);\n+    __ sub(len, len, step_1);\n+    __ bgez(len, L_by1_loop);\n+\n+  __ bind(L_do_mod);\n+    \/\/ s1 = s1 % BASE\n+    __ remuw(s1, s1, base);\n+    \/\/ s2 = s2 % BASE\n+    __ remuw(s2, s2, base);\n+\n+    \/\/ Combine lower bits and higher bits\n+    \/\/ adler = s1 | (s2 << 16)\n+  __ bind(L_combine);\n+    __ slli(s2, s2, 16);\n+    __ orr(s1, s1, s2);\n+\n+    __ leave(); \/\/ Required for proper stackwalking of RuntimeStub frame\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5683,1 +5939,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -5717,1 +5972,0 @@\n-#endif \/\/ COMPILER2\n@@ -5731,4 +5985,0 @@\n-    generate_compare_long_strings();\n-\n-    generate_string_indexof_stubs();\n-\n@@ -5749,1 +5999,9 @@\n-#endif \/\/ COMPILER2_OR_JVMCI\n+    if (UseAdler32Intrinsics) {\n+      StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n+    }\n+\n+    generate_compare_long_strings();\n+\n+    generate_string_indexof_stubs();\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":265,"deletions":7,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -61,0 +61,7 @@\n+  common_initialize();\n+#ifdef COMPILER2\n+  c2_initialize();\n+#endif \/\/ COMPILER2\n+}\n+\n+void VM_Version::common_initialize() {\n@@ -155,4 +162,0 @@\n-  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n-    FLAG_SET_DEFAULT(UseMD5Intrinsics, true);\n-  }\n-\n@@ -233,87 +236,0 @@\n-\n-#ifdef COMPILER2\n-  c2_initialize();\n-#endif \/\/ COMPILER2\n-\n-  \/\/ NOTE: Make sure codes dependent on UseRVV are put after c2_initialize(),\n-  \/\/       as there are extra checks inside it which could disable UseRVV\n-  \/\/       in some situations.\n-\n-  \/\/ ChaCha20\n-  if (UseRVV) {\n-    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n-    }\n-  } else if (UseChaCha20Intrinsics) {\n-    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n-      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n-    }\n-    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n-  }\n-\n-  \/\/ UseZvbb (depends on RVV).\n-  if (UseZvbb && !UseRVV) {\n-    FLAG_SET_DEFAULT(UseZvbb, false);\n-    warning(\"Cannot enable UseZvbb on cpu without RVV support.\");\n-  }\n-\n-  \/\/ SHA's\n-  if (FLAG_IS_DEFAULT(UseSHA)) {\n-    FLAG_SET_DEFAULT(UseSHA, true);\n-  }\n-\n-  \/\/ SHA-1, no RVV required though.\n-  if (UseSHA) {\n-    if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);\n-    }\n-  } else if (UseSHA1Intrinsics) {\n-    warning(\"Intrinsics for SHA-1 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);\n-  }\n-\n-  \/\/ UseZvkn (depends on RVV) and SHA-2.\n-  if (UseZvkn && !UseRVV) {\n-    FLAG_SET_DEFAULT(UseZvkn, false);\n-    warning(\"Cannot enable Zvkn on cpu without RVV support.\");\n-  }\n-  \/\/ SHA-2, depends on Zvkn.\n-  if (UseSHA) {\n-    if (UseZvkn) {\n-      if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n-        FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n-      }\n-      if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n-        FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n-      }\n-    } else {\n-      if (UseSHA256Intrinsics) {\n-        warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU, UseZvkn needed.\");\n-        FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n-      }\n-      if (UseSHA512Intrinsics) {\n-        warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU, UseZvkn needed.\");\n-        FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n-      }\n-    }\n-  } else {\n-    if (UseSHA256Intrinsics) {\n-      warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU, as UseSHA disabled.\");\n-      FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n-    }\n-    if (UseSHA512Intrinsics) {\n-      warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU, as UseSHA disabled.\");\n-      FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n-    }\n-  }\n-\n-  \/\/ SHA-3\n-  if (UseSHA3Intrinsics) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n-  }\n-\n-  \/\/ UseSHA\n-  if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA3Intrinsics || UseSHA512Intrinsics)) {\n-    FLAG_SET_DEFAULT(UseSHA, false);\n-  }\n@@ -348,0 +264,4 @@\n+  \/\/ NOTE: Make sure codes dependent on UseRVV are put after MaxVectorSize initialize,\n+  \/\/       as there are extra checks inside it which could disable UseRVV\n+  \/\/       in some situations.\n+\n@@ -410,0 +330,97 @@\n+\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, true);\n+  }\n+\n+  \/\/ Adler32\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseAdler32Intrinsics, true);\n+    }\n+  } else if (UseAdler32Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+      warning(\"Adler32 intrinsic requires RVV instructions (not available on this CPU).\");\n+    }\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n+  }\n+\n+  \/\/ ChaCha20\n+  if (UseRVV && MaxVectorSize >= 32) {\n+    \/\/ performance tests on hardwares (MaxVectorSize == 16, 32) show that\n+    \/\/ it brings regression when MaxVectorSize == 16.\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n+    }\n+  } else if (UseChaCha20Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n+\n+  \/\/ UseZvbb (depends on RVV).\n+  if (UseZvbb && !UseRVV) {\n+    FLAG_SET_DEFAULT(UseZvbb, false);\n+    warning(\"Cannot enable UseZvbb on cpu without RVV support.\");\n+  }\n+\n+  \/\/ SHA's\n+  if (FLAG_IS_DEFAULT(UseSHA)) {\n+    FLAG_SET_DEFAULT(UseSHA, true);\n+  }\n+\n+  \/\/ SHA-1, no RVV required though.\n+  if (UseSHA) {\n+    if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);\n+    }\n+  } else if (UseSHA1Intrinsics) {\n+    warning(\"Intrinsics for SHA-1 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);\n+  }\n+\n+  \/\/ UseZvkn (depends on RVV) and SHA-2.\n+  if (UseZvkn && !UseRVV) {\n+    FLAG_SET_DEFAULT(UseZvkn, false);\n+    warning(\"Cannot enable Zvkn on cpu without RVV support.\");\n+  }\n+  \/\/ SHA-2, depends on Zvkn.\n+  if (UseSHA) {\n+    if (UseZvkn) {\n+      if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n+      }\n+      if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n+      }\n+    } else {\n+      if (UseSHA256Intrinsics) {\n+        warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU, UseZvkn needed.\");\n+        FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n+      }\n+      if (UseSHA512Intrinsics) {\n+        warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU, UseZvkn needed.\");\n+        FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n+      }\n+    }\n+  } else {\n+    if (UseSHA256Intrinsics) {\n+      warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU, as UseSHA disabled.\");\n+      FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n+    }\n+    if (UseSHA512Intrinsics) {\n+      warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU, as UseSHA disabled.\");\n+      FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n+    }\n+  }\n+\n+  \/\/ SHA-3\n+  if (UseSHA3Intrinsics) {\n+    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+  }\n+\n+  \/\/ UseSHA\n+  if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA3Intrinsics || UseSHA512Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA, false);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":108,"deletions":91,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -267,0 +267,2 @@\n+  static void common_initialize();\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2024 IBM Corporation. All rights reserved.\n@@ -3155,0 +3156,295 @@\n+\/\/ scans r_count pointer sized words at [r_addr] for occurrence of r_value,\n+\/\/ generic (r_count must be >0)\n+\/\/ iff found: CC eq, r_result == 0\n+void MacroAssembler::repne_scan(Register r_addr, Register r_value, Register r_count, Register r_result) {\n+  NearLabel L_loop, L_exit;\n+\n+  BLOCK_COMMENT(\"repne_scan {\");\n+#ifdef ASSERT\n+  z_chi(r_count, 0);\n+  asm_assert(bcondHigh, \"count must be positive\", 11);\n+#endif\n+\n+  clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/);  \/\/ sets r_result=0, let's hope that search will be successful\n+\n+  bind(L_loop);\n+  z_cg(r_value, Address(r_addr));\n+  z_bre(L_exit); \/\/ branch on success\n+  z_la(r_addr, wordSize, r_addr);\n+  z_brct(r_count, L_loop);\n+\n+  \/\/ z_brct above doesn't change CC.\n+  \/\/ If we reach here, then the value in r_value is not present. Set r_result to 1.\n+  z_lghi(r_result, 1);\n+\n+  bind(L_exit);\n+  BLOCK_COMMENT(\"} repne_scan\");\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                 \\\n+do {                                                            \\\n+  assert(r_super_klass  == Z_ARG1                            && \\\n+         r_array_base   == Z_ARG5                            && \\\n+         r_array_length == Z_ARG4                            && \\\n+        (r_array_index  == Z_ARG3 || r_array_index == noreg) && \\\n+        (r_sub_klass    == Z_ARG2 || r_sub_klass   == noreg) && \\\n+        (r_bitmap       == Z_R10  || r_bitmap      == noreg) && \\\n+        (r_result       == Z_R11  || r_result      == noreg), \"registers must match s390.ad\"); \\\n+} while(0)\n+\n+\/\/ Note: this method also kills Z_R1_scratch register on machines older than z15\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register r_temp1,\n+                                                   Register r_temp2,\n+                                                   Register r_temp3,\n+                                                   Register r_temp4,\n+                                                   Register r_result,\n+                                                   u1 super_klass_slot) {\n+  NearLabel L_done, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = r_temp1,\n+    r_array_length = r_temp2,\n+    r_array_index  = r_temp3,\n+    r_bitmap       = r_temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  z_lg(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+\n+  z_sllg(r_array_index, r_bitmap, shift_count); \/\/ take the bit to 63rd location\n+\n+  \/\/ Initialize r_result with 0 (indicating success). If searching fails, r_result will be loaded\n+  \/\/ with 1 (failure) at the end of this method.\n+  clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/); \/\/ r_result = 0\n+\n+  \/\/ We test the MSB of r_array_index, i.e., its sign bit\n+  testbit(r_array_index, 63);\n+  z_bfalse(L_failure); \/\/ if not set, then jump!!!\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, Klass::secondary_supers_offset()));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+\n+  \/\/ Get the first array index that can contain super_klass.\n+  if (bit != 0) {\n+    pop_count_long(r_array_index, r_array_index, Z_R1_scratch); \/\/ kills Z_R1_scratch on machines older than z15\n+\n+    \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+    z_sllg(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale\n+  } else {\n+    \/\/ Actually use index 0, but r_array_base and r_array_index are off by 1 word\n+    \/\/ such that the sum is precise.\n+    z_lghi(r_array_index, BytesPerWord); \/\/ for slow path (scaled)\n+  }\n+\n+  z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+  branch_optimized(bcondEqual, L_done); \/\/ found a match; success\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  testbit(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  z_bfalse(L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 2 for the look-ahead check in the slow path.\n+  if (bit != 0) {\n+    z_rllg(r_bitmap, r_bitmap, 64-bit); \/\/ rotate right\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: r_result\n+\n+  call_stub(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+\n+  z_bru(L_done); \/\/ pass whatever result we got from a slow path\n+\n+  bind(L_failure);\n+  \/\/ TODO: use load immediate on condition and z_bru above will not be required\n+  z_lghi(r_result, 1);\n+\n+  bind(L_done);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, r_result,\n+                                  r_temp1, r_temp2, r_temp3);\n+  }\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register r_result,\n+                                                             Register r_temp1) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp1);\n+\n+  const Register\n+    r_array_length = r_temp1,\n+    r_sub_klass    = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_slow_path {\");\n+  NearLabel L_done, L_failure;\n+\n+  \/\/ Load the array length.\n+  z_llgf(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB!\n+  \/\/ Effectively increments the current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  add2reg(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  NearLabel L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n+  z_bre(L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+#ifdef ASSERT\n+    \/\/ r_result is set to 0 by lookup_secondary_supers_table.\n+    \/\/ clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/);\n+    z_cghi(r_result, 0);\n+    asm_assert(bcondEqual, \"r_result required to be 0, used by z_locgr\", 44);\n+\n+    \/\/ We should only reach here after having found a bit in the bitmap.\n+    z_ltgr(r_array_length, r_array_length);\n+    asm_assert(bcondHigh, \"array_length > 0, should hold\", 22);\n+#endif \/\/ ASSERT\n+\n+    \/\/ Compute limit in r_array_length\n+    add2reg(r_array_length, -1);\n+    z_sllg(r_array_length, r_array_length, LogBytesPerWord);\n+\n+    NearLabel L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    z_cgr(r_array_index, r_array_length);\n+    z_locgr(r_array_index, r_result, bcondHigh); \/\/ r_result is containing 0\n+\n+    z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+    z_bre(L_done); \/\/ success\n+\n+    \/\/ look-ahead check: if Bit 2 is 0, we're done\n+    testbit(r_bitmap, 2);\n+    z_bfalse(L_failure);\n+\n+    z_rllg(r_bitmap, r_bitmap, 64-1); \/\/ rotate right\n+    add2reg(r_array_index, BytesPerWord);\n+\n+    z_bru(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+\n+    bind(L_huge);\n+    repne_scan(r_array_base, r_super_klass, r_array_length, r_result);\n+\n+    z_bru(L_done); \/\/ forward the result we got from repne_scan\n+  }\n+\n+  bind(L_failure);\n+  z_lghi(r_result, 1);\n+\n+  bind(L_done);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_slow_path\");\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register r_result \/* expected *\/,\n+                                                   Register r_temp1,\n+                                                   Register r_temp2,\n+                                                   Register r_temp3) {\n+  assert_different_registers(r_sub_klass, r_super_klass, r_result, r_temp1, r_temp2, r_temp3);\n+\n+  const Register\n+    r_array_base   = r_temp1,\n+    r_array_length = r_temp2,\n+    r_array_index  = r_temp3,\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  const Register r_one = Z_R0_scratch;\n+  z_lghi(r_one, 1); \/\/ for locgr down there, to a load result for failure\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label L_passed, L_failure;\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  z_llgf(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+\n+  \/\/ And adjust the array base to point to the data.\n+  z_aghi(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  const Register r_linear_result = r_array_index; \/\/ reuse\n+  z_chi(r_array_length, 0);\n+  z_locgr(r_linear_result, r_one, bcondNotHigh); \/\/ load failure if array_length <= 0\n+  z_brc(bcondNotHigh, L_failure);\n+  repne_scan(r_array_base, r_super_klass, r_array_length, r_linear_result);\n+  bind(L_failure);\n+\n+  z_cr(r_result, r_linear_result);\n+  z_bre(L_passed);\n+\n+  assert_different_registers(Z_ARG1, r_sub_klass, r_linear_result, r_result);\n+  lgr_if_needed(Z_ARG1, r_super_klass);\n+  assert_different_registers(Z_ARG2, r_linear_result, r_result);\n+  lgr_if_needed(Z_ARG2, r_sub_klass);\n+  assert_different_registers(Z_ARG3, r_result);\n+  z_lgr(Z_ARG3, r_linear_result);\n+  z_lgr(Z_ARG4, r_result);\n+  const char* msg = \"mismatch\";\n+  load_const_optimized(Z_ARG5, (address)msg);\n+\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure));\n+  should_not_reach_here();\n+\n+  bind(L_passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":296,"deletions":0,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -711,0 +711,25 @@\n+  void repne_scan(Register r_addr, Register r_value, Register r_count, Register r_scratch);\n+\n+  void lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register r_temp1,\n+                                     Register r_temp2,\n+                                     Register r_temp3,\n+                                     Register r_temp4,\n+                                     Register r_result,\n+                                     u1 super_klass_slot);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register r_result,\n+                                               Register r_temp1);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register r_result \/* expected *\/,\n+                                     Register r_temp1,\n+                                     Register r_temp2,\n+                                     Register r_temp3);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -359,0 +359,2 @@\n+reg_class z_r10_ptr_reg(Z_R10_H, Z_R10);\n+reg_class z_r11_ptr_reg(Z_R11_H, Z_R11);\n@@ -2988,0 +2990,2 @@\n+  match(r10TempRegP);\n+  match(r11TempRegP);\n@@ -3000,0 +3004,14 @@\n+operand r10TempRegP() %{\n+  constraint(ALLOC_IN_RC(z_r10_ptr_reg));\n+  match(iRegP);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand r11TempRegP() %{\n+  constraint(ALLOC_IN_RC(z_r11_ptr_reg));\n+  match(iRegP);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -9563,0 +9581,26 @@\n+instruct partialSubtypeCheckConstSuper(rarg2RegP sub, rarg1RegP super, immP super_con,\n+                                       r11TempRegP result, rarg5RegP temp1, rarg4RegP temp2,\n+                                       rarg3RegP temp3, r10TempRegP temp4, flagsReg pcc) %{\n+  match(Set result (PartialSubtypeCheck sub (Binary super super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL pcc, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  format %{ \"partialSubtypeCheck $result, $sub, $super, $super_con\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table($sub$$Register, $super$$Register,\n+                                                 $temp1$$Register, $temp2$$Register, $temp3$$Register,\n+                                                 $temp4$$Register, $result$$Register, super_klass_slot);\n+    } else {\n+      AddressLiteral stub_address(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot));\n+      __ load_const_optimized(Z_ARG4, stub_address);\n+      __ z_basr(Z_R14, Z_ARG4);\n+    }\n+\n+  %}\n+\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -708,0 +708,44 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    const Register\n+        r_super_klass  = Z_ARG1,\n+        r_sub_klass    = Z_ARG2,\n+        r_array_index  = Z_ARG3,\n+        r_array_length = Z_ARG4,\n+        r_array_base   = Z_ARG5,\n+        r_bitmap       = Z_R10,\n+        r_result       = Z_R11;\n+    address start = __ pc();\n+\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     r_bitmap, r_result, super_klass_index);\n+\n+    __ z_br(Z_R14);\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+\n+    const Register\n+        r_super_klass  = Z_ARG1,\n+        r_array_base   = Z_ARG5,\n+        r_temp1        = Z_ARG4,\n+        r_array_index  = Z_ARG3,\n+        r_bitmap       = Z_R10,\n+        r_result       = Z_R11;\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base,\n+                                               r_array_index, r_bitmap, r_result, r_temp1);\n+\n+    __ z_br(Z_R14);\n+\n+    return start;\n+  }\n+\n@@ -3250,0 +3294,8 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -275,0 +275,7 @@\n+  if (UseSecondarySupersTable && VM_Version::get_model_index() < 5 \/* z196\/z11 *\/) {\n+    if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+      warning(\"UseSecondarySupersTable requires z196 or later.\");\n+    }\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-  \/\/ Apply IU barrier to newval.\n-  ShenandoahBarrierSet::assembler()->iu_barrier(masm->masm(), newval, tmp1);\n-\n@@ -104,4 +101,0 @@\n-  if (access.is_oop()) {\n-    value_opr = iu_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahIUBarrier || ShenandoahLoadRefBarrier) {\n+    if ((ShenandoahSATBBarrier && !dest_uninitialized) || ShenandoahLoadRefBarrier) {\n@@ -475,34 +475,0 @@\n-void ShenandoahBarrierSetAssembler::iu_barrier(MacroAssembler* masm, Register dst, Register tmp) {\n-  if (ShenandoahIUBarrier) {\n-    iu_barrier_impl(masm, dst, tmp);\n-  }\n-}\n-\n-void ShenandoahBarrierSetAssembler::iu_barrier_impl(MacroAssembler* masm, Register dst, Register tmp) {\n-  assert(ShenandoahIUBarrier, \"should be enabled\");\n-\n-  if (dst == noreg) return;\n-\n-  if (ShenandoahIUBarrier) {\n-    save_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n-\n-#ifdef _LP64\n-    Register thread = r15_thread;\n-#else\n-    Register thread = rcx;\n-    if (thread == dst || thread == tmp) {\n-      thread = rdi;\n-    }\n-    if (thread == dst || thread == tmp) {\n-      thread = rbx;\n-    }\n-    __ get_thread(thread);\n-#endif\n-    assert_different_registers(dst, tmp, thread);\n-\n-    satb_write_barrier_pre(masm, noreg, dst, thread, tmp, true, false);\n-\n-    restore_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n-  }\n-}\n-\n@@ -629,6 +595,1 @@\n-    if (val == noreg) {\n-      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n-    } else {\n-      iu_barrier(masm, val, tmp3);\n-      BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n-    }\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  void iu_barrier_impl(MacroAssembler* masm, Register dst, Register tmp);\n-\n@@ -62,1 +60,0 @@\n-  void iu_barrier(MacroAssembler* masm, Register dst, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,5 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n+\n@@ -51,11 +59,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rbp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/smallRegisterMap_x86.inline.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-static void* dll_load_library(const char *filename, char *ebuf, int ebuflen) {\n+static void* dll_load_library(const char *filename, int *eno, char *ebuf, int ebuflen) {\n@@ -1047,1 +1047,1 @@\n-  result = Aix_dlopen(filename, dflags, &error_report);\n+  result = Aix_dlopen(filename, dflags, eno, &error_report);\n@@ -1079,1 +1079,2 @@\n-  result = dll_load_library(filename, ebuf, ebuflen);\n+  int eno=0;\n+  result = dll_load_library(filename, &eno, ebuf, ebuflen);\n@@ -1082,1 +1083,1 @@\n-  if (result == nullptr && pointer_to_dot != nullptr && strcmp(pointer_to_dot, old_extension) == 0) {\n+  if (result == nullptr && eno == ENOENT && pointer_to_dot != nullptr && strcmp(pointer_to_dot, old_extension) == 0) {\n@@ -1084,1 +1085,1 @@\n-    result = dll_load_library(file_path, ebuf, ebuflen);\n+    result = dll_load_library(file_path, &eno, ebuf, ebuflen);\n@@ -1848,1 +1849,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-void* Aix_dlopen(const char* filename, int Flags, const char** error_report) {\n+void* Aix_dlopen(const char* filename, int Flags, int *eno, const char** error_report) {\n@@ -1050,0 +1050,1 @@\n+    *eno = ENOENT;\n@@ -1093,0 +1094,1 @@\n+      errno = 0;\n@@ -1104,0 +1106,1 @@\n+        *eno = errno;\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-void* Aix_dlopen(const char* filename, int Flags, const char** error_report);\n+void* Aix_dlopen(const char* filename, int Flags, int *eno, const char** error_report);\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1687,1 +1687,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3038,9 +3038,4 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n-  \/\/ This method works by doing an mmap over an existing mmaping and effectively discarding\n-  \/\/ the existing pages. However it won't work for SHM-based large pages that cannot be\n-  \/\/ uncommitted at all. We don't do anything in this case to avoid creating a segment with\n-  \/\/ small pages on top of the SHM segment. This method always works for small pages, so we\n-  \/\/ allow that in any case.\n-  if (alignment_hint <= os::vm_page_size() || can_commit_large_page_memory()) {\n-    commit_memory(addr, bytes, alignment_hint, !ExecMem);\n-  }\n+\/\/ Hints to the OS that the memory is no longer needed and may be reclaimed by the OS when convenient.\n+\/\/ The memory will be re-acquired on touch without needing explicit recommitting.\n+void os::pd_disclaim_memory(char *addr, size_t bytes) {\n+   ::madvise(addr, bytes, MADV_DONTNEED);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3896,1 +3896,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }\n+void os::pd_disclaim_memory(char *addr, size_t bytes) { }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,0 +138,2 @@\n+  }\n+  if (_overflow_arena != nullptr) {\n@@ -139,1 +141,1 @@\n-    delete cb->_overflow_arena;\n+    delete _overflow_arena;\n@@ -141,1 +143,0 @@\n-\n@@ -976,2 +977,0 @@\n-  _overflow_arena = cb->_overflow_arena;\n-  cb->_overflow_arena = nullptr;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+    has_scoped_access(),\n@@ -581,0 +582,1 @@\n+, _has_scoped_access(method->is_scoped())\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  bool               _has_scoped_access; \/\/ For shared scope closure\n@@ -148,0 +149,1 @@\n+  bool has_scoped_access() const                 { return _has_scoped_access; }\n@@ -180,0 +182,1 @@\n+  void set_has_scoped_access(bool f)             { _has_scoped_access = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3794,0 +3794,3 @@\n+  if (callee->is_scoped()) {\n+    compilation->set_has_scoped_access(true);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+  unsigned int _flags;                           \/\/ Flag bits\n@@ -307,1 +308,0 @@\n-  unsigned int _flags;                           \/\/ Flag bits\n@@ -427,0 +427,1 @@\n+  , _flags(0)\n@@ -431,1 +432,0 @@\n-  , _flags(0)\n@@ -1591,0 +1591,1 @@\n+  ArgsNonNullState _nonnull_state;\n@@ -1593,1 +1594,0 @@\n-  ArgsNonNullState _nonnull_state;\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-  , _fast_check(fast_check)\n@@ -307,0 +306,1 @@\n+  , _fast_check(fast_check)\n@@ -328,1 +328,0 @@\n-  , _fast_check(false)\n@@ -335,0 +334,1 @@\n+  , _fast_check(false)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -531,1 +531,0 @@\n-  Scale     _scale;\n@@ -533,0 +532,1 @@\n+  Scale     _scale;\n@@ -539,1 +539,0 @@\n-     , _scale(times_1)\n@@ -541,0 +540,1 @@\n+     , _scale(times_1)\n@@ -546,1 +546,0 @@\n-     , _scale(times_1)\n@@ -548,0 +547,1 @@\n+     , _scale(times_1)\n@@ -553,1 +553,0 @@\n-     , _scale(times_1)\n@@ -555,0 +554,1 @@\n+     , _scale(times_1)\n@@ -560,1 +560,0 @@\n-     , _scale(times_1)\n@@ -562,0 +561,1 @@\n+     , _scale(times_1)\n@@ -567,1 +567,0 @@\n-     , _scale(scale)\n@@ -569,0 +568,1 @@\n+     , _scale(scale)\n@@ -1571,1 +1571,0 @@\n-  bool          _fast_check;\n@@ -1578,0 +1577,1 @@\n+  bool          _fast_check;\n@@ -1697,1 +1697,0 @@\n-  BasicType _type;\n@@ -1704,0 +1703,1 @@\n+  BasicType _type;\n@@ -1713,1 +1713,0 @@\n-    , _type(type)\n@@ -1719,1 +1718,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n@@ -1728,1 +1728,0 @@\n-    , _type(type)\n@@ -1734,1 +1733,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n@@ -1745,1 +1745,0 @@\n-    , _type(type)\n@@ -1751,1 +1750,2 @@\n-    , _condition(lir_cond_unknown) {\n+    , _condition(lir_cond_unknown)\n+    , _type(type) {\n@@ -1761,1 +1761,0 @@\n-    , _type(T_ILLEGAL)\n@@ -1767,1 +1766,2 @@\n-    , _condition(lir_cond_unknown) {\n+    , _condition(lir_cond_unknown)\n+    , _type(T_ILLEGAL)    {\n@@ -1852,1 +1852,0 @@\n-  BasicType _type;\n@@ -1854,0 +1853,1 @@\n+  BasicType _type;\n@@ -1866,1 +1866,0 @@\n-    , _type(type)\n@@ -1868,0 +1867,1 @@\n+    , _type(type)\n@@ -1918,1 +1918,0 @@\n-  BasicType _type;\n@@ -1925,0 +1924,1 @@\n+  BasicType _type;\n@@ -1934,1 +1934,0 @@\n-    , _type(type)\n@@ -1940,1 +1939,2 @@\n-    , _condition(condition) {\n+    , _condition(condition)\n+    , _type(type) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1323,1 +1323,1 @@\n-  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));\n+  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(nullptr));\n@@ -1366,1 +1366,1 @@\n-  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(0));\n+  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(nullptr));\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -486,4 +486,1 @@\n-            if (value != min_jint) {\n-              if (ao->op() == Bytecodes::_isub) {\n-                value = -value;\n-              }\n+            if (ao->op() == Bytecodes::_iadd) {\n@@ -491,2 +488,3 @@\n-              last_integer = base;\n-              last_instruction = other;\n+            } else {\n+              assert(ao->op() == Bytecodes::_isub, \"unexpected bytecode\");\n+              base = java_subtract(base, value);\n@@ -494,0 +492,2 @@\n+            last_integer = base;\n+            last_instruction = other;\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1295,1 +1295,1 @@\n-    log_region(\"header\", header, header_end, 0);\n+    log_region(\"header\", header, header_end, nullptr);\n@@ -1297,1 +1297,1 @@\n-    log_as_hex(header, header_end, 0);\n+    log_as_hex(header, header_end, nullptr);\n@@ -1306,2 +1306,2 @@\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, 0);\n-    log_as_hex((address)bitmap, bitmap_end, 0);\n+    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n+    log_as_hex((address)bitmap, bitmap_end, nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    _mapped_base_address = 0;\n+    _mapped_base_address = nullptr;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    new (arena) GrowableArray<void*>(arena, expected_size, 0, 0);\n+    new (arena) GrowableArray<void*>(arena, expected_size, 0, nullptr);\n","filename":"src\/hotspot\/share\/ci\/ciConstantPoolCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1041,0 +1041,1 @@\n+                            bool has_scoped_access,\n@@ -1133,0 +1134,1 @@\n+      nm->set_has_scoped_access(has_scoped_access);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+                       bool                      has_scoped_access,\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    MutexLocker locker(Compile_lock);\n+    bool should_take_Compile_lock = !Compile_lock->owned_by_self();\n+    ConditionalMutexLocker locker(Compile_lock, should_take_Compile_lock, Mutex::_safepoint_check_flag);\n@@ -1020,0 +1021,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::is_scoped\n+\/\/\n+\/\/ Return true for methods annotated with @Scoped\n+bool ciMethod::is_scoped() const {\n+   return get_Method()->is_scoped();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+  bool is_scoped() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n@@ -605,0 +606,1 @@\n+        _nesting.check(); \/\/ Check if a reallocation in the resource arena is safe\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-  _bc_start=_was_wide=0;\n+  _bc_start = _was_wide = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1233,2 +1233,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -1237,2 +1235,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -1321,5 +1317,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -1345,5 +1336,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n-        }\n@@ -1362,1 +1348,1 @@\n-  AnnotationArray* a = assemble_annotations(runtime_visible_annotations,\n+  AnnotationArray* a = allocate_annotations(runtime_visible_annotations,\n@@ -1364,2 +1350,0 @@\n-                                            runtime_invisible_annotations,\n-                                            runtime_invisible_annotations_length,\n@@ -1368,1 +1352,1 @@\n-  a = assemble_annotations(runtime_visible_type_annotations,\n+  a = allocate_annotations(runtime_visible_type_annotations,\n@@ -1370,2 +1354,0 @@\n-                           runtime_invisible_type_annotations,\n-                           runtime_invisible_type_annotations_length,\n@@ -2258,2 +2240,0 @@\n-                                       const u1* runtime_invisible_annotations,\n-                                       int runtime_invisible_annotations_length,\n@@ -2262,2 +2242,0 @@\n-                                       const u1* runtime_invisible_parameter_annotations,\n-                                       int runtime_invisible_parameter_annotations_length,\n@@ -2266,2 +2244,0 @@\n-                                       const u1* runtime_invisible_type_annotations,\n-                                       int runtime_invisible_type_annotations_length,\n@@ -2274,3 +2250,2 @@\n-  if (runtime_visible_annotations_length +\n-      runtime_invisible_annotations_length > 0) {\n-     a = assemble_annotations(runtime_visible_annotations,\n+  if (runtime_visible_annotations_length > 0) {\n+     a = allocate_annotations(runtime_visible_annotations,\n@@ -2278,2 +2253,0 @@\n-                              runtime_invisible_annotations,\n-                              runtime_invisible_annotations_length,\n@@ -2284,3 +2257,2 @@\n-  if (runtime_visible_parameter_annotations_length +\n-      runtime_invisible_parameter_annotations_length > 0) {\n-    a = assemble_annotations(runtime_visible_parameter_annotations,\n+  if (runtime_visible_parameter_annotations_length > 0) {\n+    a = allocate_annotations(runtime_visible_parameter_annotations,\n@@ -2288,2 +2260,0 @@\n-                             runtime_invisible_parameter_annotations,\n-                             runtime_invisible_parameter_annotations_length,\n@@ -2295,1 +2265,1 @@\n-    a = assemble_annotations(annotation_default,\n+    a = allocate_annotations(annotation_default,\n@@ -2297,2 +2267,0 @@\n-                             nullptr,\n-                             0,\n@@ -2303,3 +2271,2 @@\n-  if (runtime_visible_type_annotations_length +\n-      runtime_invisible_type_annotations_length > 0) {\n-    a = assemble_annotations(runtime_visible_type_annotations,\n+  if (runtime_visible_type_annotations_length > 0) {\n+    a = allocate_annotations(runtime_visible_type_annotations,\n@@ -2307,2 +2274,0 @@\n-                             runtime_invisible_type_annotations,\n-                             runtime_invisible_type_annotations_length,\n@@ -2401,1 +2366,1 @@\n-  const u1* code_start = 0;\n+  const u1* code_start = nullptr;\n@@ -2432,2 +2397,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -2436,2 +2399,0 @@\n-  const u1* runtime_invisible_parameter_annotations = nullptr;\n-  int runtime_invisible_parameter_annotations_length = 0;\n@@ -2440,2 +2401,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -2712,5 +2671,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = method_attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -2737,6 +2691,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_parameter_annotations_length = method_attribute_length;\n-          runtime_invisible_parameter_annotations = cfs->current();\n-          assert(runtime_invisible_parameter_annotations != nullptr,\n-            \"null invisible parameter annotations\");\n-        }\n@@ -2773,7 +2721,0 @@\n-        } else {\n-          runtime_invisible_type_annotations_exists = true;\n-        }\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = method_attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -2781,0 +2722,1 @@\n+        runtime_invisible_type_annotations_exists = true;\n@@ -2814,6 +2756,3 @@\n-      runtime_visible_annotations_length +\n-           runtime_invisible_annotations_length,\n-      runtime_visible_parameter_annotations_length +\n-           runtime_invisible_parameter_annotations_length,\n-      runtime_visible_type_annotations_length +\n-           runtime_invisible_type_annotations_length,\n+      runtime_visible_annotations_length,\n+      runtime_visible_parameter_annotations_length,\n+      runtime_visible_type_annotations_length,\n@@ -2911,2 +2850,0 @@\n-                          runtime_invisible_annotations,\n-                          runtime_invisible_annotations_length,\n@@ -2915,2 +2852,0 @@\n-                          runtime_invisible_parameter_annotations,\n-                          runtime_invisible_parameter_annotations_length,\n@@ -2919,2 +2854,0 @@\n-                          runtime_invisible_type_annotations,\n-                          runtime_invisible_type_annotations_length,\n@@ -3459,2 +3392,0 @@\n-    const u1* runtime_invisible_annotations = nullptr;\n-    int runtime_invisible_annotations_length = 0;\n@@ -3464,2 +3395,0 @@\n-    const u1* runtime_invisible_type_annotations = nullptr;\n-    int runtime_invisible_type_annotations_length = 0;\n@@ -3516,5 +3445,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null record component invisible annotation\");\n-        }\n@@ -3543,5 +3467,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null record component invisible type annotation\");\n-        }\n@@ -3557,1 +3476,1 @@\n-    AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,\n+    AnnotationArray* annotations = allocate_annotations(runtime_visible_annotations,\n@@ -3559,2 +3478,0 @@\n-                                                        runtime_invisible_annotations,\n-                                                        runtime_invisible_annotations_length,\n@@ -3562,1 +3479,1 @@\n-    AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,\n+    AnnotationArray* type_annotations = allocate_annotations(runtime_visible_type_annotations,\n@@ -3564,2 +3481,0 @@\n-                                                             runtime_invisible_type_annotations,\n-                                                             runtime_invisible_type_annotations_length,\n@@ -3705,2 +3620,0 @@\n-  const u1* runtime_invisible_annotations = nullptr;\n-  int runtime_invisible_annotations_length = 0;\n@@ -3709,2 +3622,0 @@\n-  const u1* runtime_invisible_type_annotations = nullptr;\n-  int runtime_invisible_type_annotations_length = 0;\n@@ -3825,5 +3736,0 @@\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_annotations_length = attribute_length;\n-          runtime_invisible_annotations = cfs->current();\n-          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n-        }\n@@ -3881,7 +3787,0 @@\n-        } else {\n-          runtime_invisible_type_annotations_exists = true;\n-        }\n-        if (PreserveAllAnnotations) {\n-          runtime_invisible_type_annotations_length = attribute_length;\n-          runtime_invisible_type_annotations = cfs->current();\n-          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -3889,0 +3788,1 @@\n+        runtime_invisible_type_annotations_exists = true;\n@@ -3977,1 +3877,1 @@\n-  _class_annotations = assemble_annotations(runtime_visible_annotations,\n+  _class_annotations = allocate_annotations(runtime_visible_annotations,\n@@ -3979,2 +3879,0 @@\n-                                            runtime_invisible_annotations,\n-                                            runtime_invisible_annotations_length,\n@@ -3982,1 +3880,1 @@\n-  _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,\n+  _class_type_annotations = allocate_annotations(runtime_visible_type_annotations,\n@@ -3984,2 +3882,0 @@\n-                                                 runtime_invisible_type_annotations,\n-                                                 runtime_invisible_type_annotations_length,\n@@ -4136,4 +4032,2 @@\n-AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,\n-                                                       int runtime_visible_annotations_length,\n-                                                       const u1* const runtime_invisible_annotations,\n-                                                       int runtime_invisible_annotations_length,\n+AnnotationArray* ClassFileParser::allocate_annotations(const u1* const anno,\n+                                                       int anno_length,\n@@ -4142,2 +4036,1 @@\n-  if (runtime_visible_annotations != nullptr ||\n-      runtime_invisible_annotations != nullptr) {\n+  if (anno != nullptr) {\n@@ -4145,13 +4038,4 @@\n-                                          runtime_visible_annotations_length +\n-                                          runtime_invisible_annotations_length,\n-                                          CHECK_(annotations));\n-    if (runtime_visible_annotations != nullptr) {\n-      for (int i = 0; i < runtime_visible_annotations_length; i++) {\n-        annotations->at_put(i, runtime_visible_annotations[i]);\n-      }\n-    }\n-    if (runtime_invisible_annotations != nullptr) {\n-      for (int i = 0; i < runtime_invisible_annotations_length; i++) {\n-        int append = runtime_visible_annotations_length+i;\n-        annotations->at_put(append, runtime_invisible_annotations[i]);\n-      }\n+                                                 anno_length,\n+                                                 CHECK_(annotations));\n+    for (int i = 0; i < anno_length; i++) {\n+      annotations->at_put(i, anno[i]);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":26,"deletions":142,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,4 +380,2 @@\n-  AnnotationArray* assemble_annotations(const u1* const runtime_visible_annotations,\n-                                        int runtime_visible_annotations_length,\n-                                        const u1* const runtime_invisible_annotations,\n-                                        int runtime_invisible_annotations_length,\n+  AnnotationArray* allocate_annotations(const u1* const anno,\n+                                        int anno_length,\n@@ -551,2 +549,0 @@\n-                               const u1* runtime_invisible_annotations,\n-                               int runtime_invisible_annotations_length,\n@@ -555,2 +551,0 @@\n-                               const u1* runtime_invisible_parameter_annotations,\n-                               int runtime_invisible_parameter_annotations_length,\n@@ -559,2 +553,0 @@\n-                               const u1* runtime_invisible_type_annotations,\n-                               int runtime_invisible_type_annotations_length,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-template <typename T> class GrowableArray;\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoadInfo.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,3 +85,3 @@\n-    _cld(0),\n-    _class_loader(0),\n-    _parent(0),\n+    _cld(nullptr),\n+    _class_loader(),\n+    _parent(),\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,6 +207,7 @@\n-  SimpleCompactHashtable() {\n-    _entry_count = 0;\n-    _bucket_count = 0;\n-    _buckets = 0;\n-    _entries = 0;\n-  }\n+  SimpleCompactHashtable() :\n+    _base_address(nullptr),\n+    _bucket_count(0),\n+    _entry_count(0),\n+    _buckets(nullptr),\n+    _entries(nullptr)\n+  {}\n@@ -215,0 +216,1 @@\n+    _base_address = nullptr;\n@@ -217,2 +219,2 @@\n-    _buckets = 0;\n-    _entries = 0;\n+    _buckets = nullptr;\n+    _entries = nullptr;\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -873,1 +873,1 @@\n-  address code_start = 0;\n+  address code_start = nullptr;\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-JavaAssertions::OptionList*     JavaAssertions::_classes = 0;\n-JavaAssertions::OptionList*     JavaAssertions::_packages = 0;\n+JavaAssertions::OptionList*     JavaAssertions::_classes = nullptr;\n+JavaAssertions::OptionList*     JavaAssertions::_packages = nullptr;\n@@ -46,1 +46,1 @@\n-  assert(name != 0, \"need a name\");\n+  assert(name != nullptr, \"need a name\");\n@@ -54,1 +54,1 @@\n-  for (rc = 0; p != 0; p = p->next(), ++rc) \/* empty *\/;\n+  for (rc = 0; p != nullptr; p = p->next(), ++rc) \/* empty *\/;\n@@ -59,1 +59,1 @@\n-  assert(name != 0, \"must have a name\");\n+  assert(name != nullptr, \"must have a name\");\n@@ -138,1 +138,1 @@\n-  for (index = len - 1; p != 0; p = p->next(), --index) {\n+  for (index = len - 1; p != nullptr; p = p->next(), --index) {\n@@ -150,1 +150,1 @@\n-  for (OptionList* p = _classes; p != 0; p = p->next()) {\n+  for (OptionList* p = _classes; p != nullptr; p = p->next()) {\n@@ -155,1 +155,1 @@\n-  return 0;\n+  return nullptr;\n@@ -163,1 +163,1 @@\n-  if (_packages == 0) return 0;\n+  if (_packages == nullptr) return nullptr;\n@@ -173,1 +173,1 @@\n-    for (OptionList* p = _packages; p != 0; p = p->next()) {\n+    for (OptionList* p = _packages; p != nullptr; p = p->next()) {\n@@ -184,1 +184,1 @@\n-  return 0;\n+  return nullptr;\n@@ -196,1 +196,1 @@\n-  assert(classname != 0, \"must have a classname\");\n+  assert(classname != nullptr, \"must have a classname\");\n","filename":"src\/hotspot\/share\/classfile\/javaAssertions.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -756,1 +756,6 @@\n-void java_lang_String::print(oop java_string, outputStream* st) {\n+\/\/ Print the given string to the given outputStream, limiting the output to\n+\/\/ at most max_length of the string's characters. If the length exceeds the\n+\/\/ limit we print an abridged version of the string with the \"middle\" elided\n+\/\/ and replaced by \" ... (N characters ommitted) ... \". If max_length is odd\n+\/\/ it is treated as max_length-1.\n+void java_lang_String::print(oop java_string, outputStream* st, int max_length) {\n@@ -758,0 +763,3 @@\n+  \/\/ We need at least two characters to print A ... B\n+  assert(max_length > 1, \"invalid max_length: %d\", max_length);\n+\n@@ -770,0 +778,2 @@\n+  bool abridge = length > max_length;\n+\n@@ -772,0 +782,7 @@\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n@@ -781,0 +798,4 @@\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n@@ -1235,4 +1256,0 @@\n-void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {\n-  assert(_signers_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_signers_offset, signers);\n-}\n@@ -1439,6 +1456,7 @@\n-  macro(_classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,         false); \\\n-  macro(_class_loader_offset,        k, \"classLoader\",         classloader_signature, false); \\\n-  macro(_component_mirror_offset,    k, \"componentType\",       class_signature,       false); \\\n-  macro(_module_offset,              k, \"module\",              module_signature,      false); \\\n-  macro(_name_offset,                k, \"name\",                string_signature,      false); \\\n-  macro(_classData_offset,           k, \"classData\",           object_signature,      false);\n+  macro(_classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,          false); \\\n+  macro(_class_loader_offset,        k, \"classLoader\",         classloader_signature,  false); \\\n+  macro(_component_mirror_offset,    k, \"componentType\",       class_signature,        false); \\\n+  macro(_module_offset,              k, \"module\",              module_signature,       false); \\\n+  macro(_name_offset,                k, \"name\",                string_signature,       false); \\\n+  macro(_classData_offset,           k, \"classData\",           object_signature,       false); \\\n+  macro(_signers_offset,             k, \"signers\",             object_array_signature, false);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  static void print(oop java_string, outputStream* st);\n+  static void print(oop java_string, outputStream* st, int max_length = MaxStringPrintSize);\n@@ -211,1 +211,0 @@\n-  macro(java_lang_Class, signers,                object_signature,  false) \\\n@@ -306,3 +305,1 @@\n-\n-  static objArrayOop  signers(oop java_class);\n-  static void set_signers(oop java_class, objArrayOop signers);\n+  static objArrayOop signers(oop java_class);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-      DEBUG_ONLY(static void* last = 0);\n+      DEBUG_ONLY(static void* last = nullptr);\n@@ -347,0 +347,15 @@\n+\/\/ Symbols should represent entities from the constant pool that are\n+\/\/ limited to <64K in length, but usage errors creep in allowing Symbols\n+\/\/ to be used for arbitrary strings. For debug builds we will assert if\n+\/\/ a string is too long, whereas product builds will truncate it.\n+static int check_length(const char* name, int len) {\n+  assert(len <= Symbol::max_length(),\n+         \"String length %d exceeds the maximum Symbol length of %d\", len, Symbol::max_length());\n+  if (len > Symbol::max_length()) {\n+    warning(\"A string \\\"%.80s ... %.80s\\\" exceeds the maximum Symbol \"\n+            \"length of %d and has been truncated\", name, (name + len - 80), Symbol::max_length());\n+    len = Symbol::max_length();\n+  }\n+  return len;\n+}\n+\n@@ -348,1 +363,1 @@\n-  assert(len <= Symbol::max_length(), \"sanity\");\n+  len = check_length(name, len);\n@@ -488,0 +503,1 @@\n+    assert(len <= Symbol::max_length(), \"must be - these come from the constant pool\");\n@@ -497,0 +513,1 @@\n+  assert(len <= Symbol::max_length(), \"caller should have ensured this\");\n@@ -545,1 +562,1 @@\n-  int len = (int)strlen(name);\n+  int len = check_length(name, (int)strlen(name));\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -168,2 +168,2 @@\n-address CodeCache::_low_bound = 0;\n-address CodeCache::_high_bound = 0;\n+address CodeCache::_low_bound = nullptr;\n+address CodeCache::_high_bound = nullptr;\n@@ -1791,1 +1791,1 @@\n-void CodeCache::write_perf_map(const char* filename) {\n+void CodeCache::write_perf_map(const char* filename, outputStream* st) {\n@@ -1793,4 +1793,1 @@\n-\n-  \/\/ Perf expects to find the map file at \/tmp\/perf-<pid>.map\n-  \/\/ if the file name is not specified.\n-  char fname[32];\n+  char fname[JVM_MAXPATHLEN];\n@@ -1798,1 +1795,7 @@\n-    jio_snprintf(fname, sizeof(fname), \"\/tmp\/perf-%d.map\", os::current_process_id());\n+    \/\/ Invocation outside of jcmd requires pid substitution.\n+    if (!Arguments::copy_expand_pid(DEFAULT_PERFMAP_FILENAME,\n+                                    strlen(DEFAULT_PERFMAP_FILENAME),\n+                                    fname, JVM_MAXPATHLEN)) {\n+      st->print_cr(\"Warning: Not writing perf map as pid substitution failed.\");\n+      return;\n+    }\n@@ -1801,1 +1804,0 @@\n-\n@@ -1804,1 +1806,1 @@\n-    log_warning(codecache)(\"Failed to create %s for perf map\", filename);\n+    st->print_cr(\"Warning: Failed to create %s for perf map\", filename);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -83,0 +83,4 @@\n+#ifdef LINUX\n+#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-%p.map\"\n+#endif\n+\n@@ -226,1 +230,1 @@\n-  LINUX_ONLY(static void write_perf_map(const char* filename = nullptr);)\n+  LINUX_ONLY(static void write_perf_map(const char* filename, outputStream* st);) \/\/ Prints warnings and error messages to outputStream\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    _deps[i] = new(arena) GrowableArray<ciBaseObject*>(arena, 10, 0, 0);\n+    _deps[i] = new(arena) GrowableArray<ciBaseObject*>(arena, 10, 0, nullptr);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1248,0 +1248,1 @@\n+  _has_scoped_access          = 0;\n@@ -3290,1 +3291,1 @@\n-    if (value == 0) {\n+    if (value == nullptr) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+          _has_scoped_access:1,        \/\/ used by for shared scope closure (scopedMemoryAccess.cpp)\n@@ -675,0 +676,3 @@\n+  bool  has_scoped_access() const                 { return _has_scoped_access; }\n+  void  set_has_scoped_access(bool z)             { _has_scoped_access = z; }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-      _handles  = new(_arena) GrowableArray<T>(_arena, 10, 0, 0);\n-      _no_finds = new(_arena) GrowableArray<int>(    _arena, 10, 0, 0);\n+      _handles  = new(_arena) GrowableArray<T>(_arena, 10, 0, T{});\n+      _no_finds = new(_arena) GrowableArray<int>(_arena, 10, 0, 0);\n@@ -74,2 +74,2 @@\n-      _handles  = new GrowableArray<T>(10, 0, 0);\n-      _no_finds = new GrowableArray<int>(    10, 0, 0);\n+      _handles  = new GrowableArray<T>(10, 0, T{});\n+      _no_finds = new GrowableArray<int>(10, 0, 0);\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -376,0 +376,8 @@\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+void trampoline_stub_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {\n+  \/\/ Finalize owner destination only for nmethods\n+  if (dest->blob() != nullptr) return;\n+  pd_fix_owner_after_move();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1261,0 +1261,5 @@\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+  void pd_fix_owner_after_move();\n+  void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) override;\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -269,1 +269,2 @@\n-  int vtable_index;\n+  short vtable_index;\n+  static_assert(sizeof(VtableStub::_index) == sizeof(vtable_index), \"precondition\");\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,9 +54,14 @@\n-ArenaStatCounter::ArenaStatCounter() :\n-  _current(0), _start(0), _peak(0),\n-  _na(0), _ra(0),\n-  _limit(0), _hit_limit(false), _limit_in_process(false),\n-  _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0)\n-{}\n-\n-size_t ArenaStatCounter::peak_since_start() const {\n-  return _peak > _start ? _peak - _start : 0;\n+ArenaStatCounter::ArenaStatCounter() {\n+  reset();\n+}\n+\n+void ArenaStatCounter::reset() {\n+  _current = 0;\n+  _peak = 0;\n+  _current_by_tag.clear();\n+  _peak_by_tag.clear();\n+  _limit = 0;\n+  _hit_limit = false;\n+  _limit_in_process = false;\n+  _live_nodes_at_peak = 0;\n+  _active = false;\n@@ -66,1 +71,2 @@\n-  _peak = _start = _current;\n+  reset();\n+  _active = true;\n@@ -68,1 +74,0 @@\n-  _hit_limit = false;\n@@ -71,1 +76,1 @@\n-void ArenaStatCounter::end(){\n+void ArenaStatCounter::end() {\n@@ -74,0 +79,1 @@\n+  _active = false;\n@@ -77,0 +83,1 @@\n+  assert(_active, \"compilaton has not yet started\");\n@@ -93,0 +100,1 @@\n+  assert(_active, \"compilaton has not yet started\");\n@@ -99,1 +107,1 @@\n-         \"Negative overflow (d=%zd %zu %zu %zu)\", delta, _current, _start, _peak);\n+         \"Negative overflow (d=%zd %zu %zu)\", delta, _current, _peak);\n@@ -103,7 +111,1 @@\n-  \/\/ Update detail counter\n-  switch ((Arena::Tag)tag) {\n-    case Arena::Tag::tag_ra: _ra += delta; break;\n-    case Arena::Tag::tag_node: _na += delta; break;\n-    default: \/\/ ignore\n-      break;\n-  };\n+  _current_by_tag.add(tag, delta);\n@@ -113,3 +115,1 @@\n-    assert(delta > 0, \"Sanity (%zu %zu %zu)\", _current, _start, _peak);\n-    _na_at_peak = _na;\n-    _ra_at_peak = _ra;\n+    assert(delta > 0, \"Sanity (%zu %zu)\", _current, _peak);\n@@ -117,0 +117,1 @@\n+    _peak_by_tag = _current_by_tag;\n@@ -119,1 +120,1 @@\n-    if (!_hit_limit && _limit > 0 && peak_since_start() > _limit) {\n+    if (!_hit_limit && _limit > 0 && _peak > _limit) {\n@@ -127,1 +128,7 @@\n-  st->print(\"%zu [na %zu ra %zu]\", peak_since_start(), _na_at_peak, _ra_at_peak);\n+  st->print(\"%zu [\", _peak);\n+  for (int tag = 0; tag < _peak_by_tag.element_count(); tag++) {\n+    if (_peak_by_tag.counter(tag) > 0) {\n+      st->print(\"%s %zu \", _peak_by_tag.tag_name(tag), _peak_by_tag.counter(tag));\n+    }\n+  }\n+  st->print(\"]\");\n@@ -129,1 +136,1 @@\n-  st->print(\" (%zu->%zu->%zu)\", _start, _peak, _current);\n+  st->print(\" (%zu->%zu)\", _peak, _current);\n@@ -189,4 +196,2 @@\n-  \/\/ usage in node arena when total peaked\n-  size_t _na_at_peak;\n-  \/\/ usage in resource area when total peaked\n-  size_t _ra_at_peak;\n+  \/\/ usage per arena tag when total peaked\n+  ArenaCountersByTag _peak_by_tag;\n@@ -202,1 +207,1 @@\n-      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0),\n+      _total(0), _live_nodes_at_peak(0),\n@@ -204,0 +209,1 @@\n+    _peak_by_tag.clear();\n@@ -213,2 +219,1 @@\n-  void set_na_at_peak(size_t n) { _na_at_peak = n; }\n-  void set_ra_at_peak(size_t n) { _ra_at_peak = n; }\n+  void set_peak_by_tag(ArenaCountersByTag peak_by_tag) { _peak_by_tag = peak_by_tag; }\n@@ -222,0 +227,1 @@\n+#define LEGEND_KEY_FMT \"%11s\"\n@@ -223,10 +229,12 @@\n-    st->print_cr(\"  total  : memory allocated via arenas while compiling\");\n-    st->print_cr(\"  NA     : ...how much in node arenas (if c2)\");\n-    st->print_cr(\"  RA     : ...how much in resource areas\");\n-    st->print_cr(\"  result : Result: 'ok' finished successfully, 'oom' hit memory limit, 'err' compilation failed\");\n-    st->print_cr(\"  #nodes : ...how many nodes (c2 only)\");\n-    st->print_cr(\"  limit  : memory limit, if set\");\n-    st->print_cr(\"  time   : time of last compilation (sec)\");\n-    st->print_cr(\"  type   : compiler type\");\n-    st->print_cr(\"  #rc    : how often recompiled\");\n-    st->print_cr(\"  thread : compiler thread\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"total\", \"memory allocated via arenas while compiling\");\n+    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n+      st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", Arena::tag_name[tag], Arena::tag_desc[tag]);\n+    }\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"result\", \"Result: 'ok' finished successfully, 'oom' hit memory limit, 'err' compilation failed\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"#nodes\", \"...how many nodes (c2 only)\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"limit\", \"memory limit, if set\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"time\", \"time taken for last compilation (sec)\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"type\", \"compiler type\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"#rc\", \"how often recompiled\");\n+    st->print_cr(\"  \" LEGEND_KEY_FMT \": %s\", \"thread\", \"compiler thread\");\n+#undef LEGEND_KEY_FMT\n@@ -236,1 +244,11 @@\n-    st->print_cr(\"total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\");\n+#define SIZE_FMT \"%-10s\"\n+    st->print(SIZE_FMT, \"total\");\n+    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n+      st->print(SIZE_FMT, Arena::tag_name[tag]);\n+    }\n+#define HDR_FMT1 \"%-8s%-8s%-8s%-8s\"\n+#define HDR_FMT2 \"%-6s%-4s%-19s%s\"\n+\n+    st->print(HDR_FMT1, \"result\", \"#nodes\", \"limit\", \"time\");\n+    st->print(HDR_FMT2, \"type\", \"#rc\", \"thread\", \"method\");\n+    st->print_cr(\"\");\n@@ -250,13 +268,7 @@\n-    \/\/ NA\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_na_at_peak));\n-    } else {\n-      st->print(\"%zu \", _na_at_peak);\n-    }\n-    col += 10; st->fill_to(col);\n-\n-    \/\/ RA\n-    if (human_readable) {\n-      st->print(PROPERFMT \" \", PROPERFMTARGS(_ra_at_peak));\n-    } else {\n-      st->print(\"%zu \", _ra_at_peak);\n+    for (int tag = 0; tag < Arena::tag_count(); tag++) {\n+      if (human_readable) {\n+        st->print(PROPERFMT \" \", PROPERFMTARGS(_peak_by_tag.counter(tag)));\n+      } else {\n+        st->print(\"%zu \", _peak_by_tag.counter(tag));\n+      }\n+      col += 10; st->fill_to(col);\n@@ -264,1 +276,0 @@\n-    col += 10; st->fill_to(col);\n@@ -299,1 +310,1 @@\n-    st->print(PTR_FORMAT \"  \", p2i(_thread));\n+    st->print(PTR_FORMAT \" \", p2i(_thread));\n@@ -344,1 +355,1 @@\n-           size_t total, size_t na_at_peak, size_t ra_at_peak,\n+           size_t total, ArenaCountersByTag peak_by_tag,\n@@ -363,2 +374,1 @@\n-    e->set_na_at_peak(na_at_peak);\n-    e->set_ra_at_peak(ra_at_peak);\n+    e->set_peak_by_tag(peak_by_tag);\n@@ -430,1 +440,1 @@\n-  task->set_arena_bytes(arena_stat->peak_since_start());\n+  task->set_arena_bytes(arena_stat->peak());\n@@ -450,3 +460,2 @@\n-                    arena_stat->peak_since_start(), \/\/ total\n-                    arena_stat->na_at_peak(),\n-                    arena_stat->ra_at_peak(),\n+                    arena_stat->peak(), \/\/ total\n+                    arena_stat->peak_by_tag(),\n@@ -514,1 +523,1 @@\n-  if (arena_stat->account(diff, (int)arena->get_tag())) { \/\/ new peak?\n+  if (arena_stat->is_active() && arena_stat->account(diff, (int)arena->get_tag())) { \/\/ new peak?\n@@ -548,1 +557,1 @@\n-                 arena_stat->limit(), arena_stat->peak_since_start());\n+                 arena_stat->limit(), arena_stat->peak());\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":77,"deletions":68,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -38,1 +39,25 @@\n-\/\/ Counters for allocations from one arena\n+\/\/ Helper class to wrap the array of arena tags for easier processing\n+class ArenaCountersByTag {\n+private:\n+  size_t _counter[Arena::tag_count()];\n+\n+public:\n+  int element_count() const { return Arena::tag_count(); }\n+  const char* tag_name(int tag) const { return Arena::tag_name[tag]; }\n+\n+  size_t  counter(int tag) const {\n+    assert(tag < element_count(), \"invalid tag %d\", tag);\n+    return _counter[tag];\n+  }\n+\n+  void add(int tag, size_t value) {\n+    assert(tag < element_count(), \"invalid tag %d\", tag);\n+    _counter[tag] += value;\n+  }\n+\n+  void clear() {\n+    memset(_counter, 0, sizeof(size_t) * element_count());\n+  }\n+};\n+\n+\/\/ Counters for allocations from arenas during compilation\n@@ -42,2 +67,0 @@\n-  \/\/ bytes when compilation started\n-  size_t _start;\n@@ -46,4 +69,4 @@\n-  \/\/ Current bytes used for node arenas, total\n-  size_t _na;\n-  \/\/ Current bytes used for resource areas\n-  size_t _ra;\n+  \/\/ Current bytes used by arenas per tag\n+  ArenaCountersByTag _current_by_tag;\n+  \/\/ Peak composition:\n+  ArenaCountersByTag _peak_by_tag;\n@@ -55,5 +78,3 @@\n-  \/\/ Peak composition:\n-  \/\/ Size of node arena when total peaked (c2 only)\n-  size_t _na_at_peak;\n-  \/\/ Size of resource area when total peaked\n-  size_t _ra_at_peak;\n+  \/\/ When to start accounting\n+  bool _active;\n+\n@@ -65,0 +86,2 @@\n+  void reset();\n+\n@@ -69,1 +92,1 @@\n-  size_t peak_since_start() const;\n+  size_t peak() const { return _peak; }\n@@ -72,2 +95,1 @@\n-  size_t na_at_peak() const { return _na_at_peak; }\n-  size_t ra_at_peak() const { return _ra_at_peak; }\n+  ArenaCountersByTag peak_by_tag() const { return _peak_by_tag; }\n@@ -92,1 +114,1 @@\n-\n+  bool   is_active() const          { return _active; }\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -640,0 +640,4 @@\n+  tty->print_cr(\"The 'exclude' command excludes methods from top-level compilations as well as\");\n+  tty->print_cr(\"from inlining, whereas the 'compileonly' command only excludes methods from\");\n+  tty->print_cr(\"top-level compilations (i.e. they can still be inlined into other compilation units).\");\n+  tty->cr();\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,3 +90,4 @@\n-    \/\/ Yield if enough has been processed; returns if the concurrent marking cycle\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ Yield if enough has been processed. Return whether we should stop\n+    \/\/ processing this region because either the concurrent marking cycle has been\n+    \/\/ aborted or the region has been reclaimed.\n+    bool yield_if_necessary(G1HeapRegion* hr) {\n@@ -95,1 +96,5 @@\n-        _cm->do_yield_check();\n+        \/\/ If a yield occurs (potential young-gc pause), must recheck for\n+        \/\/ potential regions reclamation.\n+        if (_cm->do_yield_check() && !should_rebuild_or_scrub(hr)) {\n+          return true;\n+        }\n@@ -97,1 +102,1 @@\n-      return _cm->has_aborted();\n+      return _cm->has_aborted() || !should_rebuild_or_scrub(hr);\n@@ -114,2 +119,1 @@\n-    \/\/ Returns true if marking has been aborted or false if completed.\n-    bool scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    void scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -125,8 +129,3 @@\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n+\n+        if (yield_if_necessary(hr)) {\n+          return;\n@@ -138,1 +137,0 @@\n-      return false;\n@@ -168,54 +166,11 @@\n-    \/\/ Scrub a range of dead objects starting at scrub_start. Will never scrub past limit.\n-    HeapWord* scrub_to_next_live(G1HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n-      assert(!_bitmap->is_marked(scrub_start), \"Should not scrub live object\");\n-\n-      HeapWord* scrub_end = _bitmap->get_next_marked_addr(scrub_start, limit);\n-      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-\n-      \/\/ Return the next object to handle.\n-      return scrub_end;\n-    }\n-\n-    \/\/ Scan the given region from bottom to parsable_bottom. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_to_pb(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        if (_bitmap->is_marked(start)) {\n-          \/\/  Live object, need to scan to rebuild remembered sets for this object.\n-          start += scan_object(hr, start);\n-        } else {\n-          \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n-          \/\/ marked object and continue.\n-          start = scrub_to_next_live(hr, start, limit);\n-        }\n-\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n-      }\n-      return false;\n-    }\n-\n-    \/\/ Scan the given region from parsable_bottom to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_from_pb_to_tars(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        start += scan_object(hr, start);\n-        \/\/ Avoid stalling safepoints and stop iteration if mark cycle has been aborted.\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n+    \/\/ Scan or scrub depending on if addr is marked.\n+    HeapWord* scan_or_scrub(G1HeapRegion* hr, HeapWord* addr, HeapWord* limit) {\n+      if (_bitmap->is_marked(addr)) {\n+        \/\/  Live object, need to scan to rebuild remembered sets for this object.\n+        return addr + scan_object(hr, addr);\n+      } else {\n+        \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next marked object.\n+        HeapWord* scrub_end = _bitmap->get_next_marked_addr(addr, limit);\n+        hr->fill_range_with_dead_objects(addr, scrub_end);\n+        \/\/ Return the next object to handle.\n+        return scrub_end;\n@@ -223,1 +178,0 @@\n-      return false;\n@@ -226,3 +180,2 @@\n-    \/\/ Scan and scrub the given region to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ Scan and scrub the given region to tars.\n+    void scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -234,4 +187,6 @@\n-      if (scan_and_scrub_to_pb(hr, hr->bottom(), pb)) {\n-        log_trace(gc, marking)(\"Scan and scrub aborted for region: %u\", hr->hrm_index());\n-        return true;\n-      }\n+      {\n+        \/\/ Step 1: Scan the given region from bottom to parsable_bottom.\n+        HeapWord* start = hr->bottom();\n+        HeapWord* limit = pb;\n+        while (start < limit) {\n+          start = scan_or_scrub(hr, start, limit);\n@@ -239,4 +194,4 @@\n-      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n-      \/\/ re-check after above.\n-      if (!should_rebuild_or_scrub(hr)) {\n-        return false;\n+          if (yield_if_necessary(hr)) {\n+            return;\n+          }\n+        }\n@@ -244,0 +199,1 @@\n+\n@@ -248,4 +204,11 @@\n-      \/\/ Rebuild from TAMS (= parsable_bottom) to TARS.\n-      if (scan_from_pb_to_tars(hr, pb, _cm->top_at_rebuild_start(hr))) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n+      {\n+        \/\/ Step 2: Rebuild from TAMS (= parsable_bottom) to TARS.\n+        HeapWord* start = pb;\n+        HeapWord* limit = _cm->top_at_rebuild_start(hr);\n+        while (start < limit) {\n+          start += scan_object(hr, start);\n+\n+          if (yield_if_necessary(hr)) {\n+            return;\n+          }\n+        }\n@@ -253,1 +216,0 @@\n-      return false;\n@@ -257,2 +219,2 @@\n-    \/\/ stalling safepoints. Returns whether the concurrent marking phase has been aborted.\n-    bool scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ stalling safepoints.\n+    void scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -263,1 +225,1 @@\n-        return false;\n+        return;\n@@ -281,6 +243,1 @@\n-      bool mark_aborted = scan_large_object(hr, humongous, mr);\n-      if (mark_aborted) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n-      }\n-      return false;\n+      scan_large_object(hr, humongous, mr);\n@@ -315,1 +272,0 @@\n-      bool mark_aborted;\n@@ -318,1 +274,1 @@\n-        mark_aborted = scan_and_scrub_region(hr, pb);\n+        scan_and_scrub_region(hr, pb);\n@@ -322,1 +278,1 @@\n-        mark_aborted = scan_humongous_region(hr, pb);\n+        scan_humongous_region(hr, pb);\n@@ -325,1 +281,1 @@\n-      return mark_aborted;\n+      return _cm->has_aborted();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":56,"deletions":100,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-          range(0, 100)                                                     \\\n+          range(1, 100)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    os::free_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+    os::disclaim_memory((char*)aligned_region.start(), aligned_region.byte_size());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        os::free_memory((char*)start, size, page_size);\n+        os::disclaim_memory((char*)start, size);\n@@ -192,1 +192,6 @@\n-  assert_lock_strong(PSOldGenExpand_lock);\n+#ifdef ASSERT\n+  \/\/ If called by VM thread, locking is not needed.\n+  if (!Thread::current()->is_VM_thread()) {\n+    assert_lock_strong(PSOldGenExpand_lock);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  \/\/ precondition: holding PSOldGenExpand_lock\n+  \/\/ precondition: holding PSOldGenExpand_lock if not VM thread\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,3 +266,2 @@\n-HeapWord* ParallelScavengeHeap::mem_allocate(\n-                                     size_t size,\n-                                     bool* gc_overhead_limit_was_exceeded) {\n+HeapWord* ParallelScavengeHeap::mem_allocate(size_t size,\n+                                             bool* gc_overhead_limit_was_exceeded) {\n@@ -273,0 +272,8 @@\n+  bool is_tlab = false;\n+  return mem_allocate_work(size, is_tlab, gc_overhead_limit_was_exceeded);\n+}\n+\n+HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size,\n+                                                  bool is_tlab,\n+                                                  bool* gc_overhead_limit_was_exceeded) {\n+\n@@ -306,3 +313,5 @@\n-      result = mem_allocate_old_gen(size);\n-      if (result != nullptr) {\n-        return result;\n+      if (!is_tlab) {\n+        result = mem_allocate_old_gen(size);\n+        if (result != nullptr) {\n+          return result;\n+        }\n@@ -341,1 +350,1 @@\n-      VM_ParallelGCFailedAllocation op(size, gc_count);\n+      VM_ParallelCollectForAllocation op(size, is_tlab, gc_count);\n@@ -398,17 +407,0 @@\n-\/\/ A \"death march\" is a series of ultra-slow allocations in which a full gc is\n-\/\/ done before each allocation, and after the full gc the allocation still\n-\/\/ cannot be satisfied from the young gen.  This routine detects that condition;\n-\/\/ it should be called after a full gc has been done and the allocation\n-\/\/ attempted from the young gen. The parameter 'addr' should be the result of\n-\/\/ that young gen allocation attempt.\n-void\n-ParallelScavengeHeap::death_march_check(HeapWord* const addr, size_t size) {\n-  if (addr != nullptr) {\n-    _death_march_count = 0;  \/\/ death march has ended\n-  } else if (_death_march_count == 0) {\n-    if (should_alloc_in_eden(size)) {\n-      _death_march_count = 1;    \/\/ death march has started\n-    }\n-  }\n-}\n-\n@@ -430,10 +422,0 @@\n-  \/\/ If a \"death march\" is in progress, allocate from the old gen a limited\n-  \/\/ number of times before doing a GC.\n-  if (_death_march_count > 0) {\n-    if (_death_march_count < 64) {\n-      ++_death_march_count;\n-      return allocate_old_gen_and_record(size);\n-    } else {\n-      _death_march_count = 0;\n-    }\n-  }\n@@ -444,0 +426,3 @@\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n@@ -447,11 +432,2 @@\n-\/\/ Failed allocation policy. Must be called from the VM thread, and\n-\/\/ only at a safepoint! Note that this method has policy for allocation\n-\/\/ flow, and NOT collection policy. So we do not check for gc collection\n-\/\/ time over limit here, that is the responsibility of the heap specific\n-\/\/ collection methods. This method decides where to attempt allocations,\n-\/\/ and when to attempt collections, but no collection specific policy.\n-HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  assert(Thread::current() == (Thread*)VMThread::vm_thread(), \"should be in vm thread\");\n-  assert(!is_stw_gc_active(), \"not reentrant\");\n-  assert(!Heap_lock->owned_by_self(), \"this thread should not own the Heap_lock\");\n+HeapWord* ParallelScavengeHeap::expand_heap_and_allocate(size_t size, bool is_tlab) {\n+  HeapWord* result = nullptr;\n@@ -459,1 +435,6 @@\n-  \/\/ We assume that allocation in eden will fail unless we collect.\n+  result = young_gen()->allocate(size);\n+  if (result == nullptr && !is_tlab) {\n+    result = old_gen()->expand_and_allocate(size);\n+  }\n+  return result;   \/\/ Could be null if we are out of space.\n+}\n@@ -461,4 +442,2 @@\n-  \/\/ First level allocation failure, scavenge and allocate in young gen.\n-  GCCauseSetter gccs(this, GCCause::_allocation_failure);\n-  const bool invoked_full_gc = PSScavenge::invoke();\n-  HeapWord* result = young_gen()->allocate(size);\n+HeapWord* ParallelScavengeHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {\n+  assert(size != 0, \"precondition\");\n@@ -466,5 +445,5 @@\n-  \/\/ Second level allocation failure.\n-  \/\/   Mark sweep and allocate in young generation.\n-  if (result == nullptr && !invoked_full_gc) {\n-    do_full_collection(false);\n-    result = young_gen()->allocate(size);\n+  HeapWord* result = nullptr;\n+\n+  GCLocker::check_active_before_gc();\n+  if (GCLocker::is_active_and_needs_gc()) {\n+    return expand_heap_and_allocate(size, is_tlab);\n@@ -473,1 +452,3 @@\n-  death_march_check(result, size);\n+  \/\/ If young-gen can handle this allocation, attempt young-gc firstly.\n+  bool should_run_young_gc = is_tlab || should_alloc_in_eden(size);\n+  collect_at_safepoint(!should_run_young_gc);\n@@ -475,5 +456,3 @@\n-  \/\/ Third level allocation failure.\n-  \/\/   After mark sweep and young generation allocation failure,\n-  \/\/   allocate in old generation.\n-  if (result == nullptr) {\n-    result = allocate_old_gen_and_record(size);\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n+    return result;\n@@ -482,5 +461,15 @@\n-  \/\/ Fourth level allocation failure. We're running out of memory.\n-  \/\/   More complete mark sweep and allocate in young generation.\n-  if (result == nullptr) {\n-    do_full_collection(true);\n-    result = young_gen()->allocate(size);\n+  \/\/ If we reach this point, we're really out of memory. Try every trick\n+  \/\/ we can to reclaim memory. Force collection of soft references. Force\n+  \/\/ a complete compaction of the heap. Any additional methods for finding\n+  \/\/ free memory should be here, especially if they are expensive. If this\n+  \/\/ attempt fails, an OOM exception will be thrown.\n+  {\n+    \/\/ Make sure the heap is fully compacted\n+    uintx old_interval = HeapMaximumCompactionInterval;\n+    HeapMaximumCompactionInterval = 0;\n+\n+    const bool clear_all_soft_refs = true;\n+    PSParallelCompact::invoke(clear_all_soft_refs);\n+\n+    \/\/ Restore\n+    HeapMaximumCompactionInterval = old_interval;\n@@ -489,4 +478,3 @@\n-  \/\/ Fifth level allocation failure.\n-  \/\/   After more complete mark sweep, allocate in old generation.\n-  if (result == nullptr) {\n-    result = allocate_old_gen_and_record(size);\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n+    return result;\n@@ -495,1 +483,5 @@\n-  return result;\n+  \/\/ What else?  We might try synchronous finalization later.  If the total\n+  \/\/ space available is large enough for the allocation, then a more\n+  \/\/ complete compaction phase than we've tried so far might be\n+  \/\/ appropriate.\n+  return nullptr;\n@@ -498,0 +490,1 @@\n+\n@@ -516,1 +509,4 @@\n-  HeapWord* result = young_gen()->allocate(requested_size);\n+  bool dummy;\n+  HeapWord* result = mem_allocate_work(requested_size \/* size *\/,\n+                                       true \/* is_tlab *\/,\n+                                       &dummy);\n@@ -536,1 +532,0 @@\n-\/\/ This method is used by System.gc() and JVMTI.\n@@ -555,1 +550,1 @@\n-    VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);\n+    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n@@ -558,1 +553,1 @@\n-    if (!GCCause::is_explicit_full_gc(cause) || op.full_gc_succeeded()) {\n+    if (!GCCause::is_explicit_full_gc(cause)) {\n@@ -576,0 +571,27 @@\n+void ParallelScavengeHeap::try_collect_at_safepoint(bool full) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n+  collect_at_safepoint(full);\n+}\n+\n+bool ParallelScavengeHeap::must_clear_all_soft_refs() {\n+  return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n+         _gc_cause == GCCause::_wb_full_gc;\n+}\n+\n+void ParallelScavengeHeap::collect_at_safepoint(bool full) {\n+  assert(!GCLocker::is_active(), \"precondition\");\n+  bool clear_soft_refs = must_clear_all_soft_refs();\n+\n+  if (!full) {\n+    bool success = PSScavenge::invoke(clear_soft_refs);\n+    if (success) {\n+      return;\n+    }\n+    \/\/ Upgrade to Full-GC if young-gc fails\n+  }\n+  PSParallelCompact::invoke(clear_soft_refs);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":97,"deletions":75,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -78,2 +78,0 @@\n-  unsigned int _death_march_count;\n-\n@@ -99,1 +97,4 @@\n- protected:\n+  void collect_at_safepoint(bool full);\n+\n+  bool must_clear_all_soft_refs();\n+\n@@ -103,1 +104,1 @@\n-  inline void death_march_check(HeapWord* const result, size_t size);\n+\n@@ -106,1 +107,9 @@\n- public:\n+  HeapWord* mem_allocate_work(size_t size,\n+                              bool is_tlab,\n+                              bool* gc_overhead_limit_was_exceeded);\n+\n+  HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);\n+\n+  void do_full_collection(bool clear_all_soft_refs) override;\n+\n+public:\n@@ -109,1 +118,0 @@\n-    _death_march_count(0),\n@@ -187,4 +195,1 @@\n-  \/\/ Allocation attempt(s) during a safepoint. It should never be called\n-  \/\/ to allocate a new TLAB as this allocation might be satisfied out\n-  \/\/ of the old generation.\n-  HeapWord* failed_mem_allocate(size_t size);\n+  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n@@ -195,11 +200,1 @@\n-  \/\/ These also should be called by the vm thread at a safepoint (e.g., from a\n-  \/\/ VM operation).\n-  \/\/\n-  \/\/ The first collects the young generation only, unless the scavenge fails; it\n-  \/\/ will then attempt a full gc.  The second collects the entire heap; if\n-  \/\/ maximum_compaction is true, it will compact everything and clear all soft\n-  \/\/ references.\n-  inline bool invoke_scavenge();\n-\n-  \/\/ Perform a full collection\n-  void do_full_collection(bool clear_all_soft_refs) override;\n+  void try_collect_at_safepoint(bool full);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-inline bool ParallelScavengeHeap::invoke_scavenge() {\n-  return PSScavenge::invoke();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,2 +208,0 @@\n-  \/\/ Time statistics are updated as we go, update footprint stats here\n-  _avg_base_footprint->sample(BaseFootPrintEstimate);\n@@ -366,2 +364,1 @@\n-  log_trace(gc, ergo)(\"Base_footprint: \" SIZE_FORMAT \" avg_young_live: \" SIZE_FORMAT \" avg_old_live: \" SIZE_FORMAT,\n-                      (size_t)_avg_base_footprint->average(),\n+  log_trace(gc, ergo)(\"avg_young_live: \" SIZE_FORMAT \" avg_old_live: \" SIZE_FORMAT,\n@@ -538,2 +535,1 @@\n-  log_trace(gc, ergo)(\"Base_footprint: \" SIZE_FORMAT \" avg_young_live: \" SIZE_FORMAT \" avg_old_live: \" SIZE_FORMAT,\n-                      (size_t)_avg_base_footprint->average(),\n+  log_trace(gc, ergo)(\"avg_young_live: \" SIZE_FORMAT \" avg_old_live: \" SIZE_FORMAT,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,2 +148,1 @@\n-    return (size_t)(avg_base_footprint()->average() +\n-                    avg_young_live()->average() +\n+    return (size_t)(avg_young_live()->average() +\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,3 @@\n-ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks) {\n+ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks,\n+                                           ReferenceProcessor* ref_processor)\n+  : _mark_and_push_closure(this, ref_processor) {\n@@ -70,2 +72,3 @@\n-  assert(ParallelScavengeHeap::heap() != nullptr,\n-    \"Needed for initialization\");\n+  assert(ParallelScavengeHeap::heap() != nullptr, \"Needed for initialization\");\n+  assert(PSParallelCompact::ref_processor() != nullptr, \"precondition\");\n+  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0, \"Not initialized?\");\n@@ -89,1 +92,2 @@\n-    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i));\n+    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i),\n+                                                 PSParallelCompact::ref_processor());\n@@ -95,3 +99,0 @@\n-  assert(ParallelScavengeHeap::heap()->workers().max_workers() != 0,\n-    \"Not initialized?\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -43,0 +44,13 @@\n+class PCMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n+  ParCompactionManager* _compaction_manager;\n+\n+  template <typename T> void do_oop_work(T* p);\n+public:\n+  PCMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n+    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n+    _compaction_manager(cm) { }\n+\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n+};\n+\n@@ -50,0 +64,1 @@\n+  friend class PCAddThreadRootsMarkingTaskClosure;\n@@ -74,0 +89,1 @@\n+  PCMarkAndPushClosure _mark_and_push_closure;\n@@ -107,1 +123,3 @@\n-  ParCompactionManager(PreservedMarks* preserved_marks);\n+  ParCompactionManager(PreservedMarks* preserved_marks,\n+                       ReferenceProcessor* ref_processor);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,23 +44,4 @@\n-class PCMarkAndPushClosure: public OopClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCMarkAndPushClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n-\n-class PCIterateMarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n-private:\n-  ParCompactionManager* _compaction_manager;\n-public:\n-  PCIterateMarkAndPushClosure(ParCompactionManager* cm, ReferenceProcessor* rp) :\n-    ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_stw_fullgc_mark, rp),\n-    _compaction_manager(cm) { }\n-\n-  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n-};\n+template <typename T>\n+inline void PCMarkAndPushClosure::do_oop_work(T* p) {\n+  _compaction_manager->mark_and_push(p);\n+}\n@@ -164,1 +145,0 @@\n-  PCIterateMarkAndPushClosure cl(this, PSParallelCompact::ref_processor());\n@@ -167,1 +147,1 @@\n-    cl.do_klass(obj->klass());\n+    _mark_and_push_closure.do_klass(obj->klass());\n@@ -170,1 +150,1 @@\n-    obj->oop_iterate(&cl);\n+    obj->oop_iterate(&_mark_and_push_closure);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,4 +110,0 @@\n-    cname = PerfDataManager::counter_name(name_space(), \"avgBaseFootprint\");\n-    _avg_base_footprint = PerfDataManager::create_variable(SUN_GC, cname,\n-      PerfData::U_Bytes, (jlong) ps_size_policy()->avg_base_footprint()->average(), CHECK);\n-\n@@ -131,8 +127,0 @@\n-    cname = PerfDataManager::counter_name(name_space(), \"scavengeSkipped\");\n-    _scavenge_skipped = PerfDataManager::create_variable(SUN_GC, cname,\n-      PerfData::U_Bytes, (jlong) 0, CHECK);\n-\n-    cname = PerfDataManager::counter_name(name_space(), \"fullFollowsScavenge\");\n-    _full_follows_scavenge = PerfDataManager::create_variable(SUN_GC, cname,\n-      PerfData::U_Bytes, (jlong) 0, CHECK);\n-\n@@ -168,1 +156,0 @@\n-    update_avg_base_footprint();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psGCAdaptivePolicyCounters.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-  PerfVariable* _avg_base_footprint;\n@@ -64,3 +63,0 @@\n-  PerfVariable* _scavenge_skipped;\n-  PerfVariable* _full_follows_scavenge;\n-\n@@ -148,5 +144,0 @@\n-  inline void update_avg_base_footprint() {\n-    _avg_base_footprint->set_value(\n-      (jlong)(ps_size_policy()->avg_base_footprint()->average())\n-    );\n-  }\n@@ -183,8 +174,0 @@\n-  inline void update_scavenge_skipped(int cause) {\n-    _scavenge_skipped->set_value(cause);\n-  }\n-\n-  inline void update_full_follows_scavenge(int event) {\n-    _full_follows_scavenge->set_value(event);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psGCAdaptivePolicyCounters.hpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -123,0 +123,12 @@\n+HeapWord* PSOldGen::expand_and_allocate(size_t word_size) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  assert(Thread::current()->is_VM_thread(), \"precondition\");\n+  if (object_space()->needs_expand(word_size)) {\n+    expand(word_size*HeapWordSize);\n+  }\n+\n+  \/\/ Reuse the CAS API even though this is VM thread in safepoint. This method\n+  \/\/ is not invoked repeatedly, so the CAS overhead should be negligible.\n+  return cas_allocate_noexpand(word_size);\n+}\n+\n@@ -173,1 +185,4 @@\n-  assert_lock_strong(PSOldGenExpand_lock);\n+#ifdef ASSERT\n+  if (!Thread::current()->is_VM_thread()) {\n+    assert_lock_strong(PSOldGenExpand_lock);\n+  }\n@@ -176,0 +191,1 @@\n+#endif\n@@ -211,2 +227,0 @@\n-  assert_lock_strong(PSOldGenExpand_lock);\n-  assert_locked_or_safepoint(Heap_lock);\n@@ -247,3 +261,0 @@\n-  assert_lock_strong(PSOldGenExpand_lock);\n-  assert_locked_or_safepoint(Heap_lock);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+  \/\/ Invoked by mutators and GC-workers.\n@@ -130,0 +131,3 @@\n+  \/\/ Invoked by VM thread inside a safepoint.\n+  HeapWord* expand_and_allocate(size_t word_size);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -972,0 +973,1 @@\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n@@ -1190,2 +1192,3 @@\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    MarkingNMethodClosure mark_and_push_in_blobs(&mark_and_push_closure, !NMethodToOopClosure::FixRelocations, true \/* keepalive nmethods *\/);\n+    MarkingNMethodClosure mark_and_push_in_blobs(&cm->_mark_and_push_closure,\n+                                                 !NMethodToOopClosure::FixRelocations,\n+                                                 true \/* keepalive nmethods *\/);\n@@ -1193,1 +1196,1 @@\n-    thread->oops_do(&mark_and_push_closure, &mark_and_push_in_blobs);\n+    thread->oops_do(&cm->_mark_and_push_closure, &mark_and_push_in_blobs);\n@@ -1234,2 +1237,0 @@\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-\n@@ -1237,1 +1238,1 @@\n-      CLDToOopClosure cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n+      CLDToOopClosure cld_closure(&cm->_mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -1244,2 +1245,4 @@\n-    PCAddThreadRootsMarkingTaskClosure closure(worker_id);\n-    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &closure);\n+    {\n+      PCAddThreadRootsMarkingTaskClosure closure(worker_id);\n+      Threads::possibly_parallel_threads_do(_active_workers > 1 \/* is_par *\/, &closure);\n+    }\n@@ -1249,1 +1252,1 @@\n-      _oop_storage_set_par_state.oops_do(&mark_and_push_closure);\n+      _oop_storage_set_par_state.oops_do(&cm->_mark_and_push_closure);\n@@ -1271,1 +1274,0 @@\n-    PCMarkAndPushClosure keep_alive(cm);\n@@ -1274,1 +1276,1 @@\n-    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &enqueue, &complete_gc);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &cm->_mark_and_push_closure, &enqueue, &complete_gc);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -224,36 +225,0 @@\n-\/\/ This method contains all heap specific policy for invoking scavenge.\n-\/\/ PSScavenge::invoke_no_policy() will do nothing but attempt to\n-\/\/ scavenge. It will not clean up after failed promotions, bail out if\n-\/\/ we've exceeded policy time limits, or any other special behavior.\n-\/\/ All such policy should be placed here.\n-\/\/\n-\/\/ Note that this method should only be called from the vm_thread while\n-\/\/ at a safepoint!\n-bool PSScavenge::invoke() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  assert(Thread::current() == (Thread*)VMThread::vm_thread(), \"should be in vm thread\");\n-  assert(!ParallelScavengeHeap::heap()->is_stw_gc_active(), \"not reentrant\");\n-\n-  ParallelScavengeHeap* const heap = ParallelScavengeHeap::heap();\n-  IsSTWGCActiveMark mark;\n-\n-  const bool scavenge_done = PSScavenge::invoke_no_policy();\n-  const bool need_full_gc = !scavenge_done;\n-  bool full_gc_done = false;\n-\n-  if (UsePerfData) {\n-    PSGCAdaptivePolicyCounters* const counters = heap->gc_policy_counters();\n-    const int ffs_val = need_full_gc ? full_follows_scavenge : not_skipped;\n-    counters->update_full_follows_scavenge(ffs_val);\n-  }\n-\n-  if (need_full_gc) {\n-    GCCauseSetter gccs(heap, GCCause::_adaptive_size_policy);\n-    const bool clear_all_softrefs = heap->soft_ref_policy()->should_clear_all_soft_refs();\n-\n-    full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);\n-  }\n-\n-  return full_gc_done;\n-}\n-\n@@ -291,8 +256,8 @@\n-      WorkerTask(\"ScavengeRootsTask\"),\n-      _strong_roots_scope(active_workers),\n-      _subtasks(ParallelRootType::sentinel),\n-      _old_gen(old_gen),\n-      _gen_top(old_gen->object_space()->top()),\n-      _active_workers(active_workers),\n-      _is_old_gen_empty(old_gen->object_space()->is_empty()),\n-      _terminator(active_workers, PSPromotionManager::vm_thread_promotion_manager()->stack_array_depth()) {\n+    WorkerTask(\"ScavengeRootsTask\"),\n+    _strong_roots_scope(active_workers),\n+    _subtasks(ParallelRootType::sentinel),\n+    _old_gen(old_gen),\n+    _gen_top(old_gen->object_space()->top()),\n+    _active_workers(active_workers),\n+    _is_old_gen_empty(old_gen->object_space()->is_empty()),\n+    _terminator(active_workers, PSPromotionManager::vm_thread_promotion_manager()->stack_array_depth()) {\n@@ -356,3 +321,1 @@\n-\/\/ This method contains no policy. You should probably\n-\/\/ be calling invoke() instead.\n-bool PSScavenge::invoke_no_policy() {\n+bool PSScavenge::invoke(bool clear_soft_refs) {\n@@ -362,3 +325,2 @@\n-  _gc_timer.register_gc_start();\n-\n-  if (GCLocker::check_active_before_gc()) {\n+  \/\/ Check for potential problems.\n+  if (!should_attempt_scavenge()) {\n@@ -368,0 +330,4 @@\n+  IsSTWGCActiveMark mark;\n+\n+  _gc_timer.register_gc_start();\n+\n@@ -371,5 +337,1 @@\n-  \/\/ Check for potential problems.\n-  if (!should_attempt_scavenge()) {\n-    return false;\n-  }\n-\n+  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n@@ -385,0 +347,3 @@\n+  assert(young_gen->to_space()->is_empty(),\n+         \"Attempt to scavenge with live objects in to_space\");\n+\n@@ -420,4 +385,0 @@\n-    assert(young_gen->to_space()->is_empty(),\n-           \"Attempt to scavenge with live objects in to_space\");\n-    young_gen->to_space()->clear(SpaceDecorator::Mangle);\n-\n@@ -428,1 +389,1 @@\n-    reference_processor()->start_discovery(false \/* always_clear *\/);\n+    reference_processor()->start_discovery(clear_soft_refs);\n@@ -443,2 +404,0 @@\n-    \/\/ We'll use the promotion manager again later.\n-    PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();\n@@ -467,2 +426,0 @@\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");\n-\n@@ -475,3 +432,0 @@\n-    \/\/ Verify that usage of root_closure didn't copy any objects.\n-    assert(promotion_manager->stacks_empty(),\"stacks should be empty at this point\");\n-\n@@ -540,4 +494,3 @@\n-          size_policy->compute_survivor_space_size_and_threshold(\n-                                                           _survivor_overflow,\n-                                                           _tenuring_threshold,\n-                                                           survivor_limit);\n+          size_policy->compute_survivor_space_size_and_threshold(_survivor_overflow,\n+                                                                 _tenuring_threshold,\n+                                                                 survivor_limit);\n@@ -545,3 +498,3 @@\n-       log_debug(gc, age)(\"Desired survivor size %zu bytes, new threshold %u (max threshold %u)\",\n-                          size_policy->calculated_survivor_size_in_bytes(),\n-                          _tenuring_threshold, MaxTenuringThreshold);\n+        log_debug(gc, age)(\"Desired survivor size %zu bytes, new threshold %u (max threshold %u)\",\n+                           size_policy->calculated_survivor_size_in_bytes(),\n+                           _tenuring_threshold, MaxTenuringThreshold);\n@@ -571,2 +524,2 @@\n-            young_gen->from_space()->capacity_in_bytes() -\n-            young_gen->to_space()->capacity_in_bytes();\n+                                 young_gen->from_space()->capacity_in_bytes() -\n+                                 young_gen->to_space()->capacity_in_bytes();\n@@ -602,1 +555,1 @@\n-                        size_policy->calculated_survivor_size_in_bytes());\n+                               size_policy->calculated_survivor_size_in_bytes());\n@@ -660,5 +613,0 @@\n-  PSGCAdaptivePolicyCounters* counters = heap->gc_policy_counters();\n-\n-  if (UsePerfData) {\n-    counters->update_scavenge_skipped(not_skipped);\n-  }\n@@ -669,1 +617,0 @@\n-  \/\/ Do not attempt to promote unless to_space is empty\n@@ -671,3 +618,1 @@\n-    if (UsePerfData) {\n-      counters->update_scavenge_skipped(to_space_not_empty);\n-    }\n+    \/\/ To-space is not empty; should run full-gc instead.\n@@ -690,3 +635,0 @@\n-  if (young_gen->used_in_bytes() < (size_t) policy->padded_average_promoted_in_bytes()) {\n-    log_trace(ergo)(\" padded_promoted_average is greater than maximum promotion = \" SIZE_FORMAT, young_gen->used_in_bytes());\n-  }\n@@ -694,5 +636,0 @@\n-  if (!result) {\n-    if (UsePerfData) {\n-      counters->update_scavenge_skipped(promoted_too_large);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":31,"deletions":94,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -48,7 +48,0 @@\n- enum ScavengeSkippedCause {\n-   not_skipped = 0,\n-   to_space_not_empty,\n-   promoted_too_large,\n-   full_follows_scavenge\n- };\n-\n@@ -108,4 +101,3 @@\n-  \/\/ Scavenge entry point.  This may invoke a full gc; return true if so.\n-  static bool invoke();\n-  \/\/ Return true if a collection was done; false otherwise.\n-  static bool invoke_no_policy();\n+  \/\/ Scavenge entry point.\n+  \/\/ Return true iff a young-gc is completed without promotion-failure.\n+  static bool invoke(bool clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,3 +34,5 @@\n-VM_ParallelGCFailedAllocation::VM_ParallelGCFailedAllocation(size_t word_size,\n-                                                             uint gc_count) :\n-    VM_CollectForAllocation(word_size, gc_count, GCCause::_allocation_failure) {\n+VM_ParallelCollectForAllocation::VM_ParallelCollectForAllocation(size_t word_size,\n+                                                                 bool is_tlab,\n+                                                                 uint gc_count) :\n+  VM_CollectForAllocation(word_size, gc_count, GCCause::_allocation_failure),\n+  _is_tlab(is_tlab) {\n@@ -40,3 +42,1 @@\n-void VM_ParallelGCFailedAllocation::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-\n+void VM_ParallelCollectForAllocation::doit() {\n@@ -46,1 +46,1 @@\n-  _result = heap->failed_mem_allocate(_word_size);\n+  _result = heap->satisfy_failed_allocation(_word_size, _is_tlab);\n@@ -59,1 +59,1 @@\n-VM_ParallelGCSystemGC::VM_ParallelGCSystemGC(uint gc_count,\n+VM_ParallelGCCollect::VM_ParallelGCCollect(uint gc_count,\n@@ -62,7 +62,1 @@\n-  VM_GC_Operation(gc_count, gc_cause, full_gc_count, is_cause_full(gc_cause)),\n-  _full_gc_succeeded(false)\n-{\n-}\n-\n-void VM_ParallelGCSystemGC::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::FULL);\n+  VM_GC_Operation(gc_count, gc_cause, full_gc_count, is_cause_full(gc_cause)) {}\n@@ -70,0 +64,1 @@\n+void VM_ParallelGCCollect::doit() {\n@@ -73,6 +68,1 @@\n-  if (!_full) {\n-    \/\/ If (and only if) the scavenge fails, this will invoke a full gc.\n-    _full_gc_succeeded = heap->invoke_scavenge();\n-  } else {\n-    _full_gc_succeeded = PSParallelCompact::invoke(false);\n-  }\n+  heap->try_collect_at_safepoint(_full);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,3 +32,4 @@\n-class VM_ParallelGCFailedAllocation : public VM_CollectForAllocation {\n- public:\n-  VM_ParallelGCFailedAllocation(size_t word_size, uint gc_count);\n+class VM_ParallelCollectForAllocation : public VM_CollectForAllocation {\n+  bool _is_tlab;\n+public:\n+  VM_ParallelCollectForAllocation(size_t word_size, bool is_tlab, uint gc_count);\n@@ -37,1 +38,1 @@\n-    return VMOp_ParallelGCFailedAllocation;\n+    return VMOp_ParallelCollectForAllocation;\n@@ -42,2 +43,1 @@\n-class VM_ParallelGCSystemGC: public VM_GC_Operation {\n-  bool _full_gc_succeeded;\n+class VM_ParallelGCCollect: public VM_GC_Operation {\n@@ -45,2 +45,2 @@\n-  VM_ParallelGCSystemGC(uint gc_count, uint full_gc_count, GCCause::Cause gc_cause);\n-  virtual VMOp_Type type() const { return VMOp_ParallelGCSystemGC; }\n+  VM_ParallelGCCollect(uint gc_count, uint full_gc_count, GCCause::Cause gc_cause);\n+  virtual VMOp_Type type() const { return VMOp_ParallelGCCollect; }\n@@ -48,1 +48,0 @@\n-  bool full_gc_succeeded() const { return _full_gc_succeeded; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  BasicType         _type;\n@@ -109,0 +108,1 @@\n+  BasicType         _type;\n@@ -117,1 +117,0 @@\n-    _type(type),\n@@ -121,0 +120,1 @@\n+    _type(type),\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  delete_list(Atomic::load(&pending_list._head));\n+  delete_list(pending_list._head);\n@@ -109,1 +109,1 @@\n-  return _pending_lists[index].count();;\n+  return _pending_lists[index].count();\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-\/\/        VM_ParallelGCSystemGC\n+\/\/        VM_ParallelGCCollect\n@@ -48,1 +48,1 @@\n-\/\/          VM_ParallelGCFailedAllocation\n+\/\/          VM_ParallelCollectForAllocation\n@@ -67,1 +67,1 @@\n-\/\/  VM_ParallelGCFailedAllocation\n+\/\/  VM_ParallelCollectForAllocation\n@@ -73,1 +73,1 @@\n-\/\/  VM_ParallelGCSystemGC\n+\/\/  VM_ParallelGCCollect\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -425,4 +425,0 @@\n-  product(size_t, BaseFootPrintEstimate, 256*M,                             \\\n-          \"Estimate of footprint other than Java Heap\")                     \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,8 +186,0 @@\n-LIR_Opr ShenandoahBarrierSetC1::iu_barrier(LIRGenerator* gen, LIR_Opr obj, CodeEmitInfo* info, DecoratorSet decorators) {\n-  if (ShenandoahIUBarrier) {\n-    obj = ensure_in_register(gen, obj, T_OBJECT);\n-    pre_barrier(gen, info, decorators, LIR_OprFact::illegalOpr, obj);\n-  }\n-  return obj;\n-}\n-\n@@ -199,1 +191,0 @@\n-    value = iu_barrier(access.gen(), value, access.access_emit_info(), access.decorators());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-  LIR_Opr iu_barrier(LIRGenerator* gen, LIR_Opr obj, CodeEmitInfo* info, DecoratorSet decorators);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,19 +51,1 @@\n-  : _iu_barriers(new (comp_arena) GrowableArray<ShenandoahIUBarrierNode*>(comp_arena, 8,  0, nullptr)),\n-    _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, nullptr)) {\n-}\n-\n-int ShenandoahBarrierSetC2State::iu_barriers_count() const {\n-  return _iu_barriers->length();\n-}\n-\n-ShenandoahIUBarrierNode* ShenandoahBarrierSetC2State::iu_barrier(int idx) const {\n-  return _iu_barriers->at(idx);\n-}\n-\n-void ShenandoahBarrierSetC2State::add_iu_barrier(ShenandoahIUBarrierNode* n) {\n-  assert(!_iu_barriers->contains(n), \"duplicate entry in barrier list\");\n-  _iu_barriers->append(n);\n-}\n-\n-void ShenandoahBarrierSetC2State::remove_iu_barrier(ShenandoahIUBarrierNode* n) {\n-  _iu_barriers->remove_if_existing(n);\n+  : _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, nullptr)) {\n@@ -91,7 +73,0 @@\n-Node* ShenandoahBarrierSetC2::shenandoah_iu_barrier(GraphKit* kit, Node* obj) const {\n-  if (ShenandoahIUBarrier) {\n-    return kit->gvn().transform(new ShenandoahIUBarrierNode(obj));\n-  }\n-  return obj;\n-}\n-\n@@ -511,3 +486,0 @@\n-    Node* value = val.node();\n-    value = shenandoah_iu_barrier(kit, value);\n-    val.set_node(value);\n@@ -516,10 +488,0 @@\n-  } else {\n-    assert(access.is_opt_access(), \"only for optimization passes\");\n-    assert(((decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) && (decorators & C2_ARRAY_COPY) != 0, \"unexpected caller of this code\");\n-    C2OptAccess& opt_access = static_cast<C2OptAccess&>(access);\n-    PhaseGVN& gvn =  opt_access.gvn();\n-\n-    if (ShenandoahIUBarrier) {\n-      Node* enqueue = gvn.transform(new ShenandoahIUBarrierNode(val.node()));\n-      val.set_node(enqueue);\n-    }\n@@ -601,1 +563,0 @@\n-    new_val = shenandoah_iu_barrier(kit, new_val);\n@@ -649,1 +610,0 @@\n-    new_val = shenandoah_iu_barrier(kit, new_val);\n@@ -702,3 +662,0 @@\n-  if (access.is_oop()) {\n-    val = shenandoah_iu_barrier(kit, val);\n-  }\n@@ -722,1 +679,1 @@\n-  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier || node->Opcode() == Op_ShenandoahIUBarrier) return true;\n+  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;\n@@ -743,3 +700,0 @@\n-  if (c->Opcode() == Op_ShenandoahIUBarrier) {\n-    c = c->in(1);\n-  }\n@@ -778,3 +732,0 @@\n-  if (phase == Optimization) {\n-    return !ShenandoahIUBarrier;\n-  }\n@@ -839,5 +790,1 @@\n-    int flags = ShenandoahHeap::HAS_FORWARDED;\n-    if (ShenandoahIUBarrier) {\n-      flags |= ShenandoahHeap::MARKING;\n-    }\n-    Node* stable_and  = phase->transform_later(new AndINode(gc_state, phase->igvn().intcon(flags)));\n+    Node* stable_and  = phase->transform_later(new AndINode(gc_state, phase->igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));\n@@ -892,3 +839,0 @@\n-  if (node->Opcode() == Op_ShenandoahIUBarrier) {\n-    state()->add_iu_barrier((ShenandoahIUBarrierNode*) node);\n-  }\n@@ -901,3 +845,0 @@\n-  if (node->Opcode() == Op_ShenandoahIUBarrier) {\n-    state()->remove_iu_barrier((ShenandoahIUBarrierNode*) node);\n-  }\n@@ -951,6 +892,1 @@\n-  for (int i = state()->iu_barriers_count() - 1; i >= 0; i--) {\n-    ShenandoahIUBarrierNode* n = state()->iu_barrier(i);\n-    if (!useful.member(n)) {\n-      state()->remove_iu_barrier(n);\n-    }\n-  }\n+\n@@ -1193,3 +1129,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), delayed_worklist);\n-      break;\n@@ -1219,3 +1152,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), nullptr);\n-      return true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":4,"deletions":74,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  GrowableArray<ShenandoahIUBarrierNode*>* _iu_barriers;\n@@ -40,5 +39,0 @@\n-  int iu_barriers_count() const;\n-  ShenandoahIUBarrierNode* iu_barrier(int idx) const;\n-  void add_iu_barrier(ShenandoahIUBarrierNode* n);\n-  void remove_iu_barrier(ShenandoahIUBarrierNode * n);\n-\n@@ -76,2 +70,0 @@\n-  Node* shenandoah_iu_barrier(GraphKit* kit, Node* obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  if ((state->iu_barriers_count() +\n-       state->load_reference_barriers_count()) > 0) {\n+  if (state->load_reference_barriers_count() > 0) {\n@@ -189,10 +188,1 @@\n-          uint i = 0;\n-          for (; i < phis.size(); i++) {\n-            Node* n = phis.node_at(i);\n-            if (n->Opcode() == Op_ShenandoahIUBarrier) {\n-              break;\n-            }\n-          }\n-          if (i == phis.size()) {\n-            return false;\n-          }\n+          return false;\n@@ -202,9 +192,0 @@\n-      } else if (in->Opcode() == Op_ShenandoahIUBarrier) {\n-        if (t != ShenandoahOopStore) {\n-          in = in->in(1);\n-          continue;\n-        }\n-        if (trace) {tty->print(\"Found enqueue barrier\"); in->dump();}\n-        phis.push(in, in->req());\n-        in = in->in(1);\n-        continue;\n@@ -329,1 +310,1 @@\n-        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -371,1 +352,1 @@\n-          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -535,1 +516,1 @@\n-    } else if (n->Opcode() == Op_ShenandoahIUBarrier || n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n+    } else if (n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n@@ -1115,14 +1096,0 @@\n-  for (int i = 0; i < state->iu_barriers_count(); i++) {\n-    Node* barrier = state->iu_barrier(i);\n-    Node* ctrl = phase->get_ctrl(barrier);\n-    IdealLoopTree* loop = phase->get_loop(ctrl);\n-    Node* head = loop->head();\n-    if (head->is_OuterStripMinedLoop()) {\n-      \/\/ Expanding a barrier here will break loop strip mining\n-      \/\/ verification. Transform the loop so the loop nest doesn't\n-      \/\/ appear as strip mined.\n-      OuterStripMinedLoopNode* outer = head->as_OuterStripMinedLoop();\n-      hide_strip_mined_loop(outer, outer->unique_ctrl_out()->as_CountedLoop(), phase);\n-    }\n-  }\n-\n@@ -1459,151 +1426,0 @@\n-\n-  for (int i = state->iu_barriers_count() - 1; i >= 0; i--) {\n-    Node* barrier = state->iu_barrier(i);\n-    Node* pre_val = barrier->in(1);\n-\n-    if (phase->igvn().type(pre_val)->higher_equal(TypePtr::NULL_PTR)) {\n-      ShouldNotReachHere();\n-      continue;\n-    }\n-\n-    Node* ctrl = phase->get_ctrl(barrier);\n-\n-    if (ctrl->is_Proj() && ctrl->in(0)->is_CallJava()) {\n-      assert(is_dominator(phase->get_ctrl(pre_val), ctrl->in(0)->in(0), pre_val, ctrl->in(0), phase), \"can't move\");\n-      ctrl = ctrl->in(0)->in(0);\n-      phase->set_ctrl(barrier, ctrl);\n-    } else if (ctrl->is_CallRuntime()) {\n-      assert(is_dominator(phase->get_ctrl(pre_val), ctrl->in(0), pre_val, ctrl, phase), \"can't move\");\n-      ctrl = ctrl->in(0);\n-      phase->set_ctrl(barrier, ctrl);\n-    }\n-\n-    Node* init_ctrl = ctrl;\n-    IdealLoopTree* loop = phase->get_loop(ctrl);\n-    Node* raw_mem = fixer.find_mem(ctrl, barrier);\n-    Node* init_raw_mem = raw_mem;\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, nullptr);\n-    Node* heap_stable_ctrl = nullptr;\n-    Node* null_ctrl = nullptr;\n-    uint last = phase->C->unique();\n-\n-    enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };\n-    Node* region = new RegionNode(PATH_LIMIT);\n-    Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };\n-    Node* region2 = new RegionNode(PATH_LIMIT2);\n-    Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Stable path.\n-    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::MARKING);\n-    region->init_req(_heap_stable, heap_stable_ctrl);\n-    phi->init_req(_heap_stable, raw_mem);\n-\n-    \/\/ Null path\n-    Node* reg2_ctrl = nullptr;\n-    test_null(ctrl, pre_val, null_ctrl, phase);\n-    if (null_ctrl != nullptr) {\n-      reg2_ctrl = null_ctrl->in(0);\n-      region2->init_req(_null_path, null_ctrl);\n-      phi2->init_req(_null_path, raw_mem);\n-    } else {\n-      region2->del_req(_null_path);\n-      phi2->del_req(_null_path);\n-    }\n-\n-    const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());\n-    const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());\n-    Node* thread = new ThreadLocalNode();\n-    phase->register_new_node(thread, ctrl);\n-    Node* buffer_adr = new AddPNode(phase->C->top(), thread, phase->igvn().MakeConX(buffer_offset));\n-    phase->register_new_node(buffer_adr, ctrl);\n-    Node* index_adr = new AddPNode(phase->C->top(), thread, phase->igvn().MakeConX(index_offset));\n-    phase->register_new_node(index_adr, ctrl);\n-\n-    BasicType index_bt = TypeX_X->basic_type();\n-    assert(sizeof(size_t) == type2aelembytes(index_bt), \"Loading Shenandoah SATBMarkQueue::_index with wrong size.\");\n-    const TypePtr* adr_type = TypeRawPtr::BOTTOM;\n-    Node* index = new LoadXNode(ctrl, raw_mem, index_adr, adr_type, TypeX_X, MemNode::unordered);\n-    phase->register_new_node(index, ctrl);\n-    Node* index_cmp = new CmpXNode(index, phase->igvn().MakeConX(0));\n-    phase->register_new_node(index_cmp, ctrl);\n-    Node* index_test = new BoolNode(index_cmp, BoolTest::ne);\n-    phase->register_new_node(index_test, ctrl);\n-    IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);\n-    if (reg2_ctrl == nullptr) reg2_ctrl = queue_full_iff;\n-    phase->register_control(queue_full_iff, loop, ctrl);\n-    Node* not_full = new IfTrueNode(queue_full_iff);\n-    phase->register_control(not_full, loop, queue_full_iff);\n-    Node* full = new IfFalseNode(queue_full_iff);\n-    phase->register_control(full, loop, queue_full_iff);\n-\n-    ctrl = not_full;\n-\n-    Node* next_index = new SubXNode(index, phase->igvn().MakeConX(sizeof(intptr_t)));\n-    phase->register_new_node(next_index, ctrl);\n-\n-    Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);\n-    phase->register_new_node(buffer, ctrl);\n-    Node *log_addr = new AddPNode(phase->C->top(), buffer, next_index);\n-    phase->register_new_node(log_addr, ctrl);\n-    Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);\n-    phase->register_new_node(log_store, ctrl);\n-    \/\/ update the index\n-    Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);\n-    phase->register_new_node(index_update, ctrl);\n-\n-    \/\/ Fast-path case\n-    region2->init_req(_fast_path, ctrl);\n-    phi2->init_req(_fast_path, index_update);\n-\n-    ctrl = full;\n-\n-    Node* base = find_bottom_mem(ctrl, phase);\n-\n-    MergeMemNode* mm = MergeMemNode::make(base);\n-    mm->set_memory_at(Compile::AliasIdxRaw, raw_mem);\n-    phase->register_new_node(mm, ctrl);\n-\n-    Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), \"shenandoah_wb_pre\", TypeRawPtr::BOTTOM);\n-    call->init_req(TypeFunc::Control, ctrl);\n-    call->init_req(TypeFunc::I_O, phase->C->top());\n-    call->init_req(TypeFunc::Memory, mm);\n-    call->init_req(TypeFunc::FramePtr, phase->C->top());\n-    call->init_req(TypeFunc::ReturnAdr, phase->C->top());\n-    call->init_req(TypeFunc::Parms, pre_val);\n-    call->init_req(TypeFunc::Parms+1, thread);\n-    phase->register_control(call, loop, ctrl);\n-\n-    Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);\n-    phase->register_control(ctrl_proj, loop, call);\n-    Node* mem_proj = new ProjNode(call, TypeFunc::Memory);\n-    phase->register_new_node(mem_proj, call);\n-\n-    \/\/ Slow-path case\n-    region2->init_req(_slow_path, ctrl_proj);\n-    phi2->init_req(_slow_path, mem_proj);\n-\n-    phase->register_control(region2, loop, reg2_ctrl);\n-    phase->register_new_node(phi2, region2);\n-\n-    region->init_req(_heap_unstable, region2);\n-    phi->init_req(_heap_unstable, phi2);\n-\n-    phase->register_control(region, loop, heap_stable_ctrl->in(0));\n-    phase->register_new_node(phi, region);\n-\n-    fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);\n-    for(uint next = 0; next < uses.size(); next++ ) {\n-      Node *n = uses.at(next);\n-      assert(phase->get_ctrl(n) == init_ctrl, \"bad control\");\n-      assert(n != init_raw_mem, \"should leave input raw mem above the barrier\");\n-      phase->set_ctrl(n, region);\n-      follow_barrier_uses(n, init_ctrl, uses, phase);\n-    }\n-    fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);\n-\n-    phase->igvn().replace_node(barrier, pre_val);\n-  }\n-  assert(state->iu_barriers_count() == 0, \"all enqueue barrier nodes should have been replaced\");\n-\n@@ -1662,2 +1478,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return get_load_addr(phase, visited, in->in(1));\n@@ -1911,120 +1725,0 @@\n-ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(nullptr, val) {\n-  ShenandoahBarrierSetC2::bsc2()->state()->add_iu_barrier(this);\n-}\n-\n-const Type* ShenandoahIUBarrierNode::bottom_type() const {\n-  if (in(1) == nullptr || in(1)->is_top()) {\n-    return Type::TOP;\n-  }\n-  const Type* t = in(1)->bottom_type();\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-const Type* ShenandoahIUBarrierNode::Value(PhaseGVN* phase) const {\n-  if (in(1) == nullptr) {\n-    return Type::TOP;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-int ShenandoahIUBarrierNode::needed(Node* n) {\n-  if (n == nullptr ||\n-      n->is_Allocate() ||\n-      n->Opcode() == Op_ShenandoahIUBarrier ||\n-      n->bottom_type() == TypePtr::NULL_PTR ||\n-      (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr)) {\n-    return NotNeeded;\n-  }\n-  if (n->is_Phi() ||\n-      n->is_CMove()) {\n-    return MaybeNeeded;\n-  }\n-  return Needed;\n-}\n-\n-Node* ShenandoahIUBarrierNode::next(Node* n) {\n-  for (;;) {\n-    if (n == nullptr) {\n-      return n;\n-    } else if (n->bottom_type() == TypePtr::NULL_PTR) {\n-      return n;\n-    } else if (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr) {\n-      return n;\n-    } else if (n->is_ConstraintCast() ||\n-               n->Opcode() == Op_DecodeN ||\n-               n->Opcode() == Op_EncodeP) {\n-      n = n->in(1);\n-    } else if (n->is_Proj()) {\n-      n = n->in(0);\n-    } else {\n-      return n;\n-    }\n-  }\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n-\n-Node* ShenandoahIUBarrierNode::Identity(PhaseGVN* phase) {\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  Node* n = next(in(1));\n-\n-  int cont = needed(n);\n-\n-  if (cont == NotNeeded) {\n-    return in(1);\n-  } else if (cont == MaybeNeeded) {\n-    if (igvn == nullptr) {\n-      phase->record_for_igvn(this);\n-      return this;\n-    } else {\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-      uint wq_i = 0;\n-\n-      for (;;) {\n-        if (n->is_Phi()) {\n-          for (uint i = 1; i < n->req(); i++) {\n-            Node* m = n->in(i);\n-            if (m != nullptr) {\n-              wq.push(m);\n-            }\n-          }\n-        } else {\n-          assert(n->is_CMove(), \"nothing else here\");\n-          Node* m = n->in(CMoveNode::IfFalse);\n-          wq.push(m);\n-          m = n->in(CMoveNode::IfTrue);\n-          wq.push(m);\n-        }\n-        Node* orig_n = nullptr;\n-        do {\n-          if (wq_i >= wq.size()) {\n-            return in(1);\n-          }\n-          n = wq.at(wq_i);\n-          wq_i++;\n-          orig_n = n;\n-          n = next(n);\n-          cont = needed(n);\n-          if (cont == Needed) {\n-            return this;\n-          }\n-        } while (cont != MaybeNeeded || (orig_n != n && wq.member(n)));\n-      }\n-    }\n-  }\n-\n-  return this;\n-}\n-\n@@ -3013,2 +2707,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return needs_barrier_impl(phase, n->in(1), visited);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":5,"deletions":313,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -90,17 +90,0 @@\n-class ShenandoahIUBarrierNode : public Node {\n-public:\n-  ShenandoahIUBarrierNode(Node* val);\n-\n-  const Type *bottom_type() const;\n-  const Type* Value(PhaseGVN* phase) const;\n-  Node* Identity(PhaseGVN* phase);\n-\n-  int Opcode() const;\n-\n-private:\n-  enum { Needed, NotNeeded, MaybeNeeded };\n-\n-  static int needed(Node* n);\n-  static Node* next(Node* n);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+  if (avg_cycle_time * avg_alloc_rate > allocation_headroom) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n-#include \"gc\/shenandoah\/mode\/shenandoahIUMode.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logTag.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/java.hpp\"\n-\n-void ShenandoahIUMode::initialize_flags() const {\n-  if (FLAG_IS_CMDLINE(ClassUnloadingWithConcurrentMark) && ClassUnloading) {\n-    log_warning(gc)(\"Shenandoah I-U mode sets -XX:-ClassUnloadingWithConcurrentMark; see JDK-8261341 for details\");\n-  }\n-  FLAG_SET_DEFAULT(ClassUnloadingWithConcurrentMark, false);\n-\n-  if (ClassUnloading) {\n-    FLAG_SET_DEFAULT(VerifyBeforeExit, false);\n-  }\n-\n-  if (FLAG_IS_DEFAULT(ShenandoahIUBarrier)) {\n-    FLAG_SET_DEFAULT(ShenandoahIUBarrier, true);\n-  }\n-  if (FLAG_IS_DEFAULT(ShenandoahSATBBarrier)) {\n-    FLAG_SET_DEFAULT(ShenandoahSATBBarrier, false);\n-  }\n-\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n-  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n-\n-  \/\/ Final configuration checks\n-  SHENANDOAH_CHECK_FLAG_SET(ShenandoahLoadRefBarrier);\n-  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahSATBBarrier);\n-  SHENANDOAH_CHECK_FLAG_SET(ShenandoahIUBarrier);\n-  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCASBarrier);\n-  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCloneBarrier);\n-  SHENANDOAH_CHECK_FLAG_SET(ShenandoahStackWatermarkBarrier);\n-}\n-\n-ShenandoahHeuristics* ShenandoahIUMode::initialize_heuristics() const {\n-  if (ShenandoahGCHeuristics == nullptr) {\n-    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n-  }\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-    return new ShenandoahAggressiveHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-    return new ShenandoahStaticHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-    return new ShenandoahAdaptiveHeuristics(heap);\n-  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-    return new ShenandoahCompactHeuristics(heap);\n-  }\n-  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_MODE_SHENANDOAHIUMODE_HPP\n-#define SHARE_GC_SHENANDOAH_MODE_SHENANDOAHIUMODE_HPP\n-\n-#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n-\n-class ShenandoahHeuristics;\n-\n-class ShenandoahIUMode : public ShenandoahMode {\n-public:\n-  virtual void initialize_flags() const;\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n-\n-  virtual const char* name()     { return \"Incremental-Update (IU)\"; }\n-  virtual bool is_diagnostic()   { return false; }\n-  virtual bool is_experimental() { return true; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_MODE_SHENANDOAHIUMODE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.hpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -50,1 +50,0 @@\n-  SHENANDOAH_ERGO_DISABLE_FLAG(ShenandoahIUBarrier);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahIUBarrier);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  FLAG_SET_DEFAULT(ShenandoahIUBarrier,              false);\n@@ -145,1 +144,0 @@\n-           !FLAG_IS_DEFAULT(ShenandoahIUBarrier)              ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,0 +253,19 @@\n+\n+  \/\/ Do additional checks for special objects: their fields can hold metadata as well.\n+  \/\/ We want to check class loading\/unloading did not corrupt them.\n+\n+  if (java_lang_Class::is_instance(obj)) {\n+    Metadata* klass = obj->metadata_field(java_lang_Class::klass_offset());\n+    if (klass != nullptr && !Metaspace::contains(klass)) {\n+      print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Instance class mirror should point to Metaspace\",\n+                    file, line);\n+    }\n+\n+    Metadata* array_klass = obj->metadata_field(java_lang_Class::array_klass_offset());\n+    if (array_klass != nullptr && !Metaspace::contains(array_klass)) {\n+      print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Array class mirror should point to Metaspace\",\n+                    file, line);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  if (_heap->has_forwarded_objects() || (ShenandoahIUBarrier && _heap->is_concurrent_mark_in_progress())) {\n+  if (_heap->has_forwarded_objects()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  inline void iu_barrier(oop obj);\n@@ -123,1 +122,0 @@\n-  inline void clone_marking(oop src);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,6 +167,0 @@\n-inline void ShenandoahBarrierSet::iu_barrier(oop obj) {\n-  if (ShenandoahIUBarrier && obj != nullptr && _heap->is_concurrent_mark_in_progress()) {\n-    enqueue(obj);\n-  }\n-}\n-\n@@ -192,1 +186,0 @@\n-  iu_barrier(new_value);\n@@ -210,1 +203,0 @@\n-  iu_barrier(new_value);\n@@ -248,1 +240,0 @@\n-  bs->iu_barrier(value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,9 +77,0 @@\n-void ShenandoahBarrierSet::clone_marking(oop obj) {\n-  assert(_heap->is_concurrent_mark_in_progress(), \"only during marking\");\n-  assert(ShenandoahIUBarrier, \"only with incremental-update\");\n-  if (!_heap->marking_context()->allocated_after_mark_start(obj)) {\n-    ShenandoahUpdateRefsForOopClosure<\/* has_fwd = *\/ false, \/* evac = *\/ false, \/* enqueue *\/ true> cl;\n-    obj->oop_iterate(&cl);\n-  }\n-}\n-\n@@ -108,3 +99,1 @@\n-  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    clone_marking(obj);\n-  } else if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n+  if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -106,5 +106,0 @@\n-    _iterator.nmethods_do_begin();\n-  }\n-\n-  ~ShenandoahDisarmNMethodsTask() {\n-    _iterator.nmethods_do_end();\n@@ -178,7 +173,1 @@\n-    _iterator(ShenandoahCodeRoots::table()) {\n-    _iterator.nmethods_do_begin();\n-  }\n-\n-  ~ShenandoahUnlinkTask() {\n-    _iterator.nmethods_do_end();\n-  }\n+    _iterator(ShenandoahCodeRoots::table()) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -770,5 +770,1 @@\n-    _phase(phase) {\n-    if (ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_begin();\n-    }\n-  }\n+    _phase(phase) {}\n@@ -777,3 +773,0 @@\n-    if (ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_end();\n-    }\n@@ -881,11 +874,1 @@\n-    _nmethod_itr(ShenandoahCodeRoots::table()) {\n-    if (!ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_begin();\n-    }\n-  }\n-\n-  ~ShenandoahConcurrentRootsEvacUpdateTask() {\n-    if (!ShenandoahHeap::heap()->unload_classes()) {\n-      _nmethod_itr.nmethods_do_end();\n-    }\n-  }\n+    _nmethod_itr(ShenandoahCodeRoots::table()) {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  OopClosure* const _cl;\n@@ -77,3 +76,2 @@\n-  ShenandoahSATBAndRemarkThreadsClosure(SATBMarkQueueSet& satb_qset, OopClosure* cl) :\n-    _satb_qset(satb_qset),\n-    _cl(cl)  {}\n+  explicit ShenandoahSATBAndRemarkThreadsClosure(SATBMarkQueueSet& satb_qset) :\n+    _satb_qset(satb_qset) {}\n@@ -81,1 +79,1 @@\n-  void do_thread(Thread* thread) {\n+  void do_thread(Thread* thread) override {\n@@ -84,6 +82,0 @@\n-    if (thread->is_Java_thread()) {\n-      if (_cl != nullptr) {\n-        ResourceMark rm;\n-        thread->oops_do(_cl, nullptr);\n-      }\n-    }\n@@ -121,3 +113,1 @@\n-      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp);\n-      ShenandoahSATBAndRemarkThreadsClosure tc(satb_mq_set,\n-                                               ShenandoahIUBarrier ? &mark_cl : nullptr);\n+      ShenandoahSATBAndRemarkThreadsClosure tc(satb_mq_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n-#define LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCONTROLLER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCONTROLLER_HPP\n@@ -105,1 +105,1 @@\n-#endif \/\/LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCONTROLLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,13 +51,13 @@\n-  log_info(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n-               _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n-               _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n-               _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n-               _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)]);\n-  log_info(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n-               \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n-               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n-               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n-               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n-               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)]);\n-\n-  log_info(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  log_debug(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+                _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+                _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+                _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)]);\n+  log_debug(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+                \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+                _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+                _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+                _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+                _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)]);\n+\n+  log_debug(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n@@ -86,2 +86,2 @@\n-  log_info(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n-               aligned_idx, mutator_bits, collector_bits, notfree_bits);\n+  log_debug(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n+                aligned_idx, mutator_bits, collector_bits, notfree_bits);\n@@ -580,0 +580,1 @@\n+  _trash_regions(NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, max_regions, mtGC)),\n@@ -902,1 +903,1 @@\n-void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion *r) {\n+void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion* r) {\n@@ -913,0 +914,1 @@\n+  size_t count = 0;\n@@ -916,2 +918,13 @@\n-      ShenandoahHeapLocker locker(_heap->lock());\n-      try_recycle_trashed(r);\n+      _trash_regions[count++] = r;\n+    }\n+  }\n+\n+  \/\/ Relinquish the lock after this much time passed.\n+  static constexpr jlong deadline_ns = 30000; \/\/ 30 us\n+  size_t idx = 0;\n+  while (idx < count) {\n+    os::naked_yield(); \/\/ Yield to allow allocators to take the lock\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n+    while (idx < count && os::javaTimeNanos() < deadline) {\n+      try_recycle_trashed(_trash_regions[idx++]);\n@@ -919,1 +932,0 @@\n-    SpinPause(); \/\/ allow allocators to take the lock\n@@ -1051,2 +1063,2 @@\n-  log_info(gc)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free partition from Collector Reserve\",\n-               byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer));\n+  log_info(gc, ergo)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free partition from Collector Reserve\",\n+                     byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer));\n@@ -1342,1 +1354,0 @@\n-  int count = 0;\n@@ -1352,1 +1363,0 @@\n-    count++;\n@@ -1356,1 +1366,1 @@\n-  if (count > 0) {\n+  if (linear > 0) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":34,"deletions":24,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  ShenandoahHeapRegion** _trash_regions;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-#include \"gc\/shenandoah\/mode\/shenandoahIUMode.hpp\"\n@@ -449,2 +448,0 @@\n-    } else if (strcmp(ShenandoahGCMode, \"iu\") == 0) {\n-      _gc_mode = new ShenandoahIUMode();\n@@ -1181,2 +1178,0 @@\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n@@ -1186,0 +1181,1 @@\n+    ContinuationGCSupport::relativize_stack_chunk(copy_val);\n@@ -1697,0 +1693,1 @@\n+  size_t const _stride;\n@@ -1703,1 +1700,1 @@\n-  ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :\n+  ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk, size_t stride) :\n@@ -1705,1 +1702,1 @@\n-          _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}\n+          _heap(ShenandoahHeap::heap()), _blk(blk), _stride(stride), _index(0) {}\n@@ -1709,1 +1706,1 @@\n-    size_t stride = ShenandoahParallelRegionStride;\n+    size_t stride = _stride;\n@@ -1728,2 +1725,14 @@\n-  if (num_regions() > ShenandoahParallelRegionStride) {\n-    ShenandoahParallelHeapRegionTask task(blk);\n+  const uint active_workers = workers()->active_workers();\n+  const size_t n_regions = num_regions();\n+  size_t stride = ShenandoahParallelRegionStride;\n+  if (stride == 0 && active_workers > 1) {\n+    \/\/ Automatically derive the stride to balance the work between threads\n+    \/\/ evenly. Do not try to split work if below the reasonable threshold.\n+    constexpr size_t threshold = 4096;\n+    stride = n_regions <= threshold ?\n+            threshold :\n+            (n_regions + active_workers - 1) \/ active_workers;\n+  }\n+\n+  if (n_regions > stride && active_workers > 1) {\n+    ShenandoahParallelHeapRegionTask task(blk, stride);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n-#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n@@ -179,1 +179,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n-#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n@@ -208,1 +208,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHMARKBITMAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -478,7 +479,4 @@\n-  _table(table), _table_snapshot(nullptr) {\n-}\n-\n-void ShenandoahConcurrentNMethodIterator::nmethods_do_begin() {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  _table_snapshot = _table->snapshot_for_iteration();\n-}\n+  _table(table),\n+  _table_snapshot(nullptr),\n+  _started_workers(0),\n+  _finished_workers(0) {}\n@@ -487,3 +485,3 @@\n-  assert(_table_snapshot != nullptr, \"Must first call nmethod_do_begin()\");\n-  _table_snapshot->concurrent_nmethods_do(cl);\n-}\n+  \/\/ Cannot safepoint when iteration is running, because this can cause deadlocks\n+  \/\/ with other threads waiting on iteration to be over.\n+  NoSafepointVerifier nsv;\n@@ -491,4 +489,26 @@\n-void ShenandoahConcurrentNMethodIterator::nmethods_do_end() {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  _table->finish_iteration(_table_snapshot);\n-  CodeCache_lock->notify_all();\n+  MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  if (_finished_workers > 0) {\n+    \/\/ Some threads have already finished. We are now in rampdown: we are now\n+    \/\/ waiting for all currently recorded workers to finish. No new workers\n+    \/\/ should start.\n+    return;\n+  }\n+\n+  \/\/ Record a new worker and initialize the snapshot if it is a first visitor.\n+  if (_started_workers++ == 0) {\n+    _table_snapshot = _table->snapshot_for_iteration();\n+  }\n+\n+  \/\/ All set, relinquish the lock and go concurrent.\n+  {\n+    MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    _table_snapshot->concurrent_nmethods_do(cl);\n+  }\n+\n+  \/\/ Record completion. Last worker shuts down the iterator and notifies any waiters.\n+  uint count = ++_finished_workers;\n+  if (count == _started_workers) {\n+    _table->finish_iteration(_table_snapshot);\n+    CodeCache_lock->notify_all();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -184,0 +184,2 @@\n+  uint                                  _started_workers;\n+  uint                                  _finished_workers;\n@@ -188,1 +190,0 @@\n-  void nmethods_do_begin();\n@@ -190,1 +191,0 @@\n-  void nmethods_do_end();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n-#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n@@ -191,1 +191,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHREFERENCEPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -215,0 +215,15 @@\n+    \/\/ Do additional checks for special objects: their fields can hold metadata as well.\n+    \/\/ We want to check class loading\/unloading did not corrupt them.\n+\n+    if (java_lang_Class::is_instance(obj)) {\n+      Metadata* klass = obj->metadata_field(java_lang_Class::klass_offset());\n+      check(ShenandoahAsserts::_safe_oop, obj,\n+            klass == nullptr || Metaspace::contains(klass),\n+            \"Instance class mirror should point to Metaspace\");\n+\n+      Metadata* array_klass = obj->metadata_field(java_lang_Class::array_klass_offset());\n+      check(ShenandoahAsserts::_safe_oop, obj,\n+            array_klass == nullptr || Metaspace::contains(array_klass),\n+            \"Array class mirror should point to Metaspace\");\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  product(uintx, ShenandoahParallelRegionStride, 1024, EXPERIMENTAL,        \\\n+  product(uintx, ShenandoahParallelRegionStride, 0, EXPERIMENTAL,           \\\n@@ -323,1 +323,2 @@\n-          \"iteration. Affects heaps with lots of regions.\")                 \\\n+          \"iteration. Affects heaps with lots of regions. \"                 \\\n+          \"Set to 0 to let Shenandoah to decide the best value.\")           \\\n@@ -336,3 +337,0 @@\n-  product(bool, ShenandoahIUBarrier, false, DIAGNOSTIC,                     \\\n-          \"Turn on\/off I-U barriers barriers in Shenandoah\")                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -301,3 +301,0 @@\n-JNIEXPORT void JNICALL\n-JVM_DumpAllStacks(JNIEnv *env, jclass unused);\n-\n@@ -558,6 +555,0 @@\n-JNIEXPORT jobjectArray JNICALL\n-JVM_GetClassSigners(JNIEnv *env, jclass cls);\n-\n-JNIEXPORT void JNICALL\n-JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  static bool create();\n-  static void destroy();\n+  static bool create() NOT_JVMTI_RETURN_(true);\n+  static void destroy() NOT_JVMTI_RETURN;\n@@ -38,1 +38,1 @@\n-  static void retransform_classes(JNIEnv* env, jobjectArray classes, TRAPS);\n+  static void retransform_classes(JNIEnv* env, jobjectArray classes, TRAPS) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,0 +283,1 @@\n+#if INCLUDE_JVMTI\n@@ -319,0 +320,4 @@\n+#else  \/\/ INCLUDE_JVMTI\n+TRACE_REQUEST_FUNC(JavaAgent)   {}\n+TRACE_REQUEST_FUNC(NativeAgent) {}\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+    assert(!IS_THIS_EPOCH_CLEARED_BIT_SET(ptr), \"invariant\");\n@@ -314,0 +315,1 @@\n+  assert(IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(ptr), \"invariant\");\n@@ -932,0 +934,1 @@\n+    assert(!IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n@@ -935,0 +938,1 @@\n+  assert(IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+    assert(IS_THIS_EPOCH_CLEARED_BIT_SET(value), \"invariant\");\n+    assert(IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(value), \"invariant\");\n@@ -114,0 +116,2 @@\n+    assert(IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n+    assert(IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  return atomic_inc(&class_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&class_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -58,1 +58,1 @@\n-  return atomic_inc(&module_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&module_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -63,1 +63,1 @@\n-  return atomic_inc(&package_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&package_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -68,1 +68,1 @@\n-  return atomic_inc(&cld_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&cld_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -204,1 +204,1 @@\n-  \/\/ Mask off and store the event flags.\n+  \/\/ Mask off and store the event flags and epoch clear bits.\n@@ -208,1 +208,1 @@\n-  k->set_trace_id(EVENT_KLASS_MASK(k));\n+  k->set_trace_id(EPOCH_CLEARED_BITS | EVENT_KLASS_MASK(k));\n@@ -214,2 +214,2 @@\n-  \/\/ Clear all bits.\n-  method->set_trace_flags(0);\n+  \/\/ Clear tag bits and set epoch cleared bits.\n+  method->set_trace_flags(static_cast<uint16_t>(EPOCH_CLEARED_BITS));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n@@ -163,0 +162,1 @@\n+  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n@@ -177,1 +177,0 @@\n-  assert(METHOD_AND_CLASS_USED_PREVIOUS_EPOCH(klass), \"invariant\");\n@@ -180,0 +179,1 @@\n+  assert(METHOD_AND_CLASS_USED_PREVIOUS_EPOCH(klass), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#define EPOCH_CLEARED_BITS                        (EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n@@ -139,0 +140,2 @@\n+#define IS_THIS_EPOCH_CLEARED_BIT_SET(ptr)        (TRACE_ID_PREDICATE(ptr, (THIS_EPOCH_BIT << META_SHIFT)))\n+#define IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(ptr)    (TRACE_ID_PREDICATE(ptr, (PREVIOUS_EPOCH_BIT << META_SHIFT)))\n@@ -164,0 +167,2 @@\n+#define IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(ptr) (METHOD_FLAG_PREDICATE(ptr, (THIS_EPOCH_BIT << META_SHIFT)))\n+#define IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(ptr) (METHOD_FLAG_PREDICATE(ptr, (PREVIOUS_EPOCH_BIT << META_SHIFT)))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,1 +241,1 @@\n-  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"invalid init sequence\");\n+  JVMTI_ONLY( assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"invalid init sequence\"); )\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+static constexpr const uint16_t cleared_epoch_bits = 512 | 256;\n+\n@@ -51,1 +53,1 @@\n-  JfrTraceFlag() : _flags(0) {}\n+  JfrTraceFlag() : _flags(cleared_epoch_bits) {}\n@@ -99,3 +101,2 @@\n-  void copy_trace_flags(uint8_t src_flags) const { \\\n-    uint8_t flags = *_trace_flags.flags_addr();    \\\n-    _trace_flags.set_flags(flags | src_flags);     \\\n+  void copy_trace_flags(uint16_t rhs_flags) const { \\\n+    _trace_flags.set_flags(_trace_flags.flags() | rhs_flags); \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -667,1 +667,1 @@\n-  if (val != nullptr && strstr(name , val) != 0) {\n+  if (val != nullptr && strstr(name , val) != nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,6 @@\n+static void requireNotInHotSpot(const char* caller, JVMCI_TRAPS) {\n+    if (JVMCIENV->is_hotspot()) {\n+        JVMCI_THROW_MSG(IllegalStateException, err_msg(\"Cannot call %s from HotSpot\", caller));\n+    }\n+}\n+\n@@ -421,1 +427,1 @@\n-  if (UNPACK_PAIR(address, klass_or_method) == 0) {\n+  if (UNPACK_PAIR(address, klass_or_method) == nullptr) {\n@@ -705,0 +711,11 @@\n+C2V_VMENTRY_0(jlong, getJObjectValue, (JNIEnv* env, jobject, jobject constant_jobject))\n+    requireNotInHotSpot(\"getJObjectValue\", JVMCI_CHECK_0);\n+    if (!THREAD->has_last_Java_frame()) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    }\n+    JVMCIObject constant = JVMCIENV->wrap(constant_jobject);\n+    Handle constant_value = JVMCIENV->asConstant(constant, JVMCI_CHECK_0);\n+    jobject jni_handle = JNIHandles::make_local(THREAD, constant_value());\n+    return reinterpret_cast<jlong>(jni_handle);\n+C2V_END\n+\n@@ -760,0 +777,29 @@\n+#ifdef ASSERT\n+  \/\/ Support for testing an OOME raised in a context where the current thread cannot call Java\n+  \/\/ 1. Put -Dtest.jvmci.oome_in_lookupConstantInPool=<trace> on the command line to\n+  \/\/    discover possible values for step 2.\n+  \/\/    Example output:\n+  \/\/\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Overflow: String length out of range\"{0x00000007ffeb2960}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"null\"{0x00000007ffebdfe8}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Maximum lock count exceeded\"{0x00000007ffec4f90}\n+  \/\/      CompilerToVM.lookupConstantInPool: \"Negative length\"{0x00000007ffec4468}\n+  \/\/\n+  \/\/ 2. Choose a value shown in step 1.\n+  \/\/    Example: -Dtest.jvmci.oome_in_lookupConstantInPool=Negative\n+  const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.oome_in_lookupConstantInPool\");\n+  if (val != nullptr) {\n+    const char* str = obj->print_value_string();\n+    if (strstr(val, \"<trace>\") != nullptr) {\n+      tty->print_cr(\"CompilerToVM.lookupConstantInPool: %s\", str);\n+    } else if (strstr(str, val) != nullptr) {\n+      Handle garbage;\n+      while (true) {\n+        \/\/ Trigger an OutOfMemoryError\n+        objArrayOop next = oopFactory::new_objectArray(0x7FFFFFFF, CHECK_NULL);\n+        next->obj_at_put(0, garbage());\n+        garbage = Handle(THREAD, next);\n+      }\n+    }\n+  }\n+#endif\n@@ -1055,1 +1101,1 @@\n-  if (target_addr != 0x0) {\n+  if (target_addr != nullptr) {\n@@ -3228,0 +3274,1 @@\n+  {CC \"getJObjectValue\",                              CC \"(\" OBJECTCONSTANT \")J\",                                                           FN_PTR(getJObjectValue)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+#if INCLUDE_JVMTI\n@@ -135,0 +136,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-int* CompilerToVM::Data::_should_notify_object_alloc;\n+JVMTI_ONLY( int* CompilerToVM::Data::_should_notify_object_alloc; )\n@@ -233,1 +233,1 @@\n-  _should_notify_object_alloc = &JvmtiExport::_should_notify_object_alloc;\n+  JVMTI_ONLY( _should_notify_object_alloc = &JvmtiExport::_should_notify_object_alloc; )\n@@ -243,1 +243,1 @@\n-    cardtable_start_address = 0;\n+    cardtable_start_address = nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-    _encode_fail       = 3  \/\/ some other problem occured during encoding. If buffer != 0,\n+    _encode_fail       = 3, \/\/ some other problem occured during encoding. If buffer != 0,\n@@ -405,0 +405,2 @@\n+    _encode_oome_in_vm = 4  \/\/ an OutOfMemoryError thrown from within VM code on a\n+                            \/\/ thread that cannot call Java (OOME has no stack trace)\n@@ -491,0 +493,6 @@\n+      Symbol *ex_name = _throwable->klass()->name();\n+      if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {\n+        JVMCI_event_1(\"translating exception: OutOfMemoryError within VM code\");\n+        decode(THREAD, _encode_oome_in_vm, 0L);\n+        return 0;\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-  jfieldID JNIJVMCI::className::_##name##_field_id = 0; \\\n+  jfieldID JNIJVMCI::className::_##name##_field_id = nullptr; \\\n@@ -629,1 +629,1 @@\n-    assert(offset != 0, \"must be valid offset\");                                                                                  \\\n+    assert(offset != nullptr, \"must be valid offset\");                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-  thread->set_exception_pc(0);\n+  thread->set_exception_pc(nullptr);\n@@ -2186,0 +2186,1 @@\n+        nm->set_has_scoped_access(true); \/\/ conservative\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  static_field(CompilerToVM::Data,             _should_notify_object_alloc,            int*)                                         \\\n+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,4 @@\n+  _nesting.check(_set_arena); \/\/ Check if a potential reallocation in the arena is safe\n+  if (new_word_capacity < _size) {\n+    return; \/\/ No need to grow\n+  }\n","filename":"src\/hotspot\/share\/libadt\/vectset.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  uint32_t*  _data;\n@@ -48,0 +47,1 @@\n+  uint32_t*  _data;\n@@ -49,0 +49,1 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n@@ -80,4 +81,1 @@\n-    if (word >= _size) {\n-      \/\/ Then grow\n-      grow(word);\n-    }\n+    grow(word);\n@@ -112,3 +110,1 @@\n-    if (word >= _size) {\n-      grow(word);\n-    }\n+    grow(word);\n","filename":"src\/hotspot\/share\/libadt\/vectset.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  char* substrings[4] = {0};\n+  char* substrings[4] = {};\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-void ReallocMark::check() {\n+void ReallocMark::check(Arena* arena) {\n@@ -242,1 +242,2 @@\n-  if (_nesting != Thread::current()->resource_area()->nesting()) {\n+  if ((arena == nullptr || arena == Thread::current()->resource_area()) &&\n+      _nesting != Thread::current()->resource_area()->nesting()) {\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -559,2 +559,2 @@\n-  ReallocMark()   PRODUCT_RETURN;\n-  void check()    PRODUCT_RETURN;\n+  ReallocMark() PRODUCT_RETURN;\n+  void check(Arena* arena = nullptr) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,13 @@\n+\n+const char* Arena::tag_name[] = {\n+#define ARENA_TAG_STRING(name, str, desc) XSTR(name),\n+  DO_ARENA_TAG(ARENA_TAG_STRING)\n+#undef ARENA_TAG_STRING\n+};\n+\n+const char* Arena::tag_desc[] = {\n+#define ARENA_TAG_DESC(name, str, desc) XSTR(desc),\n+  DO_ARENA_TAG(ARENA_TAG_DESC)\n+#undef ARENA_TAG_DESC\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -86,0 +86,6 @@\n+#define DO_ARENA_TAG(FN) \\\n+  FN(other, Others, Other arenas) \\\n+  FN(ra, RA, Resource areas) \\\n+  FN(ha, HA, Handle area) \\\n+  FN(node, NA, Node arena) \\\n+\n@@ -89,6 +95,5 @@\n-\n-  enum class Tag : uint8_t {\n-    tag_other = 0,\n-    tag_ra,   \/\/ resource area\n-    tag_ha,   \/\/ handle area\n-    tag_node  \/\/ C2 Node arena\n+  enum class Tag: uint8_t {\n+#define ARENA_TAG_ENUM(name, str, desc) tag_##name,\n+    DO_ARENA_TAG(ARENA_TAG_ENUM)\n+#undef ARENA_TAG_ENUM\n+    tag_count\n@@ -97,0 +102,7 @@\n+  constexpr static int tag_count() {\n+    return static_cast<int>(Tag::tag_count);\n+  }\n+\n+  static const char* tag_name[static_cast<int>(Arena::Tag::tag_count)];\n+  static const char* tag_desc[static_cast<int>(Arena::Tag::tag_count)];\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-volatile MetaWord dummy = 0;\n+volatile MetaWord dummy = nullptr;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  assert(_first_chunk == 0, \"already have a root\");\n+  assert(_first_chunk == nullptr, \"already have a root\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/rootChunkArea.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  if (requested_address != 0) {\n+  if (requested_address != nullptr) {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -490,0 +490,16 @@\n+  out->cr();\n+  out->cr();\n+\n+  \/\/ malloc diff\n+  const size_t early_malloced_bytes =\n+    _early_baseline.malloc_memory_snapshot()->total();\n+  const size_t early_count =\n+    _early_baseline.malloc_memory_snapshot()->total_count();\n+  const size_t current_malloced_bytes =\n+    _current_baseline.malloc_memory_snapshot()->total();\n+  const size_t current_count =\n+    _current_baseline.malloc_memory_snapshot()->total_count();\n+  print_malloc_diff(current_malloced_bytes, current_count, early_malloced_bytes,\n+                    early_count, mtNone);\n+  out->cr();\n+  out->cr();\n@@ -491,0 +507,12 @@\n+  \/\/ mmap diff\n+  out->print(\"mmap: \");\n+  const size_t early_reserved =\n+    _early_baseline.virtual_memory_snapshot()->total_reserved();\n+  const size_t early_committed =\n+    _early_baseline.virtual_memory_snapshot()->total_committed();\n+  const size_t current_reserved =\n+    _current_baseline.virtual_memory_snapshot()->total_reserved();\n+  const size_t current_committed =\n+    _current_baseline.virtual_memory_snapshot()->total_committed();\n+  print_virtual_memory_diff(current_reserved, current_committed, early_reserved,\n+                            early_committed);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2095,1 +2095,1 @@\n-  fflush(0);\n+  fflush(nullptr);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3022,1 +3022,1 @@\n-  if (breakpoints() != 0x0) {\n+  if (breakpoints() != nullptr) {\n@@ -3024,1 +3024,1 @@\n-    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n+    assert(breakpoints() == nullptr, \"should have cleared breakpoints\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-  if (is_native() && bcp == 0) {\n+  if (is_native() && bcp == nullptr) {\n@@ -358,1 +358,1 @@\n-  if (bcp == 0 || bcp == code_base()) {\n+  if (bcp == nullptr || bcp == code_base()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-       f.next(SmallRegisterMap::instance)) {\n+       f.next(SmallRegisterMap::instance())) {\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  const SmallRegisterMap* map = SmallRegisterMap::instance;\n+  const SmallRegisterMap* map = SmallRegisterMap::instance();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  assert(length <= max_length(), \"SymbolTable should have caught this!\");\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+  \/\/ Constructor is private for use only by SymbolTable.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,4 @@\n-  assert(i >= Max(), \"must be an overflow\");\n+  _nesting.check(_arena); \/\/ Check if a potential reallocation in the arena is safe\n+  if (i < Max()) {\n+    return; \/\/ No need to grow\n+  }\n@@ -377,0 +380,1 @@\n+, _blocks(arena)\n@@ -1420,1 +1424,1 @@\n-  _nesting.check();\n+  _nesting.check(); \/\/ Check if a potential reallocation in the resource arena is safe\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  ReallocMark _nesting;         \/\/ Safety checks for arena reallocation\n@@ -71,1 +72,1 @@\n-  void map( uint i, Block *n ) { if( i>=Max() ) grow(i); _blocks[i] = n; }\n+  void map( uint i, Block *n ) { grow(i); _blocks[i] = n; }\n@@ -80,1 +81,3 @@\n-  Block_List() : Block_Array(Thread::current()->resource_area()), _cnt(0) {}\n+  Block_List() : Block_List(Thread::current()->resource_area()) { }\n+  Block_List(Arena* a) : Block_Array(a), _cnt(0) { }\n+\n@@ -658,1 +661,1 @@\n-  ReallocMark _nesting;  \/\/ assertion check for reallocations\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -492,1 +492,1 @@\n-          assert(def != 0, \"input edge required\");\n+          assert(def != nullptr, \"input edge required\");\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,4 @@\n+    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n+      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+                        \"late method handle call resolution\");\n+    }\n@@ -586,1 +590,1 @@\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-  if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n+  if (_name != nullptr && strstr(_name, \"arraycopy\") != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+  ciMethod* _method;               \/\/ Method being direct called\n@@ -779,1 +780,0 @@\n-  ciMethod* _method;               \/\/ Method being direct called\n@@ -784,0 +784,1 @@\n+      _method(method),\n@@ -787,1 +788,0 @@\n-      _method(method),\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n-    : ConstraintCastNode(nullptr, n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n-    init_class_id(Class_CastII);\n-  }\n@@ -110,0 +106,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -137,0 +134,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -150,0 +148,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -160,0 +159,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -170,0 +170,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n@@ -195,0 +196,1 @@\n+    assert(ctrl != nullptr, \"control must be set\");\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  else if( _def == 0 ) tty->print(\"Dead \");\n+  else if( _def == nullptr ) tty->print(\"Dead \");\n@@ -206,1 +206,1 @@\n-  , _live(0)\n+  , _live(nullptr)\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-shmacro(ShenandoahIUBarrier)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1092,0 +1092,1 @@\n+  set_has_scoped_access(false);\n@@ -1097,1 +1098,1 @@\n-    } else if (has_method() && method()->name() != 0 &&\n+    } else if (has_method() && method()->name() != nullptr &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  bool                  _has_scoped_access;     \/\/ For shared scope closure\n@@ -694,0 +695,2 @@\n+  bool              has_scoped_access() const    { return _has_scoped_access; }\n+  void          set_has_scoped_access(bool v)    { _has_scoped_access = v; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,3 +64,0 @@\n-  \/\/ Pre-grow the blocks array, prior to the ResourceMark kicking in\n-  _blocks.map(number_of_blocks(), 0);\n-\n@@ -289,2 +286,2 @@\n-  assert( _ancestor != 0, \"\" );\n-  if( _ancestor->_ancestor != 0 ) {\n+  assert( _ancestor != nullptr, \"\" );\n+  if( _ancestor->_ancestor != nullptr ) {\n@@ -578,2 +575,2 @@\n-  assert( _ancestor != 0, \"\" );\n-  if( _ancestor->_ancestor != 0 ) {\n+  assert( _ancestor != nullptr, \"\" );\n+  if( _ancestor->_ancestor != nullptr ) {\n","filename":"src\/hotspot\/share\/opto\/domgraph.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3973,1 +3973,1 @@\n-PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *>  &orig_phi_worklist) {\n+PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *> &orig_phi_worklist, uint rec_depth) {\n@@ -3989,1 +3989,1 @@\n-      Node *mem = find_inst_mem(phi->in(idx), alias_idx, orig_phi_worklist);\n+      Node *mem = find_inst_mem(phi->in(idx), alias_idx, orig_phi_worklist, rec_depth + 1);\n@@ -4131,1 +4131,6 @@\n-Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis) {\n+#define FIND_INST_MEM_RECURSION_DEPTH_LIMIT 1000\n+Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray<PhiNode *>  &orig_phis, uint rec_depth) {\n+  if (rec_depth > FIND_INST_MEM_RECURSION_DEPTH_LIMIT) {\n+    _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n+    return nullptr;\n+  }\n@@ -4205,1 +4210,1 @@\n-        result = find_inst_mem(result, alias_idx, orig_phis);\n+        result = find_inst_mem(result, alias_idx, orig_phis, rec_depth + 1);\n@@ -4273,1 +4278,1 @@\n-      result = split_memory_phi(mphi, alias_idx, orig_phis);\n+      result = split_memory_phi(mphi, alias_idx, orig_phis, rec_depth + 1);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -552,1 +552,1 @@\n-  PhiNode *split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *>  &orig_phi_worklist);\n+  PhiNode *split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray<PhiNode *>  &orig_phi_worklist, uint rec_depth);\n@@ -555,1 +555,1 @@\n-  Node* find_inst_mem(Node* mem, int alias_idx,GrowableArray<PhiNode *>  &orig_phi_worklist);\n+  Node* find_inst_mem(Node* mem, int alias_idx,GrowableArray<PhiNode *>  &orig_phi_worklist, uint rec_depth = 0);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1243,1 +1243,1 @@\n-    alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));\n+    alen = _gvn.transform( new LoadRangeNode(nullptr, immutable_memory(), r_adr, TypeInt::POS));\n@@ -2562,1 +2562,1 @@\n-      return _gvn.transform(new RoundFloatNode(0, n));\n+      return _gvn.transform(new RoundFloatNode(nullptr, n));\n@@ -2576,1 +2576,1 @@\n-      return _gvn.transform(new RoundDoubleNode(0, n));\n+      return _gvn.transform(new RoundDoubleNode(nullptr, n));\n@@ -3896,1 +3896,1 @@\n-  FastLockNode * flock = _gvn.transform(new FastLockNode(0, obj, box) )->as_FastLock();\n+  FastLockNode * flock = _gvn.transform(new FastLockNode(nullptr, obj, box) )->as_FastLock();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, 0);\n+  _pending_cvstates = new (C->node_arena()) GrowableArray<Node*>(C->node_arena(), init_size, 0, nullptr);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -625,1 +625,1 @@\n-      lrg._def = 0;\n+      lrg._def = nullptr;\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+    ctrl->outcnt() == 1 && \/\/ No side-effects\n@@ -1366,1 +1367,1 @@\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2148,6 +2148,6 @@\n-  case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;\n-  case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;\n-  case vmIntrinsics::_reverse_i:                n = new ReverseINode(0, arg); break;\n-  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(0, arg); break;\n+  case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( nullptr, arg);  break;\n+  case vmIntrinsics::_reverse_i:                n = new ReverseINode(nullptr, arg); break;\n+  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(nullptr, arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  _live(0),\n-  _livein(0),\n+  _live(nullptr),\n+  _livein(nullptr),\n","filename":"src\/hotspot\/share\/opto\/live.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1344,2 +1344,2 @@\n-  max_value = new CastIINode(max_value, type_iv);\n-  register_new_node(max_value, parse_predicate_proj);\n+  max_value = new CastIINode(new_proj, max_value, type_iv);\n+  register_new_node(max_value, new_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2874,0 +2874,1 @@\n+  bool abs_stride_is_one = stride_con == 1 || stride_con == -1;\n@@ -2885,0 +2886,9 @@\n+  \/\/ if abs(stride) == 1, an Assertion Predicate for the final iv value is added. We don't know the final iv value until\n+  \/\/ we're done with range check elimination so use a place holder.\n+  Node* final_iv_placeholder = nullptr;\n+  if (abs_stride_is_one) {\n+    final_iv_placeholder = new Node(1);\n+    _igvn.set_type(final_iv_placeholder, TypeInt::INT);\n+    final_iv_placeholder->init_req(0, loop_entry);\n+  }\n+\n@@ -2988,0 +2998,14 @@\n+          if (abs_stride_is_one) {\n+            \/\/ If the main loop becomes empty and the array access for this range check is sunk out of the loop, the index\n+            \/\/ for the array access will be set to the index value of the final iteration which could be out of loop.\n+            \/\/ Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n+            \/\/ LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n+            \/\/ well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n+            \/\/ main loop doesn't constant fold after range check elimination but, the array access for the final\n+            \/\/ iteration of the main loop is out of bound and the index for that access is out of range for the range\n+            \/\/ check CastII.\n+            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n+                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          }\n+\n@@ -3007,1 +3031,1 @@\n-          max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+          max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n@@ -3119,0 +3143,5 @@\n+  if (abs_stride_is_one) {\n+    Node* final_iv = new SubINode(main_limit, cl->stride());\n+    register_new_node(final_iv, loop_entry);\n+    _igvn.replace_node(final_iv_placeholder, final_iv);\n+  }\n@@ -3122,2 +3151,0 @@\n-\n-  return;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2594,1 +2594,1 @@\n-    Node *trip  = phase->transform(new DivINode(0, bias, in(Stride)));\n+    Node *trip  = phase->transform(new DivINode(nullptr, bias, in(Stride)));\n@@ -2623,1 +2623,1 @@\n-      Node *trip  = phase->transform(new DivLNode(0, bias, stride));\n+      Node *trip  = phase->transform(new DivLNode(nullptr, bias, stride));\n@@ -5251,0 +5251,1 @@\n+  _nesting.check(); \/\/ Check if a potential reallocation in the resource arena is safe\n@@ -5476,1 +5477,2 @@\n-      l = get_loop(m);          \/\/ Get previously determined loop\n+      IdealLoopTree* m_loop = get_loop(m);\n+      l = m_loop;          \/\/ Get previously determined loop\n@@ -5502,1 +5504,1 @@\n-          set_loop(iff, l);\n+          set_loop(iff, m_loop);\n@@ -5505,1 +5507,1 @@\n-          set_loop(if_t, l);\n+          set_loop(if_t, m_loop);\n@@ -6341,1 +6343,1 @@\n-      _loop_or_ctrl.map(n->_idx,0);    \/\/ No block setting, it's globally dead\n+      _loop_or_ctrl.map(n->_idx,nullptr); \/\/ No block setting, it's globally dead\n@@ -6359,1 +6361,1 @@\n-    _loop_or_ctrl.map(n->_idx, 0);     \/\/ This node is useless\n+    _loop_or_ctrl.map(n->_idx, nullptr); \/\/ This node is useless\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -618,0 +618,1 @@\n+      _body(Compile::current()->comp_arena()),\n@@ -848,0 +849,2 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n+\n@@ -860,0 +863,1 @@\n+    _nesting.check(); \/\/ Check if a potential re-allocation in the resource arena is safe\n@@ -870,0 +874,1 @@\n+    _nesting.check(); \/\/ Check if a potential re-allocation in the resource arena is safe\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4853,0 +4853,3 @@\n+  if (node->is_CastII()) {\n+    clone->set_req(0, new_ctrl);\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -398,1 +398,8 @@\n-  if (t->isa_intptr_t() && offset != 0 && offset != Type::OffsetBot) {\n+\n+  if (t->isa_intptr_t() &&\n+#if !defined(AARCH64)\n+      \/\/ AArch64 supports the addressing mode:\n+      \/\/ [base, 0], in which [base] is converted from a long value\n+      offset != 0 &&\n+#endif\n+      offset != Type::OffsetBot) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -906,0 +906,4 @@\n+  Node* scalarized_obj(const JVMState* jvms, uint idx) const {\n+    assert(verify_jvms(jvms), \"jvms must match\");\n+    return in(_jvmadj + jvms->scloff() + idx);\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1856,1 +1856,1 @@\n-    mach->add_req(0);             \/\/ Set initial control to none\n+    mach->add_req(nullptr);     \/\/ Set initial control to none\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2776,1 +2776,0 @@\n-  const bool _is_valid;          \/\/ The parsing succeeded\n@@ -2781,1 +2780,0 @@\n-  const jint  _int_offset_shift; \/\/ (optional) Shift value for int_offset\n@@ -2783,0 +2781,2 @@\n+  const jint _int_offset_shift; \/\/ (optional) Shift value for int_offset\n+  const bool _is_valid;          \/\/ The parsing succeeded\n@@ -2791,1 +2791,0 @@\n-      _is_valid(is_valid),\n@@ -2796,0 +2795,1 @@\n+      _other_offsets(other_offsets),\n@@ -2797,1 +2797,1 @@\n-      _other_offsets(other_offsets)\n+      _is_valid(is_valid)\n@@ -2915,1 +2915,1 @@\n-    if (_int_offset != 0) {\n+    if (_int_offset != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-  \/\/ Canonicalize the node by moving constants to the right input.\n-  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n-    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n-    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n-  }\n@@ -100,0 +95,2 @@\n+  \/\/ Check for Min\/Max patterns. This is called before constants are pushed to the right input, as that transform can\n+  \/\/ make BoolTests non-canonical.\n@@ -105,0 +102,6 @@\n+  \/\/ Canonicalize the node by moving constants to the right input.\n+  if (in(Condition)->is_Bool() && phase->type(in(IfFalse))->singleton() && !phase->type(in(IfTrue))->singleton()) {\n+    BoolNode* b = in(Condition)->as_Bool()->negate(phase);\n+    return make(in(Control), phase->transform(b), in(IfTrue), in(IfFalse), _type);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1111,1 +1111,1 @@\n-const Node *Node::is_block_proj() const { return 0; }\n+const Node *Node::is_block_proj() const { return nullptr; }\n@@ -2776,0 +2776,4 @@\n+  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+  if (i < _max) {\n+    return; \/\/ No need to grow\n+  }\n@@ -2983,0 +2987,4 @@\n+  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+  if (_inode_top < _inode_max) {\n+    return; \/\/ No need to grow\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1613,0 +1613,2 @@\n+  ReallocMark _nesting;         \/\/ Safety checks for arena reallocation\n+\n@@ -1631,1 +1633,1 @@\n-  void map( uint i, Node *n ) { if( i>=_max ) grow(i); _nodes[i] = n; }\n+  void map( uint i, Node *n ) { grow(i); _nodes[i] = n; }\n@@ -1861,0 +1863,1 @@\n+  ReallocMark _nesting; \/\/ Safety checks for arena reallocation\n@@ -1884,1 +1887,1 @@\n-    if (_inode_top >= _inode_max) grow();\n+    grow();\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1039,0 +1039,21 @@\n+\/\/ Determine if there is a scalar replaced object description represented by 'ov'.\n+bool PhaseOutput::contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                             GrowableArray<ScopeValue*>* objs,\n+                                             ObjectValue* ov) const {\n+  for (int i = 0; i < jvms->scl_size(); i++) {\n+    Node* n = sfn->scalarized_obj(jvms, i);\n+    \/\/ Other kinds of nodes that we may encounter here, for instance constants\n+    \/\/ representing values of fields of objects scalarized, aren't relevant for\n+    \/\/ us, since they don't map to ObjectValue.\n+    if (!n->is_SafePointScalarObject()) {\n+      continue;\n+    }\n+\n+    ObjectValue* other = (ObjectValue*) sv_for_node_id(objs, n->_idx);\n+    if (ov == other) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1206,1 +1227,4 @@\n-          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          bool is_root = locarray->contains(ov) ||\n+                         exparray->contains(ov) ||\n+                         contains_as_owner(monarray, ov) ||\n+                         contains_as_scalarized_obj(jvms, sfn, objs, ov);\n@@ -2971,1 +2995,1 @@\n-      assert(def != 0, \"input edge required\");\n+      assert(def != nullptr, \"input edge required\");\n@@ -2994,1 +3018,1 @@\n-    assert( from->req() == 1 && (from->len() == 1 || from->in(1)==0), \"no precedence edges on projections\" );\n+    assert( from->req() == 1 && (from->len() == 1 || from->in(1) == nullptr), \"no precedence edges on projections\" );\n@@ -3542,0 +3566,1 @@\n+                              C->has_scoped_access(),\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -211,0 +211,3 @@\n+  bool contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                  GrowableArray<ScopeValue*>* objs,\n+                                  ObjectValue* ov) const;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    const FastLockNode *flock = _gvn.transform(new FastLockNode( 0, lock_object, box ))->as_FastLock();\n+    const FastLockNode *flock = _gvn.transform(new FastLockNode( nullptr, lock_object, box ))->as_FastLock();\n@@ -445,0 +445,4 @@\n+  if (parse_method->is_scoped()) {\n+    C->set_has_scoped_access(true);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3032,1 +3032,1 @@\n-    c = _gvn.transform( new DivFNode(0,a,b) );\n+    c = _gvn.transform( new DivFNode(nullptr,a,b) );\n@@ -3042,1 +3042,1 @@\n-      c = _gvn.transform( new ModFNode(0,a,b) );\n+      c = _gvn.transform( new ModFNode(nullptr,a,b) );\n@@ -3093,1 +3093,1 @@\n-    \/\/b = _gvn.transform(new RoundFloatNode(0, b) );\n+    \/\/b = _gvn.transform(new RoundFloatNode(nullptr, b) );\n@@ -3159,1 +3159,1 @@\n-    c = _gvn.transform( new DivDNode(0,a,b) );\n+    c = _gvn.transform( new DivDNode(nullptr,a,b) );\n@@ -3177,1 +3177,1 @@\n-      c = _gvn.transform( new ModDNode(0,a,b) );\n+      c = _gvn.transform( new ModDNode(nullptr,a,b) );\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,1 +783,1 @@\n-    if (!no_dead_loop) n->dump_bfs(100,0,\"#\");\n+    if (!no_dead_loop) n->dump_bfs(100,nullptr,\"#\");\n@@ -1138,1 +1138,1 @@\n-  n->dump_bfs(3, 0, \"\");\n+  n->dump_bfs(3, nullptr, \"\");\n@@ -2417,0 +2417,1 @@\n+  assert(_a == Compile::current()->comp_arena(), \"Should be allocated in comp_arena\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    return 0;\n+    return nullptr;\n@@ -344,1 +344,1 @@\n-        if (!in_spill) { return 0; } \/\/ Bailed out\n+        if (!in_spill) { return nullptr; } \/\/ Bailed out\n@@ -360,1 +360,1 @@\n-          return 0; \/\/ Bailed out\n+          return nullptr; \/\/ Bailed out\n@@ -369,1 +369,1 @@\n-    return 0;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-               _node_regs(0),\n+               _node_regs(nullptr),\n","filename":"src\/hotspot\/share\/opto\/regalloc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2957,1 +2957,23 @@\n-  \/\/ 4: Compute (3a, b):\n+  \/\/ 4: The computation of the new pre-loop limit could overflow (for 3a) or\n+  \/\/    underflow (for 3b) the int range. This is problematic in combination\n+  \/\/    with Range Check Elimination (RCE), which determines a \"safe\" range\n+  \/\/    where a RangeCheck will always succeed. RCE adjusts the pre-loop limit\n+  \/\/    such that we only enter the main-loop once we have reached the \"safe\"\n+  \/\/    range, and adjusts the main-loop limit so that we exit the main-loop\n+  \/\/    before we leave the \"safe\" range. After RCE, the range of the main-loop\n+  \/\/    can only be safely narrowed, and should never be widened. Hence, the\n+  \/\/    pre-loop limit can only be increased (for stride > 0), but an add\n+  \/\/    overflow might decrease it, or decreased (for stride < 0), but a sub\n+  \/\/    underflow might increase it. To prevent that, we perform the Sub \/ Add\n+  \/\/    and Max \/ Min with long operations.\n+  old_limit       = new ConvI2LNode(old_limit);\n+  orig_limit      = new ConvI2LNode(orig_limit);\n+  adjust_pre_iter = new ConvI2LNode(adjust_pre_iter);\n+  phase()->register_new_node(old_limit, pre_ctrl);\n+  phase()->register_new_node(orig_limit, pre_ctrl);\n+  phase()->register_new_node(adjust_pre_iter, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(old_limit);\n+  TRACE_ALIGN_VECTOR_NODE(orig_limit);\n+  TRACE_ALIGN_VECTOR_NODE(adjust_pre_iter);\n+\n+  \/\/ 5: Compute (3a, b):\n@@ -2960,0 +2982,1 @@\n+  \/\/\n@@ -2962,1 +2985,1 @@\n-    new_limit = new SubINode(old_limit, adjust_pre_iter);\n+    new_limit = new SubLNode(old_limit, adjust_pre_iter);\n@@ -2964,1 +2987,1 @@\n-    new_limit = new AddINode(old_limit, adjust_pre_iter);\n+    new_limit = new AddLNode(old_limit, adjust_pre_iter);\n@@ -2969,1 +2992,1 @@\n-  \/\/ 5: Compute (15a, b):\n+  \/\/ 6: Compute (15a, b):\n@@ -2972,2 +2995,7 @@\n-    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n-                 : (Node*) new MaxINode(new_limit, orig_limit);\n+    (stride > 0) ? (Node*) new MinLNode(phase()->C, new_limit, orig_limit)\n+                 : (Node*) new MaxLNode(phase()->C, new_limit, orig_limit);\n+  phase()->register_new_node(constrained_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(constrained_limit);\n+\n+  \/\/ 7: We know that the result is in the int range, there is never truncation\n+  constrained_limit = new ConvL2INode(constrained_limit);\n@@ -2977,1 +3005,1 @@\n-  \/\/ 6: Hack the pre-loop limit\n+  \/\/ 8: Hack the pre-loop limit\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-                                           false, 0, Offset(oopDesc::mark_offset_in_bytes()));\n+                                           false, nullptr, Offset(oopDesc::mark_offset_in_bytes()));\n@@ -610,1 +610,1 @@\n-                                           false, 0, Offset(oopDesc::klass_offset_in_bytes()));\n+                                           false, nullptr, Offset(oopDesc::klass_offset_in_bytes()));\n@@ -621,1 +621,1 @@\n-  mreg2type[Op_Set ] = 0;\n+  mreg2type[Op_Set ] = nullptr;\n@@ -3244,1 +3244,1 @@\n-  return (TypeRawPtr*)(new TypeRawPtr(ptr,0))->hashcons();\n+  return (TypeRawPtr*)(new TypeRawPtr(ptr,nullptr))->hashcons();\n@@ -3256,1 +3256,1 @@\n-  assert( _bits==0, \"Why cast a constant address?\");\n+  assert( _bits == nullptr, \"Why cast a constant address?\");\n@@ -3640,1 +3640,1 @@\n-      (offset.get() > 0) && xk && (k != 0) && k->is_instance_klass()) {\n+      (offset.get() > 0) && xk && (k != nullptr) && k->is_instance_klass()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    Unique_Node_List calls(C->comp_arena());\n+    Unique_Node_List calls;\n@@ -241,1 +241,1 @@\n-  Unique_Node_List safepoints(C->comp_arena());\n+  Unique_Node_List safepoints;\n@@ -243,1 +243,1 @@\n-  Unique_Node_List worklist(C->comp_arena());\n+  Unique_Node_List worklist;\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2487,2 +2487,1 @@\n-      insert_val = gvn().transform(new ConvL2INode(insert_val));\n-      insert_val = gvn().transform(new CastIINode(insert_val, TypeInt::BYTE));\n+      insert_val = gvn().transform(new ConvL2INode(insert_val, TypeInt::BYTE));\n@@ -2491,2 +2490,1 @@\n-      insert_val = gvn().transform(new ConvL2INode(insert_val));\n-      insert_val = gvn().transform(new CastIINode(insert_val, TypeInt::SHORT));\n+      insert_val = gvn().transform(new ConvL2INode(insert_val, TypeInt::SHORT));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1185,1 +1185,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1240,1 +1240,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1291,1 +1291,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1583,1 +1583,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1638,1 +1638,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1694,1 +1694,1 @@\n-  ResultType ret = 0;\\\n+  ResultType ret{}; \\\n@@ -1787,1 +1787,1 @@\n-  jfieldID ret = 0;\n+  jfieldID ret = nullptr;\n@@ -3132,1 +3132,1 @@\n-      return 0;\n+      return nullptr;\n@@ -3137,1 +3137,1 @@\n-    return 0;\n+    return nullptr;\n@@ -3744,2 +3744,2 @@\n-    *vm = 0;\n-    *(JNIEnv**)penv = 0;\n+    *vm = nullptr;\n+    *(JNIEnv**)penv = nullptr;\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1326,39 +1326,0 @@\n-JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))\n-  JvmtiVMObjectAllocEventCollector oam;\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ There are no signers for primitive types\n-    return nullptr;\n-  }\n-\n-  objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));\n-\n-  \/\/ If there are no signers set in the class, or if the class\n-  \/\/ is an array, return null.\n-  if (signers == nullptr) return nullptr;\n-\n-  \/\/ copy of the signers array\n-  Klass* element = ObjArrayKlass::cast(signers->klass())->element_klass();\n-  objArrayOop signers_copy = oopFactory::new_objArray(element, signers->length(), CHECK_NULL);\n-  for (int index = 0; index < signers->length(); index++) {\n-    signers_copy->obj_at_put(index, signers->obj_at(index));\n-  }\n-\n-  \/\/ return the copy\n-  return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);\n-JVM_END\n-\n-\n-JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (!java_lang_Class::is_primitive(mirror)) {\n-    \/\/ This call is ignored for primitive types and arrays.\n-    \/\/ Signers are only set once, ClassLoader.java, and thus shouldn't\n-    \/\/ be called with an array.  Only the bootstrap loader creates arrays.\n-    Klass* k = java_lang_Class::as_Klass(mirror);\n-    if (k->is_instance_klass()) {\n-      java_lang_Class::set_signers(k->java_mirror(), objArrayOop(JNIHandles::resolve(signers)));\n-    }\n-  }\n-JVM_END\n-\n@@ -3273,8 +3234,0 @@\n-JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))\n-  VM_PrintThreads op;\n-  VMThread::execute(&op);\n-  if (JvmtiExport::should_post_data_dump()) {\n-    JvmtiExport::post_data_dump();\n-  }\n-JVM_END\n-\n@@ -3913,1 +3866,1 @@\n-    THROW_(vmSymbols::java_lang_NullPointerException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n@@ -3921,1 +3874,1 @@\n-    THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n@@ -3927,1 +3880,1 @@\n-    THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":50,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -126,1 +126,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n@@ -384,14 +384,0 @@\n-void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,\n-                                                              const char* fallback_attr_name,\n-                                                              AnnotationArray* annos) {\n-  TempNewSymbol sym = SymbolTable::probe(attr_name, (int)strlen(attr_name));\n-  if (sym != nullptr) {\n-    if (symbol_to_cpool_index(sym) != 0) {\n-      write_annotations_attribute(attr_name, annos);\n-      return;\n-    }\n-  }\n-  \/\/ use fallback name\n-  write_annotations_attribute(fallback_attr_name, annos);\n-}\n-\n@@ -557,1 +543,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", component->annotations());\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", component->annotations());\n@@ -560,1 +546,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", component->type_annotations());\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", component->type_annotations());\n@@ -799,1 +785,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -802,1 +788,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", param_anno);\n+    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", param_anno);\n@@ -805,1 +791,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n@@ -868,1 +854,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n@@ -871,1 +857,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -120,7 +120,0 @@\n-  \/\/ With PreserveAllAnnotations option \"runtime invisible\" annotations\n-  \/\/ (RuntimeInvisibleAnnotations\/RuntimeInvisibleTypeAnnotations\/RuntimeInvisibleParameterAnnotations)\n-  \/\/ are considered \"runtime visible\" and ClassFileReconstituter writes them as\n-  \/\/ RuntimeVisibleAnnotations\/RuntimeVisibleTypeAnnotations\/RuntimeVisibleParameterAnnotations.\n-  \/\/ This helper method is for the corner case when \"runtime visible\" attribute name is not presents\n-  \/\/ in the class constant pool and the annotations are written with fallback \"runtime invisible\" name.\n-  void write_annotations_attribute(const char* attr_name, const char* fallback_attr_name, AnnotationArray* annos);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2071,1 +2071,1 @@\n-          catch_jmethodID = 0;\n+          catch_jmethodID = nullptr;\n@@ -2108,2 +2108,2 @@\n-                     location==0? \"no location:\" : \"\",\n-                     location==0? 0 : location - mh()->code_base(),\n+                     location == nullptr ? \"no location:\" : \"\",\n+                     location == nullptr ? 0 : location - mh()->code_base(),\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1176,1 +1176,1 @@\n-      JFR_ONLY(k_new_method->copy_trace_flags(*k_old_method->trace_flags_addr());)\n+      JFR_ONLY(k_new_method->copy_trace_flags(k_old_method->trace_flags());)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  for (int index = 0; names[index] != 0; ++index) {\n+  for (int index = 0; names[index] != nullptr; ++index) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-    return 0;\n@@ -456,1 +455,0 @@\n-      return Bytecodes::_illegal;\n@@ -470,1 +468,0 @@\n-    return 0;\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-  char* address = 0;\n+  char* address = nullptr;\n@@ -93,1 +93,1 @@\n-  void* address = 0;\n+  void* address = nullptr;\n","filename":"src\/hotspot\/share\/prims\/perf.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -38,1 +39,11 @@\n-static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+template<typename Func>\n+static bool for_scoped_method(JavaThread* jt, const Func& func) {\n+  ResourceMark rm;\n+#ifdef ASSERT\n+  LogMessage(foreign) msg;\n+  NonInterleavingLogStream ls{LogLevelType::Trace, msg};\n+  if (ls.is_enabled()) {\n+    ls.print_cr(\"Walking thread: %s\", jt->name());\n+  }\n+#endif\n+\n@@ -43,12 +54,12 @@\n-    if (m->is_scoped()) {\n-      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-      for (int i = 0; i < locals->size(); i++) {\n-        StackValue* var = locals->at(i);\n-        if (var->type() == T_OBJECT) {\n-          if (var->get_obj() == session) {\n-            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-            return true;\n-          }\n-        }\n-      }\n-      break;\n+    bool is_scoped = m->is_scoped();\n+\n+#ifdef ASSERT\n+    if (ls.is_enabled()) {\n+      stream.asJavaVFrame()->print_value(&ls);\n+      ls.print_cr(\"    is_scoped=%s\", is_scoped ? \"true\" : \"false\");\n+    }\n+#endif\n+\n+    if (is_scoped) {\n+      assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+      return func(stream);\n@@ -57,0 +68,1 @@\n+\n@@ -58,0 +70,2 @@\n+    \/\/ On debug builds, just keep searching the stack\n+    \/\/ in case we missed an @Scoped method further up\n@@ -63,1 +77,0 @@\n-\n@@ -67,0 +80,29 @@\n+static bool is_accessing_session(JavaThread* jt, oop session, bool& in_scoped) {\n+  return for_scoped_method(jt, [&](vframeStream& stream){\n+    in_scoped = true;\n+    StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+    for (int i = 0; i < locals->size(); i++) {\n+      StackValue* var = locals->at(i);\n+      if (var->type() == T_OBJECT) {\n+        if (var->get_obj() == session) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  });\n+}\n+\n+static frame get_last_frame(JavaThread* jt) {\n+  frame last_frame = jt->last_frame();\n+  RegisterMap register_map(jt,\n+                            RegisterMap::UpdateMap::include,\n+                            RegisterMap::ProcessFrames::include,\n+                            RegisterMap::WalkContinuation::skip);\n+\n+  if (last_frame.is_safepoint_blob_frame()) {\n+    last_frame = last_frame.sender(&register_map);\n+  }\n+  return last_frame;\n+}\n+\n@@ -81,2 +123,2 @@\n-    ResourceMark rm;\n-    if (is_in_scoped_access(jt, _session.resolve())) {\n+    bool ignored;\n+    if (is_accessing_session(jt, _session.resolve(), ignored)) {\n@@ -107,18 +149,0 @@\n-    frame last_frame = jt->last_frame();\n-    RegisterMap register_map(jt,\n-                             RegisterMap::UpdateMap::include,\n-                             RegisterMap::ProcessFrames::include,\n-                             RegisterMap::WalkContinuation::skip);\n-\n-    if (last_frame.is_safepoint_blob_frame()) {\n-      last_frame = last_frame.sender(&register_map);\n-    }\n-\n-    ResourceMark rm;\n-    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n-      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n-      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n-      Deoptimization::deoptimize(jt, last_frame);\n-    }\n-\n@@ -131,1 +155,2 @@\n-    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+    bool in_scoped = false;\n+    if (is_accessing_session(jt, JNIHandles::resolve(_session), in_scoped)) {\n@@ -139,0 +164,41 @@\n+    } else if (!in_scoped) {\n+      frame last_frame = get_last_frame(jt);\n+      if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+        \/\/ We are not at a safepoint that is 'in' an @Scoped method, but due to the compiler\n+        \/\/ moving code around\/hoisting checks, we may be in a situation like this:\n+        \/\/\n+        \/\/ liveness check (from @Scoped method)\n+        \/\/ for (...) {\n+        \/\/    for (...) { \/\/ strip-mining inner loop\n+        \/\/        memory access (from @Scoped method)\n+        \/\/    }\n+        \/\/    safepoint <-- STOPPED HERE\n+        \/\/ }\n+        \/\/\n+        \/\/ The safepoint at which we're stopped may be in between the liveness check\n+        \/\/ and actual memory access, but is itself 'outside' of @Scoped code\n+        \/\/\n+        \/\/ However, we're not sure whether we are in this exact situation, and\n+        \/\/ we're also not sure whether a memory access will actually occur after\n+        \/\/ this safepoint. So, we can not just install an async exception here\n+        \/\/\n+        \/\/ Instead, we mark the frame for deoptimization (which happens just before\n+        \/\/ execution in this frame continues) to get back to code like this:\n+        \/\/\n+        \/\/ for (...) {\n+        \/\/     call to ScopedMemoryAccess\n+        \/\/     safepoint <-- STOPPED HERE\n+        \/\/ }\n+        \/\/\n+        \/\/ This means that we will re-do the liveness check before attempting\n+        \/\/ another memory access. If the scope has been closed at that point,\n+        \/\/ the target thread will see it and throw an exception.\n+\n+        nmethod* code = last_frame.cb()->as_nmethod();\n+        if (code->has_scoped_access()) {\n+          \/\/ We would like to deoptimize here only if last_frame::oops_do\n+          \/\/ reports the session oop being live at this safepoint, but this\n+          \/\/ currently isn't possible due to JDK-8290892\n+          Deoptimization::deoptimize(jt, last_frame);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":102,"deletions":36,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -813,1 +813,1 @@\n-  jclass result = 0;\n+  jclass result = nullptr;\n@@ -826,1 +826,1 @@\n-    return 0;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,8 @@\n+   } else if (strcmp(type, \"FILE\") == 0) {\n+      DCmdArgument<char*>* argument =\n+          new DCmdArgument<char*>(name, desc, \"FILE\", mandatory);\n+      if (isarg) {\n+        parser->add_dcmd_argument(argument);\n+      } else {\n+        parser->add_dcmd_option(argument);\n+      }\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -185,0 +185,8 @@\n+WB_ENTRY(jstring, WB_PrintString(JNIEnv* env, jobject wb, jstring str, jint max_length))\n+  ResourceMark rm(THREAD);\n+  stringStream sb;\n+  java_lang_String::print(JNIHandles::resolve(str), &sb, max_length);\n+  oop result = java_lang_String::create_oop_from_str(sb.as_string(), THREAD);\n+  return (jstring) JNIHandles::make_local(THREAD, result);\n+WB_END\n+\n@@ -3056,0 +3064,1 @@\n+  {CC\"printString\", CC\"(Ljava\/lang\/String;I)Ljava\/lang\/String;\", (void*)&WB_PrintString},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-LegacyGCLogging Arguments::_legacyGCLogging     = { 0, 0 };\n+LegacyGCLogging Arguments::_legacyGCLogging     = { nullptr, 0 };\n@@ -507,1 +507,0 @@\n-  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -517,0 +516,1 @@\n+  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -525,0 +525,2 @@\n+\n+  { \"BaseFootPrintEstimate\",           JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -1657,3 +1659,0 @@\n-  if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {\n-    return JNI_EINVAL;\n-  }\n@@ -1863,1 +1862,1 @@\n-  \"-da\", \"-ea\", \"-disableassertions\", \"-enableassertions\", 0\n+  \"-da\", \"-ea\", \"-disableassertions\", \"-enableassertions\", nullptr\n@@ -1867,1 +1866,1 @@\n-  \"-dsa\", \"-esa\", \"-disablesystemassertions\", \"-enablesystemassertions\", 0\n+  \"-dsa\", \"-esa\", \"-disablesystemassertions\", \"-enablesystemassertions\", nullptr\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1582,0 +1582,5 @@\n+    \/\/ Avoid Thread.yield() loops without safepoint polls.\n+    if (SafepointMechanism::should_process(current)) {\n+      cont.done(); \/\/ allow safepoint\n+      ThreadInVMfromJava tivmfj(current);\n+    }\n@@ -1863,1 +1868,1 @@\n-  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n@@ -2073,1 +2078,1 @@\n-  _stream.next(SmallRegisterMap::instance);\n+  _stream.next(SmallRegisterMap::instance());\n@@ -2181,1 +2186,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance);\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n@@ -2224,1 +2229,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance);\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n@@ -2241,1 +2246,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance);\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n@@ -2300,1 +2305,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance);\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n@@ -2382,1 +2387,1 @@\n-  chunk->fix_thawed_frame(f, SmallRegisterMap::instance); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+  chunk->fix_thawed_frame(f, SmallRegisterMap::instance()); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n@@ -2448,2 +2453,2 @@\n-  \/\/ All the frames have been thawed so we know they don't hold any monitors\n-  assert(thread->held_monitor_count() == 0, \"Must be\");\n+  \/\/ All or part of the frames have been thawed so we know they don't hold any monitors except JNI monitors.\n+  assert(thread->held_monitor_count() == thread->jni_monitor_count(), \"Must be\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/bitMap.hpp\"\n@@ -695,1 +696,1 @@\n-  const size_t length = JVMFlag::numFlags - 1;\n+  constexpr size_t length = (sizeof(flagTable) \/ sizeof(JVMFlag)) - 1;\n@@ -704,8 +705,7 @@\n-  \/\/ Sort\n-  JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);\n-  if (array != nullptr) {\n-    for (size_t i = 0; i < length; i++) {\n-      array[i] = &flagTable[i];\n-    }\n-    qsort(array, length, sizeof(JVMFlag*), compare_flags);\n-\n+  BitMap::bm_word_t iteratorArray[BitMap::calc_size_in_words(length)];\n+  BitMapView iteratorMarkers(iteratorArray, length);\n+  iteratorMarkers.clear_range(0, length);\n+  \/\/ Print the flag with best sort value, then mark it.\n+  for (size_t j = 0; j < length; j++) {\n+    JVMFlag* bestFlag = nullptr;\n+    size_t bestFlagIndex = 0;\n@@ -713,2 +713,7 @@\n-      if (array[i]->is_unlocked() && !(skipDefaults && array[i]->is_default())) {\n-        array[i]->print_on(out, withComments, printRanges);\n+      const bool skip = (skipDefaults && flagTable[i].is_default());\n+      const bool visited = iteratorMarkers.at(i);\n+      if (!visited && flagTable[i].is_unlocked() && !skip) {\n+        if ((bestFlag == nullptr) || (strcmp(bestFlag->name(), flagTable[i].name()) > 0)) {\n+          bestFlag = &flagTable[i];\n+          bestFlagIndex = i;\n+        }\n@@ -717,7 +722,3 @@\n-    FREE_C_HEAP_ARRAY(JVMFlag*, array);\n-  } else {\n-    \/\/ OOM? Print unsorted.\n-    for (size_t i = 0; i < length; i++) {\n-      if (flagTable[i].is_unlocked() && !(skipDefaults && flagTable[i].is_default())) {\n-        flagTable[i].print_on(out, withComments, printRanges);\n-      }\n+    if (bestFlag != nullptr) {\n+      bestFlag->print_on(out, withComments, printRanges);\n+      iteratorMarkers.at_put(bestFlagIndex, true);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  JVMFlagLimit(0, 0, JVMFlagConstraintPhase::AtParse, 0), _min(0), _max(0) {}\n+  JVMFlagLimit(0, 0, JVMFlagConstraintPhase::AtParse, 0), _min(), _max() {}\n@@ -166,1 +166,1 @@\n-    JVMFlagLimit(type_enum, func, phase, HAS_CONSTRAINT), _min(0), _max(0) {}\n+    JVMFlagLimit(type_enum, func, phase, HAS_CONSTRAINT), _min(), _max() {}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -798,4 +798,0 @@\n-  product(bool, PreserveAllAnnotations, false,                              \\\n-          \"(Deprecated) Preserve RuntimeInvisibleAnnotations as well \"      \\\n-          \"as RuntimeVisibleAnnotations\")                                   \\\n-                                                                            \\\n@@ -1328,0 +1324,6 @@\n+  develop(int, MaxStringPrintSize, 256,                                     \\\n+          \"maximum number of characters to print for a java.lang.String \"   \\\n+          \"in the VM. If exceeded, an abridged version of the string is \"   \\\n+          \"printed with the middle of the string elided.\")                  \\\n+          range(2, O_BUFLEN)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-    CodeCache::write_perf_map();\n+    CodeCache::write_perf_map(nullptr, tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -474,2 +474,2 @@\n-  _exception_pc(0),\n-  _exception_handler_pc(0),\n+  _exception_pc(nullptr),\n+  _exception_handler_pc(nullptr),\n@@ -487,1 +487,1 @@\n-  _cont_fastpath(0),\n+  _cont_fastpath(nullptr),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -216,3 +216,3 @@\n-  const time_t zone_hours = (abs_local_to_UTC \/ seconds_per_hour);\n-  const time_t zone_min =\n-    ((abs_local_to_UTC % seconds_per_hour) \/ seconds_per_minute);\n+  const int zone_hours = static_cast<int>(abs_local_to_UTC \/ seconds_per_hour);\n+  const int zone_min =\n+    static_cast<int>((abs_local_to_UTC % seconds_per_hour) \/ seconds_per_minute);\n@@ -2274,2 +2274,2 @@\n-void os::free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n-  pd_free_memory(addr, bytes, alignment_hint);\n+void os::disclaim_memory(char *addr, size_t bytes) {\n+  pd_disclaim_memory(addr, bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-  static void   pd_free_memory(char *addr, size_t bytes, size_t alignment_hint);\n+  static void   pd_disclaim_memory(char *addr, size_t bytes);\n@@ -523,1 +523,1 @@\n-  static void   free_memory(char *addr, size_t bytes, size_t alignment_hint);\n+  static void   disclaim_memory(char *addr, size_t bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2125,1 +2125,1 @@\n-    out->print_cr(\"In-use monitor info:\");\n+    out->print_cr(\"In-use monitor info%s:\", log_all ? \"\" : \" (eliding idle monitors)\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -621,2 +621,2 @@\n-void vframe::print() {\n-  if (WizardMode) _fr.print_value_on(tty,nullptr);\n+void vframe::print(outputStream* output) {\n+  if (WizardMode) _fr.print_value_on(output, nullptr);\n@@ -625,2 +625,2 @@\n-void vframe::print_value() const {\n-  ((vframe*)this)->print();\n+void vframe::print_value(outputStream* output) const {\n+  ((vframe*)this)->print(output);\n@@ -630,2 +630,2 @@\n-void entryVFrame::print_value() const {\n-  ((entryVFrame*)this)->print();\n+void entryVFrame::print_value(outputStream* output) const {\n+  ((entryVFrame*)this)->print(output);\n@@ -634,4 +634,4 @@\n-void entryVFrame::print() {\n-  vframe::print();\n-  tty->print_cr(\"C Chunk in between Java\");\n-  tty->print_cr(\"C     link \" INTPTR_FORMAT, p2i(_fr.link()));\n+void entryVFrame::print(outputStream* output) {\n+  vframe::print(output);\n+  output->print_cr(\"C Chunk in between Java\");\n+  output->print_cr(\"C     link \" INTPTR_FORMAT, p2i(_fr.link()));\n@@ -643,1 +643,1 @@\n-static void print_stack_values(const char* title, StackValueCollection* values) {\n+static void print_stack_values(outputStream* output, const char* title, StackValueCollection* values) {\n@@ -645,1 +645,1 @@\n-  tty->print_cr(\"\\t%s:\", title);\n+  output->print_cr(\"\\t%s:\", title);\n@@ -650,1 +650,1 @@\n-void javaVFrame::print() {\n+void javaVFrame::print(outputStream* output) {\n@@ -655,2 +655,2 @@\n-  vframe::print();\n-  tty->print(\"\\t\");\n+  vframe::print(output);\n+  output->print(\"\\t\");\n@@ -658,2 +658,2 @@\n-  tty->cr();\n-  tty->print_cr(\"\\tbci:    %d\", bci());\n+  output->cr();\n+  output->print_cr(\"\\tbci:    %d\", bci());\n@@ -661,2 +661,2 @@\n-  print_stack_values(\"locals\",      locals());\n-  print_stack_values(\"expressions\", expressions());\n+  print_stack_values(output, \"locals\",      locals());\n+  print_stack_values(output, \"expressions\", expressions());\n@@ -666,1 +666,1 @@\n-  tty->print_cr(\"\\tmonitor list:\");\n+  output->print_cr(\"\\tmonitor list:\");\n@@ -669,1 +669,1 @@\n-    tty->print(\"\\t  obj\\t\");\n+    output->print(\"\\t  obj\\t\");\n@@ -672,1 +672,1 @@\n-      tty->print(\"( is scalar replaced %s)\", k->external_name());\n+      output->print(\"( is scalar replaced %s)\", k->external_name());\n@@ -674,1 +674,1 @@\n-      tty->print(\"( null )\");\n+      output->print(\"( null )\");\n@@ -677,1 +677,1 @@\n-      tty->print(\"(owner=\" INTPTR_FORMAT \")\", p2i(monitor->owner()));\n+      output->print(\"(owner=\" INTPTR_FORMAT \")\", p2i(monitor->owner()));\n@@ -681,1 +681,1 @@\n-        tty->print(\" ( lock is eliminated in compiled frame )\");\n+        output->print(\" ( lock is eliminated in compiled frame )\");\n@@ -683,1 +683,1 @@\n-        tty->print(\" ( lock is eliminated, frame not compiled )\");\n+        output->print(\" ( lock is eliminated, frame not compiled )\");\n@@ -686,4 +686,4 @@\n-    tty->cr();\n-    tty->print(\"\\t  \");\n-    monitor->lock()->print_on(tty, monitor->owner());\n-    tty->cr();\n+    output->cr();\n+    output->print(\"\\t  \");\n+    monitor->lock()->print_on(output, monitor->owner());\n+    output->cr();\n@@ -694,1 +694,1 @@\n-void javaVFrame::print_value() const {\n+void javaVFrame::print_value(outputStream* output) const {\n@@ -697,1 +697,1 @@\n-  tty->print_cr(\"frame( sp=\" INTPTR_FORMAT \", unextended_sp=\" INTPTR_FORMAT \", fp=\" INTPTR_FORMAT \", pc=\" INTPTR_FORMAT \")\",\n+  output->print_cr(\"frame( sp=\" INTPTR_FORMAT \", unextended_sp=\" INTPTR_FORMAT \", fp=\" INTPTR_FORMAT \", pc=\" INTPTR_FORMAT \")\",\n@@ -699,1 +699,1 @@\n-  tty->print(\"%s.%s\", k->internal_name(), m->name()->as_C_string());\n+  output->print(\"%s.%s\", k->internal_name(), m->name()->as_C_string());\n@@ -705,1 +705,1 @@\n-      tty->print(\"(%s:%d)\", source_name->as_C_string(), line_number);\n+      output->print(\"(%s:%d)\", source_name->as_C_string(), line_number);\n@@ -708,1 +708,1 @@\n-    tty->print(\"(Native Method)\");\n+    output->print(\"(Native Method)\");\n@@ -722,1 +722,1 @@\n-void javaVFrame::print_activation(int index) const {\n+void javaVFrame::print_activation(int index, outputStream* output) const {\n@@ -724,1 +724,1 @@\n-  tty->print(\"%2d - \", index);\n+  output->print(\"%2d - \", index);\n@@ -726,1 +726,1 @@\n-  tty->cr();\n+  output->cr();\n@@ -730,1 +730,1 @@\n-    tty->cr();\n+    output->cr();\n@@ -736,2 +736,2 @@\n-void externalVFrame::print() {\n-  _fr.print_value_on(tty,nullptr);\n+void externalVFrame::print(outputStream* output) {\n+  _fr.print_value_on(output, nullptr);\n@@ -740,2 +740,2 @@\n-void externalVFrame::print_value() const {\n-  ((vframe*)this)->print();\n+void externalVFrame::print_value(outputStream* output) const {\n+  ((vframe*)this)->print(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-  virtual void print_value() const;\n-  virtual void print();\n+  virtual void print_value(outputStream* output = tty) const;\n+  virtual void print(outputStream* output = tty);\n@@ -148,3 +148,3 @@\n-  void print();\n-  void print_value() const;\n-  void print_activation(int index) const;\n+  void print(outputStream* output = tty);\n+  void print_value(outputStream* output = tty) const;\n+  void print_activation(int index, outputStream* output = tty) const;\n@@ -198,2 +198,2 @@\n-  void print_value() const;\n-  void print();\n+  void print_value(outputStream* output = tty) const;\n+  void print(outputStream* output = tty);\n@@ -214,2 +214,2 @@\n-  void print_value() const;\n-  void print();\n+  void print_value(outputStream* output = tty) const;\n+  void print(outputStream* output = tty);\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-    iframe()->interpreter_frame_set_mdp(0); \/\/ clear out the mdp.\n+    iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  template(ParallelGCFailedAllocation)            \\\n-  template(ParallelGCSystemGC)                    \\\n+  template(ParallelCollectForAllocation)          \\\n+  template(ParallelGCCollect)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,3 +192,12 @@\n-    _value = REALLOC_C_HEAP_ARRAY(char, _value, len + 1, mtInternal);\n-    int n = os::snprintf(_value, len + 1, \"%.*s\", (int)len, str);\n-    assert((size_t)n <= len, \"Unexpected number of characters in string\");\n+    if (strcmp(type(), \"FILE\") == 0) {\n+      _value = REALLOC_C_HEAP_ARRAY(char, _value, JVM_MAXPATHLEN, mtInternal);\n+      if (!Arguments::copy_expand_pid(str, len, _value, JVM_MAXPATHLEN)) {\n+        stringStream error_msg;\n+        error_msg.print(\"File path invalid or too long: %s\", str);\n+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), error_msg.base());\n+      }\n+    } else {\n+      _value = REALLOC_C_HEAP_ARRAY(char, _value, len + 1, mtInternal);\n+      int n = os::snprintf(_value, len + 1, \"%.*s\", (int)len, str);\n+      assert((size_t)n <= len, \"Unexpected number of characters in string\");\n+    }\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-  _filename(\"filename\",\"Name of the dump file\", \"STRING\",true),\n+  _filename(\"filename\",\"Name of the dump file\", \"FILE\",true),\n@@ -855,2 +855,0 @@\n-#define DEFAULT_PERFMAP_FILENAME \"\/tmp\/perf-<pid>.map\"\n-\n@@ -859,1 +857,1 @@\n-  _filename(\"filename\", \"Name of the map file\", \"STRING\", false, DEFAULT_PERFMAP_FILENAME)\n+  _filename(\"filename\", \"Name of the map file\", \"FILE\", false, DEFAULT_PERFMAP_FILENAME)\n@@ -865,4 +863,1 @@\n-  \/\/ The check for _filename.is_set() is because we don't want to use\n-  \/\/ DEFAULT_PERFMAP_FILENAME, since it is meant as a description\n-  \/\/ of the default, not the actual default.\n-  CodeCache::write_perf_map(_filename.is_set() ? _filename.value() : nullptr);\n+  CodeCache::write_perf_map(_filename.value(), output());\n@@ -1024,1 +1019,1 @@\n-#define DEFAULT_CDS_ARCHIVE_FILENAME \"java_pid<pid>_<subcmd>.jsa\"\n+#define DEFAULT_CDS_ARCHIVE_FILENAME \"java_pid%p_<subcmd>.jsa\"\n@@ -1029,1 +1024,1 @@\n-  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false,\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"FILE\", false,\n@@ -1067,1 +1062,1 @@\n-    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+    fileh = java_lang_String::create_from_str(file, CHECK);\n@@ -1132,1 +1127,1 @@\n-  _filepath(\"filepath\", \"The file path to the output file\", \"STRING\", true) {\n+  _filepath(\"filepath\", \"The file path to the output file\", \"FILE\", true) {\n@@ -1213,1 +1208,1 @@\n-static constexpr char default_filename[] = \"vm_memory_map_<pid>.txt\";\n+static constexpr char default_filename[] = \"vm_memory_map_%p.txt\";\n@@ -1217,1 +1212,1 @@\n-  _filename(\"-F\", \"file path\", \"STRING\", false, default_filename) {\n+  _filename(\"-F\", \"file path\", \"FILE\", false, default_filename) {\n@@ -1222,8 +1217,1 @@\n-  stringStream defaultname;\n-  const char* name = nullptr;\n-  if (_filename.is_set()) {\n-    name = _filename.value();\n-  } else {\n-    defaultname.print(\"vm_memory_map_%d.txt\", os::current_process_id());\n-    name = defaultname.base();\n-  }\n+  const char* name = _filename.value();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  bool is_executable() const      { return is_empty() || _cmd[0] != '#'; }\n+  bool is_executable() const      { return !is_empty() && _cmd[0] != '#'; }\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,5 +200,0 @@\n-void BitMap::verify_size(idx_t size_in_bits) {\n-  assert(size_in_bits <= max_size_in_bits(),\n-         \"out of bounds: \" SIZE_FORMAT, size_in_bits);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static idx_t max_size_in_words() { return raw_to_words_align_down(~idx_t(0)); }\n-  static idx_t max_size_in_bits() { return max_size_in_words() * BitsPerWord; }\n+  constexpr static idx_t max_size_in_words() { return raw_to_words_align_down(~idx_t(0)); }\n+  constexpr static idx_t max_size_in_bits() { return max_size_in_words() * BitsPerWord; }\n@@ -74,1 +74,1 @@\n-  static idx_t raw_to_words_align_up(idx_t bit) {\n+  constexpr static idx_t raw_to_words_align_up(idx_t bit) {\n@@ -79,1 +79,1 @@\n-  static idx_t raw_to_words_align_down(idx_t bit) {\n+  constexpr static idx_t raw_to_words_align_down(idx_t bit) {\n@@ -198,1 +198,1 @@\n-  static idx_t calc_size_in_words(size_t size_in_bits) {\n+  constexpr static idx_t calc_size_in_words(size_t size_in_bits) {\n@@ -260,1 +260,7 @@\n-  static void verify_size(idx_t size_in_bits) NOT_DEBUG_RETURN;\n+  constexpr static void verify_size(idx_t size_in_bits) {\n+#ifdef ASSERT\n+    assert(size_in_bits <= max_size_in_bits(),\n+           \"out of bounds: \" SIZE_FORMAT, size_in_bits);\n+#endif\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+#include \"utilities\/utf8.hpp\"\n+\n+\/\/ Limit exception message components to 64K (the same max as Symbols)\n+#define MAX_LEN 65535\n@@ -114,1 +118,1 @@\n-  if (!thread->can_call_java()) {\n+  if (h_exception.is_null() && !thread->can_call_java()) {\n@@ -116,4 +120,2 @@\n-    const char* exc_value = h_exception.not_null() ? h_exception->print_value_string() :\n-                      h_name != nullptr ? h_name->as_C_string() :\n-                      \"null\";\n-    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%s%s%s> (\" PTR_FORMAT \") \\n\"\n+    const char* exc_value = h_name != nullptr ? h_name->as_C_string() : \"null\";\n+    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n@@ -122,1 +124,2 @@\n-                        exc_value, message ? \": \" : \"\", message ? message : \"\",\n+                        MAX_LEN, exc_value, message ? \": \" : \"\",\n+                        MAX_LEN, message ? message : \"\",\n@@ -148,1 +151,1 @@\n-  log_info(exceptions)(\"Exception <%s%s%s> (\" PTR_FORMAT \") \\n\"\n+  log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n@@ -150,2 +153,3 @@\n-                       h_exception->print_value_string(),\n-                       message ? \": \" : \"\", message ? message : \"\",\n+                       MAX_LEN, h_exception->print_value_string(),\n+                       message ? \": \" : \"\",\n+                       MAX_LEN, message ? message : \"\",\n@@ -208,1 +212,1 @@\n-  if (special_exception(thread, file, line, h_cause)) return;\n+  if (special_exception(thread, file, line, Handle(), name)) return;\n@@ -262,1 +266,1 @@\n-  os::vsnprintf(msg, max_msg_size, format, ap);\n+  int ret = os::vsnprintf(msg, max_msg_size, format, ap);\n@@ -264,0 +268,24 @@\n+\n+  \/\/ If ret == -1 then either there was a format conversion error, or the required buffer size\n+  \/\/ exceeds INT_MAX and so couldn't be returned (undocumented behaviour of vsnprintf). Depending\n+  \/\/ on the platform the buffer may be filled to its capacity (Linux), filled to the conversion\n+  \/\/ that encountered the overflow (macOS), or is empty (Windows), so it is possible we\n+  \/\/ have a truncated UTF-8 sequence. Similarly, if the buffer was too small and ret >= max_msg_size\n+  \/\/ we may also have a truncated UTF-8 sequence. In such cases we need to fix the buffer so the UTF-8\n+  \/\/ sequence is valid.\n+  if (ret == -1 || ret >= max_msg_size) {\n+    int len = (int) strlen(msg);\n+    if (len > 0) {\n+      \/\/ Truncation will only happen if the buffer was filled by vsnprintf,\n+      \/\/ otherwise vsnprintf already terminated filling it at a well-defined point.\n+      \/\/ But as this is not a clearly specified area we will perform our own UTF8\n+      \/\/ truncation anyway - though for those well-defined termination points it\n+      \/\/ will be a no-op.\n+      UTF8::truncate_to_legal_utf8((unsigned char*)msg, len + 1);\n+    }\n+  }\n+  \/\/ UTF8::is_legal_utf8 should actually be called is_legal_utf8_class_name as the final\n+  \/\/ parameter controls a check for a specific character appearing in the \"name\", which is only\n+  \/\/ allowed for classfile versions <= 47. We pass `true` so that we allow such strings as this code\n+  \/\/ know nothing about the actual string content.\n+  assert(UTF8::is_legal_utf8((const unsigned char*)msg, (int)strlen(msg), true), \"must be\");\n@@ -571,4 +599,4 @@\n-    log_info(exceptions)(\"Exception <%s: %s>\\n thrown in %s\",\n-                         exception->print_value_string(),\n-                         detail_message,\n-                         message);\n+    log_info(exceptions)(\"Exception <%.*s: %.*s>\\n thrown in %.*s\",\n+                         MAX_LEN, exception->print_value_string(),\n+                         MAX_LEN, detail_message,\n+                         MAX_LEN, message);\n@@ -576,3 +604,3 @@\n-    log_info(exceptions)(\"Exception <%s>\\n thrown in %s\",\n-                         exception->print_value_string(),\n-                         message);\n+    log_info(exceptions)(\"Exception <%.*s>\\n thrown in %.*s\",\n+                         MAX_LEN, exception->print_value_string(),\n+                         MAX_LEN, message);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-const int LogBytesPerWord    = 3;\n+constexpr int LogBytesPerWord    = 3;\n@@ -227,1 +227,1 @@\n-const int LogBytesPerWord    = 2;\n+constexpr int LogBytesPerWord    = 2;\n@@ -236,1 +236,1 @@\n-const int LogBitsPerByte     = 3;\n+constexpr int LogBitsPerByte     = 3;\n@@ -239,1 +239,1 @@\n-const int LogBitsPerWord     = LogBitsPerByte + LogBytesPerWord;\n+constexpr int LogBitsPerWord     = LogBitsPerByte + LogBytesPerWord;\n@@ -245,1 +245,1 @@\n-const int BitsPerWord        = 1 << LogBitsPerWord;\n+constexpr int BitsPerWord        = 1 << LogBitsPerWord;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -394,0 +395,63 @@\n+\/\/ Return true if `b` could be the starting byte of an encoded 2,3 or 6\n+\/\/ byte sequence.\n+static bool is_starting_byte(unsigned char b) {\n+  return b >= 0xC0 && b <= 0xEF;\n+}\n+\n+\/\/ Takes an incoming buffer that was valid UTF-8, but which has been truncated such that\n+\/\/ the last encoding may be partial, and returns the same buffer with a NUL-terminator\n+\/\/ inserted such that any partial encoding has gone.\n+\/\/ Note: if the incoming buffer is already valid then we may still drop the last encoding.\n+\/\/ To avoid that the caller can choose to check for validity first.\n+\/\/ The incoming buffer is still expected to be NUL-terminated.\n+\/\/ The incoming buffer is expected to be a realistic size - we assert if it is too small.\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+  assert(length > 5, \"invalid length\");\n+  assert(buffer[length - 1] == '\\0', \"Buffer should be NUL-terminated\");\n+\n+  if (buffer[length - 2] < 128) {  \/\/ valid \"ascii\" - common case\n+    return;\n+  }\n+\n+  \/\/ Modified UTF-8 encodes characters in sequences of 1, 2, 3 or 6 bytes.\n+  \/\/ The last byte is invalid if it is:\n+  \/\/ - the 1st byte of a 2, 3 or 6 byte sequence\n+  \/\/     0b110xxxxx\n+  \/\/     0b1110xxxx\n+  \/\/     0b11101101\n+  \/\/ - the 2nd byte of a 3 or 6 byte sequence\n+  \/\/     0b10xxxxxx\n+  \/\/     0b1010xxxx\n+  \/\/ - the 3rd, 4th or 5th byte of a 6 byte sequence\n+  \/\/     0b10xxxxxx\n+  \/\/     0b11101101\n+  \/\/     0b1011xxxx\n+  \/\/\n+  \/\/ Rather than checking all possible situations we simplify things noting that as we have already\n+  \/\/ got a truncated string, then dropping one more character is not significant. So we work from the\n+  \/\/ end of the buffer looking for the first byte that can be the starting byte of a UTF-8 encoded sequence,\n+  \/\/ then we insert NUL at that location to terminate the buffer. There is an added complexity with 6 byte\n+  \/\/ encodings as the first and fourth bytes are the same and overlap with the 3 byte encoding.\n+\n+  for (int index = length - 2; index > 0; index--) {\n+    if (is_starting_byte(buffer[index])) {\n+      if (buffer[index] == 0xED) {\n+        \/\/ Could be first byte of 3 or 6, or fourth byte of 6.\n+        \/\/ If fourth the previous three bytes will encode a high\n+        \/\/ surrogate value in the range EDA080 to EDAFBF. We only\n+        \/\/ need to check for EDA to establish this as the \"missing\"\n+        \/\/ values in EDAxxx would not be valid 3 byte encodings.\n+        if ((index - 3) >= 0 &&\n+            (buffer[index - 3] == 0xED) &&\n+            ((buffer[index - 2] & 0xF0) == 0xA0)) {\n+          assert(buffer[index - 1] >= 0x80 && buffer[index - 1] <= 0xBF, \"sanity check\");\n+          \/\/ It was fourth byte so truncate 3 bytes earlier\n+          index -= 3;\n+        }\n+      }\n+      buffer[index] = '\\0';\n+      break;\n+    }\n+  }\n+}\n+\n@@ -434,1 +498,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -437,1 +501,5 @@\n-    result += utf8_size(c);\n+    int sz = utf8_size(c);\n+    if (result + sz > INT_MAX-1) {\n+      break;\n+    }\n+    result += sz;\n@@ -439,1 +507,1 @@\n-  return result;\n+  return checked_cast<int>(result);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":71,"deletions":3,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,1 @@\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.channels.ClosedSelectorException;\n@@ -95,5 +94,0 @@\n-    private void ensureOpen() {\n-        if (!isOpen())\n-            throw new ClosedSelectorException();\n-    }\n-\n@@ -246,1 +240,0 @@\n-        ensureOpen();\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    n = sendfile(dstFD, srcFD, &offset, (size_t)count);\n","filename":"src\/java.base\/linux\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n+        RESTARTABLE(sendfile(dst, src, NULL, count), bytes_sent);\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.channels.ClosedSelectorException;\n@@ -100,5 +99,0 @@\n-    private void ensureOpen() {\n-        if (!isOpen())\n-            throw new ClosedSelectorException();\n-    }\n-\n@@ -288,1 +282,0 @@\n-        ensureOpen();\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueueSelectorImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -839,1 +840,1 @@\n-        int spaceNeeded = count + Integer.stringSize(i);\n+        int spaceNeeded = count + DecimalDigits.stringSize(i);\n@@ -864,1 +865,1 @@\n-        int spaceNeeded = count + Long.stringSize(l);\n+        int spaceNeeded = count + DecimalDigits.stringSize(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.security.Permissions;\n@@ -60,0 +61,1 @@\n+import java.security.ProtectionDomain;\n@@ -1152,2 +1154,2 @@\n-    \/\/ Set by VM\n-    private transient Object classData;\n+    private transient Object classData; \/\/ Set by VM\n+    private transient Object[] signers; \/\/ Read by VM, mutable\n@@ -1562,1 +1564,5 @@\n-    public native Object[] getSigners();\n+\n+    public Object[] getSigners() {\n+        var signers = this.signers;\n+        return signers == null ? null : signers.clone();\n+    }\n@@ -1567,1 +1573,5 @@\n-    native void setSigners(Object[] signers);\n+    void setSigners(Object[] signers) {\n+        if (!isPrimitive() && !isArray()) {\n+            this.signers = signers;\n+        }\n+    }\n@@ -3265,4 +3275,0 @@\n-\n-    \/** protection domain returned when the internal domain is null *\/\n-    private static java.security.ProtectionDomain allPermDomain;\n-\n@@ -3289,1 +3295,1 @@\n-    public java.security.ProtectionDomain getProtectionDomain() {\n+    public ProtectionDomain getProtectionDomain() {\n@@ -3298,0 +3304,10 @@\n+    \/** Holder for the protection domain returned when the internal domain is null *\/\n+    private static class Holder {\n+        private static final ProtectionDomain allPermDomain;\n+        static {\n+            Permissions perms = new Permissions();\n+            perms.add(SecurityConstants.ALL_PERMISSION);\n+            allPermDomain = new ProtectionDomain(null, perms);\n+        }\n+    }\n+\n@@ -3299,2 +3315,2 @@\n-    java.security.ProtectionDomain protectionDomain() {\n-        java.security.ProtectionDomain pd = getProtectionDomain0();\n+    ProtectionDomain protectionDomain() {\n+        ProtectionDomain pd = getProtectionDomain0();\n@@ -3302,8 +3318,3 @@\n-            if (allPermDomain == null) {\n-                java.security.Permissions perms =\n-                    new java.security.Permissions();\n-                perms.add(SecurityConstants.ALL_PERMISSION);\n-                allPermDomain =\n-                    new java.security.ProtectionDomain(null, perms);\n-            }\n-            pd = allPermDomain;\n+            return Holder.allPermDomain;\n+        } else {\n+            return pd;\n@@ -3311,1 +3322,0 @@\n-        return pd;\n@@ -3317,1 +3327,1 @@\n-    private native java.security.ProtectionDomain getProtectionDomain0();\n+    private native ProtectionDomain getProtectionDomain0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n- * Double#equals equals} uses <a href=#repEquivalence> representation\n- * equivalence<\/a>, defining NaN arguments to be equal to each other,\n+ * Double#equals equals} uses {@linkplain ##repEquivalence representation\n+ * equivalence}, defining NaN arguments to be equal to each other,\n@@ -595,0 +595,17 @@\n+     * @apiNote\n+     * This method corresponds to the general functionality of the\n+     * convertToDecimalCharacter operation defined in IEEE 754;\n+     * however, that operation is defined in terms of specifying the\n+     * number of significand digits used in the conversion.\n+     * Code to do such a conversion in the Java platform includes\n+     * converting the {@code double} to a {@link java.math.BigDecimal\n+     * BigDecimal} exactly and then rounding the {@code BigDecimal} to\n+     * the desired number of digits; sample code:\n+     * {@snippet lang=java :\n+     * double d = 0.1;\n+     * int digits = 25;\n+     * BigDecimal bd = new BigDecimal(d);\n+     * String result = bd.round(new MathContext(digits,  RoundingMode.HALF_UP));\n+     * \/\/ 0.1000000000000000055511151\n+     * }\n+     *\n@@ -675,0 +692,5 @@\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n@@ -901,0 +923,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n+     *\n@@ -1091,0 +1117,1 @@\n+    @Override\n@@ -1104,0 +1131,1 @@\n+    @Override\n@@ -1113,0 +1141,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -1116,0 +1148,1 @@\n+    @Override\n@@ -1124,0 +1157,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -1128,0 +1165,1 @@\n+    @Override\n@@ -1145,0 +1183,1 @@\n+    @Override\n@@ -1154,0 +1193,1 @@\n+    @Override\n@@ -1214,3 +1254,2 @@\n-     * relation must be implemented; see <a\n-     * href=\"#equivalenceRelation\">this discussion<\/a> for details of\n-     * floating-point equality and equivalence.\n+     * relation must be implemented; see {@linkplain ##equivalenceRelation\n+     * this discussion for details of floating-point equality and equivalence}.\n@@ -1393,3 +1432,3 @@\n-     * equals<\/i>; see <a href=\"#equivalenceRelation\">this\n-     * discussion<\/a> for details of floating-point comparison and\n-     * ordering.\n+     * equals<\/i>; see {@linkplain ##equivalenceRelation this\n+     * discussion for details of floating-point comparison and\n+     * ordering}.\n@@ -1409,0 +1448,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -311,0 +311,17 @@\n+     * @apiNote\n+     * This method corresponds to the general functionality of the\n+     * convertToDecimalCharacter operation defined in IEEE 754;\n+     * however, that operation is defined in terms of specifying the\n+     * number of significand digits used in the conversion.\n+     * Code to do such a conversion in the Java platform includes\n+     * converting the {@code float} to a {@link java.math.BigDecimal\n+     * BigDecimal} exactly and then rounding the {@code BigDecimal} to\n+     * the desired number of digits; sample code:\n+     * {@snippet lang=java :\n+     * floatf = 0.1f;\n+     * int digits = 15;\n+     * BigDecimal bd = new BigDecimal(f);\n+     * String result = bd.round(new MathContext(digits,  RoundingMode.HALF_UP));\n+     * \/\/ 0.100000001490116\n+     * }\n+     *\n@@ -391,0 +408,5 @@\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n@@ -528,0 +550,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n+     *\n@@ -733,0 +759,1 @@\n+    @Override\n@@ -746,0 +773,1 @@\n+    @Override\n@@ -754,0 +782,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -758,0 +790,1 @@\n+    @Override\n@@ -766,0 +799,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -770,0 +807,1 @@\n+    @Override\n@@ -779,0 +817,1 @@\n+    @Override\n@@ -796,0 +835,1 @@\n+    @Override\n@@ -843,3 +883,2 @@\n-     * relation must be implemented; see <a\n-     * href=\"Double.html#equivalenceRelation\">this discussion<\/a> for\n-     * details of floating-point equality and equivalence.\n+     * relation must be implemented; see {@linkplain Double##equivalenceRelation\n+     * this discussion for details of floating-point equality and equivalence}.\n@@ -1096,1 +1135,1 @@\n-     * The <a href=\"#binary16Format\">binary16 format<\/a> is discussed in\n+     * The {@linkplain ##binary16Format binary16 format} is discussed in\n@@ -1212,3 +1251,3 @@\n-     * equals<\/i>; see <a href=\"Double.html#equivalenceRelation\">this\n-     * discussion<\/a> for details of floating-point comparison and\n-     * ordering.\n+     * equals<\/i>; see {@linkplain Double##equivalenceRelation this\n+     * discussion for details of floating-point comparison and\n+     * ordering}.\n@@ -1229,0 +1268,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -431,1 +432,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -461,26 +462,0 @@\n-    \/**\n-     * Returns the string representation size for a given int value.\n-     *\n-     * @param x int value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(int x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        int p = -10;\n-        for (int i = 1; i < 10; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 10 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -461,1 +462,1 @@\n-        int size = stringSize(i);\n+        int size = DecimalDigits.stringSize(i);\n@@ -491,26 +492,0 @@\n-    \/**\n-     * Returns the string representation size for a given long value.\n-     *\n-     * @param x long value\n-     * @return string size\n-     *\n-     * @implNote There are other ways to compute this: e.g. binary search,\n-     * but values are biased heavily towards zero, and therefore linear search\n-     * wins. The iteration results are also routinely inlined in the generated\n-     * code after loop unrolling.\n-     *\/\n-    static int stringSize(long x) {\n-        int d = 1;\n-        if (x >= 0) {\n-            d = 0;\n-            x = -x;\n-        }\n-        long p = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (x > p)\n-                return i + d;\n-            p = 10 * p;\n-        }\n-        return 19 + d;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-     * range -<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n+     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n@@ -264,1 +264,1 @@\n-     * range -<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n+     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n@@ -556,1 +556,1 @@\n-     * of {@code y\/x} in the range of -<i>pi<\/i> to <i>pi<\/i>. Special\n+     * of {@code y\/x} in the range of &minus;<i>pi<\/i> to <i>pi<\/i>. Special\n@@ -2648,1 +2648,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;-&nbsp;e<sup>-x<\/sup><\/i>)\/2\n+     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n@@ -2677,1 +2677,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>-x<\/sup><\/i>)\/2\n+     * (<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n@@ -2705,1 +2705,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;-&nbsp;e<sup>-x<\/sup><\/i>)\/(<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>-x<\/sup><\/i>),\n+     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/(<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>),\n@@ -2773,1 +2773,1 @@\n-     * Returns <i>e<\/i><sup>x<\/sup>&nbsp;-1.  Note that for values of\n+     * Returns <i>e<\/i><sup>x<\/sup>&nbsp;&minus;1.  Note that for values of\n@@ -2802,1 +2802,1 @@\n-     *              <i>e<\/i><sup>{@code x}<\/sup>&nbsp;-1.\n+     *              <i>e<\/i><sup>{@code x}<\/sup>&nbsp;&minus;1.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.time.Duration;\n@@ -67,1 +68,1 @@\n- * {@link #outputWriter()}, {@link #outputWriter(Charset)}},\n+ * {@link #outputWriter()}, {@link #outputWriter(Charset)},\n@@ -444,4 +445,7 @@\n-     * <p>The default implementation of this method polls the {@code exitValue}\n-     * to check if the process has terminated. Concrete implementations of this\n-     * class are strongly encouraged to override this method with a more\n-     * efficient implementation.\n+     * @implSpec\n+     * The default implementation of this method polls the {@code exitValue}\n+     * to check if the process has terminated.\n+     *\n+     * @implNote\n+     * Concrete implementations of this class are strongly encouraged to\n+     * override this method with a more efficient implementation.\n@@ -478,0 +482,32 @@\n+    \/**\n+     * Causes the current thread to wait, if necessary, until the\n+     * process represented by this {@code Process} object has\n+     * terminated, or the specified waiting duration elapses.\n+     *\n+     * <p>If the process has already terminated then this method returns\n+     * immediately with the value {@code true}.  If the process has not\n+     * terminated and the duration is not positive, then\n+     * this method returns immediately with the value {@code false}.\n+     *\n+     * @implSpec\n+     * The default implementation of this method polls the {@code exitValue}\n+     * to check if the process has terminated.\n+     *\n+     * @implNote\n+     * Concrete implementations of this class are strongly encouraged to\n+     * override this method with a more efficient implementation.\n+     *\n+     * @param duration the maximum duration to wait; if not positive,\n+     *                this method returns immediately.\n+     * @return {@code true} if the process has exited and {@code false} if\n+     *         the waiting duration elapsed before the process has exited.\n+     * @throws InterruptedException if the current thread is interrupted\n+     *         while waiting.\n+     * @throws NullPointerException if duration is null\n+     * @since 24\n+     *\/\n+    public boolean waitFor(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration, \"duration\");\n+        return waitFor(TimeUnit.NANOSECONDS.convert(duration), TimeUnit.NANOSECONDS);\n+    }\n+\n@@ -580,2 +616,2 @@\n-     * {@code waitFor(long, TimeUnit)}, which is specified to poll\n-     * {@code exitValue()}.\n+     * {@code waitFor(long, TimeUnit)} and {@code waitFor(Duration)},\n+     * which are specified to poll {@code exitValue()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-     * range -<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n+     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n@@ -214,1 +214,1 @@\n-     * range -<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n+     * range &minus;<i>pi<\/i>\/2 through <i>pi<\/i>\/2.  Special cases:\n@@ -527,1 +527,1 @@\n-     * of {@code y\/x} in the range of -<i>pi<\/i> to <i>pi<\/i>. Special\n+     * of {@code y\/x} in the range of &minus;<i>pi<\/i> to <i>pi<\/i>. Special\n@@ -2096,1 +2096,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;-&nbsp;e<sup>-x<\/sup><\/i>)\/2\n+     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n@@ -2123,1 +2123,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>-x<\/sup><\/i>)\/2\n+     * (<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>)\/2\n@@ -2149,1 +2149,1 @@\n-     * (<i>e<sup>x<\/sup>&nbsp;-&nbsp;e<sup>-x<\/sup><\/i>)\/(<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>-x<\/sup><\/i>),\n+     * (<i>e<sup>x<\/sup>&nbsp;&minus;&nbsp;e<sup>&minus;x<\/sup><\/i>)\/(<i>e<sup>x<\/sup>&nbsp;+&nbsp;e<sup>&minus;x<\/sup><\/i>),\n@@ -2206,1 +2206,1 @@\n-     * Returns <i>e<\/i><sup>x<\/sup>&nbsp;-1.  Note that for values of\n+     * Returns <i>e<\/i><sup>x<\/sup>&nbsp;&minus;1.  Note that for values of\n@@ -2227,1 +2227,1 @@\n-     *              <i>e<\/i><sup>{@code x}<\/sup>&nbsp;-1.\n+     *              <i>e<\/i><sup>{@code x}<\/sup>&nbsp;&minus;1.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2990,1 +2990,1 @@\n-        return StringConcatHelper.simpleConcat(this, str);\n+        return StringConcatHelper.doConcat(this, str);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -99,1 +100,1 @@\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -110,1 +111,1 @@\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n+        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n@@ -122,1 +123,1 @@\n-        if (value.coder() == String.UTF16) {\n+        if (!value.isLatin1()) {\n@@ -129,1 +130,1 @@\n-     * Prepends the stringly representation of boolean value into buffer,\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -136,0 +137,1 @@\n+     * @param prefix     a constant to prepend before value\n@@ -138,1 +140,1 @@\n-    static long prepend(long indexCoder, byte[] buf, boolean value) {\n+    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n@@ -142,4 +144,5 @@\n-                buf[--index] = 'e';\n-                buf[--index] = 'u';\n-                buf[--index] = 'r';\n-                buf[--index] = 't';\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n@@ -147,5 +150,6 @@\n-                buf[--index] = 'e';\n-                buf[--index] = 's';\n-                buf[--index] = 'l';\n-                buf[--index] = 'a';\n-                buf[--index] = 'f';\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n@@ -153,0 +157,2 @@\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n@@ -156,4 +162,5 @@\n-                StringUTF16.putChar(buf, --index, 'e');\n-                StringUTF16.putChar(buf, --index, 'u');\n-                StringUTF16.putChar(buf, --index, 'r');\n-                StringUTF16.putChar(buf, --index, 't');\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n@@ -161,5 +168,6 @@\n-                StringUTF16.putChar(buf, --index, 'e');\n-                StringUTF16.putChar(buf, --index, 's');\n-                StringUTF16.putChar(buf, --index, 'l');\n-                StringUTF16.putChar(buf, --index, 'a');\n-                StringUTF16.putChar(buf, --index, 'f');\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n@@ -167,0 +175,2 @@\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n@@ -178,17 +188,0 @@\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends the stringly representation of char value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n@@ -196,19 +189,0 @@\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, char value) {\n-        if (indexCoder < UTF16) {\n-            buf[(int)(--indexCoder)] = (byte) (value & 0xFF);\n-        } else {\n-            StringUTF16.putChar(buf, (int)(--indexCoder), value);\n-        }\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n@@ -219,16 +193,1 @@\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends the stringly representation of integer value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      integer value to encode\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, int value) {\n+        int index = (int)indexCoder;\n@@ -236,1 +195,4 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -238,1 +200,4 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -249,1 +214,1 @@\n-     * @param value      boolean value to encode\n+     * @param value      int value to encode\n@@ -254,16 +219,1 @@\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends the stringly representation of long value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      long value to encode\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, long value) {\n+        int index = (int)indexCoder;\n@@ -271,1 +221,4 @@\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -273,1 +226,4 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -284,1 +240,1 @@\n-     * @param value      boolean value to encode\n+     * @param value      long value to encode\n@@ -289,17 +245,1 @@\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends the stringly representation of String value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      String value to encode\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, String value) {\n-        indexCoder -= value.length();\n+        int index = (int)indexCoder;\n@@ -307,1 +247,4 @@\n-            value.getBytes(buf, (int)indexCoder, String.LATIN1);\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -309,1 +252,4 @@\n-            value.getBytes(buf, (int)indexCoder, String.UTF16);\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -311,1 +257,0 @@\n-        return indexCoder;\n@@ -326,3 +271,12 @@\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n+        int index = ((int)indexCoder) - value.length();\n+        if (indexCoder < UTF16) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n+        }\n@@ -371,10 +325,18 @@\n-        \/\/ start \"mixing\" in length and coder or arguments, order is not\n-        \/\/ important\n-        long indexCoder = mix(initialCoder(), s1);\n-        indexCoder = mix(indexCoder, s2);\n-        byte[] buf = newArray(indexCoder);\n-        \/\/ prepend each argument in reverse order, since we prepending\n-        \/\/ from the end of the byte array\n-        indexCoder = prepend(indexCoder, buf, s2);\n-        indexCoder = prepend(indexCoder, buf, s1);\n-        return newString(buf, indexCoder);\n+        return doConcat(s1, s2);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation between two non-empty strings.\n+     *\n+     * @param s1         first argument\n+     * @param s2         second argument\n+     * @return String    resulting string\n+     *\/\n+    @ForceInline\n+    static String doConcat(String s1, String s2) {\n+        byte coder = (byte) (s1.coder() | s2.coder());\n+        int newLength = (s1.length() + s2.length()) << coder;\n+        byte[] buf = newArray(newLength);\n+        s1.getBytes(buf, 0, coder);\n+        s2.getBytes(buf, s1.length(), coder);\n+        return new String(buf, coder);\n@@ -448,1 +410,11 @@\n-        if (index < 0) {\n+        return newArray(index);\n+    }\n+\n+    \/**\n+     * Allocates an uninitialized byte array based on the length\n+     * @param length\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArray(int length) {\n+        if (length < 0) {\n@@ -451,1 +423,1 @@\n-        return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index);\n+        return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":105,"deletions":133,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-import java.util.concurrent.Callable;\n@@ -2268,0 +2267,1 @@\n+        @Override\n@@ -2615,4 +2615,0 @@\n-            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n-                return StringConcatHelper.prepend(indexCoder, buf, value);\n-            }\n-\n@@ -2631,4 +2627,0 @@\n-            public int stringSize(long i) {\n-                return Long.stringSize(i);\n-            }\n-\n@@ -2685,8 +2677,0 @@\n-            public <V> V executeOnCarrierThread(Callable<V> task) throws Exception {\n-                if (Thread.currentThread() instanceof VirtualThread vthread) {\n-                    return vthread.executeOnCarrierThread(task);\n-                } else {\n-                    return task.call();\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -65,2 +66,1 @@\n- * A thread that is scheduled by the Java virtual machine rather than the operating\n- * system.\n+ * A thread that is scheduled by the Java virtual machine rather than the operating system.\n@@ -72,1 +72,1 @@\n-    private static final ScheduledExecutorService UNPARKER = createDelayedTaskScheduler();\n+    private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n@@ -220,1 +220,1 @@\n-    @ChangesCurrentThread\n+    @ChangesCurrentThread \/\/ allow mount\/unmount to be inlined\n@@ -260,0 +260,2 @@\n+     * @param scheduler the scheduler\n+     * @param retryOnOOME true to retry indefinitely if OutOfMemoryError is thrown\n@@ -262,6 +264,32 @@\n-    private void submitRunContinuation() {\n-        try {\n-            scheduler.execute(runContinuation);\n-        } catch (RejectedExecutionException ree) {\n-            submitFailed(ree);\n-            throw ree;\n+    @ChangesCurrentThread\n+    private void submitRunContinuation(Executor scheduler, boolean retryOnOOME) {\n+        boolean done = false;\n+        while (!done) {\n+            try {\n+                \/\/ The scheduler's execute method is invoked in the context of the\n+                \/\/ carrier thread. For the default scheduler this ensures that the\n+                \/\/ current thread is a ForkJoinWorkerThread so the task will be pushed\n+                \/\/ to the local queue. For other schedulers, it avoids deadlock that\n+                \/\/ would arise due to platform and virtual threads contending for a\n+                \/\/ lock on the scheduler's submission queue.\n+                if (currentThread() instanceof VirtualThread vthread) {\n+                    vthread.switchToCarrierThread();\n+                    try {\n+                        scheduler.execute(runContinuation);\n+                    } finally {\n+                        switchToVirtualThread(vthread);\n+                    }\n+                } else {\n+                    scheduler.execute(runContinuation);\n+                }\n+                done = true;\n+            } catch (RejectedExecutionException ree) {\n+                submitFailed(ree);\n+                throw ree;\n+            } catch (OutOfMemoryError e) {\n+                if (retryOnOOME) {\n+                    U.park(false, 100_000_000); \/\/ 100ms\n+                } else {\n+                    throw e;\n+                }\n+            }\n@@ -273,0 +301,1 @@\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n@@ -277,0 +306,1 @@\n+        assert Thread.currentThread() instanceof CarrierThread;\n@@ -282,0 +312,2 @@\n+        } catch (OutOfMemoryError e) {\n+            submitRunContinuation(pool, true);\n@@ -287,0 +319,1 @@\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n@@ -291,0 +324,1 @@\n+        assert Thread.currentThread() instanceof CarrierThread;\n@@ -296,0 +330,33 @@\n+        } catch (OutOfMemoryError e) {\n+            submitRunContinuation(pool, true);\n+        }\n+    }\n+\n+    \/**\n+     * Submits the runContinuation task to the scheduler. For the default scheduler,\n+     * and calling it on a worker thread, the task will be pushed to the local queue,\n+     * otherwise it will be pushed to an external submission queue.\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n+     * @throws RejectedExecutionException\n+     *\/\n+    private void submitRunContinuation() {\n+        submitRunContinuation(scheduler, true);\n+    }\n+\n+    \/**\n+     * Submits the runContinuation task to the scheduler. For the default scheduler, and\n+     * calling it a virtual thread that uses the default scheduler, the task will be\n+     * pushed to an external submission queue. This method may throw OutOfMemoryError.\n+     * @throws RejectedExecutionException\n+     * @throws OutOfMemoryError\n+     *\/\n+    private void externalSubmitRunContinuationOrThrow() {\n+        if (scheduler == DEFAULT_SCHEDULER && currentCarrierThread() instanceof CarrierThread ct) {\n+            try {\n+                ct.getPool().externalSubmit(ForkJoinTask.adapt(runContinuation));\n+            } catch (RejectedExecutionException ree) {\n+                submitFailed(ree);\n+                throw ree;\n+            }\n+        } else {\n+            submitRunContinuation(scheduler, false);\n@@ -388,0 +455,2 @@\n+        assert !Thread.holdsLock(interruptLock);\n+\n@@ -420,1 +489,1 @@\n-    private void switchToVirtualThread(VirtualThread vthread) {\n+    private static void switchToVirtualThread(VirtualThread vthread) {\n@@ -477,2 +546,2 @@\n-                \/\/ lazy submit to continue on the current thread as carrier if possible\n-                if (currentThread() instanceof CarrierThread ct) {\n+                \/\/ lazy submit to continue on the current carrier if possible\n+                if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n@@ -483,1 +552,0 @@\n-\n@@ -564,2 +632,2 @@\n-            \/\/ submit task to run thread\n-            submitRunContinuation();\n+            \/\/ submit task to run thread, using externalSubmit if possible\n+            externalSubmitRunContinuationOrThrow();\n@@ -710,1 +778,1 @@\n-            return UNPARKER.schedule(this::unpark, nanos, NANOSECONDS);\n+            return schedule(this::unpark, nanos, NANOSECONDS);\n@@ -721,0 +789,1 @@\n+        assert Thread.currentThread() == this;\n@@ -733,4 +802,3 @@\n-     * Re-enables this virtual thread for scheduling. If the virtual thread was\n-     * {@link #park() parked} then it will be unblocked, otherwise its next call\n-     * to {@code park} or {@linkplain #parkNanos(long) parkNanos} is guaranteed\n-     * not to block.\n+     * Re-enables this virtual thread for scheduling. If this virtual thread is parked\n+     * then its task is scheduled to continue, otherwise its next call to {@code park} or\n+     * {@linkplain #parkNanos(long) parkNanos} is guaranteed not to block.\n@@ -740,1 +808,0 @@\n-    @ChangesCurrentThread\n@@ -742,2 +809,1 @@\n-        Thread currentThread = Thread.currentThread();\n-        if (!getAndSetParkPermit(true) && currentThread != this) {\n+        if (!getAndSetParkPermit(true) && currentThread() != this) {\n@@ -745,13 +811,9 @@\n-            boolean parked = (s == PARKED) || (s == TIMED_PARKED);\n-            if (parked && compareAndSetState(s, UNPARKED)) {\n-                if (currentThread instanceof VirtualThread vthread) {\n-                    vthread.switchToCarrierThread();\n-                    try {\n-                        submitRunContinuation();\n-                    } finally {\n-                        switchToVirtualThread(vthread);\n-                    }\n-                } else {\n-                    submitRunContinuation();\n-                }\n-            } else if ((s == PINNED) || (s == TIMED_PINNED)) {\n+\n+            \/\/ unparked while parked\n+            if ((s == PARKED || s == TIMED_PARKED) && compareAndSetState(s, UNPARKED)) {\n+                submitRunContinuation();\n+                return;\n+            }\n+\n+            \/\/ unparked while parked when pinned\n+            if (s == PINNED || s == TIMED_PINNED) {\n@@ -759,1 +821,1 @@\n-                notifyJvmtiDisableSuspend(true);\n+                disableSuspendAndPreempt();\n@@ -768,1 +830,1 @@\n-                    notifyJvmtiDisableSuspend(false);\n+                    enableSuspendAndPreempt();\n@@ -770,0 +832,1 @@\n+                return;\n@@ -862,1 +925,1 @@\n-        notifyJvmtiDisableSuspend(true);\n+        disableSuspendAndPreempt();\n@@ -866,1 +929,1 @@\n-            notifyJvmtiDisableSuspend(false);\n+            enableSuspendAndPreempt();\n@@ -877,1 +940,1 @@\n-            \/\/ suspended when entering or holding interruptLock\n+            \/\/ suspended or unmounted when entering or holding interruptLock\n@@ -879,1 +942,1 @@\n-            notifyJvmtiDisableSuspend(true);\n+            disableSuspendAndPreempt();\n@@ -893,1 +956,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -900,0 +963,4 @@\n+\n+            \/\/ make available parking permit, unpark thread if parked\n+            unpark();\n+\n@@ -903,0 +970,1 @@\n+            setParkPermit(true);\n@@ -904,1 +972,0 @@\n-        unpark();\n@@ -917,1 +984,1 @@\n-            notifyJvmtiDisableSuspend(true);\n+            disableSuspendAndPreempt();\n@@ -924,1 +991,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -949,6 +1016,8 @@\n-                notifyJvmtiDisableSuspend(true);\n-                try {\n-                    synchronized (carrierThreadAccessLock()) {\n-                        Thread carrierThread = this.carrierThread;\n-                        if (carrierThread != null) {\n-                            return carrierThread.threadState();\n+                if (Thread.currentThread() != this) {\n+                    disableSuspendAndPreempt();\n+                    try {\n+                        synchronized (carrierThreadAccessLock()) {\n+                            Thread carrierThread = this.carrierThread;\n+                            if (carrierThread != null) {\n+                                return carrierThread.threadState();\n+                            }\n@@ -956,0 +1025,2 @@\n+                    } finally {\n+                        enableSuspendAndPreempt();\n@@ -957,2 +1028,0 @@\n-                } finally {\n-                    notifyJvmtiDisableSuspend(false);\n@@ -1071,4 +1140,7 @@\n-        Thread carrier = carrierThread;\n-        if (carrier != null) {\n-            \/\/ include the carrier thread state and name when mounted\n-            notifyJvmtiDisableSuspend(true);\n+\n+        \/\/ add the carrier state and thread name when mounted\n+        boolean mounted;\n+        if (Thread.currentThread() == this) {\n+            mounted = appendCarrierInfo(sb);\n+        } else {\n+            disableSuspendAndPreempt();\n@@ -1077,7 +1149,1 @@\n-                    carrier = carrierThread;\n-                    if (carrier != null) {\n-                        String stateAsString = carrier.threadState().toString();\n-                        sb.append(stateAsString.toLowerCase(Locale.ROOT));\n-                        sb.append('@');\n-                        sb.append(carrier.getName());\n-                    }\n+                    mounted = appendCarrierInfo(sb);\n@@ -1086,1 +1152,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -1089,2 +1155,3 @@\n-        \/\/ include virtual thread state when not mounted\n-        if (carrier == null) {\n+\n+        \/\/ add virtual thread state when not mounted\n+        if (!mounted) {\n@@ -1094,0 +1161,1 @@\n+\n@@ -1097,0 +1165,18 @@\n+    \/**\n+     * Appends the carrier state and thread name to the string buffer if mounted.\n+     * @return true if mounted, false if not mounted\n+     *\/\n+    private boolean appendCarrierInfo(StringBuilder sb) {\n+        assert Thread.currentThread() == this || Thread.holdsLock(carrierThreadAccessLock());\n+        Thread carrier = carrierThread;\n+        if (carrier != null) {\n+            String stateAsString = carrier.threadState().toString();\n+            sb.append(stateAsString.toLowerCase(Locale.ROOT));\n+            sb.append('@');\n+            sb.append(carrier.getName());\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n@@ -1130,0 +1216,16 @@\n+    \/**\n+     * Disallow the current thread be suspended or preempted.\n+     *\/\n+    private void disableSuspendAndPreempt() {\n+        notifyJvmtiDisableSuspend(true);\n+        Continuation.pin();\n+    }\n+\n+    \/**\n+     * Allow the current thread be suspended or preempted.\n+     *\/\n+    private void enableSuspendAndPreempt() {\n+        Continuation.unpin();\n+        notifyJvmtiDisableSuspend(false);\n+    }\n+\n@@ -1191,0 +1293,6 @@\n+\n+        \/\/ ensure VTHREAD_GROUP is created, may be accessed by JVMTI\n+        var group = Thread.virtualThreadGroup();\n+\n+        \/\/ ensure VirtualThreadPinnedEvent is loaded\/initialized\n+        U.ensureClassInitialized(VirtualThreadPinnedEvent.class);\n@@ -1194,1 +1302,1 @@\n-     * Creates the default scheduler.\n+     * Creates the default ForkJoinPool scheduler.\n@@ -1232,1 +1340,1 @@\n-     * Creates the ScheduledThreadPoolExecutor used for timed unpark.\n+     * Schedule a runnable task to run after a delay.\n@@ -1234,3 +1342,13 @@\n-    private static ScheduledExecutorService createDelayedTaskScheduler() {\n-        String propValue = GetPropertyAction.privilegedGetProperty(\"jdk.unparker.maxPoolSize\");\n-        int poolSize;\n+    private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        long tid = Thread.currentThread().threadId();\n+        int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n+        return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n+    }\n+\n+    \/**\n+     * Creates the ScheduledThreadPoolExecutors used to execute delayed tasks.\n+     *\/\n+    private static ScheduledExecutorService[] createDelayedTaskSchedulers() {\n+        String propName = \"jdk.virtualThreadScheduler.timerQueues\";\n+        String propValue = GetPropertyAction.privilegedGetProperty(propName);\n+        int queueCount;\n@@ -1238,1 +1356,4 @@\n-            poolSize = Integer.parseInt(propValue);\n+            queueCount = Integer.parseInt(propValue);\n+            if (queueCount != Integer.highestOneBit(queueCount)) {\n+                throw new RuntimeException(\"Value of \" + propName + \" must be power of 2\");\n+            }\n@@ -1240,1 +1361,13 @@\n-            poolSize = 1;\n+            int ncpus = Runtime.getRuntime().availableProcessors();\n+            queueCount = Math.max(Integer.highestOneBit(ncpus \/ 4), 1);\n+        }\n+        var schedulers = new ScheduledExecutorService[queueCount];\n+        for (int i = 0; i < queueCount; i++) {\n+            ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n+                Executors.newScheduledThreadPool(1, task -> {\n+                    Thread t = InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n+                    t.setDaemon(true);\n+                    return t;\n+                });\n+            stpe.setRemoveOnCancelPolicy(true);\n+            schedulers[i] = stpe;\n@@ -1242,6 +1375,1 @@\n-        ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n-            Executors.newScheduledThreadPool(poolSize, task -> {\n-                return InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n-            });\n-        stpe.setRemoveOnCancelPolicy(true);\n-        return stpe;\n+        return schedulers;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":210,"deletions":82,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,48 +67,0 @@\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a class}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofClass(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.CLASS, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a class}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofClass(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.CLASS, flags);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a field}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofField(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.FIELD, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a field}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofField(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.FIELD, flags);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a method}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofMethod(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.METHOD, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a method}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofMethod(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.METHOD, flags);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AccessFlags.java","additions":1,"deletions":49,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-        extends WritableElement<Annotation>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-        extends WritableElement<AnnotationElement>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-public sealed interface AnnotationValue extends WritableElement<AnnotationValue>\n+public sealed interface AnnotationValue\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        extends WritableElement<A>\n+        extends ClassFileElement\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -86,1 +87,1 @@\n-        return list;\n+        return Collections.unmodifiableList(list);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributedElement.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-        extends WritableElement<BootstrapMethodEntry>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/BootstrapMethodEntry.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.List;\n-\n@@ -113,7 +111,0 @@\n-    \/**\n-     * Write the contents of another {@link BufWriter} to the buffer\n-     *\n-     * @param other the other {@linkplain BufWriter}\n-     *\/\n-    void writeBytes(BufWriter other);\n-\n@@ -169,20 +160,0 @@\n-    \/**\n-     * Write a list of entities to the buffer.  The length of the list is\n-     * written as a {@code u2}, followed by the bytes corresponding to each\n-     * element in the list.  Writing of the entities is delegated to the entry.\n-     *\n-     * @param list the entities\n-     * @param <T> the type of entity\n-     *\/\n-    <T extends WritableElement<?>> void writeList(List<T> list);\n-\n-    \/**\n-     * Write a list of constant pool entry indexes to the buffer.  The length\n-     * of the list is written as a {@code u2}, followed by a {@code u2} for each\n-     * entry in the list.\n-     *\n-     * @param list the list of entries\n-     * @throws IllegalArgumentException if any entry has invalid index\n-     *\/\n-    void writeListIndices(List<? extends PoolEntry> list);\n-\n@@ -193,10 +164,0 @@\n-\n-    \/**\n-     * Copy the contents of the buffer into a byte array.\n-     *\n-     * @param array the byte array\n-     * @param bufferOffset the offset into the array at which to write the\n-     *                     contents of the buffer\n-     * @throws IndexOutOfBoundsException if copying outside of the array bounds\n-     *\/\n-    void copyTo(byte[] array, int bufferOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/BufWriter.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.Optional;\n@@ -38,0 +37,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -61,6 +62,0 @@\n-    \/**\n-     * {@return the {@link ClassModel} representing the class being transformed,\n-     * if this class builder represents the transformation of some {@link ClassModel}}\n-     *\/\n-    Optional<ClassModel> original();\n-\n@@ -83,1 +78,1 @@\n-        return with(AccessFlags.ofClass(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.CLASS, flags));\n@@ -92,1 +87,1 @@\n-        return with(AccessFlags.ofClass(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.CLASS, flags));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.constantpool.ConstantPool;\n@@ -32,0 +31,2 @@\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -74,8 +75,0 @@\n-    \/**\n-     * {@return whether the provided constant pool is compatible with this builder}\n-     * @param source the constant pool to test compatibility with\n-     *\/\n-    default boolean canWriteDirect(ConstantPool source) {\n-        return constantPool().canWriteDirect(source);\n-    }\n-\n@@ -86,0 +79,1 @@\n+     * @return this builder\n@@ -87,1 +81,1 @@\n-    default void transform(CompoundElement<E> model, ClassFileTransform<?, E, B> transform) {\n+    default B transform(CompoundElement<E> model, ClassFileTransform<?, E, B> transform) {\n@@ -90,1 +84,1 @@\n-        var resolved = transform.resolve(builder);\n+        var resolved = TransformImpl.resolve(transform, builder);\n@@ -92,1 +86,1 @@\n-        model.forEachElement(resolved.consumer());\n+        model.forEach(resolved.consumer());\n@@ -94,0 +88,1 @@\n+        return builder;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileBuilder.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        permits AttributedElement, CompoundElement, WritableElement,\n+        permits AttributedElement, CompoundElement, Attribute,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.function.Consumer;\n@@ -127,42 +126,0 @@\n-\n-    \/**\n-     * The result of binding a transform to a builder.  Used primarily within\n-     * the implementation to perform transformation.\n-     *\n-     * @param <E> the element type\n-     *\n-     * @since 22\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n-    interface ResolvedTransform<E extends ClassFileElement> {\n-        \/**\n-         * {@return a {@link Consumer} to receive elements}\n-         *\/\n-        Consumer<E> consumer();\n-\n-        \/**\n-         * {@return an action to call at the end of transformation}\n-         *\/\n-        Runnable endHandler();\n-\n-        \/**\n-         * {@return an action to call at the start of transformation}\n-         *\/\n-        Runnable startHandler();\n-    }\n-\n-    \/**\n-     * Bind a transform to a builder.  If the transform is chained, intermediate\n-     * builders are created for each chain link.  If the transform is stateful\n-     * (see, e.g., {@link ClassTransform#ofStateful(Supplier)}), the supplier is\n-     * invoked to get a fresh transform object.\n-     *\n-     * <p>This method is a low-level method that should rarely be used by\n-     * user code; most of the time, user code should prefer\n-     * {@link ClassFileBuilder#transform(CompoundElement, ClassFileTransform)},\n-     * which resolves the transform and executes it on the current builder.\n-     *\n-     * @param builder the builder to bind to\n-     * @return the bound result\n-     *\/\n-    ResolvedTransform<E> resolve(B builder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * a streaming view, or via random access (e.g.,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,15 +192,0 @@\n-\n-    \/**\n-     * Compare a range of bytes from the classfile to a range of bytes within\n-     * a {@link BufWriter}.\n-     *\n-     * @param bufWriter the {@linkplain BufWriter}\n-     * @param bufWriterOffset the offset within the {@linkplain BufWriter}\n-     * @param classReaderOffset the offset within the classfile\n-     * @param length the length of the range\n-     * @return whether the two ranges were identical\n-     *\/\n-    boolean compare(BufWriter bufWriter,\n-                    int bufWriterOffset,\n-                    int classReaderOffset,\n-                    int length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                requireNonNull(typeParameters),\n+                List.copyOf(requireNonNull(typeParameters)),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,11 +174,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given class builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -130,6 +131,0 @@\n-    \/**\n-     * {@return the {@link CodeModel} representing the method body being transformed,\n-     * if this code builder represents the transformation of some {@link CodeModel}}\n-     *\/\n-    Optional<CodeModel> original();\n-\n@@ -193,1 +188,1 @@\n-        var resolved = transform.resolve(this);\n+        var resolved = TransformImpl.resolve(transform, this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,1 @@\n- * of the method body are accessed via a streaming view (e.g., {@link\n- * #elements()}).\n+ * of the method body are accessed via a streaming view.\n@@ -47,11 +46,1 @@\n-        permits CodeAttribute, BufferedCodeBuilder.Model, CodeImpl {\n-\n-    \/**\n-     * {@return the maximum size of the local variable table}\n-     *\/\n-    int maxLocals();\n-\n-    \/**\n-     * {@return the maximum size of the operand stack}\n-     *\/\n-    int maxStack();\n+        permits CodeAttribute, BufferedCodeBuilder.Model {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeModel.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,11 +99,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given code builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<CodeElement> resolve(CodeBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -43,1 +44,1 @@\n- * (e.g., {@link #elements()}, {@link #forEachElement(Consumer)}, etc.)\n+ * (e.g., {@link #forEach(Consumer)}, etc.)\n@@ -58,9 +59,2 @@\n-    void forEachElement(Consumer<E> consumer);\n-\n-    \/**\n-     * {@return an {@link Iterable} describing all the elements contained in this\n-     * compound element}\n-     *\/\n-    default Iterable<E> elements() {\n-        return elementList();\n-    }\n+    @Override\n+    void forEach(Consumer<? super E> consumer);\n@@ -74,1 +68,1 @@\n-        return elements().iterator();\n+        return elementList().iterator();\n@@ -94,1 +88,1 @@\n-        forEachElement(new Consumer<>() {\n+        forEach(new Consumer<>() {\n@@ -100,1 +94,1 @@\n-        return list;\n+        return Collections.unmodifiableList(list);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CompoundElement.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,6 +62,0 @@\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public final void writeTo(BufWriter buf) {\n-        mapper.writeAttribute(buf, (T) this);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CustomAttribute.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -33,1 +35,0 @@\n-import java.util.Optional;\n@@ -59,1 +60,1 @@\n-        return with(AccessFlags.ofField(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.FIELD, flags));\n@@ -68,1 +69,1 @@\n-        return with(AccessFlags.ofField(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.FIELD, flags));\n@@ -71,5 +72,0 @@\n-    \/**\n-     * {@return the {@link FieldModel} representing the field being transformed,\n-     * if this field builder represents the transformation of some {@link FieldModel}}\n-     *\/\n-    Optional<FieldModel> original();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * a streaming view, or via random access (e.g.,\n@@ -45,1 +45,1 @@\n-        extends WritableElement<FieldModel>, CompoundElement<FieldElement>, AttributedElement, ClassElement\n+        extends CompoundElement<FieldElement>, AttributedElement, ClassElement\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldModel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,11 +114,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given field builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<FieldElement> resolve(FieldBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Optional;\n@@ -32,0 +31,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -53,6 +54,0 @@\n-    \/**\n-     * {@return the {@link MethodModel} representing the method being transformed,\n-     * if this method builder represents the transformation of some {@link MethodModel}}\n-     *\/\n-    Optional<MethodModel> original();\n-\n@@ -65,1 +60,1 @@\n-        return with(AccessFlags.ofMethod(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.METHOD, flags));\n@@ -74,1 +69,1 @@\n-        return with(AccessFlags.ofMethod(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.METHOD, flags));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * a streaming view, or via random access (e.g.,\n@@ -45,1 +45,1 @@\n-        extends WritableElement<MethodModel>, CompoundElement<MethodElement>, AttributedElement, ClassElement\n+        extends CompoundElement<MethodElement>, AttributedElement, ClassElement\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodModel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,11 +114,0 @@\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given method builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.classfile;\n-\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.classfile.constantpool.PoolEntry;\n-import jdk.internal.classfile.impl.DirectFieldBuilder;\n-import jdk.internal.classfile.impl.DirectMethodBuilder;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * A classfile element that can encode itself as a stream of bytes in the\n- * encoding expected by the classfile format.\n- *\n- * @param <T> the type of the entity\n- *\n- * @sealedGraph\n- * @since 22\n- *\/\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n-public sealed interface WritableElement<T> extends ClassFileElement\n-        permits Annotation, AnnotationElement, AnnotationValue, Attribute,\n-                PoolEntry, BootstrapMethodEntry, FieldModel, MethodModel,\n-                ConstantPoolBuilder, DirectFieldBuilder, DirectMethodBuilder {\n-    \/**\n-     * Writes the element to the specified writer\n-     *\n-     * @param buf the writer\n-     *\/\n-    void writeTo(BufWriter buf);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/WritableElement.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -50,0 +50,10 @@\n+    \/**\n+     * {@return the maximum size of the local variable table}\n+     *\/\n+    int maxLocals();\n+\n+    \/**\n+     * {@return the maximum size of the operand stack}\n+     *\/\n+    int maxStack();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * <p>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeStackTracker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -42,1 +41,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -64,1 +62,1 @@\n-        extends ConstantPool, WritableElement<ConstantPool>\n+        extends ConstantPool\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -37,1 +36,1 @@\n-public sealed interface PoolEntry extends WritableElement<PoolEntry>\n+public sealed interface PoolEntry\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PoolEntry.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,0 @@\n-import java.lang.constant.ClassDesc;\n-\n-import java.lang.classfile.BufWriter;\n@@ -37,0 +34,2 @@\n+import java.lang.constant.ClassDesc;\n+\n@@ -87,8 +86,0 @@\n-    \/**\n-     * Writes the local variable to the specified writer\n-     *\n-     * @param buf the writer\n-     * @return true if the variable has been written\n-     *\/\n-    boolean writeTo(BufWriter buf);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -36,0 +35,1 @@\n+\n@@ -84,8 +84,0 @@\n-    \/**\n-     * Writes the local variable to the specified writer\n-     *\n-     * @param buf the writer\n-     * @return true if the variable has been written\n-     *\/\n-    boolean writeTo(BufWriter buf);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * <p>\n+ *\n@@ -40,1 +40,1 @@\n- * <p>\n+ *\n@@ -380,1 +380,1 @@\n- * <p>\n+ *\n@@ -446,1 +446,1 @@\n- * <p>\n+ *\n@@ -472,1 +472,1 @@\n- *<p>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-  <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/..\/..\/..\/stylesheet.css\" title=\"Style\">\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/ValueBased.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-  <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/..\/..\/..\/stylesheet.css\" title=\"Style\">\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n- * the segments allocated by it) becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n+ * the segments allocated by it) becomes {@linkplain java.lang.ref##reachability unreachable},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-     *          kept <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>\n+     *          kept {@linkplain java.lang.ref##reachability reachable}\n@@ -788,1 +788,1 @@\n-     *          <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     *          {@linkplain java.lang.ref##reachability unreachable}.\n@@ -839,1 +839,1 @@\n-     *          <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     *          {@linkplain java.lang.ref##reachability unreachable}.\n@@ -2665,1 +2665,1 @@\n-     * as long as it is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * as long as it is {@linkplain java.lang.ref##reachability reachable}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. The\n+     * {@linkplain java.lang.ref##reachability unreachable}. The\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,1 +402,1 @@\n-            names[arity] = zero.newIndex(arity);\n+            names[arity] = zero.withIndex(arity);\n@@ -502,1 +502,1 @@\n-        Name[] oldNames = null;\n+        Name[] oldNames = names.clone();\n@@ -504,1 +504,0 @@\n-        int changesStart = 0;\n@@ -507,7 +506,1 @@\n-            if (!n.initIndex(i)) {\n-                if (oldNames == null) {\n-                    oldNames = names.clone();\n-                    changesStart = i;\n-                }\n-                names[i] = n.cloneWithIndex(i);\n-            }\n+            names[i] = n.withIndex(i);\n@@ -518,6 +511,3 @@\n-            int startFixing = arity;\n-            if (startFixing <= changesStart)\n-                startFixing = changesStart+1;\n-            for (int i = startFixing; i < names.length; i++) {\n-                Name fixed = names[i].replaceNames(oldNames, names, changesStart, i);\n-                names[i] = fixed.newIndex(i);\n+            for (int i = Math.max(1, arity); i < names.length; i++) {\n+                Name fixed = names[i].replaceNames(oldNames, names, 0, i);\n+                names[i] = fixed.withIndex(i);\n@@ -1346,1 +1336,1 @@\n-        @Stable short index;\n+        final short index;\n@@ -1353,1 +1343,1 @@\n-        private Name(int index, BasicType type, NamedFunction function, Object[] arguments) {\n+        private Name(int index, BasicType type, NamedFunction function, Object[] arguments, Object constraint) {\n@@ -1358,8 +1348,0 @@\n-            this.constraint = null;\n-            assert(this.index == index && typesMatch(function, this.arguments));\n-        }\n-        private Name(Name that, Object constraint) {\n-            this.index = that.index;\n-            this.type = that.type;\n-            this.function = that.function;\n-            this.arguments = that.arguments;\n@@ -1367,0 +1349,1 @@\n+            assert(this.index == index && typesMatch(function, arguments));\n@@ -1370,0 +1353,1 @@\n+\n@@ -1381,1 +1365,1 @@\n-            this(-1, function.returnType(), function, EMPTY_ARGS);\n+            this(-1, function.returnType(), function, EMPTY_ARGS, null);\n@@ -1384,1 +1368,1 @@\n-            this(-1, function.returnType(), function, new Object[] { arg });\n+            this(-1, function.returnType(), function, new Object[] { arg }, null);\n@@ -1387,1 +1371,1 @@\n-            this(-1, function.returnType(), function, new Object[] { arg0, arg1 });\n+            this(-1, function.returnType(), function, new Object[] { arg0, arg1 }, null);\n@@ -1390,1 +1374,1 @@\n-            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class));\n+            this(-1, function.returnType(), function, Arrays.copyOf(arguments, arguments.length, Object[].class), null);\n@@ -1394,1 +1378,1 @@\n-            this(index, type, null, null);\n+            this(index, type, null, null, null);\n@@ -1401,7 +1385,1 @@\n-        boolean initIndex(int i) {\n-            if (index != i) {\n-                if (index != -1)  return false;\n-                index = (short)i;\n-            }\n-            return true;\n-        }\n+\n@@ -1412,7 +1390,3 @@\n-        Name newIndex(int i) {\n-            if (initIndex(i))  return this;\n-            return cloneWithIndex(i);\n-        }\n-        Name cloneWithIndex(int i) {\n-            Object[] newArguments = (arguments == null) ? null : arguments.clone();\n-            return new Name(i, type, function, newArguments).withConstraint(constraint);\n+        Name withIndex(int i) {\n+            if (i == this.index) return this;\n+            return new Name(i, type, function, arguments, constraint);\n@@ -1420,0 +1394,1 @@\n+\n@@ -1422,1 +1397,1 @@\n-            return new Name(this, constraint);\n+            return new Name(index, type, function, arguments, constraint);\n@@ -1424,0 +1399,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":23,"deletions":47,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -568,10 +568,2 @@\n-        if (suffix != null) {\n-            \/\/ newArray variant that deals with prepending any trailing constant\n-            \/\/\n-            \/\/ initialLengthCoder is adjusted to have the correct coder\n-            \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n-            \/\/ suffix to be encoded into indexCoder\n-            initialLengthCoder -= suffix.length();\n-            newArrayCombinator = newArrayWithSuffix(suffix);\n-        } else {\n-            newArrayCombinator = newArray();\n+        if (suffix == null || suffix.isEmpty()) {\n+            suffix = \"\";\n@@ -579,0 +571,8 @@\n+        \/\/ newArray variant that deals with prepending any trailing constant\n+        \/\/\n+        \/\/ initialLengthCoder is adjusted to have the correct coder\n+        \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n+        \/\/ suffix to be encoded into indexCoder\n+        initialLengthCoder -= suffix.length();\n+        newArrayCombinator = newArrayWithSuffix(suffix);\n+\n@@ -741,3 +741,1 @@\n-            NO_PREFIX_PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(long.class, long.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl))).rebind();\n+            NO_PREFIX_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(prepender(cl), 3, \"\");\n@@ -905,10 +903,0 @@\n-    private @Stable static MethodHandle NEW_ARRAY;\n-    private static MethodHandle newArray() {\n-        MethodHandle mh = NEW_ARRAY;\n-        if (mh == null) {\n-            NEW_ARRAY = mh =\n-                    JLA.stringConcatHelper(\"newArray\", methodType(byte[].class, long.class));\n-        }\n-        return mh;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+    \/\/ Hash code of this object\n+    private int                 hash;\n@@ -384,1 +386,7 @@\n-        return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n+        int hc = hash;\n+\n+        if (hc == 0) {\n+            hc = hash = getDeclaringClass().getName().hashCode() ^ getName()\n+                .hashCode();\n+        }\n+        return hc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,4 +145,4 @@\n- * For IPv4 address format, please refer to <A\n- * HREF=\"Inet4Address.html#format\">Inet4Address#format<\/A>; For IPv6\n- * address format, please refer to <A\n- * HREF=\"Inet6Address.html#format\">Inet6Address#format<\/A>.\n+ * For IPv4 address format, please refer to the supported\n+ * {@linkplain Inet4Address##format IPv4 address textual representations};\n+ * For IPv6 address format, please refer to the supported\n+ * {@linkplain Inet6Address##format IPv6 address textual representations}.\n@@ -150,1 +150,1 @@\n- * <p> There is a <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">couple of\n+ * <p> There are a <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">couple of\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -331,2 +331,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -360,2 +360,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *                      is already bound or the socket is closed.\n@@ -521,1 +521,1 @@\n-     *               connection.\n+     *               connection, the socket is not bound or the socket is closed.\n@@ -739,0 +739,3 @@\n+     * <p> Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n+     *\n@@ -809,2 +812,2 @@\n-     * @throws  SocketException if there is an error in the underlying protocol,\n-     *          such as a TCP error\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -827,1 +830,1 @@\n-     * @throws    IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs or the socket is closed.\n@@ -890,2 +893,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol, such as a TCP error,\n+     *         or the socket is closed.\n@@ -1004,2 +1007,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1032,2 +1035,2 @@\n-     * @throws    SocketException if there is an error\n-     *            in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -686,1 +686,2 @@\n-     * @throws  IOException if an error occurs during the connection\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -720,1 +721,2 @@\n-     * @throws  IOException if an error occurs during the connection\n+     * @throws  IOException if an error occurs during the connection, the socket\n+     *          is already connected or the socket is closed\n@@ -783,2 +785,2 @@\n-     * @throws  IOException if the bind operation fails, or if the socket\n-     *                     is already bound.\n+     * @throws  IOException if the bind operation fails, the socket\n+     *          is already bound or the socket is closed.\n@@ -1177,2 +1179,2 @@\n-     * @throws     IOException  if an I\/O error occurs when creating the\n-     *               output stream or if the socket is not connected.\n+     * @throws IOException  if an I\/O error occurs when creating the\n+     *         output stream, the socket is not connected or the socket is closed.\n@@ -1254,2 +1256,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1272,2 +1274,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1292,3 +1294,3 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n-     * @throws    IllegalArgumentException if the linger value is negative.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n+     * @throws  IllegalArgumentException if the linger value is negative.\n@@ -1321,2 +1323,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1371,2 +1373,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1390,2 +1392,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1412,2 +1414,2 @@\n-     * @throws  SocketException if there is an error in the underlying protocol,\n-     *          such as a TCP error\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1431,2 +1433,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1458,3 +1460,0 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n-     *\n@@ -1464,2 +1463,3 @@\n-     * @throws    IllegalArgumentException if the\n-     * value is 0 or is negative.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n+     * @throws  IllegalArgumentException if the value is 0 or is negative.\n@@ -1484,2 +1484,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1532,2 +1532,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1553,2 +1553,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1573,2 +1573,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1589,2 +1589,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1640,2 +1640,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1664,2 +1664,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1718,2 +1718,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as a TCP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as a TCP error, or the socket is closed.\n@@ -1736,2 +1736,3 @@\n-     * use (i.e. can't be reconnected or rebound). A new socket needs to be\n-     * created.\n+     * use (i.e. can't be reconnected or rebound) and several of the methods defined\n+     * by this class will throw an exception if invoked on the closed socket. A new\n+     * socket needs to be created.\n@@ -1770,2 +1771,2 @@\n-     * @throws    IOException if an I\/O error occurs when shutting down this\n-     * socket.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the\n+     *         socket is not connected or the socket is closed.\n@@ -1800,2 +1801,2 @@\n-     * @throws    IOException if an I\/O error occurs when shutting down this\n-     * socket.\n+     * @throws IOException if an I\/O error occurs when shutting down this socket, the socket\n+     *         is not connected or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":51,"deletions":50,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-     * <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">System Properties<\/a> which affect\n+     * <a href=\"..\/doc-files\/net-properties.html#Ipv4IPv6\">System Properties<\/a> which affect\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,8 +59,0 @@\n-\n-    \/\/ Cached unaligned-access capability\n-    protected static final boolean UNALIGNED = Bits.unaligned();\n-\n-    \/\/ Base address, used in all indexing calculations\n-    \/\/ NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress\n-    \/\/    protected long address;\n-\n@@ -77,0 +69,2 @@\n+    \/\/ Cached unaligned-access capability\n+    static final boolean UNALIGNED = Bits.unaligned();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,2 @@\n+            if (keys == null)\n+                return;\n@@ -236,1 +238,1 @@\n-                    k = ((AbstractSelector)sel).register(this, ops, att);\n+                    k = ((AbstractSelector) sel).register(this, ops, att);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-                          StringBuffer buffer) {\n+                          Format.StringBuf buffer) {\n@@ -96,1 +96,1 @@\n-                          int start, int end, StringBuffer buffer) {\n+                          int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/CharacterIteratorFieldDelegate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -517,1 +517,7 @@\n-        return format((double)number, toAppendTo, status);\n+        return format((double) number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(long number, StringBuf toAppendTo,\n+                     FieldPosition status) {\n+        return format((double) number, toAppendTo, status);\n@@ -534,0 +540,6 @@\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf toAppendTo,\n+                         FieldPosition status) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -542,0 +542,16 @@\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, fieldPosition);\n+            case Integer i -> format(i.longValue(), toAppendTo, fieldPosition);\n+            case Short s -> format(s.longValue(), toAppendTo, fieldPosition);\n+            case Byte b -> format(b.longValue(), toAppendTo, fieldPosition);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, fieldPosition);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, fieldPosition);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, fieldPosition);\n+            case BigDecimal bd -> format(bd, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case BigInteger bi -> format(bi, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+            case Number n -> format(n.doubleValue(), toAppendTo, fieldPosition);\n+            case null -> throw new IllegalArgumentException(\"Cannot format null as a number\");\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Cannot format %s as a number\", number.getClass().getName()));\n+        };\n+    }\n@@ -543,22 +559,19 @@\n-        if (number == null) {\n-            throw new IllegalArgumentException(\"Cannot format null as a number\");\n-        }\n-\n-        if (number instanceof Long || number instanceof Integer\n-                || number instanceof Short || number instanceof Byte\n-                || number instanceof AtomicInteger\n-                || number instanceof AtomicLong\n-                || (number instanceof BigInteger\n-                && ((BigInteger) number).bitLength() < 64)) {\n-            return format(((Number) number).longValue(), toAppendTo,\n-                    fieldPosition);\n-        } else if (number instanceof BigDecimal) {\n-            return format((BigDecimal) number, toAppendTo, fieldPosition);\n-        } else if (number instanceof BigInteger) {\n-            return format((BigInteger) number, toAppendTo, fieldPosition);\n-        } else if (number instanceof Number) {\n-            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot format \"\n-                    + number.getClass().getName() + \" as a number\");\n-        }\n+    @Override\n+    StringBuf format(Object number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition fieldPosition) {\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, fieldPosition);\n+            case Integer i -> format(i.longValue(), toAppendTo, fieldPosition);\n+            case Short s -> format(s.longValue(), toAppendTo, fieldPosition);\n+            case Byte b -> format(b.longValue(), toAppendTo, fieldPosition);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, fieldPosition);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, fieldPosition);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, fieldPosition);\n+            case BigDecimal bd -> format(bd, toAppendTo, fieldPosition);\n+            case BigInteger bi -> format(bi, toAppendTo, fieldPosition);\n+            case Number n -> format(n.doubleValue(), toAppendTo, fieldPosition);\n+            case null -> throw new IllegalArgumentException(\"Cannot format null as a number\");\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Cannot format %s as a number\", number.getClass().getName()));\n+        };\n@@ -594,0 +607,9 @@\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+\n@@ -599,1 +621,1 @@\n-    private StringBuffer format(double number, StringBuffer result,\n+    private StringBuf format(double number, StringBuf result,\n@@ -684,0 +706,9 @@\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(long number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+\n@@ -689,1 +720,1 @@\n-    private StringBuffer format(long number, StringBuffer result, FieldDelegate delegate) {\n+    private StringBuf format(long number, StringBuf result, FieldDelegate delegate) {\n@@ -760,1 +791,1 @@\n-     * @return        the {@code StringBuffer} passed in as {@code result}\n+     * @return        the {@code StringBuf} passed in as {@code result}\n@@ -767,2 +798,2 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n-            FieldPosition fieldPosition) {\n+    private StringBuf format(BigDecimal number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -776,1 +807,1 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n+    private StringBuf format(BigDecimal number, StringBuf result,\n@@ -846,1 +877,1 @@\n-     * @return        the {@code StringBuffer} passed in as {@code result}\n+     * @return        the {@code StringBuf} passed in as {@code result}\n@@ -853,2 +884,2 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n-            FieldPosition fieldPosition) {\n+    private StringBuf format(BigInteger number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -862,1 +893,1 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n+    private StringBuf format(BigInteger number, StringBuf result,\n@@ -939,1 +970,1 @@\n-    private void appendPrefix(StringBuffer result, String prefix,\n+    private void appendPrefix(StringBuf result, String prefix,\n@@ -955,1 +986,1 @@\n-    private void appendSuffix(StringBuffer result, String suffix,\n+    private void appendSuffix(StringBuf result, String suffix,\n@@ -971,1 +1002,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n@@ -1137,14 +1168,13 @@\n-        StringBuffer sb = new StringBuffer();\n-\n-        if (obj instanceof Double || obj instanceof Float) {\n-            format(((Number) obj).doubleValue(), sb, delegate);\n-        } else if (obj instanceof Long || obj instanceof Integer\n-                || obj instanceof Short || obj instanceof Byte\n-                || obj instanceof AtomicInteger || obj instanceof AtomicLong) {\n-            format(((Number) obj).longValue(), sb, delegate);\n-        } else if (obj instanceof BigDecimal) {\n-            format((BigDecimal) obj, sb, delegate);\n-        } else if (obj instanceof BigInteger) {\n-            format((BigInteger) obj, sb, delegate, false);\n-        } else if (obj == null) {\n-            throw new NullPointerException(\n+        StringBuf sb = StringBufFactory.of();\n+        switch (obj) {\n+            case Double d -> format(d.doubleValue(), sb, delegate);\n+            case Float f -> format(f.doubleValue(), sb, delegate);\n+            case Long l -> format(l.longValue(), sb, delegate);\n+            case Integer i -> format(i.longValue(), sb, delegate);\n+            case Short s -> format(s.longValue(), sb, delegate);\n+            case Byte b -> format(b.longValue(), sb, delegate);\n+            case AtomicInteger ai -> format(ai.longValue(), sb, delegate);\n+            case AtomicLong al -> format(al.longValue(), sb, delegate);\n+            case BigDecimal bd -> format(bd, sb, delegate);\n+            case BigInteger bi -> format(bi, sb, delegate, false);\n+            case null -> throw new NullPointerException(\n@@ -1152,2 +1182,1 @@\n-        } else {\n-            throw new IllegalArgumentException(\n+            default -> throw new IllegalArgumentException(\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":80,"deletions":51,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -349,0 +349,13 @@\n+    @Override\n+    final StringBuf format(Object obj, StringBuf toAppendTo,\n+                           FieldPosition fieldPosition) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo, fieldPosition);\n+        } else if (obj instanceof Number) {\n+            return format(new Date(((Number) obj).longValue()),\n+                    toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n+        }\n+    }\n+\n@@ -374,0 +387,5 @@\n+    StringBuf format(Date date, StringBuf toAppendTo,\n+                     FieldPosition fieldPosition) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -382,2 +400,8 @@\n-        return format(date, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())\n+                    && \"java.text\".equals(numberFormat.getClass().getPackageName())) {\n+            return format(date, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(date, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,14 +354,0 @@\n-    \/**\n-     * Returns a DateFormatSymbols provided by a provider or found in\n-     * the cache. Note that this method returns a cached instance,\n-     * not its clone. Therefore, the instance should never be given to\n-     * an application.\n-     *\/\n-    static final DateFormatSymbols getInstanceRef(Locale locale) {\n-        DateFormatSymbols dfs = getProviderInstance(locale);\n-        if (dfs != null) {\n-            return dfs;\n-        }\n-        throw new RuntimeException(\"DateFormatSymbols instance creation failed.\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -433,5 +433,0 @@\n-     * <p>\n-     * To obtain standard formats for a given locale, use the factory methods\n-     * on NumberFormat such as getNumberInstance. These factories will\n-     * return the most appropriate sub-class of NumberFormat for a given\n-     * locale.\n@@ -439,4 +434,8 @@\n-     * @see java.text.NumberFormat#getInstance\n-     * @see java.text.NumberFormat#getNumberInstance\n-     * @see java.text.NumberFormat#getCurrencyInstance\n-     * @see java.text.NumberFormat#getPercentInstance\n+     * @apiNote To obtain standard formats for a given locale, use the\n+     * {@code NumberFormat} factory methods such as {@link\n+     * NumberFormat#getNumberInstance(Locale)}. These factories will return the most\n+     * appropriate subclass of NumberFormat for a given locale.\n+     * @see NumberFormat#getInstance(Locale)\n+     * @see NumberFormat#getNumberInstance(Locale)\n+     * @see NumberFormat#getCurrencyInstance(Locale)\n+     * @see NumberFormat#getPercentInstance(Locale)\n@@ -467,5 +466,0 @@\n-     * <p>\n-     * To obtain standard formats for a given locale, use the factory methods\n-     * on NumberFormat such as getNumberInstance. These factories will\n-     * return the most appropriate sub-class of NumberFormat for a given\n-     * locale.\n@@ -473,0 +467,4 @@\n+     * @apiNote To obtain standard formats for a given locale, use the\n+     * {@code NumberFormat} factory methods such as {@link\n+     * NumberFormat#getNumberInstance(Locale)}. These factories will return the most\n+     * appropriate subclass of NumberFormat for a given locale.\n@@ -476,4 +474,4 @@\n-     * @see java.text.NumberFormat#getInstance\n-     * @see java.text.NumberFormat#getNumberInstance\n-     * @see java.text.NumberFormat#getCurrencyInstance\n-     * @see java.text.NumberFormat#getPercentInstance\n+     * @see NumberFormat#getInstance(Locale)\n+     * @see NumberFormat#getNumberInstance(Locale)\n+     * @see NumberFormat#getCurrencyInstance(Locale)\n+     * @see NumberFormat#getPercentInstance(Locale)\n@@ -495,6 +493,0 @@\n-     * <p>\n-     * To obtain standard formats for a given\n-     * locale, use the factory methods on NumberFormat such as\n-     * getInstance or getCurrencyInstance. If you need only minor adjustments\n-     * to a standard format, you can modify the format returned by\n-     * a NumberFormat factory method.\n@@ -502,0 +494,5 @@\n+     * @apiNote To obtain standard formats for a given locale, use the\n+     * {@code NumberFormat} factory methods such as {@link\n+     * NumberFormat#getInstance(Locale)} or {@link NumberFormat#getCurrencyInstance(Locale)}.\n+     * If you need only minor adjustments to a standard format, you can modify\n+     * the format returned by a NumberFormat factory method.\n@@ -506,4 +503,4 @@\n-     * @see java.text.NumberFormat#getInstance\n-     * @see java.text.NumberFormat#getNumberInstance\n-     * @see java.text.NumberFormat#getCurrencyInstance\n-     * @see java.text.NumberFormat#getPercentInstance\n+     * @see NumberFormat#getInstance(Locale)\n+     * @see NumberFormat#getNumberInstance(Locale)\n+     * @see NumberFormat#getCurrencyInstance(Locale)\n+     * @see NumberFormat#getPercentInstance(Locale)\n@@ -525,2 +522,2 @@\n-     * <p>\n-     * This implementation uses the maximum precision permitted.\n+     *\n+     * @implSpec This implementation uses the maximum precision permitted.\n@@ -551,16 +548,32 @@\n-        if (number instanceof Long || number instanceof Integer ||\n-                   number instanceof Short || number instanceof Byte ||\n-                   number instanceof AtomicInteger ||\n-                   number instanceof AtomicLong ||\n-                   (number instanceof BigInteger &&\n-                    ((BigInteger)number).bitLength () < 64)) {\n-            return format(((Number)number).longValue(), toAppendTo, pos);\n-        } else if (number instanceof BigDecimal) {\n-            return format((BigDecimal)number, toAppendTo, pos);\n-        } else if (number instanceof BigInteger) {\n-            return format((BigInteger)number, toAppendTo, pos);\n-        } else if (number instanceof Number) {\n-            return format(((Number)number).doubleValue(), toAppendTo, pos);\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n-        }\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, pos);\n+            case Integer i -> format(i.longValue(), toAppendTo, pos);\n+            case Short s -> format(s.longValue(), toAppendTo, pos);\n+            case Byte b -> format(b.longValue(), toAppendTo, pos);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, pos);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, pos);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, pos);\n+            case BigDecimal bd -> format(bd, StringBufFactory.of(toAppendTo), pos).asStringBuffer();\n+            case BigInteger bi -> format(bi, StringBufFactory.of(toAppendTo), pos).asStringBuffer();\n+            case Number n -> format(n.doubleValue(), toAppendTo, pos);\n+            case null, default -> throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        };\n+    }\n+\n+    @Override\n+    final StringBuf format(Object number,\n+                           StringBuf toAppendTo,\n+                           FieldPosition pos) {\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, pos);\n+            case Integer i -> format(i.longValue(), toAppendTo, pos);\n+            case Short s -> format(s.longValue(), toAppendTo, pos);\n+            case Byte b -> format(b.longValue(), toAppendTo, pos);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, pos);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, pos);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, pos);\n+            case BigDecimal bd -> format(bd, toAppendTo, pos);\n+            case BigInteger bi -> format(bi, toAppendTo, pos);\n+            case Number n -> format(n.doubleValue(), toAppendTo, pos);\n+            case null, default -> throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        };\n@@ -591,0 +604,6 @@\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n@@ -622,2 +641,2 @@\n-    StringBuffer format(double number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(double number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -669,1 +688,1 @@\n-    boolean handleNaN(double number, StringBuffer result,\n+    boolean handleNaN(double number, StringBuf result,\n@@ -694,1 +713,1 @@\n-    boolean handleInfinity(double number, StringBuffer result,\n+    boolean handleInfinity(double number, StringBuf result,\n@@ -723,1 +742,1 @@\n-    StringBuffer doubleSubformat(double number, StringBuffer result,\n+    StringBuf doubleSubformat(double number, StringBuf result,\n@@ -764,0 +783,8 @@\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    StringBuf format(long number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+\n@@ -777,2 +804,2 @@\n-    StringBuffer format(long number, StringBuffer result,\n-                               FieldDelegate delegate) {\n+    StringBuf format(long number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -852,2 +879,2 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n-                                FieldPosition fieldPosition) {\n+    private StringBuf format(BigDecimal number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -868,2 +895,2 @@\n-    StringBuffer format(BigDecimal number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(BigDecimal number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -911,2 +938,2 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n-                               FieldPosition fieldPosition) {\n+    private StringBuf format(BigInteger number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -929,2 +956,2 @@\n-    StringBuffer format(BigInteger number, StringBuffer result,\n-                               FieldDelegate delegate, boolean formatLong) {\n+    StringBuf format(BigInteger number, StringBuf result,\n+                     FieldDelegate delegate, boolean formatLong) {\n@@ -988,19 +1015,17 @@\n-                         new CharacterIteratorFieldDelegate();\n-        StringBuffer sb = new StringBuffer();\n-\n-        if (obj instanceof Double || obj instanceof Float) {\n-            format(((Number)obj).doubleValue(), sb, delegate);\n-        } else if (obj instanceof Long || obj instanceof Integer ||\n-                   obj instanceof Short || obj instanceof Byte ||\n-                   obj instanceof AtomicInteger || obj instanceof AtomicLong) {\n-            format(((Number)obj).longValue(), sb, delegate);\n-        } else if (obj instanceof BigDecimal) {\n-            format((BigDecimal)obj, sb, delegate);\n-        } else if (obj instanceof BigInteger) {\n-            format((BigInteger)obj, sb, delegate, false);\n-        } else if (obj == null) {\n-            throw new NullPointerException(\n-                \"formatToCharacterIterator must be passed non-null object\");\n-        } else {\n-            throw new IllegalArgumentException(\n-                \"Cannot format given Object as a Number\");\n+                new CharacterIteratorFieldDelegate();\n+        StringBuf sb = StringBufFactory.of();\n+        switch (obj) {\n+            case Double d -> format(d.doubleValue(), sb, delegate);\n+            case Float f -> format(f.doubleValue(), sb, delegate);\n+            case Long l -> format(l.longValue(), sb, delegate);\n+            case Integer i -> format(i.longValue(), sb, delegate);\n+            case Short s -> format(s.longValue(), sb, delegate);\n+            case Byte b -> format(b.longValue(), sb, delegate);\n+            case AtomicInteger ai -> format(ai.longValue(), sb, delegate);\n+            case AtomicLong al -> format(al.longValue(), sb, delegate);\n+            case BigDecimal bd -> format(bd, sb, delegate);\n+            case BigInteger bi -> format(bi, sb, delegate, false);\n+            case null -> throw new NullPointerException(\n+                    \"formatToCharacterIterator must be passed non-null object\");\n+            default -> throw new IllegalArgumentException(\n+                    \"Cannot format given Object as a Number\");\n@@ -1757,1 +1782,1 @@\n-     * Sets the {@code DigitList} used by this {@code DecimalFormat}\n+     * Utility method that sets the {@code DigitList} used by this {@code DecimalFormat}\n@@ -1759,0 +1784,1 @@\n+     *\n@@ -1762,0 +1788,2 @@\n+     * @throws AssertionError if provided a Number subclass that is not supported\n+     *         by {@code DigitList}\n@@ -1764,9 +1792,7 @@\n-\n-        if (number instanceof Double) {\n-            digitList.set(isNegative, (Double) number, maxDigits, true);\n-        } else if (number instanceof BigDecimal) {\n-            digitList.set(isNegative, (BigDecimal) number, maxDigits, true);\n-        } else if (number instanceof Long) {\n-            digitList.set(isNegative, (Long) number, maxDigits);\n-        } else if (number instanceof BigInteger) {\n-            digitList.set(isNegative, (BigInteger) number, maxDigits);\n+        switch (number) {\n+            case Double d -> digitList.set(isNegative, d, maxDigits, true);\n+            case BigDecimal bd -> digitList.set(isNegative, bd, maxDigits, true);\n+            case Long l -> digitList.set(isNegative, l, maxDigits);\n+            case BigInteger bi -> digitList.set(isNegative, bi, maxDigits);\n+            default -> throw new AssertionError(\n+                    String.format(\"DigitList does not support %s\", number.getClass().getName()));\n@@ -1782,1 +1808,1 @@\n-    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,\n+    private StringBuf subformat(StringBuf result, FieldDelegate delegate,\n@@ -1824,1 +1850,1 @@\n-    void subformatNumber(StringBuffer result, FieldDelegate delegate,\n+    void subformatNumber(StringBuf result, FieldDelegate delegate,\n@@ -2111,1 +2137,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n@@ -2382,2 +2408,2 @@\n-        \/\/ First character after the prefix was un-parseable, should\n-        \/\/ fail regardless if lenient or strict.\n+        \/\/ First character after the prefix was un-parseable or parsing integer\n+        \/\/ only with no integer portion. Should fail regardless if lenient or strict.\n@@ -2424,2 +2450,2 @@\n-            \/\/ If intPos is 0, the entire value was integer\n-            if (isParseIntegerOnly() && pos.intPos > 0) {\n+            \/\/ If intPos is -1, the entire value was integer and index should be full pos\n+            if (isParseIntegerOnly() && pos.intPos != -1) {\n@@ -2477,1 +2503,1 @@\n-        int intIndex = 0;\n+        int intIndex = -1;\n@@ -2573,0 +2599,4 @@\n+                    if (isParseIntegerOnly() && startPos == position) {\n+                        \/\/ Parsing int only with no integer portion, fail\n+                        return new NumericPosition(-1, intIndex);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":128,"deletions":98,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -42,1 +42,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DontCareFieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -302,1 +302,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/FieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,3 @@\n-     * Formats an object to produce a string. This is equivalent to\n+     * Formats an object to produce a string.\n+     *\n+     * @implSpec This method returns a string that would be equal to the string returned by\n@@ -156,1 +158,0 @@\n-     *\n@@ -163,1 +164,5 @@\n-        return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(obj, StringBufFactory.of(), new FieldPosition(0)).toString();\n+        } else {\n+            return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        }\n@@ -188,0 +193,6 @@\n+    StringBuf format(Object obj,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -199,4 +210,0 @@\n-     * <p>The default implementation creates an\n-     * {@code AttributedCharacterIterator} with no attributes. Subclasses\n-     * that support fields should override this and create an\n-     * {@code AttributedCharacterIterator} with meaningful attributes.\n@@ -204,0 +211,4 @@\n+     * @apiNote Subclasses that support fields should override this and create an\n+     * {@code AttributedCharacterIterator} with meaningful attributes.\n+     * @implSpec The default implementation creates an\n+     * {@code AttributedCharacterIterator} with no attributes.\n@@ -397,1 +408,1 @@\n-                              int end, StringBuffer buffer);\n+                              int end, StringBuf buffer);\n@@ -411,1 +422,33 @@\n-                              int start, int end, StringBuffer buffer);\n+                              int start, int end, StringBuf buffer);\n+    }\n+\n+    \/**\n+     * StringBuf is the minimal common interface of {@code StringBuffer} and {@code StringBuilder}.\n+     * It is used by the various {@code Format} implementations as the internal string buffer.\n+     *\/\n+    sealed interface StringBuf\n+            permits StringBufFactory.StringBufferImpl, StringBufFactory.StringBuilderImpl {\n+\n+        int length();\n+\n+        String substring(int start, int end);\n+\n+        String substring(int start);\n+\n+        StringBuf append(char c);\n+\n+        StringBuf append(String str);\n+\n+        StringBuf append(int i);\n+\n+        StringBuf append(char[] str, int offset, int len);\n+\n+        StringBuf append(CharSequence s, int start, int end);\n+\n+        StringBuf append(StringBuffer sb);\n+\n+        boolean isProxyStringBuilder();\n+\n+        StringBuffer asStringBuffer();\n+\n+        StringBuilder asStringBuilder();\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":53,"deletions":10,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-        return format(input, new StringBuffer(),\n+        return format(input, StringBufFactory.of(),\n@@ -384,0 +384,12 @@\n+        return format(obj, StringBufFactory.of(toAppendTo)).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(Object obj, StringBuf toAppendTo, FieldPosition pos) {\n+        Objects.requireNonNull(obj);\n+        Objects.requireNonNull(toAppendTo);\n+\n+        return format(obj, toAppendTo);\n+    }\n+\n+    private StringBuf format(Object obj, StringBuf toAppendTo) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n- * <p>\n+ *\n@@ -375,1 +375,0 @@\n- * <p>\n@@ -1030,1 +1029,1 @@\n-        return subformat(arguments, result, pos, null);\n+        return subformat(arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n@@ -1035,1 +1034,2 @@\n-     * to format the given arguments. This is equivalent to\n+     * to format the given arguments.\n+     * This method returns a string that would be equal to the string returned by\n@@ -1079,0 +1079,6 @@\n+        return subformat((Object[]) arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuf format(Object arguments, StringBuf result,\n+                           FieldPosition pos) {\n@@ -1119,1 +1125,1 @@\n-        StringBuffer result = new StringBuffer();\n+        StringBuf result = StringBufFactory.of();\n@@ -1475,1 +1481,1 @@\n-    private StringBuffer subformat(Object[] arguments, StringBuffer result,\n+    private StringBuf subformat(Object[] arguments, StringBuf result,\n@@ -1585,1 +1591,1 @@\n-     * {@code iterator} to the StringBuffer {@code result}.\n+     * {@code iterator} to the StringBuf {@code result}.\n@@ -1587,1 +1593,1 @@\n-    private void append(StringBuffer result, CharacterIterator iterator) {\n+    private void append(StringBuf result, CharacterIterator iterator) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -305,11 +305,28 @@\n-        if (number instanceof Long || number instanceof Integer ||\n-            number instanceof Short || number instanceof Byte ||\n-            number instanceof AtomicInteger || number instanceof AtomicLong ||\n-            (number instanceof BigInteger &&\n-             ((BigInteger)number).bitLength() < 64)) {\n-            return format(((Number)number).longValue(), toAppendTo, pos);\n-        } else if (number instanceof Number) {\n-            return format(((Number)number).doubleValue(), toAppendTo, pos);\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n-        }\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, pos);\n+            case Integer i -> format(i.longValue(), toAppendTo, pos);\n+            case Short s -> format(s.longValue(), toAppendTo, pos);\n+            case Byte b -> format(b.longValue(), toAppendTo, pos);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, pos);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, pos);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, pos);\n+            case Number n -> format(n.doubleValue(), toAppendTo, pos);\n+            case null, default -> throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        };\n+    }\n+\n+    @Override\n+    StringBuf format(Object number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, pos);\n+            case Integer i -> format(i.longValue(), toAppendTo, pos);\n+            case Short s -> format(s.longValue(), toAppendTo, pos);\n+            case Byte b -> format(b.longValue(), toAppendTo, pos);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, pos);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, pos);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, pos);\n+            case Number n -> format(n.doubleValue(), toAppendTo, pos);\n+            case null, default -> throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        };\n@@ -350,2 +367,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(number, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -370,2 +392,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(number, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -397,0 +424,6 @@\n+    StringBuf format(double number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -420,0 +453,6 @@\n+    StringBuf format(long number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":54,"deletions":15,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -626,1 +626,1 @@\n-        this.formatData = DateFormatSymbols.getInstanceRef(locale);\n+        formatData = DateFormatSymbols.getInstance(locale);\n@@ -647,1 +647,1 @@\n-        this.formatData = (DateFormatSymbols) formatSymbols.clone();\n+        formatData = (DateFormatSymbols) formatSymbols.clone();\n@@ -971,0 +971,7 @@\n+        return format(date, StringBufFactory.of(toAppendTo), pos.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuf format(Date date, StringBuf toAppendTo,\n+                           FieldPosition pos) {\n+        pos.beginIndex = pos.endIndex = 0;\n@@ -975,1 +982,1 @@\n-    private StringBuffer format(Date date, StringBuffer toAppendTo,\n+    private StringBuf format(Date date, StringBuf toAppendTo,\n@@ -1027,1 +1034,1 @@\n-        StringBuffer sb = new StringBuffer();\n+        StringBuf sb = StringBufFactory.of();\n@@ -1133,1 +1140,1 @@\n-                           FieldDelegate delegate, StringBuffer buffer,\n+                           FieldDelegate delegate, StringBuf buffer,\n@@ -1323,1 +1330,5 @@\n-            CalendarUtils.sprintf0d(buffer, num, width);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), num, width);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), num, width);\n+            }\n@@ -1343,1 +1354,5 @@\n-            CalendarUtils.sprintf0d(buffer, value \/ 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value \/ 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value \/ 60, 2);\n+            }\n@@ -1351,1 +1366,5 @@\n-            CalendarUtils.sprintf0d(buffer, value % 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value % 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value % 60, 2);\n+            }\n@@ -1385,1 +1404,1 @@\n-    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)\n+    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuf buffer)\n@@ -1428,1 +1447,11 @@\n-        numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);\n+        if (buffer.isProxyStringBuilder()) {\n+            \/\/User can set numberFormat with a user-defined NumberFormat which\n+            \/\/not override format(long, StringBuf, FieldPosition).\n+            if (\"java.text\".equals(numberFormat.getClass().getPackageName())) {\n+                numberFormat.format((long) value, buffer, DontCareFieldPosition.INSTANCE);\n+            } else {\n+                buffer.append(numberFormat.format((long) value, new StringBuffer(), DontCareFieldPosition.INSTANCE));\n+            }\n+        } else {\n+            numberFormat.format((long) value, buffer.asStringBuffer(), DontCareFieldPosition.INSTANCE);\n+        }\n@@ -2568,1 +2597,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.text;\n+\n+import java.text.Format.StringBuf;\n+\n+\/**\n+ * {@code StringBufFactory} creates implementations of {@code Format.StringBuf},\n+ * which is an interface with the minimum overlap required to support {@code StringBuffer}\n+ * and {@code StringBuilder} in {@code Format}. This allows for {@code StringBuilder} to be used\n+ * in place of {@code StringBuffer} to provide performance benefits for JDK internal\n+ * {@code Format} subclasses.\n+ *\/\n+final class StringBufFactory {\n+\n+    private StringBufFactory() {\n+    }\n+\n+    static StringBuf of(StringBuffer sb) {\n+        return new StringBufferImpl(sb);\n+    }\n+\n+    static StringBuf of(StringBuilder sb) {\n+        return new StringBuilderImpl(sb);\n+    }\n+\n+    static StringBuf of() {\n+        return new StringBuilderImpl();\n+    }\n+\n+    final static class StringBufferImpl implements StringBuf {\n+        private final StringBuffer sb;\n+\n+        StringBufferImpl(StringBuffer sb) {\n+            this.sb = sb;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(StringBuffer asb) {\n+            sb.append(asb);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return false;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            throw new AssertionError(\"Can't cast StringBuffer to StringBuilder\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+    final static class StringBuilderImpl implements StringBuf {\n+        private final StringBuilder sb;\n+\n+        StringBuilderImpl(StringBuilder sb) {\n+            this.sb = sb;\n+        }\n+\n+        StringBuilderImpl() {\n+            this.sb = new StringBuilder();\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(StringBuffer asb) {\n+            sb.append(asb);\n+            return this;\n+        }\n+\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return true;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            throw new AssertionError(\"Can't cast StringBuilder to StringBuffer\");\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/text\/StringBufFactory.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2151,0 +2151,10 @@\n+        var buf = new StringBuilder(10);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     * Requires extra capacity of 10 to avoid StringBuilder reallocation.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -2155,1 +2165,0 @@\n-        StringBuilder buf = new StringBuilder(10);\n@@ -2158,3 +2167,1 @@\n-                buf.append(yearValue - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(yearValue + 10000).deleteCharAt(0);\n+                buf.append('-');\n@@ -2162,0 +2169,2 @@\n+            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n+            buf.append(absYear);\n@@ -2168,5 +2177,4 @@\n-        return buf.append(monthValue < 10 ? \"-0\" : \"-\")\n-            .append(monthValue)\n-            .append(dayValue < 10 ? \"-0\" : \"-\")\n-            .append(dayValue)\n-            .toString();\n+        buf.append(monthValue < 10 ? \"-0\" : \"-\")\n+           .append(monthValue)\n+           .append(dayValue < 10 ? \"-0\" : \"-\")\n+           .append(dayValue);\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1969,1 +1969,5 @@\n-        return date.toString() + 'T' + time.toString();\n+        var buf = new StringBuilder(29);\n+        date.formatTo(buf);\n+        buf.append('T');\n+        time.formatTo(buf);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -1633,1 +1635,10 @@\n-        StringBuilder buf = new StringBuilder(18);\n+        var buf = new StringBuilder(18);\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     * Requires extra capacity of 18 to avoid StringBuilder reallocation.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1644,2 +1655,7 @@\n-                if (nanoValue % 1000_000 == 0) {\n-                    buf.append(Integer.toString((nanoValue \/ 1000_000) + 1000).substring(1));\n+                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n+                if (zeros > 0) {\n+                    buf.repeat('0', zeros);\n+                }\n+                int digits;\n+                if (nanoValue % 1_000_000 == 0) {\n+                    digits = nanoValue \/ 1_000_000;\n@@ -1647,1 +1663,1 @@\n-                    buf.append(Integer.toString((nanoValue \/ 1000) + 1000_000).substring(1));\n+                    digits = nanoValue \/ 1000;\n@@ -1649,1 +1665,1 @@\n-                    buf.append(Integer.toString((nanoValue) + 1000_000_000).substring(1));\n+                    digits = nanoValue;\n@@ -1651,0 +1667,1 @@\n+                buf.append(digits);\n@@ -1653,1 +1670,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -2911,18 +2913,0 @@\n-        \/*\n-         * Copied from Long.stringSize\n-         *\/\n-        private static int stringSize(long x) {\n-            int d = 1;\n-            if (x >= 0) {\n-                d = 0;\n-                x = -x;\n-            }\n-            long p = -10;\n-            for (int i = 1; i < 19; i++) {\n-                if (x > p)\n-                    return i + d;\n-                p = 10 * p;\n-            }\n-            return 19 + d;\n-        }\n-\n@@ -2937,1 +2921,1 @@\n-            int size = stringSize(value);\n+            int size = DecimalDigits.stringSize(value);\n@@ -2968,2 +2952,3 @@\n-            for (int i = 0; i < minWidth - size; i++) {\n-                buf.append(zeroDigit);\n+            int zeros = minWidth - size;\n+            if (zeros > 0) {\n+                buf.repeat(zeroDigit, zeros);\n@@ -3371,11 +3356,0 @@\n-        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n-        private static int stringSize(int x) {\n-            int p = 10;\n-            for (int i = 1; i < 10; i++) {\n-                if (x < p)\n-                    return i;\n-                p = 10 * p;\n-            }\n-            return 10;\n-        }\n-\n@@ -3402,1 +3376,1 @@\n-            int stringSize = stringSize(val);\n+            int stringSize = DecimalDigits.stringSize(val);\n@@ -3413,3 +3387,1 @@\n-                    for (int i = 0; i < width; i++) {\n-                        buf.append(zero);\n-                    }\n+                    buf.repeat(zero, width);\n@@ -3422,2 +3394,3 @@\n-                for (int i = 9 - stringSize; i > 0; i--) {\n-                    buf.append(zero);\n+                int zeros = 9 - stringSize;\n+                if (zeros > 0) {\n+                    buf.repeat(zero, zeros);\n@@ -3597,3 +3570,1 @@\n-                    for (int i = 0; i < minWidth; i++) {\n-                        buf.append(decimalStyle.getZeroDigit());\n-                    }\n+                    buf.repeat(decimalStyle.getZeroDigit(), minWidth);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":12,"deletions":41,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -161,1 +162,1 @@\n-            new HexFormat(\"\", \"\", \"\", Case.LOWERCASE);\n+            new HexFormat(\"\", \"\", \"\", false);\n@@ -164,1 +165,1 @@\n-            new HexFormat(\"\", \"\", \"\", Case.UPPERCASE);\n+            new HexFormat(\"\", \"\", \"\", true);\n@@ -171,6 +172,1 @@\n-    private final Case digitCase;\n-\n-    private enum Case {\n-        LOWERCASE,\n-        UPPERCASE\n-    }\n+    private final boolean ucase;\n@@ -184,1 +180,1 @@\n-     * @param digitCase enum indicating how to case digits\n+     * @param ucase enum indicating how to case digits\n@@ -187,1 +183,1 @@\n-    private HexFormat(String delimiter, String prefix, String suffix, Case digitCase) {\n+    private HexFormat(String delimiter, String prefix, String suffix, boolean ucase) {\n@@ -191,1 +187,1 @@\n-        this.digitCase = digitCase;\n+        this.ucase = ucase;\n@@ -220,1 +216,1 @@\n-        return new HexFormat(delimiter, \"\", \"\", Case.LOWERCASE);\n+        return new HexFormat(delimiter, \"\", \"\", false);\n@@ -229,1 +225,1 @@\n-        return new HexFormat(delimiter, this.prefix, this.suffix, this.digitCase);\n+        return new HexFormat(delimiter, this.prefix, this.suffix, this.ucase);\n@@ -239,1 +235,1 @@\n-        return new HexFormat(this.delimiter, prefix, this.suffix, this.digitCase);\n+        return new HexFormat(this.delimiter, prefix, this.suffix, this.ucase);\n@@ -249,1 +245,1 @@\n-        return new HexFormat(this.delimiter, this.prefix, suffix, this.digitCase);\n+        return new HexFormat(this.delimiter, this.prefix, suffix, this.ucase);\n@@ -261,1 +257,1 @@\n-        return new HexFormat(this.delimiter, this.prefix, this.suffix, Case.UPPERCASE);\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, true);\n@@ -271,1 +267,1 @@\n-        return new HexFormat(this.delimiter, this.prefix, this.suffix, Case.LOWERCASE);\n+        return new HexFormat(this.delimiter, this.prefix, this.suffix, false);\n@@ -309,1 +305,1 @@\n-        return digitCase == Case.UPPERCASE;\n+        return ucase;\n@@ -439,1 +435,0 @@\n-        boolean ucase = digitCase == Case.UPPERCASE;\n@@ -640,1 +635,1 @@\n-        if (digitCase == Case.LOWERCASE) {\n+        if (!ucase) {\n@@ -661,1 +656,1 @@\n-        if (digitCase == Case.LOWERCASE) {\n+        if (!ucase) {\n@@ -1070,1 +1065,1 @@\n-        return digitCase == otherHex.digitCase &&\n+        return ucase == otherHex.ucase &&\n@@ -1084,1 +1079,1 @@\n-        result = 31 * result + Boolean.hashCode(digitCase == Case.UPPERCASE);\n+        result = 31 * result + Boolean.hashCode(ucase);\n@@ -1096,1 +1091,1 @@\n-        return escapeNL(\"uppercase: \" + (digitCase == Case.UPPERCASE) +\n+        return escapeNL(\"uppercase: \" + ucase +\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-import jdk.internal.misc.VirtualThreads;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -179,1 +181,1 @@\n-                VirtualThreads.unpark(thread);\n+                JLA.unparkVirtualThread(thread);\n@@ -219,1 +221,1 @@\n-                VirtualThreads.park();\n+                JLA.parkVirtualThread();\n@@ -267,1 +269,1 @@\n-                    VirtualThreads.park(nanos);\n+                    JLA.parkVirtualThread(nanos);\n@@ -314,5 +316,1 @@\n-            if (t.isVirtual()) {\n-                VirtualThreads.parkUntil(deadline);\n-            } else {\n-                U.park(true, deadline);\n-            }\n+            parkUntil(deadline);\n@@ -369,1 +367,1 @@\n-            VirtualThreads.park();\n+            JLA.parkVirtualThread();\n@@ -408,1 +406,1 @@\n-                VirtualThreads.park(nanos);\n+                JLA.parkVirtualThread(nanos);\n@@ -447,1 +445,2 @@\n-            VirtualThreads.parkUntil(deadline);\n+            long millis = deadline - System.currentTimeMillis();\n+            JLA.parkVirtualThread(TimeUnit.MILLISECONDS.toNanos(millis));\n@@ -465,0 +464,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/LockSupport.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,6 +812,5 @@\n-     * @implSpec The default implementation checks that {@code bound} is a\n-     * positive {@code int}. Then invokes {@code nextInt()}, limiting the result\n-     * to be greater than or equal zero and less than {@code bound}. If {@code bound}\n-     * is a power of two then limiting is a simple masking operation. Otherwise,\n-     * the result is re-calculated by invoking {@code nextInt()} until the\n-     * result is greater than or equal zero and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code bound} is positive.\n+     * It then invokes {@link #nextInt()} one or more times to ensure a uniform\n+     * distribution in the range 0 (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextInt()} to be uniform.\n@@ -838,7 +837,6 @@\n-     * @implSpec The default implementation checks that {@code origin} and\n-     * {@code bound} are positive {@code ints}. Then invokes {@code nextInt()},\n-     * limiting the result to be greater that or equal {@code origin} and less\n-     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n-     * simple masking operation. Otherwise, the result is re-calculated  by\n-     * invoking {@code nextInt()} until the result is greater than or equal\n-     * {@code origin} and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code origin}\n+     * is less than {@code bound}.\n+     * It then invokes {@link #nextInt()} one or more times to ensure a uniform\n+     * distribution in the range {@code origin} (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextInt()} to be uniform.\n@@ -871,7 +869,5 @@\n-     * @implSpec The default implementation checks that {@code bound} is a\n-     * positive  {@code long}. Then invokes {@code nextLong()}, limiting the\n-     * result to be greater than or equal zero and less than {@code bound}. If\n-     * {@code bound} is a power of two then limiting is a simple masking\n-     * operation. Otherwise, the result is re-calculated by invoking\n-     * {@code nextLong()} until the result is greater than or equal zero and\n-     * less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code bound} is positive.\n+     * It then invokes {@link #nextLong()} one or more times to ensure a uniform\n+     * distribution in the range 0 (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextLong()} to be uniform.\n@@ -898,7 +894,6 @@\n-     * @implSpec The default implementation checks that {@code origin} and\n-     * {@code bound} are positive {@code longs}. Then invokes {@code nextLong()},\n-     * limiting the result to be greater than or equal {@code origin} and less\n-     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n-     * simple masking operation. Otherwise, the result is re-calculated by\n-     * invoking {@code nextLong()} until the result is greater than or equal\n-     * {@code origin} and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code origin}\n+     * is less than {@code bound}.\n+     * It then invokes {@link #nextLong()} one or more times to ensure a uniform\n+     * distribution in the range {@code origin} (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextLong()} to be uniform.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-    static final int  ZIP64_EXTID  = 0x0001;       \/\/ Extra field Zip64 header ID\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipConstants64.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1327,1 +1327,1 @@\n-                if (tag == ZIP64_EXTID) {\n+                if (tag == EXTID_ZIP64) {\n@@ -1363,1 +1363,1 @@\n-            \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+            \/\/ if EXTID_ZIP64 blocksize == 0, which may occur with some older\n@@ -1371,1 +1371,1 @@\n-                \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+                \/\/ Only validate the EXTID_ZIP64 data if the block size > 0\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-                if (id == ZIP64_EXTID) {\n+                if (id == EXTID_ZIP64) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-            writeShort(ZIP64_EXTID);\n+            writeShort(EXTID_ZIP64);\n@@ -646,1 +646,1 @@\n-            writeShort(ZIP64_EXTID);\/\/ Zip64 extra\n+            writeShort(EXTID_ZIP64);\/\/ Zip64 extra\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n- * <p><b><a id=\"sm-allowed\">These methods behave differently depending on\n+ * <p id=\"sm-allowed\"><b>These methods behave differently depending on\n@@ -113,1 +113,1 @@\n- * <a href=\"..\/..\/..\/java\/lang\/SecurityManager.html#set-security-manager\">allowed or disallowed<\/a><\/a><\/b>:\n+ * {@linkplain SecurityManager##set-security-manager allowed or disallowed}<\/b>:\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import java.util.concurrent.Callable;\n@@ -436,6 +435,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\/\n-    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n-\n@@ -469,2 +462,0 @@\n-    int stringSize(long i);\n-\n@@ -514,5 +505,0 @@\n-    \/**\n-     * Executes the given value returning task on the current carrier thread.\n-     *\/\n-    <V> V executeOnCarrierThread(Callable<V> task) throws Exception;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-            attr.defaultValue().writeTo(buf);\n+            AnnotationReader.writeAnnotationValue((BufWriterImpl) buf, attr.defaultValue());\n@@ -122,1 +122,5 @@\n-            buf.writeList(attr.bootstrapMethods());\n+            var b = (BufWriterImpl) buf;\n+            b.writeU2(attr.bootstrapMethodsSize());\n+            for (var bsm : attr.bootstrapMethods()) {\n+                ((BootstrapMethodEntryImpl) bsm).writeTo(b);\n+            }\n@@ -257,1 +261,1 @@\n-            buf.writeListIndices(attr.exceptions());\n+            Util.writeListIndices(buf, attr.exceptions());\n@@ -323,1 +327,1 @@\n-            buf.writeListIndices(attr.loadableDescriptors());\n+            Util.writeListIndices(buf, attr.loadableDescriptors());\n@@ -429,1 +433,1 @@\n-                buf.writeListIndices(export.exportsTo());\n+                Util.writeListIndices(buf, export.exportsTo());\n@@ -435,1 +439,1 @@\n-                buf.writeListIndices(open.opensTo());\n+                Util.writeListIndices(buf, open.opensTo());\n@@ -437,1 +441,1 @@\n-            buf.writeListIndices(attr.uses());\n+            Util.writeListIndices(buf, attr.uses());\n@@ -441,1 +445,1 @@\n-                buf.writeListIndices(provide.providesWith());\n+                Util.writeListIndices(buf, provide.providesWith());\n@@ -503,1 +507,1 @@\n-            buf.writeListIndices(attr.packages());\n+            Util.writeListIndices(buf, attr.packages());\n@@ -575,1 +579,1 @@\n-            buf.writeListIndices(attr.nestMembers());\n+            Util.writeListIndices(buf, attr.nestMembers());\n@@ -593,1 +597,1 @@\n-            buf.writeListIndices(attr.permittedSubclasses());\n+            Util.writeListIndices(buf, attr.permittedSubclasses());\n@@ -616,1 +620,1 @@\n-                buf.writeList(info.attributes());\n+                Util.writeAttributes((BufWriterImpl) buf, info.attributes());\n@@ -635,1 +639,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -656,1 +660,1 @@\n-                buf.writeList(list);\n+                AnnotationReader.writeAnnotations(buf, list);\n@@ -674,1 +678,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -692,1 +696,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n@@ -713,1 +717,1 @@\n-                buf.writeList(list);\n+                AnnotationReader.writeAnnotations(buf, list);\n@@ -731,1 +735,1 @@\n-            buf.writeList(attr.annotations());\n+            AnnotationReader.writeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -32,1 +31,1 @@\n-        extends AbstractElement {\n+        extends AbstractElement implements Util.WritableLocalVariable {\n@@ -83,2 +82,3 @@\n-    public boolean writeTo(BufWriter b) {\n-        var lc = ((BufWriterImpl)b).labelContext();\n+    @Override\n+    public boolean writeLocalTo(BufWriterImpl b) {\n+        var lc = b.labelContext();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.util.Optional;\n-\n@@ -30,0 +28,1 @@\n+import java.lang.classfile.constantpool.ConstantPool;\n@@ -46,2 +45,2 @@\n-    public Optional<M> original() {\n-        return Optional.ofNullable(original);\n+    public boolean canWriteDirect(ConstantPool source) {\n+        return constantPool().canWriteDirect(source);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-            if (high < low || high - low > code.codeLength >> 2) {\n+            if (high < low || (long)high - low > code.codeLength >> 2) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -71,1 +70,1 @@\n-    private static final int INT_PHI = 0x9E3779B9;\n+    static final int NON_ZERO = 0x40000000;\n@@ -74,1 +73,1 @@\n-        return phiMix(tag * TAG_SMEAR + x1);\n+        return (tag * TAG_SMEAR + x1) | NON_ZERO;\n@@ -78,1 +77,1 @@\n-        return phiMix(tag * TAG_SMEAR + x1 + 31*x2);\n+        return (tag * TAG_SMEAR + x1 + 31 * x2) | NON_ZERO;\n@@ -83,6 +82,1 @@\n-        return phiMix(stringHash | (1 << 30));\n-    }\n-\n-    public static int phiMix(int x) {\n-        int h = x * INT_PHI;\n-        return h ^ (h >> 16);\n+        return stringHash | NON_ZERO;\n@@ -131,0 +125,2 @@\n+    abstract void writeTo(BufWriterImpl buf);\n+\n@@ -415,1 +411,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -486,1 +482,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -516,1 +512,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -822,1 +818,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -927,1 +923,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -1077,1 +1073,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -1110,1 +1106,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -1142,1 +1138,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n@@ -1174,1 +1170,1 @@\n-        public void writeTo(BufWriter pool) {\n+        void writeTo(BufWriterImpl pool) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,2 @@\n-    private abstract static sealed class AbstractLocalPseudo extends AbstractPseudoInstruction {\n+    private abstract static sealed class AbstractLocalPseudo extends AbstractPseudoInstruction\n+            implements Util.WritableLocalVariable {\n@@ -192,2 +193,3 @@\n-        public boolean writeTo(BufWriter b) {\n-            var lc = ((BufWriterImpl)b).labelContext();\n+        @Override\n+        public boolean writeLocalTo(BufWriterImpl b) {\n+            var lc = b.labelContext();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Collections;\n@@ -40,1 +41,1 @@\n-    private final List<E> elements;\n+    final List<E> elements;\n@@ -44,1 +45,1 @@\n-        this.elements = elements;\n+        this.elements = Collections.unmodifiableList(elements);\n@@ -48,1 +49,1 @@\n-    public void forEachElement(Consumer<E> consumer) {\n+    public void forEach(Consumer<? super E> consumer) {\n@@ -66,2 +67,5 @@\n-                                 .filter(e -> e instanceof Attribute)\n-                                 .<Attribute<?>>map(e -> (Attribute<?>) e)\n+                                 .<Attribute<?>>mapMulti((e, sink) -> {\n+                                     if (e instanceof Attribute<?> attr) {\n+                                         sink.accept(attr);\n+                                     }\n+                                 })\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractUnboundModel.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,13 +35,4 @@\n-public final class AnnotationImpl implements Annotation {\n-    private final Utf8Entry className;\n-    private final List<AnnotationElement> elements;\n-\n-    public AnnotationImpl(Utf8Entry className,\n-                          List<AnnotationElement> elems) {\n-        this.className = className;\n-        this.elements = List.copyOf(elems);\n-    }\n-\n-    @Override\n-    public Utf8Entry className() {\n-        return className;\n+public record AnnotationImpl(Utf8Entry className, List<AnnotationElement> elements)\n+        implements Annotation, Util.Writable {\n+    public AnnotationImpl {\n+        elements = List.copyOf(elements);\n@@ -51,6 +42,1 @@\n-    public List<AnnotationElement> elements() {\n-        return elements;\n-    }\n-\n-    @Override\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -58,1 +44,5 @@\n-        buf.writeList(elements());\n+        buf.writeU2(elements().size());\n+        for (var e : elements) {\n+            buf.writeIndex(e.name());\n+            AnnotationReader.writeAnnotationValue(buf, e.value());\n+        }\n@@ -84,1 +74,1 @@\n-            implements AnnotationElement {\n+            implements AnnotationElement, Util.Writable {\n@@ -87,1 +77,1 @@\n-        public void writeTo(BufWriter buf) {\n+        public void writeTo(BufWriterImpl buf) {\n@@ -89,1 +79,1 @@\n-            value().writeTo(buf);\n+            AnnotationReader.writeAnnotationValue(buf, value());\n@@ -93,1 +83,1 @@\n-    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant\n+    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable\n@@ -101,1 +91,1 @@\n-        default void writeTo(BufWriter buf) {\n+        default void writeTo(BufWriterImpl buf) {\n@@ -240,1 +230,1 @@\n-            implements AnnotationValue.OfArray {\n+            implements AnnotationValue.OfArray, Util.Writable {\n@@ -252,1 +242,1 @@\n-        public void writeTo(BufWriter buf) {\n+        public void writeTo(BufWriterImpl buf) {\n@@ -254,1 +244,4 @@\n-            buf.writeList(values);\n+            buf.writeU2(values.size());\n+            for (var e : values) {\n+                AnnotationReader.writeAnnotationValue(buf, e);\n+            }\n@@ -260,1 +253,1 @@\n-            implements AnnotationValue.OfEnum {\n+            implements AnnotationValue.OfEnum, Util.Writable {\n@@ -267,1 +260,1 @@\n-        public void writeTo(BufWriter buf) {\n+        public void writeTo(BufWriterImpl buf) {\n@@ -276,1 +269,1 @@\n-            implements AnnotationValue.OfAnnotation {\n+            implements AnnotationValue.OfAnnotation, Util.Writable {\n@@ -283,1 +276,1 @@\n-        public void writeTo(BufWriter buf) {\n+        public void writeTo(BufWriterImpl buf) {\n@@ -285,1 +278,1 @@\n-            annotation.writeTo(buf);\n+            AnnotationReader.writeAnnotation(buf, annotation);\n@@ -291,1 +284,1 @@\n-            implements AnnotationValue.OfClass {\n+            implements AnnotationValue.OfClass, Util.Writable {\n@@ -298,1 +291,1 @@\n-        public void writeTo(BufWriter buf) {\n+        public void writeTo(BufWriterImpl buf) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":29,"deletions":36,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.classfile.BufWriter;\n@@ -42,1 +43,1 @@\n-class AnnotationReader {\n+public final class AnnotationReader {\n@@ -283,0 +284,20 @@\n+\n+    public static void writeAnnotation(BufWriterImpl buf, Annotation annotation) {\n+        \/\/ handles annotations and type annotations\n+        \/\/ TODO annotation cleanup later\n+        ((Util.Writable) annotation).writeTo(buf);\n+    }\n+\n+    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n+        \/\/ handles annotations and type annotations\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n+    public static void writeAnnotationValue(BufWriterImpl buf, AnnotationValue value) {\n+        \/\/ TODO annotation cleanup later\n+        ((Util.Writable) value).writeTo(buf);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -53,4 +52,2 @@\n-    public void writeTo(BufWriter buf) {\n-        buf.writeU2(attributes.size());\n-        for (Attribute<?> a : attributes)\n-            a.writeTo(buf);\n+    public void writeTo(BufWriterImpl buf) {\n+        Util.writeAttributes(buf, attributes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -79,3 +78,1 @@\n-        int hash = handle.hashCode();\n-        hash = 31 * hash + arguments.hashCode();\n-        return AbstractPoolEntry.phiMix(hash);\n+        return (31 * handle.hashCode() + arguments.hashCode()) | AbstractPoolEntry.NON_ZERO;\n@@ -92,2 +89,1 @@\n-    @Override\n-    public void writeTo(BufWriter writer) {\n+    void writeTo(BufWriterImpl writer) {\n@@ -95,1 +91,1 @@\n-        writer.writeListIndices(arguments());\n+        Util.writeListIndices(writer, arguments());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-\n@@ -43,0 +37,1 @@\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -44,0 +39,7 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n@@ -50,1 +52,1 @@\n-        implements Attribute<T> {\n+        implements Attribute<T>, Util.Writable {\n@@ -103,1 +105,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -119,1 +121,1 @@\n-    <E> List<E> readEntryList(int p) {\n+    <E extends PoolEntry> List<E> readEntryList(int p, Class<E> type) {\n@@ -125,1 +127,1 @@\n-            entries[i] = classReader.readEntry(p);\n+            entries[i] = classReader.readEntry(p, type);\n@@ -136,1 +138,0 @@\n-        var apo = ((ClassReaderImpl)reader).context().attributesProcessingOption();\n@@ -150,1 +151,1 @@\n-                filled.add((Attribute)mapper.readAttribute(enclosing, reader, p));\n+                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n@@ -288,1 +289,5 @@\n-            codeAttribute = (CodeImpl) enclosing;\n+            if (enclosing instanceof CodeImpl ci) {\n+                this.codeAttribute = ci;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid LocalVariableTable attribute location\");\n+            }\n@@ -315,1 +320,5 @@\n-            this.codeAttribute = (CodeImpl) enclosing;\n+            if (enclosing instanceof CodeImpl ci) {\n+                this.codeAttribute = ci;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid LocalVariableTypeTable attribute location\");\n+            }\n@@ -552,1 +561,1 @@\n-                exceptions = readEntryList(payloadStart);\n+                exceptions = readEntryList(payloadStart, ClassEntry.class);\n@@ -648,1 +657,1 @@\n-                    List<ModuleEntry> exportsTo = readEntryList(p);\n+                    List<ModuleEntry> exportsTo = readEntryList(p, ModuleEntry.class);\n@@ -663,1 +672,1 @@\n-                    List<ModuleEntry> opensTo = readEntryList(p);\n+                    List<ModuleEntry> opensTo = readEntryList(p, ModuleEntry.class);\n@@ -671,1 +680,1 @@\n-                uses = readEntryList(p);\n+                uses = readEntryList(p, ClassEntry.class);\n@@ -680,1 +689,1 @@\n-                    List<ClassEntry> providesWith = readEntryList(p);\n+                    List<ClassEntry> providesWith = readEntryList(p, ClassEntry.class);\n@@ -700,1 +709,1 @@\n-                packages = readEntryList(payloadStart);\n+                packages = readEntryList(payloadStart, PackageEntry.class);\n@@ -718,1 +727,1 @@\n-                members = readEntryList(payloadStart);\n+                members = readEntryList(payloadStart, ClassEntry.class);\n@@ -747,1 +756,1 @@\n-                    final List<LoadableConstantEntry> args = readEntryList(p + 2);\n+                    final List<LoadableConstantEntry> args = readEntryList(p + 2, LoadableConstantEntry.class);\n@@ -927,1 +936,1 @@\n-                permittedSubclasses = readEntryList(payloadStart);\n+                permittedSubclasses = readEntryList(payloadStart, ClassEntry.class);\n@@ -944,1 +953,1 @@\n-                loadableDescriptors = readEntryList(payloadStart);\n+                loadableDescriptors = readEntryList(payloadStart, Utf8Entry.class);\n@@ -1007,1 +1016,1 @@\n-            case 0x78147009 ->\n+            case 0x46699ff2 ->\n@@ -1009,1 +1018,1 @@\n-            case 0x665e3a3a ->\n+            case 0x5208e184 ->\n@@ -1011,1 +1020,1 @@\n-            case 0xcb7e162 ->\n+            case 0xcb60907a ->\n@@ -1013,1 +1022,1 @@\n-            case 0x21e41e7e ->\n+            case 0x4020220d ->\n@@ -1015,1 +1024,1 @@\n-            case 0x5a306b41 ->\n+            case 0xc20dd1fe ->\n@@ -1017,1 +1026,1 @@\n-            case 0x3e191c7c ->\n+            case 0xcab1940d ->\n@@ -1019,1 +1028,1 @@\n-            case 0x5e88ed0c ->\n+            case 0x558641d3 ->\n@@ -1021,1 +1030,1 @@\n-            case 0x7284695e ->\n+            case 0x51d443cd ->\n@@ -1023,1 +1032,1 @@\n-            case 0x21df25db ->\n+            case 0x687c1624 ->\n@@ -1025,1 +1034,1 @@\n-            case 0x11392da9 ->\n+            case 0x7adb2910 ->\n@@ -1027,1 +1036,1 @@\n-            case 0x167536fc ->\n+            case 0x653f0551 ->\n@@ -1029,1 +1038,1 @@\n-            case 0x4d56b212 ->\n+           case 0x5f348b64 ->\n@@ -1031,1 +1040,1 @@\n-            case 0x46939abc ->\n+            case 0x64c75927 ->\n@@ -1033,1 +1042,1 @@\n-            case 0x63ee67f4 ->\n+            case 0x6697f98d ->\n@@ -1035,1 +1044,1 @@\n-            case 0x2b597e15 ->\n+            case 0xdbb0cdcb ->\n@@ -1037,1 +1046,1 @@\n-            case 0x19f20ade ->\n+            case 0xc9b0928c ->\n@@ -1039,1 +1048,1 @@\n-            case 0x47f6395e ->\n+            case 0x41cd27e8 ->\n@@ -1041,1 +1050,1 @@\n-            case 0x54db809 ->\n+            case 0x7deb0a13 ->\n@@ -1043,1 +1052,1 @@\n-            case 0x1abd1c2c ->\n+            case 0x6706ff99 ->\n@@ -1045,1 +1054,1 @@\n-            case 0x6ba46dd ->\n+            case 0x60272858 ->\n@@ -1047,1 +1056,1 @@\n-            case 0x46f7d91d ->\n+            case 0x5646d73d ->\n@@ -1049,1 +1058,1 @@\n-            case 0x5137f53 ->\n+            case 0x50336c40 ->\n@@ -1051,1 +1060,1 @@\n-            case 0x4a8fa3b6 ->\n+            case 0x4735ab81 ->\n@@ -1053,1 +1062,1 @@\n-            case 0x55c73cb6 ->\n+            case 0x7100d9fe ->\n@@ -1055,1 +1064,1 @@\n-            case 0x3fe76d4e ->\n+            case 0xd1ab5871 ->\n@@ -1057,1 +1066,1 @@\n-            case 0x180d6925 ->\n+            case 0x7588550f ->\n@@ -1059,1 +1068,1 @@\n-            case 0x7be22752 ->\n+            case 0xcc74da30 ->\n@@ -1061,1 +1070,1 @@\n-            case 0x5299824 ->\n+            case 0xf67697f5 ->\n@@ -1063,1 +1072,1 @@\n-            case 0x3534786e ->\n+            case 0xe0837d2a ->\n@@ -1065,1 +1074,1 @@\n-            case 0xb4b4ac6 ->\n+            case 0xc945a075 ->\n@@ -1067,1 +1076,1 @@\n-            case 0x6926482 ->\n+            case 0x611a3a90 ->\n@@ -1069,1 +1078,1 @@\n-            case 0x16a42b7c ->\n+            case 0xf76fb898 ->\n@@ -1071,1 +1080,1 @@\n-            case 0x400ab245 ->\n+            case 0x6b41b047 ->\n@@ -1073,1 +1082,1 @@\n-            case 0x2af490d4 ->\n+            case 0x748c2857 ->\n@@ -1075,1 +1084,1 @@\n-            case 0x303e0c58 ->\n+            case 0x6bf13a96 ->\n@@ -1077,1 +1086,1 @@\n-            case 0x19c7d0cd ->\n+            case 0xfa85ee5a ->\n@@ -1079,1 +1088,1 @@\n-            case 0x3dc79b7a ->\n+            case 0xf2670725 ->\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":70,"deletions":61,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -129,4 +127,2 @@\n-    @Override\n-    public void writeBytes(BufWriter other) {\n-        BufWriterImpl o = (BufWriterImpl) other;\n-        writeBytes(o.elems, 0, o.offset);\n+    public void writeBytes(BufWriterImpl other) {\n+        writeBytes(other.elems, 0, other.offset);\n@@ -178,1 +174,0 @@\n-    @Override\n@@ -201,16 +196,0 @@\n-\n-    @Override\n-    public<T extends WritableElement<?>> void writeList(List<T> list) {\n-        writeU2(list.size());\n-        for (T t : list) {\n-            t.writeTo(this);\n-        }\n-    }\n-\n-    @Override\n-    public void writeListIndices(List<? extends PoolEntry> list) {\n-        writeU2(list.size());\n-        for (PoolEntry info : list) {\n-            writeIndex(info);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -36,3 +35,0 @@\n-import java.lang.classfile.instruction.IncrementInstruction;\n-import java.lang.classfile.instruction.LoadInstruction;\n-import java.lang.classfile.instruction.StoreInstruction;\n@@ -51,1 +47,0 @@\n-    private final CodeModel original;\n@@ -64,1 +59,0 @@\n-        this.original = original;\n@@ -66,4 +60,1 @@\n-        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n-        if (original != null)\n-            this.maxLocals = Math.max(this.maxLocals, original.maxLocals());\n-\n+        this.maxLocals = TerminalCodeBuilder.setupTopLocal(methodInfo, original);\n@@ -73,5 +64,0 @@\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return Optional.ofNullable(original);\n-    }\n-\n@@ -165,1 +151,1 @@\n-            super(elements);\n+            super(BufferedCodeBuilder.this.elements);\n@@ -171,2 +157,5 @@\n-                           .filter(x -> x instanceof ExceptionCatch)\n-                           .map(x -> (ExceptionCatch) x)\n+                           .<ExceptionCatch>mapMulti((x, sink) -> {\n+                               if (x instanceof ExceptionCatch ec) {\n+                                   sink.accept(ec);\n+                               }\n+                           })\n@@ -176,16 +165,2 @@\n-        @Override\n-        public int maxLocals() {\n-            for (CodeElement element : elements) {\n-                if (element instanceof LoadInstruction i)\n-                    maxLocals = Math.max(maxLocals, i.slot() + i.typeKind().slotSize());\n-                else if (element instanceof StoreInstruction i)\n-                    maxLocals = Math.max(maxLocals, i.slot() + i.typeKind().slotSize());\n-                else if (element instanceof IncrementInstruction i)\n-                    maxLocals = Math.max(maxLocals, i.slot() + 1);\n-            }\n-            return maxLocals;\n-        }\n-\n-        @Override\n-        public int maxStack() {\n-            throw new UnsupportedOperationException(\"nyi\");\n+        int curTopLocal() {\n+            return BufferedCodeBuilder.this.curTopLocal();\n@@ -204,1 +179,1 @@\n-                    forEachElement(cb);\n+                    forEach(cb);\n@@ -209,4 +184,0 @@\n-        public void writeTo(BufWriter buf) {\n-            DirectCodeBuilder.build(methodInfo, cb -> elements.forEach(cb), constantPool, context, null).writeTo(buf);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":10,"deletions":39,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -44,1 +45,0 @@\n-    private final FieldModel original;\n@@ -49,2 +49,1 @@\n-                                Utf8Entry type,\n-                                FieldModel original) {\n+                                Utf8Entry type) {\n@@ -55,2 +54,1 @@\n-        this.flags = AccessFlags.ofField();\n-        this.original = original;\n+        this.flags = new AccessFlagsImpl(AccessFlag.Location.FIELD);\n@@ -64,5 +62,0 @@\n-    @Override\n-    public Optional<FieldModel> original() {\n-        return Optional.ofNullable(original);\n-    }\n-\n@@ -89,1 +82,1 @@\n-            super(elements);\n+            super(BufferedFieldBuilder.this.elements);\n@@ -94,2 +87,1 @@\n-            FieldModel fm = original().orElse(null);\n-            return fm == null? Optional.empty() : fm.parent();\n+            return Optional.empty();\n@@ -115,1 +107,1 @@\n-            builder.withField(name, desc, new Consumer<FieldBuilder>() {\n+            builder.withField(name, desc, new Consumer<>() {\n@@ -123,7 +115,0 @@\n-        @Override\n-        public void writeTo(BufWriter buf) {\n-            DirectFieldBuilder fb = new DirectFieldBuilder(constantPool, context, name, desc, null);\n-            elements.forEach(fb);\n-            fb.writeTo(buf);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -35,1 +36,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -47,1 +47,1 @@\n-        implements TerminalMethodBuilder, MethodInfo {\n+        implements TerminalMethodBuilder {\n@@ -62,0 +62,1 @@\n+                                 int flags,\n@@ -68,1 +69,1 @@\n-        this.flags = AccessFlags.ofMethod();\n+        this.flags = new AccessFlagsImpl(AccessFlag.Location.METHOD, flags);\n@@ -75,1 +76,1 @@\n-        if (element instanceof AccessFlags f) this.flags = f;\n+        if (element instanceof AccessFlags f) this.flags = checkFlags(f);\n@@ -79,3 +80,6 @@\n-    @Override\n-    public ConstantPoolBuilder constantPool() {\n-        return constantPool;\n+    private AccessFlags checkFlags(AccessFlags updated) {\n+        boolean wasStatic = updated.has(AccessFlag.STATIC);\n+        boolean isStatic = flags.has(AccessFlag.STATIC);\n+        if (wasStatic != isStatic)\n+            throw new IllegalArgumentException(\"Cannot change ACC_STATIC flag of method\");\n+        return updated;\n@@ -85,2 +89,2 @@\n-    public Optional<MethodModel> original() {\n-        return Optional.ofNullable(original);\n+    public ConstantPoolBuilder constantPool() {\n+        return constantPool;\n@@ -155,1 +159,1 @@\n-            super(elements);\n+            super(BufferedMethodBuilder.this.elements);\n@@ -165,1 +169,1 @@\n-            return original().flatMap(MethodModel::parent);\n+            return Optional.empty();\n@@ -195,1 +199,5 @@\n-            throw new UnsupportedOperationException(\"nyi\");\n+            return elements.stream().<CodeModel>mapMulti((e, sink) -> {\n+                if (e instanceof CodeModel cm) {\n+                    sink.accept(cm);\n+                }\n+            }).findFirst();\n@@ -203,1 +211,1 @@\n-                    forEachElement(mb);\n+                    forEach(mb);\n@@ -208,7 +216,0 @@\n-        @Override\n-        public void writeTo(BufWriter buf) {\n-            DirectMethodBuilder mb = new DirectMethodBuilder(constantPool, context, name, desc, methodFlags(), null);\n-            elements.forEach(mb);\n-            mb.writeTo(buf);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Optional;\n@@ -54,5 +53,0 @@\n-    @Override\n-    public Optional<ClassModel> original() {\n-        return terminal.original();\n-    }\n-\n@@ -62,1 +56,1 @@\n-                                                        name, descriptor, null)\n+                                                        name, descriptor)\n@@ -71,2 +65,1 @@\n-                                                                field.fieldName(), field.fieldType(),\n-                                                                field);\n+                                                                field.fieldName(), field.fieldType());\n@@ -82,1 +75,1 @@\n-                                                         name, descriptor, null)\n+                                                         name, descriptor, flags, null)\n@@ -91,1 +84,1 @@\n-                                                                  method.methodName(), method.methodType(), method);\n+                                                                  method.methodName(), method.methodType(), method.flags().flagsMask(), method);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.Optional;\n@@ -32,1 +31,0 @@\n-import java.lang.classfile.FieldModel;\n@@ -53,5 +51,0 @@\n-    @Override\n-    public Optional<FieldModel> original() {\n-        return terminal.original();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedFieldBuilder.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Optional;\n@@ -35,1 +34,0 @@\n-import java.lang.classfile.MethodModel;\n@@ -78,5 +76,0 @@\n-    @Override\n-    public Optional<MethodModel> original() {\n-        return terminal.original();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -135,1 +135,5 @@\n-        return VerifierImpl.verify(model, classHierarchyResolverOption().classHierarchyResolver(), null);\n+        try {\n+            return VerifierImpl.verify(model, classHierarchyResolverOption().classHierarchyResolver(), null);\n+        } catch (IllegalArgumentException verifierInitializationError) {\n+            return List.of(new VerifyError(verifierInitializationError.getMessage()));\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return AccessFlags.ofClass(reader.flags());\n+        return new AccessFlagsImpl(AccessFlag.Location.CLASS, reader.flags());\n@@ -159,1 +159,1 @@\n-    public void forEachElement(Consumer<ClassElement> consumer) {\n+    public void forEach(Consumer<? super ClassElement> consumer) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-    boolean writeBootstrapMethods(BufWriter buf) {\n+    boolean writeBootstrapMethods(BufWriterImpl buf) {\n@@ -329,1 +329,2 @@\n-        a.get().writeTo(buf);\n+        \/\/ BootstrapMethodAttribute implementations are all internal writable\n+        ((Util.Writable) a.get()).writeTo(buf);\n@@ -468,2 +469,1 @@\n-    @Override\n-    public boolean compare(BufWriter bufWriter,\n+    public boolean compare(BufWriterImpl bufWriter,\n@@ -474,1 +474,1 @@\n-            return Arrays.equals(((BufWriterImpl) bufWriter).elems,\n+            return Arrays.equals(bufWriter.elems,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-                        fm.fieldTypeSymbol()), fb ->\n-                                fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+                        fm.fieldTypeSymbol()), fb -> fb.transform(fm, asFieldTransform()));\n@@ -105,2 +104,1 @@\n-                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n-                                mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb -> mb.transform(mm, asMethodTransform()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -45,1 +46,1 @@\n-        implements CodeModel, LabelContext {\n+        implements LabelContext {\n@@ -143,1 +144,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -152,1 +153,1 @@\n-                                            forEachElement(cb);\n+                                            forEach(cb);\n@@ -156,1 +157,1 @@\n-                                    ((BufWriterImpl)buf).context(),\n+                                    buf.context(),\n@@ -169,1 +170,2 @@\n-    public void forEachElement(Consumer<CodeElement> consumer) {\n+    public void forEach(Consumer<? super CodeElement> consumer) {\n+        Objects.requireNonNull(consumer);\n@@ -211,1 +213,1 @@\n-    public boolean compareCodeBytes(BufWriter buf, int offset, int len) {\n+    public boolean compareCodeBytes(BufWriterImpl buf, int offset, int len) {\n@@ -332,1 +334,1 @@\n-    private void generateCatchTargets(Consumer<CodeElement> consumer) {\n+    private void generateCatchTargets(Consumer<? super CodeElement> consumer) {\n@@ -346,1 +348,1 @@\n-    private void generateDebugElements(Consumer<CodeElement> consumer) {\n+    private void generateDebugElements(Consumer<? super CodeElement> consumer) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -47,1 +46,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -55,2 +53,2 @@\n-    private final List<WritableElement<FieldModel>> fields = new ArrayList<>();\n-    private final List<WritableElement<MethodModel>> methods = new ArrayList<>();\n+    private final List<Util.Writable> fields = new ArrayList<>();\n+    private final List<Util.Writable> methods = new ArrayList<>();\n@@ -81,1 +79,1 @@\n-            writeAttribute((CustomAttribute)element);\n+            writeAttribute((CustomAttribute<?>) element);\n@@ -123,1 +121,1 @@\n-    public ClassBuilder withField(WritableElement<FieldModel> field) {\n+    ClassBuilder withField(Util.Writable field) {\n@@ -128,1 +126,1 @@\n-    public ClassBuilder withMethod(WritableElement<MethodModel> method) {\n+    ClassBuilder withMethod(Util.Writable method) {\n@@ -175,1 +173,1 @@\n-        BufWriter head = new BufWriterImpl(constantPool, context, size);\n+        BufWriterImpl head = new BufWriterImpl(constantPool, context, size);\n@@ -180,2 +178,2 @@\n-        tail.writeList(fields);\n-        tail.writeList(methods);\n+        Util.writeList(tail, fields);\n+        Util.writeList(tail, methods);\n@@ -200,1 +198,1 @@\n-        head.writeListIndices(ies);\n+        Util.writeListIndices(head, ies);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -45,1 +43,0 @@\n-import java.lang.classfile.Instruction;\n@@ -52,1 +49,0 @@\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -86,1 +82,1 @@\n-    final BufWriter bytecodesBufWriter;\n+    final BufWriterImpl bytecodesBufWriter;\n@@ -103,1 +99,1 @@\n-    public static Attribute<CodeAttribute> build(MethodInfo methodInfo,\n+    public static UnboundAttribute<CodeAttribute> build(MethodInfo methodInfo,\n@@ -134,1 +130,1 @@\n-                                                               : new BufWriterImpl(constantPool, context);\n+                : new BufWriterImpl(constantPool, context);\n@@ -137,3 +133,1 @@\n-        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n-        if (original != null)\n-            this.topLocal = Math.max(this.topLocal, original.maxLocals());\n+        this.topLocal = TerminalCodeBuilder.setupTopLocal(methodInfo, original);\n@@ -147,1 +141,1 @@\n-            writeAttribute((CustomAttribute)element);\n+            writeAttribute((CustomAttribute<?>) element);\n@@ -196,1 +190,1 @@\n-    private Attribute<CodeAttribute> content = null;\n+    private UnboundAttribute<CodeAttribute> content = null;\n@@ -198,1 +192,1 @@\n-    private void writeExceptionHandlers(BufWriter buf) {\n+    private void writeExceptionHandlers(BufWriterImpl buf) {\n@@ -236,1 +230,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -267,1 +261,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -272,1 +266,1 @@\n-                            if (!l.writeTo(b)) {\n+                            if (!Util.writeLocalVariable(b, l)) {\n@@ -290,1 +284,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -295,1 +289,1 @@\n-                            if (!l.writeTo(b)) {\n+                            if (!Util.writeLocalVariable(b, l)) {\n@@ -319,2 +313,3 @@\n-                    buf.writeU2(original.maxStack());\n-                    buf.writeU2(original.maxLocals());\n+                    var originalAttribute = (CodeImpl) original;\n+                    buf.writeU2(originalAttribute.maxStack());\n+                    buf.writeU2(originalAttribute.maxLocals());\n@@ -355,2 +350,1 @@\n-            public void writeBody(BufWriter b) {\n-                BufWriterImpl buf = (BufWriterImpl) b;\n+            public void writeBody(BufWriterImpl buf) {\n@@ -392,2 +386,2 @@\n-                writeExceptionHandlers(b);\n-                attributes.writeTo(b);\n+                writeExceptionHandlers(buf);\n+                attributes.writeTo(buf);\n@@ -430,1 +424,1 @@\n-        public void writeBody(BufWriter b) {\n+        public void writeBody(BufWriterImpl b) {\n@@ -435,1 +429,1 @@\n-        public void writeTo(BufWriter b) {\n+        public void writeTo(BufWriterImpl b) {\n@@ -450,1 +444,1 @@\n-                BufWriter bw = new BufWriterImpl(constantPool, context);\n+                var bw = new BufWriterImpl(constantPool, context);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -35,1 +34,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -40,1 +38,1 @@\n-        implements TerminalFieldBuilder, WritableElement<FieldModel> {\n+        implements TerminalFieldBuilder, Util.Writable {\n@@ -62,1 +60,1 @@\n-            writeAttribute((CustomAttribute)element);\n+            writeAttribute((CustomAttribute<?>) element);\n@@ -77,1 +75,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -40,1 +39,0 @@\n-import java.lang.classfile.WritableElement;\n@@ -45,1 +43,1 @@\n-        implements TerminalMethodBuilder, WritableElement<MethodModel>, MethodInfo {\n+        implements TerminalMethodBuilder, Util.Writable {\n@@ -118,1 +116,1 @@\n-            writeAttribute((CustomAttribute)element);\n+            writeAttribute((CustomAttribute<?>) element);\n@@ -151,2 +149,1 @@\n-    public void writeTo(BufWriter b) {\n-        BufWriterImpl buf = (BufWriterImpl) b;\n+    public void writeTo(BufWriterImpl buf) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -36,1 +37,1 @@\n-        implements FieldModel {\n+        implements FieldModel, Util.Writable {\n@@ -51,1 +52,1 @@\n-        return AccessFlags.ofField(reader.readU2(startPos));\n+        return new AccessFlagsImpl(AccessFlag.Location.FIELD, reader.readU2(startPos));\n@@ -81,1 +82,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -89,1 +90,1 @@\n-            buf.writeList(attributes());\n+            Util.writeAttributes(buf, attributes());\n@@ -104,1 +105,1 @@\n-                    FieldImpl.this.forEachElement(fb);\n+                    FieldImpl.this.forEach(fb);\n@@ -111,1 +112,1 @@\n-    public void forEachElement(Consumer<FieldElement> consumer) {\n+    public void forEach(Consumer<? super FieldElement> consumer) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -37,1 +38,1 @@\n-        implements MethodModel, MethodInfo {\n+        implements MethodModel, MethodInfo, Util.Writable {\n@@ -54,1 +55,1 @@\n-        return AccessFlags.ofMethod(reader.readU2(startPos));\n+        return new AccessFlagsImpl(AccessFlag.Location.METHOD, reader.readU2(startPos));\n@@ -104,2 +105,1 @@\n-    public void writeTo(BufWriter b) {\n-        BufWriterImpl buf = (BufWriterImpl) b;\n+    public void writeTo(BufWriterImpl buf) {\n@@ -113,1 +113,1 @@\n-            buf.writeList(attributes());\n+            Util.writeAttributes(buf, attributes());\n@@ -125,1 +125,1 @@\n-    public void forEachElement(Consumer<MethodElement> consumer) {\n+    public void forEach(Consumer<? super MethodElement> consumer) {\n@@ -143,1 +143,1 @@\n-                    MethodImpl.this.forEachElement(mb);\n+                    MethodImpl.this.forEach(mb);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n-public interface MethodInfo {\n+public sealed interface MethodInfo\n+        permits MethodImpl, TerminalMethodBuilder, BufferedMethodBuilder.Model {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodInfo.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.util.Optional;\n-\n@@ -30,1 +28,0 @@\n-import java.lang.classfile.CodeModel;\n@@ -62,5 +59,0 @@\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return terminal.original();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/NonterminalCodeBuilder.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.Attribute;\n@@ -37,1 +36,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -138,1 +136,1 @@\n-    public boolean writeBootstrapMethods(BufWriter buf) {\n+    public boolean writeBootstrapMethods(BufWriterImpl buf) {\n@@ -151,1 +149,1 @@\n-            Attribute<BootstrapMethodsAttribute> a\n+            UnboundAttribute<BootstrapMethodsAttribute> a\n@@ -155,1 +153,1 @@\n-                public void writeBody(BufWriter b) {\n+                public void writeBody(BufWriterImpl b) {\n@@ -166,2 +164,1 @@\n-    @Override\n-    public void writeTo(BufWriter buf) {\n+    void writeTo(BufWriterImpl buf) {\n@@ -178,1 +175,1 @@\n-            PoolEntry info = entryByIndex(i);\n+            var info = (AbstractPoolEntry) entryByIndex(i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                ((BufWriterImpl) dcb.bytecodesBufWriter).asByteBuffer(),\n+                dcb.bytecodesBufWriter.asByteBuffer(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,0 +288,4 @@\n+        public StackMapFrameImpl {\n+            locals = List.copyOf(locals);\n+            stack = List.copyOf(stack);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                ((BufWriterImpl) dcb.bytecodesBufWriter).asByteBuffer(),\n+                dcb.bytecodesBufWriter.asByteBuffer(),\n@@ -386,1 +386,1 @@\n-            public void writeBody(BufWriter b) {\n+            public void writeBody(BufWriterImpl b) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -192,5 +192,0 @@\n-\n-    @Override\n-    public void writeTo(BufWriter buf) {\n-        throw new UnsupportedOperationException();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -32,0 +34,14 @@\n+\n+    static int setupTopLocal(MethodInfo methodInfo, CodeModel original) {\n+        int paramSlots = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n+        if (original == null) {\n+            return paramSlots;\n+        }\n+        if (original instanceof CodeAttribute attr) {\n+            return Math.max(paramSlots, attr.maxLocals());\n+        }\n+        if (original instanceof BufferedCodeBuilder.Model buffered) {\n+            return Math.max(paramSlots, buffered.curTopLocal());\n+        }\n+        throw new InternalError(\"Unknown code model \" + original);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        extends MethodBuilder\n+        extends MethodBuilder, MethodInfo\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalMethodBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.ClassFileTransform;\n@@ -35,1 +37,0 @@\n-import java.lang.classfile.ClassFileTransform;\n@@ -49,1 +50,1 @@\n-public class TransformImpl {\n+public final class TransformImpl {\n@@ -61,1 +62,17 @@\n-    interface UnresolvedClassTransform extends ClassTransform {\n+    public static <E extends ClassFileElement, B extends ClassFileBuilder<E, B>>\n+            ResolvedTransform<E> resolve(ClassFileTransform<?, E, B> transform, B builder) {\n+        if (transform instanceof ResolvableTransform) {\n+            @SuppressWarnings(\"unchecked\")\n+            var ut = (ResolvableTransform<E, B>) transform;\n+            return ut.resolve(builder);\n+        }\n+        return new ResolvedTransform<>(e -> transform.accept(builder, e),\n+            () -> transform.atEnd(builder),\n+            () -> transform.atStart(builder));\n+    }\n+\n+    interface ResolvableTransform<E extends ClassFileElement, B extends ClassFileBuilder<E, B>> {\n+        ResolvedTransform<E> resolve(B builder);\n+    }\n+\n+    interface UnresolvedClassTransform extends ClassTransform, ResolvableTransform<ClassElement, ClassBuilder> {\n@@ -78,1 +95,1 @@\n-    public record ResolvedTransformImpl<E extends ClassFileElement>(Consumer<E> consumer,\n+    public record ResolvedTransform<E extends ClassFileElement>(Consumer<E> consumer,\n@@ -80,2 +97,1 @@\n-                                     Runnable startHandler)\n-            implements ClassFileTransform.ResolvedTransform<E> {\n+                                     Runnable startHandler) {\n@@ -83,1 +99,1 @@\n-        public ResolvedTransformImpl(Consumer<E> consumer) {\n+        public ResolvedTransform(Consumer<E> consumer) {\n@@ -92,2 +108,2 @@\n-        public ResolvedTransformImpl<ClassElement> resolve(ClassBuilder builder) {\n-            ResolvedTransform<ClassElement> downstream = next.resolve(builder);\n+        public ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n+            ResolvedTransform<ClassElement> downstream = TransformImpl.resolve(next, builder);\n@@ -95,2 +111,2 @@\n-            ResolvedTransform<ClassElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<ClassElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -98,1 +114,1 @@\n-                                          chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+                                          chainRunnable(downstream.startHandler(), upstream.startHandler()));\n@@ -106,1 +122,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -115,1 +131,1 @@\n-            return new ResolvedTransformImpl<>(ce -> {\n+            return new ResolvedTransform<>(ce -> {\n@@ -138,1 +154,1 @@\n-            return new ResolvedTransformImpl<>(ce -> {\n+            return new ResolvedTransform<>(ce -> {\n@@ -158,1 +174,1 @@\n-    interface UnresolvedMethodTransform extends MethodTransform {\n+    interface UnresolvedMethodTransform extends MethodTransform, ResolvableTransform<MethodElement, MethodBuilder> {\n@@ -180,1 +196,1 @@\n-            ResolvedTransform<MethodElement> downstream = next.resolve(builder);\n+            ResolvedTransform<MethodElement> downstream = TransformImpl.resolve(next, builder);\n@@ -182,2 +198,2 @@\n-            ResolvedTransform<MethodElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<MethodElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -185,1 +201,1 @@\n-                                           chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+                                           chainRunnable(downstream.startHandler(), upstream.startHandler()));\n@@ -193,1 +209,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -201,1 +217,1 @@\n-            return new ResolvedTransformImpl<>(me -> {\n+            return new ResolvedTransform<>(me -> {\n@@ -222,1 +238,1 @@\n-    interface UnresolvedFieldTransform extends FieldTransform {\n+    interface UnresolvedFieldTransform extends FieldTransform, ResolvableTransform<FieldElement, FieldBuilder> {\n@@ -243,1 +259,1 @@\n-            ResolvedTransform<FieldElement> downstream = next.resolve(builder);\n+            ResolvedTransform<FieldElement> downstream = TransformImpl.resolve(next, builder);\n@@ -245,2 +261,2 @@\n-            ResolvedTransform<FieldElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<FieldElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -248,1 +264,1 @@\n-                                           chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+                                           chainRunnable(downstream.startHandler(), upstream.startHandler()));\n@@ -256,1 +272,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -262,1 +278,1 @@\n-    interface UnresolvedCodeTransform extends CodeTransform {\n+    interface UnresolvedCodeTransform extends CodeTransform, ResolvableTransform<CodeElement, CodeBuilder> {\n@@ -283,1 +299,1 @@\n-            ResolvedTransform<CodeElement> downstream = next.resolve(builder);\n+            ResolvedTransform<CodeElement> downstream = TransformImpl.resolve(next, builder);\n@@ -285,2 +301,2 @@\n-            ResolvedTransform<CodeElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<CodeElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -288,1 +304,1 @@\n-                                         chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+                                         chainRunnable(downstream.startHandler(), upstream.startHandler()));\n@@ -296,1 +312,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":51,"deletions":35,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -97,0 +96,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -99,1 +100,1 @@\n-        implements Attribute<T> {\n+        implements Attribute<T>, Util.Writable {\n@@ -118,1 +119,1 @@\n-    public void writeTo(BufWriter buf) {\n+    public void writeTo(BufWriterImpl buf) {\n@@ -648,1 +649,7 @@\n-            this.elements = List.copyOf(elements);\n+            \/\/ deep copy\n+            var array = elements.toArray().clone();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = List.copyOf((List<?>) array[i]);\n+            }\n+\n+            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n@@ -772,1 +779,1 @@\n-                                        List<AnnotationElement> elements) implements TypeAnnotation {\n+                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n@@ -789,2 +796,2 @@\n-        public void writeTo(BufWriter buf) {\n-            LabelContext lr = ((BufWriterImpl) buf).labelContext();\n+        public void writeTo(BufWriterImpl buf) {\n+            LabelContext lr = buf.labelContext();\n@@ -838,1 +845,1 @@\n-                pair.value().writeTo(buf);\n+                AnnotationReader.writeAnnotationValue(buf, pair.value());\n@@ -924,1 +931,1 @@\n-        public abstract void writeBody(BufWriter b);\n+        public abstract void writeBody(BufWriterImpl b);\n@@ -927,1 +934,1 @@\n-        public void writeTo(BufWriter b) {\n+        public void writeTo(BufWriterImpl b) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -50,1 +53,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -191,0 +193,25 @@\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+        if (attr instanceof CustomAttribute<?> ca) {\n+            var mapper = (AttributeMapper<T>) ca.attributeMapper();\n+            mapper.writeAttribute(writer, (T) ca);\n+        } else {\n+            assert attr instanceof BoundAttribute || attr instanceof UnboundAttribute;\n+            ((Writable) attr).writeTo(writer);\n+        }\n+    }\n+\n+    public static void writeAttributes(BufWriterImpl buf, List<? extends Attribute<?>> list) {\n+        buf.writeU2(list.size());\n+        for (var e : list) {\n+            writeAttribute(buf, e);\n+        }\n+    }\n+\n+    static void writeList(BufWriterImpl buf, List<Writable> list) {\n+        buf.writeU2(list.size());\n+        for (var e : list) {\n+            e.writeTo(buf);\n+        }\n+    }\n+\n@@ -219,1 +246,1 @@\n-                                public void writeBody(BufWriter b) {\n+                                public void writeBody(BufWriterImpl b) {\n@@ -240,0 +267,24 @@\n+\n+    public static void writeListIndices(BufWriter writer, List<? extends PoolEntry> list) {\n+        writer.writeU2(list.size());\n+        for (PoolEntry info : list) {\n+            writer.writeIndex(info);\n+        }\n+    }\n+\n+    public static boolean writeLocalVariable(BufWriterImpl buf, PseudoInstruction lvOrLvt) {\n+        return ((WritableLocalVariable) lvOrLvt).writeLocalTo(buf);\n+    }\n+\n+    \/**\n+     * A generic interface for objects to write to a\n+     * buf writer. Do not implement unless necessary,\n+     * as this writeTo is public, which can be troublesome.\n+     *\/\n+    interface Writable {\n+        void writeTo(BufWriterImpl writer);\n+    }\n+\n+    interface WritableLocalVariable {\n+        boolean writeLocalTo(BufWriterImpl buf);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -117,2 +118,2 @@\n-        var klass = new VerificationWrapper(classModel);\n-        log_info(logger, \"Start class verification for: %s\", klass.thisClassName());\n+        String clsName = classModel.thisClass().asInternalName();\n+        log_info(logger, \"Start class verification for: %s\", clsName);\n@@ -120,0 +121,1 @@\n+            var klass = new VerificationWrapper(classModel);\n@@ -135,1 +137,1 @@\n-            return errors;\n+            return Collections.unmodifiableList(errors);\n@@ -137,1 +139,1 @@\n-            log_info(logger, \"End class verification for: %s\", klass.thisClassName());\n+            log_info(logger, \"End class verification for: %s\", clsName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -216,10 +216,19 @@\n-        @SuppressWarnings(\"removal\")\n-        MethodType mtype = AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public MethodType run() {\n-                return MethodType.fromMethodDescriptorString(descriptorString(),\n-                                                             lookup.lookupClass().getClassLoader());\n-            }\n-        });\n-\n-        \/\/ let's check that the lookup has access to all the types in the method type\n+        MethodType mtype;\n+        try {\n+            @SuppressWarnings(\"removal\")\n+            MethodType mt = AccessController.doPrivileged(new PrivilegedAction<>() {\n+                @Override\n+                public MethodType run() {\n+                    return MethodType.fromMethodDescriptorString(descriptorString(),\n+                        lookup.lookupClass().getClassLoader());\n+                }\n+            });\n+            mtype = mt;\n+        } catch (TypeNotPresentException ex) {\n+            throw (ClassNotFoundException) ex.getCause();\n+        }\n+\n+        \/\/ Some method types, like ones containing a package private class not accessible\n+        \/\/ to the overriding method, can be valid method descriptors and obtained from\n+        \/\/ MethodType.fromMethodDescriptor, but ldc instruction will fail to resolve such\n+        \/\/ MethodType constants due to access control (JVMS 5.4.3.1 and 5.4.3.5)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.RejectedExecutionException;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * Defines static methods to support execution in the context of a virtual thread.\n- *\/\n-public final class VirtualThreads {\n-    private static final JavaLangAccess JLA;\n-    static {\n-        JLA = SharedSecrets.getJavaLangAccess();\n-        if (JLA == null) {\n-            throw new InternalError(\"JavaLangAccess not setup\");\n-        }\n-    }\n-    private VirtualThreads() { }\n-\n-    \/**\n-     * Parks the current virtual thread until it is unparked or interrupted.\n-     * If already unparked then the parking permit is consumed and this method\n-     * completes immediately (meaning it doesn't yield). It also completes\n-     * immediately if the interrupt status is set.\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void park() {\n-        JLA.parkVirtualThread();\n-    }\n-\n-    \/**\n-     * Parks the current virtual thread up to the given waiting time or until it\n-     * is unparked or interrupted. If already unparked then the parking permit is\n-     * consumed and this method completes immediately (meaning it doesn't yield).\n-     * It also completes immediately if the interrupt status is set or the waiting\n-     * time is {@code <= 0}.\n-     * @param nanos the maximum number of nanoseconds to wait\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void park(long nanos) {\n-        JLA.parkVirtualThread(nanos);\n-    }\n-\n-    \/**\n-     * Parks the current virtual thread until the given deadline or until is is\n-     * unparked or interrupted. If already unparked then the parking permit is\n-     * consumed and this method completes immediately (meaning it doesn't yield).\n-     * It also completes immediately if the interrupt status is set or the\n-     * deadline has past.\n-     * @param deadline absolute time, in milliseconds, from the epoch\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void parkUntil(long deadline) {\n-        long millis = deadline - System.currentTimeMillis();\n-        long nanos = TimeUnit.NANOSECONDS.convert(millis, TimeUnit.MILLISECONDS);\n-        park(nanos);\n-    }\n-\n-    \/**\n-     * Re-enables a virtual thread for scheduling. If the thread was parked then\n-     * it will be unblocked, otherwise its next attempt to park will not block\n-     * @param thread the virtual thread to unpark\n-     * @throws IllegalArgumentException if the thread is not a virtual thread\n-     * @throws RejectedExecutionException if the scheduler cannot accept a task\n-     *\/\n-    public static void unpark(Thread thread) {\n-        JLA.unparkVirtualThread(thread);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VirtualThreads.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,52 @@\n+\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(int x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        int p = -10;\n+        for (int i = 1; i < 10; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 10 + d;\n+    }\n+\n+    \/**\n+     * Returns the string representation size for a given long value.\n+     *\n+     * @param x long value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    public static int stringSize(long x) {\n+        int d = 1;\n+        if (x >= 0) {\n+            d = 0;\n+            x = -x;\n+        }\n+        long p = -10;\n+        for (int i = 1; i < 19; i++) {\n+            if (x > p)\n+                return i + d;\n+            p = 10 * p;\n+        }\n+        return 19 + d;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+ *\n+ * Successfully translated exceptions are wrapped in a TranslatedException instance.\n+ * This allows callers to distiguish between a translated exception and an error\n+ * that arose during translation.\n@@ -47,1 +51,1 @@\n-final class TranslatedException extends Exception {\n+public final class TranslatedException extends Exception {\n@@ -64,2 +68,1 @@\n-                encodeThrowable(new TranslatedException(\"error during encoding\",\n-                                                        \"<unknown>\"), false);\n+                encodeThrowable(translationFailure(\"error during encoding\"), false);\n@@ -67,1 +70,1 @@\n-                encodeThrowable(new OutOfMemoryError(), false);\n+                encodeThrowable(translationFailure(\"OutOfMemoryError during encoding\"), false);\n@@ -73,0 +76,4 @@\n+    private static InternalError translationFailure(String messageFormat, Object... messageArgs) {\n+        return new InternalError(messageFormat.formatted(messageArgs));\n+    }\n+\n@@ -89,8 +96,2 @@\n-    \/**\n-     * Class name of exception that could not be instantiated.\n-     *\/\n-    private String originalExceptionClassName;\n-\n-    private TranslatedException(String message, String originalExceptionClassName) {\n-        super(message);\n-        this.originalExceptionClassName = originalExceptionClassName;\n+    TranslatedException(Throwable translated) {\n+        super(translated);\n@@ -109,12 +110,0 @@\n-    @Override\n-    public String toString() {\n-        String s;\n-        if (originalExceptionClassName.equals(TranslatedException.class.getName())) {\n-            s = getClass().getName();\n-        } else {\n-            s = getClass().getName() + \"[\" + originalExceptionClassName + \"]\";\n-        }\n-        String message = getMessage();\n-        return (message != null) ? (s + \": \" + message) : s;\n-    }\n-\n@@ -166,1 +155,1 @@\n-            return initCause(new TranslatedException(message, className), cause, debug);\n+            return initCause(translationFailure(\"%s [%s]\", message, className), cause, debug);\n@@ -311,1 +300,1 @@\n-            return throwable;\n+            return new TranslatedException(throwable);\n@@ -314,2 +303,1 @@\n-            return new TranslatedException(\"Error decoding exception: \" + encodedThrowable,\n-                                           translationFailure.getClass().getName());\n+            return translationFailure(\"error decoding exception: %s\", encodedThrowable);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+     *             4: an OutOfMemoryError thrown from within VM code on a\n+     *                thread that cannot call Java (OOME has no stack trace)\n@@ -132,0 +134,3 @@\n+            if (format == 4) {\n+                throw new TranslatedException(new OutOfMemoryError(\"in VM code and current thread cannot call Java\"));\n+            }\n@@ -138,1 +143,1 @@\n-                throw new OutOfMemoryError(\"OutOfMemoryError occurred \" + context);\n+                throw new OutOfMemoryError(context);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,1 +191,1 @@\n-                    SelectionKeyImpl ski = (SelectionKeyImpl)i.next();\n+                    SelectionKeyImpl ski = (SelectionKeyImpl) i.next();\n@@ -195,1 +195,1 @@\n-                        ((SelChImpl)selch).kill();\n+                        ((SelChImpl) selch).kill();\n@@ -224,1 +224,4 @@\n-        } catch (ClosedSelectorException e) {\n+        } catch (CancelledKeyException e) {\n+            \/\/ key observed and cancelled. Okay to return a cancelled key.\n+        }\n+        if (!isOpen()) {\n@@ -228,3 +231,1 @@\n-            throw e;\n-        } catch (CancelledKeyException e) {\n-            \/\/ key observed and cancelled. Okay to return a cancelled key.\n+            throw new ClosedSelectorException();\n@@ -280,1 +281,1 @@\n-                    ((SelChImpl)ch).kill();\n+                    ((SelChImpl) ch).kill();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorImpl.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-    HEARTBEAT               (0x000E, \"heartbeat\"),\n+    HEARTBEAT               (0x000F, \"heartbeat\"),\n@@ -409,1 +409,1 @@\n-    POST_HANDSHAKE_AUTH     (0x0030, \"post_handshake_auth\"),\n+    POST_HANDSHAKE_AUTH     (0x0031, \"post_handshake_auth\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,2 +431,11 @@\n-            checkIdentity(peerHost,\n-                    trustedChain[0], algorithm, chainsToPublicCA);\n+            try {\n+                checkIdentity(peerHost,\n+                        trustedChain[0], algorithm, chainsToPublicCA);\n+            } catch(CertificateException ce) {\n+                if (checkClientTrusted && \"HTTPS\".equalsIgnoreCase(algorithm)) {\n+                    throw new CertificateException(\"Endpoint Identification Algorithm \" +\n+                            \"HTTPS is not supported on the server side\");\n+                } else {\n+                    throw ce;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-            this.pos = this.data.length - unused;\n+            this.pos = this.end - unused;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,2 +206,1 @@\n-            \/\/ Ensure the name is the Object ID\n-            String name = namedCurve.getObjectId();\n+            String name = namedCurve.getNameAndAliases()[0];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ECParameters.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-    {\"getSigners\",       \"()[\" OBJ,         (void *)&JVM_GetClassSigners},\n-    {\"setSigners\",       \"([\" OBJ \")V\",     (void *)&JVM_SetClassSigners},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,1 +234,0 @@\n-        ensureOpen();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PollSelectorImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.nio.file.ProviderMismatchException;\n@@ -129,8 +128,0 @@\n-    UnixPath checkPath(Path obj) {\n-        if (obj == null)\n-            throw new NullPointerException();\n-        if (!(obj instanceof UnixPath))\n-            throw new ProviderMismatchException();\n-        return (UnixPath)obj;\n-    }\n-\n@@ -219,1 +210,1 @@\n-        UnixPath file = checkPath(obj);\n+        UnixPath file = UnixPath.toUnixPath(obj);\n@@ -236,1 +227,1 @@\n-        UnixPath file = checkPath(obj);\n+        UnixPath file = UnixPath.toUnixPath(obj);\n@@ -256,9 +247,1 @@\n-        UnixPath file = UnixPath.toUnixPath(obj);\n-        int mode = UnixFileModeAttribute\n-            .toUnixMode(UnixFileModeAttribute.ALL_READWRITE, attrs);\n-        try {\n-            return UnixChannelFactory.newFileChannel(file, options, mode);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-            return null;  \/\/ keep compiler happy\n-        }\n+        return newFileChannel(obj, options, attrs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.channels.ClosedSelectorException;\n@@ -92,5 +91,0 @@\n-    private void ensureOpen() {\n-        if (!isOpen())\n-            throw new ClosedSelectorException();\n-    }\n-\n@@ -231,1 +225,0 @@\n-        ensureOpen();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WEPollSelectorImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -609,1 +609,0 @@\n-        ensureOpen();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.PreviewFeatures;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.ContinuationSupport;\n@@ -109,1 +109,1 @@\n-        if (PreviewFeatures.isEnabled())\n+        if (ContinuationSupport.isSupported())\n@@ -129,1 +129,1 @@\n-                if (PreviewFeatures.isEnabled())\n+                if (ContinuationSupport.isSupported())\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsSecurity.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -490,2 +491,0 @@\n-        final Graphics2D g2d = g instanceof Graphics2D ? (Graphics2D)g : null;\n-\n@@ -495,1 +494,1 @@\n-        final int mnemonicIndex = AquaMnemonicHandler.isMnemonicHidden() ? -1 : b.getDisplayedMnemonicIndex();\n+        final int mnemonicIndex = MnemonicHandler.isMnemonicHidden() ? -1 : b.getDisplayedMnemonicIndex();\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonUI.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Graphics;\n@@ -30,5 +31,5 @@\n-import javax.swing.*;\n-import javax.swing.plaf.*;\n-import javax.swing.plaf.basic.*;\n-\n-import sun.swing.SwingUtilities2;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicLabelUI;\n@@ -38,0 +39,2 @@\n+import sun.swing.MnemonicHandler;\n+import sun.swing.SwingUtilities2;\n@@ -58,1 +61,1 @@\n-        if (AquaMnemonicHandler.isMnemonicHidden()) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n@@ -75,1 +78,1 @@\n-        if (AquaMnemonicHandler.isMnemonicHidden()) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLabelUI.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+import sun.swing.AltProcessor;\n+import sun.swing.MnemonicHandler;\n@@ -177,1 +179,3 @@\n-        KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventPostProcessor(AquaMnemonicHandler.getInstance());\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n+                .addKeyEventPostProcessor(AltProcessor.getInstance());\n+        MnemonicHandler.setMnemonicHidden(true);\n@@ -188,1 +192,2 @@\n-        KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventPostProcessor(AquaMnemonicHandler.getInstance());\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n+                .removeKeyEventPostProcessor(AltProcessor.getInstance());\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,22 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-\n-import javax.swing.*;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.ButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.JComponent;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.KeyStroke;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n@@ -36,4 +54,2 @@\n-import sun.swing.SwingUtilities2;\n-\n-import apple.laf.JRSUIConstants.*;\n-\n+import apple.laf.JRSUIConstants.State;\n+import apple.laf.JRSUIConstants.Widget;\n@@ -43,0 +59,2 @@\n+import sun.swing.MnemonicHandler;\n+import sun.swing.SwingUtilities2;\n@@ -290,1 +308,1 @@\n-                final int mnemonic = (AquaMnemonicHandler.isMnemonicHidden() ? -1 : model.getMnemonic());\n+                final int mnemonic = (MnemonicHandler.isMnemonicHidden() ? -1 : model.getMnemonic());\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMenuPainter.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.apple.laf;\n-\n-import java.awt.*;\n-import java.awt.event.KeyEvent;\n-\n-import javax.swing.*;\n-\n-import com.apple.laf.AquaUtils.RecyclableSingleton;\n-import com.apple.laf.AquaUtils.RecyclableSingletonFromDefaultConstructor;\n-\n-public class AquaMnemonicHandler {\n-    private static final RecyclableSingleton<AltProcessor> altProcessor = new RecyclableSingletonFromDefaultConstructor<AltProcessor>(AltProcessor.class);\n-    public static KeyEventPostProcessor getInstance() {\n-        return altProcessor.get();\n-    }\n-\n-    protected static boolean isMnemonicHidden = true; \/\/ true by default\n-\n-    public static void setMnemonicHidden(final boolean hide) {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        } else {\n-            isMnemonicHidden = hide;\n-        }\n-    }\n-\n-    \/**\n-     * Gets the state of the hide mnemonic flag. This only has meaning if this feature is supported by the underlying OS.\n-     *\n-     * @return true if mnemonics are hidden, otherwise, false\n-     * @see #setMnemonicHidden\n-     * @since 1.4\n-     *\/\n-    public static boolean isMnemonicHidden() {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        }\n-        return isMnemonicHidden;\n-    }\n-\n-    static class AltProcessor implements KeyEventPostProcessor {\n-        public boolean postProcessKeyEvent(final KeyEvent ev) {\n-            if (ev.getKeyCode() != KeyEvent.VK_ALT) {\n-                return false;\n-            }\n-\n-            final JRootPane root = SwingUtilities.getRootPane(ev.getComponent());\n-            final Window winAncestor = (root == null ? null : SwingUtilities.getWindowAncestor(root));\n-\n-            switch(ev.getID()) {\n-                case KeyEvent.KEY_PRESSED:\n-                    setMnemonicHidden(false);\n-                    break;\n-                case KeyEvent.KEY_RELEASED:\n-                    setMnemonicHidden(true);\n-                    break;\n-            }\n-\n-            repaintMnemonicsInWindow(winAncestor);\n-\n-            return false;\n-        }\n-    }\n-\n-    \/*\n-     * Repaints all the components with the mnemonics in the given window and all its owned windows.\n-     *\/\n-    static void repaintMnemonicsInWindow(final Window w) {\n-        if (w == null || !w.isShowing()) {\n-            return;\n-        }\n-\n-        final Window[] ownedWindows = w.getOwnedWindows();\n-        for (final Window element : ownedWindows) {\n-            repaintMnemonicsInWindow(element);\n-        }\n-\n-        repaintMnemonicsInContainer(w);\n-    }\n-\n-    \/*\n-     * Repaints all the components with the mnemonics in container.\n-     * Recursively searches for all the subcomponents.\n-     *\/\n-    static void repaintMnemonicsInContainer(final Container cont) {\n-        for (int i = 0; i < cont.getComponentCount(); i++) {\n-            final Component c = cont.getComponent(i);\n-            if (c == null || !c.isVisible()) {\n-                continue;\n-            }\n-\n-            if (c instanceof AbstractButton && ((AbstractButton)c).getMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            }\n-\n-            if (c instanceof JLabel && ((JLabel)c).getDisplayedMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            }\n-\n-            if (c instanceof Container) {\n-                repaintMnemonicsInContainer((Container)c);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMnemonicHandler.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -92,1 +92,5 @@\n-                setData(bytes, format);\n+                if (DataFlavor.javaFileListFlavor.equals(flavor)) {\n+                    writeFileObjects(bytes);\n+                } else {\n+                    setData(bytes, format);\n+                }\n@@ -130,0 +134,1 @@\n+    private native void writeFileObjects(byte[] data);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CClipboard.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -177,0 +177,33 @@\n+\/*\n+ * Class:     sun_lwawt_macosx_CClipboard\n+ * Method:    writeFileObjects\n+ * Signature: ([B)V\n+*\/\n+JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CClipboard_writeFileObjects\n+(JNIEnv *env, jobject inObject, jbyteArray inBytes)\n+{\n+    CHECK_NULL(inBytes);\n+\n+JNI_COCOA_ENTER(env);\n+    jint nBytes = (*env)->GetArrayLength(env, inBytes);\n+    jbyte *rawBytes = (*env)->GetPrimitiveArrayCritical(env, inBytes, NULL);\n+    CHECK_NULL(rawBytes);\n+    NSMutableArray *formatArray = [NSMutableArray arrayWithCapacity:2];\n+    int i = 0;\n+    for (int j = 0; j < nBytes; j++) {\n+        if (rawBytes[j] == 0) {\n+            NSString *path = [NSString stringWithUTF8String:(const char*)(rawBytes + i)];\n+            NSURL *fileURL = [NSURL fileURLWithPath:path];\n+            [formatArray addObject:fileURL.absoluteURL];\n+            i = j + 1;\n+        }\n+    }\n+    (*env)->ReleasePrimitiveArrayCritical(env, inBytes, rawBytes, JNI_ABORT);\n+\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n+        [[NSPasteboard generalPasteboard] writeObjects:formatArray];\n+    }];\n+JNI_COCOA_EXIT(env);\n+}\n+\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CClipboard.m","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import javax.swing.*;\n-import javax.swing.plaf.synth.*;\n@@ -33,0 +31,9 @@\n+import javax.swing.AbstractButton;\n+import javax.swing.JComponent;\n+import javax.swing.plaf.synth.Region;\n+import javax.swing.plaf.synth.SynthConstants;\n+import javax.swing.plaf.synth.SynthContext;\n+import javax.swing.plaf.synth.SynthGraphicsUtils;\n+\n+import sun.swing.MnemonicHandler;\n+\n@@ -52,0 +59,5 @@\n+\n+        if (MnemonicHandler.isMnemonicHidden()) {\n+            mnemonicIndex = -1;\n+        }\n+\n@@ -118,1 +130,2 @@\n-        super.paintText(context, g, text, bounds, mnemonicIndex);\n+        super.paintText(context, g, text, bounds,\n+                        MnemonicHandler.isMnemonicHidden() ? -1 : mnemonicIndex);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKGraphicsUtils.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,4 +28,13 @@\n-import java.awt.*;\n-import java.beans.*;\n-import java.io.File;\n-import java.lang.ref.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Insets;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -33,6 +42,20 @@\n-import java.security.PrivilegedAction;\n-import java.util.Locale;\n-import javax.swing.*;\n-import javax.swing.colorchooser.*;\n-import javax.swing.plaf.*;\n-import javax.swing.plaf.synth.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JTextField;\n+import javax.swing.LayoutStyle;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.colorchooser.AbstractColorChooserPanel;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.DimensionUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n+import javax.swing.plaf.synth.Region;\n+import javax.swing.plaf.synth.SynthConstants;\n+import javax.swing.plaf.synth.SynthLookAndFeel;\n+import javax.swing.plaf.synth.SynthStyleFactory;\n@@ -43,2 +66,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -47,1 +68,0 @@\n-import sun.awt.OSInfo;\n@@ -49,0 +69,1 @@\n+import sun.swing.AltProcessor;\n@@ -50,0 +71,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -869,1 +891,0 @@\n-\n@@ -1417,0 +1438,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -1459,0 +1484,17 @@\n+\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n+                .addKeyEventPostProcessor(AltProcessor.getInstance());\n+\n+        \/\/ By default mnemonics are hidden for GTK L&F\n+        MnemonicHandler.setMnemonicHidden(true);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public void uninitialize() {\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager()\n+                .removeKeyEventPostProcessor(AltProcessor.getInstance());\n+        MnemonicHandler.setMnemonicHidden(false);\n+        super.uninitialize();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":56,"deletions":14,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-            if(!isHW) {\n+            if (!isHW && img != null) {\n@@ -615,2 +615,2 @@\n-                if (img != null && border == img.getRGB(w \/ 2, h \/ 2)) {\n-                    \/\/ fix no menu borders in Adwaita theme\n+                if (border == img.getRGB(w \/ 2, h \/ 2)) {\n+                    \/\/ fix no menu borders\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.ComponentOrientation;\n@@ -367,0 +368,26 @@\n+     * @param orientation {@inheritDoc}\n+     *\/\n+    @Override\n+    public void setComponentOrientation(ComponentOrientation orientation) {\n+        super.setComponentOrientation(orientation);\n+        Component leftComponent = this.getLeftComponent();\n+        Component rightComponent = this.getRightComponent();\n+        if (!this.getComponentOrientation().isLeftToRight()) {\n+            if (rightComponent != null) {\n+                setLeftComponent(rightComponent);\n+            }\n+            if (leftComponent != null) {\n+                setRightComponent(leftComponent);\n+            }\n+        } else {\n+            if (leftComponent != null) {\n+                setLeftComponent(leftComponent);\n+            }\n+            if (rightComponent != null) {\n+                setRightComponent(rightComponent);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSplitPane.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,0 +1269,6 @@\n+                if (mode == JTable.AUTO_RESIZE_LAST_COLUMN) {\n+                    int colCnt = columnModel.getColumnCount();\n+                    if (colCnt > 0) {\n+                        tableHeader.setResizingColumn(columnModel.getColumn(colCnt - 1));\n+                    }\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -847,0 +847,4 @@\n+        if (value.startsWith(\"none\")) {\n+            return null;\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2394,1 +2394,1 @@\n-            int y = Math.max(ay, ay + (int)Math.ceil(ah\/2));\n+            int y = Math.max(ay, ay + ah\/2);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/StyleSheet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,2 +318,1 @@\n-            StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,\n-                                        advance);\n+            StrikeCache.setGlyphXAdvance(ptr, advance);\n@@ -668,2 +667,1 @@\n-                advance = StrikeCache.unsafe.getFloat\n-                    (glyphPtr + StrikeCache.xAdvanceOffset);\n+                advance = StrikeCache.getGlyphXAdvance(glyphPtr);\n@@ -729,2 +727,2 @@\n-        topLeftX = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftXOffset);\n-        topLeftY = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftYOffset);\n+        topLeftX = StrikeCache.getGlyphTopLeftX(ptr);\n+        topLeftY = StrikeCache.getGlyphTopLeftY(ptr);\n@@ -734,4 +732,2 @@\n-        result.width =\n-            StrikeCache.unsafe.getShort(ptr+StrikeCache.widthOffset)  &0x0ffff;\n-        result.height =\n-            StrikeCache.unsafe.getShort(ptr+StrikeCache.heightOffset) &0x0ffff;\n+        result.width = StrikeCache.getGlyphWidth(ptr) & 0x0ffff;\n+        result.height = StrikeCache.getGlyphHeight(ptr) & 0x0ffff;\n@@ -758,4 +754,3 @@\n-        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);\n-        int height = StrikeCache.unsafe.getChar(ptr+StrikeCache.heightOffset);\n-        int rowBytes =\n-            StrikeCache.unsafe.getChar(ptr+StrikeCache.rowBytesOffset);\n+        int width = StrikeCache.getGlyphWidth(ptr);\n+        int height = StrikeCache.getGlyphHeight(ptr);\n+        int rowBytes = StrikeCache.getGlyphRowBytes(ptr);\n@@ -767,4 +762,1 @@\n-        long pixelData =\n-            StrikeCache.unsafe.getAddress(ptr + StrikeCache.pixelDataOffset);\n-\n-        if (pixelData == 0L) {\n+        if (StrikeCache.getGlyphImagePtr(ptr) == 0L) {\n@@ -774,0 +766,1 @@\n+        byte[] pixelData = StrikeCache.getGlyphPixelBytes(ptr);\n@@ -776,1 +769,1 @@\n-                if (StrikeCache.unsafe.getByte(pixelData+y*rowBytes+x) != 0) {\n+                if (pixelData[(y*rowBytes)+x] != 0) {\n@@ -822,4 +815,2 @@\n-            metrics.x = StrikeCache.unsafe.getFloat\n-                (glyphPtr + StrikeCache.xAdvanceOffset);\n-            metrics.y = StrikeCache.unsafe.getFloat\n-                (glyphPtr + StrikeCache.yAdvanceOffset);\n+            metrics.x = StrikeCache.getGlyphXAdvance(glyphPtr);\n+            metrics.y = StrikeCache.getGlyphYAdvance(glyphPtr);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -322,4 +322,3 @@\n-        float gx =\n-            StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftXOffset);\n-        float gy =\n-            StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftYOffset);\n+\n+        float gx = StrikeCache.getGlyphTopLeftX(images[i]);\n+        float gy = StrikeCache.getGlyphTopLeftY(images[i]);\n@@ -334,4 +333,2 @@\n-            gposx += StrikeCache.unsafe.getFloat\n-                (images[i]+StrikeCache.xAdvanceOffset);\n-            gposy += StrikeCache.unsafe.getFloat\n-                (images[i]+StrikeCache.yAdvanceOffset);\n+            gposx += StrikeCache.getGlyphXAdvance(images[i]);\n+            gposy += StrikeCache.getGlyphYAdvance(images[i]);\n@@ -339,6 +336,3 @@\n-        metrics[2] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.widthOffset);\n-        metrics[3] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.heightOffset);\n-        metrics[4] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.rowBytesOffset);\n+        metrics[2] = StrikeCache.getGlyphWidth(images[i]);\n+        metrics[3] = StrikeCache.getGlyphHeight(images[i]);\n+        metrics[4] = StrikeCache.getGlyphRowBytes(images[i]);\n@@ -363,4 +357,1 @@\n-        long pixelDataAddress =\n-            StrikeCache.unsafe.getAddress(images[glyphindex] +\n-                                          StrikeCache.pixelDataOffset);\n-\n+        long pixelDataAddress = StrikeCache.getGlyphImagePtr(images[glyphindex]);\n@@ -370,9 +361,2 @@\n-        \/* unsafe is supposed to be fast, but I doubt if this loop can beat\n-         * a native call which does a getPrimitiveArrayCritical and a\n-         * memcpy for the typical amount of image data (30-150 bytes)\n-         * Consider a native method if there is a performance problem (which\n-         * I haven't seen so far).\n-         *\/\n-        for (int i=0; i<len; i++) {\n-            graybits[i] = StrikeCache.unsafe.getByte(pixelDataAddress+i);\n-        }\n+        byte[] bytes = StrikeCache.getGlyphPixelBytes(images[glyphindex]);\n+        System.arraycopy(bytes, 0, graybits, 0, bytes.length);\n@@ -448,7 +432,0 @@\n-        \/* Faster to access local variables in the for loop? *\/\n-        int xOffset = StrikeCache.topLeftXOffset;\n-        int yOffset = StrikeCache.topLeftYOffset;\n-        int wOffset = StrikeCache.widthOffset;\n-        int hOffset = StrikeCache.heightOffset;\n-        int xAdvOffset = StrikeCache.xAdvanceOffset;\n-        int yAdvOffset = StrikeCache.yAdvanceOffset;\n@@ -474,4 +451,4 @@\n-            gx = StrikeCache.unsafe.getFloat(images[i]+xOffset);\n-            gy = StrikeCache.unsafe.getFloat(images[i]+yOffset);\n-            gw = StrikeCache.unsafe.getChar(images[i]+wOffset);\n-            gh = StrikeCache.unsafe.getChar(images[i]+hOffset);\n+            gx = StrikeCache.getGlyphTopLeftX(images[i]);\n+            gy = StrikeCache.getGlyphTopLeftY(images[i]);\n+            gw = StrikeCache.getGlyphWidth(images[i]);\n+            gh = StrikeCache.getGlyphHeight(images[i]);\n@@ -485,2 +462,2 @@\n-                glx += StrikeCache.unsafe.getFloat(images[i]+xAdvOffset);\n-                gly += StrikeCache.unsafe.getFloat(images[i]+yAdvOffset);\n+                glx += StrikeCache.getGlyphXAdvance(images[i]);\n+                gly += StrikeCache.getGlyphYAdvance(images[i]);\n@@ -509,4 +486,2 @@\n-        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                               StrikeCache.widthOffset);\n-        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                                  StrikeCache.rowBytesOffset);\n+        int width = StrikeCache.getGlyphWidth(images[glyphIndex]);\n+        int rowBytes = StrikeCache.getGlyphRowBytes(images[glyphIndex]);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":19,"deletions":44,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,10 @@\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import static java.lang.foreign.MemorySegment.NULL;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n@@ -40,1 +50,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -66,2 +75,0 @@\n-    static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n@@ -101,2 +108,3 @@\n-     * Native sizes and offsets for glyph cache\n-     * There are 10 values.\n+     * Native sizes and accessors for glyph cache structure.\n+     * There are 10 values. Also need native address size and a long which\n+     * references a memory address for a \"null\" glyph image.\n@@ -104,31 +112,149 @@\n-    static int nativeAddressSize;\n-    static int glyphInfoSize;\n-    static int xAdvanceOffset;\n-    static int yAdvanceOffset;\n-    static int boundsOffset;\n-    static int widthOffset;\n-    static int heightOffset;\n-    static int rowBytesOffset;\n-    static int topLeftXOffset;\n-    static int topLeftYOffset;\n-    static int pixelDataOffset;\n-    static int cacheCellOffset;\n-    static int managedOffset;\n-    static long invisibleGlyphPtr;\n-\n-    \/* Native method used to return information used for unsafe\n-     * access to native data.\n-     * return values as follows:-\n-     * arr[0] = size of an address\/pointer.\n-     * arr[1] = size of a GlyphInfo\n-     * arr[2] = offset of advanceX\n-     * arr[3] = offset of advanceY\n-     * arr[4] = offset of width\n-     * arr[5] = offset of height\n-     * arr[6] = offset of rowBytes\n-     * arr[7] = offset of topLeftX\n-     * arr[8] = offset of topLeftY\n-     * arr[9] = offset of pixel data.\n-     * arr[10] = address of a GlyphImageRef representing the invisible glyph\n-     *\/\n-    static native void getGlyphCacheDescription(long[] infoArray);\n+    static final int nativeAddressSize = (int)ValueLayout.ADDRESS.byteSize();\n+    static final long invisibleGlyphPtr = getInvisibleGlyphPtr(); \/\/ a singleton.\n+\n+    static native long getInvisibleGlyphPtr();\n+\n+    public static final StructLayout GlyphImageLayout = MemoryLayout.structLayout(\n+        JAVA_FLOAT.withName(\"xAdvance\"), \/\/ 0+4=4,\n+        JAVA_FLOAT.withName(\"yAdvance\"), \/\/ 4+4=8,\n+        JAVA_CHAR.withName(\"width\"),     \/\/ 8+2=10,\n+        JAVA_CHAR.withName(\"height\"),    \/\/ 10+2=12\n+        JAVA_CHAR.withName(\"rowBytes\"),  \/\/ 12+2=14\n+        JAVA_BYTE.withName(\"managed\"),   \/\/ 14+1=15\n+        MemoryLayout.paddingLayout(1),   \/\/ 15+1=16\n+        JAVA_FLOAT.withName(\"topLeftX\"), \/\/ 16+4=20\n+        JAVA_FLOAT.withName(\"topLeftY\"), \/\/ 20+4=24\n+        ADDRESS.withName(\"cellInfo\"),    \/\/ 24+8=32\n+        ADDRESS.withName(\"image\")        \/\/ 32+8=40\n+     );\n+\n+   private static final long GLYPHIMAGESIZE = GlyphImageLayout.byteSize();\n+\n+   private static VarHandle getVarHandle(StructLayout struct, String name) {\n+        VarHandle h = struct.varHandle(PathElement.groupElement(name));\n+        \/* insert 0 offset so don't need to pass arg every time *\/\n+        return MethodHandles.insertCoordinates(h, 1, 0L).withInvokeExactBehavior();\n+    }\n+\n+    private static final VarHandle xAdvanceHandle = getVarHandle(GlyphImageLayout, \"xAdvance\");\n+    private static final VarHandle yAdvanceHandle = getVarHandle(GlyphImageLayout, \"yAdvance\");\n+    private static final VarHandle widthHandle    = getVarHandle(GlyphImageLayout, \"width\");\n+    private static final VarHandle heightHandle   = getVarHandle(GlyphImageLayout, \"height\");\n+    private static final VarHandle rowBytesHandle = getVarHandle(GlyphImageLayout, \"rowBytes\");\n+    private static final VarHandle managedHandle  = getVarHandle(GlyphImageLayout, \"managed\");\n+    private static final VarHandle topLeftXHandle = getVarHandle(GlyphImageLayout, \"topLeftX\");\n+    private static final VarHandle topLeftYHandle = getVarHandle(GlyphImageLayout, \"topLeftY\");\n+    private static final VarHandle cellInfoHandle = getVarHandle(GlyphImageLayout, \"cellInfo\");\n+    private static final VarHandle imageHandle    = getVarHandle(GlyphImageLayout, \"image\");\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphXAdvance(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)xAdvanceHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final void setGlyphXAdvance(long ptr, float val) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        xAdvanceHandle.set(seg, val);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphYAdvance(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)yAdvanceHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphWidth(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)widthHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphHeight(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)heightHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphRowBytes(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)rowBytesHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final byte getGlyphManaged(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (byte)managedHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphTopLeftX(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)topLeftXHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphTopLeftY(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)topLeftYHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final long getGlyphCellInfo(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return ((MemorySegment)cellInfoHandle.get(seg)).address();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final void setGlyphCellInfo(long ptr, long val) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        MemorySegment segval = MemorySegment.ofAddress(val);\n+        cellInfoHandle.set(seg, segval);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final long getGlyphImagePtr(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return ((MemorySegment)imageHandle.get(seg)).address();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final MemorySegment getGlyphPixelData(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        char hgt = (char)heightHandle.get(seg);\n+        char rb = (char)rowBytesHandle.get(seg);\n+        MemorySegment pixelData = (MemorySegment)imageHandle.get(seg);\n+        pixelData = pixelData.reinterpret(rb * hgt);\n+        return pixelData;\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final byte[] getGlyphPixelBytes(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        char hgt = (char)heightHandle.get(seg);\n+        char rb = (char)rowBytesHandle.get(seg);\n+        MemorySegment pixelData = (MemorySegment)imageHandle.get(seg);\n+        int sz = rb * hgt;\n+        pixelData = pixelData.reinterpret(sz);\n+        return pixelData.toArray(ValueLayout.JAVA_BYTE);\n+    }\n+\n+    static final byte getPixelByte(MemorySegment pixelData, long index) {\n+       return pixelData.getAtIndex(JAVA_BYTE, index);\n+    }\n@@ -143,18 +269,0 @@\n-        long[] nativeInfo = new long[13];\n-        getGlyphCacheDescription(nativeInfo);\n-        \/\/Can also get address size from Unsafe class :-\n-        \/\/nativeAddressSize = unsafe.addressSize();\n-        nativeAddressSize = (int)nativeInfo[0];\n-        glyphInfoSize     = (int)nativeInfo[1];\n-        xAdvanceOffset    = (int)nativeInfo[2];\n-        yAdvanceOffset    = (int)nativeInfo[3];\n-        widthOffset       = (int)nativeInfo[4];\n-        heightOffset      = (int)nativeInfo[5];\n-        rowBytesOffset    = (int)nativeInfo[6];\n-        topLeftXOffset    = (int)nativeInfo[7];\n-        topLeftYOffset    = (int)nativeInfo[8];\n-        pixelDataOffset   = (int)nativeInfo[9];\n-        invisibleGlyphPtr = nativeInfo[10];\n-        cacheCellOffset = (int) nativeInfo[11];\n-        managedOffset = (int) nativeInfo[12];\n-\n@@ -327,1 +435,1 @@\n-                    if (glyphPtrs[i] != 0 && unsafe.getByte(glyphPtrs[i] + managedOffset) == 0) {\n+                    if ((glyphPtrs[i] != 0) && getGlyphManaged(glyphPtrs[i]) == 0) {\n@@ -353,2 +461,1 @@\n-                    if (glyphPtrs[i] != 0\n-                            && unsafe.getByte(glyphPtrs[i] + managedOffset) == 0) {\n+                    if ((glyphPtrs[i] != 0) && getGlyphManaged(glyphPtrs[i]) == 0) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":164,"deletions":57,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2153,7 +2153,10 @@\n-        if (dy == 0 && dx > 0 && dx < w) {\n-            while (w > 0) {\n-                int partW = Math.min(w, dx);\n-                w -= partW;\n-                int sx = x + w;\n-                ob.Blit(theData, theData, comp, clip,\n-                        sx, y, sx+dx, y+dy, partW, h);\n+        try {\n+            if (dy == 0 && dx > 0 && dx < w) {\n+                while (w > 0) {\n+                    int partW = Math.min(w, dx);\n+                    w -= partW;\n+                    int sx = Math.addExact(x, w);\n+                    ob.Blit(theData, theData, comp, clip,\n+                            sx, y, sx+dx, y+dy, partW, h);\n+                }\n+                return;\n@@ -2161,9 +2164,9 @@\n-            return;\n-        }\n-        if (dy > 0 && dy < h && dx > -w && dx < w) {\n-            while (h > 0) {\n-                int partH = Math.min(h, dy);\n-                h -= partH;\n-                int sy = y + h;\n-                ob.Blit(theData, theData, comp, clip,\n-                        x, sy, x+dx, sy+dy, w, partH);\n+            if (dy > 0 && dy < h && dx > -w && dx < w) {\n+                while (h > 0) {\n+                    int partH = Math.min(h, dy);\n+                    h -= partH;\n+                    int sy = Math.addExact(y, h);\n+                    ob.Blit(theData, theData, comp, clip,\n+                            x, sy, Math.addExact(x, dx), sy+dy, w, partH);\n+                }\n+                return;\n@@ -2171,0 +2174,4 @@\n+            ob.Blit(theData, theData, comp, clip, x, y,\n+                Math.addExact(x, dx), Math.addExact(y, dy), w, h);\n+        } catch (ArithmeticException ex) {\n+            \/\/ We are hitting integer overflow in Math.addExact()\n@@ -2173,1 +2180,0 @@\n-            ob.Blit(theData, theData, comp, clip, x, y, x+dx, y+dy, w, h);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,0 +372,7 @@\n+            double[] mat = new double[6];\n+            itx.getMatrix(mat);\n+            for (double d : mat) {\n+                if (!Double.isFinite(d)) {\n+                    return;\n+                }\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/DrawImage.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.swing;\n+\n+import java.awt.KeyEventPostProcessor;\n+import java.awt.Window;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JRootPane;\n+import javax.swing.SwingUtilities;\n+\n+public final class AltProcessor implements KeyEventPostProcessor {\n+\n+    private AltProcessor() {}\n+\n+    private static final AltProcessor altProcessor = new AltProcessor();\n+\n+    public static KeyEventPostProcessor getInstance() {\n+        return altProcessor;\n+    }\n+\n+    @Override\n+    public boolean postProcessKeyEvent(final KeyEvent ev) {\n+        if (ev.getKeyCode() != KeyEvent.VK_ALT) {\n+            return false;\n+        }\n+\n+        final JRootPane root = SwingUtilities.getRootPane(ev.getComponent());\n+        final Window winAncestor = (root == null ? null : SwingUtilities.getWindowAncestor(root));\n+\n+        switch (ev.getID()) {\n+            case KeyEvent.KEY_PRESSED:\n+                MnemonicHandler.setMnemonicHidden(false);\n+                break;\n+            case KeyEvent.KEY_RELEASED:\n+                MnemonicHandler.setMnemonicHidden(true);\n+                break;\n+        }\n+\n+        MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n+\n+        return false;\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/AltProcessor.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.swing;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Window;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.JLabel;\n+import javax.swing.UIManager;\n+\n+public final class MnemonicHandler {\n+\n+    private static boolean isMnemonicHidden;\n+\n+    private MnemonicHandler() {}\n+\n+    \/**\n+     * Gets the state of the hide mnemonic flag.\n+     * This only has meaning if this feature is supported by the underlying OS.\n+     *\n+     * @return true if mnemonics are hidden, otherwise, false\n+     *\/\n+    public static boolean isMnemonicHidden() {\n+        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n+            \/\/ Do not hide mnemonics if the UI defaults do not support this\n+            isMnemonicHidden = false;\n+        }\n+        return isMnemonicHidden;\n+    }\n+\n+    \/**\n+     * Sets the state of the hide mnemonic flag. This flag is used by the\n+     * component UI delegates to determine if the mnemonic should be rendered.\n+     * This method is a non operation if the underlying operating system\n+     * does not support the mnemonic hiding feature.\n+     *\n+     * @param hide true if mnemonics should be hidden\n+     *\/\n+    public static void setMnemonicHidden(final boolean hide) {\n+        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n+            \/\/ Do not hide mnemonics if the UI defaults do not support this\n+            isMnemonicHidden = false;\n+        } else {\n+            isMnemonicHidden = hide;\n+        }\n+    }\n+\n+    \/**\n+     * Repaints all the components with the mnemonics in the given window and all its owned windows.\n+     *\/\n+    public static void repaintMnemonicsInWindow(final Window w) {\n+        if (w == null || !w.isShowing()) {\n+            return;\n+        }\n+\n+        final Window[] ownedWindows = w.getOwnedWindows();\n+        for (final Window element : ownedWindows) {\n+            repaintMnemonicsInWindow(element);\n+        }\n+\n+        repaintMnemonicsInContainer(w);\n+    }\n+\n+    \/**\n+     * Repaints all the components with the mnemonics in container.\n+     * Recursively searches for all the subcomponents.\n+     *\/\n+    private static void repaintMnemonicsInContainer(final Container cont) {\n+        final Component[] elements = cont.getComponents();\n+        for (final Component c : elements) {\n+            if (c == null || !c.isVisible()) {\n+                continue;\n+            }\n+\n+            if ((c instanceof AbstractButton b && b.getMnemonic() != '\\0')\n+                || (c instanceof JLabel l && l.getDisplayedMnemonic() != '\\0')) {\n+                c.repaint();\n+            } else if (c instanceof Container) {\n+                repaintMnemonicsInContainer((Container) c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/MnemonicHandler.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include <limits.h>\n@@ -56,0 +57,8 @@\n+#define UNSAFE_TO_ADD(a, b) \\\n+    (((a >= 0) && (b >= 0) && (a > (INT_MAX - b))) || \\\n+     ((a < 0) && (b < 0) && (a < (INT_MIN - b)))) \\\n+\n+#define UNSAFE_TO_SUB(a, b) \\\n+    (((b >= 0) && (a < 0) && (a < (INT_MIN + b))) || \\\n+     ((b < 0) && (a >= 0) && (-b > (INT_MAX - a)))) \\\n+\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/SurfaceData.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+    if (width <= 0 || height <= 0) {\n+        return;\n+    }\n+\n@@ -73,0 +77,6 @@\n+    if (UNSAFE_TO_ADD(srcx, width) ||\n+        UNSAFE_TO_ADD(srcy, height) ||\n+        UNSAFE_TO_ADD(dstx, width) ||\n+        UNSAFE_TO_ADD(dsty, height)) {\n+        return;\n+    }\n@@ -79,0 +89,4 @@\n+    if (UNSAFE_TO_SUB(srcx, dstx) ||\n+        UNSAFE_TO_SUB(srcy, dsty)) {\n+        return;\n+    }\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/MaskBlit.c","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -470,1 +470,1 @@\n-        if (xmid <= (CX2)) { \\\n+        if (xmid < (CX2)) { \\\n@@ -559,1 +559,1 @@\n-    jfloat localaccum[MASK_BUF_LEN + 1];\n+    jfloat localaccum[MASK_BUF_LEN + 2];\n@@ -571,1 +571,1 @@\n-              ? malloc((width + 1) * sizeof(jfloat))\n+              ? malloc((width + 2) * sizeof(jfloat))\n@@ -576,1 +576,1 @@\n-    memset(pAccum, 0, (width+1) * sizeof(jfloat));\n+    memset(pAccum, 0, (width + 2) * sizeof(jfloat));\n@@ -797,1 +797,1 @@\n-    jfloat localaccum[MASK_BUF_LEN + 1];\n+    jfloat localaccum[MASK_BUF_LEN + 2];\n@@ -818,1 +818,1 @@\n-              ? malloc((width + 1) * sizeof(jfloat))\n+              ? malloc((width + 2) * sizeof(jfloat))\n@@ -823,1 +823,1 @@\n-    memset(pAccum, 0, (width+1) * sizeof(jfloat));\n+    memset(pAccum, 0, (width + 2) * sizeof(jfloat));\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/MaskFill.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-#define TX_FIXED_UNSAFE(v)  (fabs(v) >= (1<<30))\n+#define TX_FIXED_UNSAFE(v)  (isinf(v) || isnan(v) || fabs(v) >= (1<<30))\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/TransformHelper.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,11 +303,2 @@\n-JNIEXPORT void JNICALL\n-Java_sun_font_StrikeCache_getGlyphCacheDescription\n-  (JNIEnv *env, jclass cls, jlongArray results) {\n-\n-    jlong* nresults;\n-    GlyphInfo *info;\n-    size_t baseAddr;\n-\n-    if ((*env)->GetArrayLength(env, results) < 13) {\n-        return;\n-    }\n+JNIEXPORT jlong JNICALL\n+Java_sun_font_StrikeCache_getInvisibleGlyphPtr(JNIEnv *env, jclass cls) {\n@@ -315,25 +306,2 @@\n-    nresults = (jlong*)(*env)->GetPrimitiveArrayCritical(env, results, NULL);\n-    if (nresults == NULL) {\n-        return;\n-    }\n-    info = (GlyphInfo*) calloc(1, sizeof(GlyphInfo));\n-    if (info == NULL) {\n-        (*env)->ReleasePrimitiveArrayCritical(env, results, nresults, 0);\n-        return;\n-    }\n-    baseAddr = (size_t)info;\n-    nresults[0] = sizeof(void*);\n-    nresults[1] = sizeof(GlyphInfo);\n-    nresults[2] = 0;\n-    nresults[3] = (size_t)&(info->advanceY)-baseAddr;\n-    nresults[4] = (size_t)&(info->width)-baseAddr;\n-    nresults[5] = (size_t)&(info->height)-baseAddr;\n-    nresults[6] = (size_t)&(info->rowBytes)-baseAddr;\n-    nresults[7] = (size_t)&(info->topLeftX)-baseAddr;\n-    nresults[8] = (size_t)&(info->topLeftY)-baseAddr;\n-    nresults[9] = (size_t)&(info->image)-baseAddr;\n-    nresults[10] = (jlong)(uintptr_t)info; \/* invisible glyph *\/\n-    nresults[11] = (size_t)&(info->cellInfo)-baseAddr;\n-    nresults[12] = (size_t)&(info->managed)-baseAddr;\n-\n-    (*env)->ReleasePrimitiveArrayCritical(env, results, nresults, 0);\n+    GlyphInfo *info = (GlyphInfo*) calloc(1, sizeof(GlyphInfo));\n+    return (jlong)(uintptr_t)info; \/* invisible glyph *\/\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":4,"deletions":36,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        \/\/ We need to access the GlyphID with Unsafe.getAddress() because the\n+        \/\/ We need to access the GlyphID as a long because the\n@@ -77,3 +77,2 @@\n-        \/\/ field with Unsafe.getInt().\n-        return (int) StrikeCache.unsafe.getAddress(glyphInfoPtr +\n-                                                   StrikeCache.cacheCellOffset);\n+        \/\/ field as an int.\n+        return (int)StrikeCache.getGlyphCellInfo(glyphInfoPtr);\n@@ -83,1 +82,1 @@\n-        \/\/ We need to access the GlyphID with Unsafe.putAddress() because the\n+        \/\/ We need to access the GlyphID as a long because the\n@@ -85,5 +84,4 @@\n-        \/\/ 'void*' (see field 'cellInfo' of struct 'GlyphInfo' in\n-        \/\/ src\/share\/native\/sun\/font\/fontscalerdefs.h).\n-        \/\/ On 64-bit Big-endian architectures it would be wrong to write this\n-        \/\/ field with Unsafe.putInt() because it is also accessed from native\n-        \/\/ code as a 'long'.\n+        \/\/ 'void*' (see field 'cellInfo' of struct 'GlyphInfo'\n+        \/\/ in src\/share\/native\/sun\/font\/fontscalerdefs.h).\n+        \/\/ On 64-bit Big-endian architectures it would be wrong to access this\n+        \/\/ field as an int\n@@ -91,3 +89,2 @@\n-        \/\/ in src\/solaris\/native\/sun\/java2d\/x11\/XRBackendNative.c\n-        StrikeCache.unsafe.putAddress(glyphInfoPtr +\n-                                      StrikeCache.cacheCellOffset, (long)id);\n+        \/\/ in src\/unix\/native\/sun\/java2d\/x11\/XRBackendNative.c\n+        StrikeCache.setGlyphCellInfo(glyphInfoPtr, (long)id);\n@@ -105,1 +102,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.xAdvanceOffset);\n+        return StrikeCache.getGlyphXAdvance(glyphInfoPtr);\n@@ -109,1 +106,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.yAdvanceOffset);\n+        return StrikeCache.getGlyphYAdvance(glyphInfoPtr);\n@@ -113,1 +110,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.rowBytesOffset);\n+        return StrikeCache.getGlyphRowBytes(glyphInfoPtr);\n@@ -117,1 +114,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.widthOffset);\n+        return StrikeCache.getGlyphWidth(glyphInfoPtr);\n@@ -121,1 +118,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.heightOffset);\n+        return StrikeCache.getGlyphHeight(glyphInfoPtr);\n@@ -125,3 +122,1 @@\n-        long pixelDataAddress =\n-            StrikeCache.unsafe.getAddress(glyphInfoPtr +\n-                                          StrikeCache.pixelDataOffset);\n+        long pixelDataAddress = StrikeCache.getGlyphImagePtr(glyphInfoPtr);\n@@ -137,0 +132,1 @@\n+        byte[] pixelBytes = StrikeCache.getGlyphPixelBytes(glyphInfoPtr);\n@@ -141,1 +137,1 @@\n-                        os.write(StrikeCache.unsafe.getByte(pixelDataAddress + (line * rowBytes + x)));\n+                        os.write(pixelBytes[(line * rowBytes + x)]);\n@@ -154,6 +150,3 @@\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 2)));\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 1)));\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 0)));\n+                    os.write(pixelBytes[rowStart + srcpix + 2]);\n+                    os.write(pixelBytes[rowStart + srcpix + 1]);\n+                    os.write(pixelBytes[rowStart + srcpix + 0]);\n@@ -168,1 +161,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.topLeftXOffset);\n+        return StrikeCache.getGlyphTopLeftX(glyphInfoPtr);\n@@ -172,1 +165,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.topLeftYOffset);\n+        return StrikeCache.getGlyphTopLeftY(glyphInfoPtr);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-typedef void GMainContext;\n@@ -64,1 +63,0 @@\n-typedef void GdkPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,0 @@\n-typedef void GdkPixbuf;\n-typedef void GMainContext;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,16 @@\n-import sun.swing.SwingUtilities2;\n-\n-import java.awt.*;\n-\n-import javax.swing.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonModel;\n+import javax.swing.JButton;\n+import javax.swing.JCheckBox;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuItem;\n+import javax.swing.JRadioButton;\n+import javax.swing.JToggleButton;\n+import javax.swing.UIManager;\n@@ -35,1 +46,7 @@\n-import static com.sun.java.swing.plaf.windows.TMSchema.*;\n+import sun.swing.MnemonicHandler;\n+import sun.swing.SwingUtilities2;\n+\n+import static com.sun.java.swing.plaf.windows.TMSchema.Part;\n+import static com.sun.java.swing.plaf.windows.TMSchema.Prop;\n+import static com.sun.java.swing.plaf.windows.TMSchema.State;\n+import static com.sun.java.swing.plaf.windows.TMSchema.TypeEnum;\n@@ -63,1 +80,1 @@\n-        if (WindowsLookAndFeel.isMnemonicHidden() == true) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n@@ -194,42 +211,0 @@\n-    \/*\n-     * Repaints all the components with the mnemonics in the given window and\n-     * all its owned windows.\n-     *\/\n-    static void repaintMnemonicsInWindow(Window w) {\n-        if(w == null || !w.isShowing()) {\n-            return;\n-        }\n-\n-        Window[] ownedWindows = w.getOwnedWindows();\n-        for(int i=0;i<ownedWindows.length;i++) {\n-            repaintMnemonicsInWindow(ownedWindows[i]);\n-        }\n-\n-        repaintMnemonicsInContainer(w);\n-    }\n-\n-    \/*\n-     * Repaints all the components with the mnemonics in container.\n-     * Recursively searches for all the subcomponents.\n-     *\/\n-    static void repaintMnemonicsInContainer(Container cont) {\n-        Component c;\n-        for(int i=0; i<cont.getComponentCount(); i++) {\n-            c = cont.getComponent(i);\n-            if(c == null || !c.isVisible()) {\n-                continue;\n-            }\n-            if(c instanceof AbstractButton\n-               && ((AbstractButton)c).getMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            } else if(c instanceof JLabel\n-                      && ((JLabel)c).getDisplayedMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            }\n-            if(c instanceof Container) {\n-                repaintMnemonicsInContainer((Container)c);\n-            }\n-        }\n-    }\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsGraphicsUtils.java","additions":25,"deletions":50,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -65,1 +66,1 @@\n-        if (WindowsLookAndFeel.isMnemonicHidden() == true) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n@@ -78,1 +79,1 @@\n-        if (WindowsLookAndFeel.isMnemonicHidden() == true) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLabelUI.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -199,0 +200,1 @@\n+        MnemonicHandler.setMnemonicHidden(true);\n@@ -1911,4 +1913,0 @@\n-\n-    \/\/ Toggle flag for drawing the mnemonic state\n-    private static boolean isMnemonicHidden = true;\n-\n@@ -1919,34 +1917,0 @@\n-    \/**\n-     * Sets the state of the hide mnemonic flag. This flag is used by the\n-     * component UI delegates to determine if the mnemonic should be rendered.\n-     * This method is a non operation if the underlying operating system\n-     * does not support the mnemonic hiding feature.\n-     *\n-     * @param hide true if mnemonics should be hidden\n-     * @since 1.4\n-     *\/\n-    public static void setMnemonicHidden(boolean hide) {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\") == true) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        } else {\n-            isMnemonicHidden = hide;\n-        }\n-    }\n-\n-    \/**\n-     * Gets the state of the hide mnemonic flag. This only has meaning\n-     * if this feature is supported by the underlying OS.\n-     *\n-     * @return true if mnemonics are hidden, otherwise, false\n-     * @see #setMnemonicHidden\n-     * @since 1.4\n-     *\/\n-    public static boolean isMnemonicHidden() {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\") == true) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        }\n-        return isMnemonicHidden;\n-    }\n-\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":3,"deletions":39,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+import sun.swing.MnemonicHandler;\n+\n@@ -152,1 +154,1 @@\n-                    WindowsLookAndFeel.setMnemonicHidden(true);\n+                    MnemonicHandler.setMnemonicHidden(true);\n@@ -156,1 +158,1 @@\n-                    WindowsLookAndFeel.setMnemonicHidden(false);\n+                    MnemonicHandler.setMnemonicHidden(false);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuBarUI.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -206,1 +207,1 @@\n-            if (WindowsLookAndFeel.isMnemonicHidden() == true) {\n+            if (MnemonicHandler.isMnemonicHidden()) {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -102,1 +103,1 @@\n-                if(!WindowsLookAndFeel.isMnemonicHidden()) {\n+                if (!MnemonicHandler.isMnemonicHidden()) {\n@@ -104,1 +105,1 @@\n-                    WindowsLookAndFeel.setMnemonicHidden(true);\n+                    MnemonicHandler.setMnemonicHidden(true);\n@@ -108,1 +109,1 @@\n-                        WindowsGraphicsUtils.repaintMnemonicsInWindow(win);\n+                        MnemonicHandler.repaintMnemonicsInWindow(win);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsPopupMenuUI.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,2 @@\n+import sun.swing.MnemonicHandler;\n+\n@@ -96,2 +98,2 @@\n-                WindowsLookAndFeel.setMnemonicHidden(false);\n-                WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                MnemonicHandler.setMnemonicHidden(false);\n+                MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -101,2 +103,2 @@\n-                WindowsLookAndFeel.setMnemonicHidden(false);\n-                WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                MnemonicHandler.setMnemonicHidden(false);\n+                MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -116,2 +118,2 @@\n-                WindowsLookAndFeel.setMnemonicHidden(true);\n-                WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                MnemonicHandler.setMnemonicHidden(true);\n+                MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -154,3 +156,3 @@\n-                } else if(!WindowsLookAndFeel.isMnemonicHidden()) {\n-                    WindowsLookAndFeel.setMnemonicHidden(true);\n-                    WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                } else if (!MnemonicHandler.isMnemonicHidden()) {\n+                    MnemonicHandler.setMnemonicHidden(true);\n+                    MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -160,2 +162,2 @@\n-                    WindowsLookAndFeel.setMnemonicHidden(true);\n-                    WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                    MnemonicHandler.setMnemonicHidden(true);\n+                    MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -196,2 +198,2 @@\n-                            WindowsLookAndFeel.setMnemonicHidden(true);\n-                            WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                            MnemonicHandler.setMnemonicHidden(true);\n+                            MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n@@ -205,3 +207,3 @@\n-                if (WindowsLookAndFeel.isMnemonicHidden() && ev.isAltDown()) {\n-                    WindowsLookAndFeel.setMnemonicHidden(false);\n-                    WindowsGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n+                if (MnemonicHandler.isMnemonicHidden() && ev.isAltDown()) {\n+                    MnemonicHandler.setMnemonicHidden(false);\n+                    MnemonicHandler.repaintMnemonicsInWindow(winAncestor);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRootPaneUI.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,3 +158,3 @@\n- * Note the term <i>class file<\/i> is used as defined in section 3.1 of\n- * <cite>The Java Virtual Machine Specification<\/cite>, to mean a\n- * sequence of bytes in class file format, whether or not they reside in a\n+ * Note the term <i>class file<\/i> is used as defined in chapter {@jvms 4} The\n+ * {@code class} File Format of <cite>The Java Virtual Machine Specification<\/cite>,\n+ * to mean a sequence of bytes in class file format, whether or not they reside in a\n@@ -163,0 +163,17 @@\n+ * @apiNote\n+ * Great care must be taken when transforming core JDK classes which are at the\n+ * same time required during the transformation process as this can lead to class\n+ * circularity or linkage errors.\n+ *\n+ * <P>\n+ * If for example the invocation of {@link #transform transform()} for a class\n+ * {@code C} requires loading or resolving the same class {@code C},\n+ * an error is thrown that is an instance of {@link LinkageError} (or a subclass).\n+ * If the {@link LinkageError} occurs during reference resolution (see section\n+ * {@jvms 5.4.3} Resolution of <cite>The Java Virtual Machine Specification<\/cite>)\n+ * for a class {@code D}, the resolution of the corresponding reference in class\n+ * {@code D} will permanently fail with the same error at any subsequent attempt.\n+ * This means that a {@link LinkageError} triggered during transformation of\n+ * {@code C} in a class {@code D} not directly related to {@code C} can repeatedly\n+ * occur later in arbitrary user code which uses {@code D}.\n+ *\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/ClassFileTransformer.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-     * max retry time for a single KDC, default Krb5.KDC_RETRY_LIMIT (3)\n+     * max retry time for a single KDC, default Krb5.KDC_RETRY_LIMIT (3),\n+     * Must be > 0.\n@@ -69,1 +70,2 @@\n-     * timeout requesting a ticket from KDC, in millisec, default 30 sec\n+     * timeout requesting a ticket from KDC, in millisec, default\n+     * Krb5.KDC_TIMEOUT (30000). Must be > 0.\n@@ -73,1 +75,2 @@\n-     * max UDP packet size, default unlimited (-1)\n+     * max UDP packet size, default Krb5.KDC_DEFAULT_UDP_PREF_LIMIT (1465).\n+     * Must be >= 0 and <= Krb5.KDC_HARD_UDP_LIMIT (32700).\n@@ -149,1 +152,1 @@\n-            max_retries = parsePositiveIntString(temp);\n+            max_retries = parseNonNegativeIntString(temp);\n@@ -151,1 +154,1 @@\n-            udp_pref_limit = parsePositiveIntString(temp);\n+            udp_pref_limit = parseNonNegativeIntString(temp);\n@@ -160,1 +163,1 @@\n-        defaultKdcTimeout = timeout > 0 ? timeout : 30*1000; \/\/ 30 seconds\n+        defaultKdcTimeout = timeout > 0 ? timeout : Krb5.KDC_TIMEOUT;\n@@ -178,1 +181,1 @@\n-    private String realm;\n+    private final String realm;\n@@ -182,1 +185,1 @@\n-           realm = Config.getInstance().getDefaultRealm();\n+            realm = Config.getInstance().getDefaultRealm();\n@@ -194,1 +197,1 @@\n-                realm, \"udp_preference_limit\", defaultUdpPrefLimit);\n+                realm, \"udp_preference_limit\", defaultUdpPrefLimit, false);\n@@ -197,2 +200,1 @@\n-        boolean useTCP = (udpPrefLimit > 0 &&\n-             (obuf != null && obuf.length > udpPrefLimit));\n+        boolean useTCP = obuf != null && obuf.length > udpPrefLimit;\n@@ -210,8 +212,0 @@\n-        if (realm == null) {\n-            realm = cfg.getDefaultRealm();\n-            if (realm == null) {\n-                throw new KrbException(Krb5.KRB_ERR_GENERIC,\n-                                       \"Cannot find default realm\");\n-            }\n-        }\n-\n@@ -299,1 +293,1 @@\n-                realm, \"max_retries\", defaultKdcRetryLimit);\n+                realm, \"max_retries\", defaultKdcRetryLimit, true);\n@@ -301,1 +295,1 @@\n-                realm, \"kdc_timeout\", defaultKdcTimeout);\n+                realm, \"kdc_timeout\", defaultKdcTimeout, true);\n@@ -342,1 +336,1 @@\n-            int tempPort = parsePositiveIntString(portStr);\n+            int tempPort = parseNonNegativeIntString(portStr);\n@@ -447,1 +441,1 @@\n-            int seconds = parsePositiveIntString(s.substring(0, s.length()-1));\n+            int seconds = parseNonNegativeIntString(s.substring(0, s.length()-1));\n@@ -450,1 +444,1 @@\n-            return parsePositiveIntString(s);\n+            return parseNonNegativeIntString(s);\n@@ -464,0 +458,1 @@\n+     * @param mustBePositive true if value must be >0, false if value must be >=0\n@@ -466,1 +461,2 @@\n-    private int getRealmSpecificValue(String realm, String key, int defValue) {\n+    private int getRealmSpecificValue(String realm, String key, int defValue,\n+            boolean mustBePositive) {\n@@ -478,1 +474,1 @@\n-                temp = parsePositiveIntString(value);\n+                temp = parseNonNegativeIntString(value);\n@@ -484,1 +480,5 @@\n-        if (temp > 0) v = temp;\n+        if (mustBePositive) {\n+            if (temp > 0) v = temp;\n+        } else {\n+            if (temp >= 0) v = temp;\n+        }\n@@ -489,1 +489,1 @@\n-    private static int parsePositiveIntString(String intString) {\n+    private static int parseNonNegativeIntString(String intString) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/KdcComm.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    public static final int KDC_TIMEOUT = 30000;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/Krb5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n- * <th scope=\"row\" valign='top' rowspan='1' colspan='1'>\n+ * <th scope=\"row\">\n@@ -129,1 +129,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -132,1 +132,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -135,1 +135,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -140,3 +140,2 @@\n- * <th scope=\"row\" valign='top' rowspan='1' colspan='1'>Built-in\n- * character entity<\/th>\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <th scope=\"row\">Built-in character entity<\/th>\n+ * <td>\n@@ -145,1 +144,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -148,1 +147,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -153,4 +152,3 @@\n- * <th scope=\"row\" valign='top' rowspan='1' colspan='1'>Literal newline between<\/th>\n- * <td valign='top' rowspan='1' colspan='1'>\n- * <pre>\n- * \"x=5&amp;#10;y=6\"<\/pre>\n+ * <th scope=\"row\">Literal newline between<\/th>\n+ * <td>\n+ * <pre>\"x=5&amp;#10;y=6\"<\/pre>\n@@ -158,1 +156,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -161,1 +159,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -166,2 +164,2 @@\n- * <th scope=\"row\" valign='top' rowspan='1' colspan='1'>Normalized newline between<\/th>\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <th scope=\"row\">Normalized newline between<\/th>\n+ * <td>\n@@ -171,1 +169,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -174,1 +172,1 @@\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <td>\n@@ -179,2 +177,2 @@\n- * <th scope=\"row\" valign='top' rowspan='1' colspan='1'>Entity <code>e<\/code> with literal newline<\/th>\n- * <td valign='top' rowspan='1' colspan='1'>\n+ * <th scope=\"row\">Entity <code>e<\/code> with literal newline<\/th>\n+ * <td>\n@@ -184,2 +182,2 @@\n- * <td valign='top' rowspan='1' colspan='1'><em>Dependent on Implementation and Load Options<\/em><\/td>\n- * <td valign='top' rowspan='1' colspan='1'><em>Dependent on Implementation and Load\/Save Options<\/em><\/td>\n+ * <td><em>Dependent on Implementation and Load Options<\/em><\/td>\n+ * <td><em>Dependent on Implementation and Load\/Save Options<\/em><\/td>\n","filename":"src\/java.xml\/share\/classes\/org\/w3c\/dom\/Attr.java","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-\/* convert jstring to C string *\/\n-static void jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, int len);\n+\/* Converts jstring to C string, returns JNI_FALSE if the string has been truncated. *\/\n+static jboolean jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, size_t cstr_buf_size);\n@@ -78,3 +78,3 @@\n-   char cmd[MAX_CMD_LENGTH];                \/* \"load\", \"dump\", ...      *\/\n-   char arg[MAX_ARGS][MAX_ARG_LENGTH];      \/* arguments to command     *\/\n-   char pipename[MAX_PIPE_NAME_LENGTH];\n+   char cmd[MAX_CMD_LENGTH + 1];            \/* \"load\", \"dump\", ...      *\/\n+   char arg[MAX_ARGS][MAX_ARG_LENGTH + 1];  \/* arguments to command     *\/\n+   char pipename[MAX_PIPE_NAME_LENGTH + 1];\n@@ -380,1 +380,0 @@\n-\n@@ -413,1 +412,5 @@\n-    jstring_to_cstring(env, cmd, data.cmd, MAX_CMD_LENGTH);\n+    if (!jstring_to_cstring(env, cmd, data.cmd, sizeof(data.cmd))) {\n+        JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                        \"command is too long\");\n+        return;\n+    }\n@@ -426,1 +429,5 @@\n-                jstring_to_cstring(env, obj, data.arg[i], MAX_ARG_LENGTH);\n+                if (!jstring_to_cstring(env, obj, data.arg[i], sizeof(data.arg[i]))) {\n+                    JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                                    \"argument is too long\");\n+                    return;\n+                }\n@@ -436,1 +443,5 @@\n-    jstring_to_cstring(env, pipename, data.pipename, MAX_PIPE_NAME_LENGTH);\n+    if (!jstring_to_cstring(env, pipename, data.pipename, sizeof(data.pipename))) {\n+        JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                        \"pipe name is too long\");\n+        return;\n+    }\n@@ -618,2 +629,2 @@\n-\/* convert jstring to C string *\/\n-static void jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, int len) {\n+\/* Converts jstring to C string, returns JNI_FALSE if the string has been truncated. *\/\n+static jboolean jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, size_t cstr_buf_size) {\n@@ -622,0 +633,1 @@\n+    jboolean result = JNI_TRUE;\n@@ -627,1 +639,6 @@\n-        if ((*env)->ExceptionOccurred(env)) return;\n+        if ((*env)->ExceptionOccurred(env)) {\n+            return result;\n+        }\n+        if (strlen(str) >= cstr_buf_size) {\n+            result = JNI_FALSE;\n+        }\n@@ -629,2 +646,2 @@\n-        strncpy(cstr, str, len);\n-        cstr[len-1] = '\\0';\n+        strncpy(cstr, str, cstr_buf_size);\n+        cstr[cstr_buf_size - 1] = '\\0';\n@@ -635,0 +652,1 @@\n+    return result;\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -516,1 +516,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n@@ -1558,15 +1574,0 @@\n-        public RecordComponent findRecordComponentToRemove(JCVariableDecl var) {\n-            RecordComponent toRemove = null;\n-            for (RecordComponent rc : recordComponents) {\n-                \/* it could be that a record erroneously declares two record components with the same name, in that\n-                 * case we need to use the position to disambiguate, but if we loaded the record from a class file\n-                 * all positions will be -1, in that case we have to ignore the position and match only based on the\n-                 * name\n-                 *\/\n-                if (rc.name == var.name && (var.pos == rc.pos || rc.pos == -1)) {\n-                    toRemove = rc;\n-                }\n-            }\n-            return toRemove;\n-        }\n-\n@@ -1578,3 +1579,10 @@\n-            if (existing != null) {\n-                recordComponents = List.filter(recordComponents, existing);\n-                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+            if (existing != null && !recordComponents.isEmpty()) {\n+                ListBuffer<RecordComponent> newRComps = new ListBuffer<>();\n+                for (RecordComponent rcomp : recordComponents) {\n+                    if (existing == rcomp) {\n+                        newRComps.add(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+                    } else {\n+                        newRComps.add(rcomp);\n+                    }\n+                }\n+                recordComponents = newRComps.toList();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n+\n@@ -102,0 +104,1 @@\n+    public final boolean dumpStacktraceOnError;\n@@ -128,0 +131,2 @@\n+        Options options = Options.instance(context);\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -642,1 +647,1 @@\n-    public static class FunctionDescriptorLookupError extends RuntimeException {\n+    public static class FunctionDescriptorLookupError extends CompilerInternalException {\n@@ -647,1 +652,2 @@\n-        FunctionDescriptorLookupError() {\n+        FunctionDescriptorLookupError(boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -659,6 +665,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n@@ -817,1 +817,1 @@\n-            return new FunctionDescriptorLookupError().setMessage(diag);\n+            return new FunctionDescriptorLookupError(Types.this.dumpStacktraceOnError).setMessage(diag);\n@@ -5133,1 +5133,1 @@\n-    public abstract static class SignatureGenerator {\n+    public abstract class SignatureGenerator {\n@@ -5135,1 +5135,1 @@\n-        public static class InvalidSignatureException extends RuntimeException {\n+        public class InvalidSignatureException extends CompilerInternalException {\n@@ -5140,1 +5140,2 @@\n-            InvalidSignatureException(Type type) {\n+            InvalidSignatureException(Type type, boolean dumpStackTraceOnError) {\n+                super(dumpStackTraceOnError);\n@@ -5147,6 +5148,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -5155,2 +5150,0 @@\n-        private final Types types;\n-\n@@ -5162,4 +5155,0 @@\n-        protected SignatureGenerator(Types types) {\n-            this.types = types;\n-        }\n-\n@@ -5167,1 +5156,1 @@\n-            throw new InvalidSignatureException(t);\n+            throw new InvalidSignatureException(t, Types.this.dumpStacktraceOnError);\n@@ -5283,1 +5272,1 @@\n-                        c.name == types.names.empty; \/\/ or anonymous\n+                        c.name == Types.this.names.empty; \/\/ or anonymous\n@@ -5285,1 +5274,1 @@\n-                        ? types.erasure(outer)\n+                        ? Types.this.erasure(outer)\n@@ -5307,1 +5296,1 @@\n-                List<Type> bounds = types.getBounds(tvar);\n+                List<Type> bounds = Types.this.getBounds(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -961,1 +961,7 @@\n-        Scope scope = targetContainerType.tsym.members();\n+        Scope scope = null;\n+        try {\n+            scope = targetContainerType.tsym.members();\n+        } catch (CompletionFailure ex) {\n+            chk.completionError(pos, ex);\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5273,8 +5273,1 @@\n-        Type underlyingType =\n-                attribTree(tree.underlyingType, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (underlyingType.hasTag(PACKAGE)) {\n-            \/\/ Type annotations are not admissible on packages, but we handle packages here to\n-            \/\/ report better diagnostics later in validateAnnotatedType.\n-            result = tree.type = underlyingType;\n-            return;\n-        }\n+        Type underlyingType = attribType(tree.underlyingType, env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -790,1 +790,1 @@\n-            Set<Object> booleanLiterals = new HashSet<>();\n+            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n@@ -803,1 +803,1 @@\n-                            booleanLiterals.add(value);\n+                            booleanLiterals.remove(value);\n@@ -820,1 +820,1 @@\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.util.CompilerInternalException;\n@@ -71,1 +72,1 @@\n-import java.util.Comparator;\n+import static com.sun.tools.javac.main.Option.DOE;\n@@ -100,0 +101,2 @@\n+    private final boolean dumpStacktraceOnError;\n+\n@@ -122,0 +125,1 @@\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -136,2 +140,2 @@\n-        InferenceException() {\n-            super(null);\n+        InferenceException(boolean dumpStacktrace) {\n+            super(null, dumpStacktrace);\n@@ -147,1 +151,1 @@\n-        InferenceException result = new InferenceException();\n+        InferenceException result = new InferenceException(dumpStacktraceOnError);\n@@ -1345,1 +1349,1 @@\n-        public static class NodeNotFoundException extends RuntimeException {\n+        class NodeNotFoundException extends CompilerInternalException {\n@@ -1350,1 +1354,2 @@\n-            public NodeNotFoundException(InferenceGraph graph) {\n+            public NodeNotFoundException(InferenceGraph graph, boolean dumpStacktraceOnError) {\n+                super(dumpStacktraceOnError);\n@@ -1353,6 +1358,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -1378,1 +1377,1 @@\n-                throw new NodeNotFoundException(g);\n+                throw new NodeNotFoundException(g, Infer.this.dumpStacktraceOnError);\n@@ -1453,1 +1452,1 @@\n-                throw new NodeNotFoundException(g);\n+                throw new NodeNotFoundException(g, Infer.this.dumpStacktraceOnError);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1294,0 +1294,1 @@\n+            Assert.check(sym.kind != TYP);\n@@ -1299,1 +1300,1 @@\n-                        if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {\n+                        if (clazz.isSubClass(sym.enclClass(), types)) {\n@@ -1798,1 +1799,1 @@\n-            super(types);\n+            types.super();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -42,1 +41,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -67,0 +65,1 @@\n+\n@@ -70,2 +69,0 @@\n-import javax.lang.model.type.TypeKind;\n-\n@@ -380,4 +377,0 @@\n-                } else {\n-                    if (outerThisStack.head != null &&\n-                        outerThisStack.head != _sym)\n-                        visitSymbol(outerThisStack.head);\n@@ -387,40 +380,0 @@\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            if (tree.encl == null &&\n-                c.hasOuterInstance() &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitNewClass(tree);\n-        }\n-\n-        \/** If tree refers to a qualified this or super expression\n-         *  for anything but the current class, add the outer this\n-         *  stack as a free variable.\n-         *\/\n-        public void visitSelect(JCFieldAccess tree) {\n-            if ((tree.name == names._this || tree.name == names._super) &&\n-                tree.selected.type.tsym != clazz &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitSelect(tree);\n-        }\n-\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                Symbol constructor = TreeInfo.symbol(tree.meth);\n-                ClassSymbol c = (ClassSymbol)constructor.owner;\n-                if (c.hasOuterInstance() &&\n-                    !tree.meth.hasTag(SELECT) &&\n-                    outerThisStack.head != null)\n-                    visitSymbol(outerThisStack.head);\n-            }\n-            super.visitApply(tree);\n-        }\n-\n@@ -1599,1 +1552,1 @@\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n+        Type target = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -1885,1 +1838,0 @@\n-        Symbol c = sym.owner;\n@@ -1889,1 +1841,1 @@\n-            return make.at(pos).This(c.erasure(types));\n+            return make.at(pos).This(currentClass.erasure(types));\n@@ -2689,1 +2641,1 @@\n-            super(types);\n+            types.super();\n@@ -3118,1 +3070,1 @@\n-                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);\n+                thisArg = makeThis(tree.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3335,1 +3287,1 @@\n-                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);\n+                    thisArg = makeThis(tree.meth.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3406,0 +3358,3 @@\n+        Assert.check(!type.hasTag(VOID));\n+        if (type.hasTag(NONE))\n+            return tree;\n@@ -3922,0 +3877,3 @@\n+            \/\/ represent void results as NO_TYPE, to avoid unnecessary boxing in boxIfNeeded\n+            if (currentRestype.hasTag(VOID))\n+                currentRestype = Type.noType;\n@@ -3931,331 +3889,0 @@\n-    @Override\n-    public void visitReference(JCMemberReference tree) {\n-        if (needsConversionToLambda(tree)) {\n-            \/\/ Convert to a lambda, and process as such\n-            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n-            result = translate(conv.lambda());\n-        } else {\n-            super.visitReference(tree);\n-        }\n-    }\n-    \/\/ where\n-        boolean needsVarArgsConversion(JCMemberReference tree) {\n-            return tree.varargsElement != null;\n-        }\n-\n-        \/**\n-         * @return Is this an array operation like clone()\n-         *\/\n-        boolean isArrayOp(JCMemberReference tree) {\n-            return tree.sym.owner == syms.arrayClass;\n-        }\n-\n-        boolean receiverAccessible(JCMemberReference tree) {\n-            \/\/hack needed to workaround 292 bug (7087658)\n-            \/\/when 292 issue is fixed we should remove this and change the backend\n-            \/\/code to always generate a method handle to an accessible method\n-            return tree.ownerAccessible;\n-        }\n-\n-        \/**\n-         * Erasure destroys the implementation parameter subtype\n-         * relationship for intersection types.\n-         * Have similar problems for union types too.\n-         *\/\n-        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n-            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-            for (; tl.nonEmpty(); tl = tl.tail) {\n-                Type pt = tl.head;\n-                if (isIntersectionOrUnionType(pt))\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        boolean isIntersectionOrUnionType(Type t) {\n-            switch (t.getKind()) {\n-                case INTERSECTION:\n-                case UNION:\n-                    return true;\n-                case TYPEVAR:\n-                    TypeVar tv = (TypeVar) t;\n-                    return isIntersectionOrUnionType(tv.getUpperBound());\n-            }\n-            return false;\n-        }\n-\n-        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                              Symbol currentClass) {\n-            return ((targetReference.flags() & PROTECTED) != 0 &&\n-                    targetReference.packge() != currentClass.packge());\n-        }\n-\n-        \/**\n-         * This method should be called only when target release <= 14\n-         * where LambdaMetaFactory does not spin nestmate classes.\n-         *\n-         * This method should be removed when --release 14 is not supported.\n-         *\/\n-        boolean isPrivateInOtherClass(JCMemberReference tree) {\n-            assert !target.runtimeUseNestAccess();\n-            return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                    !types.isSameType(\n-                            types.erasure(tree.sym.enclClass().asType()),\n-                            types.erasure(currentClass.asType()));\n-        }\n-\n-        \/**\n-         * Does this reference need to be converted to a lambda\n-         * (i.e. var args need to be expanded or \"super\" is used)\n-         *\/\n-        boolean needsConversionToLambda(JCMemberReference tree) {\n-            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n-                    tree.hasKind(ReferenceKind.SUPER) ||\n-                    needsVarArgsConversion(tree) ||\n-                    isArrayOp(tree) ||\n-                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n-                    !receiverAccessible(tree) ||\n-                    (tree.getMode() == ReferenceMode.NEW &&\n-                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-        }\n-\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree) {\n-            this.tree = tree;\n-        }\n-\n-        JCExpression lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                slam.wasMethodReference = true;\n-                if (receiverExpression != null) {\n-                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n-                    return make.at(tree.pos).LetExpr(\n-                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n-                } else {\n-                    return slam;\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n-                    rcvr.pos = tree.pos;\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                    : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                            makeReceiver(rcvr) :\n-                            tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-        Assert.check(meth.kind == MTH);\n-        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-        if (varargsElement != null) {\n-            Assert.check((meth.flags() & VARARGS) != 0);\n-        }\n-        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":12,"deletions":385,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -333,0 +333,1 @@\n+                    decl.sym = syms.errModule;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n@@ -115,0 +116,1 @@\n+    final boolean dumpStacktraceOnError;\n@@ -152,0 +154,1 @@\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -592,1 +595,1 @@\n-                throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));\n+                throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))), dumpStacktraceOnError);\n@@ -601,1 +604,1 @@\n-                        throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));\n+                        throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)), dumpStacktraceOnError);\n@@ -838,1 +841,1 @@\n-                methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));\n+                getMethodCheckFailure().setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));\n@@ -850,1 +853,1 @@\n-                super(null);\n+                super(null, Resolve.this.dumpStacktraceOnError);\n@@ -859,1 +862,1 @@\n-        SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();\n+        private SharedInapplicableMethodException methodCheckFailure;\n@@ -865,0 +868,3 @@\n+        private SharedInapplicableMethodException getMethodCheckFailure() {\n+            return methodCheckFailure == null ? methodCheckFailure = new SharedInapplicableMethodException() : methodCheckFailure;\n+        }\n@@ -1044,1 +1050,1 @@\n-            throw new InapplicableMethodException(details);\n+            throw new InapplicableMethodException(details, Resolve.this.dumpStacktraceOnError);\n@@ -1400,1 +1406,1 @@\n-    public static class InapplicableMethodException extends RuntimeException {\n+    public static class InapplicableMethodException extends CompilerInternalException {\n@@ -1405,1 +1411,2 @@\n-        InapplicableMethodException(JCDiagnostic diag) {\n+        InapplicableMethodException(JCDiagnostic diag, boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -1412,6 +1419,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,2 @@\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n+\n@@ -788,1 +790,1 @@\n-            super(types);\n+            types.super();\n@@ -1263,1 +1265,5 @@\n-                        tree.body = make.Block(0, List.of(make.Return(value)));\n+                        if (value.type.hasTag(VOID)) {\n+                            tree.body = make.Block(0, List.of(make.Exec(value)));\n+                        } else {\n+                            tree.body = make.Block(0, List.of(make.Return(value)));\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -33,0 +34,2 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.jvm.Target;\n@@ -49,0 +52,2 @@\n+import javax.lang.model.type.TypeKind;\n+\n@@ -78,0 +83,1 @@\n+    private final Target target;\n@@ -92,0 +98,1 @@\n+        target = Target.instance(context);\n@@ -542,0 +549,262 @@\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            Type t = types.skipTypeVars(tree.expr.type, false);\n+            Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n+            if (tree.kind == ReferenceKind.UNBOUND) {\n+                tree.expr = make.Type(receiverTarget);\n+            } else {\n+                tree.expr = translate(tree.expr, receiverTarget);\n+            }\n+            if (!tree.type.isIntersection()) {\n+                tree.type = erasure(tree.type);\n+            } else {\n+                tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n+            }\n+            result = tree;\n+        }\n+    }\n+    \/\/ where\n+    boolean needsVarArgsConversion(JCMemberReference tree) {\n+        return tree.varargsElement != null;\n+    }\n+\n+    \/**\n+     * @return Is this an array operation like clone()\n+     *\/\n+    boolean isArrayOp(JCMemberReference tree) {\n+        return tree.sym.owner == syms.arrayClass;\n+    }\n+\n+    boolean receiverAccessible(JCMemberReference tree) {\n+        \/\/hack needed to workaround 292 bug (7087658)\n+        \/\/when 292 issue is fixed we should remove this and change the backend\n+        \/\/code to always generate a method handle to an accessible method\n+        return tree.ownerAccessible;\n+    }\n+\n+    \/**\n+     * Erasure destroys the implementation parameter subtype\n+     * relationship for intersection types.\n+     * Have similar problems for union types too.\n+     *\/\n+    boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+        List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+        for (; tl.nonEmpty(); tl = tl.tail) {\n+            Type pt = tl.head;\n+            if (isIntersectionOrUnionType(pt))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean isIntersectionOrUnionType(Type t) {\n+        return switch (t.getKind()) {\n+            case INTERSECTION, UNION -> true;\n+            case TYPEVAR -> {\n+                TypeVar tv = (TypeVar) t;\n+                yield isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                          Symbol currentClass) {\n+        return ((targetReference.flags() & PROTECTED) != 0 &&\n+                targetReference.packge() != currentClass.packge());\n+    }\n+\n+    \/**\n+     * This method should be called only when target release <= 14\n+     * where LambdaMetaFactory does not spin nestmate classes.\n+     *\n+     * This method should be removed when --release 14 is not supported.\n+     *\/\n+    boolean isPrivateInOtherClass(JCMemberReference tree) {\n+        return (tree.sym.flags() & PRIVATE) != 0 &&\n+                !types.isSameType(\n+                        types.erasure(tree.sym.enclClass().asType()),\n+                        types.erasure(env.enclClass.sym.asType()));\n+    }\n+\n+    \/**\n+     * Does this reference need to be converted to a lambda\n+     * (i.e. var args need to be expanded or \"super\" is used)\n+     *\/\n+    boolean needsConversionToLambda(JCMemberReference tree) {\n+        return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                tree.hasKind(ReferenceKind.SUPER) ||\n+                needsVarArgsConversion(tree) ||\n+                isArrayOp(tree) ||\n+                (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, env.enclClass.sym) ||\n+                !receiverAccessible(tree) ||\n+                (tree.getMode() == ReferenceMode.NEW &&\n+                        tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                        (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+    }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, env.enclClass.sym);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, receiverExpression), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = descPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ Use the descriptor parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            make.Ident(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            args.toList()).setType(tree.referentType.getReturnType());\n+\n+            TreeInfo.setVarargsElement(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                TreeInfo.setVarargsElement(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n@@ -863,18 +1132,0 @@\n-    public void visitReference(JCMemberReference tree) {\n-        Type t = types.skipTypeVars(tree.expr.type, false);\n-        Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n-        if (tree.kind == ReferenceKind.UNBOUND) {\n-            tree.expr = make.Type(receiverTarget);\n-        } else {\n-            tree.expr = translate(tree.expr, receiverTarget);\n-        }\n-        if (!tree.type.isIntersection()) {\n-            tree.type = erasure(tree.type);\n-        } else {\n-            tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n-        }\n-        if (tree.varargsElement != null)\n-            tree.varargsElement = erasure(tree.varargsElement);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":269,"deletions":18,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -1052,0 +1052,1 @@\n+                int fieldPos = 0;\n@@ -1067,2 +1068,2 @@\n-                     *  First, we find the record component by comparing its name and position with current field,\n-                     *  if any, and we mark it. Then we copy the annotations to the field so that annotations applicable only to the record component\n+                     *  First, we get the record component matching the field position. Then we copy the annotations\n+                     *  to the field so that annotations applicable only to the record component\n@@ -1073,1 +1074,1 @@\n-                    RecordComponent rc = sym.findRecordComponentToRemove(field);\n+                    RecordComponent rc = getRecordComponentAt(sym, fieldPos);\n@@ -1077,2 +1078,1 @@\n-                        List<JCAnnotation> originalAnnos = tc.copy(rc.getOriginalAnnos());\n-                        field.mods.annotations = originalAnnos;\n+                        field.mods.annotations = tc.copy(rc.getOriginalAnnos());\n@@ -1085,0 +1085,1 @@\n+                    fieldPos++;\n@@ -1099,0 +1100,12 @@\n+    \/\/ where\n+        private RecordComponent getRecordComponentAt(ClassSymbol sym, int componentPos) {\n+            int i = 0;\n+            for (RecordComponent rc : sym.getRecordComponents()) {\n+                if (i == componentPos) {\n+                    return rc;\n+                }\n+                i++;\n+            }\n+            return null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        this.signatureGen = new SharedSignatureGenerator(types);\n+        this.signatureGen = new SharedSignatureGenerator();\n@@ -295,2 +295,2 @@\n-        SharedSignatureGenerator(Types types) {\n-            super(types);\n+        SharedSignatureGenerator() {\n+            types.super();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-     * @throws ClassNotFoundException if the class cannot be located\n@@ -190,1 +189,1 @@\n-    ClassLoader newClassLoaderFor(ClassLoader parent, String mainClassName) throws ClassNotFoundException, Fault {\n+    ClassLoader newClassLoaderFor(ClassLoader parent, String mainClassName) throws Fault {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+        ClassLoader loader = context.newClassLoaderFor(parentLoader, firstClassName);\n+        Thread.currentThread().setContextClassLoader(loader);\n@@ -202,1 +204,0 @@\n-            ClassLoader loader = context.newClassLoaderFor(parentLoader, firstClassName);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.util;\n+\n+\/** The super class of all compiler internal exceptions\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class CompilerInternalException extends RuntimeException {\n+    private static final long serialVersionUID = 0;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public CompilerInternalException(boolean dumpStackTraceOnError) {\n+        \/* by default the stacktrace wont be filled, meaning that method CompilerInternalException::fillInStackTrace\n+         * will always be invoked, if we do want to dump the stacktrace then we will invoke super::fillInStackTrace\n+         * there is a bit of a dance here that could be fixed once flexible constructor bodies exits the preview\n+         * state\n+         *\/\n+        if (dumpStackTraceOnError) {\n+            super.fillInStackTrace();\n+        }\n+    }\n+\n+    @Override\n+    public Throwable fillInStackTrace() {\n+        return this;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/CompilerInternalException.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -710,0 +710,1 @@\n+-method name phiMix descriptor (I)I\n@@ -802,0 +803,4 @@\n+class name jdk\/internal\/classfile\/impl\/BufferedCodeBuilder\n+header extends java\/lang\/Object implements jdk\/internal\/classfile\/impl\/TerminalCodeBuilder nestMembers jdk\/internal\/classfile\/impl\/BufferedCodeBuilder$Model flags 31\n+innerclass innerClass jdk\/internal\/classfile\/impl\/BufferedCodeBuilder$Model outerClass jdk\/internal\/classfile\/impl\/BufferedCodeBuilder innerClassName Model flags 11\n+\n@@ -917,0 +922,10 @@\n+class name jdk\/internal\/classfile\/impl\/DirectCodeBuilder\n+header extends jdk\/internal\/classfile\/impl\/AbstractDirectBuilder implements jdk\/internal\/classfile\/impl\/TerminalCodeBuilder flags 31 signature Ljdk\/internal\/classfile\/impl\/AbstractDirectBuilder<Ljava\/lang\/classfile\/CodeModel;>;Ljdk\/internal\/classfile\/impl\/TerminalCodeBuilder;\n+innerclass innerClass java\/lang\/classfile\/ClassFile$ShortJumpsOption outerClass java\/lang\/classfile\/ClassFile innerClassName ShortJumpsOption flags 4019\n+innerclass innerClass jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction$ExceptionCatchImpl outerClass jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction innerClassName ExceptionCatchImpl flags 19\n+innerclass innerClass java\/lang\/classfile\/ClassFile$DeadLabelsOption outerClass java\/lang\/classfile\/ClassFile innerClassName DeadLabelsOption flags 4019\n+innerclass innerClass java\/lang\/classfile\/ClassFile$DebugElementsOption outerClass java\/lang\/classfile\/ClassFile innerClassName DebugElementsOption flags 4019\n+\n+class name jdk\/internal\/classfile\/impl\/LabelContext\n+header extends java\/lang\/Object sealed true permittedSubclasses jdk\/internal\/classfile\/impl\/TerminalCodeBuilder,jdk\/internal\/classfile\/impl\/CodeImpl flags 601\n+\n@@ -1020,0 +1035,6 @@\n+class name jdk\/internal\/classfile\/impl\/TerminalCodeBuilder\n+header extends java\/lang\/Object implements java\/lang\/classfile\/CodeBuilder,jdk\/internal\/classfile\/impl\/LabelContext sealed true permittedSubclasses jdk\/internal\/classfile\/impl\/DirectCodeBuilder,jdk\/internal\/classfile\/impl\/BufferedCodeBuilder flags 601\n+method name curTopLocal descriptor ()I flags 401\n+\n+-class name jdk\/internal\/classfile\/impl\/TransformingCodeBuilder\n+\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-N.sym.txt","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -564,2 +564,13 @@\n-            if (keySensitive) {\n-                return new P11RSAPrivateKeyInternal(session, keyID, algorithm,\n+            P11RSAPrivateKeyInternal p11Key = null;\n+            if (!keySensitive) {\n+                \/\/ Key is not sensitive: try to interpret as CRT or non-CRT.\n+                p11Key = asCRT(session, keyID, algorithm, keyLength, attrs);\n+                if (p11Key == null) {\n+                    p11Key = asNonCRT(session, keyID, algorithm, keyLength,\n+                            attrs);\n+                }\n+            }\n+            if (p11Key == null) {\n+                \/\/ Key is sensitive or there was a failure while querying its\n+                \/\/ attributes: handle as opaque.\n+                p11Key = new P11RSAPrivateKeyInternal(session, keyID, algorithm,\n@@ -567,20 +578,17 @@\n-            } else {\n-                CK_ATTRIBUTE[] rsaAttrs = new CK_ATTRIBUTE[] {\n-                        new CK_ATTRIBUTE(CKA_MODULUS),\n-                        new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PRIME_1),\n-                        new CK_ATTRIBUTE(CKA_PRIME_2),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-                };\n-                boolean isCRT = true;\n-                Session tempSession = null;\n-                try {\n-                    tempSession = session.token.getOpSession();\n-                    session.token.p11.C_GetAttributeValue(tempSession.id(),\n-                            keyID, rsaAttrs);\n-                    for (CK_ATTRIBUTE attr : rsaAttrs) {\n-                        isCRT &= (attr.pValue instanceof byte[]);\n-                        if (!isCRT) break;\n+            }\n+            return p11Key;\n+        }\n+\n+        private static CK_ATTRIBUTE[] tryFetchAttributes(Session session,\n+                long keyID, long... attrTypes) {\n+            int i = 0;\n+            CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[attrTypes.length];\n+            for (long attrType : attrTypes) {\n+                attrs[i++] = new CK_ATTRIBUTE(attrType);\n+            }\n+            try {\n+                session.token.p11.C_GetAttributeValue(session.id(), keyID,\n+                        attrs);\n+                for (CK_ATTRIBUTE attr : attrs) {\n+                    if (!(attr.pValue instanceof byte[])) {\n+                        return null;\n@@ -588,15 +596,0 @@\n-                } catch (PKCS11Exception e) {\n-                    \/\/ ignore, assume not available\n-                    isCRT = false;\n-                } finally {\n-                    session.token.releaseSession(tempSession);\n-                }\n-                BigInteger n = rsaAttrs[0].getBigInteger();\n-                BigInteger d = rsaAttrs[1].getBigInteger();\n-                if (isCRT) {\n-                    return new P11RSAPrivateKey(session, keyID, algorithm,\n-                           keyLength, attrs, n, d,\n-                           Arrays.copyOfRange(rsaAttrs, 2, rsaAttrs.length));\n-                } else {\n-                    return new P11RSAPrivateNonCRTKey(session, keyID,\n-                           algorithm, keyLength, attrs, n, d);\n@@ -604,0 +597,30 @@\n+                return attrs;\n+            } catch (PKCS11Exception ignored) {\n+                \/\/ ignore, assume not available\n+                return null;\n+            }\n+        }\n+\n+        private static P11RSAPrivateKeyInternal asCRT(Session session,\n+                long keyID, String algorithm, int keyLength,\n+                CK_ATTRIBUTE[] attrs) {\n+            CK_ATTRIBUTE[] rsaCRTAttrs = tryFetchAttributes(session, keyID,\n+                    CKA_MODULUS, CKA_PRIVATE_EXPONENT, CKA_PUBLIC_EXPONENT,\n+                    CKA_PRIME_1, CKA_PRIME_2, CKA_EXPONENT_1, CKA_EXPONENT_2,\n+                    CKA_COEFFICIENT);\n+            if (rsaCRTAttrs == null) {\n+                return null;\n+            }\n+            return new P11RSAPrivateKey(session, keyID, algorithm, keyLength,\n+                    attrs, rsaCRTAttrs[0].getBigInteger(),\n+                    rsaCRTAttrs[1].getBigInteger(),\n+                    Arrays.copyOfRange(rsaCRTAttrs, 2, rsaCRTAttrs.length));\n+        }\n+\n+        private static P11RSAPrivateKeyInternal asNonCRT(Session session,\n+                long keyID, String algorithm, int keyLength,\n+                CK_ATTRIBUTE[] attrs) {\n+            CK_ATTRIBUTE[] rsaNonCRTAttrs = tryFetchAttributes(session, keyID,\n+                    CKA_MODULUS, CKA_PRIVATE_EXPONENT);\n+            if (rsaNonCRTAttrs == null) {\n+                return null;\n@@ -605,0 +628,3 @@\n+            return new P11RSAPrivateNonCRTKey(session, keyID, algorithm,\n+                    keyLength, attrs, rsaNonCRTAttrs[0].getBigInteger(),\n+                    rsaNonCRTAttrs[1].getBigInteger());\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":63,"deletions":37,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -407,2 +407,0 @@\n-alias sun.gc.policy.avgBaseFootprint              \/\/ 1.5.0 b39\n-\thotspot.gc.policy.avg_base_footprint      \/\/ 1.5.0 b21\n@@ -462,2 +460,0 @@\n-alias sun.gc.policy.fullFollowsScavenge           \/\/ 1.5.0 b39\n-\thotspot.gc.policy.full_follows_scavenge   \/\/ 1.5.0 b21\n@@ -511,2 +507,0 @@\n-alias sun.gc.policy.scavengeSkipped               \/\/ 1.5.0 b39\n-\thotspot.gc.policy.scavenge_skipped        \/\/ 1.5.0 b21\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/resources\/aliasmap","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);\n+                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle.seg, lpClipRectangle.seg, dwDestinationOrigin.seg, lpFill.seg);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/Kernel32.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    public static final String NEW_LINE = String.format(\"%n\");\n+    public static final String NEW_LINE = System.lineSeparator();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/CodeUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,0 +292,6 @@\n+    \/**\n+     * Gets the {@code jobject} value wrapped by {@code peerObject}.\n+     * Must not be called if {@link Services#IS_IN_NATIVE_IMAGE} is {@code false}.\n+     *\/\n+    native long getJObjectValue(HotSpotObjectConstantImpl peerObject);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -928,5 +928,6 @@\n-     * Gets the {@code jobject} value wrapped by {@code peerObject}. The returned \"naked\" value is\n-     * only valid as long as {@code peerObject} is valid. Note that the latter may be shorter than\n-     * the lifetime of {@code peerObject}. As such, this method should only be used to pass an\n-     * object parameter across a JNI call from the JVMCI shared library to HotSpot. This method must\n-     * only be called from within the JVMCI shared library.\n+     * Gets the {@code jobject} value wrapped by {@code peerObject}. The returned value is\n+     * a JNI local reference whose lifetime is scoped by the nearest Java caller (from\n+     * HotSpot's perspective). You can use {@code PushLocalFrame} and {@code PopLocalFrame} to\n+     * shorten the lifetime of the reference. The current thread's state must be\n+     * {@code _thread_in_native}. A call from the JVMCI shared library (e.g. libgraal) is in such\n+     * a state.\n@@ -934,2 +935,2 @@\n-     * @param peerObject a reference to an object in the peer runtime\n-     * @return the {@code jobject} value wrapped by {@code peerObject}\n+     * @param peerObject a reference to an object in the HotSpot heap\n+     * @return the {@code jobject} value unpacked from {@code peerObject}\n@@ -937,1 +938,4 @@\n-     *             {@code peerObject} is not a peer object reference\n+     *             {@code peerObject} is not a HotSpot heap object reference\n+     * @throws IllegalStateException if not called from within the JVMCI shared library\n+     *         or if there is no Java caller frame on the stack\n+     *         (i.e., JavaThread::has_last_Java_frame returns false)\n@@ -940,5 +944,1 @@\n-        if (peerObject instanceof IndirectHotSpotObjectConstantImpl) {\n-            IndirectHotSpotObjectConstantImpl remote = (IndirectHotSpotObjectConstantImpl) peerObject;\n-            return remote.getHandle();\n-        }\n-        throw new IllegalArgumentException(\"Cannot get jobject value for \" + peerObject + \" (\" + peerObject.getClass().getName() + \")\");\n+        return compilerToVm.getJObjectValue((HotSpotObjectConstantImpl)peerObject);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,1 +324,1 @@\n-        String nl = String.format(\"%n\");\n+        String nl = System.lineSeparator();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-        cm.forEachElement(attrs);\n+        cm.forEach(attrs);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -133,0 +134,18 @@\n+    \/**\n+     * Adds the generic type parameters.\n+     *\n+     * @param member the member to add the generic type parameters for\n+     * @param target the content to which the generic type parameters will be added\n+     *\/\n+    protected void addTypeParameters(ExecutableElement member, Content target) {\n+        Content typeParameters = getTypeParameters(member);\n+        target.add(typeParameters);\n+        \/\/ Add explicit line break between method type parameters and\n+        \/\/ return type in member summary table to avoid random wrapping.\n+        if (typeParameters.charCount() > 10) {\n+            target.add(new HtmlTree(TagName.BR));\n+        } else {\n+            target.add(Entity.NO_BREAK_SPACE);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -469,10 +469,2 @@\n-                Content typeParameters = ((AbstractExecutableMemberWriter) this)\n-                        .getTypeParameters((ExecutableElement)member);\n-                code.add(typeParameters);\n-                \/\/ Add explicit line break between method type parameters and\n-                \/\/ return type in member summary table to avoid random wrapping.\n-                if (typeParameters.charCount() > 10) {\n-                    code.add(new HtmlTree(TagName.BR));\n-                } else {\n-                    code.add(Entity.NO_BREAK_SPACE);\n-                }\n+                ((AbstractExecutableMemberWriter) this)\n+                  .addTypeParameters((ExecutableElement)member, code);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        constrSubWriter.setFoundNonPubConstructor(true);\n+        constrSubWriter.setShowConstructorModifiers(true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -56,1 +57,11 @@\n-    private boolean foundNonPubConstructor = false;\n+    \/**\n+     * If any constructors are non-public, then we want the modifiers shown in the summary.\n+     * This implies we need a three-column summary.\n+     *\/\n+    private boolean showConstructorModifiers = false;\n+\n+    \/**\n+     * Whether any constructors have type parameters.\n+     * This implies we need a three column summary.\n+     *\/\n+    private boolean hasTypeParamsConstructor = false;\n@@ -68,5 +79,1 @@\n-        for (Element constructor : constructors) {\n-            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n-                setFoundNonPubConstructor(true);\n-            }\n-        }\n+        analyzeConstructors(constructors);\n@@ -97,5 +104,1 @@\n-            for (Element constructor : constructors) {\n-                if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n-                    setFoundNonPubConstructor(true);\n-                }\n-            }\n+            analyzeConstructors(constructors);\n@@ -129,0 +132,18 @@\n+    \/\/ Calculate \"showConstructorModifiers\" and \"hasTypeParamsConstructor\"\n+    private void analyzeConstructors(List<? extends Element> constructors) {\n+        for (Element constructor : constructors) {\n+            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n+                setShowConstructorModifiers(true);\n+            }\n+            List<? extends TypeParameterElement> list = ((ExecutableElement)constructor).getTypeParameters();\n+            if (list != null && !list.isEmpty()) {\n+                hasTypeParamsConstructor = true;\n+            }\n+        }\n+    }\n+\n+    \/\/ Does the constructor summary need three columnns or just two?\n+    protected boolean threeColumnSummary() {\n+        return showConstructorModifiers || hasTypeParamsConstructor;\n+    }\n+\n@@ -204,0 +225,1 @@\n+                .setTypeParameters(getTypeParameters(constructor))\n@@ -234,2 +256,2 @@\n-    protected void setFoundNonPubConstructor(boolean foundNonPubConstructor) {\n-        this.foundNonPubConstructor = foundNonPubConstructor;\n+    protected void setShowConstructorModifiers(boolean showConstructorModifiers) {\n+        this.showConstructorModifiers = showConstructorModifiers;\n@@ -247,1 +269,1 @@\n-        if (foundNonPubConstructor) {\n+        if (threeColumnSummary()) {\n@@ -259,1 +281,1 @@\n-        if (foundNonPubConstructor) {\n+        if (threeColumnSummary()) {\n@@ -279,1 +301,1 @@\n-        if (foundNonPubConstructor) {\n+        if (threeColumnSummary()) {\n@@ -291,0 +313,5 @@\n+            ExecutableElement constructor = (ExecutableElement)member;\n+            List<? extends TypeParameterElement> list = constructor.getTypeParameters();\n+            if (list != null && !list.isEmpty()) {\n+                addTypeParameters(constructor, code);\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.lang.model.element.ModuleElement;\n@@ -598,0 +599,31 @@\n+\n+    \/**\n+     * Returns an id for a snippet.\n+     *\n+     * @param e the element in whose documentation the snippet appears\n+     * @param snippetIds the set of snippet ids already generated\n+     * @return a unique id for the snippet\n+     *\/\n+    public HtmlId forSnippet(Element e, Set<String> snippetIds) {\n+        String id = \"snippet-\";\n+        ElementKind kind = e.getKind();\n+        if (kind == ElementKind.PACKAGE) {\n+            id += forPackage((PackageElement) e).name();\n+        } else if (kind.isDeclaredType()) {\n+            id += forClass((TypeElement) e).name();\n+        } else if (kind.isExecutable()) {\n+            id += forMember((ExecutableElement) e).getFirst().name();\n+        } else if (kind.isField()) {\n+            id += forMember((VariableElement) e).name();\n+        } else if (kind == ElementKind.MODULE) {\n+            id += ((ModuleElement) e).getQualifiedName();\n+        } else {\n+            \/\/ while utterly unexpected, we shouldn't fail\n+            id += \"unknown-element\";\n+        }\n+        int counter = 1;\n+        while (!snippetIds.add(id + counter)) {\n+            counter++;\n+        }\n+        return HtmlId.of(id + counter);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -532,0 +532,1 @@\n+            \/\/ Note return type will be null if this is a constructor.\n@@ -542,0 +543,1 @@\n+            int returnTypeLength = returnType != null ? returnType.charCount() : 0;\n@@ -544,1 +546,1 @@\n-            if (lineLength + returnType.charCount() > RETURN_TYPE_MAX_LINE_LENGTH) {\n+            if (lineLength + returnTypeLength > RETURN_TYPE_MAX_LINE_LENGTH) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.net.URI;\n+import java.nio.file.Path;\n@@ -68,0 +70,2 @@\n+import static jdk.javadoc.internal.doclets.formats.html.taglets.SnippetTaglet.Language.*;\n+\n@@ -74,29 +78,2 @@\n-\n-        JAVA(\"java\"),\n-        PROPERTIES(\"properties\");\n-\n-        private static final Map<String, Language> languages;\n-\n-        static {\n-            Map<String, Language> tmp = new HashMap<>();\n-            for (var language : values()) {\n-                String id = Objects.requireNonNull(language.identifier);\n-                if (tmp.put(id, language) != null)\n-                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n-            }\n-            languages = Map.copyOf(tmp);\n-        }\n-\n-        Language(String id) {\n-            identifier = id;\n-        }\n-\n-        private final String identifier;\n-\n-        public static Optional<Language> of(String identifier) {\n-            if (identifier == null)\n-                return Optional.empty();\n-            return Optional.ofNullable(languages.get(identifier));\n-        }\n-\n-        public String getIdentifier() {return identifier;}\n+        JAVA,\n+        PROPERTIES;\n@@ -151,0 +128,2 @@\n+        } else {\n+            pre.put(HtmlAttr.ID, config.htmlIds.forSnippet(element, ids).name());\n@@ -235,0 +214,2 @@\n+    private final Set<String> ids = new HashSet<>();\n+\n@@ -360,1 +341,1 @@\n-        String lang = null;\n+        String lang;\n@@ -362,1 +343,2 @@\n-        if (langAttr != null) {\n+\n+        if (langAttr != null) { \/\/ the lang attribute overrides everything else\n@@ -364,1 +346,1 @@\n-        } else if (containsClass) {\n+        } else if (inlineContent != null && externalContent == null) { \/\/ an inline snippet\n@@ -366,2 +348,11 @@\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n+        } else if (externalContent != null) { \/\/ an external or a hybrid snippet\n+            if (containsClass) { \/\/ the class attribute means Java\n+                lang = \"java\";\n+            } else {\n+                var uri = fileObject.toUri();\n+                var path = uri.getPath() != null ? uri.getPath() : \"\";\n+                var fileName = path.substring(path.lastIndexOf('\/') + 1);\n+                lang = languageFromFileName(fileName);\n+            }\n+        } else {\n+            throw new AssertionError();\n@@ -370,2 +361,4 @@\n-        Optional<Language> language = Language.of(lang);\n-\n+        var language = switch (lang) {\n+            case \"properties\" -> PROPERTIES;\n+            case null, default -> JAVA;\n+        };\n@@ -481,1 +474,1 @@\n-    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n+    private StyledText parse(Resources resources, Diags diags, Language language, String content) throws ParseException {\n@@ -504,5 +497,7 @@\n-        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n-        if (fileName.endsWith(\".java\")) {\n-            return \"java\";\n-        } else if (fileName.endsWith(\".properties\")) {\n-            return \"properties\";\n+        \/\/ The assumption is simple: a file extension is the language\n+        \/\/ identifier.\n+        \/\/ Was about to use Path.getExtension introduced in 8057113, but then\n+        \/\/ learned that it was removed in 8298303.\n+        int lastPeriod = fileName.lastIndexOf('.');\n+        if (lastPeriod <= 0) {\n+            return null;\n@@ -510,1 +505,1 @@\n-        return null;\n+        return (lastPeriod == fileName.length() - 1) ? null : fileName.substring(lastPeriod + 1);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":39,"deletions":44,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,2 @@\n-    public Result parse(SnippetTaglet.Diags diags, Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n-        SnippetTaglet.Language lang = language.orElse(SnippetTaglet.Language.JAVA);\n-        var p = switch (lang) {\n+    public Result parse(SnippetTaglet.Diags diags, SnippetTaglet.Language language, String source) throws ParseException {\n+        var p = switch (language) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Parser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -322,1 +322,2 @@\n- primitive components are compared with '=='.\n+ primitive components are compared with the <code>compare<\/code> method from \\\n+ their corresponding wrapper classes.\n@@ -325,1 +326,2 @@\n- All components in this record class are compared with '=='.\n+ All components in this record class are compared with the <code>compare<\/code> \\\n+ method from their corresponding wrapper classes.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-        ROLE,\n+        ROLE(true),\n@@ -609,20 +609,0 @@\n-        attrs.put(Attr.CLASS, AttrKind.OK);\n-        attrs.put(Attr.ID, AttrKind.OK);\n-        attrs.put(Attr.STYLE, AttrKind.OK);\n-        attrs.put(Attr.ROLE, AttrKind.OK);\n-        \/\/ for now, assume that all ARIA attributes are allowed on all tags.\n-        attrs.put(Attr.ARIA_ACTIVEDESCENDANT, AttrKind.OK);\n-        attrs.put(Attr.ARIA_CONTROLS, AttrKind.OK);\n-        attrs.put(Attr.ARIA_DESCRIBEDBY, AttrKind.OK);\n-        attrs.put(Attr.ARIA_EXPANDED, AttrKind.OK);\n-        attrs.put(Attr.ARIA_LABEL, AttrKind.OK);\n-        attrs.put(Attr.ARIA_LABELLEDBY, AttrKind.OK);\n-        attrs.put(Attr.ARIA_LEVEL, AttrKind.OK);\n-        attrs.put(Attr.ARIA_MULTISELECTABLE, AttrKind.OK);\n-        attrs.put(Attr.ARIA_OWNS, AttrKind.OK);\n-        attrs.put(Attr.ARIA_POSINSET, AttrKind.OK);\n-        attrs.put(Attr.ARIA_READONLY, AttrKind.OK);\n-        attrs.put(Attr.ARIA_REQUIRED, AttrKind.OK);\n-        attrs.put(Attr.ARIA_SELECTED, AttrKind.OK);\n-        attrs.put(Attr.ARIA_SETSIZE, AttrKind.OK);\n-        attrs.put(Attr.ARIA_SORT, AttrKind.OK);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/HtmlTag.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -881,1 +881,1 @@\n-\\[dq]vm_memory_map_.txt\\[dq])\n+\\[dq]vm_memory_map_<pid>.txt\\[dq])\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -154,1 +156,1 @@\n-        writeModifiers(getClassModifiers(cm.flags().flagsMask(), classModel.majorVersion(), classModel.minorVersion()));\n+        writeModifiers(getClassModifiers(cm.flags(), classModel.majorVersion(), classModel.minorVersion()));\n@@ -215,1 +217,1 @@\n-                    getClassFlags(cm.flags().flagsMask()), \"\\n\");\n+                    getClassFlags(cm.flags()), \"\\n\");\n@@ -421,1 +423,1 @@\n-        var flags = AccessFlags.ofField(f.flags().flagsMask());\n+        var flags = f.flags();\n@@ -799,3 +801,10 @@\n-    private Set<String> getClassModifiers(int mask) {\n-        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask)));\n+    private Set<String> getClassModifiers(AccessFlags flags) {\n+        var flagSet = flagsReportUnknown(flags);\n+        Set<AccessFlag> set;\n+        if (flagSet.contains(AccessFlag.INTERFACE)) {\n+            set = EnumSet.copyOf(flagSet);\n+            set.remove(AccessFlag.ABSTRACT);\n+        } else {\n+            set = flagSet;\n+        }\n+        return getModifiers(set);\n@@ -804,1 +813,1 @@\n-    private static Set<String> getClassModifiers(int mask, int majorVersion, int minorVersion) {\n+    private static Set<String> getClassModifiers(AccessFlags flags, int majorVersion, int minorVersion) {\n@@ -806,4 +815,8 @@\n-        Set<String> result = getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-        if ((mask & ACC_INTERFACE) == 0 && Source.isSupported(Source.Feature.VALUE_CLASSES, majorVersion) && previewClassFile) {\n-            result.add(\"value\");\n+        Set<AccessFlag> flagSet = flags.flags();\n+        if (flagSet.contains(AccessFlag.INTERFACE)) {\n+            flagSet = EnumSet.copyOf(flagSet);\n+            flagSet.remove(AccessFlag.ABSTRACT);\n+        } else if (Source.isSupported(Source.Feature.VALUE_CLASSES, majorVersion) && previewClassFile) {\n+          Set<String> classModifers = getModifiers(flagSet);\n+          classModifers.add(\"value\");\n+          return classModifers;\n@@ -811,1 +824,1 @@\n-        return result;\n+        return getModifiers(flagSet);\n@@ -821,10 +834,2 @@\n-    private Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n-    }\n-\n-    private Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n-    }\n-\n-    private Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n+    private Set<String> getClassFlags(AccessFlags flags) {\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,2 +96,2 @@\n- *   WARNING: No not 'return' or 'goto' out of the BEGIN_CALLBACK\/END_CALLBACK\n- *            block, this will mess up the count.\n+ *   WARNING: Do not 'return' or 'goto' out of the BEGIN_CALLBACK\/END_CALLBACK\n+ *            block. This will mess up the active_callbacks count.\n@@ -1712,0 +1712,12 @@\n+void\n+callback_lock(void)\n+{\n+    debugMonitorEnter(callbackLock);\n+}\n+\n+void\n+callback_unlock(void)\n+{\n+    debugMonitorExit(callbackLock);\n+}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,3 @@\n+void callback_lock(void);\n+void callback_unlock(void);\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -722,1 +722,3 @@\n-    eventHandler_lock(); \/* for proper lock order *\/\n+    callback_lock();     \/* for proper lock order in threadControl getLocks() *\/\n+    eventHandler_lock(); \/* for proper lock order in threadControl getLocks() *\/\n+    stepControl_lock();  \/* for proper lock order in threadControl getLocks() *\/\n@@ -775,1 +777,1 @@\n-     * after writing the respone.\n+     * after writing the response.\n@@ -793,0 +795,1 @@\n+    stepControl_unlock();\n@@ -794,0 +797,1 @@\n+    callback_unlock();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,1 +808,2 @@\n-    eventHandler_lock(); \/* for proper lock order *\/\n+    callback_lock();     \/* for proper lock order in threadControl getLocks() *\/\n+    eventHandler_lock(); \/* for proper lock order in threadControl getLocks() *\/\n@@ -855,0 +856,1 @@\n+    callback_unlock();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -645,0 +645,5 @@\n+     *\n+     * stepControl_beginStep() grabs the eventHandler lock and stepControl lock\n+     * before eventually ending up here, so we need to maintain that order here.\n+     * Similarly, invoker_completeInvokeRequest() grabs the eventHandler lock\n+     * and invoker lock.\n@@ -646,1 +651,1 @@\n-\n+    callback_lock();\n@@ -648,0 +653,1 @@\n+    stepControl_lock();\n@@ -650,2 +656,0 @@\n-    stepControl_lock();\n-    commonRef_lock();\n@@ -653,1 +657,1 @@\n-\n+    commonRef_lock();\n@@ -659,1 +663,0 @@\n-    debugMonitorExit(threadLock);\n@@ -661,1 +664,1 @@\n-    stepControl_unlock();\n+    debugMonitorExit(threadLock);\n@@ -664,0 +667,1 @@\n+    stepControl_unlock();\n@@ -665,0 +669,1 @@\n+    callback_unlock();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,1 @@\n+                lastValue = delegate.getValue();\n@@ -113,0 +114,1 @@\n+                lastValue = null;\n@@ -115,1 +117,1 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+            lastValue = AccessController.doPrivileged(new PrivilegedAction<String>() {\n@@ -117,1 +119,1 @@\n-                public Void run() {\n+                public String run() {\n@@ -120,0 +122,1 @@\n+                        return delegate.getValue();\n@@ -128,1 +131,0 @@\n-        lastValue = value;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-        String def = type.getAnnotationValue(Threshold.class, \"0 ns\");\n+        String def = type.getAnnotationValue(Threshold.class, ThresholdSetting.DEFAULT_VALUE);\n@@ -314,1 +314,1 @@\n-        String def = type.getAnnotationValue(Cutoff.class, Cutoff.INFINITY);\n+        String def = type.getAnnotationValue(Cutoff.class, CutoffSetting.DEFAULT_VALUE);\n@@ -320,1 +320,1 @@\n-        String def = type.getAnnotationValue(Throttle.class, Throttle.DEFAULT);\n+        String def = type.getAnnotationValue(Throttle.class, ThrottleSetting.DEFAULT_VALUE);\n@@ -333,1 +333,1 @@\n-        String def = type.getAnnotationValue(Period.class, \"everyChunk\");\n+        String def = type.getAnnotationValue(Period.class, PeriodSetting.DEFAULT_VALUE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        for (ClassElement ce : classModel.elements()) {\n+        for (ClassElement ce : classModel) {\n@@ -263,1 +263,1 @@\n-            for (var me : m.elements()) {\n+            for (var me : m) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.internal.PlatformEventType;\n+\n+abstract class BooleanSetting extends JDKSettingControl {\n+    private final PlatformEventType eventType;\n+    private final String defaultValue;\n+    private String value;\n+\n+    public BooleanSetting(PlatformEventType eventType, String defaultValue) {\n+        this.eventType = Objects.requireNonNull(eventType);\n+        this.defaultValue = defaultValue;\n+        this.value = defaultValue;\n+        if (parse(defaultValue) == null) {\n+            throw new InternalError(\"Only 'true' or 'false' is allowed with class BooleanSetting\");\n+        }\n+    }\n+\n+    protected abstract void apply(PlatformEventType eventType, boolean value);\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        if (values.contains(\"true\")) {\n+            return \"true\";\n+        }\n+        if (values.contains(\"false\")) {\n+            return \"false\";\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public void setValue(String value) {\n+        Boolean b = parse(value);\n+        if (b != null) {\n+            apply(eventType, b.booleanValue());\n+            this.value = value;\n+        }\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    private static Boolean parse(String value) {\n+        if (\"true\".equals(value)) {\n+            return Boolean.TRUE;\n+        }\n+        if (\"false\".equals(value)) {\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/BooleanSetting.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.settings;\n-\n-import java.util.Set;\n-\n-\/**\n- * Helper class for settings that use boolean numbers\n- *\n- *\/\n-final class BooleanValue  {\n-    private String value = \"false\";\n-    private boolean booleanValue;\n-\n-    private BooleanValue(boolean b) {\n-        booleanValue = b;\n-        value = b ? \"true\" : \"false\";\n-    }\n-\n-    public String union(Set<String> values) {\n-        for (String v : values) {\n-            if (\"true\".equals(v)) {\n-                return \"true\";\n-            }\n-        }\n-        return \"false\";\n-    }\n-\n-    public void setValue(String value) {\n-        this.value = value;\n-        this.booleanValue = Boolean.valueOf(value);\n-    }\n-\n-    public final String getValue() {\n-        return this.value;\n-    }\n-\n-    public boolean getBoolean() {\n-        return booleanValue;\n-    }\n-\n-    public static BooleanValue valueOf(String defaultValue) {\n-        if (\"true\".equals(defaultValue)) {\n-            return new BooleanValue(true);\n-        }\n-        if (\"false\".equals(defaultValue)) {\n-            return new BooleanValue(false);\n-        }\n-        throw new InternalError(\"Unknown default value for settings '\" + defaultValue + \"'\");\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/BooleanValue.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n+\n@@ -46,2 +48,2 @@\n-\n-    private String value = \"0 ns\";\n+    public static final String DEFAULT_VALUE = ValueParser.INFINITY;\n+    private String value = DEFAULT_VALUE;\n@@ -57,1 +59,1 @@\n-        String text = \"0 ns\";\n+        String text = null;\n@@ -59,2 +61,2 @@\n-            long l =  ValueParser.parseTimespanWithInfinity(value);\n-            if (l > max) {\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos != MISSING && nanos > max) {\n@@ -62,1 +64,1 @@\n-                max = l;\n+                max = nanos;\n@@ -65,1 +67,1 @@\n-        return text;\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -70,3 +72,5 @@\n-        long l =  ValueParser.parseTimespanWithInfinity(value);\n-        this.value = value;\n-        eventType.setCutoff(l);\n+        long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+        if (nanos != MISSING) {\n+            eventType.setCutoff(nanos);\n+            this.value = value;\n+        }\n@@ -84,5 +88,1 @@\n-        try {\n-            return ValueParser.parseTimespanWithInfinity(value);\n-        } catch (NumberFormatException nfe) {\n-            return 0L;\n-        }\n+        return ValueParser.parseTimespanWithInfinity(value, 0L);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CutoffSetting.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.util.Objects;\n-import java.util.Set;\n-\n@@ -44,4 +41,1 @@\n-public final class EnabledSetting extends JDKSettingControl {\n-    private final BooleanValue booleanValue;\n-    private final PlatformEventType eventType;\n-\n+public final class EnabledSetting extends BooleanSetting {\n@@ -49,7 +43,1 @@\n-        this.booleanValue = BooleanValue.valueOf(defaultValue);\n-        this.eventType = Objects.requireNonNull(eventType);\n-    }\n-\n-    @Override\n-    public String combine(Set<String> values) {\n-        return booleanValue.union(values);\n+        super(eventType, defaultValue);\n@@ -59,3 +47,2 @@\n-    public void setValue(String value) {\n-        booleanValue.setValue(value);\n-        eventType.setEnabled(booleanValue.getBoolean());\n+    protected void apply(PlatformEventType eventType, boolean value) {\n+        eventType.setEnabled(value);\n@@ -68,5 +55,0 @@\n-\n-    @Override\n-    public String getValue() {\n-        return booleanValue.getValue();\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/EnabledSetting.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        this.value = levels[0];\n@@ -54,1 +55,1 @@\n-        int maxIndex = 0;\n+        int maxIndex = 0; \/\/ index 0 contains the default value\n@@ -56,1 +57,1 @@\n-            maxIndex = Math.max(maxIndex, indexOf(value));\n+            maxIndex = Math.max(maxIndex, levels.indexOf(value));\n@@ -63,2 +64,5 @@\n-        this.value = value;\n-        this.eventType.setLevel(indexOf(value));\n+        int index = levels.indexOf(value);\n+        if (index != -1) {\n+            this.eventType.setLevel(index);\n+            this.value = value;\n+        }\n@@ -71,5 +75,0 @@\n-\n-    private int indexOf(String value) {\n-        int index = levels.indexOf(value);\n-        return index < 0 ? 0 : index;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n@@ -49,0 +50,1 @@\n+    public static final String DEFAULT_VALUE = EVERY_CHUNK;\n@@ -59,1 +61,0 @@\n-\n@@ -77,7 +78,3 @@\n-                long l = ValueParser.parseTimespanWithInfinity(value);\n-                \/\/ Always accept first specified value\n-                if (min == null) {\n-                    text = value;\n-                    min = l;\n-                } else {\n-                    if (l < min) {\n+                long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+                if (nanos != MISSING) {\n+                    if (min == null || nanos < min) {\n@@ -85,1 +82,1 @@\n-                        min = l;\n+                        min = nanos;\n@@ -100,1 +97,1 @@\n-        return EVERY_CHUNK; \/\/ also default\n+        return DEFAULT_VALUE; \/\/ \"everyChunk\" is default\n@@ -116,1 +113,4 @@\n-            long nanos = ValueParser.parseTimespanWithInfinity(value);\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos == MISSING) {\n+                return;\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/PeriodSetting.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import jdk.jfr.Description;\n@@ -33,0 +29,1 @@\n+import jdk.jfr.Description;\n@@ -44,4 +41,2 @@\n-public final class StackTraceSetting extends JDKSettingControl {\n-    private static final long typeId =  Type.getTypeId(StackTraceSetting.class);\n-    private final BooleanValue booleanValue;\n-    private final PlatformEventType eventType;\n+public final class StackTraceSetting extends BooleanSetting {\n+    private static final long typeId = Type.getTypeId(StackTraceSetting.class);\n@@ -50,13 +45,1 @@\n-        this.booleanValue = BooleanValue.valueOf(defaultValue);\n-        this.eventType = Objects.requireNonNull(eventType);\n-    }\n-\n-    @Override\n-    public String combine(Set<String> values) {\n-        return booleanValue.union(values);\n-    }\n-\n-    @Override\n-    public void setValue(String value) {\n-        booleanValue.setValue(value);\n-        eventType.setStackTraceEnabled(booleanValue.getBoolean());\n+        super(eventType, defaultValue);\n@@ -66,2 +49,2 @@\n-    public String getValue() {\n-        return booleanValue.getValue();\n+    protected void apply(PlatformEventType eventType, boolean value) {\n+        eventType.setStackTraceEnabled(value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/StackTraceSetting.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n+\n@@ -39,0 +41,1 @@\n+\n@@ -45,0 +48,1 @@\n+    public static final String DEFAULT_VALUE = \"0 ns\";\n@@ -46,1 +50,1 @@\n-    private String value = \"0 ns\";\n+    private String value = DEFAULT_VALUE;\n@@ -58,7 +62,3 @@\n-            long l = ValueParser.parseTimespanWithInfinity(value);\n-            \/\/ always accept first value\n-            if (min == null) {\n-                min = l;\n-                text = value;\n-            } else {\n-                if (l < min) {\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos != MISSING) {\n+                if (min == null || nanos < min) {\n@@ -66,1 +66,1 @@\n-                    min = l;\n+                    min = nanos;\n@@ -70,1 +70,1 @@\n-        return text == null ? \"0 ns\" : text;\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -75,3 +75,5 @@\n-        long l = ValueParser.parseTimespanWithInfinity(value);\n-        this.value = value;\n-        eventType.setThreshold(l);\n+        long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+        if (nanos != MISSING) {\n+            eventType.setThreshold(nanos);\n+            this.value = value;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThresholdSetting.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n+import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n+\n@@ -37,0 +40,1 @@\n+import jdk.jfr.internal.Throttle;\n@@ -38,0 +42,3 @@\n+import jdk.jfr.internal.util.Rate;\n+import jdk.jfr.internal.util.TimespanUnit;\n+import jdk.jfr.internal.util.Utils;\n@@ -44,3 +51,1 @@\n-    static final String OFF_TEXT = \"off\";\n-    private static final long OFF = -2;\n-    private String value = \"0\/s\";\n+    public static final String DEFAULT_VALUE = Throttle.DEFAULT;\n@@ -48,0 +53,1 @@\n+    private String value = DEFAULT_VALUE;\n@@ -55,2 +61,2 @@\n-        long max = OFF;\n-        String text = \"off\";\n+        Rate max = null;\n+        String text = null;\n@@ -58,4 +64,6 @@\n-            long l = parseValueSafe(value);\n-            if (l > max) {\n-                text = value;\n-                max = l;\n+            Rate rate = Rate.of(value);\n+            if (rate != null) {\n+                if (max == null || rate.isHigher(max)) {\n+                    text = value;\n+                    max = rate;\n+                }\n@@ -64,1 +72,2 @@\n-        return text;\n+        \/\/ \"off\" is default\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -67,5 +76,6 @@\n-    private static long parseValueSafe(String s) {\n-        long value = 0L;\n-        try {\n-            value = parseThrottleValue(s);\n-        } catch (NumberFormatException nfe) {\n+    @Override\n+    public void setValue(String value) {\n+        if (\"off\".equals(value)) {\n+            eventType.setThrottle(-2, 1000);\n+            this.value = value;\n+            return;\n@@ -73,2 +83,0 @@\n-        return value;\n-    }\n@@ -76,9 +84,16 @@\n-    @Override\n-    public void setValue(String s) {\n-        long size = 0;\n-        long millis = 1000;\n-        try {\n-            size = parseThrottleValue(s);\n-            millis = parseThrottleTimeUnit(s);\n-            this.value = s;\n-        } catch (NumberFormatException nfe) {\n+        Rate rate = Rate.of(value);\n+        if (rate != null) {\n+            long millis = 1000;\n+            long samples = rate.amount();\n+            TimespanUnit unit = rate.unit();\n+            \/\/ if unit is more than 1 s, set millis\n+            if (unit.nanos > SECONDS.nanos) {\n+                millis = unit.nanos \/ MILLISECONDS.nanos;\n+            }\n+            \/\/ if unit is less than 1 s, scale samples\n+            if (unit.nanos < SECONDS.nanos) {\n+                long perSecond = SECONDS.nanos \/ unit.nanos;\n+                samples *= Utils.multiplyOverflow(samples, perSecond, Long.MAX_VALUE);\n+            }\n+            eventType.setThrottle(samples, millis);\n+            this.value = value;\n@@ -86,1 +101,0 @@\n-        eventType.setThrottle(size, millis);\n@@ -93,32 +107,0 @@\n-\n-    private static long parseThrottleValue(String s) {\n-        if (s.equals(OFF_TEXT)) {\n-            return OFF;\n-        }\n-        String parsedValue = parseThrottleString(s, true);\n-        long normalizedValue = 0;\n-        try {\n-            normalizedValue = ThrottleUnit.normalizeValueAsMillis(Long.parseLong(parsedValue), s);\n-        } catch (NumberFormatException nfe) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return normalizedValue;\n-    }\n-\n-    private static long parseThrottleTimeUnit(String s) {\n-        return ThrottleUnit.asMillis(s);\n-    }\n-\n-    \/\/ Expected input format is \"x\/y\" where x is a non-negative long\n-    \/\/ and y is a time unit. Split the string at the delimiter.\n-    static String parseThrottleString(String s, boolean value) {\n-        String[] split = s.split(\"\/\");\n-        if (split.length != 2) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return value ? split[0].trim() : split[1].trim();\n-    }\n-\n-    private static void throwThrottleNumberFormatException(String s) {\n-        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. '\/', and then followed by a unit e.g. 100\/s.\");\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":42,"deletions":60,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal.settings;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-enum ThrottleUnit {\n-        NANOSECONDS(\"ns\", TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toMillis(1)),\n-        MICROSECONDS(\"us\", TimeUnit.SECONDS.toNanos(1) \/ 1000, TimeUnit.SECONDS.toMillis(1)),\n-        MILLISECONDS(\"ms\", TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toMillis(1)),\n-        SECONDS(\"s\", 1, TimeUnit.SECONDS.toMillis(1)),\n-        MINUTES(\"m\", 1, TimeUnit.MINUTES.toMillis(1)),\n-        HOUR(\"h\", 1, TimeUnit.HOURS.toMillis(1)),\n-        DAY(\"d\", 1, TimeUnit.DAYS.toMillis(1));\n-\n-        private final String text;\n-        private final long factor;\n-        private final long millis;\n-\n-        ThrottleUnit(String t, long factor, long millis) {\n-            this.text = t;\n-            this.factor = factor;\n-            this.millis = millis;\n-        }\n-\n-        private static ThrottleUnit parse(String s) {\n-            if (s.equals(ThrottleSetting.OFF_TEXT)) {\n-                return MILLISECONDS;\n-            }\n-            return unit(ThrottleSetting.parseThrottleString(s, false));\n-        }\n-\n-        private static ThrottleUnit unit(String s) {\n-            if (s.endsWith(\"ns\") || s.endsWith(\"us\") || s.endsWith(\"ms\")) {\n-                return value(s.substring(s.length() - 2));\n-            }\n-            if (s.endsWith(\"s\") || s.endsWith(\"m\") || s.endsWith(\"h\") || s.endsWith(\"d\")) {\n-                return value(s.substring(s.length() - 1));\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        private static ThrottleUnit value(String s) {\n-            for (ThrottleUnit t : values()) {\n-                if (t.text.equals(s)) {\n-                    return t;\n-                }\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        static long asMillis(String s) {\n-            return parse(s).millis;\n-        }\n-\n-        static long normalizeValueAsMillis(long value, String s) {\n-            return value * parse(s).factor;\n-        }\n-    }\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleUnit.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    private String lineSeparator = String.format(\"%n\");\n+    private String lineSeparator = System.lineSeparator();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+public record Rate(long amount, TimespanUnit unit) {\n+\n+    public static Rate of(String text) {\n+        String[] splitted = text.split(\"\/\");\n+        if (splitted.length != 2) {\n+            return null;\n+        }\n+        String value = splitted[0].strip();\n+        String unit = splitted[1].strip();\n+        TimespanUnit tu = TimespanUnit.fromText(unit);\n+        if (unit == null) {\n+            return null;\n+        }\n+        try {\n+            long v = Long.parseLong(value);\n+            if (v >= 0) {\n+                return new Rate(v, tu);\n+            }\n+        } catch (NumberFormatException nfe) {\n+            \/\/ Ignore\n+        }\n+        return null;\n+    }\n+\n+    public boolean isHigher(Rate that) {\n+        return this.inNanos() > that.inNanos();\n+    }\n+\n+    private double inNanos() {\n+        return (double) amount \/ unit.nanos;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Rate.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+public enum TimespanUnit {\n+    NANOSECONDS (\"ns\",                           1L, 1000),\n+    MICROSECONDS(\"us\",                        1000L, 1000),\n+    MILLISECONDS(\"ms\",                   1_000_000L, 1000),\n+    SECONDS     (\"s\",                1_000_000_000L,   60),\n+    MINUTES     (\"m\",           60 * 1_000_000_000L,   60),\n+    HOURS       (\"h\",      60 * 60 * 1_000_000_000L,   24),\n+    DAYS        (\"d\", 24 * 60 * 60 * 1_000_000_000L,    7);\n+    public final String text;\n+    public final long nanos;\n+    public final int size;\n+    TimespanUnit(String text, long nanos, int size) {\n+        this.text = text;\n+        this.nanos = nanos;\n+        this.size = size;\n+    }\n+\n+    public static TimespanUnit fromText(String text) {\n+        for (TimespanUnit tu : values()) {\n+            \/\/ Case-sensitive by design\n+            if (tu.text.equals(text)) {\n+                return tu;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanUnit.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -433,0 +433,8 @@\n+\n+    public static long multiplyOverflow(long a, long b, long defaultValue) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException ae) {\n+            return defaultValue;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,17 +43,0 @@\n-    private static enum TimespanUnit {\n-        NANOSECONDS(\"ns\", 1000),\n-        MICROSECONDS(\"us\", 1000),\n-        MILLISECONDS(\"ms\", 1000),\n-        SECONDS(\"s\", 60), MINUTES(\"m\", 60),\n-        HOURS(\"h\", 24),\n-        DAYS(\"d\", 7);\n-\n-        private final String text;\n-        private final long amount;\n-\n-        TimespanUnit(String unit, long amount) {\n-            this.text = unit;\n-            this.amount = amount;\n-        }\n-    }\n-\n@@ -85,1 +68,1 @@\n-            long amount = unit.amount;\n+            long amount = unit.size;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,1 +35,10 @@\n-    private static final String INFINITY = \"infinity\";\n+    public static final String INFINITY = \"infinity\";\n+    public static final long MISSING = Long.MIN_VALUE;\n+\n+    public static long parseTimespanWithInfinity(String s, long defaultValue) {\n+        try {\n+            return parseTimespanWithInfinity(s);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueParser.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import java.lang.classfile.ClassModel;\n@@ -371,3 +370,3 @@\n-                ClassFile.of().parse(bytes).forEachElement(cle -> {\n-                    if (cle instanceof MethodModel mm) mm.forEachElement(me -> {\n-                        if (me instanceof CodeModel com) com.forEachElement(coe -> {\n+                ClassFile.of().parse(bytes).forEach(cle -> {\n+                    if (cle instanceof MethodModel mm) mm.forEach(me -> {\n+                        if (me instanceof CodeModel com) com.forEach(coe -> {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jimage\/JImageTask.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-\\f[I]modulepath\\f[R] \\f[V]--add-modules\\f[R] \\f[I]module\\f[R] [,\n-\\f[I]module\\f[R]...]\n+\\f[I]modulepath\\f[R] \\f[V]--add-modules\\f[R]\n+\\f[I]module\\f[R][,\\f[I]module\\f[R]...]\n@@ -72,1 +72,1 @@\n-\\f[V]--add-modules\\f[R] \\f[I]mod\\f[R] [\\f[V],\\f[R] \\f[I]mod\\f[R]...]\n+\\f[V]--add-modules\\f[R] \\f[I]mod\\f[R][\\f[V],\\f[R]\\f[I]mod\\f[R]...]\n@@ -113,1 +113,1 @@\n-\\f[V]--limit-modules\\f[R] \\f[I]mod\\f[R] [\\f[V],\\f[R] \\f[I]mod\\f[R]...]\n+\\f[V]--limit-modules\\f[R] \\f[I]mod\\f[R][\\f[V],\\f[R]\\f[I]mod\\f[R]...]\n","filename":"src\/jdk.jlink\/share\/man\/jlink.1","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-            super(types);\n+            types.super();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TreeDissector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,0 @@\n-    static final int  ZIP64_EXTID  = 0x0001;       \/\/ Extra field Zip64 header ID\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipConstants.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1713,1 +1713,1 @@\n-        \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+        \/\/ if EXTID_ZIP64 blocksize == 0, which may occur with some older\n@@ -1721,1 +1721,1 @@\n-            \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+            \/\/ Only validate the EXTID_ZIP64 data if the block size > 0\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+# Core files can be very big and take a long time to load on macosx-aarch64.\n+# The 20 seconds default timeout is not nearly enough.\n+native.lldb.timeout=120000\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-    os::free_memory(base, size, page_sz);\n+    os::disclaim_memory(base, size);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-\n@@ -980,0 +979,24 @@\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+TEST_VM(os, free_without_uncommit) {\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t pages = 64;\n+  const size_t size = pages * page_sz;\n+\n+  char* base = os::reserve_memory(size, false, mtTest);\n+  ASSERT_NE(base, (char*) nullptr);\n+  ASSERT_TRUE(os::commit_memory(base, size, false));\n+\n+  for (size_t index = 0; index < pages; index++) {\n+    base[index * page_sz] = 'a';\n+  }\n+\n+  os::disclaim_memory(base, size);\n+\n+  \/\/ Ensure we can still use the memory without having to recommit.\n+  for (size_t index = 0; index < pages; index++) {\n+    base[index * page_sz] = 'a';\n+  }\n+\n+  os::release_memory(base, size);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+#include \"nmt\/memflags.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -104,0 +106,100 @@\n+}\n+\n+TEST_VM(utf8, truncation) {\n+\n+  \/\/ Test that truncation removes partial encodings as expected.\n+\n+  const char orig_bytes[] = { 'A', 'B', 'C', 'D', 'E', '\\0' };\n+  const int orig_length = sizeof(orig_bytes)\/sizeof(char);\n+  ASSERT_TRUE(UTF8::is_legal_utf8((const unsigned char*)orig_bytes, orig_length - 1, false));\n+  const char* orig_str = &orig_bytes[0];\n+  ASSERT_EQ((int)strlen(orig_str), orig_length - 1);\n+\n+  unsigned char* temp_bytes;\n+  const char* temp_str;\n+  char* utf8;\n+  int n_utf8; \/\/ Number of bytes in the encoding\n+\n+  \/\/ Test 1: a valid UTF8 \"ascii\" ending string should be returned as-is\n+\n+  temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * orig_length, mtTest);\n+  strcpy((char*)temp_bytes, orig_str);\n+  temp_str = (const char*) temp_bytes;\n+  UTF8::truncate_to_legal_utf8(temp_bytes, orig_length);\n+  ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be unchanged\";\n+  ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be unchanged\";\n+  os::free(temp_bytes);\n+\n+  \/\/ Test 2: a UTF8 sequence that \"ends\" with a 2-byte encoding\n+  \/\/         drops the 2-byte encoding\n+\n+  jchar two_byte_char[] = { 0x00D1 }; \/\/ N with tilde\n+  n_utf8 = 2;\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(two_byte_char, 1, utf8);\n+  int utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero or one byte from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n+  \/\/ Test 3: a UTF8 sequence that \"ends\" with a 3-byte encoding\n+  \/\/         drops the 3-byte encoding\n+  n_utf8 = 3;\n+  jchar three_byte_char[] = { 0x0800 };\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(three_byte_char, 1, utf8);\n+  utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero, to two bytes from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n+  \/\/ Test 4: a UTF8 sequence that \"ends\" with a 6-byte encoding\n+  \/\/         drops the 6-byte encoding\n+  n_utf8 = 6;\n+  jchar six_byte_char[] = { 0xD801, 0xDC37 }; \/\/ U+10437 as its UTF-16 surrogate pairs\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(six_byte_char, 2, utf8);\n+  utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero to five bytes from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_utf8.cpp","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+\n+vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n+vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n+vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n+vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-compiler\/vectorization\/TestFloat16VectorConvChain.java 8335860 generic-all\n+compiler\/interpreter\/Test6833129.java 8335266 generic-i586\n@@ -75,1 +75,4 @@\n-\n+compiler\/valhalla\/inlinetypes\/TestCallingConvention.java   8342064 generic-all\n+compiler\/valhalla\/inlinetypes\/TestIntrinsics.java          8342064 generic-all\n+compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java 8342064 generic-all\n+compiler\/valhalla\/inlinetypes\/TestNullableArrays.java      8342064 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test TestCastX2P\n+ * @summary AArch64: remove extra register copy when converting from long to pointer.\n+ * @bug 8336245\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-TieredCompilation compiler.c2.TestCastX2P\n+ *\/\n+\n+public class TestCastX2P {\n+\n+    public static final int LEN = 2040;\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static long lseed = 0xbeef;\n+    public static int iseed = 0xbeef;\n+    public static short sseed = (short) (0xef);\n+    public static byte bseed = (byte) (0xe);\n+\n+    public static long off1 = 16;\n+    public static long off2 = 32;\n+    public static long off3 = 64;\n+\n+    public static class TestLong {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putLong(address+i, lseed);\n+                }\n+            }\n+\n+            UNSAFE.putLong(address + off1 + 1030, lseed);\n+            UNSAFE.putLong(address + 1023, lseed);\n+            UNSAFE.putLong(address + off2 + 1001, lseed);\n+        }\n+    }\n+\n+    public static class TestLongIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putLong(address+i, lseed);\n+                }\n+            }\n+\n+            UNSAFE.putLong(address + off1, lseed);\n+            UNSAFE.putLong(address + off1 + off2, lseed);\n+            UNSAFE.putLong(address + off3, lseed);\n+        }\n+    }\n+\n+    public static class TestInt {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putInt(address+i, iseed);\n+                }\n+            }\n+\n+            UNSAFE.putInt(address + off1 + 274, iseed);\n+            UNSAFE.putInt(address + 278, iseed);\n+            UNSAFE.putInt(address + off2 + 282, iseed);\n+        }\n+    }\n+\n+    public static class TestIntIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putInt(address+i, iseed);\n+                }\n+            }\n+\n+            UNSAFE.putInt(address + off1, iseed);\n+            UNSAFE.putInt(address + off1 + off2, iseed);\n+            UNSAFE.putInt(address + off3, iseed);\n+        }\n+    }\n+\n+    public static class TestShort {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putShort(address+i, sseed);\n+                }\n+            }\n+\n+            UNSAFE.putShort(address + off1 + 257, sseed);\n+            UNSAFE.putShort(address + 277, sseed);\n+            UNSAFE.putShort(address + off2 + 283, sseed);\n+        }\n+    }\n+\n+    public static class TestShortIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putShort(address+i, sseed);\n+                }\n+            }\n+\n+            UNSAFE.putShort(address + off1, sseed);\n+            UNSAFE.putShort(address + off1 + off2, sseed);\n+            UNSAFE.putShort(address + off3, sseed);\n+        }\n+    }\n+\n+    public static class TestByte {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putByte(address+i, bseed);\n+                }\n+            }\n+\n+            UNSAFE.putByte(address + off1 + 257, bseed);\n+            UNSAFE.putByte(address + 277, bseed);\n+            UNSAFE.putByte(address + off2 + 283, bseed);\n+        }\n+    }\n+\n+    public static class TestByteIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putByte(address+i, bseed);\n+                }\n+            }\n+\n+            UNSAFE.putByte(address + off1, bseed);\n+            UNSAFE.putByte(address + off1 + off2, bseed);\n+            UNSAFE.putByte(address + off3, bseed);\n+        }\n+    }\n+\n+    static void test() {\n+        TestLong t1 = new TestLong();\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + off1 + 1030), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + 1023), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + off2 + 1001), lseed, \"put long failed!\");\n+\n+        TestLongIndirect t2 = new TestLongIndirect();\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off1), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off1 + off2), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off3), lseed, \"put long failed!\");\n+\n+        TestInt t3 = new TestInt();\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + off1 + 274), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + 278), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + off2 + 282), iseed, \"put int failed!\");\n+\n+        TestIntIndirect t4 = new TestIntIndirect();\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off1), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off1 + off2), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off3), iseed, \"put int failed!\");\n+\n+        TestShort t5 = new TestShort();\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + off1 + 257), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + 277), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + off2 + 283), sseed, \"put short failed!\");\n+\n+        TestShortIndirect t6 = new TestShortIndirect();\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off1), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off1 + off2), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off3), sseed, \"put short failed!\");\n+\n+        TestByte t7 = new TestByte();\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + off1 + 257), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + 277), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + off2 + 283), bseed, \"put byte failed!\");\n+\n+        TestByteIndirect t8 = new TestByteIndirect();\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off1), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off1 + off2), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off3), bseed, \"put byte failed!\");\n+    }\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2P.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -42,2 +42,1 @@\n- *                    Shenandoah,\n- *                    ShenandoahIU}\n+ *                    Shenandoah}\n@@ -98,7 +97,0 @@\n-        case \"ShenandoahIU\":\n-            argcount = 11;\n-            procArgs = new String[argcount];\n-            procArgs[argcount - 4] = \"-XX:+UnlockExperimentalVMOptions\";\n-            procArgs[argcount - 3] = \"-XX:+UseShenandoahGC\";\n-            procArgs[argcount - 2] = \"-XX:ShenandoahGCMode=iu\";\n-            break;\n@@ -289,1 +281,0 @@\n-        case \"ShenandoahIU\":\n@@ -361,1 +352,0 @@\n-        case \"ShenandoahIU\":\n@@ -448,1 +438,0 @@\n-        case \"ShenandoahIU\":\n@@ -515,1 +504,0 @@\n-        case \"ShenandoahIU\":\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestVolatiles.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,27 +74,0 @@\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestVolatileLoad ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestVolatileStore ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileLoad ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileStore ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileCAS ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileWeakCAS ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileCAE ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileGAS ShenandoahIU\n- *\n- * @run driver compiler.c2.aarch64.TestVolatilesShenandoah\n- *      TestUnsafeVolatileGAA ShenandoahIU\n- *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestVolatilesShenandoah.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8324655 8329797\n+ * @bug 8324655 8329797 8331090\n@@ -508,1 +508,21 @@\n-    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinIConst(int a) {\n+        if (a > 65535) {\n+            a = 65535;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinLConst(long a) {\n+        if (a > 65535) {\n+            a = 65535;\n+        }\n+\n+        return a;\n+    }\n+\n+    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\", \"testMinIConst\" })\n@@ -529,0 +549,3 @@\n+\n+        Asserts.assertEQ(a > 65535 ? 65535 : a, testMinIConst(a));\n+        Asserts.assertEQ(b > 65535 ? 65535 : b, testMinIConst(b));\n@@ -531,1 +554,1 @@\n-    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n+    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\", \"testMinLConst\" })\n@@ -554,0 +577,3 @@\n+\n+        Asserts.assertEQ(a > 65535L ? 65535L : a, testMinLConst(a));\n+        Asserts.assertEQ(b > 65535L ? 65535L : b, testMinLConst(b));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.gc;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.whitebox.gc.GC;\n+\n+import java.lang.ref.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8256999\n+ * @summary Test that Reference.refersTo intrinsics are properly handled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.compiler2.enabled\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.gc.ReferenceRefersToTests\n+ *\/\n+public class ReferenceRefersToTests {\n+\n+    private static String[] args(String... add) {\n+        List<String> args = new ArrayList<>();\n+\n+         \/\/ Use PerMethodTrapLimit=0 to compile all branches in the intrinsics.\n+        args.add(\"-XX:PerMethodTrapLimit=0\");\n+\n+        \/\/ Forcefully inline all methods to reach the intrinsic code.\n+        args.add(\"-XX:CompileCommand=inline,compiler.c2.irTests.gc.ReferenceRefersToTests::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.Reference::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.PhantomReference::*\");\n+\n+        \/\/ Mix in test config code.\n+        args.addAll(Arrays.asList(add));\n+\n+        return args.toArray(new String[0]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+\n+        int idx = 0;\n+        if (GC.isSelectedErgonomically() && GC.Serial.isSupported()) {\n+            \/\/ Serial does not have any barriers in refersTo.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseSerialGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Parallel.isSupported()) {\n+            \/\/ Parallel does not have any barriers in refersTo.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseParallelGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.G1.isSupported()) {\n+            \/\/ G1 nominally needs keep-alive barriers for Reference loads,\n+            \/\/ but should not have them for refersTo.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseG1GC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Shenandoah.isSupported()) {\n+            \/\/ Shenandoah nominally needs keep-alive barriers for Reference loads,\n+            \/\/ but should not have them for refersTo. We only care to check that\n+            \/\/ SATB barrier is not emitted. Shenandoah would also emit LRB barrier,\n+            \/\/ which would false-negative the test.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:ShenandoahGCMode=passive\",\n+                \"-XX:+ShenandoahSATBBarrier\",\n+                \"-XX:+UseShenandoahGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Z.isSupported()) {\n+            \/\/ ZGC does not emit barriers in IR.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseZGC\"\n+            )));\n+        }\n+        framework.start();\n+    }\n+\n+    static final Object REF = new Object();\n+\n+    static final SoftReference<Object> SR = new SoftReference<>(REF);\n+    static final WeakReference<Object> WR = new WeakReference<>(REF);\n+    static final PhantomReference<Object> PR = new PhantomReference<>(REF, null);\n+\n+    \/\/ Verify that we are left with a single load of Reference.referent and no stores.\n+    \/\/ This serves as a signal that no GC barriers are emitted in IR.\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean soft_null() {\n+        return SR.refersTo(null);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean soft_ref() {\n+        return SR.refersTo(REF);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean weak_null() {\n+        return WR.refersTo(null);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean weak_ref() {\n+        return WR.refersTo(REF);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean phantom_null() {\n+        return PR.refersTo(null);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.STORE })\n+    public boolean phantom_ref() {\n+        return PR.refersTo(REF);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/gc\/ReferenceRefersToTests.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324345\n+ * @summary Ensure that ConnectionGraph::find_inst_mem does not cause a stack\n+ *          overflow.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileThreshold=10 -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=CompileOnly,javax.swing.plaf.basic.BasicLookAndFeel::initComponentDefaults\n+ *                   -XX:CompileCommand=MemLimit,*.*,0\n+ *                   compiler.escapeAnalysis.TestFindInstMemRecursion\n+ *\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+import javax.swing.*;\n+import javax.swing.plaf.metal.*;\n+\n+public class TestFindInstMemRecursion {\n+    public static void main(String[] args) throws Exception {\n+        LookAndFeel lookAndFeel = new MetalLookAndFeel();\n+        for (int i = 0; i < 20; ++i) {\n+            UIManager.setLookAndFeel(lookAndFeel);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestFindInstMemRecursion.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331194\n+ * @summary Check that Reduce Allocation Merges doesn't crash when an input\n+ *          of the Phi is not the _current_ output of the Phi but said input\n+ *          needs to be rematerialized because it's used regardless of the\n+ *          Phi output.\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*Picture*::*init*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*init*\n+ *                   -XX:CompileCommand=exclude,*Unloaded*::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:-UseCompressedOops\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.escapeAnalysis.TestReduceAllocationAndNestedScalarized\n+ * @run main compiler.escapeAnalysis.TestReduceAllocationAndNestedScalarized\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class TestReduceAllocationAndNestedScalarized {\n+    static class Picture {\n+        public Point first;\n+        public Point second;\n+    }\n+\n+    static class Point {\n+        int x;\n+    }\n+\n+    static class Unloaded {\n+    }\n+\n+    static int test(boolean cond) {\n+        Picture p = new Picture();\n+        p.first = new Point();\n+        Point p2 = p.first;\n+\n+        if (cond) p2 = new Point();\n+\n+        p.second = p2;\n+\n+        new Unloaded();\n+\n+        return p.first.x;\n+    }\n+\n+    public static void main(String[] args) {\n+        Picture pic = new Picture();\n+        Point pnt   = new Point();\n+        int res     = test(true);\n+        System.out.println(\"Result is: \" + res);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationAndNestedScalarized.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -203,80 +203,0 @@\n-\n-    public static Class<?> objectOnStack() {\n-        return SimpleDebugInfoTest.class;\n-    }\n-\n-    private void testObjectOnStack(DebugInfoCompiler compiler) {\n-        test(compiler, getMethod(\"objectOnStack\"), 2, JavaKind.Object);\n-    }\n-\n-    public static Class<?> objectInLocal() {\n-        Class<?> local = SimpleDebugInfoTest.class;\n-        return local;\n-    }\n-\n-    private void testObjectInLocal(DebugInfoCompiler compiler) {\n-        test(compiler, getMethod(\"objectInLocal\"), 3, JavaKind.Object);\n-    }\n-\n-    @Test\n-    public void testConstObject() {\n-        ResolvedJavaType type = metaAccess.lookupJavaType(objectOnStack());\n-        DebugInfoCompiler compiler = (asm, values) -> {\n-            values[0] = constantReflection.asJavaClass(type);\n-            return null;\n-        };\n-        testObjectOnStack(compiler);\n-        testObjectInLocal(compiler);\n-    }\n-\n-    @Test\n-    public void testRegObject() {\n-        ResolvedJavaType type = metaAccess.lookupJavaType(objectOnStack());\n-        DebugInfoCompiler compiler = (asm, values) -> {\n-            Register reg = asm.emitLoadPointer((HotSpotConstant) constantReflection.asJavaClass(type));\n-            values[0] = reg.asValue(asm.getValueKind(JavaKind.Object));\n-            return null;\n-        };\n-        testObjectOnStack(compiler);\n-        testObjectInLocal(compiler);\n-    }\n-\n-    @Test\n-    public void testStackObject() {\n-        ResolvedJavaType type = metaAccess.lookupJavaType(objectOnStack());\n-        DebugInfoCompiler compiler = (asm, values) -> {\n-            Register reg = asm.emitLoadPointer((HotSpotConstant) constantReflection.asJavaClass(type));\n-            values[0] = asm.emitPointerToStack(reg);\n-            return null;\n-        };\n-        testObjectOnStack(compiler);\n-        testObjectInLocal(compiler);\n-    }\n-\n-    @Test\n-    public void testRegNarrowObject() {\n-        Assume.assumeTrue(config.useCompressedOops);\n-        ResolvedJavaType type = metaAccess.lookupJavaType(objectOnStack());\n-        DebugInfoCompiler compiler = (asm, values) -> {\n-            HotSpotConstant wide = (HotSpotConstant) constantReflection.asJavaClass(type);\n-            Register reg = asm.emitLoadPointer((HotSpotConstant) wide.compress());\n-            values[0] = reg.asValue(asm.narrowOopKind);\n-            return null;\n-        };\n-        testObjectOnStack(compiler);\n-        testObjectInLocal(compiler);\n-    }\n-\n-    @Test\n-    public void testStackNarrowObject() {\n-        Assume.assumeTrue(config.useCompressedOops);\n-        ResolvedJavaType type = metaAccess.lookupJavaType(objectOnStack());\n-        DebugInfoCompiler compiler = (asm, values) -> {\n-            HotSpotConstant wide = (HotSpotConstant) constantReflection.asJavaClass(type);\n-            Register reg = asm.emitLoadPointer((HotSpotConstant) wide.compress());\n-            values[0] = asm.emitNarrowPointerToStack(reg);\n-            return null;\n-        };\n-        testObjectOnStack(compiler);\n-        testObjectInLocal(compiler);\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335709\n+ * @summary C2: assert(!loop->is_member(get_loop(useblock))) failed: must be outside loop\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,InfiniteLoopBadControlNeverBranch::* InfiniteLoopBadControlNeverBranch\n+ *\n+ *\/\n+\n+\n+import jdk.test.lib.Utils;\n+\n+public class InfiniteLoopBadControlNeverBranch {\n+    static int b;\n+    static short c;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        Thread thread = new Thread(() -> test());\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+\n+    static void test() {\n+        int i = 0;\n+        while (true) {\n+            if (i > 1) {\n+                b = 0;\n+            }\n+            c = (short) (b * 7);\n+            i++;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InfiniteLoopBadControlNeverBranch.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -80,2 +80,2 @@\n-        \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n-        \/\/ 2149912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n+        \/\/ total     Others    RA        HA        NA        result  #nodes  limit   time    type  #rc thread             method\n+        \/\/ 523648    32728     490920    0         0         ok      -       -       0.250   c1    1   0x00007f4ec00d4ac0 java\/lang\/Class::descriptorString(()Ljava\/lang\/String;)\n@@ -83,2 +83,3 @@\n-        \/\/ 537784    98184     208536    ok      267     -       0.096   c2    1   0x0000000153019c00  jdk\/internal\/classfile\/impl\/BufWriterImpl::writeU1((I)V) 4521912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n-        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameIncl + \".*\");\n+        \/\/ 1898600   853176    750872    0         294552    ok      934     -       1.501   c2    1   0x00007f4ec00d3330 java\/lang\/String::replace((CC)Ljava\/lang\/String;)\n+        oa.shouldMatch(\"total.*method\");\n+        oa.shouldMatch(\"\\\\d+ +(\\\\d+ +){4}ok +(\\\\d+|-) +.*\" + expectedNameIncl + \".*\");\n@@ -89,1 +90,1 @@\n-            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameExcl + \".*\");\n+            oa.shouldMatch(\"\\\\d+ +(\\\\d+ +){4}ok +(\\\\d+|-) +.*\" + expectedNameExcl + \".*\");\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335843\n+ * @summary C2 hits assert(_print_inlining_stream->size() > 0) failed: missing inlining msg\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-BackgroundCompilation -XX:+PrintCompilation -XX:+PrintInlining TestPrintInliningLateMHCall\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class TestPrintInliningLateMHCall {\n+    static final MethodHandle mh1;\n+    static MethodHandle mh2;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            mh1 = lookup.findStatic(TestPrintInliningLateMHCall.class, \"lateResolved\", MethodType.methodType(void.class));\n+            mh2 = mh1;\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper(0);\n+            testHelper(10);\n+            test();\n+        }\n+    }\n+\n+    private static void testHelper(int i) throws Throwable {\n+        MethodHandle mh = null;\n+        if (i == 10) {\n+            mh = mh1;\n+        } else {\n+            mh = mh2;\n+        }\n+        mh.invokeExact();\n+    }\n+\n+    private static void test() throws Throwable {\n+        int i;\n+        for (i = 0; i < 10; i++) {\n+\n+        }\n+        testHelper(i);\n+    }\n+\n+    private static void lateResolved() {\n+        \/\/ noop\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/TestPrintInliningLateMHCall.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -47,2 +47,0 @@\n-            a = fieldA;\n-        } else if (i > 10) {\n@@ -50,0 +48,2 @@\n+        } else if (i > 10) {\n+            a = fieldA;\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/TestPrintInliningLateVirtualCall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335393\n+ * @summary C2: assert(!had_error) failed: bad dominance\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:-UseLoopPredicate\n+ *                   -XX:LoopMaxUnroll=0 TestEmptyLoopDeadCast\n+ *\/\n+\n+public class TestEmptyLoopDeadCast {\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1Helper(1, 101, array);\n+            test1(0, array);\n+            test2Helper(0, -101, array);\n+            test2(0, array);\n+        }\n+    }\n+\n+    private static int test1(int start, int[] array) {\n+        return test1Helper(start, 0, array);\n+    }\n+\n+    private static int test1Helper(int start, int stop, int[] array) {\n+        if (array == null) {\n+        }\n+        int v = 0;\n+        for (int i = start; i < stop; i++) {\n+            v = array[i - 1];\n+        }\n+        return v;\n+    }\n+\n+    private static int test2(int start, int[] array) {\n+        return test2Helper(start, -1, array);\n+    }\n+\n+    private static int test2Helper(int start, int stop, int[] array) {\n+        if (array == null) {\n+        }\n+        int v = 0;\n+        for (int i = start-1; i > stop; i--) {\n+            v = array[-1 - i];\n+        }\n+        return v;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestEmptyLoopDeadCast.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n- * @run testng\/othervm -XX:UseSVE=0 -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorReplicateLongSpecialImmTest\n+ * @run testng\/othervm -XX:UseSVE=0 -XX:-TieredCompilation -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:CompileCommand=MemLimit,*.*,0 compiler.vectorapi.VectorReplicateLongSpecialImmTest\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReplicateLongSpecialImmTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-* @requires vm.compiler2.enabled\n+* @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch == \"aarch64\"\n+*           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh.*\")\n@@ -42,1 +43,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n+    @IR(applyIfCPUFeatureOr = {\"f16c\", \"true\", \"avx512vl\", \"true\"}, counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -123,45 +123,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n- *      TestAllocHumongousFragment\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n- *      TestAllocHumongousFragment\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestAllocHumongousFragment\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestAllocHumongousFragment\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestAllocHumongousFragment\n- *\n- * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestAllocHumongousFragment\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/TestDisableExplicitGC.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,4 +54,4 @@\n-    private static final String[] defaultValid = new String[] {\n-        \"0\", \"1\", \"50\", \"95\", \"100\" };\n-    private static final String[] defaultInvalid = new String[] {\n-        \"-10\", \"110\", \"bad\" };\n+    private static final String[] rangeOneToHundredValid = new String[] {\n+        \"1\", \"50\", \"95\", \"100\" };\n+    private static final String[] rangeOneToHundredInvalid = new String[] {\n+        \"0\", \"-10\", \"110\", \"bad\" };\n@@ -61,1 +61,1 @@\n-        new OptionDescription(\"G1ConfidencePercent\", defaultValid, defaultInvalid)\n+        new OptionDescription(\"G1ConfidencePercent\", rangeOneToHundredValid, rangeOneToHundredInvalid)\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1PercentageOptions.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -138,50 +138,0 @@\n-\n-\/*\n- * @test id=iu-aggressive\n- * @summary Acceptance tests: collector can withstand allocation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestAllocIntArrays\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can withstand allocation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestAllocIntArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestAllocIntArrays\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -138,50 +138,0 @@\n-\n-\/*\n- * @test id=iu-aggressive\n- * @summary Acceptance tests: collector can withstand allocation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n- *      TestAllocObjectArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n- *      TestAllocObjectArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestAllocObjectArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestAllocObjectArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestAllocObjectArrays\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can withstand allocation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestAllocObjectArrays\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestAllocObjectArrays\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -115,46 +115,0 @@\n-\n-\/*\n- * @test id=iu-aggressive\n- * @summary Acceptance tests: collector can withstand allocation\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n- *      TestAllocObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n- *      TestAllocObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestAllocObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestAllocObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestAllocObjects\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can withstand allocation\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestAllocObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestAllocObjects\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -85,22 +85,0 @@\n- *\/\n-\n-\/*\n- * @test id=iu-aggressive\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dtarget=1000\n- *      TestDynamicSoftMaxHeapSize\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -Dtarget=10000\n- *      TestDynamicSoftMaxHeapSize\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -79,18 +79,0 @@\n-\/**\n- * @test id=iu\n- * @summary Test Shenandoah GC uses concurrent\/parallel threads correctly\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:ConcGCThreads=2 -XX:ParallelGCThreads=4\n- *      -Dtarget=1000\n- *      TestGCThreadGroups\n- *\n- * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:ConcGCThreads=2 -XX:ParallelGCThreads=4\n- *      -Dtarget=1000\n- *      TestGCThreadGroups\n-*\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestGCThreadGroups.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -87,21 +87,0 @@\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can withstand allocation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestHeapUncommit\n- *\n- * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestHeapUncommit\n- *\n- * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestHeapUncommit\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHeapUncommit.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,32 +97,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @library \/test\/lib\n- * @modules jdk.attach\/com.sun.tools.attach\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestJcmdHeapDump\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestJcmdHeapDump\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestJcmdHeapDump\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules jdk.attach\/com.sun.tools.attach\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestJcmdHeapDump\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestJcmdHeapDump.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -94,32 +94,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      -Dtarget=1000\n- *      TestLotsOfCycles\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      -Dtarget=1000\n- *      TestLotsOfCycles\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dtarget=1000\n- *      TestLotsOfCycles\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -Dtarget=10000\n- *      TestLotsOfCycles\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLotsOfCycles.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-             {{\"iu\"},      {\"adaptive\", \"aggressive\"}},\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestObjItrWithHeapDump.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,30 +100,0 @@\n-        testWith(\"Zero interval with iu mode\",\n-                 false,\n-                 \"-Xlog:gc\",\n-                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                 \"-XX:+UnlockExperimentalVMOptions\",\n-                 \"-XX:+UseShenandoahGC\",\n-                 \"-XX:ShenandoahGCMode=iu\",\n-                 \"-XX:ShenandoahGuaranteedGCInterval=0\"\n-        );\n-\n-        testWith(\"Short interval with iu mode\",\n-                 true,\n-                 \"-Xlog:gc\",\n-                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                 \"-XX:+UnlockExperimentalVMOptions\",\n-                 \"-XX:+UseShenandoahGC\",\n-                 \"-XX:ShenandoahGCMode=iu\",\n-                 \"-XX:ShenandoahGuaranteedGCInterval=1000\"\n-        );\n-\n-        testWith(\"Long interval with iu mode\",\n-                 false,\n-                 \"-Xlog:gc\",\n-                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                 \"-XX:+UnlockExperimentalVMOptions\",\n-                 \"-XX:+UseShenandoahGC\",\n-                 \"-XX:ShenandoahGCMode=iu\",\n-                 \"-XX:ShenandoahGuaranteedGCInterval=100000\" \/\/ deliberately too long\n-        );\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,12 +38,0 @@\n-\/* @test id=iu\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      gc.shenandoah.TestReferenceRefersToShenandoah\n- *\/\n-\n@@ -63,13 +51,0 @@\n-\/* @test id=iu-100\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @modules java.base\n- * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n- *      gc.shenandoah.TestReferenceRefersToShenandoah\n- *\/\n-\n@@ -203,4 +178,0 @@\n-    private static boolean isShenandoahIUMode() {\n-        return \"iu\".equals(WB.getStringVMFlag(\"ShenandoahGCMode\"));\n-    }\n-\n@@ -242,8 +213,1 @@\n-            \/\/ This is true for all currently supported concurrent collectors,\n-            \/\/ except Shenandoah+IU, which allows clearing refs even when\n-            \/\/ accessed during concurrent marking.\n-            if (isShenandoahIUMode()) {\n-              expectCleared(testWeak4, \"testWeak4\");\n-            } else {\n-              expectNotCleared(testWeak4, \"testWeak4\");\n-            }\n+            expectNotCleared(testWeak4, \"testWeak4\");\n@@ -264,6 +228,4 @@\n-            if (!isShenandoahIUMode()) {\n-                if (obj4 == null) {\n-                    fail(\"testWeak4.get() returned null\");\n-                } else if (obj4.value != 4) {\n-                    fail(\"testWeak4.get().value is \" + obj4.value);\n-                }\n+            if (obj4 == null) {\n+                fail(\"testWeak4.get() returned null\");\n+            } else if (obj4.value != 4) {\n+                fail(\"testWeak4.get().value is \" + obj4.value);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceRefersToShenandoah.java","additions":5,"deletions":43,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -39,13 +39,0 @@\n-\/* @test id=iu-100\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @modules java.base\n- * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n- *      gc.shenandoah.TestReferenceShortcutCycle\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceShortcutCycle.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,19 +44,0 @@\n-\/*\n- * @test id=iu\n- * @summary Test that null references\/referents work fine\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestRefprocSanity\n- *\n- * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestRefprocSanity\n- *\n- * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestRefprocSanity\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRefprocSanity.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,19 +76,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahRegionSampling\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestRegionSampling\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahRegionSampling\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestRegionSampling\n- *\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSampling.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -141,40 +141,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @key randomness\n- * @summary Test that Shenandoah is able to work with(out) resizeable TLABs\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahVerify\n- *      -XX:+ResizeTLAB\n- *      TestResizeTLAB\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahVerify\n- *      -XX:-ResizeTLAB\n- *      TestResizeTLAB\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @key randomness\n- * @summary Test that Shenandoah is able to work with(out) resizeable TLABs\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      -XX:+ResizeTLAB\n- *      TestResizeTLAB\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      -XX:-ResizeTLAB\n- *      TestResizeTLAB\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestResizeTLAB.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -117,35 +117,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @summary Acceptance tests: collector can deal with retained objects\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestRetainObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestRetainObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestRetainObjects\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can deal with retained objects\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestRetainObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestRetainObjects\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -130,39 +130,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @summary Acceptance tests: collector can deal with retained objects\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      TestSieveObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      TestSieveObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestSieveObjects\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @summary Acceptance tests: collector can deal with retained objects\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestSieveObjects\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestSieveObjects\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -68,18 +68,0 @@\n-\/*\n- * @test id=iu\n- * @summary Test Shenandoah string deduplication implementation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:open\n- *          java.management\n- *\n- * @run main\/othervm -Xmx256m -Xlog:gc+stats -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:StringDeduplicationAgeThreshold=3\n- *      TestStringDedup\n- *\n- * @run main\/othervm -Xmx256m -Xlog:gc+stats -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive -XX:StringDeduplicationAgeThreshold=3\n- *      TestStringDedup\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedup.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,31 +75,0 @@\n- \/*\n- * @test id=iu\n- * @summary Test Shenandoah string deduplication implementation\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:open\n- *          java.management\n- *\n- * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestStringDedupStress\n- *\n- * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -DtargetStrings=2000000\n- *      TestStringDedupStress\n- *\n- * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      -DtargetStrings=2000000\n- *      TestStringDedupStress\n- *\n- * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      -DtargetStrings=2000000\n- *      TestStringDedupStress\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedupStress.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -78,20 +78,0 @@\n-\/*\n- * @test id=iu\n- * @summary Check that Shenandoah cleans up interned strings\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestStringInternCleanup\n- *\n- * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahVerify\n- *      TestStringInternCleanup\n- *\n- * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestStringInternCleanup\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringInternCleanup.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -61,27 +61,0 @@\n-\/*\n- * @test id=iu\n- * @summary Tests that we pass at least one jcstress-like test with all verification turned on\n- * @requires vm.gc.Shenandoah\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      TestVerifyJCStress\n- *\/\n-\n-\/*\n- * @test id=iu-c1\n- * @summary Tests that we pass at least one jcstress-like test with all verification turned on\n- * @requires vm.gc.Shenandoah\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify -XX:TieredStopAtLevel=1\n- *      TestVerifyJCStress\n- *\/\n-\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyJCStress.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n- * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC                         TestWrongArrayMember\n- * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC TestWrongArrayMember\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWrongArrayMember.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -Xcomp -XX:CompileOnly=BarrierInInfiniteLoop::test1\n- *                   -XX:CompileOnly=BarrierInInfiniteLoop::test2 -XX:CompileOnly=BarrierInInfiniteLoop::test3 -XX:CompileCommand=quiet BarrierInInfiniteLoop\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/BarrierInInfiniteLoop.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * bug 8280885\n- * @summary Shenandoah: Some tests failed with \"EA: missing allocation reference path\"\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -XX:-BackgroundCompilation -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=iu\n- *                   -XX:CompileCommand=dontinline,TestUnexpectedIUBarrierEA::notInlined TestUnexpectedIUBarrierEA\n- *\/\n-\n-public class TestUnexpectedIUBarrierEA {\n-\n-    private static Object field;\n-\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            test(false);\n-        }\n-    }\n-\n-    private static void test(boolean flag) {\n-        A a = new A();\n-        B b = new B();\n-        b.field = a;\n-        notInlined();\n-        Object o = b.field;\n-        if (!(o instanceof A)) {\n-\n-        }\n-        C c = new C();\n-        c.field = o;\n-        if (flag) {\n-            field = c.field;\n-        }\n-    }\n-\n-    private static void notInlined() {\n-\n-    }\n-\n-    private static class A {\n-    }\n-\n-    private static class B {\n-        public Object field;\n-    }\n-\n-    private static class C {\n-        public Object field;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestUnexpectedIUBarrierEA.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -90,17 +90,0 @@\n-\/*\n- * @test id=iu\n- * @summary Check that MX notifications are reported for all cycles\n- * @library \/test\/lib \/\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dprecise=false\n- *      TestChurnNotifications\n- *\n- * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -Dprecise=false\n- *      TestChurnNotifications\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -86,15 +86,0 @@\n-\/*\n- * @test id=iu\n- * @summary Check that MX notifications are reported for all cycles\n- * @library \/test\/lib \/\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      TestPauseNotifications\n- *\n- * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      TestPauseNotifications\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-             {{\"iu\"},      {\"adaptive\", \"aggressive\"}},\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,18 +128,0 @@\n-\n-        {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-Xlog:gc\",\n-                    \"-XX:+ExplicitGCInvokesConcurrent\",\n-                    \"-XX:ShenandoahGCMode=iu\",\n-                    TestExplicitGC.class.getName(),\n-                    \"test\");\n-            for (String p : full) {\n-                output.shouldNotContain(p);\n-            }\n-            for (String p : concNormal) {\n-                output.shouldContain(p);\n-            }\n-         }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestExplicitGC.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-        testWith(\"-XX:ShenandoahGCMode=iu\",      Mode.EXPERIMENTAL);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                new String[] { \"ShenandoahSATBBarrier\", \"ShenandoahIUBarrier\" },\n+                new String[] { \"ShenandoahSATBBarrier\" },\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSelectiveBarrierFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,7 +47,0 @@\n-        String[] iu = {\n-                \"ShenandoahLoadRefBarrier\",\n-                \"ShenandoahIUBarrier\",\n-                \"ShenandoahCASBarrier\",\n-                \"ShenandoahCloneBarrier\",\n-                \"ShenandoahStackWatermarkBarrier\",\n-        };\n@@ -59,1 +52,0 @@\n-        shouldFailAll(\"-XX:ShenandoahGCMode=iu\",               iu);\n@@ -61,1 +53,0 @@\n-        shouldPassAll(\"-XX:ShenandoahGCMode=passive\",          iu);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierDisable.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test that disabling wrong barriers fails early\n+ * @summary Test that SATB barrier may be enabled for all modes\n@@ -41,3 +41,0 @@\n-                \"ShenandoahIUBarrier\",\n-        };\n-        String[] iu = {\n@@ -46,6 +43,4 @@\n-\n-        shouldFailAll(\"-XX:ShenandoahGCHeuristics=adaptive\",   concurrent);\n-        shouldFailAll(\"-XX:ShenandoahGCHeuristics=static\",     concurrent);\n-        shouldFailAll(\"-XX:ShenandoahGCHeuristics=compact\",    concurrent);\n-        shouldFailAll(\"-XX:ShenandoahGCHeuristics=aggressive\", concurrent);\n-        shouldFailAll(\"-XX:ShenandoahGCMode=iu\",               iu);\n+        shouldPassAll(\"-XX:ShenandoahGCHeuristics=adaptive\",   concurrent);\n+        shouldPassAll(\"-XX:ShenandoahGCHeuristics=static\",     concurrent);\n+        shouldPassAll(\"-XX:ShenandoahGCHeuristics=compact\",    concurrent);\n+        shouldPassAll(\"-XX:ShenandoahGCHeuristics=aggressive\", concurrent);\n@@ -53,1 +48,0 @@\n-        shouldPassAll(\"-XX:ShenandoahGCMode=passive\",          iu);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierEnable.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -102,41 +102,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @key stress\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient\n- * @summary Stress the Shenandoah GC by trying to make old objects more likely to be garbage than young objects.\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @key stress\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient\n- * @summary Stress the Shenandoah GC by trying to make old objects more likely to be garbage than young objects.\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\/\n-\n@@ -224,47 +183,0 @@\n-\/*\n- * @test id=iu-aggressive-deopt-nmethod\n- * @key stress\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n- * @summary Stress Shenandoah GC with nmethod barrier forced deoptimization enabled.\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n- *      -XX:+ShenandoahAllocFailureALot\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\/\n-\n-\/*\n- * @test id=iu-deopt-nmethod\n- * @key stress\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n- * @summary Stress Shenandoah GC with nmethod barrier forced deoptimization enabled.\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\n- * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n- *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n- *\/\n-\n-\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithShenandoah.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -105,39 +105,0 @@\n-\/*\n- * @test id=iu-aggressive\n- * @key stress randomness\n- * @library \/ \/test\/lib\n- * @requires vm.gc.Shenandoah\n- * @summary Stress the GC by trying to make old objects more likely to be garbage than young objects.\n- *\n- * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahOOMDuringEvacALot\n- *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n- *\n- * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahAllocFailureALot\n- *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n- *\n- * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n- *\/\n-\n-\/*\n- * @test id=iu\n- * @key stress randomness\n- * @library \/ \/test\/lib\n- * @requires vm.gc.Shenandoah\n- * @summary Stress the GC by trying to make old objects more likely to be garbage than young objects.\n- *\n- * @run main\/othervm\/timeout=600 -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n- *\n- * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOldWithShenandoah.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -43,14 +43,0 @@\n-\n-\/*\n- * @test id=iu\n- * @key stress\n- * @library \/\n- * @requires vm.gc.Shenandoah\n- * @summary Stress the Shenandoah GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n- *\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahVerify\n- *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n- *\n- *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332125\n+ * @summary Test to verify correctness of total malloc and mmap diffs\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary -Xms32m -Xmx32m TotalMallocMmapDiffTest\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TotalMallocMmapDiffTest {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final long ALLOCATE_SIZE = 250 * 1024 * 1024; \/\/ 250MB\n+    private static final double FUDGE_FACTOR = 0.2;\n+    private static final double UPPER_BOUND = ALLOCATE_SIZE * (1 + FUDGE_FACTOR);\n+    private static final double LOWER_BOUND = ALLOCATE_SIZE * (1 - FUDGE_FACTOR);\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Get baseline\n+        OutputAnalyzer output = NMTTestUtils.startJcmdVMNativeMemory(\"baseline=true\", \"scale=1\");\n+        output.shouldContain(\"Baseline taken\");\n+\n+        \/\/ Allocate some memory via malloc\n+        long addr = wb.NMTMalloc(ALLOCATE_SIZE);\n+\n+        \/\/ Virtually reserve and commit memory\n+        addr = wb.NMTReserveMemory(ALLOCATE_SIZE);\n+        wb.NMTCommitMemory(addr, ALLOCATE_SIZE);\n+\n+        \/\/ Get NMT diff\n+        output = NMTTestUtils.startJcmdVMNativeMemory(\"summary.diff\", \"scale=1\");\n+\n+        \/\/ Verify malloc diff accounts for memory allocation with a fudge factor\n+        long mallocDiff = getMallocDiff(output);\n+        if (mallocDiff < LOWER_BOUND || mallocDiff > UPPER_BOUND) {\n+            throw new Exception(\"Total malloc diff is incorrect. \" +\n+                    \"Expected malloc diff range: [\" + LOWER_BOUND + \" - \" + UPPER_BOUND + \"]\" +\n+                    \"Actual malloc diff: \" + mallocDiff);\n+        }\n+\n+        \/\/ Verify mmap diff accounts for reserve and commit\n+        long reservedDiff = getReservedDiff(output);\n+        long committedDiff = getCommittedDiff(output);\n+        if (reservedDiff < LOWER_BOUND || reservedDiff > UPPER_BOUND) {\n+            throw new Exception(\"mmap reserved diff is incorrect. \" +\n+                    \"Expected reserved diff range: [\" + LOWER_BOUND + \" - \" + UPPER_BOUND + \"]\" +\n+                    \"Actual reserved diff: \" + reservedDiff);\n+        }\n+        if (committedDiff < LOWER_BOUND || committedDiff > UPPER_BOUND) {\n+            throw new Exception(\"mmap committed diff is incorrect. \" +\n+                    \"Expected committed diff range: [\" + LOWER_BOUND + \" - \" + UPPER_BOUND + \"]\" +\n+                    \"Actual committed diff: \" + committedDiff);\n+        }\n+\n+    }\n+\n+    private static long getMallocDiff(OutputAnalyzer output) {\n+        \/\/ First match should be global malloc diff\n+        String malloc = output.firstMatch(\"malloc=\\\\d+ \\\\+(\\\\d+)\", 1);\n+        return Long.parseLong(malloc);\n+    }\n+\n+    private static long getReservedDiff(OutputAnalyzer output) {\n+        \/\/ First match should be global mmap diff\n+        String reservedDiff = output.firstMatch(\"mmap: reserved=\\\\d+ \\\\+(\\\\d+)\", 1);\n+        return Long.parseLong(reservedDiff);\n+    }\n+\n+    private static long getCommittedDiff(OutputAnalyzer output) {\n+        \/\/ First match should be global mmap diff\n+        String committedDiff = output.firstMatch(\"mmap: reserved=\\\\d+ \\\\+\\\\d+, committed=\\\\d+ \\\\+(\\\\d+)\", 1);\n+        return Long.parseLong(committedDiff);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/TotalMallocMmapDiffTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325945\n+ * @summary Test abridged VM String printing\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI StringPrinting\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class StringPrinting {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    static void checkEqual(String s1, String s2) {\n+        if (!s1.equals(s2)) {\n+            throw new RuntimeException(\"Different strings: \" + s1 + \" vs \" + s2);\n+        }\n+    }\n+\n+    static void checkEqual(int len1, int len2) {\n+        if (len1 != len2) {\n+            throw new RuntimeException(\"Different lengths: \" + len1 + \" vs \" + len2);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Modified string format is \"xxx ... (N characters ommitted) ... xxx\" (abridged)\n+        final String elipse = \" ... \";\n+        final String text = \" characters ommitted)\";\n+        final String abridged = \"\\\" (abridged) \";\n+\n+        \/\/ Define a set of maxLengths for ease of inspection in the test outout\n+        \/\/ Note: maxLength must be >= 2\n+        int[] maxLengths = new int[] { 2, 3, 16, 256, 512 };\n+        for (int maxLength : maxLengths) {\n+            \/\/ Test string lengths around maxLength and \"much\" bigger\n+            \/\/ than maxLength\n+            int[] strLengths = new int[] { maxLength - 1,\n+                                           maxLength,\n+                                           maxLength + 1,\n+                                           2 * maxLength\n+            };\n+            for (int length : strLengths) {\n+                System.out.println(\"Testing string length \" + length + \" with maxLength \" + maxLength);\n+                String s = \"x\".repeat(length);\n+                String r = WB.printString(s, maxLength);\n+                if (length <= maxLength) {\n+                    \/\/ Strip off the double-quotes that surround the string\n+                    if (r.charAt(0) == '\\\"' && r.charAt(r.length() - 1) == '\\\"') {\n+                        r = r.substring(1, r.length() - 1);\n+                    } else {\n+                        throw new RuntimeException(\"String was not quoted as expected: \" + r);\n+                    }\n+                    checkEqual(s, r);\n+                } else {\n+                    \/\/ Strip off leading double-quote\n+                    if (r.charAt(0) == '\\\"') {\n+                        r = r.substring(1, r.length());\n+                    } else {\n+                        throw new RuntimeException(\"String was not quoted as expected: \" + r);\n+                    }\n+\n+                    \/\/ Strip off abridged\n+                    if (r.endsWith(abridged)) {\n+                        r = r.substring(0, r.length() - abridged.length());\n+                    } else {\n+                        throw new RuntimeException(\"String was not marked abridged as expected: \" + r);\n+                    }\n+\n+                    \/\/ Now extract the two \"halves\"\n+                    int elipseStart = r.indexOf(elipse);\n+                    String firstHalf = r.substring(0, elipseStart);\n+                    int secondElipseStart = r.lastIndexOf(elipse);\n+                    String secondHalf = r.substring(secondElipseStart + elipse.length(), r.length());\n+\n+                    System.out.println(\"S1: >\" + firstHalf + \"<\");\n+                    System.out.println(\"S2: >\" + secondHalf + \"<\");\n+\n+                    checkEqual(firstHalf.length(), maxLength \/ 2);\n+                    checkEqual(secondHalf.length(), maxLength \/2);\n+\n+                    \/\/ Now check number of characters ommitted\n+                    String tail = r.substring(r.indexOf(\"(\"), r.length());\n+                    int numberEnd = tail.indexOf(\" \");\n+                    String nChars = tail.substring(1, numberEnd);\n+                    System.out.println(\"N: >\" + nChars + \"<\");\n+\n+                    \/\/ Now add all the bits back together to get the expected full length\n+                    int fullLength = maxLength \/ 2 + elipse.length() + 1 \/* for ( *\/\n+                        + nChars.length() + text.length() + elipse.length() + maxLength \/ 2;\n+                    checkEqual(r.length(), fullLength);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/PrintingTests\/StringPrinting.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,4 @@\n+        if (archiveFileName.contains(\"%p\")) {\n+            archiveFileName = archiveFileName.replace(\"%p\", \"%d\").formatted(pid);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDumpBase.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,7 @@\n+        \/\/ Test static dump with file name containing %p\n+        print2ln(test_count++ + \" Test static dump with given file name containing %p.\");\n+        app = createLingeredApp(\"-cp\", allJars);\n+        pid = app.getPid();\n+        test(\"%p.jsa\", pid, noBoot, EXPECT_PASS, STATIC_MESSAGES);\n+        app.stopApp();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestStaticDump.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/Bad_NCDFE_Msg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -52,0 +53,1 @@\n+        testFileName();\n@@ -162,0 +164,27 @@\n+    public void testFileName() throws Exception {\n+        \/\/ --- Testing options\n+        long pid = ProcessTools.getProcessId();\n+\n+        \/\/ Test pid gets injected into %p\n+        String name = \"name\";\n+        DiagnosticCommand arg = new DiagnosticCommand(name,\n+                \"desc\", DiagnosticArgumentType.FILE,\n+                false, null);\n+        DiagnosticCommand[] args = {arg};\n+        parse(name, \"file%d.txt\".formatted(pid), name + \"=file%p.txt\", args);\n+\n+        \/\/ Test custom file name with no %p\n+        parse(name, \"myFile.txt\", name + \"=myFile.txt\", args);\n+\n+        \/\/ --- Testing arguments\n+\n+        \/\/ Test pid gets injected into %p\n+        arg = new DiagnosticCommand(name, \"desc\", DiagnosticArgumentType.FILE, true,\n+                false, null);\n+        args = new DiagnosticCommand[]{arg};\n+        parse(name, \"file%d.txt\".formatted(pid), \"file%p.txt\", args);\n+\n+        \/\/ Test custom file name with no %p\n+        parse(name, \"myFile.txt\", \"myFile.txt\", args);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/ParserTest.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests that long arguments of attach operation are not truncated\n+ * @bug 8334168\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/sun.tools.attach\n+ * @run main LongArgTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import sun.tools.attach.HotSpotVirtualMachine;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LongArgTest {\n+\n+    \/\/ current restriction: max arg size is 1024\n+    private static int MAX_ARG_SIZE = 1024;\n+\n+    public static void main(String[] args) throws Exception {\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp();\n+\n+            \/\/ sanity\n+            test(app)\n+                .mustSucceed()\n+                .run();\n+\n+            test(app)\n+                .valueLength(MAX_ARG_SIZE)\n+                .mustSucceed()\n+                .run();\n+\n+            test(app)\n+                .valueLength(MAX_ARG_SIZE + 1)\n+                .run();\n+\n+            \/\/ more than max args (3) with MAX_ARG_SIZE\n+            test(app)\n+                .valueLength(3 * MAX_ARG_SIZE + 1)\n+                .run();\n+\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+\n+    private static Test test(LingeredApp app) {\n+        return new Test(app);\n+    }\n+\n+    \/\/ For simplicity, the test uses internal HotSpotVirtualMachine,\n+    \/\/ sets\/gets \"HeapDumpPath\" flag value (string flag, not validated by JVM).\n+    private static class Test {\n+        private LingeredApp app;\n+        private String flagName = \"HeapDumpPath\";\n+        private String flagValue = generateValue(5);\n+        private boolean setFlagMustSucceed = false;\n+\n+        Test(LingeredApp app) {\n+            this.app = app;\n+        }\n+\n+        Test valueLength(int len) {\n+            flagValue = generateValue(len);\n+            return this;\n+        }\n+\n+        Test mustSucceed() {\n+            setFlagMustSucceed = true;\n+            return this;\n+        }\n+\n+        void run() throws Exception {\n+            System.out.println(\"======== Start ========\");\n+            System.out.println(\"Arg size = \" + flagValue.length());\n+\n+            HotSpotVirtualMachine vm = (HotSpotVirtualMachine)VirtualMachine.attach(String.valueOf(app.getPid()));\n+\n+            if (setFlag(vm)) {\n+                String actualValue = getFlag(vm);\n+\n+                if (!flagValue.equals(actualValue)) {\n+                    String msg = \"Actual value is different: \";\n+                    if (actualValue == null) {\n+                        msg += \"null\";\n+                    } else if (flagValue.startsWith(actualValue)) {\n+                        msg += \"truncated from \" + flagValue.length() + \" to \" + actualValue.length();\n+                    } else {\n+                        msg += actualValue + \", expected value: \" + flagValue;\n+                    }\n+                    System.out.println(msg);\n+                    vm.detach();\n+                    throw new RuntimeException(msg);\n+                } else {\n+                    System.out.println(\"Actual value matches: \" + actualValue);\n+                }\n+            }\n+\n+            vm.detach();\n+\n+            System.out.println(\"======== End ========\");\n+            System.out.println();\n+        }\n+\n+        \/\/ Sets the flag value, return true on success.\n+        private boolean setFlag(HotSpotVirtualMachine vm) throws Exception {\n+            BufferedReader replyReader = null;\n+            try {\n+                replyReader = new BufferedReader(new InputStreamReader(\n+                    vm.setFlag(flagName, flagValue)));\n+            } catch (IOException ex) {\n+                if (setFlagMustSucceed) {\n+                    throw ex;\n+                }\n+                System.out.println(\"OK: setFlag() thrown exception:\");\n+                ex.printStackTrace(System.out);\n+                return false;\n+            }\n+\n+            String line;\n+            while ((line = replyReader.readLine()) != null) {\n+                System.out.println(\"setFlag: \" + line);\n+            }\n+            replyReader.close();\n+            return true;\n+        }\n+\n+        private String getFlag(HotSpotVirtualMachine vm) throws Exception {\n+            \/\/ Then read and make sure we get back the same value.\n+            BufferedReader replyReader = new BufferedReader(new InputStreamReader(vm.printFlag(flagName)));\n+\n+            String prefix = \"-XX:\" + flagName + \"=\";\n+            String value = null;\n+            String line;\n+            while((line = replyReader.readLine()) != null) {\n+                System.out.println(\"getFlag: \" + line);\n+                if (line.startsWith(prefix)) {\n+                    value = line.substring(prefix.length());\n+                }\n+            }\n+            return value;\n+        }\n+\n+        private String generateValue(int len) {\n+            return \"X\" + \"A\".repeat(len - 2) + \"X\";\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/LongArgTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -50,2 +50,2 @@\n-        \/\/ total     NA        RA        result  #nodes  time    type  #rc thread              method\n-        \/\/ 211488    66440     77624     ok      13      0.057   c2    2   0x00007fb49428db70  compiler\/print\/CompileCommandPrintMemStat$TestMain::method1(()V)\n+        \/\/ total     Others    RA        HA        NA        result  #nodes  limit   time    type  #rc thread             method\n+        \/\/ 1898600   853176    750872    0         294552    ok      934     -       1.501   c2    1   0x00007f4ec00d3330 java\/lang\/String::replace((CC)Ljava\/lang\/String;)\n@@ -53,1 +53,1 @@\n-        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n+        out.shouldMatch(\"\\\\d+ +(\\\\d+ +){4}\\\\S+ +\\\\d+.*java.*\\\\(.*\\\\)\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,12 @@\n+\n+    @Test\n+    public void logErrorsDcmdOutputStream() throws IOException {\n+        String test_dir = System.getProperty(\"test.dir\", \".\");\n+        Path path = Paths.get(\"nonexistent\", test_dir);\n+        try {\n+            OutputAnalyzer output = new JMXExecutor().execute(\"Compiler.perfmap %s\".formatted(path));\n+            output.shouldContain(\"Warning: Failed to create nonexistent\/%s for perf map\".formatted(test_dir));\n+        } finally {\n+            Files.deleteIfExists(path);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/PerfMapTest.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-        \/\/ vdso library, should be part of all user space apps on all architectures OpenJDK supports.\n-        regexBase_committed + \"\\\\[vdso\\\\]\",\n+        \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n+        regexBase_committed + \"\\\\[heap\\\\]\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8185164 8320515\n+ * @bug 8185164 8320515 8334085\n@@ -89,0 +89,3 @@\n+                \/\/ Extra unmount helps to reproduce 8334085.\n+                \/\/ Two sub-sequential thaws are needed in that scenario.\n+                Thread.yield();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=23m -XX:MaxMetaspaceSize=23m RedefineLeakThrowable\n+ * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=25m -XX:MaxMetaspaceSize=25m RedefineLeakThrowable\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 14);\n+        checkFrames(vThread1, false, 13);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -29,1 +30,1 @@\n- * @run junit\/othervm\/native GetThreadStateTest\n+ * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED GetThreadStateTest\n@@ -35,0 +36,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -36,1 +38,1 @@\n- * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations GetThreadStateTest\n+ * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations --enable-native-access=ALL-UNNAMED GetThreadStateTest\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -46,0 +49,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -54,0 +59,5 @@\n+\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n@@ -108,1 +118,1 @@\n-     * Test state of thread waiting to enter a monitor.\n+     * Test state of thread waiting to enter a monitor when pinned and not pinned.\n@@ -110,3 +120,4 @@\n-    @Test\n-    void testMonitorEnter() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testMonitorEnter(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -115,2 +126,9 @@\n-            started.set(true);\n-            synchronized (lock) { }\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    synchronized (lock) { }\n+                });\n+            } else {\n+                ready.set(true);\n+                synchronized (lock) { }\n+            }\n@@ -122,1 +140,1 @@\n-                awaitTrue(started);\n+                awaitTrue(ready);\n@@ -138,1 +156,1 @@\n-     * Test state of thread waiting in Object.wait().\n+     * Test state of thread waiting in Object.wait() when pinned and not pinned.\n@@ -140,3 +158,4 @@\n-    @Test\n-    void testObjectWait() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWait(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -146,1 +165,0 @@\n-                started.set(true);\n@@ -148,1 +166,9 @@\n-                    lock.wait();\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n@@ -154,1 +180,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -180,1 +206,1 @@\n-     * Test state of thread waiting in Object.wait(millis).\n+     * Test state of thread waiting in Object.wait(millis) when pinned and not pinned.\n@@ -182,3 +208,4 @@\n-    @Test\n-    void testObjectWaitMillis() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitMillis(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -188,4 +215,13 @@\n-                started.set(true);\n-                try {\n-                    lock.wait(Long.MAX_VALUE);\n-                } catch (InterruptedException e) { }\n+                synchronized (lock) {\n+                    try {\n+                        if (pinned) {\n+                            VThreadPinner.runPinned(() -> {\n+                                ready.set(true);\n+                                lock.wait(Long.MAX_VALUE);\n+                            });\n+                        } else {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        }\n+                    } catch (InterruptedException e) { }\n+                }\n@@ -196,1 +232,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -222,1 +258,1 @@\n-     * Test state of thread parked with LockSupport.park.\n+     * Test state of thread parked with LockSupport.park when pinned and not pinned.\n@@ -224,3 +260,4 @@\n-    @Test\n-    void testPark() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testPark(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -229,62 +266,9 @@\n-            started.set(true);\n-            while (!done.get()) {\n-                LockSupport.park();\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread to start execution\n-            awaitTrue(started);\n-\n-            \/\/ thread should park\n-            int expected = JVMTI_THREAD_STATE_ALIVE |\n-                    JVMTI_THREAD_STATE_WAITING |\n-                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n-                    JVMTI_THREAD_STATE_PARKED;\n-            await(thread, expected);\n-        } finally {\n-            done.set(true);\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test state of thread parked with LockSupport.parkNanos.\n-     *\/\n-    @Test\n-    void testParkNanos() throws Exception {\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            started.set(true);\n-            while (!done.get()) {\n-                LockSupport.parkNanos(Long.MAX_VALUE);\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread to start execution\n-            awaitTrue(started);\n-\n-            \/\/ thread should park\n-            int expected = JVMTI_THREAD_STATE_ALIVE |\n-                    JVMTI_THREAD_STATE_WAITING |\n-                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n-                    JVMTI_THREAD_STATE_PARKED;\n-            await(thread, expected);\n-        } finally {\n-            done.set(true);\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test state of thread parked with LockSupport.park while holding a monitor.\n-     *\/\n-    @Test\n-    void testParkWhenPinned() throws Exception {\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            VThreadPinner.runPinned(() -> {\n-                started.set(true);\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -294,1 +278,1 @@\n-            });\n+            }\n@@ -298,1 +282,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -314,1 +298,1 @@\n-     * Test state of thread parked with LockSupport.parkNanos while holding a monitor.\n+     * Test state of thread parked with LockSupport.parkNanos when pinned and not pinned.\n@@ -316,3 +300,4 @@\n-    @Test\n-    void testParkNanosWhenPinned() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testParkNanos(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -321,2 +306,9 @@\n-            VThreadPinner.runPinned(() -> {\n-                started.set(true);\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -326,1 +318,1 @@\n-            });\n+            }\n@@ -330,1 +322,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":94,"deletions":102,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n@@ -32,1 +34,0 @@\n- *     -Djdk.virtualThreadScheduler.parallelism=9\n@@ -37,2 +38,1 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -42,24 +42,1 @@\n-\n-\/*\n- * The test uses custom implementation of the CountDownLatch class.\n- * The reason is we want the state of tested thread to be predictable.\n- * With java.util.concurrent.CountDownLatch it is not clear what thread state is expected.\n- *\/\n-class CountDownLatch {\n-    private int count = 0;\n-\n-    CountDownLatch(int count) {\n-        this.count = count;\n-    }\n-\n-    public synchronized void countDown() {\n-        count--;\n-        notify();\n-    }\n-\n-    public synchronized void await() throws InterruptedException {\n-        while (count > 0) {\n-            wait(1);\n-        }\n-    }\n-}\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -68,4 +45,2 @@\n-    static final int TCNT1 = 10;\n-    static final int TCNT2 = 4;\n-    static final int TCNT3 = 4;\n-    static final int THREAD_CNT = TCNT1 + TCNT2 + TCNT3;\n+    static final int PARKED_THREAD_COUNT = 4;\n+    static final int SPINNING_THREAD_COUNT = 4;\n@@ -80,14 +55,4 @@\n-    private static boolean failed;\n-    private static List<Thread> test1Threads = new ArrayList(TCNT1);\n-\n-    private static CountDownLatch ready0 = new CountDownLatch(THREAD_CNT);\n-    private static CountDownLatch ready1 = new CountDownLatch(TCNT1);\n-    private static CountDownLatch ready2 = new CountDownLatch(THREAD_CNT);\n-    private static CountDownLatch mready = new CountDownLatch(1);\n-\n-    private static void await(CountDownLatch dumpedLatch) {\n-        try {\n-            dumpedLatch.await();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+\n+    \/\/ called by agent when it is initialized and has enabled events\n+    static void agentStarted() {\n+        attached = true;\n@@ -96,4 +61,4 @@\n-    \/\/ The test1 vthreads are kept unmounted until interrupted after agent attach.\n-    static final Runnable test1 = () -> {\n-        synchronized (test1Threads) {\n-            test1Threads.add(Thread.currentThread());\n+    public static void main(String[] args) throws Exception {\n+        if (Thread.currentThread().isVirtual()) {\n+            System.out.println(\"Skipping test as current thread is a virtual thread\");\n+            return;\n@@ -101,8 +66,17 @@\n-        log(\"test1 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n-        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await(mready)\n-        try {\n-            Thread.sleep(20000); \/\/ big timeout to keep unmounted until interrupted\n-        } catch (InterruptedException ex) {\n-            \/\/ it is expected, ignore\n+        VThreadRunner.ensureParallelism(SPINNING_THREAD_COUNT+1);\n+\n+        \/\/ start threads that park (unmount)\n+        var threads1 = new ArrayList<Thread>();\n+        for (int i = 0; i < PARKED_THREAD_COUNT; i++) {\n+            var started = new AtomicBoolean();\n+            var thread = Thread.startVirtualThread(() -> {\n+                started.set(true);\n+                LockSupport.park();\n+            });\n+\n+            \/\/ wait for thread to start execution + park\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n+            await(thread, Thread.State.WAITING);\n+            threads1.add(thread);\n@@ -110,10 +84,17 @@\n-        ready2.countDown();\n-    };\n-\n-    \/\/ The test2 vthreads are kept mounted until agent attach.\n-    static final Runnable test2 = () -> {\n-        log(\"test2 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n-        while (!attached) {\n-            \/\/ keep mounted\n+\n+        \/\/ start threads that spin (stay mounted)\n+        var threads2 = new ArrayList<Thread>();\n+        for (int i = 0; i < SPINNING_THREAD_COUNT; i++) {\n+            var started = new AtomicBoolean();\n+            var thread = Thread.startVirtualThread(() -> {\n+                started.set(true);\n+                while (!attached) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+\n+            \/\/ wait for thread to start execution\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n+            threads2.add(thread);\n@@ -121,8 +102,6 @@\n-        ready2.countDown();\n-    };\n-\n-    \/\/ The test3 vthreads are kept mounted until agent attach.\n-    static final Runnable test3 = () -> {\n-        log(\"test3 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n+\n+        \/\/ attach to the current VM\n+        VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+        vm.loadAgentLibrary(\"VThreadEventTest\");\n+\n+        \/\/ wait for agent to start\n@@ -130,1 +109,1 @@\n-            \/\/ keep mounted\n+            Thread.sleep(10);\n@@ -132,3 +111,0 @@\n-        LockSupport.parkNanos(10_000_000L); \/\/ will cause extra mount and unmount\n-        ready2.countDown();\n-    };\n@@ -136,3 +112,3 @@\n-    public static void main(String[] args) throws Exception {\n-        if (Runtime.getRuntime().availableProcessors() < 8) {\n-            log(\"WARNING: test expects at least 8 processors.\");\n+        \/\/ unpark the threads that were parked\n+        for (Thread thread : threads1) {\n+            LockSupport.unpark(thread);\n@@ -140,27 +116,0 @@\n-        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n-            for (int i = 0; i < TCNT1; i++) {\n-                executorService.execute(test1);\n-            }\n-            for (int i = 0; i < TCNT2; i++) {\n-                executorService.execute(test2);\n-            }\n-            for (int i = 0; i < TCNT3; i++) {\n-                executorService.execute(test3);\n-            }\n-            await(ready0);\n-            mready.countDown();\n-            await(ready1); \/\/ to guarantee state is not State.TIMED_WAITING after await(mready) in test1()\n-            \/\/ wait for test1 threads to reach TIMED_WAITING state in sleep()\n-            for (Thread t : test1Threads) {\n-                Thread.State state = t.getState();\n-                log(\"DBG: state: \" + state);\n-                while (state != Thread.State.TIMED_WAITING) {\n-                    Thread.sleep(10);\n-                    state = t.getState();\n-                    log(\"DBG: state: \" + state);\n-                }\n-            }\n-\n-            VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n-            vm.loadAgentLibrary(\"VThreadEventTest\");\n-            Thread.sleep(200); \/\/ to allow the agent to get ready\n@@ -168,5 +117,3 @@\n-            attached = true;\n-            for (Thread t : test1Threads) {\n-                 t.interrupt();\n-            }\n-            ready2.await();\n+        \/\/ wait for all threads to terminate\n+        for (Thread thread : threads1) {\n+            thread.join();\n@@ -174,6 +121,2 @@\n-        \/\/ wait until all VirtualThreadEnd events have been sent\n-        for (int sleepNo = 1; threadEndCount() < THREAD_CNT; sleepNo++) {\n-            Thread.sleep(100);\n-            if (sleepNo % 100 == 0) { \/\/ 10 sec period of waiting\n-                log(\"main: waited seconds: \" + sleepNo\/10);\n-            }\n+        for (Thread thread : threads2) {\n+            thread.join();\n@@ -181,0 +124,1 @@\n+\n@@ -184,3 +128,0 @@\n-        int threadEndExp = THREAD_CNT;\n-        int threadMountExp = THREAD_CNT - TCNT2;\n-        int threadUnmountExp = THREAD_CNT + TCNT3;\n@@ -188,3 +129,4 @@\n-        log(\"ThreadEnd cnt: \"     + threadEndCnt     + \" (expected: \" + threadEndExp + \")\");\n-        log(\"ThreadMount cnt: \"   + threadMountCnt   + \" (expected: \" + threadMountExp + \")\");\n-        log(\"ThreadUnmount cnt: \" + threadUnmountCnt + \" (expected: \" + threadUnmountExp + \")\");\n+        int threadCount = PARKED_THREAD_COUNT + SPINNING_THREAD_COUNT;\n+        log(\"VirtualThreadEnd events: \" + threadEndCnt + \", expected: \" + threadCount);\n+        log(\"VirtualThreadMount events: \" + threadMountCnt + \", expected: \" + PARKED_THREAD_COUNT);\n+        log(\"VirtualThreadUnmount events: \" + threadUnmountCnt + \", expected: \" + threadCount);\n@@ -192,2 +134,3 @@\n-        if (threadEndCnt != threadEndExp) {\n-            log(\"FAILED: unexpected count of ThreadEnd events\");\n+        boolean failed = false;\n+        if (threadEndCnt != threadCount) {\n+            log(\"FAILED: unexpected count of VirtualThreadEnd events\");\n@@ -196,2 +139,2 @@\n-        if (threadMountCnt != threadMountExp) {\n-            log(\"FAILED: unexpected count of ThreadMount events\");\n+        if (threadMountCnt != PARKED_THREAD_COUNT) {\n+            log(\"FAILED: unexpected count of VirtualThreadMount events\");\n@@ -200,2 +143,2 @@\n-        if (threadUnmountCnt != threadUnmountExp) {\n-            log(\"FAILED: unexpected count of ThreadUnmount events\");\n+        if (threadUnmountCnt != threadCount) {\n+            log(\"FAILED: unexpected count of VirtualThreadUnmount events\");\n@@ -209,0 +152,9 @@\n+    private static void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assert state != Thread.State.TERMINATED : \"Thread has terminated\";\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":85,"deletions":133,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+  JNIEnv *env;\n+  jsize nVMs;\n+  jint res;\n+  jclass clazz;\n+  jmethodID mid;\n@@ -100,0 +105,35 @@\n+\n+  \/\/ call VThreadEventTest.agentStarted to notify test that agent has started\n+\n+  res = JNI_GetCreatedJavaVMs(&vm, 1, &nVMs);\n+  if (res != JNI_OK) {\n+      LOG(\"JNI_GetCreatedJavaVMs failed: %d\\n\", res);\n+      return JNI_ERR;\n+  }\n+\n+  res = vm->GetEnv((void **) &env, JNI_VERSION_21);\n+  if (res != JNI_OK) {\n+    LOG(\"GetEnv failed: %d\\n\", res);\n+    return JNI_ERR;\n+  }\n+\n+  clazz = env->FindClass(\"VThreadEventTest\");\n+  if (clazz == NULL) {\n+      LOG(\"FindClass failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  mid = env->GetStaticMethodID(clazz, \"agentStarted\", \"()V\");\n+  if (mid == NULL) {\n+      LOG(\"GetStaticMethodID failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  env->CallStaticVoidMethod(clazz, mid);\n+  if (env->ExceptionOccurred()) {\n+      LOG(\"CallStaticVoidMethod failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  LOG(\"Agent_OnAttach done\\n\");\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/libVThreadEventTest.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,4 @@\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment Running this test with -Xcomp is slow and therefore tends to cause\n+ *          timeouts. As there is no known direct benefit from running the test\n+ *          with -Xcomp, we disable such testing.\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                \"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\"));\n+                \"^\\\\s+- waiting on (<0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)|<no object reference available>)$\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestClhsdbJstackLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            out.shouldMatch(\"^\\\\s+- waiting on <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)$\");\n+            out.shouldMatch(\"^\\\\s+- waiting on (<0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)|<no object reference available>)$\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    static Debugee             debuggee      = null;\n@@ -140,2 +141,0 @@\n-        Debugee debuggee;\n-\n@@ -339,1 +338,0 @@\n-\n@@ -344,0 +342,10 @@\n+\n+                \/\/ don't do vm.suspend() until mainThread is waiting\n+                line = pipe.readln();\n+                if (line.equals(\"waiting\")) {\n+                    log2(\"     : returned string is 'waiting'\");\n+                } else {\n+                    log3(\"ERROR: returned string is not 'waiting': \" + line);\n+                    expresult = returnCode4;\n+                    break label1;\n+                }\n@@ -346,0 +354,1 @@\n+\n@@ -364,2 +373,1 @@\n-\n-                log2(\"      resuming the thread2\");\n+                log2(\"       resuming the thread2\");\n@@ -368,0 +376,7 @@\n+                log2(\"       undo the vm.suspend() with vm.resume()\");\n+                vm.resume();\n+            }\n+            \/\/ These are only needed if we break out of the loop due to an error\n+            if (expresult != returnCode0) {\n+                vm.resume();\n+                vm.resume();  \/\/ for case error when both VirtualMachine and the thread2 were suspended\n@@ -369,2 +384,0 @@\n-            vm.resume();\n-            vm.resume();  \/\/ for case error when both VirtualMachine and the thread2 were suspended\n@@ -490,1 +503,2 @@\n-                        log3(\"ERROR:  timeout for waiting for a BreakpintEvent\");\n+                        log3(\"ERROR:  timeout for waiting for a BreakpointEvent\");\n+                        debuggee.printThreadsInfo(vm);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/resume\/resume001.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,7 @@\n-            log1(\"waiting for an instruction from the debugger ...\");\n+            log1(\"waiting for an instruction from the debugger: iteration \" + i);\n+            if (i == 1) {\n+                \/\/ Let the debugger know we finished the first iteration and are now\n+                \/\/ waiting for next command. This is needed so we don't suspend the\n+                \/\/ main thread while it is doing a log(), which can hold a needed lock.\n+                pipe.println(\"waiting\");\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/resume\/resume001a.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,0 +143,4 @@\n+            \/\/ Disable collection on testedObject. invokeMethod() will essentially do a\n+            \/\/ vm.resume(), which gives GC a chance to run, which might result in this\n+            \/\/ object being collected.\n+            testedObject.disableCollection();\n@@ -181,0 +185,1 @@\n+        testedObject.enableCollection();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VoidValue\/toString\/tostring001.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -42,0 +43,1 @@\n+    private static final int MAX_TRIES = 6; \/\/ limit attempts to receive Notification data\n@@ -65,2 +67,2 @@\n-        \/\/ 2. Check CompositeData that doest not represnt\n-        \/\/ MemoryNotificationInfo - IllegalArgumentException must be thrown\n+        \/\/ 2. Check CompositeData that does not represent MemoryNotificationInfo\n+        \/\/ throws IllegalArgumentException\n@@ -88,1 +90,1 @@\n-            \/\/ Expected: CompositeData doest not represnt MemoryNotificationInfo\n+            \/\/ Expected: CompositeData does not represent MemoryNotificationInfo\n@@ -91,1 +93,1 @@\n-        log.display(\"check for CompositeData doest not represnt MemoryNotificationInfo passed.\");\n+        log.display(\"check that CompositeData does not represent MemoryNotificationInfo passed.\");\n@@ -93,1 +95,2 @@\n-        \/\/ 3. Check correct CompositeData\n+        \/\/ 3. Check correct CompositeData usage:\n+        \/\/ First try to provoke a Notification on a MemoryPool.\n@@ -126,1 +129,5 @@\n-        \/\/ eat memory just to emmit notification\n+        if (poolObject == null) {\n+            throw new TestFailure(\"No memory pool found to test.\");\n+        }\n+\n+        \/\/ eat memory just to emit notification\n@@ -136,4 +143,11 @@\n-        GarbageUtils.eatMemory(stresser);\n-\n-        boolean messageNotRecieved = true;\n-        while(messageNotRecieved) {\n+        int oomCount = GarbageUtils.eatMemory(stresser);\n+        log.display(\"eatMemory returns OOM count: \" + oomCount);\n+\n+        \/\/ Check for the message.  Poll on queue to avoid waiting forver on failure.\n+        \/\/ Notification is known to fail, very rarely, with -Xcomp where the allocations\n+        \/\/ do not affect the monitored pool. Possibly a timing issue, where the \"eatMemory\"\n+        \/\/ is done before Notification\/threshold processing happens.\n+        \/\/ The Notification is quite immediate, other than that problem.\n+        boolean messageReceived = false;\n+        int tries = 0;\n+        while (!messageReceived && ++tries < MAX_TRIES) {\n@@ -141,2 +155,8 @@\n-                from001Listener.queue.take();\n-                messageNotRecieved = false;\n+                Object r = from001Listener.queue.poll(10000, TimeUnit.MILLISECONDS);\n+                if (r == null) {\n+                    log.display(\"poll for Notification data returns null...\");\n+                    continue;\n+                } else {\n+                    messageReceived = true;\n+                    break;\n+                }\n@@ -144,1 +164,1 @@\n-                messageNotRecieved = true;\n+                \/\/ ignored, continue\n@@ -148,0 +168,4 @@\n+        \/\/ If we got a Notification, test that the CompositeData can create a MemoryNotificationInfo\n+        if (!messageReceived) {\n+            throw new TestFailure(\"No Notification received.\");\n+        }\n@@ -150,14 +174,14 @@\n-           ObjectName poolObjectName = new ObjectName(monitor.getName(poolObject));\n-           ObjectName resultObjectName = new ObjectName(\n-                     ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE +\n-                     \",name=\" + result.getPoolName());\n-\n-           log.display(\"poolObjectName : \" + poolObjectName +\n-                              \" resultObjectName : \" + resultObjectName);\n-\n-           if (!poolObjectName.equals(resultObjectName)) {\n-              log.complain(\"FAILURE 3.\");\n-              log.complain(\"Wrong pool name : \" + resultObjectName +\n-                           \", expected : \" + poolObjectName);\n-              testFailed = true;\n-           }\n+            ObjectName poolObjectName = new ObjectName(monitor.getName(poolObject));\n+            ObjectName resultObjectName = new ObjectName(\n+                        ManagementFactory.MEMORY_POOL_MXBEAN_DOMAIN_TYPE +\n+                        \",name=\" + result.getPoolName());\n+\n+            log.display(\"poolObjectName : \" + poolObjectName +\n+                        \" resultObjectName : \" + resultObjectName);\n+\n+            if (!poolObjectName.equals(resultObjectName)) {\n+                log.complain(\"FAILURE 3.\");\n+                log.complain(\"Wrong pool name : \" + resultObjectName +\n+                             \", expected : \" + poolObjectName);\n+                testFailed = true;\n+            }\n@@ -170,1 +194,0 @@\n-\n@@ -186,1 +209,2 @@\n-        if (data.get() != null)\n+        if (data.get() != null) {\n+            System.out.println(\"handleNotification: ignoring\");\n@@ -188,1 +212,4 @@\n-        data.set((CompositeData) notification.getUserData());\n+        }\n+        System.out.println(\"handleNotification: getting data\");\n+        CompositeData d = (CompositeData) notification.getUserData();\n+        data.set(d);\n@@ -196,1 +223,1 @@\n-                messageNotSent = true;\n+                \/\/ ignore, retry\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/MemoryNotificationInfo\/from\/from001.java","additions":59,"deletions":32,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- *     2. trows IllegalArgumentException, if CompositeData doest not represnt\n+ *     2. throws IllegalArgumentException, if CompositeData does not represent\n@@ -39,1 +39,1 @@\n- *     3. correct MemoryNotificationInfo object, if CompositeData is correst (i.e\n+ *     3. correct MemoryNotificationInfo object, if CompositeData is correct, i.e\n@@ -46,0 +46,5 @@\n+ * Avoid running with -Xcomp due to rare failure where the MemoryPool does not\n+ * increase in usage and send Notification.  Likely the timing changes so \"eatMemory\"\n+ * completes before Notification\/threshold processing.\n+ *\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/MemoryNotificationInfo\/from\/from001\/TestDescription.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -598,1 +598,1 @@\n-    protected void printThreadsInfo(VirtualMachine vm)  {\n+    public void printThreadsInfo(VirtualMachine vm) {\n@@ -600,1 +600,1 @@\n-            log.display(\"------------ Try to print debuggee threads before killing process ------------\");\n+            log.display(\"------------ Print debuggee threads ------------\");\n@@ -634,1 +634,1 @@\n-            log.display(\"----------------------------------------------------------------------\");\n+            log.display(\"------------------------------------------------\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Debugee.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -534,2 +534,0 @@\n-javax\/management\/remote\/mandatory\/connection\/RMIConnector_NPETest.java 8267887 generic-all\n-\n@@ -614,1 +612,0 @@\n-com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java         8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -632,1 +632,0 @@\n-    com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322133\n+ * @summary Make sure getParameterSpec returns std name for EC AlgorithmParameters\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+\n+public class CurveGetParameterSpec {\n+    public static void main(String[] args) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(new ECGenParameterSpec(\"secp384r1\"));\n+        var k = kpg.generateKeyPair().getPublic();\n+        var a = AlgorithmParameters.getInstance(\"EC\");\n+        a.init(k.getParams());\n+        String name = a.getParameterSpec(ECGenParameterSpec.class).getName();\n+        if (!name.equals(\"secp384r1\")) {\n+            throw new Exception(\"EC getParameterSpec does not return std name secp384r1. Instead returns: \" + name);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/AlgorithmParameters\/EC\/CurveGetParameterSpec.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/manual PerformanceTest\n@@ -31,1 +30,0 @@\n-import java.security.*;\n@@ -33,1 +31,0 @@\n-import java.io.*;\n@@ -181,1 +178,1 @@\n-        start = System.currentTimeMillis();\n+        start = getTimeInMicroseconds();\n@@ -186,1 +183,1 @@\n-        end = System.currentTimeMillis();\n+        end = getTimeInMicroseconds();\n@@ -188,1 +185,3 @@\n-        int speed = (int)((data.length * count)\/(end - start));\n+        \/\/ To avoid dividing by zero in the rare case where end is equal to start\n+        long executionTime = end != start ? end - start : 1L;\n+        int speed = (int) ((data.length * count) \/ executionTime);\n@@ -201,1 +200,1 @@\n-            (\"Algorithm                      DataSize Rounds Kbytes\/sec\");\n+            (\"Algorithm                      DataSize Rounds Bytes\/microsec\");\n@@ -205,0 +204,4 @@\n+    private static long getTimeInMicroseconds() {\n+        return System.nanoTime() \/ 1000;\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,2 +104,4 @@\n-                \/\/ Give other thread a chance to interrupt\n-                Thread.sleep(100);\n+                \/\/ Give other thread a chance to interrupt. Normally only a very short\n+                \/\/ sleep is needed, but we need to account for unexpected delays in\n+                \/\/ the interrupt due to machine and network hiccups.\n+                Thread.sleep(10*1000);\n","filename":"test\/jdk\/com\/sun\/jdi\/InterruptHangTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @key randomness\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run testng\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -XX:CompileCommand=dontinline,TestConcurrentClose$SegmentAccessor::doAccess\n+ *   -Xbatch\n+ *   TestConcurrentClose\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestConcurrentClose {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final Method DO_ACCESS_METHOD;\n+    static final int C2_COMPILED_LEVEL = 4;\n+\n+    static {\n+        try {\n+            DO_ACCESS_METHOD = SegmentAccessor.class.getDeclaredMethod(\"doAccess\");\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final int ITERATIONS = 5;\n+    static final int SEGMENT_SIZE = 10_000;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 60;\n+    static final int NUM_ACCESSORS = 50;\n+\n+    static final AtomicLong start = new AtomicLong();\n+    static final AtomicBoolean started = new AtomicBoolean();\n+\n+    @Test\n+    public void testHandshake() throws InterruptedException {\n+        for (int it = 0; it < ITERATIONS; it++) {\n+            System.out.println(\"ITERATION \" + it + \" - starting\");\n+            ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+            start.set(System.currentTimeMillis());\n+            started.set(false);\n+            CountDownLatch startClosureLatch = new CountDownLatch(1);\n+\n+            for (int i = 0; i < NUM_ACCESSORS ; i++) {\n+                Arena arena = Arena.ofShared();\n+                MemorySegment segment = arena.allocate(SEGMENT_SIZE, 1);\n+                accessExecutor.execute(new SegmentAccessor(i, segment));\n+                accessExecutor.execute(new Closer(i, startClosureLatch, arena));\n+            }\n+\n+            awaitCompilation();\n+\n+            long closeDelay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Starting closers after delay of \" + closeDelay + \" millis\");\n+            startClosureLatch.countDown();\n+            accessExecutor.shutdown();\n+            assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+            long finishDelay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"ITERATION \" + it + \" - finished, after \" + finishDelay + \"milis\");\n+        }\n+    }\n+\n+    static class SegmentAccessor implements Runnable {\n+        final MemorySegment segment;\n+        final int id;\n+        boolean hasFailed = false;\n+\n+        SegmentAccessor(int id, MemorySegment segment) {\n+            this.id = id;\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public final void run() {\n+            start(\"Accessor #\" + id);\n+            while (segment.scope().isAlive()) {\n+                try {\n+                    doAccess();\n+                } catch (IllegalStateException ex) {\n+                    \/\/ scope was closed, loop should exit\n+                    assertFalse(hasFailed);\n+                    hasFailed = true;\n+                }\n+            }\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Accessor #\" + id + \" terminated - elapsed (ms): \" + delay);\n+        }\n+\n+        \/\/ keep this out of line, so it has a chance to be fully C2 compiled\n+        private int doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                sum += segment.get(JAVA_BYTE, i);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    static class Closer implements Runnable {\n+        final int id;\n+        final Arena arena;\n+        final CountDownLatch startLatch;\n+\n+        Closer(int id, CountDownLatch startLatch, Arena arena) {\n+            this.id = id;\n+            this.arena = arena;\n+            this.startLatch = startLatch;\n+        }\n+\n+        @Override\n+        public void run() {\n+            start(\"Closer #\" + id);\n+            try {\n+                \/\/ try to close all at the same time, to simulate concurrent\n+                \/\/ closures of unrelated arenas\n+                startLatch.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Unexpected interruption\", e);\n+            }\n+            arena.close(); \/\/ This should NOT throw\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Closer #\" + id + \"terminated - elapsed (ms): \" + delay);\n+        }\n+    }\n+\n+    static void start(String name) {\n+        if (started.compareAndSet(false, true)) {\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Started first thread: \" + name + \" ; elapsed (ms): \" + delay);\n+        }\n+    }\n+\n+    private static void awaitCompilation() throws InterruptedException {\n+        while (WB.getMethodCompilationLevel(DO_ACCESS_METHOD, false) != C2_COMPILED_LEVEL) {\n+            Thread.sleep(1000);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestConcurrentClose.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -103,1 +103,1 @@\n-            start(\"\\\"Accessor #\\\" + id\");\n+            start(\"Accessor #\" + id);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334394\n+ * @summary ensure there is no race condition in Class::protectionDomain\n+ * @run main\/othervm ProtectionDomainRace\n+ *\/\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+\n+\/**\n+ * Without the code fix, this test would fail with\n+ * java.lang.AssertionError: sun.security.util.ResourcesMgr (PD)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller.checkInjectedInvoker(MethodHandleImpl.java:1209)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller.makeInjectedInvoker(MethodHandleImpl.java:1110)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller$1.computeValue(MethodHandleImpl.java:1117)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller$1.computeValue(MethodHandleImpl.java:1114)\n+ *         at java.base\/java.lang.ClassValue.getFromHashMap(ClassValue.java:229)\n+ *         at java.base\/java.lang.ClassValue.getFromBackup(ClassValue.java:211)\n+ *         at java.base\/java.lang.ClassValue.get(ClassValue.java:117)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller.bindCallerWithInjectedInvoker(MethodHandleImpl.java:1089)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl$BindCaller.bindCaller(MethodHandleImpl.java:1077)\n+ *         at java.base\/java.lang.invoke.MethodHandleImpl.bindCaller(MethodHandleImpl.java:1032)\n+ *         at java.base\/java.lang.invoke.MethodHandles$Lookup.maybeBindCaller(MethodHandles.java:4149)\n+ *         at java.base\/java.lang.invoke.MethodHandles$Lookup.getDirectMethodCommon(MethodHandles.java:4133)\n+ *         at java.base\/java.lang.invoke.MethodHandles$Lookup.getDirectMethodNoSecurityManager(MethodHandles.java:4077)\n+ *         at java.base\/java.lang.invoke.MethodHandles$Lookup.getDirectMethodForConstant(MethodHandles.java:4326)\n+ *         at java.base\/java.lang.invoke.MethodHandles$Lookup.linkMethodHandleConstant(MethodHandles.java:4274)\n+ *         at java.base\/java.lang.invoke.MethodHandleNatives.linkMethodHandleConstant(MethodHandleNatives.java:628)\n+ *         at java.base\/sun.security.util.ResourcesMgr.getBundle(ResourcesMgr.java:54)\n+ *         at java.base\/sun.security.util.ResourcesMgr.getString(ResourcesMgr.java:40)\n+ *         at java.base\/javax.security.auth.Subject.doAs(Subject.java:517)\n+ *         ...\n+ * as the Class::protectionDomain might assign different objects to the (original) allPermDomain field.\n+ *\/\n+public class ProtectionDomainRace {\n+    private static volatile Throwable failed = null;\n+    public static void main(String[] args) throws Throwable {\n+        PrivilegedAction<?> pa = () -> null;\n+        Thread[] threads = new Thread[100];\n+        for (int i = 0; i < 100; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    Subject.doAs(null, pa);\n+                } catch (Throwable t) {\n+                    failed = t;\n+                }\n+            });\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            threads[i].join();\n+        }\n+        if (failed != null) {\n+            throw failed;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/ProtectionDomainRace.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336479\n+ * @summary Tests for Process.waitFor(Duration)\n+ * @library \/test\/lib\n+ * @run junit WaitForDuration\n+ *\/\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class WaitForDuration {\n+    static Stream<Arguments> durations() {\n+        return Stream.of(\n+            Arguments.of(Duration.ZERO, 3_600_000, false),\n+            Arguments.of(Duration.ofSeconds(-100), 3_600_000, false),\n+            Arguments.of(Duration.ofSeconds(100), 0, true),\n+            Arguments.of(Duration.ofSeconds(Long.MAX_VALUE), 0, true), \/\/ nano overflow\n+            Arguments.of(Duration.ofSeconds(Long.MIN_VALUE), 3_600_000, false) \/\/ nano underflow\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"durations\")\n+    void testEdgeDurations(Duration d, int sleepMillis, boolean expected)\n+            throws IOException, InterruptedException {\n+        var child = ProcessTools.createTestJavaProcessBuilder(\n+            WaitForDuration.class.getSimpleName(), Integer.toString(sleepMillis))\n+                .start();\n+        try {\n+            assertEquals(expected, child.waitFor(d));\n+        } finally {\n+            child.destroy();\n+        }\n+    }\n+\n+    @Test\n+    void testNullDuration() throws IOException, InterruptedException {\n+        var pb = ProcessTools.createTestJavaProcessBuilder(\n+            WaitForDuration.class.getSimpleName(), \"0\");\n+        assertThrows(NullPointerException.class, () -> pb.start().waitFor(null));\n+    }\n+\n+    public static void main(String... args) throws InterruptedException {\n+        Thread.sleep(Integer.parseInt(args[0]));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/WaitForDuration.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @bug 8284161 8286788\n+ * @summary Test java.lang.management.ThreadInfo contains expected information for carrier threads\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_LIGHTWEIGHT\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=2 CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_LEGACY\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=1 CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_MONITOR\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=0 CarrierThreadInfo\n+ *\/\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class CarrierThreadInfo {\n+\n+    \/**\n+     * Test that ThreadInfo.getLockedMonitors returns information about a lock held by\n+     * a carrier thread.\n+     *\/\n+    @Test\n+    void testCarrierThreadHoldsLock() throws Exception {\n+        Object lock = new Object();\n+        ThreadFactory factory = task -> Thread.ofPlatform().unstarted(() -> {\n+            synchronized (lock) {\n+                task.run();\n+            }\n+        });\n+\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                \/\/ carrier threads holds the lock\n+                long carrierId = scheduler.carrier().threadId();\n+                ThreadInfo threadInfo = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                        .getThreadInfo(new long[] { carrierId }, true, true)[0];\n+                boolean holdsLock = Arrays.stream(threadInfo.getLockedMonitors())\n+                        .anyMatch(mi -> mi.getIdentityHashCode() == System.identityHashCode(lock));\n+                assertTrue(holdsLock, \"Carrier should hold lock\");\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadInfo.getLockedMonitors does not return information about a lock\n+     * held by mounted virtual thread.\n+     *\/\n+    @Test\n+    void testVirtualThreadHoldsLock() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var lock = new Object();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                \/\/ carrier threads does not hold lock\n+                long carrierId = scheduler.carrier().threadId();\n+                ThreadInfo threadInfo = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                        .getThreadInfo(new long[] { carrierId }, true, true)[0];\n+                boolean holdsLock = Arrays.stream(threadInfo.getLockedMonitors())\n+                        .anyMatch(mi -> mi.getIdentityHashCode() == System.identityHashCode(lock));\n+                assertFalse(holdsLock, \"Carrier should not hold lock\");\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadInfo.getLockOwnerId and getLockInfo return information about a\n+     * synthetic lock that make it appear that the carrier is blocking waiting on the\n+     * virtual thread.\n+     *\/\n+    @Test\n+    void testCarrierThreadWaits() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                long carrierId = scheduler.carrier().threadId();\n+                long vthreadId = vthread.threadId();\n+\n+                ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(carrierId);\n+                assertNotNull(threadInfo);\n+\n+                \/\/ carrier should be blocked waiting for lock owned by virtual thread\n+                assertEquals(vthreadId, threadInfo.getLockOwnerId());\n+\n+                \/\/ carrier thread should be on blocked waiting on virtual thread\n+                LockInfo lockInfo = threadInfo.getLockInfo();\n+                assertNotNull(lockInfo);\n+                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n+                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Custom scheduler with a single carrier thread.\n+     *\/\n+    private static class CustomScheduler implements AutoCloseable {\n+        private final ExecutorService pool;\n+        private final Executor scheduler;\n+        private final AtomicReference<Thread> carrierRef = new AtomicReference<>();\n+\n+        CustomScheduler(ThreadFactory factory) {\n+            pool = Executors.newSingleThreadExecutor(factory);\n+            scheduler = task -> {\n+                pool.submit(() -> {\n+                    carrierRef.set(Thread.currentThread());\n+                    try {\n+                        task.run();\n+                    } finally {\n+                        carrierRef.set(null);\n+                    }\n+                });\n+            };\n+        }\n+\n+        \/**\n+         * Returns the carrier thread if a virtual thread is mounted.\n+         *\/\n+        Thread carrier() throws InterruptedException {\n+            return carrierRef.get();\n+        }\n+\n+        \/**\n+         * Starts a virtual thread to execute the give task.\n+         *\/\n+        Thread forkVirtualThread(Runnable task) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread thread = factory.newThread(task);\n+            thread.start();\n+            return thread;\n+        }\n+\n+        @Override\n+        public void close() {\n+            pool.close();\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadInfo.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8284161 8286788\n- * @summary Test that a carrier thread waits on a virtual thread\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @run junit CarrierThreadWaits\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.continuations & vm.debug\n- * @modules java.base\/java.lang:+open\n- * @run junit\/othervm -XX:LockingMode=0 CarrierThreadWaits\n- *\/\n-\n-import java.lang.management.LockInfo;\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.ThreadInfo;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class CarrierThreadWaits {\n-\n-    @Test\n-    void testCarrierThreadWaiting() throws Exception {\n-        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n-            var carrierRef = new AtomicReference<Thread>();\n-            var vthreadRef = new AtomicReference<Thread>();\n-\n-            Executor scheduler = task -> {\n-                pool.submit(() -> {\n-                    Thread carrier = Thread.currentThread();\n-                    carrierRef.set(carrier);\n-                    Thread vthread = vthreadRef.get();\n-\n-                    System.err.format(\"%s run task (%s) ...%n\", carrier, vthread);\n-                    task.run();\n-                    System.err.format(\"%s task done (%s)%n\", carrier, vthread);\n-                });\n-            };\n-\n-            \/\/ start a virtual thread that spins and remains mounted until \"done\"\n-            var started = new AtomicBoolean();\n-            var done = new AtomicBoolean();\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.unstarted(() -> {\n-                started.set(true);\n-                while (!done.get()) {\n-                    Thread.onSpinWait();\n-                }\n-            });\n-            vthreadRef.set(vthread);\n-            vthread.start();\n-\n-            try {\n-                \/\/ wait for virtual thread to start\n-                while (!started.get()) {\n-                    Thread.sleep(10);\n-                }\n-\n-                Thread carrier = carrierRef.get();\n-\n-                long carrierId = carrier.threadId();\n-                long vthreadId = vthread.threadId();\n-\n-                \/\/ carrier thread should be on WAITING on virtual thread\n-                ThreadInfo ti = ManagementFactory.getThreadMXBean().getThreadInfo(carrierId);\n-                Thread.State state = ti.getThreadState();\n-                LockInfo lockInfo = ti.getLockInfo();\n-                assertEquals(Thread.State.WAITING, state);\n-                assertNotNull(lockInfo);\n-                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n-                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n-                assertEquals(vthreadId, ti.getLockOwnerId());\n-            } finally {\n-                done.set(true);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadWaits.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -68,4 +72,7 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n-            ref.set(scheduler(Thread.currentThread()));\n-        }).join();\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        Thread thread = factory.newThread(() -> {\n+            ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n+        });\n+        thread.start();\n+        thread.join();\n@@ -80,11 +87,1 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        Thread.ofVirtual().start(() -> {\n-            try {\n-                ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n-                    ref.set(scheduler(Thread.currentThread()));\n-                }).join();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }).join();\n-        assertTrue(ref.get() == scheduler1);\n+        VThreadRunner.run(this::testCustomScheduler1);\n@@ -99,2 +96,3 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        Thread thread = factory.newThread(() -> {\n@@ -103,1 +101,1 @@\n-                    ref.set(scheduler(Thread.currentThread()));\n+                    ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n@@ -108,1 +106,3 @@\n-        }).join();\n+        });\n+        thread.start();\n+        thread.join();\n@@ -118,2 +118,4 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory1 = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        ThreadFactory factory2 = VThreadScheduler.virtualThreadFactory(scheduler2);\n+        Thread thread1 = factory1.newThread(() -> {\n@@ -121,3 +123,5 @@\n-                ThreadBuilders.virtualThreadBuilder(scheduler2).start(() -> {\n-                    ref.set(scheduler(Thread.currentThread()));\n-                }).join();\n+                Thread thread2 = factory2.newThread(() -> {\n+                    ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n+                });\n+                thread2.start();\n+                thread2.join();\n@@ -127,1 +131,3 @@\n-        }).join();\n+        });\n+        thread1.start();\n+        thread1.join();\n@@ -152,2 +158,3 @@\n-\n-        ThreadBuilders.virtualThreadBuilder(scheduler).start(LockSupport::park);\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(LockSupport::park);\n+        thread.start();\n@@ -165,2 +172,2 @@\n-            var builder = ThreadBuilders.virtualThreadBuilder(Runnable::run);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(Runnable::run);\n+            Thread vthread = factory.newThread(() -> {\n@@ -170,0 +177,1 @@\n+            vthread.start();\n@@ -186,2 +194,2 @@\n-            var builder = ThreadBuilders.virtualThreadBuilder(Runnable::run);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(Runnable::run);\n+            Thread vthread = factory.newThread(() -> {\n@@ -190,0 +198,1 @@\n+            vthread.start();\n@@ -207,0 +216,1 @@\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -209,1 +219,1 @@\n-            Thread vthread = ThreadBuilders.virtualThreadBuilder(scheduler).start(() -> {\n+            Thread vthread = factory.newThread(() -> {\n@@ -212,0 +222,1 @@\n+            vthread.start();\n@@ -219,1 +230,1 @@\n-     * Returns the scheduler for the given virtual thread.\n+     * Test custom scheduler throwing OOME when starting a thread.\n@@ -221,10 +232,52 @@\n-    private static Executor scheduler(Thread thread) {\n-        if (!thread.isVirtual())\n-            throw new IllegalArgumentException(\"Not a virtual thread\");\n-        try {\n-            Field scheduler = Class.forName(\"java.lang.VirtualThread\")\n-                    .getDeclaredField(\"scheduler\");\n-            scheduler.setAccessible(true);\n-            return (Executor) scheduler.get(thread);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n+    @Test\n+    void testThreadStartOOME() throws Exception {\n+        Executor scheduler = task -> {\n+            System.err.println(\"OutOfMemoryError\");\n+            throw new OutOfMemoryError();\n+        };\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(() -> { });\n+        assertThrows(OutOfMemoryError.class, thread::start);\n+    }\n+\n+    \/**\n+     * Test custom scheduler throwing OOME when unparking a thread.\n+     *\/\n+    @Test\n+    void testThreadUnparkOOME() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(1)) {\n+            AtomicInteger counter = new AtomicInteger();\n+            Executor scheduler = task -> {\n+                switch (counter.getAndIncrement()) {\n+                    case 0 -> executor.execute(task);             \/\/ Thread.start\n+                    case 1, 2 -> {                                \/\/ unpark attempt 1+2\n+                        System.err.println(\"OutOfMemoryError\");\n+                        throw new OutOfMemoryError();\n+                    }\n+                    default -> executor.execute(task);\n+                }\n+                executor.execute(task);\n+            };\n+\n+            \/\/ start thread and wait for it to park\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            var thread = factory.newThread(LockSupport::park);\n+            thread.start();\n+            await(thread, Thread.State.WAITING);\n+\n+            \/\/ unpark thread, this should retry until OOME is not thrown\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":97,"deletions":44,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test Thread.getStackTrace to examine the stack trace of a virtual\n- *     thread and its carrier\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @run main GetStackTrace\n- *\/\n-\n-import java.util.Objects;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.LinkedTransferQueue;\n-import java.util.stream.Stream;\n-\n-public class GetStackTrace {\n-\n-    private static final Object LOCK = new Object();\n-\n-    public static void main(String[] args) throws Exception {\n-        try (var scheduler = new Scheduler()) {\n-            Thread vthread = scheduler.startVirtualThread(() -> {\n-                synchronized (LOCK) {\n-                    try {\n-                        LOCK.wait();\n-                    } catch (InterruptedException e) { }\n-                }\n-            });\n-\n-            try {\n-                \/\/ wait for virtual thread to wait\n-                while (vthread.getState() != Thread.State.WAITING) {\n-                    Thread.sleep(10);\n-                }\n-\n-                \/\/ bottom-most frame of virtual thread should be VirtualThread.run\n-                System.out.println(vthread);\n-                StackTraceElement[] vthreadStack = vthread.getStackTrace();\n-                Stream.of(vthreadStack).forEach(System.out::println);\n-                assertEquals(\"run\", vthreadStack[vthreadStack.length - 1].getMethodName());\n-\n-                System.out.println();\n-\n-                \/\/ top-most frame of carrier thread should be Continuation.run\n-                \/\/ bottom-most frame of carrier thread should be Thread.run\n-                var carrier = scheduler.thread();\n-                System.out.println(carrier);\n-                StackTraceElement[] carrierStack = carrier.getStackTrace();\n-                Stream.of(carrierStack).forEach(System.out::println);\n-                assertEquals(\"run\", carrierStack[0].getMethodName());\n-                assertEquals(\"run\", carrierStack[carrierStack.length - 1].getMethodName());\n-            } finally {\n-                vthread.interrupt();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A scheduler with one thread.\n-     *\/\n-    private static class Scheduler implements AutoCloseable, Executor {\n-        private final BlockingQueue<Runnable> tasks = new LinkedTransferQueue<>();\n-        private final Thread thread;\n-        private volatile boolean done;\n-\n-        Scheduler() {\n-            this.thread = Thread.ofPlatform().start(() -> {\n-                try {\n-                    while (!done) {\n-                        Runnable task = tasks.take();\n-                        task.run();\n-                    }\n-                } catch (InterruptedException e) { }\n-            });\n-        }\n-\n-        Thread thread() {\n-            return thread;\n-        }\n-\n-        @Override\n-        public void close() throws InterruptedException {\n-            done = true;\n-            thread.interrupt();\n-            thread.join();\n-        }\n-\n-        @Override\n-        public void execute(Runnable task) {\n-            tasks.add(task);\n-        }\n-\n-        Thread startVirtualThread(Runnable task) {\n-            return ThreadBuilders.virtualThreadBuilder(this).start(task);\n-        }\n-    }\n-\n-    private static void assertTrue(boolean e) {\n-        if (!e) throw new RuntimeException();\n-    }\n-\n-    private static void assertEquals(Object x, Object y) {\n-        if (!Objects.equals(x, y))\n-            throw new RuntimeException();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test Thread::getStackTrace on a virtual thread that is runnable-unmounted\n- * @requires vm.continuations\n- * @run main\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 GetStackTraceWhenRunnable\n- *\/\n-\n-import java.io.IOException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-\n-public class GetStackTraceWhenRunnable {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        \/\/ start thread1 and wait for it to park\n-        Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n-        while (thread1.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n-        }\n-\n-        \/\/ start thread2 to pin the carrier thread\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        Thread thread2 = Thread.startVirtualThread(() -> {\n-            started.set(true);\n-            while (!done.get()) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread2 to start\n-            while (!started.get()) {\n-                Thread.sleep(10);\n-            }\n-\n-            \/\/ unpark thread1 and check that it is \"stuck\" in the runnable state\n-            \/\/ (the carrier thread is pinned, no other virtual thread can run)\n-            LockSupport.unpark(thread1);\n-            for (int i = 0; i < 5; i++) {\n-                assertTrue(thread1.getState() == Thread.State.RUNNABLE);\n-                Thread.sleep(100);\n-            }\n-\n-            \/\/ print thread1's stack trace\n-            StackTraceElement[] stack = thread1.getStackTrace();\n-            assertTrue(stack.length > 0);\n-            for (StackTraceElement e : stack) {\n-                System.out.println(e);\n-            }\n-        } finally {\n-            done.set(true);\n-            thread2.join();\n-            thread1.join();\n-        }\n-    }\n-\n-    static void assertTrue(boolean e) {\n-        if (!e) throw new RuntimeException();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -45,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -55,1 +53,2 @@\n-import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -57,0 +56,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -58,2 +58,1 @@\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -64,0 +63,9 @@\n+    @BeforeAll\n+    static void setup() {\n+        int minParallelism = 2;\n+        if (Thread.currentThread().isVirtual()) {\n+            minParallelism++;\n+        }\n+        VThreadRunner.ensureParallelism(minParallelism);\n+    }\n+\n@@ -96,50 +104,1 @@\n-     * Arguments for testVirtualThreadPinned to test jdk.VirtualThreadPinned event.\n-     *   [0] label\/description\n-     *   [1] the operation to park\/wait\n-     *   [2] the Thread.State when parked\/waiting\n-     *   [3] the action to unpark\/notify the thread\n-     *\/\n-    static Stream<Arguments> pinnedCases() {\n-        Object lock = new Object();\n-\n-        \/\/ park with native frame on stack\n-        var finish1 = new AtomicBoolean();\n-        var parkWhenPinned = Arguments.of(\n-            \"LockSupport.park when pinned\",\n-            (ThrowingRunnable<Exception>) () -> {\n-                VThreadPinner.runPinned(() -> {\n-                    while (!finish1.get()) {\n-                        LockSupport.park();\n-                    }\n-                });\n-            },\n-            Thread.State.WAITING,\n-                (Consumer<Thread>) t -> {\n-                    finish1.set(true);\n-                    LockSupport.unpark(t);\n-                }\n-        );\n-\n-        \/\/ timed park with native frame on stack\n-        var finish2 = new AtomicBoolean();\n-        var timedParkWhenPinned = Arguments.of(\n-            \"LockSupport.parkNanos when pinned\",\n-            (ThrowingRunnable<Exception>) () -> {\n-                VThreadPinner.runPinned(() -> {\n-                    while (!finish2.get()) {\n-                        LockSupport.parkNanos(Long.MAX_VALUE);\n-                    }\n-                });\n-            },\n-            Thread.State.TIMED_WAITING,\n-            (Consumer<Thread>) t -> {\n-                finish2.set(true);\n-                LockSupport.unpark(t);\n-            }\n-        );\n-\n-        return Stream.of(parkWhenPinned, timedParkWhenPinned);\n-    }\n-\n-    \/**\n-     * Test jdk.VirtualThreadPinned event.\n+     * Test jdk.VirtualThreadPinned event when parking while pinned.\n@@ -148,6 +107,2 @@\n-    @MethodSource(\"pinnedCases\")\n-    void testVirtualThreadPinned(String label,\n-                                 ThrowingRunnable<Exception> parker,\n-                                 Thread.State expectedState,\n-                                 Consumer<Thread> unparker) throws Exception {\n-\n+    @ValueSource(booleans = { true, false })\n+    void testParkWhenPinned(boolean timed) throws Exception {\n@@ -156,1 +111,0 @@\n-\n@@ -158,7 +112,12 @@\n-            try {\n-                var exception = new AtomicReference<Throwable>();\n-                var thread = Thread.ofVirtual().start(() -> {\n-                    try {\n-                        parker.run();\n-                    } catch (Throwable e) {\n-                        exception.set(e);\n+\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            var vthread = Thread.startVirtualThread(() -> {\n+                VThreadPinner.runPinned(() -> {\n+                    started.set(true);\n+                    while (!done.get()) {\n+                        if (timed) {\n+                            LockSupport.parkNanos(Long.MAX_VALUE);\n+                        } else {\n+                            LockSupport.park();\n+                        }\n@@ -167,13 +126,6 @@\n-                try {\n-                    \/\/ wait for thread to park\/wait\n-                    Thread.State state = thread.getState();\n-                    while (state != expectedState) {\n-                        assertTrue(state != Thread.State.TERMINATED, thread.toString());\n-                        Thread.sleep(10);\n-                        state = thread.getState();\n-                    }\n-                } finally {\n-                    unparker.accept(thread);\n-                    thread.join();\n-                    assertNull(exception.get());\n-                }\n+            });\n+\n+            try {\n+                \/\/ wait for thread to start and park\n+                awaitTrue(started);\n+                await(vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n@@ -181,0 +133,3 @@\n+                done.set(true);\n+                LockSupport.unpark(vthread);\n+                vthread.join();\n@@ -184,6 +139,1 @@\n-            Map<String, Integer> events = sumEvents(recording);\n-            System.err.println(events);\n-\n-            \/\/ should have at least one pinned event\n-            int pinnedCount = events.getOrDefault(\"jdk.VirtualThreadPinned\", 0);\n-            assertTrue(pinnedCount >= 1, \"Expected one or more events\");\n+            assertContainsPinnedEvent(recording, vthread);\n@@ -206,1 +156,1 @@\n-                ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler).factory();\n+                ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -213,3 +163,1 @@\n-                while (thread.getState() != Thread.State.WAITING) {\n-                    Thread.sleep(10);\n-                }\n+                await(thread, Thread.State.WAITING);\n@@ -235,5 +183,3 @@\n-            Map<String, Integer> events = sumEvents(recording);\n-            System.err.println(events);\n-\n-            int count = events.getOrDefault(\"jdk.VirtualThreadSubmitFailed\", 0);\n-            assertEquals(2, count);\n+            List<RecordedEvent> submitFailedEvents = find(recording, \"jdk.VirtualThreadSubmitFailed\");\n+            System.err.println(submitFailedEvents);\n+            assertTrue(submitFailedEvents.size() == 2, \"Expected two events\");\n@@ -243,0 +189,11 @@\n+    \/**\n+     * Returns the list of events in the given recording with the given name.\n+     *\/\n+    private static List<RecordedEvent> find(Recording recording, String name) throws IOException {\n+        Path recordingFile = recordingFile(recording);\n+        return RecordingFile.readAllEvents(recordingFile)\n+                .stream()\n+                .filter(e -> e.getEventType().getName().equals(name))\n+                .toList();\n+    }\n+\n@@ -267,0 +224,34 @@\n+\n+    \/**\n+     * Assert that a recording contains a jdk.VirtualThreadPinned event on the given thread.\n+     *\/\n+    private void assertContainsPinnedEvent(Recording recording, Thread thread) throws IOException {\n+        List<RecordedEvent> pinnedEvents = find(recording, \"jdk.VirtualThreadPinned\");\n+        assertTrue(pinnedEvents.size() > 0, \"No jdk.VirtualThreadPinned events in recording\");\n+        System.err.println(pinnedEvents);\n+\n+        long tid = thread.threadId();\n+        assertTrue(pinnedEvents.stream()\n+                        .anyMatch(e -> e.getThread().getJavaThreadId() == tid),\n+                \"jdk.VirtualThreadPinned for javaThreadId = \" + tid + \" not found\");\n+    }\n+\n+    \/**\n+     * Waits for the given boolean to be set to true.\n+     *\/\n+    private void awaitTrue(AtomicBoolean b) throws InterruptedException {\n+        while (!b.get()) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private static void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":89,"deletions":98,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test virtual thread with monitor enter\/exit\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.condition.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+class MonitorEnterExit {\n+    static final int MAX_ENTER_DEPTH = 256;\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+    }\n+\n+    \/**\n+     * Test monitor enter with no contention.\n+     *\/\n+    @Test\n+    void testEnterNoContention() throws Exception {\n+        var lock = new Object();\n+        VThreadRunner.run(() -> {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor is held by platform thread.\n+     *\/\n+    @Test\n+    void testEnterWhenHeldByPlatformThread() throws Exception {\n+        testEnterWithContention();\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor is held by virtual thread.\n+     *\/\n+    @Test\n+    void testEnterWhenHeldByVirtualThread() throws Exception {\n+        VThreadRunner.run(this::testEnterWithContention);\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor will be held by caller thread.\n+     *\/\n+    private void testEnterWithContention() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+                entered.set(true);\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+\n+                \/\/ wait for thread to start and block\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test monitor reenter.\n+     *\/\n+    @Test\n+    void testReenter() throws Exception {\n+        var lock = new Object();\n+        VThreadRunner.run(() -> {\n+            testReenter(lock, 0);\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    private void testReenter(Object lock, int depth) {\n+        if (depth < MAX_ENTER_DEPTH) {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+                testReenter(lock, depth + 1);\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test monitor enter when pinned.\n+     *\/\n+    @Test\n+    void testEnterWhenPinned() throws Exception {\n+        var lock = new Object();\n+        VThreadPinner.runPinned(() -> {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test monitor reenter when pinned.\n+     *\/\n+    @Test\n+    void testReenterWhenPinned() throws Exception {\n+        VThreadRunner.run(() -> {\n+            var lock = new Object();\n+            synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                    synchronized (lock) {\n+                        assertTrue(Thread.holdsLock(lock));\n+                    }\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned. Monitor is held by platform thread.\n+     *\/\n+    @Test\n+    void testContendedEnterWhenPinnedHeldByPlatformThread() throws Exception {\n+        testEnterWithContentionWhenPinned();\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned. Monitor is held by virtual thread.\n+     *\/\n+    @Test\n+    void testContendedEnterWhenPinnedHeldByVirtualThread() throws Exception {\n+        \/\/ need at least two carrier threads\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            VThreadRunner.run(this::testEnterWithContentionWhenPinned);\n+        } finally {\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned, monitor will be held by caller thread.\n+     *\/\n+    private void testEnterWithContentionWhenPinned() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        Thread vthread = Thread.ofVirtual().unstarted(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                started.countDown();\n+                synchronized (lock) {\n+                    entered.set(true);\n+                }\n+            });\n+        });\n+        synchronized (lock) {\n+            \/\/ start thread and wait for it to block\n+            vthread.start();\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+            assertFalse(entered.get());\n+        }\n+        vthread.join();\n+\n+        \/\/ check thread entered monitor\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Returns a stream of elements that are ordered pairs of platform and virtual thread\n+     * counts. 0,2,4,..16 platform threads. 2,4,6,..32 virtual threads.\n+     *\/\n+    static Stream<Arguments> threadCounts() {\n+        return IntStream.range(0, 17)\n+                .filter(i -> i % 2 == 0)\n+                .mapToObj(i -> i)\n+                .flatMap(np -> IntStream.range(2, 33)\n+                        .filter(i -> i % 2 == 0)\n+                        .mapToObj(vp -> Arguments.of(np, vp)));\n+    }\n+\n+    \/**\n+     * Test mutual exclusion of monitors with platform and virtual threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadCounts\")\n+    void testMutualExclusion(int nPlatformThreads, int nVirtualThreads) throws Exception {\n+        class Counter {\n+            int count;\n+            synchronized void increment() {\n+                count++;\n+                Thread.yield();\n+            }\n+        }\n+        var counter = new Counter();\n+        int nThreads = nPlatformThreads + nVirtualThreads;\n+        var threads = new Thread[nThreads];\n+        int index = 0;\n+        for (int i = 0; i < nPlatformThreads; i++) {\n+            threads[index] = Thread.ofPlatform()\n+                    .name(\"platform-\" + index)\n+                    .unstarted(counter::increment);\n+            index++;\n+        }\n+        for (int i = 0; i < nVirtualThreads; i++) {\n+            threads[index] = Thread.ofVirtual()\n+                    .name(\"virtual-\" + index)\n+                    .unstarted(counter::increment);\n+            index++;\n+        }\n+        \/\/ start all threads\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+        \/\/ wait for all threads to terminate\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        assertEquals(nThreads, counter.count);\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor held by a platform thread.\n+     *\/\n+    @RepeatedTest(20)\n+    void testUnblockingByPlatformThread() throws Exception {\n+        testUnblocking();\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor held by another\n+     * virtual thread.\n+     *\/\n+    @RepeatedTest(20)\n+    void testUnblockingByVirtualThread() throws Exception {\n+        VThreadRunner.run(this::testUnblocking);\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor, monitor will be\n+     * initially be held by caller thread.\n+     *\/\n+    private void testUnblocking() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                entered.set(true);\n+            }\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+                started.await();\n+\n+                \/\/ random delay before exiting monitor\n+                switch (ThreadLocalRandom.current().nextInt(4)) {\n+                    case 0 -> { \/* no delay *\/}\n+                    case 1 -> Thread.onSpinWait();\n+                    case 2 -> Thread.yield();\n+                    case 3 -> await(vthread, Thread.State.BLOCKED);\n+                    default -> fail();\n+                }\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test that unblocking a virtual thread waiting to enter a monitor does not consume\n+     * the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotConsumed() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            LockSupport.unpark(Thread.currentThread());\n+            synchronized (lock) { }  \/\/ should block\n+            LockSupport.park();      \/\/ should not park\n+        });\n+\n+        synchronized (lock) {\n+            vthread.start();\n+            \/\/ wait for thread to start and block\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+    }\n+\n+    \/**\n+     * Test that unblocking a virtual thread waiting to enter a monitor does not make\n+     * available the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotOffered() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) { }  \/\/ should block\n+            LockSupport.park();      \/\/ should park\n+        });\n+\n+        synchronized (lock) {\n+            vthread.start();\n+            \/\/ wait for thread to start and block\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+\n+        try {\n+            \/\/ wait for thread to park, it should not terminate\n+            await(vthread, Thread.State.WAITING);\n+            vthread.join(Duration.ofMillis(100));\n+            assertEquals(Thread.State.WAITING, vthread.getState());\n+        } finally {\n+            LockSupport.unpark(vthread);\n+            vthread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-\/**\n- * @test\n+\/*\n+ * @test id=default\n@@ -29,1 +29,1 @@\n- * @run junit MonitorWaitNotify\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -32,1 +32,15 @@\n-import java.util.concurrent.Semaphore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n@@ -34,0 +48,2 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -35,0 +51,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -36,0 +53,3 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -37,0 +57,1 @@\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -40,0 +61,6 @@\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n@@ -43,2 +70,3 @@\n-    @Test\n-    void testWaitNotify1() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWaitNotify1(boolean pinned) throws Exception {\n@@ -46,1 +74,1 @@\n-        var ready = new Semaphore(0);\n+        var ready = new AtomicBoolean();\n@@ -49,1 +77,0 @@\n-                ready.release();\n@@ -51,1 +78,9 @@\n-                    lock.wait();\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n@@ -55,2 +90,3 @@\n-        \/\/ thread invokes notify\n-        ready.acquire();\n+        awaitTrue(ready);\n+\n+        \/\/ notify, thread should block waiting to reenter\n@@ -59,0 +95,1 @@\n+            await(thread, Thread.State.BLOCKED);\n@@ -69,3 +106,1 @@\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n@@ -77,1 +112,1 @@\n-            ready.release();\n+            thread.start();\n@@ -86,11 +121,15 @@\n-    @Test\n-    void testWaitNotify3() throws Exception {\n-        \/\/ need at least two carrier threads due to pinning\n-        int previousParallelism = VThreadRunner.ensureParallelism(2);\n-        try {\n-            var lock = new Object();\n-            var ready = new Semaphore(0);\n-            var thread1 = Thread.ofVirtual().start(() -> {\n-                synchronized (lock) {\n-                    ready.release();\n-                    try {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWaitNotify3(boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var thread1 = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n@@ -98,1 +137,3 @@\n-                    } catch (InterruptedException e) { }\n+                    }\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n@@ -100,3 +141,7 @@\n-            });\n-            var thread2 = Thread.ofVirtual().start(() -> {\n-                ready.acquireUninterruptibly();\n+            }\n+        });\n+        var thread2 = Thread.ofVirtual().start(() -> {\n+            try {\n+                awaitTrue(ready);\n+\n+                \/\/ notify, thread should block waiting to reenter\n@@ -105,0 +150,1 @@\n+                    await(thread1, Thread.State.BLOCKED);\n@@ -106,3 +152,48 @@\n-            });\n-            thread1.join();\n-            thread2.join();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        thread1.join();\n+        thread2.join();\n+    }\n+\n+    \/**\n+     * Test notifyAll when there are no threads waiting.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testNotifyBeforeWait(int timeout) throws Exception {\n+        var lock = new Object();\n+\n+        \/\/ no threads waiting\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    ready.set(true);\n+\n+                    \/\/ thread should wait\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        try {\n+            \/\/ wait for thread to start and wait\n+            awaitTrue(ready);\n+            Thread.State expectedState = timeout > 0\n+                    ? Thread.State.TIMED_WAITING\n+                    : Thread.State.WAITING;\n+            await(thread, expectedState);\n+\n+            \/\/ poll thread state again, it should still be waiting\n+            Thread.sleep(10);\n+            assertEquals(thread.getState(), expectedState);\n@@ -110,2 +201,4 @@\n-            \/\/ restore\n-            VThreadRunner.setParallelism(previousParallelism);\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+            thread.join();\n@@ -114,0 +207,23 @@\n+    \/**\n+     * Test duration of timed Object.wait.\n+     *\/\n+    @Test\n+    void testTimedWaitDuration1() throws Exception {\n+        var lock = new Object();\n+\n+        var durationRef = new AtomicReference<Long>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    long start = millisTime();\n+                    lock.wait(2000);\n+                    durationRef.set(millisTime() - start);\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        thread.join();\n+\n+        long duration = durationRef.get();\n+        checkDuration(duration, 1900, 20_000);\n+    }\n@@ -116,1 +232,3 @@\n-     * Test interrupt status set when calling Object.wait.\n+     * Test duration of timed Object.wait. This test invokes wait twice, first with a short\n+     * timeout, the second with a longer timeout. The test scenario ensures that the\n+     * timeout from the first wait doesn't interfere with the second wait.\n@@ -119,1 +237,40 @@\n-    void testWaitNotify4() throws Exception {\n+    void testTimedWaitDuration2() throws Exception {\n+        var lock = new Object();\n+\n+        var ready = new AtomicBoolean();\n+        var waited = new AtomicBoolean();\n+        var durationRef = new AtomicReference<Long>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    ready.set(true);\n+                    lock.wait(200);\n+                    waited.set(true);\n+\n+                    long start = millisTime();\n+                    lock.wait(2000);\n+                    durationRef.set(millisTime() - start);\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        awaitTrue(ready);\n+        synchronized (lock) {\n+            \/\/ wake thread if waiting in first wait\n+            if (!waited.get()) {\n+                lock.notifyAll();\n+            }\n+        }\n+\n+        thread.join();\n+\n+        long duration = durationRef.get();\n+        checkDuration(duration, 1900, 20_000);\n+    }\n+\n+    \/**\n+     * Testing invoking Object.wait with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testWaitWithInterruptSet(int timeout) throws Exception {\n@@ -121,2 +278,0 @@\n-            Thread t = Thread.currentThread();\n-            t.interrupt();\n@@ -124,0 +279,146 @@\n+            synchronized (lock) {\n+                Thread.currentThread().interrupt();\n+                if (timeout > 0) {\n+                    assertThrows(InterruptedException.class, () -> lock.wait(timeout));\n+                } else {\n+                    assertThrows(InterruptedException.class, lock::wait);\n+                }\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupting a virtual thread waiting in Object.wait.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testInterruptWait(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    ready.set(true);\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) {\n+                    \/\/ check stack trace has the expected frames\n+                    Set<String> expected = Set.of(\"wait0\", \"wait\", \"run\");\n+                    Set<String> methods = Stream.of(e.getStackTrace())\n+                            .map(StackTraceElement::getMethodName)\n+                            .collect(Collectors.toSet());\n+                    assertTrue(methods.containsAll(expected));\n+\n+                    interruptedException.set(true);\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ interrupt thread, should block, then throw InterruptedException\n+        synchronized (lock) {\n+            vthread.interrupt();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+        assertTrue(interruptedException.get());\n+    }\n+\n+    \/**\n+     * Test interrupting a virtual thread blocked waiting to reenter after waiting.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testInterruptReenterAfterWait(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    ready.set(true);\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) {\n+                    interruptedException.set(true);\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ notify, thread should block waiting to reenter\n+        synchronized (lock) {\n+            lock.notifyAll();\n+            await(vthread, Thread.State.BLOCKED);\n+\n+            \/\/ interrupt when blocked\n+            vthread.interrupt();\n+        }\n+\n+        vthread.join();\n+        assertFalse(interruptedException.get());\n+        assertTrue(vthread.isInterrupted());\n+    }\n+\n+    \/**\n+     * Test Object.wait when the monitor entry count > 1.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testWaitWhenEnteredManyTimes(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                synchronized (lock) {\n+                    synchronized (lock) {\n+                        try {\n+                            ready.set(true);\n+                            if (timeout > 0) {\n+                                lock.wait(timeout);\n+                            } else {\n+                                lock.wait();\n+                            }\n+                        } catch (InterruptedException e) { }\n+                    }\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ notify, thread should block waiting to reenter\n+        synchronized (lock) {\n+            lock.notifyAll();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+    }\n+\n+    \/**\n+     * Test that Object.wait does not consume the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotConsumed() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var completed = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+            LockSupport.unpark(Thread.currentThread());\n@@ -127,1 +428,0 @@\n-                    fail();\n@@ -129,2 +429,1 @@\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n+                    fail(\"wait interrupted\");\n@@ -133,0 +432,2 @@\n+            LockSupport.park();      \/\/ should not park\n+            completed.set(true);\n@@ -134,0 +435,13 @@\n+\n+        \/\/ wait for thread to start and wait\n+        started.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        \/\/ wakeup thread\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ thread should terminate\n+        vthread.join();\n+        assertTrue(completed.get());\n@@ -137,1 +451,1 @@\n-     * Test interrupt when blocked in Object.wait.\n+     * Test that Object.wait does not make available the thread's parking permit.\n@@ -140,5 +454,7 @@\n-    void testWaitNotify5() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            scheduleInterrupt(t, 1000);\n-            Object lock = new Object();\n+    void testParkingPermitNotOffered() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var readyToPark = new CountDownLatch(1);\n+        var completed = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n@@ -148,1 +464,0 @@\n-                    fail();\n@@ -150,2 +465,1 @@\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n+                    fail(\"wait interrupted\");\n@@ -154,0 +468,3 @@\n+            readyToPark.countDown();\n+            LockSupport.park();      \/\/ should park\n+            completed.set(true);\n@@ -155,0 +472,19 @@\n+\n+        \/\/ wait for thread to start and wait\n+        started.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        \/\/ wakeup thread\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ thread should park\n+        readyToPark.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        LockSupport.unpark(vthread);\n+\n+        \/\/ thread should terminate\n+        vthread.join();\n+        assertTrue(completed.get());\n@@ -158,1 +494,1 @@\n-     * Schedule a thread to be interrupted after a delay.\n+     * Test that wait(long) throws IAE when timeout is negative.\n@@ -160,7 +496,8 @@\n-    private static void scheduleInterrupt(Thread thread, long delay) {\n-        Runnable interruptTask = () -> {\n-            try {\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n+    @Test\n+    void testIllegalArgumentException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Object obj = new Object();\n+            synchronized (obj) {\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(-1L));\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(-1000L));\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(Long.MIN_VALUE));\n@@ -168,2 +505,58 @@\n-        };\n-        new Thread(interruptTask).start();\n+        });\n+    }\n+\n+    \/**\n+     * Test that wait throws IMSE when not owner.\n+     *\/\n+    @Test\n+    void testIllegalMonitorStateException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Object obj = new Object();\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait());\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(0));\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(1000));\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(Long.MAX_VALUE));\n+        });\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check a duration is within expected bounds.\n+     * @param duration, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private static void checkDuration(long duration, long min, long max) {\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":455,"deletions":62,"binary":false,"changes":517,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +36,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -61,3 +63,1 @@\n-            ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler)\n-                    .name(\"vthread-\", 0)\n-                    .factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -145,1 +146,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -148,2 +149,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -324,1 +324,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -327,2 +327,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test stack traces in exceptions, stack frames walked by the StackWalker,\n+ *    and the stack trace returned by Thread.getStackTrace\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n+ * @run junit StackFrames\n+ * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackFrames\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import static java.lang.StackWalker.Option.*;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StackFrames {\n+\n+    \/**\n+     * Test that the stack trace in exceptions does not include the carrier thread\n+     * frames, except when running with -XX:+ShowCarrierFrames.\n+     *\/\n+    @Test\n+    void testStackTraceException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Exception e = new Exception();\n+            boolean found = Arrays.stream(e.getStackTrace())\n+                    .map(StackTraceElement::getClassName)\n+                    .anyMatch(\"java.util.concurrent.ForkJoinPool\"::equals);\n+            assertTrue(found == hasJvmArgument(\"-XX:+ShowCarrierFrames\"));\n+        });\n+    }\n+\n+    \/**\n+     * Test that StackWalker does not include carrier thread frames in the stream of\n+     * stack frames.\n+     *\/\n+    @Test\n+    void testStackWalker() throws Exception {\n+        VThreadRunner.run(() -> {\n+            StackWalker walker = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE));\n+            boolean found = walker.walk(sf ->\n+                    sf.map(StackWalker.StackFrame::getDeclaringClass)\n+                            .anyMatch(c -> c == ForkJoinPool.class));\n+            assertFalse(found);\n+        });\n+    }\n+\n+    \/**\n+     * Test Thread.getStackTrace returns the expected bottom frame for both the carrier\n+     * and virtual thread.\n+     *\/\n+    @Test\n+    void testBottomFrames() throws Exception {\n+        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n+            var carrierRef = new AtomicReference<Thread>();\n+            Executor scheduler = task -> {\n+                pool.submit(() -> {\n+                    carrierRef.set(Thread.currentThread());\n+                    task.run();\n+                });\n+            };\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+\n+            var ready = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+\n+            \/\/ create virtual thread to use custom scheduler\n+            var vthread = factory.newThread(() -> {\n+                ready.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+\n+            vthread.start();\n+            try {\n+                awaitTrue(ready);\n+\n+                \/\/ get carrier Thread\n+                Thread carrier = carrierRef.get();\n+                assertTrue(carrier instanceof ForkJoinWorkerThread);\n+\n+                \/\/ bottom-most frame of virtual thread should be VirtualThread.run\n+                System.err.println(vthread);\n+                StackTraceElement[] vthreadStack = vthread.getStackTrace();\n+                Stream.of(vthreadStack).forEach(e -> System.err.println(\"    \" + e));\n+                StackTraceElement bottomFrame = vthreadStack[vthreadStack.length - 1];\n+                assertEquals(\"java.lang.VirtualThread.run\",\n+                        bottomFrame.getClassName() + \".\" + bottomFrame.getMethodName());\n+\n+                \/\/ bottom-most frame of carrier thread should be Thread.run\n+                System.err.println(carrier);\n+                StackTraceElement[] carrierStack = carrier.getStackTrace();\n+                Stream.of(carrierStack).forEach(e -> System.err.println(\"    \" + e));\n+                bottomFrame = carrierStack[carrierStack.length - 1];\n+                assertEquals(\"java.util.concurrent.ForkJoinWorkerThread.run\",\n+                        bottomFrame.getClassName() + \".\" + bottomFrame.getMethodName());\n+\n+            } finally {\n+                done.set(true);\n+                vthread.join();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if started with the given VM option.\n+     *\/\n+    private static boolean hasJvmArgument(String arg) {\n+        for (String argument : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n+            if (argument.equals(arg)) return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackFrames.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test stack traces in exceptions and stack frames walked by the StackWalker\n- *     API do not include the carrier stack frames\n- * @requires vm.continuations\n- * @modules java.management\n- * @library \/test\/lib\n- * @run junit StackTraces\n- * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.concurrent.ForkJoinPool;\n-import static java.lang.StackWalker.Option.*;\n-\n-import jdk.test.lib.thread.VThreadRunner;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StackTraces {\n-\n-    \/**\n-     * Test that the stack trace in exceptions does not include the carrier thread\n-     * frames, except when running with -XX:+ShowCarrierFrames.\n-     *\/\n-    @Test\n-    void testStackTrace() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Exception e = new Exception();\n-            boolean found = Arrays.stream(e.getStackTrace())\n-                    .map(StackTraceElement::getClassName)\n-                    .anyMatch(\"java.util.concurrent.ForkJoinPool\"::equals);\n-            assertTrue(found == hasJvmArgument(\"-XX:+ShowCarrierFrames\"));\n-        });\n-    }\n-\n-    \/**\n-     * Test that StackWalker does not include carrier thread frames.\n-     *\/\n-    @Test\n-    void testStackWalker() throws Exception {\n-        VThreadRunner.run(() -> {\n-            StackWalker walker = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE));\n-            boolean found = walker.walk(sf ->\n-                    sf.map(StackWalker.StackFrame::getDeclaringClass)\n-                            .anyMatch(c -> c == ForkJoinPool.class));\n-            assertFalse(found);\n-        });\n-    }\n-\n-    private static boolean hasJvmArgument(String arg) {\n-        for (String argument : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n-            if (argument.equals(arg)) return true;\n-        }\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-import jdk.test.lib.thread.VThreadRunner;\n@@ -66,0 +65,2 @@\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -69,0 +70,1 @@\n+import org.junit.jupiter.api.Disabled;\n@@ -71,0 +73,1 @@\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -81,1 +84,1 @@\n-    static void setup() throws Exception {\n+    static void setup() {\n@@ -84,0 +87,3 @@\n+\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n@@ -722,8 +728,1 @@\n-        \/\/ need at least two carrier threads due to pinning\n-        int previousParallelism = VThreadRunner.ensureParallelism(2);\n-        try {\n-            VThreadRunner.run(this::testJoin33);\n-        } finally {\n-            \/\/ restore\n-            VThreadRunner.setParallelism(previousParallelism);\n-        }\n+        VThreadRunner.run(this::testJoin33);\n@@ -1087,1 +1086,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1090,2 +1089,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -1115,1 +1113,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1118,2 +1116,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -1711,1 +1708,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1714,4 +1711,4 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread t1 = builder.start(() -> {\n-                Thread t2 = builder.unstarted(LockSupport::park);\n-                assertEquals(Thread.State.NEW, t2.getState());\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread thread1 = factory.newThread(() -> {\n+                Thread thread2 = factory.newThread(LockSupport::park);\n+                assertEquals(Thread.State.NEW, thread2.getState());\n@@ -1720,1 +1717,1 @@\n-                t2.start();\n+                thread2.start();\n@@ -1722,1 +1719,1 @@\n-                    assertEquals(Thread.State.RUNNABLE, t2.getState());\n+                    assertEquals(Thread.State.RUNNABLE, thread2.getState());\n@@ -1726,1 +1723,1 @@\n-                    assertEquals(Thread.State.WAITING, t2.getState());\n+                    assertEquals(Thread.State.WAITING, thread2.getState());\n@@ -1729,1 +1726,1 @@\n-                    LockSupport.unpark(t2);\n+                    LockSupport.unpark(thread2);\n@@ -1733,1 +1730,1 @@\n-                assertEquals(Thread.State.RUNNABLE, t2.getState());\n+                assertEquals(Thread.State.RUNNABLE, thread2.getState());\n@@ -1737,1 +1734,2 @@\n-            t1.join();\n+            thread1.start();\n+            thread1.join();\n@@ -1743,1 +1741,1 @@\n-     * Test Thread::getState when thread is waiting to enter a monitor.\n+     * Test Thread::getState when thread is blocked waiting to enter a monitor.\n@@ -1745,3 +1743,4 @@\n-    @Test\n-    void testGetState5() throws Exception {\n-        var started = new CountDownLatch(1);\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState5(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1749,2 +1748,9 @@\n-            started.countDown();\n-            synchronized (lock) { }\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    synchronized (lock) { }\n+                });\n+            } else {\n+                ready.set(true);\n+                synchronized (lock) { }\n+            }\n@@ -1754,1 +1760,1 @@\n-            started.await();\n+            awaitTrue(ready);\n@@ -1765,2 +1771,4 @@\n-    @Test\n-    void testGetState6() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState6(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1769,1 +1777,11 @@\n-                try { lock.wait(); } catch (InterruptedException e) { }\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) { }\n@@ -1774,0 +1792,1 @@\n+            awaitTrue(ready);\n@@ -1775,0 +1794,6 @@\n+\n+            \/\/ notify, thread should block trying to reenter\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                await(thread, Thread.State.BLOCKED);\n+            }\n@@ -1784,2 +1809,4 @@\n-    @Test\n-    void testGetState7() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState7(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1789,1 +1816,9 @@\n-                    lock.wait(Long.MAX_VALUE);\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait(Long.MAX_VALUE);\n+                    }\n@@ -1794,1 +1829,2 @@\n-            \/\/ wait for thread to wait\n+            \/\/ wait for thread to timed-wait\n+            awaitTrue(ready);\n@@ -1796,0 +1832,6 @@\n+\n+            \/\/ notify, thread should block trying to reenter\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                await(thread, Thread.State.BLOCKED);\n+            }\n@@ -1936,1 +1978,1 @@\n-    void testGetStackTrace1() {\n+    void testGetStackTraceUnstarted() {\n@@ -1946,2 +1988,2 @@\n-    void testGetStackTrace2() throws Exception {\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+    void testGetStackTraceStarted() throws Exception {\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1949,2 +1991,3 @@\n-        Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-        Thread thread = builder.start(() -> { });\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(() -> { });\n+        thread.start();\n@@ -1956,1 +1999,1 @@\n-     * Test Thread::getStackTrace on running thread.\n+     * Test Thread::getStackTrace on thread that is runnable-mounted.\n@@ -1959,9 +2002,10 @@\n-    void testGetStackTrace3() throws Exception {\n-        var sel = Selector.open();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try { sel.select(); } catch (Exception e) { }\n-        });\n-        try {\n-            while (!contains(thread.getStackTrace(), \"select\")) {\n-                assertTrue(thread.isAlive());\n-                Thread.sleep(20);\n+    void testGetStackTraceRunnableMounted() throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+\n+        class Foo {\n+            void spinUntilDone() {\n+                ready.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n@@ -1969,0 +2013,8 @@\n+        }\n+\n+        Foo foo = new Foo();\n+        var thread = Thread.ofVirtual().start(foo::spinUntilDone);\n+        try {\n+            awaitTrue(ready);\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, Foo.class.getName() + \".spinUntilDone\"));\n@@ -1970,1 +2022,1 @@\n-            sel.close();\n+            done.set(true);\n@@ -1976,1 +2028,1 @@\n-     * Test Thread::getStackTrace on thread waiting in Object.wait.\n+     * Test Thread::getStackTrace on thread that is runnable-unmounted.\n@@ -1979,10 +2031,2 @@\n-    void testGetStackTrace4() throws Exception {\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n-        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n-            AtomicReference<Thread> ref = new AtomicReference<>();\n-            Executor scheduler = task -> {\n-                pool.submit(() -> {\n-                    ref.set(Thread.currentThread());\n-                    task.run();\n-                });\n-            };\n+    void testGetStackTraceRunnableUnmounted() throws Exception {\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1990,6 +2034,16 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.start(() -> {\n-                synchronized (lock) {\n-                    try {\n-                        lock.wait();\n-                    } catch (Exception e) { }\n+        \/\/ custom scheduler with one carrier thread\n+        try (ExecutorService scheduler = Executors.newFixedThreadPool(1)) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+\n+            \/\/ start thread1 to park\n+            Thread thread1 = factory.newThread(LockSupport::park);\n+            thread1.start();\n+            await(thread1, Thread.State.WAITING);\n+\n+            \/\/ start thread2 to spin and pin the carrier thread\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread thread2 = factory.newThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n@@ -1998,0 +2052,2 @@\n+            thread2.start();\n+            awaitTrue(started);\n@@ -1999,5 +2055,5 @@\n-            \/\/ get carrier Thread\n-            Thread carrier;\n-            while ((carrier = ref.get()) == null) {\n-                Thread.sleep(20);\n-            }\n+            try {\n+                \/\/ unpark thread1, it should be \"stuck\" in runnable state\n+                \/\/ (the carrier thread is pinned, no other virtual thread can run)\n+                LockSupport.unpark(thread1);\n+                assertEquals(Thread.State.RUNNABLE, thread1.getState());\n@@ -2005,2 +2061,3 @@\n-            \/\/ wait for virtual thread to block in wait\n-            await(vthread, Thread.State.WAITING);\n+                \/\/ print thread1's stack trace\n+                StackTraceElement[] stack = thread1.getStackTrace();\n+                assertTrue(contains(stack, \"LockSupport.park\"));\n@@ -2008,3 +2065,5 @@\n-            \/\/ get stack trace of both carrier and virtual thread\n-            StackTraceElement[] carrierStackTrace = carrier.getStackTrace();\n-            StackTraceElement[] vthreadStackTrace = vthread.getStackTrace();\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n@@ -2012,3 +2071,22 @@\n-            \/\/ allow virtual thread to terminate\n-            synchronized (lock) {\n-                lock.notifyAll();\n+    \/**\n+     * Test Thread::getStackTrace on thread blocked on monitor enter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceBlocked(boolean pinned) throws Exception {\n+        class Foo {\n+            void enter() {\n+                synchronized (this) { }\n+            }\n+        }\n+        Foo foo = new Foo();\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    foo.enter();\n+                });\n+            } else {\n+                ready.set(true);\n+                foo.enter();\n@@ -2016,0 +2094,4 @@\n+        });\n+        synchronized (foo) {\n+            thread.start();\n+            awaitTrue(ready);\n@@ -2017,3 +2099,2 @@\n-            \/\/ check carrier thread's stack trace\n-            assertTrue(contains(carrierStackTrace, \"java.util.concurrent.ForkJoinPool.runWorker\"));\n-            assertFalse(contains(carrierStackTrace, \"java.lang.Object.wait\"));\n+            \/\/ wait for thread to block\n+            await(thread, Thread.State.BLOCKED);\n@@ -2021,3 +2102,2 @@\n-            \/\/ check virtual thread's stack trace\n-            assertFalse(contains(vthreadStackTrace, \"java.util.concurrent.ForkJoinPool.runWorker\"));\n-            assertTrue(contains(vthreadStackTrace, \"java.lang.Object.wait\"));\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, Foo.class.getName() + \".enter\"));\n@@ -2025,0 +2105,1 @@\n+        thread.join();\n@@ -2028,1 +2109,1 @@\n-     * Test Thread::getStackTrace on parked thread.\n+     * Test Thread::getStackTrace when thread is waiting in Object.wait.\n@@ -2030,4 +2111,19 @@\n-    @Test\n-    void testGetStackTrace5() throws Exception {\n-        var thread = Thread.ofVirtual().start(LockSupport::park);\n-        await(thread, Thread.State.WAITING);\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceWaiting(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n@@ -2035,0 +2131,4 @@\n+            \/\/ wait for thread to wait\n+            awaitTrue(ready);\n+            await(thread, Thread.State.WAITING);\n+\n@@ -2036,1 +2136,1 @@\n-            assertTrue(contains(stack, \"LockSupport.park\"));\n+            assertTrue(contains(stack, \"Object.wait\"));\n@@ -2038,1 +2138,1 @@\n-            LockSupport.unpark(thread);\n+            thread.interrupt();\n@@ -2044,1 +2144,1 @@\n-     * Test Thread::getStackTrace on timed-parked thread.\n+     * Test Thread::getStackTrace when thread is waiting in timed-Object.wait.\n@@ -2046,2 +2146,4 @@\n-    @Test\n-    void testGetStackTrace6() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceTimedWaiting(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -2049,1 +2151,13 @@\n-            LockSupport.parkNanos(Long.MAX_VALUE);\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait(Long.MAX_VALUE);\n+                    }\n+                } catch (InterruptedException e) { }\n+            }\n@@ -2051,1 +2165,0 @@\n-        await(thread, Thread.State.TIMED_WAITING);\n@@ -2053,0 +2166,4 @@\n+            \/\/ wait for thread to wait\n+            awaitTrue(ready);\n+            await(thread, Thread.State.TIMED_WAITING);\n+\n@@ -2054,1 +2171,1 @@\n-            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+            assertTrue(contains(stack, \"Object.wait\"));\n@@ -2056,1 +2173,1 @@\n-            LockSupport.unpark(thread);\n+            thread.interrupt();\n@@ -2062,1 +2179,1 @@\n-     * Test Thread::getStackTrace on parked thread that is pinned.\n+     * Test Thread::getStackTrace when thread in park.\n@@ -2064,3 +2181,5 @@\n-    @Test\n-    void testGetStackTrace7() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceParked(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n@@ -2068,1 +2187,9 @@\n-            VThreadPinner.runPinned(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -2072,1 +2199,1 @@\n-            });\n+            }\n@@ -2074,1 +2201,0 @@\n-        await(thread, Thread.State.WAITING);\n@@ -2076,0 +2202,4 @@\n+            \/\/ wait for thread to park\n+            awaitTrue(ready);\n+            await(thread, Thread.State.WAITING);\n+\n@@ -2086,1 +2216,1 @@\n-     * Test Thread::getStackTrace on timed-parked thread that is pinned.\n+     * Test Thread::getStackTrace when thread in timed-park.\n@@ -2088,3 +2218,5 @@\n-    @Test\n-    void testGetStackTrace8() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceTimedPark(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n@@ -2092,1 +2224,9 @@\n-            VThreadPinner.runPinned(() -> {\n+            if (pinned) {\n+                ready.set(true);\n+                VThreadPinner.runPinned(() -> {\n+                    while (!done.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -2096,1 +2236,1 @@\n-            });\n+            }\n@@ -2098,1 +2238,0 @@\n-        await(thread, Thread.State.TIMED_WAITING);\n@@ -2100,0 +2239,4 @@\n+            \/\/ wait for thread to park\n+            awaitTrue(ready);\n+            await(thread, Thread.State.TIMED_WAITING);\n+\n@@ -2113,1 +2256,1 @@\n-    void testGetStackTrace9() throws Exception {\n+    void testGetStackTraceTerminated() throws Exception {\n@@ -2136,1 +2279,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -2146,2 +2289,2 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread vthread = factory.newThread(() -> {\n@@ -2154,0 +2297,1 @@\n+            vthread.start();\n@@ -2171,0 +2315,1 @@\n+            vthread.join();\n@@ -2172,1 +2317,1 @@\n-            \/\/ get stack trace for the carrier thread\n+            \/\/ stack trace for the carrier thread\n@@ -2420,0 +2565,9 @@\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":281,"deletions":127,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n-\n-\/**\n- * Helper class for creating Thread buidlers.\n- *\n- * Tests using this class need to open java.base\/java.lang.\n- *\/\n-class ThreadBuilders {\n-    private ThreadBuilders() { }\n-\n-    private static final Constructor<?> VTBUILDER_CTOR;\n-    static {\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            VTBUILDER_CTOR = ctor;\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     * @throws UnsupportedOperationException if custom schedulers are not supported\n-     *\/\n-    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        try {\n-            return (Thread.Builder.OfVirtual) VTBUILDER_CTOR.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Return true if custom schedulers are supported.\n-     *\/\n-    static boolean supportsCustomScheduler() {\n-        try (var pool = Executors.newCachedThreadPool()) {\n-            try {\n-                virtualThreadBuilder(pool);\n-                return true;\n-            } catch (UnsupportedOperationException e) {\n-                return false;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8335269\n+ * @summary Test that Thread.yield loop polls for safepoints\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run junit\/othervm ThreadPollOnYield\n+ *\/\n+\n+\/*\n+ * @test id=c2\n+ * @bug 8335269\n+ * @summary Test that Thread.yield loop polls for safepoints\n+ * @requires vm.continuations & vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=inline,*::yield* -XX:CompileCommand=inline,*::*Yield ThreadPollOnYield\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.test.lib.thread.VThreadPinner;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ThreadPollOnYield {\n+    static void foo(AtomicBoolean done) {\n+        while (!done.get()) {\n+            Thread.yield();\n+        }\n+    }\n+\n+    @Test\n+    void testThreadYieldPolls() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> foo(done));\n+        });\n+        Thread.sleep(5000);\n+        done.set(true);\n+        vthread.join();\n+\n+        System.out.println(\"First vthread done\");\n+\n+        AtomicBoolean done2 = new AtomicBoolean();\n+        vthread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> foo(done2));\n+        });\n+        long start = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - start < 5000) {\n+            Thread.sleep(250);\n+            System.gc();\n+        }\n+        done2.set(true);\n+        vthread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadPollOnYield.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.event\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.event\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -41,0 +42,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -45,0 +47,8 @@\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress parking with CompletableFuture timed get\n+ * @requires vm.debug != true & vm.continuations\n+ * @run main\/othervm -Xmx1g CompletableFutureTimedGet 100000\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class CompletableFutureTimedGet {\n+\n+    static final String RESULT = \"foo\";\n+\n+    public static void main(String... args) throws InterruptedException {\n+        int threadCount = 250_000;\n+        if (args.length > 0) {\n+            threadCount = Integer.parseInt(args[0]);\n+        }\n+\n+        \/\/ the count of the number of threads that complete successfully\n+        AtomicInteger completed = new AtomicInteger();\n+\n+        \/\/ list of futures and threads\n+        List<CompletableFuture<String>> futures = new ArrayList<>();\n+        List<Thread> threads = new ArrayList<>();\n+\n+        \/\/ start threads that wait with timeout for a result\n+        for (int i = 0; i < threadCount; i++) {\n+            var future = new CompletableFuture<String>();\n+            futures.add(future);\n+\n+            \/\/ start a thread that uses a timed-get to wait for the result\n+            Thread thread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    String result = future.get(1, TimeUnit.DAYS);\n+                    if (!RESULT.equals(result)) {\n+                        throw new RuntimeException(\"result=\" + result);\n+                    }\n+                    completed.incrementAndGet();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+\n+        \/\/ sets the result, which will unpark waiting threads\n+        futures.forEach(f -> f.complete(RESULT));\n+\n+        \/\/ wait for all threads to terminate\n+        long lastTimestamp = System.currentTimeMillis();\n+        boolean done;\n+        do {\n+            done = true;\n+            for (Thread t : threads) {\n+                if (!t.join(Duration.ofSeconds(1))) {\n+                    done = false;\n+                }\n+            }\n+\n+            \/\/ print trace message so the output tracks progress\n+            long currentTime = System.currentTimeMillis();\n+            if (done || ((currentTime - lastTimestamp) > 500)) {\n+                System.out.format(\"%s => completed %d of %d%n\",\n+                        Instant.now(), completed.get(), threadCount);\n+                lastTimestamp = currentTime;\n+            }\n+\n+        } while (!done);\n+\n+        \/\/ all tasks should have completed successfully\n+        int completedCount = completed.get();\n+        if (completedCount != threadCount) {\n+            throw new RuntimeException(\"completed = \" + completedCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/CompletableFutureTimedGet.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Stress test asynchronous Thread.getStackTrace\n- * @requires vm.debug != true & vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main GetStackTraceALot\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.debug == true & vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main\/timeout=300 GetStackTraceALot 1000\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.LockSupport;\n-\n-public class GetStackTraceALot {\n-    static class RoundRobinExecutor implements Executor, AutoCloseable {\n-        private final ExecutorService[] executors;\n-        private int next;\n-\n-        RoundRobinExecutor() {\n-            var factory = Thread.ofPlatform().name(\"worker-\", 1).daemon(true).factory();\n-            var executors = new ExecutorService[2];\n-            for (int i = 0; i < executors.length; i++) {\n-                executors[i] = Executors.newSingleThreadExecutor(factory);\n-            }\n-            this.executors = executors;\n-        }\n-\n-        @Override\n-        public void execute(Runnable task) {\n-            executors[next].execute(task);\n-            next = (next + 1) % executors.length;\n-        }\n-\n-        @Override\n-        public void close() {\n-            for (int i = 0; i < executors.length; i++) {\n-                executors[i].shutdown();\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        int iterations = args.length > 0 ? Integer.parseInt(args[0])  : 10_000;\n-\n-        final int ITERATIONS = iterations;\n-        final int SPIN_NANOS = 5000;\n-\n-        AtomicInteger count = new AtomicInteger();\n-\n-        try (RoundRobinExecutor executor = new RoundRobinExecutor()) {\n-            Thread thread = ThreadBuilders.virtualThreadBuilder(executor).start(() -> {\n-                while (count.incrementAndGet() < ITERATIONS) {\n-                    long start = System.nanoTime();\n-                    while ((System.nanoTime() - start) < SPIN_NANOS) {\n-                        Thread.onSpinWait();\n-                    }\n-                    LockSupport.parkNanos(500_000);\n-                }\n-            });\n-\n-            long start = System.nanoTime();\n-            while (thread.isAlive()) {\n-                StackTraceElement[] stackTrace = thread.getStackTrace();\n-                \/\/ printStackTrace(stackTrace);\n-                Thread.sleep(5);\n-                if ((System.nanoTime() - start) > 500_000_000) {\n-                    System.out.println(count.get());\n-                    start = System.nanoTime();\n-                }\n-            }\n-\n-            int countValue = count.get();\n-            if (countValue != ITERATIONS) {\n-                throw new RuntimeException(\"count = \" + countValue);\n-            }\n-        }\n-    }\n-\n-    static void printStackTrace(StackTraceElement[] stackTrace) {\n-        if (stackTrace == null) {\n-            System.out.println(\"NULL\");\n-        } else {\n-            for (var e : stackTrace) {\n-                System.out.println(\"\\t\" + e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALot.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test Thread.getStackTrace on virtual threads that are blocking or\n+ *     blocked on monitorenter\n+ * @requires vm.debug != true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm GetStackTraceALotWhenBlocking 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 50000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class GetStackTraceALotWhenBlocking {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ need at least two carriers\n+        VThreadRunner.ensureParallelism(2);\n+\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0]) : 100_000;\n+\n+        var done = new AtomicBoolean();\n+        var lock = new Object();\n+\n+        Runnable task = () -> {\n+            long count = 0L;\n+            while (!done.get()) {\n+                synchronized (lock) {\n+                    pause();\n+                }\n+                count++;\n+            }\n+            System.out.format(\"%s %s => %d loops%n\", Instant.now(), Thread.currentThread(), count);\n+        };\n+\n+        var thread1 = Thread.ofVirtual().start(task);\n+        var thread2 = Thread.ofVirtual().start(task);\n+        try {\n+            for (int i = 1; i <= iterations; i++) {\n+                if ((i % 10_000) == 0) {\n+                    System.out.format(\"%s => %d of %d%n\", Instant.now(), i, iterations);\n+                }\n+\n+                thread1.getStackTrace();\n+                pause();\n+                thread2.getStackTrace();\n+                pause();\n+            }\n+        } finally {\n+            done.set(true);\n+            thread1.join();\n+            thread2.join();\n+        }\n+    }\n+\n+    private static void pause() {\n+        if (ThreadLocalRandom.current().nextBoolean()) {\n+            Thread.onSpinWait();\n+        } else {\n+            Thread.yield();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Stress test asynchronous Thread.getStackTrace when parking\n+ * @requires vm.debug != true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main GetStackTraceALotWhenParking\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.debug == true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/timeout=300 GetStackTraceALotWhenParking 1000\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import jdk.test.lib.thread.VThreadScheduler;\n+\n+public class GetStackTraceALotWhenParking {\n+    static class RoundRobinExecutor implements Executor, AutoCloseable {\n+        private final ExecutorService[] executors;\n+        private int next;\n+\n+        RoundRobinExecutor() {\n+            var factory = Thread.ofPlatform().name(\"worker-\", 1).daemon(true).factory();\n+            var executors = new ExecutorService[2];\n+            for (int i = 0; i < executors.length; i++) {\n+                executors[i] = Executors.newSingleThreadExecutor(factory);\n+            }\n+            this.executors = executors;\n+        }\n+\n+        @Override\n+        public void execute(Runnable task) {\n+            executors[next].execute(task);\n+            next = (next + 1) % executors.length;\n+        }\n+\n+        @Override\n+        public void close() {\n+            for (int i = 0; i < executors.length; i++) {\n+                executors[i].shutdown();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0])  : 10_000;\n+\n+        final int ITERATIONS = iterations;\n+        final int SPIN_NANOS = 5000;\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        try (RoundRobinExecutor executor = new RoundRobinExecutor()) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(executor);\n+\n+            Thread thread = factory.newThread(() -> {\n+                while (count.incrementAndGet() < ITERATIONS) {\n+                    long start = System.nanoTime();\n+                    while ((System.nanoTime() - start) < SPIN_NANOS) {\n+                        Thread.onSpinWait();\n+                    }\n+                    LockSupport.parkNanos(500_000);\n+                }\n+            });\n+            thread.start();\n+\n+            long start = System.nanoTime();\n+            while (thread.isAlive()) {\n+                StackTraceElement[] stackTrace = thread.getStackTrace();\n+                \/\/ printStackTrace(stackTrace);\n+                Thread.sleep(5);\n+                if ((System.nanoTime() - start) > 500_000_000) {\n+                    System.out.format(\"%s => %d of %d%n\", Instant.now(), count.get(), ITERATIONS);\n+                    start = System.nanoTime();\n+                }\n+            }\n+\n+            int countValue = count.get();\n+            if (countValue != ITERATIONS) {\n+                throw new RuntimeException(\"count = \" + countValue);\n+            }\n+        }\n+    }\n+\n+    static void printStackTrace(StackTraceElement[] stackTrace) {\n+        if (stackTrace == null) {\n+            System.out.println(\"NULL\");\n+        } else {\n+            for (var e : stackTrace) {\n+                System.out.println(\"\\t\" + e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenParking.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm GetStackTraceALotWhenPinned 500000\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED GetStackTraceALotWhenPinned 500000\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenPinned 200000\n+ * @run main\/othervm\/timeout=300 --enable-native-access=ALL-UNNAMED GetStackTraceALotWhenPinned 200000\n@@ -82,1 +82,1 @@\n-        for (int i = 0; i < iterations; i++) {\n+        for (int i = 1; i <= iterations; i++) {\n@@ -90,2 +90,2 @@\n-            if ((currentTime - lastTimestamp) > 500) {\n-                System.out.format(\"%s %d remaining ...%n\", Instant.now(), (iterations - i));\n+            if (i == iterations || ((currentTime - lastTimestamp) > 500)) {\n+                System.out.format(\"%s => %d of %d%n\", Instant.now(), i, iterations);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -52,0 +52,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -53,1 +55,0 @@\n-        final int ITERATIONS = iterations;\n@@ -56,1 +57,0 @@\n-\n@@ -59,1 +59,1 @@\n-                while (count.incrementAndGet() < ITERATIONS) {\n+                while (count.incrementAndGet() < iterations) {\n@@ -68,1 +68,1 @@\n-            System.out.println(Instant.now() + \" => \" + count.get());\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -72,2 +72,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.time.Instant;\n@@ -94,1 +95,1 @@\n-            if (terminated)\n+            if (terminated) {\n@@ -96,1 +97,3 @@\n-            System.out.format(\"%d %s%n\", count1.get(), count2.get());\n+            }\n+            System.out.format(\"%s => T1 %d of %d, T2 %d of %d%n\",\n+                    Instant.now(), count1.get(), iterations, count2.get(), iterations);\n@@ -98,1 +101,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PingPong.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            throw new AssertionError(\"unexpected result!\");\n+            throw new RuntimeException(\"Expected \" + expected);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -47,0 +47,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -48,1 +50,0 @@\n-        final int ITERATIONS = iterations;\n@@ -51,1 +52,0 @@\n-\n@@ -53,1 +53,1 @@\n-            while (count.incrementAndGet() < ITERATIONS) {\n+            while (count.incrementAndGet() < iterations) {\n@@ -63,1 +63,1 @@\n-            System.out.println(Instant.now() + \" => \" + count.get());\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -67,2 +67,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Stress parking with CompletableFuture timed get\n- * @requires vm.debug != true & vm.continuations\n- * @run main\/othervm -Xmx1g TimedGet 100000\n- *\/\n-\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-public class TimedGet {\n-\n-    static final String RESULT = \"foo\";\n-\n-    public static void main(String... args) throws InterruptedException {\n-        int threadCount = 250_000;\n-        if (args.length > 0) {\n-            threadCount = Integer.parseInt(args[0]);\n-        }\n-\n-        \/\/ the count of the number of threads that complete successfully\n-        AtomicInteger completed = new AtomicInteger();\n-\n-        \/\/ list of futures and threads\n-        List<CompletableFuture<String>> futures = new ArrayList<>();\n-        List<Thread> threads = new ArrayList<>();\n-\n-        \/\/ start threads that wait with timeout for a result\n-        for (int i = 0; i < threadCount; i++) {\n-            var future = new CompletableFuture<String>();\n-            futures.add(future);\n-\n-            \/\/ start a thread that uses a timed-get to wait for the result\n-            Thread thread = Thread.ofVirtual().start(() -> {\n-                try {\n-                    String result = future.get(1, TimeUnit.DAYS);\n-                    if (!RESULT.equals(result)) {\n-                        throw new RuntimeException(\"result=\" + result);\n-                    }\n-                    completed.incrementAndGet();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            });\n-            threads.add(thread);\n-        }\n-\n-        \/\/ sets the result, which will unpark waiting threads\n-        futures.forEach(f -> f.complete(RESULT));\n-\n-        \/\/ wait for all threads to terminate\n-        long lastTimestamp = System.currentTimeMillis();\n-        int i = 0;\n-        while (i < threadCount) {\n-            Thread t = threads.get(i);\n-            boolean terminated;\n-            if (t.isAlive()) {\n-                terminated = t.join(Duration.ofMillis(500));\n-\n-                \/\/ print trace message so the output tracks progress\n-                long currentTime = System.currentTimeMillis();\n-                if ((currentTime - lastTimestamp) > 500) {\n-                    System.out.println(completed.get());\n-                    lastTimestamp = currentTime;\n-                }\n-            } else {\n-                terminated = true;\n-            }\n-            if (terminated) {\n-                i++;\n-            }\n-        }\n-\n-        \/\/ all tasks should have completed successfully\n-        int completedCount = completed.get();\n-        System.out.println(completedCount);\n-        if (completedCount != threadCount) {\n-            throw new RuntimeException(\"completed = \" + completedCount);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedGet.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=timeout\n+ * @summary Stress test timed-Object.wait\n+ * @run main\/othervm TimedWaitALot 200\n+ *\/\n+\n+\/*\n+ * @test id=timeout-notify\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Object.notify\n+ *     at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 200 true false\n+ *\/\n+\n+\/*\n+ * @test id=timeout-interrupt\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Thread.interrupt\n+ *     at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 200 false true\n+ *\/\n+\n+\/*\n+ * @test id=timeout-notify-interrupt\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Object.notify\n+ *     and Thread.interrupt at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 100 true true\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TimedWaitALot {\n+    public static void main(String[] args) throws Exception {\n+        int iterations = Integer.parseInt(args[0]);\n+        boolean notify = args.length >= 2 && \"true\".equals(args[1]);\n+        boolean interrupt = args.length >=3 && \"true\".equals(args[2]);\n+\n+        \/\/ test all timeouts concurrently\n+        int[] timeouts = { 10, 20, 50, 100 };\n+        for (int i = 1; i <= iterations; i++) {\n+            System.out.println(Instant.now() + \" => \" + i + \" of \" + iterations);\n+            test(notify, interrupt, timeouts);\n+        }\n+    }\n+\n+    \/**\n+     * Start a first virtual thread to wait in Object.wait(millis).\n+     * If {@code notify} is true, start a virtual thread to use Object.notifyAll at around\n+     * the same time that the timeout expires.\n+     * If {@code interrupt} is true, start virtual thread to interrupts the first virtual\n+     * thread at around the same time as the timeout expires.\n+     *\/\n+    static void test(boolean notify, boolean interrupt, int... timeouts) throws Exception {\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            for (int timeout : timeouts) {\n+                var queue = new SynchronousQueue<Thread>();\n+                var lock = new Object();\n+\n+                \/\/ virtual thread waits with Object.wait(timeout)\n+                executor.submit(() -> {\n+                    queue.put(Thread.currentThread());\n+                    synchronized (lock) {\n+                        lock.wait(timeout);\n+                    }\n+                    return null;\n+                });\n+\n+                \/\/ wait for thread to start\n+                Thread thread = queue.take();\n+\n+                \/\/ start thread to Object.notifyAll at around time that the timeout expires\n+                if (notify) {\n+                    if (ThreadLocalRandom.current().nextBoolean()) {\n+                        synchronized (lock) {\n+                            sleepLessThan(timeout);\n+                            lock.notifyAll();\n+                        }\n+                    } else {\n+                        sleepLessThan(timeout);\n+                        synchronized (lock) {\n+                            lock.notifyAll();\n+                        }\n+                    }\n+                }\n+\n+                \/\/ start thread to interrupt first thread at around time that the timeout expires\n+                if (interrupt) {\n+                    executor.submit(() -> {\n+                        sleepLessThan(timeout);\n+                        thread.interrupt();\n+                        return null;\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sleeps for just less than the given timeout, in millis.\n+     *\/\n+    private static void sleepLessThan(long timeout) throws InterruptedException {\n+        int delta = ThreadLocalRandom.current().nextInt(10);\n+        Thread.sleep(timeout - delta);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedWaitALot.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main YieldALot 350000\n+ * @run main YieldALot 500000\n@@ -38,0 +38,1 @@\n+import java.time.Instant;\n@@ -43,1 +44,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -46,0 +47,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -47,1 +50,0 @@\n-        final int ITERATIONS = iterations;\n@@ -50,1 +52,0 @@\n-\n@@ -52,1 +53,1 @@\n-            while (count.incrementAndGet() < ITERATIONS) {\n+            while (count.incrementAndGet() < iterations) {\n@@ -59,2 +60,2 @@\n-            terminated = thread.join(Duration.ofMillis(500));\n-            System.out.println(count.get());\n+            terminated = thread.join(Duration.ofSeconds(1));\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -64,2 +65,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -307,0 +308,5 @@\n+\n+    public void testMissingClass() {\n+        var mtd = MTD_void.insertParameterTypes(0, ClassDesc.of(\"does.not.exist.DoesNotExist\"));\n+        assertThrows(ReflectiveOperationException.class, () -> mtd.resolveConstantDesc(MethodHandles.publicLookup()));\n+    }\n","filename":"test\/jdk\/java\/lang\/constant\/MethodTypeDescTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static Throwable agentError;\n+    private static Throwable agentError; \/\/ to be accessed\/updated in a synchronized block\n@@ -40,1 +40,3 @@\n-    public static void checkErrors() {\n+    private static final String CLASS_TO_TRANSFORM = \"NativeMethodPrefixApp$Dummy\";\n+\n+    public static synchronized void checkErrors() {\n@@ -46,0 +48,10 @@\n+    private static synchronized void trackError(final Throwable t) {\n+        if (agentError == null) {\n+            agentError = t;\n+            return;\n+        }\n+        if (agentError != t) {\n+            agentError.addSuppressed(t);\n+        }\n+    }\n+\n@@ -51,0 +63,1 @@\n+        private final String nativeMethodPrefix;\n@@ -55,0 +68,1 @@\n+            this.nativeMethodPrefix = \"wrapped_\" + trname + \"_\";\n@@ -57,31 +71,3 @@\n-        public byte[]\n-        transform(\n-            ClassLoader loader,\n-            String className,\n-            Class<?> classBeingRedefined,\n-            ProtectionDomain    protectionDomain,\n-            byte[] classfileBuffer) {\n-            boolean redef = classBeingRedefined != null;\n-            System.out.println(trname + \": \" +\n-                               (redef? \"Retransforming \" : \"Loading \") + className);\n-            if (className != null) {\n-                try {\n-                    byte[] newcf = Instrumentor.instrFor(classfileBuffer)\n-                                   .addNativeMethodTrackingInjection(\n-                                        \"wrapped_\" + trname + \"_\", (name, h) -> {\n-                                            h.loadConstant(name);\n-                                            h.loadConstant(transformId);\n-                                            h.invokestatic(\n-                                                    CD_StringIdCallbackReporter,\n-                                                    \"tracker\",\n-                                                    MTD_void_String_int);\n-                                        })\n-                                   .apply();\n-                    \/*** debugging ...\n-                    if (newcf != null) {\n-                        String fname = trname + (redef?\"_redef\" : \"\") + \"\/\" + className;\n-                        System.err.println(\"dumping to: \" + fname);\n-                        write_buffer(fname + \"_before.class\", classfileBuffer);\n-                        write_buffer(fname + \"_instr.class\", newcf);\n-                    }\n-                    ***\/\n+        @Override\n+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n@@ -89,7 +75,6 @@\n-                    return redef? null : newcf;\n-                } catch (Throwable ex) {\n-                    if (agentError == null) {\n-                        agentError = ex;\n-                    }\n-                    System.err.println(\"ERROR: Injection failure: \" + ex);\n-                    ex.printStackTrace();\n+            try {\n+                \/\/ we only transform a specific application class\n+                if (!className.equals(CLASS_TO_TRANSFORM)) {\n+                    return null;\n+                }\n+                if (classBeingRedefined != null) {\n@@ -98,0 +83,16 @@\n+                \/\/ use a byte code generator which creates wrapper methods,\n+                \/\/ with a configured native method prefix, for each native method on the\n+                \/\/ class being transformed\n+                final Instrumentor byteCodeGenerator = Instrumentor.instrFor(classfileBuffer)\n+                        .addNativeMethodTrackingInjection(nativeMethodPrefix,\n+                                (name, cb) -> {\n+                                    cb.loadConstant(name);\n+                                    cb.loadConstant(transformId);\n+                                    cb.invokestatic(CD_StringIdCallbackReporter,\n+                                            \"tracker\", MTD_void_String_int);\n+                                });\n+                \/\/ generate the bytecode\n+                return byteCodeGenerator.apply();\n+            } catch (Throwable t) {\n+                trackError(t);\n+                return null;\n@@ -99,1 +100,0 @@\n-            return null;\n@@ -101,1 +101,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -27,2 +26,0 @@\n-import java.lang.management.*;\n-import java.util.zip.CRC32;\n@@ -37,1 +34,1 @@\n- * @bug 6263319\n+ * @bug 6263319 8334167\n@@ -40,2 +37,1 @@\n- * @modules java.management\n- *          java.instrument\n+ * @modules java.instrument\n@@ -47,2 +43,1 @@\n- * @run driver\/timeout=240 NativeMethodPrefixApp roleDriver\n- * @comment The test uses a higher timeout to prevent test timeouts noted in JDK-6528548\n+ * @run main\/native NativeMethodPrefixApp roleDriver\n@@ -52,5 +47,3 @@\n-    \/\/ This test is fragile like a golden file test.\n-    \/\/ It assumes that a specific non-native library method will call a specific\n-    \/\/ native method.  The below may need to be updated based on library changes.\n-    static String goldenNativeMethodName = \"getStartupTime\";\n-\n+    \/\/ we expect this native method, which is part of this test's application,\n+    \/\/ to be instrumented and invoked\n+    static String goldenNativeMethodName = \"fooBarNativeMethod\";\n@@ -58,0 +51,1 @@\n+    private static final String testLibraryPath = System.getProperty(\"test.nativepath\");\n@@ -72,0 +66,1 @@\n+            System.loadLibrary(\"NativeMethodPrefix\"); \/\/ load the native library\n@@ -77,1 +72,0 @@\n-        final String testClassesDir = System.getProperty(\"test.classes\");\n@@ -84,3 +78,1 @@\n-                \"\"\"\n-                + \"Boot-Class-Path: \" + testClassesDir.replace(File.separatorChar, '\/') + \"\/\"\n-                + \"\\n\";\n+                \"\"\";\n@@ -100,4 +92,1 @@\n-                \/\/ We disable CheckIntrinsic because the NativeMethodPrefixAgent modifies\n-                \/\/ the native method names, which then causes a failure in the VM check\n-                \/\/ for the presence of an intrinsic on a @IntrinsicCandidate native method.\n-                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-CheckIntrinsics\",\n+                \"-Djava.library.path=\" + testLibraryPath,\n@@ -113,8 +102,5 @@\n-\n-        java.lang.reflect.Array.getLength(new short[5]);\n-        RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n-        System.err.println(mxbean.getVmVendor());\n-        \/\/ Simply load a class containing an @IntrinsicCandidate on a native method\n-        \/\/ to exercise the VM code which verifies the presence of the intrinsic\n-        \/\/ implementation for that method.\n-        System.err.println(new CRC32());\n+        final long val = new Dummy().callSomeNativeMethod();\n+        if (val != 42) {\n+            throw new RuntimeException(\"unexpected return value \" + val\n+                    + \" from native method, expected 42\");\n+        }\n@@ -140,0 +126,9 @@\n+\n+    private static class Dummy {\n+\n+        private long callSomeNativeMethod() {\n+            return fooBarNativeMethod();\n+        }\n+\n+        private native long fooBarNativeMethod();\n+    }\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixApp.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8315575 8328137\n- * @summary test that records with invisible annotation can be retransformed\n- *\n- * @library \/test\/lib\n- * @run shell MakeJAR.sh retransformAgent\n- * @run main\/othervm -javaagent:retransformAgent.jar -Xlog:redefine+class=trace RetransformRecordAnnotation\n- * @run main\/othervm -javaagent:retransformAgent.jar -XX:+PreserveAllAnnotations -Xlog:redefine+class=trace RetransformRecordAnnotation\n- *\/\n-\n-import java.io.File;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.instrument.ClassFileTransformer;\n-import java.nio.file.Files;\n-import java.security.ProtectionDomain;\n-\n-public class RetransformRecordAnnotation extends AInstrumentationTestCase {\n-\n-    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface RuntimeTypeAnno {}\n-\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface RuntimeParamAnno {\n-        String s() default \"foo\";\n-    }\n-\n-    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n-    @Retention(RetentionPolicy.CLASS)\n-    @interface ClassTypeAnno {}\n-\n-    @Retention(RetentionPolicy.CLASS)\n-    @interface ClassParamAnno {\n-        String s() default \"bar\";\n-    }\n-\n-    @RuntimeTypeAnno\n-    @RuntimeParamAnno(s = \"1\")\n-    public record VisibleAnnos(@RuntimeTypeAnno @RuntimeParamAnno(s = \"2\") Object o, Object other) {\n-    }\n-\n-    @ClassTypeAnno\n-    @ClassParamAnno(s = \"3\")\n-    public record InvisibleAnnos(@ClassTypeAnno @ClassParamAnno(s = \"4\") Object o, Object other) {\n-    }\n-\n-    @RuntimeTypeAnno\n-    @RuntimeParamAnno(s = \"5\")\n-    @ClassTypeAnno\n-    @ClassParamAnno(s = \"6\")\n-    public record MixedAnnos(@RuntimeTypeAnno @RuntimeParamAnno(s = \"7\")\n-                             @ClassTypeAnno @ClassParamAnno(s = \"8\") Object o, Object other) {\n-    }\n-\n-    public static void main (String[] args) throws Throwable {\n-        ATestCaseScaffold test = new RetransformRecordAnnotation();\n-        test.beVerbose();\n-        test.runTest();\n-    }\n-\n-    private Transformer transformer;\n-\n-    public RetransformRecordAnnotation() throws Throwable {\n-        super(\"RetransformRecordAnnotation\");\n-    }\n-\n-    private void log(Object o) {\n-        System.out.println(String.valueOf(o));\n-    }\n-\n-    \/\/ Retransforms target class using provided class bytes;\n-    private void retransform(Class targetClass, byte[] classBytes) throws Throwable {\n-        transformer.prepare(targetClass, classBytes);\n-        fInst.retransformClasses(targetClass);\n-        assertTrue(targetClass.getName() + \" was not seen by transform()\",\n-                   transformer.getSeenClassBytes() != null);\n-    }\n-\n-    protected final void doRunTest() throws Throwable {\n-        transformer = new Transformer();\n-        fInst.addTransformer(transformer, true);\n-\n-        {\n-            log(\"Sanity: retransform to original class bytes\");\n-            retransform(InvisibleAnnos.class, loadClassBytes(InvisibleAnnos.class));\n-            log(\"\");\n-        }\n-\n-        \/\/ The following testcases use null as new class bytes (i.e. no transform is performed).\n-        \/\/ However, it is enough for testing purposes as the JvmtiClassFileReconstituter is still involved\n-        \/\/ in preparation of the initial class bytes.\n-        {\n-            log(\"Test: retransform VisibleAnnos to null\");\n-            retransform(VisibleAnnos.class, null);\n-            log(\"\");\n-        }\n-\n-        {\n-            log(\"Test: retransform InvisibleAnnos to null\");\n-            retransform(InvisibleAnnos.class, null);\n-            log(\"\");\n-        }\n-\n-        {\n-            log(\"Test: retransform MixedAnnos to null\");\n-            retransform(MixedAnnos.class, null);\n-            log(\"\");\n-        }\n-    }\n-\n-    private byte[] loadClassBytes(Class cls) throws Exception {\n-        String classFileName = cls.getName() + \".class\";\n-        File classFile = new File(System.getProperty(\"test.classes\", \".\"), classFileName);\n-        log(\"Reading test class from \" + classFile);\n-        byte[] classBytes = Files.readAllBytes(classFile.toPath());\n-        log(\"Read \" + classBytes.length + \" bytes.\");\n-        return classBytes;\n-    }\n-\n-    public class Transformer implements ClassFileTransformer {\n-        private String targetClassName;\n-        private byte[] seenClassBytes;\n-        private byte[] newClassBytes;\n-\n-        public Transformer() {\n-        }\n-\n-        \/\/ Prepares transformer for Instrumentation.retransformClasses.\n-        public void prepare(Class targetClass, byte[] classBytes) {\n-            targetClassName = targetClass.getName();\n-            newClassBytes = classBytes;\n-            seenClassBytes = null;\n-        }\n-\n-        byte[] getSeenClassBytes() {\n-            return seenClassBytes;\n-        }\n-\n-        public String toString() {\n-            return Transformer.this.getClass().getName();\n-        }\n-\n-        public byte[] transform(ClassLoader loader, String className,\n-            Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n-\n-            if (className.equals(targetClassName)) {\n-                log(this + \".transform() sees '\" + className\n-                        + \"' of \" + classfileBuffer.length + \" bytes.\");\n-                seenClassBytes = classfileBuffer;\n-                if (newClassBytes != null) {\n-                    log(this + \".transform() sets new classbytes for '\" + className\n-                            + \"' of \" + newClassBytes.length + \" bytes.\");\n-                }\n-                return newClassBytes;\n-            }\n-\n-            return null;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformRecordAnnotation.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -136,1 +136,1 @@\n-                    builder.withMethod(newName, mt, mm.flags().flagsMask(), mm::forEachElement);\n+                    builder.withMethod(newName, mt, mm.flags().flagsMask(), mm::forEach);\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jlong JNICALL\n+Java_NativeMethodPrefixApp_00024Dummy_fooBarNativeMethod(JNIEnv *env, jclass clazz)\n+{\n+    fprintf(stderr, \"native method called\\n\");\n+    return 42;\n+}\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    fprintf(stderr, \"native library loaded\\n\");\n+    return JNI_VERSION_1_1; \/\/ this native library needs the very basic JNI support\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/libNativeMethodPrefix.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-             cb.withMethod(\"nemo\", mm.methodTypeSymbol(), mm.flags().flagsMask(), mm::forEachElement);\n+             cb.withMethod(\"nemo\", mm.methodTypeSymbol(), mm.flags().flagsMask(), mm::forEach);\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/MHIllegalAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-        for (var inst : code.elements()) {\n+        for (var inst : code) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadMXBean.getLockedMonitors returns information about an object\n+ *    monitor lock entered with a synchronized native method or JNI MonitorEnter\n+ * @run junit\/othervm LockedMonitorInNative\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LockedMonitorInNative {\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        System.loadLibrary(\"LockedMonitorInNative\");\n+    }\n+\n+    \/**\n+     * Test ThreadMXBean.getLockedMonitors returns information about an object\n+     * monitor lock entered with a synchronized native method.\n+     *\/\n+    @Test\n+    void testSynchronizedNative() {\n+        Object lock = this;\n+        runWithSynchronizedNative(() -> {\n+            assertTrue(holdsLock(lock), \"Thread does not hold lock\");\n+        });\n+    }\n+\n+    \/**\n+     * Test ThreadMXBean.getLockedMonitors returns information about an object\n+     * monitor lock entered with JNI MonitorEnter.\n+     *\/\n+    @Test\n+    void testMonitorEnteredInNative() {\n+        var lock = new Object();\n+        runWithMonitorEnteredInNative(lock, () -> {\n+            assertTrue(holdsLock(lock), \"Thread does not hold lock\");\n+        });\n+    }\n+\n+    private boolean holdsLock(Object lock) {\n+        int hc = System.identityHashCode(lock);\n+        long tid = Thread.currentThread().threadId();\n+        ThreadInfo ti = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                .getThreadInfo(new long[] { tid }, true, true)[0];\n+        return Arrays.stream(ti.getLockedMonitors())\n+                .anyMatch(mi -> mi.getIdentityHashCode() == hc);\n+    }\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for \"this\".\n+     *\/\n+    private synchronized native void runWithSynchronizedNative(Runnable task);\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for the given\n+     * object. The monitor is entered with JNI MonitorEnter, and exited with JNI MonitorExit.\n+     *\/\n+    private native void runWithMonitorEnteredInNative(Object lock, Runnable task);\n+\n+    \/**\n+     * Called from native methods to run the given task.\n+     *\/\n+    private void run(Runnable task) {\n+        task.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/LockedMonitorInNative.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,2 @@\n+        \/\/ Account for threads using CPU for a few millis after their WAITING state is visible:\n+        goSleep(500);\n@@ -231,9 +233,0 @@\n-\/*************\n- * FIXME: Seems that on Solaris-sparc,\n- * It occasionally returns a different current thread user time > thread user time\n-            if (utime1 > utime2) {\n-                throw new RuntimeException(\"TEST FAILED: \" + getName() +\n-                    \" CurrentThreadUserTime = \" + utime1 +\n-                    \" > ThreadUserTime = \" + utime2);\n-            }\n-*\/\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/ThreadCpuTime.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,0 +50,1 @@\n+import java.util.concurrent.ThreadFactory;\n@@ -56,0 +55,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -57,0 +57,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -198,1 +199,1 @@\n-        assumeTrue(supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -207,0 +208,1 @@\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -209,1 +211,3 @@\n-            virtualThreadBuilder(scheduler).start(() -> { }).join();\n+            Thread thread = factory.newThread(() -> { });\n+            thread.start();\n+            thread.join();\n@@ -214,2 +218,4 @@\n-                \/\/ start virtual thread that blocks in a native method\n-                virtualThreadBuilder(scheduler).start(() -> {\n+                String selClassName = sel.getClass().getName();\n+\n+                \/\/ start virtual thread that blocks while pinned\n+                Thread vthread = factory.newThread(() -> {\n@@ -217,1 +223,1 @@\n-                        sel.select();\n+                        VThreadPinner.runPinned(sel::select);\n@@ -220,0 +226,6 @@\n+                vthread.start();\n+\n+                \/\/ wait for virtual thread to block in select\n+                while (!contains(vthread.getStackTrace(), selClassName)) {\n+                    Thread.sleep(20);\n+                }\n@@ -228,1 +240,1 @@\n-                assertFalse(contains(stack, \"java.nio.channels.Selector\"));\n+                assertFalse(contains(stack, selClassName));\n@@ -354,36 +366,0 @@\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     * @throws UnsupportedOperationException if there is no support for custom schedulers\n-     *\/\n-    private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Return true if custom schedulers are supported.\n-     *\/\n-    private static boolean supportsCustomScheduler() {\n-        try (var pool = Executors.newCachedThreadPool()) {\n-            try {\n-                virtualThreadBuilder(pool);\n-                return true;\n-            } catch (UnsupportedOperationException e) {\n-                return false;\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":21,"deletions":45,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_LockedMonitorInNative_runWithSynchronizedNative(JNIEnv *env, jobject obj, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_LockedMonitorInNative_runWithMonitorEnteredInNative(JNIEnv *env, jobject obj, jobject lock, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL && (*env)->MonitorEnter(env, lock) == 0) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+        (*env)->MonitorExit(env, lock);  \/\/ can be called with pending exception\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/libLockedMonitorInNative.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketException;\n+import java.net.StandardSocketOptions;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the APIs on java.net.ServerSocket throw expected exceptions\n+ *          when invoked on a closed ServerSocket\n+ * @run junit ClosedServerSocketTest\n+ *\/\n+public class ClosedServerSocketTest {\n+\n+    private static final InetAddress loopback = InetAddress.getLoopbackAddress();\n+    private static final InetSocketAddress loopbackEphemeral = new InetSocketAddress(loopback, 0);\n+\n+    \/**\n+     * Verifies that various operations that specify to throw an IOException on a\n+     * closed ServerSocket, do indeed throw it.\n+     *\/\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrows(IOException.class,\n+                    ss::accept,\n+                    \"accept() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.bind(loopbackEphemeral, 10),\n+                    \"bind(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    ss::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> ss.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw IOException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that specify to throw a SocketOperation on a\n+     * closed ServerSocket, do indeed throw it.\n+     *\/\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    ss::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> ss.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that aren't expected to throw an exception on a\n+     * closed ServerSocket, complete normally.\n+     *\/\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            \/\/ close and then invoke the operations on the ServerSocket\n+            ss.close();\n+            assertTrue(ss.isClosed(), \"ServerSocket isn't closed\");\n+            ss.getInetAddress();\n+            ss.getLocalPort();\n+            ss.getLocalSocketAddress();\n+            ss.isBound();\n+            ss.supportedOptions();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ServerSocket\/ClosedServerSocketTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.StandardSocketOptions;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the APIs on java.net.Socket throw expected exceptions\n+ *          when invoked on a closed socket\n+ * @run junit ClosedSocketTest\n+ *\/\n+public class ClosedSocketTest {\n+\n+    private static final InetAddress loopback = InetAddress.getLoopbackAddress();\n+    private static final InetSocketAddress loopbackEphemeral = new InetSocketAddress(loopback, 0);\n+\n+    \/**\n+     * Verifies that various operations that specify to throw an IOException on a closed socket,\n+     * do indeed throw it.\n+     *\/\n+    @Test\n+    public void testIOExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operation on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrows(IOException.class, () -> s.bind(loopbackEphemeral),\n+                    \"bind() when already closed didn't throw IOException\");\n+            \/\/ connect() will never get to the stage of attempting\n+            \/\/ a connection against this port\n+            final int dummyPort = 12345;\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort)),\n+                    \"connect() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.connect(new InetSocketAddress(loopback, dummyPort), 10),\n+                    \"connect(SocketAddress, int) when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    () -> s.getOption(StandardSocketOptions.SO_RCVBUF),\n+                    \"getOption() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::getOutputStream,\n+                    \"getOutputStream() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownInput,\n+                    \"shutdownInput() when already closed didn't throw IOException\");\n+            assertThrows(IOException.class,\n+                    s::shutdownOutput,\n+                    \"shutdownOutput() when already closed didn't throw IOException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that specify to throw a SocketOperation on a closed socket,\n+     * do indeed throw it.\n+     *\/\n+    @Test\n+    public void testSocketExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke the operations on the socket\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getKeepAlive,\n+                    \"getKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getOOBInline,\n+                    \"getOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReceiveBufferSize,\n+                    \"getReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getReuseAddress,\n+                    \"getReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSendBufferSize,\n+                    \"getSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoLinger,\n+                    \"getSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getSoTimeout,\n+                    \"getSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTcpNoDelay,\n+                    \"getTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    s::getTrafficClass,\n+                    \"getTrafficClass() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setKeepAlive(false),\n+                    \"setKeepAlive() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOOBInline(false),\n+                    \"setOOBInline() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setOption(StandardSocketOptions.SO_RCVBUF, 1024),\n+                    \"setOption() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReceiveBufferSize(1024),\n+                    \"setReceiveBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setReuseAddress(false),\n+                    \"setReuseAddress() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSendBufferSize(1024),\n+                    \"setSendBufferSize() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoLinger(false, 0),\n+                    \"setSoLinger() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setSoTimeout(1000),\n+                    \"setSoTimeout() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTcpNoDelay(false),\n+                    \"setTcpNoDelay() when already closed didn't throw SocketException\");\n+            assertThrowsExactly(SocketException.class,\n+                    () -> s.setTrafficClass(123),\n+                    \"setTrafficClass() when already closed didn't throw SocketException\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that various operations that aren't expected to throw an exception on a\n+     * closed socket, complete normally.\n+     *\/\n+    @Test\n+    public void testNoExceptionThrown() throws Exception {\n+        try (final Socket s = new Socket()) {\n+            \/\/ close and then invoke various operation on the socket and don't expect an exception\n+            s.close();\n+            assertTrue(s.isClosed(), \"socket isn't closed\");\n+            s.getInetAddress();\n+            s.getLocalAddress();\n+            s.getLocalPort();\n+            s.getLocalSocketAddress();\n+            s.getPort();\n+            s.getRemoteSocketAddress();\n+            s.isBound();\n+            s.isConnected();\n+            s.isInputShutdown();\n+            s.isOutputShutdown();\n+            s.supportedOptions();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ClosedSocketTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -158,0 +158,1 @@\n+        fifoFile.deleteOnExit();\n","filename":"test\/jdk\/java\/nio\/channels\/AsyncCloseAndInterrupt.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336339\n+ * @summary Race registration and selection key updates with Selector.close\n+ * @run junit RaceUpdatesAndClose\n+ *\/\n+\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Phaser;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+class RaceUpdatesAndClose {\n+    private static ExecutorService executor;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        executor = Executors.newFixedThreadPool(2);\n+    }\n+\n+    @AfterAll\n+    static void finish() {\n+        executor.shutdown();\n+    }\n+\n+    \/**\n+     * Race SelectableChannel.register and Selector.close.\n+     *\/\n+    @RepeatedTest(100)\n+    void raceRegisterAndClose() throws Exception {\n+        try (Selector sel = Selector.open();\n+             DatagramChannel dc = DatagramChannel.open()) {\n+\n+            dc.configureBlocking(false);\n+\n+            Phaser phaser = new Phaser(2);\n+\n+            \/\/ register\n+            var task1 = executor.submit(() -> {\n+                phaser.arriveAndAwaitAdvance();\n+                try {\n+                    dc.register(sel, SelectionKey.OP_READ);\n+                } catch (ClosedSelectorException e) { }\n+                return null;\n+            });\n+\n+            \/\/ close selector\n+            var task2 = executor.submit(() -> {\n+                phaser.arriveAndAwaitAdvance();\n+                sel.close();\n+                return null;\n+            });\n+\n+            task1.get();\n+            task2.get();\n+        }\n+    }\n+\n+    \/**\n+     * Race SelectionKey.interestOps and Selector.close.\n+     *\/\n+    @RepeatedTest(100)\n+    void raceInterestOpsAndClose() throws Exception {\n+        try (Selector sel = Selector.open();\n+             DatagramChannel dc = DatagramChannel.open()) {\n+\n+            dc.configureBlocking(false);\n+            SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+\n+            Phaser phaser = new Phaser(2);\n+\n+            \/\/ interestOps\n+            var task1 = executor.submit(() -> {\n+                phaser.arriveAndAwaitAdvance();\n+                try {\n+                    key.interestOps(0);\n+                } catch (CancelledKeyException e) { }\n+            });\n+\n+            \/\/ close selector\n+            var task2 = executor.submit(() -> {\n+                phaser.arriveAndAwaitAdvance();\n+                sel.close();\n+                return null;\n+            });\n+\n+            task1.get();\n+            task2.get();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/RaceUpdatesAndClose.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 4162583 7054918 8130181\n- * @library ..\/testlibrary\n+ * @bug 4162583 7054918 8130181 8028127\n+ * @library \/test\/lib ..\/testlibrary\n@@ -33,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -45,0 +47,1 @@\n+        var providersCountBefore = Security.getProviders().length;\n@@ -46,3 +49,4 @@\n-        for (int i=0; i < acc.length; i++)\n-            acc[i] = new AccessorThread(\"thread\"+i);\n-        for (int i=0; i < acc.length; i++)\n+        for (int i = 0; i < acc.length; i++) {\n+            acc[i] = new AccessorThread(\"thread\" + i);\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -50,1 +54,2 @@\n-        for (int i=0; i < acc.length; i++)\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -52,0 +57,3 @@\n+        }\n+        var providersCountAfter = Security.getProviders().length;\n+        Asserts.assertEquals(providersCountBefore, providersCountAfter);\n@@ -53,1 +61,0 @@\n-}\n@@ -55,1 +62,1 @@\n-class AccessorThread extends Thread {\n+    static class AccessorThread extends Thread {\n@@ -57,3 +64,3 @@\n-    public AccessorThread(String str) {\n-        super(str);\n-    }\n+        public AccessorThread(String str) {\n+            super(str);\n+        }\n@@ -61,4 +68,5 @@\n-    public void run() {\n-        Provider[] provs = new Provider[10];\n-        for (int i=0; i < provs.length; i++)\n-            provs[i] = new MyProvider(\"name\"+i, \"1\", \"test\");\n+        public void run() {\n+            Provider[] provs = new Provider[10];\n+            for (int i = 0; i < provs.length; i++) {\n+                provs[i] = new MyProvider(\"name\" + i, \"1\", \"test\");\n+            }\n@@ -66,4 +74,4 @@\n-        int rounds = 20;\n-        while (rounds-- > 0) {\n-            try {\n-                for (int i=0; i<provs.length; i++) {\n+            int rounds = 20;\n+            while (rounds-- > 0) {\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might install (>=0) or not (-1) if already installed\n@@ -71,0 +79,8 @@\n+                    Thread.yield();\n+                }\n+\n+                try {\n+                    Signature.getInstance(\"sigalg\");\n+                    Thread.yield();\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    \/\/ All providers may have been deregistered.  Ok.\n@@ -72,3 +88,5 @@\n-                Signature sig = Signature.getInstance(\"sigalg\");\n-                for (int i=0; i<provs.length; i++) {\n-                    Security.removeProvider(\"name\"+i);\n+\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might or might not remove (silent return)\n+                    Security.removeProvider(\"name\" + i);\n+                    Thread.yield();\n@@ -76,2 +94,7 @@\n-                provs = Security.getProviders();\n-            } catch (NoSuchAlgorithmException nsae) {\n+            } \/\/ while\n+        }\n+\n+        public static final class MyProvider extends Provider {\n+            public MyProvider(String name, String version, String info) {\n+                super(name, version, info);\n+                put(\"Signature.sigalg\", SigImpl.class.getName());\n@@ -79,0 +102,3 @@\n+        }\n+\n+        public static final class SigImpl extends Signature {\n@@ -80,3 +106,2 @@\n-            try {\n-                Thread.sleep(5);\n-            } catch (InterruptedException ie) {\n+            public SigImpl() {\n+                super(null);\n@@ -84,3 +109,0 @@\n-        } \/\/ while\n-    }\n-}\n@@ -88,4 +110,37 @@\n-class MyProvider extends Provider {\n-    public MyProvider(String name, String version, String info) {\n-        super(name, version, info);\n-        put(\"Signature.sigalg\", \"sigimpl\");\n+            @Override\n+            protected void engineInitVerify(PublicKey publicKey) {\n+            }\n+\n+            @Override\n+            protected void engineInitSign(PrivateKey privateKey) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte b) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte[] b, int off, int len) {\n+            }\n+\n+            @Override\n+            protected byte[] engineSign() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            protected boolean engineVerify(byte[] sigBytes) {\n+                return false;\n+            }\n+\n+            @Override\n+            protected void engineSetParameter(String param, Object value)\n+                    throws InvalidParameterException {\n+            }\n+\n+            @Override\n+            protected Object engineGetParameter(String param)\n+                    throws InvalidParameterException {\n+                return null;\n+            }\n+        }\n@@ -93,1 +148,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/SynchronizedAccess.java","additions":91,"deletions":36,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485 8333456\n+ * @bug 8327640 8331485 8333456 8335668\n@@ -131,0 +131,22 @@\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test\n+    public void integerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, localizeText(\".\"), 0);\n+        failParse(fmt, localizeText(\".0\"), 0);\n+        failParse(fmt, localizeText(\".55\"), 0);\n+    }\n+\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactIntegerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        fmt.setParseIntegerOnly(true);\n+        failParse(fmt, \".K\", 0);\n+        failParse(fmt, \".0K\", 0);\n+        failParse(fmt, \".55K\", 0);\n+    }\n+\n@@ -316,1 +338,5 @@\n-                Arguments.of(\"10,000,000\", 10000000d))\n+                Arguments.of(\"10,000,000\", 10000000d),\n+                \/\/ Smaller value cases (w\/ decimal)\n+                Arguments.of(\".1\", .1d),\n+                Arguments.of(\"1.1\", 1.1d),\n+                Arguments.of(\"11.1\", 11.1d))\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485 8333755\n+ * @bug 8327640 8331485 8333755 8335668\n@@ -206,0 +206,22 @@\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test\n+    public void integerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, localizeText(\".\"), 0);\n+        failParse(fmt, localizeText(\".0\"), 0);\n+        failParse(fmt, localizeText(\".55\"), 0);\n+    }\n+\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactIntegerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        fmt.setParseIntegerOnly(true);\n+        failParse(fmt, \".K\", 0);\n+        failParse(fmt, \".0K\", 0);\n+        failParse(fmt, \".55K\", 0);\n+    }\n+\n@@ -429,2 +451,2 @@\n-                Arguments.of(\".22a\", 3),\n-                Arguments.of(\".1a1\", 2),\n+                Arguments.of(\"1.22a\", 4),\n+                Arguments.of(\"1.1a1\", 3),\n@@ -456,1 +478,5 @@\n-                Arguments.of(\"10,000,000\", 10000000d))\n+                Arguments.of(\"10,000,000\", 10000000d),\n+                \/\/ Smaller value cases (w\/ decimal)\n+                Arguments.of(\".1\", .1d),\n+                Arguments.of(\"1.1\", 1.1d),\n+                Arguments.of(\"11.1\", 11.1d))\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary NPE IN RMIConnector.connect\n- * @bug 6984520\n- * @library \/java\/rmi\/testlibrary\n- * @modules java.management.rmi\n- *          java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- * @run clean RMIConnector_NPETest\n- * @run build TestLibrary RMID\n- * @run build RMIConnector_NPETest\n- * @run main RMIConnector_NPETest\n- *\/\n-import java.io.IOException;\n-import javax.management.*;\n-import javax.management.remote.rmi.*;\n-\n-public class RMIConnector_NPETest {\n-    public static void main(String argv[]) throws Exception {\n-        RMID rmid = RMID.createRMID();\n-        Exception failureCause = null;\n-        RMIConnector agent = null;\n-\n-        try {\n-            rmid.start();\n-            int rmidPort = rmid.getPort();\n-            MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-            RMIJRMPServerImpl rmiserver = new RMIJRMPServerImpl(rmidPort, null, null, null);\n-            rmiserver.setMBeanServer(mbs);\n-            agent = new RMIConnector(rmiserver, null);\n-            agent.connect();\n-        } catch (NullPointerException npe) {\n-            failureCause = npe;\n-        } catch (Exception e) {\n-            \/\/ OK\n-        } finally {\n-            if (agent != null) {\n-                try {\n-                    agent.close();\n-                } catch (IOException e) {\n-                    \/\/ ignore\n-                }\n-            }\n-            rmid.destroy();\n-        }\n-\n-        if (failureCause != null) {\n-            TestLibrary.bomb(\"Test failed\", failureCause);\n-        }\n-\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/RMIConnector_NPETest.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -44,1 +44,8 @@\n-                Test passes if the panel is as described, test fails otherwise.\"\"\";\n+                Test passes if the panel is as described, test fails otherwise.\n+\n+                Note: \"Preview\" title is not applicable for GTK Look and Feel.\"\"\";\n+\n+        \/\/ In case this test is run with GTK L&F, the preview panel title\n+        \/\/ is missing due to the \"ColorChooser.showPreviewPanelText\" property\n+        \/\/ which is set to \"Boolean.FALSE\" for GTK L&F. Test instructions are\n+        \/\/ modified to reflect that \"Preview\" title is not applicable for GTK L&F.\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6977726.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8326458\n+ * @bug 8326458 8155030\n@@ -29,1 +29,1 @@\n- * @modules java.desktop\/com.sun.java.swing.plaf.windows\n+ * @modules java.desktop\/sun.swing\n@@ -46,1 +46,1 @@\n-import com.sun.java.swing.plaf.windows.WindowsLookAndFeel;\n+import sun.swing.MnemonicHandler;\n@@ -96,1 +96,1 @@\n-        if (WindowsLookAndFeel.isMnemonicHidden()) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/TestMenuMnemonic.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8155030\n+ * @key headful\n+ * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @library \/javax\/swing\/regtesthelpers\n+ * @build Util\n+ * @summary Verifies if menu mnemonic toggle on Alt press in GTK and Aqua LAF\n+ * @run main TestMenuMnemonicLinuxAndMac\n+ *\/\n+\n+public class TestMenuMnemonicLinuxAndMac {\n+\n+    private static JFrame frame;\n+    private static JMenu fileMenu;\n+    private static volatile Rectangle fileMenuRect;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (laf.getName().contains(\"GTK\") || laf.getName().contains(\"Aqua\")) {\n+                System.out.println(\"Testing: \" + laf.getName());\n+                UIManager.setLookAndFeel(laf.getClassName());\n+                break;\n+            }\n+        }\n+\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(200);\n+\n+        try {\n+            SwingUtilities.invokeAndWait(TestMenuMnemonicLinuxAndMac::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                fileMenuRect = new Rectangle(fileMenu.getLocationOnScreen(),\n+                        fileMenu.getSize());\n+            });\n+\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.waitForIdle();\n+\n+            BufferedImage img1 = robot.createScreenCapture(fileMenuRect);\n+\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.waitForIdle();\n+\n+            BufferedImage img2 = robot.createScreenCapture(fileMenuRect);\n+\n+            if (Util.compareBufferedImages(img1, img2)) {\n+                try {\n+                    ImageIO.write(img1, \"png\", new File(\"Menu_With_Mnemonic.png\"));\n+                    ImageIO.write(img2, \"png\", new File(\"Menu_Without_Mnemonic.png\"));\n+                } catch (IOException ignored) {\n+                }\n+                throw new RuntimeException(\"Mismatch in mnemonic show\/hide on Alt press\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Menu Mnemonic Show\/Hide\");\n+        JMenuBar menuBar = new JMenuBar();\n+        fileMenu = new JMenu(\"File\");\n+        fileMenu.setMnemonic(KeyEvent.VK_F);\n+        JMenuItem item1 = new JMenuItem(\"Item-1\");\n+        JMenuItem item2 = new JMenuItem(\"Item-2\");\n+        fileMenu.add(item1);\n+        fileMenu.add(item2);\n+        menuBar.add(fileMenu);\n+        frame.setJMenuBar(menuBar);\n+        frame.setSize(250, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/TestMenuMnemonicLinuxAndMac.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4265389\n+ * @summary  Verifies JSplitPane support ComponentOrientation\n+ * @run main TestSplitPaneOrientationTest\n+ *\/\n+\n+import java.awt.ComponentOrientation;\n+import javax.swing.JButton;\n+import javax.swing.JSplitPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class TestSplitPaneOrientationTest {\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                setLookAndFeel(laf);\n+                JSplitPane jsp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                                                new JButton(\"Left\"), new JButton(\"Right\"));\n+                jsp.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);\n+                if (jsp.getRightComponent() instanceof JButton button) {\n+                    System.out.println(button.getText());\n+                    if (!button.getText().equals(\"Left\")) {\n+                        throw new RuntimeException(\"JSplitPane did not support ComponentOrientation\");\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JSplitPane\/TestSplitPaneOrientationTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-                ON ALL PLATFORMS\n+                ON ALL PLATFORMS except macos where pt.6 is not applicable\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/bug4666224.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4736093\n+ * @bug 4736093 8155030\n@@ -29,1 +29,1 @@\n- * @modules java.desktop\/com.sun.java.swing.plaf.windows\n+ * @modules java.desktop\/sun.swing\n@@ -45,1 +45,1 @@\n-import com.sun.java.swing.plaf.windows.WindowsLookAndFeel;\n+import sun.swing.MnemonicHandler;\n@@ -65,1 +65,1 @@\n-                if (winlaf && WindowsLookAndFeel.isMnemonicHidden()) {\n+                if (winlaf && MnemonicHandler.isMnemonicHidden()) {\n@@ -103,1 +103,1 @@\n-        if (expected != WindowsLookAndFeel.isMnemonicHidden()) {\n+        if (expected != MnemonicHandler.isMnemonicHidden()) {\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/bug4736093.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6921687 8079428\n+ * @bug 6921687 8079428 8155030\n@@ -30,1 +30,0 @@\n- * @author Semyon Sadetsky\n@@ -34,1 +33,1 @@\n- * @modules java.desktop\/com.sun.java.swing.plaf.windows\n+ * @modules java.desktop\/sun.swing\n@@ -48,0 +47,2 @@\n+import sun.swing.MnemonicHandler;\n+\n@@ -94,1 +95,1 @@\n-        if ((Boolean) lafClass.getMethod(\"isMnemonicHidden\").invoke(lafClass)) {\n+        if (MnemonicHandler.isMnemonicHidden()) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/windows\/6921687\/bug6921687.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.text.View;\n+import javax.swing.text.html.CSS;\n+\n+\/*\n+ * @test\n+ * @bug 8335967\n+ * @summary Tests 'text-decoration: none' is respected\n+ * @run main HTMLTextDecorationNone\n+ *\/\n+public final class HTMLTextDecorationNone {\n+    private static final String HTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+            <head>\n+                <meta charset=\"UTF-8\">\n+                <title>text-decoration: none (&lt;a&gt;)<\/title>\n+                <style>\n+                    a.none { text-decoration: none }\n+                <\/style>\n+            <\/head>\n+            <body>\n+            <p><a href=\"https:\/\/openjdk.org\/\">underlined<\/a><\/p>\n+            <p><a href=\"https:\/\/openjdk.org\/\" style=\"text-decoration: none\">not underlined<\/a><\/p>\n+            <p><a href=\"https:\/\/openjdk.org\/\" class=\"none\">not underlined<\/a><\/p>\n+            <p style=\"text-decoration: underline\"><a\n+                   href=\"https:\/\/openjdk.org\/\" style=\"text-decoration: none\">underlined?<\/a><\/p>\n+            <p style=\"text-decoration: underline\"><a\n+                   href=\"https:\/\/openjdk.org\/\" class=\"none\">underlined?<\/a><\/p>\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+\n+    private static final boolean[] underlined = {true, false, false, true, true};\n+\n+    public static void main(String[] args) {\n+        final JEditorPane html = new JEditorPane(\"text\/html\", HTML);\n+        html.setEditable(false);\n+\n+        final Dimension size = html.getPreferredSize();\n+        html.setSize(size);\n+\n+        BufferedImage image = new BufferedImage(size.width, size.height,\n+                                                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        \/\/ Paint the editor pane to ensure all views are created\n+        html.paint(g);\n+        g.dispose();\n+\n+        int errorCount = 0;\n+        String firstError = null;\n+\n+        System.out.println(\"----- Views -----\");\n+        final View bodyView = html.getUI()\n+                                  .getRootView(html)\n+                                  .getView(1)\n+                                  .getView(1);\n+        for (int i = 0; i < bodyView.getViewCount(); i++) {\n+            View pView = bodyView.getView(i);\n+            View contentView = getContentView(pView);\n+\n+            Object decorationAttr =\n+                    contentView.getAttributes()\n+                               .getAttribute(CSS.Attribute.TEXT_DECORATION);\n+            String decoration = decorationAttr == null\n+                                ? \"none\" : decorationAttr.toString();\n+\n+            System.out.println(i + \": \" + decoration);\n+            if (decoration.contains(\"underline\") != underlined[i]) {\n+                errorCount++;\n+                if (firstError == null) {\n+                    firstError = \"Line \" + i + \": \" + decoration + \" vs \"\n+                                 + (underlined[i] ? \"underline\" : \"none\");\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            saveImage(image);\n+            throw new RuntimeException(errorCount + \" error(s) found, \"\n+                                       + \"the first one: \" + firstError);\n+        }\n+    }\n+\n+    private static View getContentView(View parent) {\n+        View view = parent.getView(0);\n+        return view.getViewCount() > 0\n+               ? getContentView(view)\n+               : view;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html.png\"));\n+        } catch (IOException ignored) { }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLTextDecorationNone.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n@@ -37,0 +40,4 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -48,3 +55,14 @@\n-            case CLASS -> AccessFlags::ofClass;\n-            case METHOD -> AccessFlags::ofMethod;\n-            case FIELD -> AccessFlags::ofField;\n+            case CLASS -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb.withFlags(v));\n+                return ClassFile.of().parse(bytes).flags();\n+            };\n+            case METHOD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withMethod(\"test\", MTD_void, v & ACC_STATIC, mb -> mb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).methods().getFirst().flags();\n+            };\n+            case FIELD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withField(\"test\", CD_int, fb -> fb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).fields().getFirst().flags();\n+            };\n@@ -54,3 +72,15 @@\n-            case CLASS -> AccessFlags::ofClass;\n-            case METHOD -> AccessFlags::ofMethod;\n-            case FIELD -> AccessFlags::ofField;\n+            case CLASS -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb.withFlags(v));\n+                return ClassFile.of().parse(bytes).flags();\n+            };\n+            case METHOD -> v -> {\n+                boolean hasStatic = Arrays.stream(v).anyMatch(f -> f == AccessFlag.STATIC);\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withMethod(\"test\", MTD_void, hasStatic ? ACC_STATIC : 0, mb -> mb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).methods().getFirst().flags();\n+            };\n+            case FIELD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withField(\"test\", CD_int, fb -> fb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).fields().getFirst().flags();\n+            };\n@@ -75,5 +105,5 @@\n-        assertAll(\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofClass),\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofField),\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofMethod)\n-        );\n+        ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> {\n+            assertThrowsForInvalidFlagsUse(clb::withFlags);\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> assertThrowsForInvalidFlagsUse(mb::withFlags));\n+            clb.withField(\"test\", CD_int, fb -> assertThrowsForInvalidFlagsUse(fb::withFlags));\n+        });\n","filename":"test\/jdk\/jdk\/classfile\/AccessFlagsTest.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        byte[] newBytes = cc.build(cm.thisClass().asSymbol(), cb -> cm.forEachElement(cb));\n+        byte[] newBytes = cc.build(cm.thisClass().asSymbol(), cm::forEach);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,23 @@\n+\n+    @Test\n+    void testEquality() {\n+        assertEquals(Annotation.of(CD_Object), Annotation.of(ClassDesc.of(\"java.lang.Object\")));\n+        assertNotEquals(Annotation.of(CD_Object), Annotation.of(CD_String));\n+        assertEquals(Annotation.of(CD_Object, AnnotationElement.of(\"fly\", AnnotationValue.ofInt(5))),\n+                Annotation.of(CD_Object, AnnotationElement.ofInt(\"fly\", 5)));\n+        assertEquals(AnnotationElement.ofFloat(\"one\", 1.2F),\n+                AnnotationElement.ofFloat(\"one\", 1.2F));\n+        assertEquals(AnnotationElement.ofFloat(\"one\", 1.2F),\n+                AnnotationElement.of(\"one\", AnnotationValue.ofFloat(1.2F)));\n+        assertNotEquals(AnnotationElement.ofFloat(\"one\", 1.2F),\n+                AnnotationElement.ofFloat(\"two\", 1.2F));\n+        assertNotEquals(AnnotationElement.ofFloat(\"one\", 1.2F),\n+                AnnotationElement.ofFloat(\"one\", 2.1F));\n+        assertNotEquals(AnnotationElement.ofFloat(\"one\", 1.2F),\n+                AnnotationElement.ofDouble(\"one\", 1.2F));\n+        assertEquals(AnnotationValue.ofInt(23), AnnotationValue.ofInt(23));\n+        assertNotEquals(AnnotationValue.ofInt(23), AnnotationValue.ofInt(42));\n+        assertNotEquals(AnnotationValue.ofInt(23), AnnotationValue.ofLong(23));\n+        assertEquals(AnnotationValue.ofAnnotation(Annotation.of(CD_Object)),\n+                AnnotationValue.ofAnnotation(Annotation.of(Object.class.describeConstable().orElseThrow())));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationTest.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-            cc.build(classModel.thisClass().asSymbol(), cb -> classModel.forEachElement(cb));\n+            cc.build(classModel.thisClass().asSymbol(), classModel::forEach);\n","filename":"test\/jdk\/jdk\/classfile\/BasicBlockTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304837\n+ * @bug 8304837 8336585\n@@ -30,0 +30,7 @@\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.opentest4j.AssertionFailedError;\n+\n@@ -36,3 +43,1 @@\n-import org.junit.jupiter.api.Test;\n-import org.opentest4j.AssertionFailedError;\n-\n+import java.lang.classfile.constantpool.ConstantPoolException;\n@@ -70,0 +75,29 @@\n+\n+    @Test\n+    void testBadEntryTypeInList() {\n+        var cf = ClassFile.of();\n+\n+        \/\/ Craft an attribute list with index to badly typed attributes\n+        var bytes = cf.build(ClassDesc.of(\"Test\"), clb -> {\n+            var cp = clb.constantPool();\n+            var oneClassString = cp.utf8Entry(\"Test$Ape\");\n+            var oneClass = cp.classEntry(oneClassString);\n+            ((DirectClassBuilder) clb).writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.nestMembers()) {\n+                @Override\n+                public void writeBody(BufWriterImpl b) {\n+                    b.writeU2(2);\n+                    b.writeIndex(oneClass);\n+                    b.writeIndex(oneClassString);\n+                }\n+            });\n+        });\n+\n+        var nm = cf.parse(bytes).findAttribute(Attributes.nestMembers()).orElseThrow();\n+        Assertions.assertThrows(ConstantPoolException.class, () -> {\n+            int sum = 0;\n+            \/\/ this should throw CPE upon encountering non-ClassEntry\n+            for (var member : nm.nestMembers()) {\n+                sum += member.index();\n+            }\n+        });\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/BoundAttributeTest.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8337225\n@@ -29,0 +30,14 @@\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.StringEntry;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -30,3 +45,0 @@\n-\n-import static java.lang.constant.ConstantDescs.*;\n-\n@@ -34,0 +46,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -35,0 +48,1 @@\n+import java.net.URI;\n@@ -36,1 +50,0 @@\n-import java.nio.file.Paths;\n@@ -39,6 +52,0 @@\n-import java.lang.classfile.AccessFlags;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.TypeKind;\n@@ -46,1 +53,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -49,0 +55,7 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -54,2 +67,2 @@\n-    static final String testClassName = \"AdaptCodeTest$TestClass\";\n-    static final Path testClassPath = Paths.get(\"target\/test-classes\/\" + testClassName + \".class\");\n+    static final String testClassName = \"BuilderBlockTest$TestClass\";\n+    static final Path testClassPath = Path.of(URI.create(BuilderBlockTest.class.getResource(testClassName + \".class\").toString()));\n@@ -107,1 +120,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -126,1 +139,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -144,1 +157,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -164,1 +177,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -184,1 +197,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -203,1 +216,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -228,1 +241,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -308,0 +321,77 @@\n+\n+    private static final CodeTransform ALLOCATE_LOCAL_EXAMINER = CodeTransform.ofStateful(() -> new CodeTransform() {\n+        boolean foundItem = false;\n+\n+        @Override\n+        public void atStart(CodeBuilder builder) {\n+            foundItem = false;\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            cob.with(coe);\n+            if (coe instanceof ConstantInstruction.LoadConstantInstruction ldc\n+                    && ldc.constantEntry() instanceof StringEntry se\n+                    && se.utf8().equalsString(\"Output\")) {\n+                assertFalse(foundItem);\n+                foundItem = true;\n+                var i = cob.allocateLocal(TypeKind.IntType);\n+                assertEquals(7, i, \"Allocated new int slot\");\n+            }\n+        }\n+\n+        @Override\n+        public void atEnd(CodeBuilder builder) {\n+            assertTrue(foundItem);\n+        }\n+    });\n+\n+    \/\/ Test updating local variable slot management from\n+    \/\/ source code models in transformingCode;\n+    \/\/ CodeBuilder.transform(CodeModel, CodeTransform) is\n+    \/\/ not managed for now\n+    @Test\n+    void testAllocateLocalTransformingCodeAttribute() throws IOException {\n+        var cf = ClassFile.of();\n+        var code = cf.parse(testClassPath)\n+                .methods()\n+                .stream()\n+                .filter(f -> f.methodName().equalsString(\"work\"))\n+                .findFirst()\n+                .orElseThrow()\n+                .findAttribute(Attributes.code())\n+                .orElseThrow();\n+        ClassFile.of().build(ClassDesc.of(\"Foo\"), cb -> cb\n+                .withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), 0, mb -> mb\n+                        .transformCode(code, ALLOCATE_LOCAL_EXAMINER)));\n+    }\n+\n+    @Test\n+    void testAllocateLocalTransformingBufferedCode() throws IOException {\n+        var cf = ClassFile.of();\n+        var testClass = cf.parse(testClassPath);\n+        ClassTransform bufferingTransform = (clb, cle) -> {\n+            if (cle instanceof MethodModel mm && mm.methodName().equalsString(\"work\")) {\n+                clb.withMethodBody(mm.methodName(), mm.methodType(), mm.flags().flagsMask(), cob -> {\n+                    int d = cob.allocateLocal(TypeKind.IntType);\n+                    int e = cob.allocateLocal(TypeKind.IntType);\n+\n+                    assertEquals(5, d);\n+                    assertEquals(6, e);\n+\n+                    mm.code().ifPresent(code -> code.forEach(cob));\n+                });\n+            }\n+        };\n+        cf.transformClass(testClass, bufferingTransform.andThen(ClassTransform.transformingMethods(MethodTransform.transformingCode(ALLOCATE_LOCAL_EXAMINER))));\n+    }\n+\n+    public static class TestClass {\n+        public void work(int a, long b, int c) {\n+            int d = Math.addExact(a, 25);\n+            int e = Math.multiplyExact(d, c);\n+            System.out.println(\"Output\");\n+            System.out.println(e + b);\n+            throw new IllegalArgumentException(\"foo\");\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":111,"deletions":21,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -38,0 +37,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -46,1 +48,0 @@\n-import java.lang.reflect.AccessFlag;\n@@ -187,1 +188,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n@@ -218,1 +219,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n@@ -281,1 +282,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-                                mb.withCode(cob -> cm.forEachElement(cob));\n+                                mb.withCode(cm::forEach);\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.Util;\n@@ -40,0 +42,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -88,1 +91,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -96,1 +99,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -98,1 +101,1 @@\n-                        lv.writeTo(b);\n+                        Util.writeLocalVariable(b, lv);\n@@ -103,1 +106,1 @@\n-                    public void writeBody(BufWriter b) {\n+                    public void writeBody(BufWriterImpl b) {\n@@ -105,1 +108,1 @@\n-                        lvt.writeTo(b);\n+                        Util.writeLocalVariable(b, lvt);\n@@ -203,1 +206,1 @@\n-                classModel::forEachElement);\n+                classModel::forEach);\n@@ -223,1 +226,2 @@\n-                      + m1.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+                      + m1.code().map(CodeAttribute.class::cast)\n+                                 .map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n@@ -225,1 +229,2 @@\n-                      + m2.code().map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n+                      + m2.code().map(CodeAttribute.class::cast)\n+                                 .map(c -> c.maxLocals() + \" \/ \" + c.maxStack()).orElse(\"-\");\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -66,1 +67,1 @@\n-        var c = cc.parse(bytes).methods().get(0).code().get();\n+        var c = (CodeAttribute) cc.parse(bytes).methods().get(0).code().get();\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -41,1 +44,0 @@\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -59,1 +61,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655 8331940 8332486\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833\n@@ -31,1 +31,0 @@\n-import java.lang.classfile.BufWriter;\n@@ -42,0 +41,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -46,0 +46,2 @@\n+\n+import jdk.internal.classfile.impl.BufWriterImpl;\n@@ -132,1 +134,1 @@\n-                                public void writeBody(BufWriter b) {\n+                                public void writeBody(BufWriterImpl b) {\n@@ -157,1 +159,1 @@\n-                                public void writeBody(BufWriter b) {\n+                                public void writeBody(BufWriterImpl b) {\n@@ -170,0 +172,22 @@\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"TableSwitchClass\"), cb -> cb.withMethod(\n+                \"tableSwitchMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, mb ->\n+                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.code()) {\n+                                @Override\n+                                public void writeBody(BufWriterImpl b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(20);\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.TABLESWITCH.bytecode());\n+                                    b.writeU1(0); \/\/padding\n+                                    b.writeU2(0); \/\/padding\n+                                    b.writeInt(0); \/\/default\n+                                    b.writeInt(Integer.MIN_VALUE); \/\/low\n+                                    b.writeInt(Integer.MAX_VALUE - 4); \/\/high to jump back and cause infinite loop\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }})))).methods().get(0).code().get().elementList());\n@@ -193,0 +217,6 @@\n+\n+    @Test\n+    void testZeroHashCPEntry() {\n+        var cpb = ConstantPoolBuilder.of();\n+        cpb.intEntry(-cpb.intEntry(0).hashCode());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -38,1 +41,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -42,2 +44,0 @@\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.TypeKind;\n@@ -46,1 +46,0 @@\n-import jdk.internal.classfile.impl.DirectClassBuilder;\n@@ -78,1 +77,1 @@\n-            cl.methods().forEach(m -> ((DirectClassBuilder) cb).withMethod(m));\n+            cl.methods().forEach(cb::with);\n@@ -81,1 +80,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/LowAdaptTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.nio.file.Path;\n@@ -41,1 +40,0 @@\n-import java.util.Arrays;\n@@ -44,1 +42,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -61,0 +58,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -63,3 +62,0 @@\n-import static java.lang.classfile.Opcode.*;\n-import static java.lang.classfile.Opcode.INVOKEVIRTUAL;\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -91,1 +87,1 @@\n-        co.forEachElement(e -> {\n+        co.forEach(e -> {\n@@ -131,1 +127,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -201,1 +197,1 @@\n-        co.forEachElement(e -> {\n+        co.forEach(e -> {\n@@ -246,1 +242,1 @@\n-                          ClassFile.ACC_PUBLIC,\n+                          ACC_PUBLIC,\n@@ -307,1 +303,1 @@\n-        c.forEachElement(e -> {\n+        c.forEach(e -> {\n@@ -309,1 +305,1 @@\n-                m.forEachElement(el -> {\n+                m.forEach(el -> {\n@@ -311,1 +307,1 @@\n-                        cm.forEachElement(elem -> {\n+                        cm.forEach(elem -> {\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.impl.ChainedClassBuilder;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8336777\n+ * @summary Testing MethodBuilder correctly rejecting resetting the static\n+ *          access flag.\n+ * @run junit MethodBuilderStaticFlagTest\n+ *\/\n+class MethodBuilderStaticFlagTest {\n+\n+    void testClassBuilder(ClassBuilder clb) {\n+        clb.withMethod(\"staticToStatic\", MTD_void, ACC_STATIC, mb -> mb.withFlags(ACC_PUBLIC | ACC_STATIC));\n+        assertThrows(IllegalArgumentException.class, () ->\n+                clb.withMethod(\"staticToInstance\", MTD_void, ACC_STATIC, mb -> mb.withFlags(ACC_PUBLIC)));\n+        assertThrows(IllegalArgumentException.class, () ->\n+                clb.withMethod(\"instanceToStatic\", MTD_void, 0, mb -> mb.withFlags(ACC_PUBLIC | ACC_STATIC)));\n+        clb.withMethod(\"instanceToInstance\", MTD_void, 0, mb -> mb.withFlags(ACC_PUBLIC));\n+    }\n+\n+    @Test\n+    void testDirectBuilder() {\n+        ClassFile.of().build(ClassDesc.of(\"C1\"), this::testClassBuilder);\n+    }\n+\n+    @Test\n+    void testBufferedBuilder() {\n+        var cf = ClassFile.of();\n+        var bytes = cf.build(ClassDesc.of(\"C2\"), _ -> {});\n+        var cm = cf.parse(bytes);\n+\n+        cf.transformClass(cm, new ClassTransform() {\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                builder.with(element);\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder clb) {\n+                assertInstanceOf(ChainedClassBuilder.class, clb);\n+                testClassBuilder(clb);\n+            }\n+        }.andThen(ClassBuilder::with));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/MethodBuilderStaticFlagTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -34,1 +37,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -41,1 +43,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -77,1 +78,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        if (e instanceof CompoundElement ce) ce.forEachElement(ee -> testNoUnstable(path, (ClassFileElement)ee));\n+        if (e instanceof CompoundElement ce) ce.forEach(ee -> testNoUnstable(path, (ClassFileElement)ee));\n","filename":"test\/jdk\/jdk\/classfile\/OptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -273,1 +274,1 @@\n-                                                   classModel.forEachElement(cb);\n+                                                   classModel.forEach(cb);\n@@ -332,1 +333,1 @@\n-            var code = method.code().orElseThrow();\n+            var code = (CodeAttribute) method.code().orElseThrow();\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -32,0 +31,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -41,3 +43,0 @@\n-import static java.lang.reflect.AccessFlag.PUBLIC;\n-import static java.lang.reflect.AccessFlag.STATIC;\n-\n@@ -51,1 +50,1 @@\n-            cb.withMethodBody(\"m\", mtd, AccessFlags.ofMethod(PUBLIC, STATIC).flagsMask(), xb -> {\n+            cb.withMethodBody(\"m\", mtd, ACC_PUBLIC | ACC_STATIC, xb -> {\n","filename":"test\/jdk\/jdk\/classfile\/SwapTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        cm.forEachElement((ce) -> {\n+        cm.forEach((ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010\n+ * @bug 8336010 8336588\n@@ -30,0 +30,1 @@\n+\n@@ -31,0 +32,4 @@\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n@@ -33,0 +38,2 @@\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.CodeTransform;\n@@ -36,0 +43,1 @@\n+import java.lang.classfile.MethodModel;\n@@ -38,0 +46,1 @@\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -46,9 +55,0 @@\n-\n-import helpers.ByteArrayClassLoader;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.instruction.ConstantInstruction;\n@@ -58,0 +58,1 @@\n+import helpers.ByteArrayClassLoader;\n@@ -292,0 +293,39 @@\n+    @Test\n+    void testStateOrder() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+\n+        int[] counter = {0};\n+\n+        enum TransformState { START, ONGOING, ENDED }\n+\n+        var ct = ClassTransform.ofStateful(() -> new ClassTransform() {\n+            TransformState state = TransformState.START;\n+\n+            @Override\n+            public void atStart(ClassBuilder builder) {\n+                assertSame(TransformState.START, state);\n+                builder.withField(\"f\" + counter[0]++, CD_int, 0);\n+                state = TransformState.ONGOING;\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                assertSame(TransformState.ONGOING, state);\n+                builder.withField(\"f\" + counter[0]++, CD_int, 0);\n+                state = TransformState.ENDED;\n+            }\n+\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                assertSame(TransformState.ONGOING, state);\n+                builder.with(element);\n+            }\n+        });\n+\n+        cf.transformClass(cm, ct);\n+        cf.transformClass(cm, ct.andThen(ct));\n+        cf.transformClass(cm, ct.andThen(ct).andThen(ct));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8333812\n@@ -49,0 +50,4 @@\n+\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n@@ -50,1 +55,1 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -82,1 +87,1 @@\n-                                mb.withCode(cob -> cm.forEachElement(cob));\n+                                mb.withCode(cob -> cm.forEach(cob));\n@@ -97,0 +102,21 @@\n+    @Test\n+    void testInvalidAttrLocation() {\n+        var cc = ClassFile.of();\n+        var bytes = cc.build(ClassDesc.of(\"InvalidAttrLocationClass\"), cb ->\n+            ((DirectClassBuilder)cb).writeAttribute(new UnboundAttribute.AdHocAttribute<LocalVariableTableAttribute>(Attributes.localVariableTable()) {\n+                @Override\n+                public void writeBody(BufWriterImpl b) {\n+                    b.writeU2(0);\n+                }\n+            }));\n+        assertTrue(cc.verify(bytes).stream().anyMatch(e -> e.getMessage().contains(\"Invalid LocalVariableTable attribute location\")));\n+    }\n+\n+    @Test\n+    void testInvalidClassNameEntry() {\n+        var cc = ClassFile.of();\n+        var bytes = cc.parse(new byte[]{(byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE,\n+            0, 0, 0, 0, 0, 2, ClassFile.TAG_INTEGER, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});\n+        assertTrue(cc.verify(bytes).stream().anyMatch(e -> e.getMessage().contains(\"expected ClassEntry\")));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -36,1 +35,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -42,0 +40,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -43,4 +43,0 @@\n-import static java.lang.classfile.Opcode.*;\n-import static java.lang.classfile.TypeKind.IntType;\n-import static java.lang.classfile.TypeKind.ReferenceType;\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -64,1 +60,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -105,1 +101,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/WriteTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-                case AccessFlags a -> fb.with(AccessFlags.ofField(a.flagsMask() & ~ClassFile.ACC_PUBLIC & ~ClassFile.ACC_PROTECTED));\n+                case AccessFlags a -> fb.withFlags(a.flagsMask() & ~ClassFile.ACC_PUBLIC & ~ClassFile.ACC_PROTECTED);\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                                                com.forEachElement(cob4::with);\n+                                                com.forEach(cob4::with);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-                                xm.forEachElement(new Consumer<>() {\n+                                xm.forEach(new Consumer<>() {\n@@ -273,1 +273,1 @@\n-                                       cm.forEachElement(cb);\n+                                       cm.forEach(cb);\n@@ -304,1 +304,1 @@\n-                                       cm.forEachElement(element -> {\n+                                       cm.forEach(element -> {\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,1 +429,1 @@\n-            checkDuration(startMillis, 1900, 4000);\n+            checkDuration(startMillis, 1900, 20_000);\n@@ -456,1 +456,1 @@\n-                    checkDuration(startMillis, 1900, 4000);\n+                    checkDuration(startMillis, 1900, 20_000);\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+            default:\n+                throw new RuntimeException(\"unknown args: \" + args[0] + \" for MetricsMemoryTester\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-            testMemoryFailCount(\"64m\");\n+            testMemoryFailCount(\"128m\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.vm.TranslatedException;\n@@ -103,0 +104,9 @@\n+        } catch (TranslatedException decoded) {\n+            Assert.assertEquals(decoded.getCause().getClass(), OutOfMemoryError.class);\n+        } catch (Throwable decoded) {\n+            throw new AssertionError(\"unexpected exception: \" + decoded);\n+        }\n+\n+        try {\n+            VMSupport.decodeAndThrowThrowable(5, 0L, true, false);\n+            throw new AssertionError(\"expected decodeAndThrowThrowable to throw an exception\");\n@@ -145,1 +155,1 @@\n-                        assertThrowableEquals(throwable, decoded);\n+                        assertThrowableEquals(throwable, decoded.getCause());\n@@ -155,1 +165,3 @@\n-    private static void assertThrowableEquals(Throwable original, Throwable decoded) {\n+    private static void assertThrowableEquals(Throwable originalIn, Throwable decodedIn) {\n+        Throwable original = originalIn;\n+        Throwable decoded = decodedIn;\n@@ -160,2 +172,2 @@\n-                    Assert.assertEquals(decoded.getClass().getName(), \"jdk.internal.vm.TranslatedException\");\n-                    Assert.assertEquals(decoded.toString(), \"jdk.internal.vm.TranslatedException[jdk.internal.vm.test.TestTranslatedException$Untranslatable]: test exception\");\n+                    Assert.assertEquals(decoded.getClass().getName(), \"java.lang.InternalError\");\n+                    Assert.assertEquals(decoded.toString(), \"java.lang.InternalError: test exception [jdk.internal.vm.test.TestTranslatedException$Untranslatable]\");\n@@ -185,1 +197,1 @@\n-            original.printStackTrace(System.err);\n+            originalIn.printStackTrace(System.err);\n@@ -188,1 +200,1 @@\n-            original.printStackTrace(System.err);\n+            decodedIn.printStackTrace(System.err);\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.settings;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+import jdk.jfr.SettingDescriptor;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Tests that methods on all SettingControls have expected behavior.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.api.settings.TestSettingControl\n+ *\/\n+public class TestSettingControl {\n+    record SettingTest(String setting, String defaultValue, String event, List<String> exampleValues) {\n+        public String eventSettingName() {\n+            return event + \"#\" + setting;\n+        }\n+    }\n+\n+    \/\/ Example values should be listed in precedence order with the lowest precedence first.\n+    static List<SettingTest> SETTING_TESTS = List.of(\n+        new SettingTest(\"enabled\", \"false\", \"jdk.JavaMonitorWait\",List.of(\"false\", \"true\")),\n+        new SettingTest(\"stackTrace\", \"true\", \"jdk.JavaMonitorWait\", List.of(\"false\", \"true\")),\n+        new SettingTest(\"threshold\", \"0 ns\", \"jdk.JavaMonitorWait\", List.of(\"infinity\", \"10 ms\", \"0 ns\")),\n+        new SettingTest(\"level\", \"forRemoval\", \"jdk.DeprecatedInvocation\", List.of(\"off\", \"forRemoval\")),\n+        new SettingTest(\"period\", \"everyChunk\", \"jdk.ExceptionStatistics\", List.of(\"everyChunk\", \"60 s\", \"1 s\")),\n+        new SettingTest(\"cutoff\", \"infinity\", \"jdk.OldObjectSample\", List.of(\"0 ms\", \"1 s\", \"infinity\")),\n+        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\"))\n+    );\n+\n+    public static void main(String... args) throws Exception {\n+        testTesting();\n+        testDefault();\n+        testDefaultWithInvalid();\n+        testPrecedence();\n+        testPrecedenceWithInvalid();\n+    }\n+\n+    \/\/ Ensure that all known SettingControl\/types are tested at least once\n+    private static void testTesting() throws Exception {\n+        Set<String> foundSettings = new HashSet<>();\n+        for (EventType eventType : allEventTypes()) {\n+            for (SettingDescriptor s : eventType.getSettingDescriptors()) {\n+                foundSettings.add(s.getName());\n+            }\n+        }\n+        for (SettingTest st : SETTING_TESTS) {\n+            foundSettings.remove(st.setting());\n+        }\n+        if (!foundSettings.isEmpty()) {\n+            throw new Exception(\"All event SettingControls should be tested. Missing test for \" + foundSettings);\n+        }\n+    }\n+\n+    \/\/ Ensure that the default values for all SettingControls are correct\n+    private static void testDefault() throws Exception {\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            SettingDescriptor s = findSettingDescriptor(settingTest);\n+            if (!settingTest.defaultValue().equals(s.getDefaultValue())) {\n+                String message = \"Incorrect default value \" + quote(s.getDefaultValue());\n+                message += \" for setting \" + settingTest.eventSettingName() + \". \";\n+                message += \"Expected \" + quote(settingTest.defaultValue());\n+                throw new Exception(message);\n+            }\n+        }\n+    }\n+\n+    \/\/ Ensure that default settings are used if an invalid setting is specified.\n+    private static void testDefaultWithInvalid() throws Exception {\n+        Map<String, String> settings = createEnabledMap();\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            settings.put(settingTest.eventSettingName(), \"%#&2672g\");\n+        }\n+        Map<String, String> result = check(\"testDefaultWithInvalid\", List.of(settings));\n+        for (var entry : new ArrayList<>(result.entrySet())) {\n+            String key = entry.getKey();\n+            String removed = result.remove(key);\n+            if (removed == null) {\n+                throw new Exception(\"Expected setting \" + quote(key) + \" to exist\");\n+            }\n+            String setting = key.substring(key.indexOf(\"#\") + 1);\n+            SettingTest st = findSettingTest(setting);\n+            if (st == null) {\n+                throw new Exception(\"Found unexpected setting \" + quote(key));\n+            }\n+            if (!removed.equals(st.defaultValue())) {\n+                String message = \"Expected default value \" + quote(st.defaultValue());\n+                message += \" for setting \" + quote(setting) + \" when\";\n+                message += \" an invalid settings value was specified\";\n+                throw new Exception(message);\n+            }\n+        }\n+        if (!result.isEmpty()) {\n+            throw new Exception(\"Found unexpected setting when testing preserved default\");\n+        }\n+    }\n+\n+    \/\/ Only enabled events will use settings\n+    private static Map<String, String> createEnabledMap() {\n+        Map<String, String> settings = new TreeMap<>();\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            settings.put(settingTest.event + \"#enabled\", \"true\");\n+        }\n+        return settings;\n+    }\n+\n+    \/\/ Ensure that precedence are respected when multiple settings are specified\n+    private static void testPrecedence() throws Exception {\n+        testPrecedence(\"testPrecedence\");\n+    }\n+\n+    \/\/ Ensure that precedence are respected when an incorrect setting is used\n+    private static void testPrecedenceWithInvalid() throws Exception {\n+        testPrecedence(\"testPrecedenceWithInvalid\");\n+    }\n+\n+    \/\/ * * * HELPER METHODS * * *\n+\n+    private static void testPrecedence(String testName) throws Exception {\n+        List<Map<String, String>> settingsList = new ArrayList<>();\n+        int maxExamples = 0;\n+        for (SettingTest t : SETTING_TESTS) {\n+            maxExamples = Math.max(t.exampleValues().size(), maxExamples);\n+        }\n+        for (int i = 0; i < maxExamples; i++) {\n+            Map<String, String> settings = createEnabledMap();\n+            for (SettingTest settingTest : SETTING_TESTS) {\n+                List<String> examples = settingTest.exampleValues();\n+                String name = settingTest.eventSettingName();\n+                if (i < examples.size()) {\n+                    settings.put(name, examples.get(i));\n+                }\n+                \/\/ Insert the invalid setting first\n+                if (testName.contains(\"Invalid\") && i == 0) {\n+                    settings.put(name, \"%#&2672g\");\n+                }\n+            }\n+            settingsList.add(settings);\n+        }\n+        Map<String, String> results = check(testName, settingsList);\n+        Map<String, String> reversed = check(testName + \"-reversed\", settingsList.reversed());\n+        if (!reversed.equals(results)) {\n+            throw new Exception(\"Active settings should not depend on the order event settings are applied\");\n+        }\n+        for (SettingTest t : SETTING_TESTS) {\n+            String expected = t.exampleValues().get(t.exampleValues().size() - 1);\n+            String found = results.get(t.eventSettingName());\n+            if (!expected.equals(found)) {\n+                throw new Exception(\"Expected \" + expected + \" to be used with setting \" + quote(t.setting()) + \", not \" + quote(found));\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> check(String testName, List<Map<String, String>> settingsList) throws Exception {\n+        System.out.println(\"*** Check for \" + testName + \" ****\");\n+        System.out.println(\"Input:\");\n+        int index = 0;\n+        for (var settings : settingsList) {\n+            System.out.println(\"Setting[\" + index + \"] = {\");\n+            for (var e : settings.entrySet()) {\n+                System.out.println(\"  \" + e.getKey() + \"=\" + e.getValue());\n+            }\n+            System.out.println(\"}\");\n+            index++;\n+        }\n+        int settingsCount = settingsList.size();\n+\n+        \/\/ Start a recording for each settings\n+        List<Recording> recordings = new ArrayList<>();\n+        for (int i = 0; i < settingsCount; i++) {\n+            Recording r = new Recording();\n+            Map<String, String> settings = settingsList.get(i);\n+            settings.put(\"jdk.ActiveSetting#enabled\", \"true\");\n+            r.setSettings(settings);\n+            r.start();\n+            recordings.add(r);\n+        }\n+\n+        \/\/ Stop all recordings\n+        for (Recording r : recordings) {\n+            r.stop();\n+        }\n+\n+        \/\/ Dump the innermost recording\n+        Path p = Path.of(\"recording.jfr\");\n+        Recording inner = recordings.get(settingsCount - 1);\n+        inner.dump(p);\n+\n+        \/\/ Close all recordings\n+        for (Recording r : recordings) {\n+            r.close();\n+        }\n+        System.out.println(\"Result:\");\n+        Map<String, String> r = lastSettings(p);\n+        for (var e : r.entrySet()) {\n+            System.out.println(e.getKey() + \"=\" + e.getValue());\n+        }\n+        System.out.println(\"*************\");\n+        System.out.println();\n+        Files.delete(p);\n+        return r;\n+    }\n+\n+    private static SettingTest findSettingTest(String name) throws Exception {\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            if (name.equals(settingTest.setting())) {\n+                return settingTest;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Map<String, String> lastSettings(Path p) throws Exception {\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+        Instant timestamp = findLastActiveSetting(events);\n+        Map<String, String> lastInnerMostSettings = new HashMap<>();\n+        for (SettingTest t : SETTING_TESTS) {\n+            long id = eventTypeNameToId(t.event());\n+            for (RecordedEvent event : events) {\n+                if (event.getEventType().getName().equals(\"jdk.ActiveSetting\")) {\n+                    if (event.getStartTime().equals(timestamp) && id == event.getLong(\"id\")) {\n+                        String name = event.getString(\"name\");\n+                        String value = event.getString(\"value\");\n+                        if (t.setting.equals(name)) {\n+                            String fullName = t.event() + \"#\" + name;\n+                            String previous = lastInnerMostSettings.put(fullName, value);\n+                            if (previous != null) {\n+                                throw new Exception(\"Expected only one ActiveSetting event per event setting\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return lastInnerMostSettings;\n+    }\n+\n+    private static Instant findLastActiveSetting(List<RecordedEvent> events) {\n+        Instant lastTimestamp = null;\n+        for (RecordedEvent event : events) {\n+            if (event.getEventType().getName().equals(\"jdk.ActiveSetting\")) {\n+                Instant t = event.getStartTime();\n+                if (lastTimestamp == null || t.isBefore(lastTimestamp)) {\n+                    lastTimestamp = t;\n+                }\n+            }\n+        }\n+        return lastTimestamp;\n+    }\n+\n+    private static long eventTypeNameToId(String name) throws Exception {\n+        for (EventType eventType : allEventTypes()) {\n+            if (eventType.getName().equals(name)) {\n+                return eventType.getId();\n+            }\n+        }\n+        throw new Exception(\"Could not find event type with name \" + name);\n+    }\n+\n+    private static SettingDescriptor findSettingDescriptor(SettingTest settingTest) throws Exception {\n+        for (EventType eventType : allEventTypes()) {\n+            if (eventType.getName().equals(settingTest.event())) {\n+                for (SettingDescriptor s : eventType.getSettingDescriptors()) {\n+                    if (settingTest.setting().equals(s.getName())) {\n+                        return s;\n+                    }\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find setting with name \" + settingTest.event() + \"#\" + settingTest.setting());\n+    }\n+\n+    private static List<EventType> allEventTypes() {\n+        return FlightRecorder.getFlightRecorder().getEventTypes();\n+    }\n+\n+    private static String quote(String text) {\n+        return \"'\" + text + \"'\";\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestSettingControl.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -393,1 +393,1 @@\n-                for (var ce : com.elements()) {\n+                for (var ce : com) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerInlining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseSerialGC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestDefNewAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseSerialGC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestDefNewAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestDefNewAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseG1GC -Xlog:gc* -Xmx64M -XX:InitiatingHeapOccupancyPercent=100 jdk.jfr.event.gc.stacktrace.TestG1HumongousAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseG1GC -Xlog:gc* -Xmx64M -XX:InitiatingHeapOccupancyPercent=100\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestG1HumongousAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestG1HumongousAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:MaxNewSize=10M -Xmx128M -XX:+UseG1GC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestG1OldAllocationPendingStackTrace\n+ * @run main\/othervm -XX:MaxNewSize=10M -Xmx128M -XX:+UseG1GC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestG1OldAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestG1OldAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseG1GC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestG1YoungAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseG1GC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestG1YoungAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestG1YoungAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:MaxNewSize=10M -Xmx64M -XX:+UseSerialGC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestMarkSweepCompactAllocationPendingStackTrace\n+ * @run main\/othervm -XX:MaxNewSize=10M -Xmx64M -XX:+UseSerialGC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestMarkSweepCompactAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestMarkSweepCompactAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,3 @@\n- * @run main\/othervm -XX:+UseG1GC -Xlog:gc* -XX:MaxMetaspaceSize=64M jdk.jfr.event.gc.stacktrace.TestMetaspaceG1GCAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseG1GC -Xlog:gc* -XX:MaxMetaspaceSize=64M\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestMetaspaceG1GCAllocationPendingStackTrace\n@@ -33,1 +35,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestMetaspaceG1GCAllocationPendingStackTrace.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseParallelGC -Xlog:gc* -XX:MaxMetaspaceSize=64M jdk.jfr.event.gc.stacktrace.TestMetaspaceParallelGCAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseParallelGC -Xlog:gc* -XX:MaxMetaspaceSize=64M\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestMetaspaceParallelGCAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestMetaspaceParallelGCAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseSerialGC -Xlog:gc* -XX:MaxMetaspaceSize=64M jdk.jfr.event.gc.stacktrace.TestMetaspaceSerialGCAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseSerialGC -Xlog:gc* -XX:MaxMetaspaceSize=64M\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestMetaspaceSerialGCAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestMetaspaceSerialGCAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:MaxNewSize=10M -Xmx64M -XX:+UseParallelGC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestParallelMarkSweepAllocationPendingStackTrace\n+ * @run main\/othervm -XX:MaxNewSize=10M -Xmx64M -XX:+UseParallelGC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestParallelMarkSweepAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestParallelMarkSweepAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseParallelGC -Xlog:gc* jdk.jfr.event.gc.stacktrace.TestParallelScavengeAllocationPendingStackTrace\n+ * @run main\/othervm -XX:+UseParallelGC -Xlog:gc*\n+ *                   -XX:FlightRecorderOptions:stackdepth=256\n+ *                   jdk.jfr.event.gc.stacktrace.TestParallelScavengeAllocationPendingStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/stacktrace\/TestParallelScavengeAllocationPendingStackTrace.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.jvmti\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestAgentEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private static final String VM_OPERATION = \"ParallelGCSystemGC\";\n+    private static final String VM_OPERATION = \"ParallelGCCollect\";\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestVMOperation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+        CountDownLatch threadSleep = new CountDownLatch(1);\n@@ -59,0 +60,1 @@\n+            rs.enable(\"jdk.ThreadSleep\").withoutThreshold().withStackTrace();\n@@ -73,0 +75,5 @@\n+            rs.onEvent(\"jdk.ThreadSleep\", e -> {\n+                threadSleep.countDown();\n+                System.out.println(e);\n+                storeLastTimestamp(e);\n+            });\n@@ -93,0 +100,2 @@\n+            \/\/ Emit thread sleep event\n+            Thread.sleep(1);\n@@ -96,0 +105,1 @@\n+            threadSleep.await();\n@@ -163,1 +173,1 @@\n-             \"JFR.view\", \"verbose=true\", \"width=300\", \"cell-height=100\", \"SystemGC\");\n+             \"JFR.view\", \"verbose=true\", \"width=300\", \"cell-height=100\", \"ThreadSleep\");\n@@ -165,1 +175,1 @@\n-        output.shouldContain(\"System GC\");\n+        output.shouldContain(\"Thread Sleep\");\n@@ -167,1 +177,1 @@\n-        output.shouldContain(\"Invoked Concurrent\");\n+        output.shouldContain(\"Sleep Time\");\n@@ -169,1 +179,1 @@\n-        output.shouldContain(\"invokedConcurrent\");\n+        output.shouldContain(\"time\");\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdView.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    private static ManagementAgentJcmd jcmd = new ManagementAgentJcmd(TEST_APP_NAME, verbose);\n+    private static ManagementAgentJcmd jcmd;\n@@ -350,0 +350,1 @@\n+                    jcmd = new ManagementAgentJcmd(p, verbose);\n","filename":"test\/jdk\/sun\/management\/jmxremote\/startstop\/JMXStartStopTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,0 @@\n-        jcmd = new ManagementAgentJcmd(TEST_APP_NAME, false);\n@@ -79,0 +78,1 @@\n+        jcmd = new ManagementAgentJcmd(testApp, false);\n","filename":"test\/jdk\/sun\/management\/jmxremote\/startstop\/JMXStatusPerfCountersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,0 @@\n-\n-        jcmd = new ManagementAgentJcmd(TEST_APP_NAME, false);\n@@ -101,0 +99,1 @@\n+        jcmd = new ManagementAgentJcmd(testApp, false);\n","filename":"test\/jdk\/sun\/management\/jmxremote\/startstop\/JMXStatusTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    private final String id;\n+    private final long pid;\n@@ -53,2 +53,2 @@\n-    public ManagementAgentJcmd(String targetApp, boolean verbose) {\n-        this.id = targetApp;\n+    public ManagementAgentJcmd(Process targetApp, boolean verbose) {\n+        this.pid = targetApp.pid();\n@@ -177,1 +177,1 @@\n-        return jcmd(id, c, command);\n+        return jcmd(Long.toString(pid), c, command);\n","filename":"test\/jdk\/sun\/management\/jmxremote\/startstop\/ManagementAgentJcmd.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @bug 8164656 8181461 8194486\n+ * @bug 8164656 8181461 8194486 8333772\n@@ -222,1 +222,1 @@\n-                inDefaults += \"udp_preference_limit = 1\\n\";\n+                inDefaults += \"udp_preference_limit = 0\\n\";\n@@ -226,1 +226,1 @@\n-                inDefaults += \"udp_preference_limit = 1\\n\";\n+                inDefaults += \"udp_preference_limit = 0\\n\";\n@@ -228,1 +228,1 @@\n-                inRealm += \"   udp_preference_limit = 1\\n\";\n+                inRealm += \"   udp_preference_limit = 0\\n\";\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/KdcPolicy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+\n+\/*\n+ * @test\n+ * @bug 8333772\n+ * @summary check krb5.conf reading on default and realm-specific values\n+ * @library \/test\/lib\n+ * @run main\/othervm RealmSpecificValues\n+ *\/\n+public class RealmSpecificValues {\n+\n+    static DebugMatcher cm = new DebugMatcher();\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"sun.security.krb5.debug\", \"true\");\n+        System.setProperty(\"java.security.krb5.conf\", \"alternative-krb5.conf\");\n+\n+        \/\/ Defaults\n+        writeConf(-1, -1, -1, -1, -1, -1);\n+        test(true, 3, 30000);\n+\n+        \/\/ Below has settings. For each setting we provide 3 cases:\n+        \/\/ 1. Set in defaults, 2, set in realms, 3, both\n+\n+        \/\/ udp = 0 is useful\n+        writeConf(0, -1, -1, -1, -1, -1);\n+        test(false, 3, 30000);\n+        writeConf(-1, -1, -1, 0, -1, -1);\n+        test(false, 3, 30000);\n+        writeConf(1, -1, -1, 0, -1, -1);\n+        test(false, 3, 30000);\n+\n+        \/\/ max_retries = 0 is ignored\n+        writeConf(-1, 0, -1, -1, -1, -1);\n+        test(true, 3, 30000);\n+        writeConf(-1, -1, -1, -1, 0, -1);\n+        test(true, 3, 30000);\n+        writeConf(-1, 6, -1, -1, 0, -1); \/\/ Note: 0 is ignored, it does not reset to default\n+        test(true, 6, 30000);\n+\n+        \/\/ max_retries = 1 is useful\n+        writeConf(-1, 1, -1, -1, -1, -1);\n+        test(true, 1, 30000);\n+        writeConf(-1, -1, -1, -1, 1, -1);\n+        test(true, 1, 30000);\n+        writeConf(-1, 3, -1, -1, 1, -1);\n+        test(true, 1, 30000);\n+\n+        \/\/ timeout = 0 is ignored\n+        writeConf(-1, -1, 0, -1, -1, -1);\n+        test(true, 3, 30000);\n+        writeConf(-1, -1, -1, -1, -1, 0);\n+        test(true, 3, 30000);\n+        writeConf(-1, -1, 10000, -1, -1, 0);\n+        test(true, 3, 10000);\n+\n+        \/\/ timeout > 0 is useful\n+        writeConf(-1, -1, 10000, -1, -1, -1);\n+        test(true, 3, 10000);\n+        writeConf(-1, -1, -1, -1, -1, 10000);\n+        test(true, 3, 10000);\n+        writeConf(-1, -1, 20000, -1, -1, 10000);\n+        test(true, 3, 10000);\n+    }\n+\n+    static void writeConf(int limit, int retries, int timeout,\n+            int limitR, int retriesR, int timeoutR) throws Exception {\n+\n+        String inDefaults = \"\";\n+        if (limit >= 0) inDefaults += \"udp_preference_limit = \" + limit + \"\\n\";\n+        if (retries >= 0) inDefaults += \"max_retries = \" + retries + \"\\n\";\n+        if (timeout >= 0) inDefaults += \"kdc_timeout = \" + timeout + \"\\n\";\n+\n+        String inRealm = \"\";\n+        if (limitR >= 0) inRealm += \"udp_preference_limit = \" + limitR + \"\\n\";\n+        if (retriesR >= 0) inRealm += \"max_retries = \" + retriesR + \"\\n\";\n+        if (timeoutR >= 0) inRealm += \"kdc_timeout = \" + timeoutR + \"\\n\";\n+\n+        String conf = \"[libdefaults]\\n\" +\n+                \"default_realm = \" + OneKDC.REALM + \"\\n\" +\n+                inDefaults +\n+                \"\\n\" +\n+                \"[realms]\\n\" +\n+                OneKDC.REALM + \" = {\\n\" +\n+                \"kdc = \" + OneKDC.KDCHOST + \":12345\\n\" +\n+                inRealm +\n+                \"}\\n\";\n+\n+        Files.writeString(Paths.get(\"alternative-krb5.conf\"), conf);\n+    }\n+\n+    static void test(boolean isUDP, int retries, int timeout) throws Exception {\n+\n+        PrintStream oldErr = System.err;\n+        ByteArrayOutputStream bo = new ByteArrayOutputStream();\n+        System.setErr(new PrintStream(bo));\n+        try {\n+            Config.refresh();\n+            Context.fromUserPass(OneKDC.USER, OneKDC.PASS, false);\n+        } catch (Exception e) {\n+            \/\/ will happen\n+        } finally {\n+            System.setErr(oldErr);\n+        }\n+\n+        String[] lines = new String(bo.toByteArray()).split(\"\\n\");\n+        for (String line: lines) {\n+            if (cm.match(line)) {\n+                System.out.println(line);\n+                Asserts.assertEQ(cm.isUDP(), isUDP);\n+                Asserts.assertEQ(cm.timeout(), timeout);\n+                Asserts.assertEQ(cm.retries(), retries);\n+                return;\n+            }\n+        }\n+        Asserts.fail(\"Should not reach here\");\n+    }\n+\n+    \/**\n+     * A helper class to match the krb5 debug output:\n+     * >>> KrbKdcReq send: kdc=kdc.rabbit.hole TCP:12345, timeout=30000,\n+     *     number of retries =3, #bytes=141\n+     *\/\n+    static class DebugMatcher {\n+\n+        static final Pattern re = Pattern.compile(\n+                \">>> KrbKdcReq send: kdc=\\\\S+ (TCP|UDP):\\\\d+, \" +\n+                        \"timeout=(\\\\d+), number of retries\\\\s*=(\\\\d+)\");\n+\n+        Matcher matcher;\n+\n+        boolean match(String line) {\n+            matcher = re.matcher(line);\n+            return matcher.find();\n+        }\n+\n+        boolean isUDP() {\n+            return matcher.group(1).equals(\"UDP\");\n+        }\n+\n+        int timeout() {\n+            return Integer.parseInt(matcher.group(2));\n+        }\n+\n+        int retries() {\n+            return Integer.parseInt(matcher.group(3));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/RealmSpecificValues.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336667\n+ * @summary Ensure the unused bytes are calculated correctly when converting\n+ *          indefinite length BER to DER\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import sun.security.util.DerInputStream;\n+\n+import java.util.HexFormat;\n+\n+public class PoC {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ A BER indefinite encoding with some unused bytes at the end\n+        var data = HexFormat.of().parseHex(\"\"\"\n+                2480 0401AA 0401BB 0000 -- 2 byte string\n+                010100 -- boolean false\n+                12345678 -- 4 unused bytes\"\"\"\n+                .replaceAll(\"(\\\\s|--.*)\", \"\"));\n+        var dis = new DerInputStream(data, 0, data.length - 4, true);\n+        Asserts.assertEQ(dis.getDerValue().getOctetString().length, 2);\n+        Asserts.assertFalse(dis.getDerValue().getBoolean());\n+        dis.atEnd();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/DerInputBuffer\/B8336667\/PoC.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336667\n+ * @summary Ensure the unused bytes are calculated correctly when converting\n+ *          indefinite length BER to DER\n+ *\/\n+import java.io.ByteArrayInputStream;\n+import java.security.cert.CRLException;\n+import java.security.cert.CertificateException;\n+import java.util.Base64;\n+\n+public class Reproducer {\n+    private static final String INPUT = \"\"\"\n+            MIIBljCCAVMwgAaB\/\/\/\/\/\/\/\/\/yb\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/9\/\/\/\/AgDv\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/2RjPWNvbf\/\/\/\/8k\/\/\/\/\/\/\/\/\/yb\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/9vbf\/\/\/\/8k\/\/\/\/\/\/\/\/\/yb\/\/\/\/\/\n+            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/AgD\/\/\/\/\/\/\/\/\/\/\/\/\/b23\/\/\/\/\/JP\/\/\/\/\/\/\/\/8m\/\/\/\/\/yf\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/wIA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/8AAABl\/\/\/\/\/\/8m\/\/\/\/\/\/\/\/\/y1CRUdJ\n+            TiA9Y290cnVlVlZWVlZWVlZWVjEAAAAAAAAArQdVUwNVBAsTA0RvRDEaMBhAA1UAAAAAAAAAAAAA\n+            AAAAAAAAAAAAAAAAAAEXDTAzMDcxNTE2MjAwNFqgHzAdMA8GA1UdHAEB\/wQFMAPyAf8wCgYDVR0P\n+            BAMCAQIwCwYHKoZIzjgEAwUAAzBkARkTA2NvbTEYMBYGCgmSJomT8ixkARkTCG15VGVzdENBMBIC\n+            AQHyAjZG+RfHdO4=\"\"\";\n+\n+    Reproducer(byte[] data) {\n+        try {\n+            java.security.cert.CertificateFactory.\n+                    getInstance(\"X.509\").generateCRLs(new ByteArrayInputStream(data));\n+        } catch (CertificateException | CRLException e) {\n+            if (System.getProperty(\"dbg\", \"false\").equals(\"true\")) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] a) throws Exception {\n+        byte[] decodedBytes = Base64.getMimeDecoder().decode(INPUT);\n+        new Reproducer(decodedBytes);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/DerInputBuffer\/B8336667\/Reproducer.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334492\n+ * @summary Test to verify jcmd accepts %p in output filenames and substitutes for PID\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestJcmdPIDSubstitution\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class TestJcmdPIDSubstitution {\n+\n+    private static final String FILENAME = \"myfile%p\";\n+\n+    public static void main(String[] args) throws Exception {\n+        verifyOutputFilenames(\"Thread.dump_to_file\", FILENAME);\n+        verifyOutputFilenames(\"GC.heap_dump\", FILENAME);\n+        verifyOutputFilenames(\"Compiler.perfmap\", FILENAME);\n+        verifyOutputFilenames(\"System.dump_map\", \"-F=%s\".formatted(FILENAME));\n+    }\n+\n+    private static void verifyOutputFilenames(String... args) throws Exception {\n+        long pid = ProcessTools.getProcessId();\n+        String test_dir = System.getProperty(\"test.dir\", \".\");\n+        Path path = Paths.get(\"%s\/myfile%d\".formatted(test_dir, pid));\n+        OutputAnalyzer output = JcmdBase.jcmd(args);\n+        output.shouldHaveExitValue(0);\n+        if (Files.exists(path)) {\n+            Files.delete(path);\n+        } else {\n+            throw new Exception(\"File %s was not created as expected for diagnostic cmd %s\".formatted(path, args[0]));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdPIDSubstitution.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+\n+    private static final String TOOL_VM_OPTIONS = System.getProperty(\"test.tool.vm.opts\", \"\");\n+\n@@ -49,0 +52,3 @@\n+        if (!TOOL_VM_OPTIONS.isEmpty()) {\n+            cmd.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(\"\\\\s+\", -1)));\n+        }\n","filename":"test\/jdk\/tools\/jlink\/JLinkReproducibleTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class ChildProcessAppLauncher {\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        if (args.length == 1 && \"noexit\".equals(args[0])) {\n+            var lock = new Object();\n+            synchronized (lock) {\n+                lock.wait();\n+            }\n+        } else {\n+            var childPath = System.getProperty(\"jpackage.app-path\"); \/\/ get the path to the current jpackage app launcher\n+            ProcessBuilder processBuilder = new ProcessBuilder(childPath, \"noexit\"); \/\/ChildProcessAppLauncher acts as third party app\n+            Process process = processBuilder.start();\n+            System.out.println(\"Child id=\" + process.pid());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/apps\/ChildProcessAppLauncher.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8325203\n+ * @summary Test that Jpackage windows executable application kills the launched 3rd party application\n+ *          when System.exit(0) is invoked along with terminating java program.\n+ * @library ..\/helpers\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @build WinChildProcessTest\n+ * @build jdk.jpackage.test.*\n+ * @build WinChildProcessTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinChildProcessTest\n+ *\n+ *\/\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import java.nio.file.Path;\n+\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.TKit;\n+\n+public class WinChildProcessTest {\n+    private static final Path TEST_APP_JAVA = TKit.TEST_SRC_ROOT\n+            .resolve(\"apps\/ChildProcessAppLauncher.java\");\n+\n+    @Test\n+    public static void test() throws Throwable {\n+        long childPid = 0;\n+        try {\n+            JPackageCommand cmd = JPackageCommand\n+                    .helloAppImage(TEST_APP_JAVA + \"*Hello\");\n+\n+            \/\/ Create the image of the third party application launcher\n+            cmd.executeAndAssertImageCreated();\n+\n+            \/\/ Start the third party application launcher and dump and save the\n+            \/\/ output of the application\n+            List<String> output = new Executor().saveOutput().dumpOutput()\n+                    .setExecutable(cmd.appLauncherPath().toAbsolutePath())\n+                    .execute(0).getOutput();\n+            String pidStr = output.get(0);\n+\n+            \/\/ parse child PID\n+            childPid = Long.parseLong(pidStr.split(\"=\", 2)[1]);\n+\n+            \/\/ Check whether the termination of third party application launcher\n+            \/\/ also terminating the launched third party application\n+            \/\/ If third party application is not terminated the test is\n+            \/\/ successful else failure\n+            Optional<ProcessHandle> processHandle = ProcessHandle.of(childPid);\n+            boolean isAlive = processHandle.isPresent()\n+                    && processHandle.get().isAlive();\n+            TKit.assertTrue(isAlive, \"Check is child process is alive\");\n+        } finally {\n+            \/\/ Kill only a specific child instance\n+            Runtime.getRuntime().exec(\"taskkill \/F \/PID \" + childPid);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -71,0 +71,1 @@\n+tools\/javap\/UndefinedAccessFlagTest.java                                        8342036    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,2 +85,3 @@\n-                <div class=\"summary-table two-column-summary\">\n-                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"summary-table three-column-summary\">\n+                <div class=\"table-header col-first\">Modifier<\/div>\n+                <div class=\"table-header col-second\">Constructor<\/div>\n@@ -88,0 +89,1 @@\n+                <div class=\"col-first even-row-color\"><code>&nbsp;<\/code><\/div>\n@@ -91,0 +93,1 @@\n+                <div class=\"col-first odd-row-color\"><code>&nbsp;&lt;T extends X&gt;<br><\/code><\/div>\n@@ -94,0 +97,1 @@\n+                <div class=\"col-first even-row-color\"><code>&nbsp;&lt;T extends Y&gt;<br><\/code><\/div>\n@@ -191,2 +195,3 @@\n-                <div class=\"summary-table two-column-summary\">\n-                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"summary-table three-column-summary\">\n+                <div class=\"table-header col-first\">Modifier<\/div>\n+                <div class=\"table-header col-second\">Constructor<\/div>\n@@ -194,0 +199,1 @@\n+                <div class=\"col-first even-row-color\"><code>&nbsp;<\/code><\/div>\n@@ -198,0 +204,1 @@\n+                <div class=\"col-first odd-row-color\"><code>&nbsp;&lt;T extends X&gt;<br><\/code><\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testErasure\/TestErasure.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                    <pre class=\"snippet\"><code>   this is snippet_standalone\n+                    <pre class=\"snippet\" id=\"snippet-snippet_standalone()1\"><code class=\"language-java\">   this is snippet_standalone\n@@ -134,1 +134,1 @@\n-                    <pre class=\"snippet\"><code>   this is a snippet_wrapped\n+                    <pre class=\"snippet\" id=\"snippet-snippet_wrapped()1\"><code class=\"language-java\">   this is a snippet_wrapped\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownTaglets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,2 @@\n-                    equal. All components in this record class are compared with '=='.\"\"\",\n+                    equal. All components in this record class are compared with the <code>compare<\/\\\n+                    code> method from their corresponding wrapper classes.\"\"\",\n@@ -303,1 +304,2 @@\n-                    equal. All components in this record class are compared with '=='.\"\"\",\n+                    equal. All components in this record class are compared with the <code>compare<\/\\\n+                    code> method from their corresponding wrapper classes.\"\"\",\n@@ -314,1 +316,2 @@\n-             \"All components in this record class are compared with '=='.\");\n+             \"All components in this record class are compared with the <code>compare<\/code> method \" +\n+                     \"from their corresponding wrapper classes.\");\n@@ -327,1 +330,2 @@\n-             + \"primitive components are compared with '=='.\");\n+             + \"primitive components are compared with the <code>compare<\/code> method from their \"\n+             + \"corresponding wrapper classes.\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-        return getSnippetHtmlRepresentation(pathToHtmlFile, content, Optional.empty(), Optional.empty());\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, Optional.of(\"java\"), Optional.empty());\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,1 +182,1 @@\n-                    t.expectedOutput(), Optional.of(\"properties\")));\n+                    t.expectedOutput(), Optional.of(\"properties\"), Optional.of(\"snippet-case\" + index + \"()2\")));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestLangProperties.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import java.util.Optional;\n@@ -368,1 +369,1 @@\n-                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput()));\n+                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput(), Optional.of(\"java\"), Optional.of(\"snippet-case\" + index + \"()2\")));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8266666 8275788 8276964\n+ * @bug 8266666 8275788 8276964 8299080\n@@ -111,1 +111,1 @@\n-                    \"\"\", \"foo1\", null),\n+                    \"\"\", \"foo1\", \"java\"),\n@@ -116,1 +116,1 @@\n-                    \"\"\", \"foo2\", null),\n+                    \"\"\", \"foo2\", \"java\"),\n@@ -121,1 +121,1 @@\n-                    \"\"\", \"foo3\", null),\n+                    \"\"\", \"foo3\", \"java\"),\n@@ -126,1 +126,1 @@\n-                    \"\"\", \"foo4\", null),\n+                    \"\"\", \"foo4\", \"java\"),\n@@ -131,1 +131,1 @@\n-                    \"\"\", \"foo5\", null),\n+                    \"\"\", \"foo5\", \"java\"),\n@@ -140,1 +140,1 @@\n-\/\/                    \"\"\", \"foo6\", null),\n+\/\/                    \"\"\", \"foo6\", \"java\"),\n@@ -146,1 +146,1 @@\n-                    \"\"\", null, null),\n+                    \"\"\", null, \"java\"),\n@@ -151,1 +151,1 @@\n-                    \"\"\", null, null),\n+                    \"\"\", null, \"java\"),\n@@ -156,1 +156,1 @@\n-                    \"\"\", null, null),\n+                    \"\"\", null, \"java\"),\n@@ -161,1 +161,1 @@\n-                    \"\"\", null, null),\n+                    \"\"\", null, \"java\"),\n@@ -223,0 +223,1 @@\n+            Optional<String> id = (attr.id() != null ? Optional.of(attr.id()) : Optional.of(\"snippet-case\" + j + \"()1\"));\n@@ -224,1 +225,1 @@\n-                    Optional.ofNullable(attr.lang()), Optional.ofNullable(attr.id()));\n+                    Optional.ofNullable(attr.lang()), id);\n@@ -882,1 +883,2 @@\n-                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.of(\"java\"),\n+                                Optional.of(\"snippet-case\" + id + \"()2\"))));\n@@ -974,1 +976,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput)));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput, Optional.of(\"txt\"),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -1552,1 +1555,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.of(\"java\"),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -1665,1 +1669,2 @@\n-                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\", Optional.of(\"txt\"),\n+                            Optional.of(\"snippet-case0()2\")));\n@@ -1670,1 +1675,2 @@\n-                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\", Optional.of(\"txt\"),\n+                            Optional.of(\"snippet-case1()2\")));\n@@ -1768,1 +1774,2 @@\n-                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\")));\n+                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\", Optional.empty(),\n+                                Optional.of(\"snippet-case\" + j + \"()2\"))));\n@@ -1847,1 +1854,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.of(\"java\"),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -1852,0 +1860,114 @@\n+    public void testPositiveExternalHybridLangAttribute(Path base) throws Exception {\n+\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+\n+        record TestCase(String tag, String expectedContent, String expectedLang) { }\n+\n+        final var testCases = List.of(\n+                \/\/ -------------------- external snippets --------------------\n+                \/\/ if there's no file extension and no lang attribute, then\n+                \/\/ markup is that of \"java\" and the class=\"language-\" attribute\n+                \/\/ is absent\n+                new TestCase(\"\"\"\n+                        {@snippet file=\".file\"}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", null),\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file\"}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", null),\n+                \/\/ if the file extension differs from the value of the lang\n+                \/\/ attribute, which is set to \"java\", \"properties\" or other,\n+                \/\/ then the class=\"language-\" attribute is that of lang and\n+                \/\/ markup is that of \"properties\" for lang=properties and\n+                \/\/ markup is that of \"java\" for anything else\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"File.java\" lang=properties}\n+                        \"\"\", \"\"\"\n+                        <span class=\"bold\">hi<\/span> there \/\/ @<span class=\"bold\">hi<\/span>ghlight substring=there\n+                        \"\"\", \"properties\"),\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file.properties\" lang=java}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", \"java\"),\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"File.java\" lang=txt}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", \"txt\"),\n+                \/\/ if there's no file extension, but the lang attribute is set\n+                \/\/ to \"java\", \"properties\", or other, then the class=\"language-\"\n+                \/\/ attribute is that of lang and markup is that of \"properties\"\n+                \/\/ for lang=properties and markup is that of \"java\" for\n+                \/\/ anything else\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file\" lang=properties}\n+                        \"\"\", \"\"\"\n+                        <span class=\"bold\">hi<\/span> there \/\/ @<span class=\"bold\">hi<\/span>ghlight substring=there\n+                        \"\"\", \"properties\"),\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file\" lang=java}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", \"java\"),\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file\" lang=txt}\n+                        \"\"\", \"\"\"\n+                        # @highlight substring=hi:\n+                        hi <span class=\"bold\">there<\/span>\n+                        \"\"\", \"txt\"),\n+                \/\/ --------------------- hybrid snippets ---------------------\n+                \/\/ the lang attribute \"overrides\" file extension\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"File.java\" lang=properties:\n+                        # @highlight substring=hi:\n+                        hi there \/\/ @highlight substring=there\n+                        }\n+                        \"\"\", \"\"\"\n+                        <span class=\"bold\">hi<\/span> there \/\/ @<span class=\"bold\">hi<\/span>ghlight substring=there\n+                        \"\"\", \"properties\"),\n+                \/\/ if the lang attribute is absent, file extension determines\n+                \/\/ markup and the the class=\"language-\" attribute\n+                new TestCase(\"\"\"\n+                        {@snippet file=\"file.properties\":\n+                        # @highlight substring=hi:\n+                        hi there \/\/ @highlight substring=there\n+                        }\n+                        \"\"\", \"\"\"\n+                        <span class=\"bold\">hi<\/span> there \/\/ @<span class=\"bold\">hi<\/span>ghlight substring=there\n+                        \"\"\", \"properties\")\n+        );\n+\n+        for (var f : List.of(\".file\", \"file\", \"File.java\", \"file.properties\"))\n+            addSnippetFile(srcDir, \"pkg\", f, \"\"\"\n+                    # @highlight substring=hi:\n+                    hi there \/\/ @highlight substring=there\n+                    \"\"\");\n+\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (s, i) -> classBuilder.addMembers(\n+                MethodBuilder.parse(\"public void case%s() { }\".formatted(i)).setComments(s.tag)));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, i) -> checkOutput(\"pkg\/A.html\", true, \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        %s\n+                        \"\"\".formatted(i, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedContent, Optional.ofNullable(t.expectedLang),\n+                Optional.of(\"snippet-case\" + i + \"()2\")))));\n+    }\n+\n+    \/\/@Test\n@@ -2305,1 +2427,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.of(\"txt\"),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":144,"deletions":21,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-                        \"public class S { }\", Optional.of(\"java\"))));\n+                        \"public class S { }\", Optional.of(\"java\"), Optional.of(\"snippet-C1\"))));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetUnnamedPackage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      4927167 4974929 7010344 8025633 8081854 8182765 8187288 8261976\n+ * @bug      4927167 4974929 6381729 7010344 8025633 8081854 8182765 8187288 8261976\n@@ -32,0 +32,1 @@\n+ *           Verify that generic type parameters on constructors are documented.\n@@ -97,0 +98,21 @@\n+\n+    @Test\n+    public void test3() {\n+        javadoc(\"-d\", \"out-3\",\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"-sourcepath\", testSrc,\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"pkg\/CtorTypeParam.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color\"><code>&nbsp;&lt;T extends java.lang.Runnable&gt;<br><\/code><\/div>\n+                    <div class=\"col-constructor-name even-row-color\"><code>\\\n+                    <a href=\"#%3Cinit%3E()\" class=\"member-name-link\">CtorTypeParam<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">&nbsp;<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>\\\n+                    &nbsp;<span class=\"type-parameters\">&lt;T extends java.lang.Runnable&gt;<\/span>\\\n+                    &nbsp;<span class=\"element-name\">CtorTypeParam<\/span>()<\/div>\"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/TestTypeParameters.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+public class CtorTypeParam {\n+    public <T extends Runnable> CtorTypeParam() {\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n-LocalClassTest$1CapturingLocal$1.<init>(final val$this$0\/*synthetic*\/, final val$val$i\/*synthetic*\/)\n+LocalClassTest$1CapturingLocal$1.<init>(final this$0\/*implicit*\/, final val$val$i\/*synthetic*\/)\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LocalClassTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336320\n+ * @summary NullPointerException: Cannot invoke Type.getTag because type is null after JDK-8334037\n+ * @compile MrefDoubleTrans.java\n+ *\/\n+class MrefDoubleTrans {\n+    public void f() {\n+        Runnable r = new I()::m;\n+    }\n+\n+    class I {\n+        void m(Object... xs) {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/MrefDoubleTrans.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334121\n+ * @summary Anonymous class capturing two enclosing instances fails to compile\n+ * @enablePreview\n+ *\/\n+\n+public class MultiLevelOuterInstance {\n+\n+    interface A {\n+        void run();\n+    }\n+    interface B {\n+        void run();\n+    }\n+\n+    class Inner1 {\n+        Inner1() {\n+            this(new A() {\n+                class Inner2 {\n+                    Inner2() {\n+                        this(new B() {\n+                            public void run() {\n+                                m();\n+                                g();\n+                            }\n+                        });\n+                    }\n+\n+                    Inner2(B o) {\n+                        o.run();\n+                    }\n+                }\n+\n+                public void run() {\n+                    new Inner2();\n+                }\n+\n+                void m() { }\n+            });\n+        }\n+\n+        Inner1(A o) { }\n+    }\n+    void g() { }\n+\n+    public static void main(String[] args) {\n+        new MultiLevelOuterInstance().new Inner1();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/MultiLevelOuterInstance.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332850\n+ * @summary javac crashes if container for repeatable annotation is not found\n+ * @library \/tools\/javac\/lib \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import toolbox.*;\n+import toolbox.Task.*;\n+\n+public class CompletionErrorOnRepeatingAnnosTest {\n+    ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        CompletionErrorOnRepeatingAnnosTest t = new CompletionErrorOnRepeatingAnnosTest();\n+        \/\/t.testMissingContainerAnno();\n+        t.testMissingContainerTypeAnno();\n+    }\n+\n+    void testMissingContainerTypeAnno() throws Exception {\n+        doTest(\n+                \"\"\"\n+                import java.lang.annotation.*;\n+                import static java.lang.annotation.RetentionPolicy.*;\n+                import static java.lang.annotation.ElementType.*;\n+                @Target({TYPE_USE,FIELD}) @Repeatable( As.class) @interface A { }\n+                @Target({TYPE_USE,FIELD}) @interface As { A[] value(); }\n+                \"\"\",\n+                \"\"\"\n+                class T {\n+                    @A @A String data = \"test\";\n+                }\n+                \"\"\",\n+                List.of(\n+                        \"T.java:2:5: compiler.err.cant.access: As, (compiler.misc.class.file.not.found: As)\",\n+                        \"T.java:2:8: compiler.err.invalid.repeatable.annotation.no.value: As\",\n+                        \"2 errors\"\n+                )\n+        );\n+    }\n+\n+    void testMissingContainerAnno() throws Exception {\n+        doTest(\n+                \"\"\"\n+                import java.lang.annotation.Repeatable;\n+                @Repeatable(As.class)\n+                @interface A {}\n+                @interface As {\n+                    A[] value();\n+                }\n+                \"\"\",\n+                \"@A @A class T {}\",\n+                List.of(\n+                        \"T.java:1:1: compiler.err.cant.access: As, (compiler.misc.class.file.not.found: As)\",\n+                        \"T.java:1:4: compiler.err.invalid.repeatable.annotation.no.value: As\",\n+                        \"2 errors\"\n+                )\n+        );\n+    }\n+\n+    private void doTest(String annosSrc, String annotatedSrc, List<String> expectedOutput) throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.createDirectories(src);\n+        tb.writeJavaFiles(src, annosSrc);\n+        Path out = base.resolve(\"out\");\n+        tb.createDirectories(out);\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(tb.findJavaFiles(src))\n+                .run();\n+        \/\/ let's now compile T.java which uses repeated annotations, we want to load the anno classes from the CP\n+        tb.deleteFiles(src.resolve(\"A.java\"));\n+        tb.writeJavaFiles(src, annotatedSrc);\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .classpath(out)\n+                .files(tb.findJavaFiles(src))\n+                .run();\n+        \/\/ now if we remove As.class there will be an error but javac should not crash\n+        tb.deleteFiles(out.resolve(\"As.class\"));\n+        List<String> log = new JavacTask(tb)\n+                .outdir(out)\n+                .classpath(out)\n+                .options(\"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(src))\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (!expectedOutput.equals(log))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/repeatingAnnotations\/CompletionErrorOnRepeatingAnnosTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8026564 8043226\n+ * @summary 8334055\n+ * @compile\/fail\/ref=CantAnnotateMissingSymbol.out -XDrawDiagnostics CantAnnotateMissingSymbol.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.List;\n+\n+class CantAnnotateMissingSymbol {\n+    List<@TA NoSuch> x;\n+}\n+\n+@Target(ElementType.TYPE_USE)\n+@interface TA { }\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateMissingSymbol.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CantAnnotateMissingSymbol.java:12:14: compiler.err.cant.resolve.location: kindname.class, NoSuch, , , (compiler.misc.location: kindname.class, CantAnnotateMissingSymbol, null)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateMissingSymbol.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8026564 8043226\n+ * @bug 8026564 8043226 8334055\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotatePackages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+CantAnnotatePackages.java:16:14: compiler.err.cant.resolve.location: kindname.class, java, , , (compiler.misc.location: kindname.class, CantAnnotatePackages, null)\n+CantAnnotatePackages.java:17:9: compiler.err.cant.resolve.location: kindname.class, lang, , , (compiler.misc.location: kindname.package, java, null)\n+CantAnnotatePackages.java:18:14: compiler.err.cant.resolve.location: kindname.class, lang, , , (compiler.misc.location: kindname.package, java, null)\n@@ -2,3 +5,0 @@\n-CantAnnotatePackages.java:16:14: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @TA), java.lang, @TA java.lang.Object\n-CantAnnotatePackages.java:17:9: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @TA), java.lang, @TA java.lang.Object\n-CantAnnotatePackages.java:18:14: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @TA), java.lang, @TA java.lang.Object\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotatePackages.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8006733 8006775 8043226\n+ * @bug 8006733 8006775 8043226 8334055\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateScoping.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,3 @@\n-CantAnnotateScoping.java:68:18: compiler.err.doesnt.exist: java.XXX\n+CantAnnotateScoping.java:63:9: compiler.err.cant.resolve.location: kindname.class, lang, , , (compiler.misc.location: kindname.package, java, null)\n+CantAnnotateScoping.java:68:9: compiler.err.cant.resolve.location: kindname.class, XXX, , , (compiler.misc.location: kindname.package, java, null)\n+CantAnnotateScoping.java:71:9: compiler.err.cant.resolve.location: kindname.class, lang, , , (compiler.misc.location: kindname.package, java, null)\n@@ -6,3 +8,0 @@\n-CantAnnotateScoping.java:63:11: compiler.err.annotation.type.not.applicable.to.type: DA\n-CantAnnotateScoping.java:68:11: compiler.err.annotation.type.not.applicable.to.type: DA\n-CantAnnotateScoping.java:71:9: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @TA), java.lang, @TA java.lang.Object\n@@ -13,1 +12,1 @@\n-12 errors\n+11 errors\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateScoping.out","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,2 @@\n-            BufWriter buf = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n-            attr.defaultValue().writeTo(buf);\n+            var buf = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n+            AnnotationReader.writeAnnotationValue(buf, attr.defaultValue());\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/AnnotationDefault\/AnnotationDefaultVerifier.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336786\n+ * @summary VerifyError with lambda capture and enclosing instance references\n+ * @compile a\/A.java SuperClassThisCapture.java\n+ * @run main SuperClassThisCapture\n+ *\/\n+\n+public class SuperClassThisCapture extends a.A {\n+\n+  public static void main(String[] args) {\n+    new SuperClassThisCapture().f(42);\n+    new SuperClassThisCapture().g();\n+  }\n+\n+  public void f(int x) {\n+    Runnable r = () -> {\n+      System.err.println(x);\n+      new I();\n+    };\n+    r.run();\n+  }\n+\n+  public void g() {\n+    Runnable r = () -> new I();\n+    r.run();\n+  }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/SuperClassThisCapture\/SuperClassThisCapture.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package a;\n+\n+public class A {\n+  public class I {}\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/SuperClassThisCapture\/a\/A.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336491\n+ * @summary Verify that void returning expression lambdas don't box their result\n+ * @modules jdk.compiler\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Path;\n+\n+public class VoidReturnBoxing {\n+\n+    public static void main(String[] args) {\n+        new VoidReturnBoxing().run();\n+    }\n+\n+    void run() {\n+        Path path = Path.of(System.getProperty(\"test.classes\"), \"T.class\");\n+        StringWriter s;\n+        String out;\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(new String[] {\"-p\", \"-c\", path.toString()}, pw);\n+            out = s.toString();\n+        }\n+        if (out.contains(\"java\/lang\/Integer.valueOf\")) {\n+            throw new AssertionError(\n+                    \"Unnecessary boxing of void returning expression lambda result:\\n\\n\" + out);\n+        }\n+    }\n+}\n+\n+class T {\n+    int g() {\n+        return 0;\n+    }\n+\n+    Runnable r = () -> g();\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/VoidReturnBoxing.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339 8335896\n@@ -280,0 +280,21 @@\n+    @Test\n+    public void testThreadContextClassLoader(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \/\/language=java\n+                \"\"\"\n+                class ThreadContextClassLoader {\n+                    public static void main(String... args) {\n+                        var expected = ThreadContextClassLoader.class.getClassLoader();\n+                        var actual = Thread.currentThread().getContextClassLoader();\n+                        System.out.println(expected == actual);\n+                    }\n+                }\n+                \"\"\");\n+\n+        Path file = base.resolve(\"ThreadContextClassLoader.java\");\n+        String log = new JavaTask(tb)\n+                .className(file.toString())\n+                .run(Task.Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDOUT);\n+        checkEqual(\"stdout\", log.trim(), \"true\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335817\n+ * @summary Verify synthetic catches for deconstruction patterns work properly in expression lambdas\n+ * @compile MatchExceptionLambdaExpression.java\n+ * @run main MatchExceptionLambdaExpression\n+ *\/\n+public class MatchExceptionLambdaExpression {\n+\n+    public static void main(String[] args) {\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkPrimitiveVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkNonVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunVoidBox(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunNonVoid(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunNonVoid(new A(\"\", true), o -> checkNonVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    static void doRunPrimitiveVoid(Object inp, PrimitiveVoidFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void doRunVoidBox(Object inp, VoidBoxFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void doRunNonVoid(Object inp, NonVoidFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void checkPrimitiveVoid(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+    }\n+\n+    static Void checkVoidBox(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+        return null;\n+    }\n+\n+    static Object checkNonVoid(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+        return null;\n+    }\n+\n+    interface PrimitiveVoidFI {\n+        public void run(Object o);\n+    }\n+\n+    interface VoidBoxFI {\n+        public Void run(Object o);\n+    }\n+\n+    interface NonVoidFI {\n+        public Object run(Object o);\n+    }\n+\n+    record A(String s, boolean fail) {\n+        public String s() {\n+            if (fail) {\n+                throw new RequestedException();\n+            }\n+            return s;\n+        }\n+    }\n+\n+    static class RequestedException extends RuntimeException {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionLambdaExpression.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8336781\n+ * @summary Erroneous exhaustivity check with boolean switch\n+ * @enablePreview\n+ * @compile -XDshould-stop.at=FLOW T8336781.java\n+ *\/\n+public class T8336781 {\n+    public static void test() {\n+        Boolean bool = null;\n+        var _ = switch (bool) {\n+            case null -> \"nothing\";\n+            case true -> \"something true\";\n+            case false -> \"something false\";\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8336781.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ *      8332600\n@@ -139,0 +140,1 @@\n+        assertFail(\"compiler.err.already.defined\", \"record R(int x, int x, int x) {}\");\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.BiConsumer;\n@@ -53,1 +54,3 @@\n-    int expectedExitCode = 0;\n+    \/\/validator for exit codes, first parameter is the exit code\n+    \/\/the second the test name:\n+    private BiConsumer<Integer, String> exitCodeValidator = null;\n@@ -70,1 +73,1 @@\n-        expect(expect, Integer.MIN_VALUE);\n+        expect(expect, (_, _) -> {});\n@@ -86,0 +89,34 @@\n+    \/**\n+     * Sets the expected outcome of the task and calls {@code run()}.\n+     * @param expect the expected outcome\n+     * @param exitCodeValidator an exit code validator. The first parameter will\n+     *                          be the actual exit code, the second test name,\n+     *                          should throw TaskError if the exit code is not\n+     *                          as expected. Only used if the expected outcome\n+     *                          is {@code FAIL}\n+     * @return the result of calling {@code run()}\n+     *\/\n+    public Result run(Expect expect,\n+                      BiConsumer<Integer, String> exitCodeValidator) {\n+        expect(expect, exitCodeValidator);\n+        return run();\n+    }\n+\n+    \/**\n+     * Sets the expected outcome and expected exit code of the task.\n+     * The exit code will not be checked if the outcome is\n+     * {@code Expect.SUCCESS} or if the exit code is set to\n+     * {@code Integer.MIN_VALUE}.\n+     * @param expect the expected outcome\n+     * @param expectedExitCode the expected exit code\n+     *\/\n+    protected void expect(Expect expect, int expectedExitCode) {\n+        expect(expect, (exitCode, testName) -> {\n+            if (expectedExitCode != Integer.MIN_VALUE &&\n+                exitCode != expectedExitCode) {\n+                throw new TaskError(\"Task \" + testName + \"failed with unexpected exit code \"\n+                    + exitCode + \", expected \" + expectedExitCode);\n+            }\n+        });\n+    }\n+\n@@ -92,1 +129,5 @@\n-     * @param exitCode the expected exit code\n+     * @param exitCodeValidator an exit code validator. The first parameter will\n+     *                          be the actual exit code, the second test name,\n+     *                          should throw TaskError if the exit code is not\n+     *                          as expected. Only used if the expected outcome\n+     *                          is {@code FAIL}\n@@ -94,1 +135,2 @@\n-    protected void expect(Expect expect, int exitCode) {\n+    protected void expect(Expect expect,\n+                          BiConsumer<Integer, String> exitCodeValidator) {\n@@ -96,1 +138,1 @@\n-        this.expectedExitCode = exitCode;\n+        this.exitCodeValidator = exitCodeValidator;\n@@ -122,2 +164,3 @@\n-                if (expectedExitCode != Integer.MIN_VALUE\n-                        && result.exitCode != expectedExitCode) {\n+                try {\n+                    exitCodeValidator.accept(result.exitCode, name());\n+                } catch (Throwable t) {\n@@ -125,2 +168,1 @@\n-                    throw new TaskError(\"Task \" + name() + \"failed with unexpected exit code \"\n-                        + result.exitCode + \", expected \" + expectedExitCode);\n+                    throw t;\n","filename":"test\/langtools\/tools\/lib\/toolbox\/AbstractTask.java","additions":51,"deletions":9,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -317,0 +317,20 @@\n+    @Override\n+    public Result run(Expect expect) {\n+        int expectedExitCode = expect == Expect.SUCCESS ? 0 : 1;\n+\n+        return run(expect, (exitCode, testName) -> {\n+            if (exitCode == 4) {\n+                throw new TaskError(\"Task \" + testName + \" failed due to a javac crash \"\n+                    + \"(exit code 4)\");\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public Result run(Expect expect, int exitCode) {\n+        if (exitCode == 4) {\n+            throw new IllegalArgumentException(\"Disallowed exit code: 4\");\n+        }\n+        return super.run(expect, exitCode);\n+    }\n+\n","filename":"test\/langtools\/tools\/lib\/toolbox\/JavacTask.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.time.Duration;\n@@ -964,0 +965,9 @@\n+            }\n+            return rslt;\n+        }\n+\n+        @Override\n+        public boolean waitFor(Duration duration) throws InterruptedException {\n+            boolean rslt = p.waitFor(duration);\n+            if (rslt) {\n+                waitForStreams();\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.thread;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+\n+\/**\n+ * Helper class to allow tests run virtual threads with a custom scheduler.\n+ *\n+ * Tests using this class need to open java.base\/java.lang.\n+ *\/\n+public class VThreadScheduler {\n+    private VThreadScheduler() { }\n+\n+    \/**\n+     * Returns the scheduler for the given virtual thread.\n+     *\/\n+    public static Executor scheduler(Thread thread) {\n+        if (!thread.isVirtual())\n+            throw new IllegalArgumentException(\"Not a virtual thread\");\n+        try {\n+            Field scheduler = Class.forName(\"java.lang.VirtualThread\")\n+                    .getDeclaredField(\"scheduler\");\n+            scheduler.setAccessible(true);\n+            return (Executor) scheduler.get(thread);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Return true if custom schedulers are supported.\n+     *\/\n+    public static boolean supportsCustomScheduler() {\n+        try (var pool = Executors.newCachedThreadPool()) {\n+            try {\n+                virtualThreadBuilder(pool);\n+                return true;\n+            } catch (UnsupportedOperationException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     * @throws UnsupportedOperationException if custom schedulers are not supported\n+     *\/\n+    public static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a ThreadFactory to create virtual threads that use the given scheduler.\n+     * @throws UnsupportedOperationException if custom schedulers are not supported\n+     *\/\n+    public static ThreadFactory virtualThreadFactory(Executor scheduler) {\n+        return virtualThreadBuilder(scheduler).factory();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadScheduler.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -102,1 +102,5 @@\n-  \/\/ Make sure class name is in the correct format\n+\n+  \/\/ Returns the potentially abridged form of `str` as it would be\n+  \/\/ printed by the VM.\n+  public native String printString(String str, int maxLength);\n+\n@@ -104,0 +108,1 @@\n+    \/\/ Make sure class name is in the correct format\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-        JLONG, BOOLEAN, STRING, NANOTIME, STRINGARRAY, MEMORYSIZE\n+        JLONG, BOOLEAN, STRING, NANOTIME, STRINGARRAY, MEMORYSIZE, FILE\n","filename":"test\/lib\/jdk\/test\/whitebox\/parser\/DiagnosticCommand.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,0 +222,12 @@\n+\n+    public static void main(String... args) {\n+        StringConcat concat = new StringConcat();\n+        concat.concat4String();\n+        concat.concat123String();\n+        concat.concat6String();\n+        concat.concat13String();\n+        concat.concat23String();\n+        concat.concatConstInt();\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,354 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmarks stressing String concat startup. Provides a main method that takes names of the sub-benchmarks\n+ * of choice as arguments to work well as a standalone startup test\/diagnostic\n+ *\n+ *   StringSingle\n+ *   MixedSmall - small number of mixed expressions\n+ *   StringLarge - large number of expressions with a mix of String arguments and constants\n+ *   MixedLarge - large number of expressions with a mix of constants, Strings and primivitive arguments\n+ *\/\n+public class StringConcatStartup {\n+\n+    public static void main(String... args) {\n+        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        if (args.length > 0) {\n+            selection = args;\n+        }\n+        for (String select : selection) {\n+            switch (select) {\n+                case \"StringSingle\" -> new StringSingle().run();\n+                case \"MixedSmall\" -> new MixedSmall().run();\n+                case \"StringLarge\" -> new StringLarge().run();\n+                case \"MixedLarge\" -> new MixedLarge().run();\n+            }\n+        }\n+    }\n+\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringSingle {\n+\n+        public String s = \"foo\";\n+\n+        @Benchmark\n+        public String run() {\n+            return \"\" + s;\n+        }\n+    }\n+\n+\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 20, warmups = 2)\n+    public static class MixedSmall {\n+\n+        public String s = \"foo\";\n+        public int i = 17;\n+        public long l = 21L;\n+        public char c = 'a';\n+        public boolean z = true;\n+\n+        @Benchmark\n+        public String run() {\n+            String concat;\n+            concat = \"foo\" + s + \"bar\" + i + \"baz\" + l + \"bur\" + c + \"dub\" + z + \"foo\";\n+            concat = \"bar\" + i + \"baz\" + l + c + \"dub\" + z + \"foo\";\n+            concat = \"bar\" + i + \"baz\" + l + \"dub\" + z;\n+            concat = s + \"bar\" + i + s + \"bur\" + c + \"dub\" + s + \"foo\";\n+            return concat;\n+        }\n+    }\n+\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 10, warmups = 2)\n+    public static class StringLarge {\n+\n+        public String i = \"1\";\n+        public String l = \"2\";\n+        public String b = \"3\";\n+        public String s = \"4\";\n+        public String c = \"5\";\n+        public String S = \"6\";\n+        public String z = \"7\";\n+        public String f = \"8\";\n+        public String d = \"9\";\n+\n+        @Benchmark\n+        public void run() {\n+            String concat;\n+            concat = \"\" + \"S\" + f + l + z + f + \"S\" + d + S + d + S;\n+            concat = \"\" + \"S\" + S + i + b + b + z + i + s + S + b + \"S\";\n+            concat = \"\" + S + f + f + f + b + f + \"S\" + S + S + i + b;\n+            concat = \"\" + b + l + i + l + b + S + i + i + f + z;\n+            concat = \"\" + f + z + d + b + \"S\" + c + S + f + s + s + d;\n+            concat = \"\" + f + b + d + d + l + s + s + b + l + c + z;\n+            concat = \"\" + S + z + l + s + s + i + f + c + i + i + d;\n+            concat = \"\" + b + \"S\" + c + d + \"S\" + d + s + \"S\" + f + c + l + \"S\" + i + z + d + \"S\";\n+            concat = \"\" + S + \"S\" + S + i + c + z + i + i + S + b;\n+            concat = \"\" + S + S + d + s + z + f + z + i + b + s + s + \"S\";\n+            concat = \"\" + i + z + f + d + f + S + c + \"S\" + i;\n+            concat = \"\" + c + c + c + \"S\" + S + l;\n+            concat = \"\" + z + d + s + i + l + i + z + c + i + f + l + s + b + S + S + s + z + \"S\" + c + z;\n+            concat = \"\" + d + b + l + S + s + b + \"S\" + c + d + c + c + l + d + S + b + l + b + S + d + \"S\";\n+            concat = \"\" + c + z + c + d + b + S + c + b + S + \"S\" + d + s + c + s + b + c + b + z + s + i;\n+            concat = \"\" + l + S + \"S\";\n+            concat = \"\" + s + i + f + S + f + i + s + d + S + l + i + \"S\" + i + S + d + i + l + c + i + d;\n+            concat = \"\" + S + l + s + i + b + f + z + c + S + d + s + f + l + i + s + b + f + s + d + l;\n+            concat = \"\" + i + d + b + d + S + b + d + \"S\" + \"S\" + i + l + i + b + \"S\" + \"S\" + s + \"S\" + i + b + c;\n+            concat = \"\" + \"S\" + l + \"S\" + s + d + l + i + l + z + s + i + z + b + b + c + S + d + d + s + i;\n+            concat = \"\" + b + c + i + b + z + d + z + z + d + z + l + b + z + f + b + c + d + c + z + c;\n+            concat = \"\" + b + z + f + b + z + f + s + z + f + \"S\" + l + f + l + z + b + z + i + l + i + S;\n+            concat = \"\" + c + b + \"S\" + z;\n+            concat = \"\" + b + \"S\" + i + \"S\" + S + i + l + c + i + c + z + z + d + \"S\" + z + z + c + z + z + i;\n+            concat = \"\" + f + c + c + \"S\" + c + s + i + z + b + s + f + b + i + i + z + f + d + f + i + i;\n+            concat = \"\" + d + s + z + l + s + d + S + i + S + s + i + c + b + c + s + \"S\" + d + S + f + s;\n+            concat = \"\" + S + f + s + z + d + d + S + s + s + z + f + z + \"S\" + i + d + d + S + c + S + \"S\";\n+            concat = \"\" + c + c + b + S + \"S\" + \"S\" + d + S + s + b + c + d + z + c + b + i + S + z + i + s;\n+            concat = \"\" + l + l + d + z + s + s + i + i + l + c + f + z + i + f + l + z + s + d + f + l;\n+            concat = \"\" + f + d + \"S\" + s;\n+            concat = \"\" + d + S + \"S\" + S + f + \"S\" + c + i + s + b + c + b + l + f + S + c + c + i + z + s;\n+            concat = \"\" + z + \"S\" + s + S + s + d + d + s + f + \"S\" + f + \"S\" + i + S + \"S\" + c + l + b + f + f;\n+            concat = \"\" + l + f + d + b + s + f + d + \"S\" + l + s + \"S\" + b + b + s + S + S + \"S\" + \"S\" + d + b;\n+            concat = \"\" + b + l + f + b + S + f + z + s + S + f + b + b + s + s + b + s + l + d + l;\n+            concat = \"\" + b + b + S + S + S + z + z + d + \"S\" + l + \"S\" + s + i + \"S\" + c + f + S + f + i;\n+            concat = \"\" + l + l + f + i + S + s + \"S\" + \"S\" + z + d + \"S\" + l + d + b + f + f + l + b + b;\n+            concat = \"\" + l + f + \"S\" + f + f + i + l + l + i + S + b + f + d + i + c + c + d + d + i;\n+            concat = \"\" + l + b + s + d + i + i + d + c + \"S\" + s + f + d + z + d + S + c;\n+            concat = \"\" + f + s + \"S\" + z + s + \"S\" + b + b + b + d + d + b + z + l + c + b;\n+            concat = \"\" + l + d + \"S\" + b + z + z + f + c + z + c + c + c + c + d;\n+            concat = \"\" + z + d + l + \"S\" + i + s + b + b + d + s + s;\n+            concat = \"\" + f + i + d + S + f + f + i + s + d + S + c + l + d + s + c + i;\n+            concat = \"\" + f + c + i + \"S\" + \"S\" + c + f + b + l + i + s + c + i + S + S + i;\n+            concat = \"\" + z + S + z + d + d + S + \"S\" + f + d + s + s + \"S\" + l + z + l + c;\n+            concat = \"\" + b + c + s + f + S + l + b + f + \"S\" + l + \"S\" + c + c + z + b + b;\n+            concat = \"\" + c + b + z + s + d + l + l + S + l + \"S\" + f + S + c + f + s + f;\n+            concat = \"\" + z + z + d + i + z + s + z + S + f + S + \"S\" + \"S\" + l + d + c + d;\n+            concat = \"\" + c + S + s + f + c + i + b + l + S + c + l + f + f + l + i + l;\n+            concat = \"\" + \"S\" + i + f + d + s + S + S + l + s + S + l + \"S\" + b + l + s + l + d + d + f + S;\n+            concat = \"\" + l + z + c + l + f + f + d + s + l + b + d + f + S + S + \"S\" + i + i + s + f + i;\n+            concat = \"\" + S + S + l + S + z + d + s + c + \"S\" + d + f + d + f + f + z + i + f + l + S + s;\n+            concat = \"\" + z + d + z + l + f + s + d + z + i + S + S + d + i + z + c + i + i + f + b + \"S\";\n+            concat = \"\" + b + d + \"S\" + f + f + d + s + i + b + l + i + b + f + f + b + f + l + i + z + l;\n+            concat = \"\" + c + z + s + \"S\" + z + f + \"S\" + i + f + s + l + i + \"S\" + d + i + b + i + S + b + l;\n+            concat = \"\" + d + l + s + c + l + d + \"S\" + \"S\" + s + S + f + z + b + s + b + f + z + z + l + l;\n+            concat = \"\" + f + b + \"S\" + s + i + \"S\" + s + f + c + f + c + f + i + i + b + i + i + b + S + S;\n+            concat = \"\" + i + i + s + i + s + S + s + \"S\" + c + c + f + s + d + l + l + d + f + l + i + S;\n+            concat = \"\" + z + d + z + \"S\" + c + i + f + s + b + S + i + c + s + b + c + f + s + z + f + c;\n+            concat = \"\" + f + s + f + b + l + z + f + f + f + c + z + S + b + s + z + i + s + S + i + b;\n+            concat = \"\" + d + i + S + b + i + \"S\" + l + S + S + S + z + i + z + b;\n+            concat = \"\" + \"S\" + S + s + l + f + i + l + b + f + S + d + c + b + d;\n+            concat = \"\" + c + i + i + d + S + z + c + i + c + S + f + i + c + c;\n+            concat = \"\" + \"S\" + \"S\" + c + d + z + l + d + z + f + b + d + z + S + f;\n+            concat = \"\" + b + d + z + d + i + z + d + b + d + \"S\" + c + f + d;\n+            concat = \"\" + d + s + f + c + i + \"S\" + b + b + S + i + s + d + \"S\" + f;\n+            concat = \"\" + l + S + d + b + S + s + \"S\" + s + s + l + S + \"S\" + c + d;\n+            concat = \"\" + c + s + z + c + S + S + \"S\" + l + S + f + f + c + S + f;\n+            concat = \"\" + d + i + s + c + z + \"S\" + d + f + \"S\" + S + c + b + \"S\" + c;\n+            concat = \"\" + i + b + \"S\" + l + S + d + \"S\" + c + b + s + f + l + f + \"S\";\n+            concat = \"\" + c + b + f + \"S\" + S + s + i + l + s + z + z + f + l + b;\n+            concat = \"\" + S + s + \"S\" + d + s + z + \"S\" + i + i + z + S + b + f + i;\n+            concat = \"\" + z + S + S + \"S\" + S + S + z + b + S + z + b + f + s + l;\n+            concat = \"\" + s + z + d + \"S\" + z + l + f + z + s + z + d + l + s + l;\n+            concat = \"\" + l + d + i + s + i + c + i + f + b + f + s + b + s + s;\n+            concat = \"\" + z + \"S\" + S + \"S\" + \"S\" + i + \"S\" + s + d + z + l;\n+            concat = \"\" + i + S + S + \"S\" + f + \"S\" + \"S\" + z + S + z + b + z + c + b;\n+            concat = \"\" + i + f + f + d + z + f + z + b + \"S\" + c + l + l + z + s + S + s;\n+            concat = \"\" + b + b + z + \"S\" + f + s + \"S\" + l +c + S + i + i + b + \"S\" + S;\n+            concat = \"\" + i + \"S\" + d + d + d + \"S\" + f + \"S\" + b + s + S + i + \"S\" + d + b;\n+            concat = \"\" + s + f + b + d + c + d + c + S + S + b + i + b + z + c;\n+            concat = \"\" + l + l + S + l + f + s + i + c + z + f + d + l + f + b + l + f + f + i + i + z;\n+            concat = \"\" + l + l + l + l + s + s + f + i + i + f + z + c + S + s + f + \"S\" + \"S\" + s + z + s;\n+            concat = \"\" + S + z + f + b + l + c + i + l;\n+            concat = \"\" + c + z + b + f + i + i + f + d + f + f + d + d + l + d + S + \"S\" + i + c + b + f;\n+            concat = \"\" + s + d + S + d + b + l + l + f + b + \"S\" + i + z + b + S + S + c + S + f + S + z;\n+            concat = \"\" + l + S + S + i + l + s + d + f + z + i + \"S\" + b + f + c + z + c + S + c + i + s;\n+            concat = \"\" + l + S + S + s + f + S + s + \"S\" + c + c + c;\n+            concat = \"\" + s + \"S\" + c + d + z + c + l + c + z + S + i + f + c + c + s + \"S\" + S + z + s + \"S\";\n+            concat = \"\" + c + i + z + s + b + s + s + b + \"S\" + d + \"S\" + z + f + \"S\" + c + S + s + S + b + i;\n+            concat = \"\" + s + c + d + d + \"S\" + \"S\" + l + s + i + l + l + f + S + f + f + i + S + d + l + c;\n+            concat = \"\" + \"S\" + S + b + c + i + \"S\" + c + c + s + i + \"S\" + b + i + b + b + S + f + l + s + \"S\";\n+            concat = \"\" + l + l + b + f + i + i + f + z + c + S + b + f + z + \"S\" + s + z + \"S\" + f + S + s;\n+            concat = \"\" + i + c + b + i + b + z + \"S\" + i + c + i + l + \"S\" + z + b + b + i + i + c + i + f;\n+            concat = \"\" + \"S\" + c + d + z + d + f + c + c + b + \"S\" + l + f + d + \"S\" + s + s + S + i + s + i;\n+            concat = \"\" + S + \"S\" + d + c + \"S\" + S + \"S\" + b + f + z + \"S\" + l + d + f + \"S\" + S + d + b + c + c;\n+            concat = \"\" + f + S + l + s + l + z + S + d + S + b + f + c + s + b + \"S\" + z + \"S\" + \"S\" + b + z;\n+            concat = \"\" + f + s + c + i + S + b + s + S + i + S + c + b + s + d + i + \"S\" + s + l + c + s;\n+            concat = \"\" + l + f + s + b + d + b + i + c + c + b + s + f + i + z + s + i + s + \"S\" + l + z;\n+            concat = \"\" + d + z + z + c + b + b + s + b + S + l + d + i + S + d + \"S\" + i + S + i + b + S;\n+            concat = \"\" + c + d + \"S\" + f + i + b + d + c + z + f + \"S\" + i + d + b + f + s + \"S\" + c + S + i;\n+            concat = \"\" + i + z + \"S\" + b + S + s + c + s + f + S + S + f + z + s + b + d + z + i + s + z;\n+            concat = \"\" + z + s + z + l + \"S\" + S + s + \"S\" + i + b + c + s + l + l + s + i + c + i + i + d;\n+            concat = \"\" + \"S\" + b + l + z + c + f + l + S + \"S\" + l + i + z + z + l + S + \"S\" + z + S + z + c + \"S\";\n+            concat = \"\" + \"S\" + f + S + i + i + i + \"S\" + i + i + l + c + l + S + S + z + b + i + c + f + S;\n+            concat = \"\" + c + z + S + S + b + i + c;\n+            concat = \"\" + S + s + S + c;\n+        }\n+    }\n+\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 10, warmups = 2)\n+    public static class MixedLarge {\n+\n+        public int i = 17;\n+        public long l = 21L;\n+        public byte b = (byte)17;\n+        public short s = (short)17;\n+        public char c = 'a';\n+        public String S = \"S\";\n+        public float f = 1.0f;\n+        public double d = 2.0;\n+        public boolean z = true;\n+\n+        @Benchmark\n+        public void run() {\n+            String concat;\n+            concat = \"\" + \"S\" + f + l + z + f + \"S\" + d + S + d + S;\n+            concat = \"\" + \"S\" + S + i + b + b + z + i + s + S + b + \"S\";\n+            concat = \"\" + S + f + f + f + b + f + \"S\" + S + S + i + b;\n+            concat = \"\" + b + l + i + l + b + S + i + i + f + z;\n+            concat = \"\" + f + z + d + b + \"S\" + c + S + f + s + s + d;\n+            concat = \"\" + f + b + d + d + l + s + s + b + l + c + z;\n+            concat = \"\" + S + z + l + s + s + i + f + c + i + i + d;\n+            concat = \"\" + b + \"S\" + c + d + \"S\" + d + s + \"S\" + f + c + l + \"S\" + i + z + d + \"S\";\n+            concat = \"\" + S + \"S\" + S + i + c + z + i + i + S + b;\n+            concat = \"\" + S + S + d + s + z + f + z + i + b + s + s + \"S\";\n+            concat = \"\" + i + z + f + d + f + S + c + \"S\" + i;\n+            concat = \"\" + c + c + c + \"S\" + S + l;\n+            concat = \"\" + z + d + s + i + l + i + z + c + i + f + l + s + b + S + S + s + z + \"S\" + c + z;\n+            concat = \"\" + d + b + l + S + s + b + \"S\" + c + d + c + c + l + d + S + b + l + b + S + d + \"S\";\n+            concat = \"\" + c + z + c + d + b + S + c + b + S + \"S\" + d + s + c + s + b + c + b + z + s + i;\n+            concat = \"\" + l + S + \"S\";\n+            concat = \"\" + s + i + f + S + f + i + s + d + S + l + i + \"S\" + i + S + d + i + l + c + i + d;\n+            concat = \"\" + S + l + s + i + b + f + z + c + S + d + s + f + l + i + s + b + f + s + d + l;\n+            concat = \"\" + i + d + b + d + S + b + d + \"S\" + \"S\" + i + l + i + b + \"S\" + \"S\" + s + \"S\" + i + b + c;\n+            concat = \"\" + \"S\" + l + \"S\" + s + d + l + i + l + z + s + i + z + b + b + c + S + d + d + s + i;\n+            concat = \"\" + b + c + i + b + z + d + z + z + d + z + l + b + z + f + b + c + d + c + z + c;\n+            concat = \"\" + b + z + f + b + z + f + s + z + f + \"S\" + l + f + l + z + b + z + i + l + i + S;\n+            concat = \"\" + c + b + \"S\" + z;\n+            concat = \"\" + b + \"S\" + i + \"S\" + S + i + l + c + i + c + z + z + d + \"S\" + z + z + c + z + z + i;\n+            concat = \"\" + f + c + c + \"S\" + c + s + i + z + b + s + f + b + i + i + z + f + d + f + i + i;\n+            concat = \"\" + d + s + z + l + s + d + S + i + S + s + i + c + b + c + s + \"S\" + d + S + f + s;\n+            concat = \"\" + S + f + s + z + d + d + S + s + s + z + f + z + \"S\" + i + d + d + S + c + S + \"S\";\n+            concat = \"\" + c + c + b + S + \"S\" + \"S\" + d + S + s + b + c + d + z + c + b + i + S + z + i + s;\n+            concat = \"\" + l + l + d + z + s + s + i + i + l + c + f + z + i + f + l + z + s + d + f + l;\n+            concat = \"\" + f + d + \"S\" + s;\n+            concat = \"\" + d + S + \"S\" + S + f + \"S\" + c + i + s + b + c + b + l + f + S + c + c + i + z + s;\n+            concat = \"\" + z + \"S\" + s + S + s + d + d + s + f + \"S\" + f + \"S\" + i + S + \"S\" + c + l + b + f + f;\n+            concat = \"\" + l + f + d + b + s + f + d + \"S\" + l + s + \"S\" + b + b + s + S + S + \"S\" + \"S\" + d + b;\n+            concat = \"\" + b + l + f + b + S + f + z + s + S + f + b + b + s + s + b + s + l + d + l;\n+            concat = \"\" + b + b + S + S + S + z + z + d + \"S\" + l + \"S\" + s + i + \"S\" + c + f + S + f + i;\n+            concat = \"\" + l + l + f + i + S + s + \"S\" + \"S\" + z + d + \"S\" + l + d + b + f + f + l + b + b;\n+            concat = \"\" + l + f + \"S\" + f + f + i + l + l + i + S + b + f + d + i + c + c + d + d + i;\n+            concat = \"\" + l + b + s + d + i + i + d + c + \"S\" + s + f + d + z + d + S + c;\n+            concat = \"\" + f + s + \"S\" + z + s + \"S\" + b + b + b + d + d + b + z + l + c + b;\n+            concat = \"\" + l + d + \"S\" + b + z + z + f + c + z + c + c + c + c + d;\n+            concat = \"\" + z + d + l + \"S\" + i + s + b + b + d + s + s;\n+            concat = \"\" + f + i + d + S + f + f + i + s + d + S + c + l + d + s + c + i;\n+            concat = \"\" + f + c + i + \"S\" + \"S\" + c + f + b + l + i + s + c + i + S + S + i;\n+            concat = \"\" + z + S + z + d + d + S + \"S\" + f + d + s + s + \"S\" + l + z + l + c;\n+            concat = \"\" + b + c + s + f + S + l + b + f + \"S\" + l + \"S\" + c + c + z + b + b;\n+            concat = \"\" + c + b + z + s + d + l + l + S + l + \"S\" + f + S + c + f + s + f;\n+            concat = \"\" + z + z + d + i + z + s + z + S + f + S + \"S\" + \"S\" + l + d + c + d;\n+            concat = \"\" + c + S + s + f + c + i + b + l + S + c + l + f + f + l + i + l;\n+            concat = \"\" + \"S\" + i + f + d + s + S + S + l + s + S + l + \"S\" + b + l + s + l + d + d + f + S;\n+            concat = \"\" + l + z + c + l + f + f + d + s + l + b + d + f + S + S + \"S\" + i + i + s + f + i;\n+            concat = \"\" + S + S + l + S + z + d + s + c + \"S\" + d + f + d + f + f + z + i + f + l + S + s;\n+            concat = \"\" + z + d + z + l + f + s + d + z + i + S + S + d + i + z + c + i + i + f + b + \"S\";\n+            concat = \"\" + b + d + \"S\" + f + f + d + s + i + b + l + i + b + f + f + b + f + l + i + z + l;\n+            concat = \"\" + c + z + s + \"S\" + z + f + \"S\" + i + f + s + l + i + \"S\" + d + i + b + i + S + b + l;\n+            concat = \"\" + d + l + s + c + l + d + \"S\" + \"S\" + s + S + f + z + b + s + b + f + z + z + l + l;\n+            concat = \"\" + f + b + \"S\" + s + i + \"S\" + s + f + c + f + c + f + i + i + b + i + i + b + S + S;\n+            concat = \"\" + i + i + s + i + s + S + s + \"S\" + c + c + f + s + d + l + l + d + f + l + i + S;\n+            concat = \"\" + z + d + z + \"S\" + c + i + f + s + b + S + i + c + s + b + c + f + s + z + f + c;\n+            concat = \"\" + f + s + f + b + l + z + f + f + f + c + z + S + b + s + z + i + s + S + i + b;\n+            concat = \"\" + d + i + S + b + i + \"S\" + l + S + S + S + z + i + z + b;\n+            concat = \"\" + \"S\" + S + s + l + f + i + l + b + f + S + d + c + b + d;\n+            concat = \"\" + c + i + i + d + S + z + c + i + c + S + f + i + c + c;\n+            concat = \"\" + \"S\" + \"S\" + c + d + z + l + d + z + f + b + d + z + S + f;\n+            concat = \"\" + b + d + z + d + i + z + d + b + d + \"S\" + c + f + d;\n+            concat = \"\" + d + s + f + c + i + \"S\" + b + b + S + i + s + d + \"S\" + f;\n+            concat = \"\" + l + S + d + b + S + s + \"S\" + s + s + l + S + \"S\" + c + d;\n+            concat = \"\" + c + s + z + c + S + S + \"S\" + l + S + f + f + c + S + f;\n+            concat = \"\" + d + i + s + c + z + \"S\" + d + f + \"S\" + S + c + b + \"S\" + c;\n+            concat = \"\" + i + b + \"S\" + l + S + d + \"S\" + c + b + s + f + l + f + \"S\";\n+            concat = \"\" + c + b + f + \"S\" + S + s + i + l + s + z + z + f + l + b;\n+            concat = \"\" + S + s + \"S\" + d + s + z + \"S\" + i + i + z + S + b + f + i;\n+            concat = \"\" + z + S + S + \"S\" + S + S + z + b + S + z + b + f + s + l;\n+            concat = \"\" + s + z + d + \"S\" + z + l + f + z + s + z + d + l + s + l;\n+            concat = \"\" + l + d + i + s + i + c + i + f + b + f + s + b + s + s;\n+            concat = \"\" + z + \"S\" + S + \"S\" + \"S\" + i + \"S\" + s + d + z + l;\n+            concat = \"\" + i + S + S + \"S\" + f + \"S\" + \"S\" + z + S + z + b + z + c + b;\n+            concat = \"\" + i + f + f + d + z + f + z + b + \"S\" + c + l + l + z + s + S + s;\n+            concat = \"\" + b + b + z + \"S\" + f + s + \"S\" + l +c + S + i + i + b + \"S\" + S;\n+            concat = \"\" + i + \"S\" + d + d + d + \"S\" + f + \"S\" + b + s + S + i + \"S\" + d + b;\n+            concat = \"\" + s + f + b + d + c + d + c + S + S + b + i + b + z + c;\n+            concat = \"\" + l + l + S + l + f + s + i + c + z + f + d + l + f + b + l + f + f + i + i + z;\n+            concat = \"\" + l + l + l + l + s + s + f + i + i + f + z + c + S + s + f + \"S\" + \"S\" + s + z + s;\n+            concat = \"\" + S + z + f + b + l + c + i + l;\n+            concat = \"\" + c + z + b + f + i + i + f + d + f + f + d + d + l + d + S + \"S\" + i + c + b + f;\n+            concat = \"\" + s + d + S + d + b + l + l + f + b + \"S\" + i + z + b + S + S + c + S + f + S + z;\n+            concat = \"\" + l + S + S + i + l + s + d + f + z + i + \"S\" + b + f + c + z + c + S + c + i + s;\n+            concat = \"\" + l + S + S + s + f + S + s + \"S\" + c + c + c;\n+            concat = \"\" + s + \"S\" + c + d + z + c + l + c + z + S + i + f + c + c + s + \"S\" + S + z + s + \"S\";\n+            concat = \"\" + c + i + z + s + b + s + s + b + \"S\" + d + \"S\" + z + f + \"S\" + c + S + s + S + b + i;\n+            concat = \"\" + s + c + d + d + \"S\" + \"S\" + l + s + i + l + l + f + S + f + f + i + S + d + l + c;\n+            concat = \"\" + \"S\" + S + b + c + i + \"S\" + c + c + s + i + \"S\" + b + i + b + b + S + f + l + s + \"S\";\n+            concat = \"\" + l + l + b + f + i + i + f + z + c + S + b + f + z + \"S\" + s + z + \"S\" + f + S + s;\n+            concat = \"\" + i + c + b + i + b + z + \"S\" + i + c + i + l + \"S\" + z + b + b + i + i + c + i + f;\n+            concat = \"\" + \"S\" + c + d + z + d + f + c + c + b + \"S\" + l + f + d + \"S\" + s + s + S + i + s + i;\n+            concat = \"\" + S + \"S\" + d + c + \"S\" + S + \"S\" + b + f + z + \"S\" + l + d + f + \"S\" + S + d + b + c + c;\n+            concat = \"\" + f + S + l + s + l + z + S + d + S + b + f + c + s + b + \"S\" + z + \"S\" + \"S\" + b + z;\n+            concat = \"\" + f + s + c + i + S + b + s + S + i + S + c + b + s + d + i + \"S\" + s + l + c + s;\n+            concat = \"\" + l + f + s + b + d + b + i + c + c + b + s + f + i + z + s + i + s + \"S\" + l + z;\n+            concat = \"\" + d + z + z + c + b + b + s + b + S + l + d + i + S + d + \"S\" + i + S + i + b + S;\n+            concat = \"\" + c + d + \"S\" + f + i + b + d + c + z + f + \"S\" + i + d + b + f + s + \"S\" + c + S + i;\n+            concat = \"\" + i + z + \"S\" + b + S + s + c + s + f + S + S + f + z + s + b + d + z + i + s + z;\n+            concat = \"\" + z + s + z + l + \"S\" + S + s + \"S\" + i + b + c + s + l + l + s + i + c + i + i + d;\n+            concat = \"\" + \"S\" + b + l + z + c + f + l + S + \"S\" + l + i + z + z + l + S + \"S\" + z + S + z + c + \"S\";\n+            concat = \"\" + \"S\" + f + S + i + i + i + \"S\" + i + i + l + c + l + S + S + z + b + i + c + f + S;\n+            concat = \"\" + c + z + S + S + b + i + c;\n+            concat = \"\" + S + s + S + c;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":354,"deletions":0,"binary":false,"changes":354,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(1)\n+public class ConcurrentClose {\n+\n+    static final int SIZE = 10_000;\n+    static final VarHandle BYTES = MethodHandles.arrayElementVarHandle(byte[].class);\n+\n+    MemorySegment segment;\n+    byte[] array;\n+\n+    @Setup\n+    public void setup() {\n+        segment = Arena.global().allocate(SIZE);\n+        array = new byte[SIZE];\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public void closing() {\n+        Arena arena = Arena.ofShared();\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public int memorySegmentAccess() {\n+        int sum = 0;\n+        for (long i = 0; i < segment.byteSize(); i++) {\n+            sum += segment.get(JAVA_BYTE, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    @GroupThreads(1)\n+    @Group(\"sharedClose\")\n+    public int otherAccess() {\n+        int sum = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            sum += (byte) BYTES.get(array, i);\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ConcurrentClose.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -39,2 +39,3 @@\n- * Benchmark measuring the speed of Method\/Method.getExceptionTypes() and\n- * getParameterTypes(), in cases where the result array is length zero.\n+ * Benchmark measuring the speed of Method\/Method.getExceptionTypes(),\n+ * getParameterTypes() in cases where the result array is length zero,\n+ * and hashCode().\n@@ -53,0 +54,1 @@\n+    Method hashCodeMethod;\n@@ -61,0 +63,2 @@\n+\n+            hashCodeMethod = String.class.getDeclaredMethod(\"toString\");\n@@ -85,0 +89,5 @@\n+\n+    @Benchmark\n+    public int getMethodHashCode() {\n+        return hashCodeMethod.hashCode();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/MethodBenchmark.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.DateFormat;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class DateFormatterBench {\n+\n+    private Date date;\n+\n+    private Object objDate;\n+\n+    @Setup\n+    public void setup() {\n+        date = new Date();\n+        objDate = new Date();\n+    }\n+\n+    private DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL, Locale.ENGLISH);\n+\n+    @Benchmark\n+    public String testFormatDate() {\n+        return dateFormat.format(date);\n+    }\n+\n+    @Benchmark\n+    public String testFormatObject() {\n+        return dateFormat.format(objDate);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(DateFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DateFormatterBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.ListFormat;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ListFormatterBench {\n+\n+    private List<String> data;\n+\n+    @Setup\n+    public void setup() {\n+        data = List.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"quuz\");\n+    }\n+\n+    private ListFormat listFormat = ListFormat.getInstance();\n+\n+    @Benchmark\n+    public String testListFormat() {\n+        return listFormat.format(data);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(ListFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/ListFormatterBench.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class MessageFormatterBench {\n+\n+    private Object[][] values;\n+\n+    @Setup\n+    public void setup() {\n+        values = new Object[][]{\n+                new Object[]{Integer.valueOf(13), \"MyDisk1\"},\n+                new Object[]{Float.valueOf(25.6f), \"MyDisk2\"},\n+                new Object[]{Double.valueOf(123.89), \"MyDisk3\"},\n+                new Object[]{Long.valueOf(1234567), \"MyDisk4\"},\n+        };\n+    }\n+\n+    private MessageFormat messageFormat = new MessageFormat(\"There is {0} GB of free space on the {1}.\", Locale.ENGLISH);\n+\n+    @Benchmark\n+    @OperationsPerInvocation(4)\n+    public void testMessageFormat(final Blackhole bh) {\n+        for (Object[] value : values) {\n+            bh.consume(messageFormat.format(value));\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(MessageFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/MessageFormatterBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class ToStringBench {\n+    private static final Instant[] INSTANTS;\n+    private static final ZonedDateTime[] ZONED_DATE_TIMES;\n+    private static final LocalDateTime[] LOCAL_DATE_TIMES;\n+    private static final LocalDate[] LOCAL_DATES;\n+    private static final LocalTime[] LOCAL_TIMES;\n+\n+    static {\n+        Instant loInstant = Instant.EPOCH.plus(Duration.ofDays(365*50)); \/\/ 2020-01-01\n+        Instant hiInstant = loInstant.plus(Duration.ofDays(1));\n+        long maxOffsetNanos = Duration.between(loInstant, hiInstant).toNanos();\n+        Random random = new Random(0);\n+        INSTANTS = IntStream\n+                .range(0, 1_000)\n+                .mapToObj(ignored -> {\n+                    final long offsetNanos = (long) Math.floor(random.nextDouble() * maxOffsetNanos);\n+                    return loInstant.plus(offsetNanos, ChronoUnit.NANOS);\n+                })\n+                .toArray(Instant[]::new);\n+\n+        ZONED_DATE_TIMES = Stream.of(INSTANTS)\n+                .map(instant -> ZonedDateTime.ofInstant(instant, ZoneOffset.UTC))\n+                .toArray(ZonedDateTime[]::new);\n+\n+        LOCAL_DATE_TIMES = Stream.of(ZONED_DATE_TIMES)\n+                .map(zdt -> zdt.toLocalDateTime())\n+                .toArray(LocalDateTime[]::new);\n+\n+        LOCAL_DATES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalDate())\n+                .toArray(LocalDate[]::new);\n+\n+        LOCAL_TIMES = Stream.of(LOCAL_DATE_TIMES)\n+                .map(ldt -> ldt.toLocalTime())\n+                .toArray(LocalTime[]::new);\n+    }\n+\n+    @Benchmark\n+    public void zonedDateTimeToString(Blackhole bh) {\n+        for (final ZonedDateTime zonedDateTime : ZONED_DATE_TIMES) {\n+            bh.consume(zonedDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void localDateTimeToString(Blackhole bh) {\n+        for (LocalDateTime localDateTime : LOCAL_DATE_TIMES) {\n+            bh.consume(localDateTime.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void localDateToString(Blackhole bh) {\n+        for (LocalDate localDate : LOCAL_DATES) {\n+            bh.consume(localDate.toString());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void localTimeToString(Blackhole bh) {\n+        for (LocalTime localTime : LOCAL_TIMES) {\n+            bh.consume(localTime.toString());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/ToStringBench.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-            cm.forEachElement(ce -> {\n+            cm.forEach(ce -> {\n@@ -106,1 +106,1 @@\n-                    mm.forEachElement(me -> {\n+                    mm.forEach(me -> {\n@@ -108,1 +108,1 @@\n-                            xm.forEachElement(xe -> {\n+                            xm.forEach(xe -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadDeep.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-                                xm.forEachElement(new Consumer<>() {\n+                                xm.forEach(new Consumer<>() {\n@@ -259,1 +259,1 @@\n-                                       cm.forEachElement(cb);\n+                                       cm.forEach(cb);\n@@ -290,1 +290,1 @@\n-                                       cm.forEachElement(element -> {\n+                                       cm.forEach(element -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -33,0 +32,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -151,1 +152,1 @@\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              ACC_PUBLIC | ACC_STATIC,\n@@ -199,1 +200,1 @@\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,1132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.nio.ByteOrder;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+public class MergeStoreBench {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    final static VarHandle INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN);\n+    final static VarHandle INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN);\n+    final static VarHandle LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);\n+    final static VarHandle LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN);\n+    final static VarHandle CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN);\n+    final static VarHandle CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n+\n+    final static int NUMBERS = 8192;\n+\n+    final byte[] bytes4 = new byte[NUMBERS * 4];\n+    final byte[] bytes8 = new byte[NUMBERS * 8];\n+    final int [] ints   = new int [NUMBERS    ];\n+    final long[] longs  = new long[NUMBERS    ];\n+    final char[] chars  = new char[NUMBERS    ];\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+        for (int i = 0; i < ints.length; i++) {\n+            ints[i] = r.nextInt();\n+            INT_L.set(bytes4, i * 4, i);\n+        }\n+\n+        for (int i = 0; i < longs.length; i++) {\n+            longs[i] = r.nextLong();\n+            LONG_L.set(bytes8, i * 8, i);\n+        }\n+    }\n+\n+    \/*\n+     * The names of these cases have the following `B\/L\/V\/U` suffixes, which are:\n+     * ```\n+     * B BigEndian\n+     * L LittleEndian\n+     * V VarHandle\n+     * U Unsafe\n+     * R ReverseBytes\n+     * C Unsafe.getChar & putChar\n+     * S Unsafe.getShort & putShort\n+     * ```\n+     *\/\n+\n+    @Benchmark\n+    public void getIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_B.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_L.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += Integer.reverseBytes(\n+                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntB(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntBU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            INT_B.set(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntL(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntLU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            INT_L.set(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRB(bytes4, i * 4, ints[i]);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRBU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRL(bytes4, i * 4, ints[i]);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRLU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            v = Integer.reverseBytes(v);\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_B.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_L.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += Long.reverseBytes(\n+                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongB(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongBU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            LONG_B.set(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongL(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongLU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            LONG_L.set(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRB(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRBU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRL(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRLU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            v = Long.reverseBytes(v);\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharB(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_B.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharBU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharL(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+    @Benchmark\n+    public void getCharLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharLU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+\n+    @Benchmark\n+    public void getCharLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_L.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharC(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = UNSAFE.getChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setCharBS(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+            putShortB(bytes4, i * 2, c);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setCharBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+            CHAR_B.set(bytes4, i * 2, c);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setCharLS(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+            putShortL(bytes4, i * 2, c);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setCharLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+            CHAR_L.set(bytes4, i * 2, c);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setCharC(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+            UNSAFE.putChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2, c);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    \/*\n+     * putChars4 Test whether four constant chars can be MergeStored\n+     *\n+     *\/\n+    @Benchmark\n+    public void putChars4B(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4B(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4BU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4BU(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4BV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4BV(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4L(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4L(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4LU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4LU(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4LV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4LV(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4C(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4C(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4S(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4S(bytes8, i * 4);\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    static int getIntB(byte[] array, int offset) {\n+        return ((array[offset    ] & 0xff) << 24)\n+             | ((array[offset + 1] & 0xff) << 16)\n+             | ((array[offset + 2] & 0xff) <<  8)\n+             | ((array[offset + 3] & 0xff)      );\n+    }\n+\n+    static int getIntBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n+    }\n+\n+    static int getIntL(byte[] array, int offset) {\n+        return ((array[offset       ] & 0xff)      )\n+                | ((array[offset + 1] & 0xff) <<  8)\n+                | ((array[offset + 2] & 0xff) << 16)\n+                | ((array[offset + 3] & 0xff) << 24);\n+    }\n+\n+    static int getIntRB(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntB(array, offset));\n+    }\n+\n+    static int getIntRBU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntBU(array, offset));\n+    }\n+\n+    static int getIntRL(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntL(array, offset));\n+    }\n+\n+    static int getIntRLU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntLU(array, offset));\n+    }\n+\n+    static void setIntB(byte[] array, int offset, int value) {\n+        array[offset    ] = (byte) (value >> 24);\n+        array[offset + 1] = (byte) (value >> 16);\n+        array[offset + 2] = (byte) (value >>  8);\n+        array[offset + 3] = (byte) (value      );\n+    }\n+\n+    static void setIntBU(byte[] array, int offset, int value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 1, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 3, (byte) (value      ));\n+    }\n+\n+    public static void setIntL(byte[] array, int offset, int value) {\n+        array[offset    ] = (byte)  value;\n+        array[offset + 1] = (byte) (value >> 8);\n+        array[offset + 2] = (byte) (value >> 16);\n+        array[offset + 3] = (byte) (value >> 24);\n+    }\n+\n+    public static void setIntLU(byte[] array, int offset, int value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte)  value       );\n+        UNSAFE.putByte(array, address + 1, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 24));\n+    }\n+\n+    public static void setIntRL(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntL(array, offset, value);\n+    }\n+\n+    public static void setIntRLU(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntLU(array, offset, value);\n+    }\n+\n+    public static void setIntRB(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntB(array, offset, value);\n+    }\n+\n+    public static void setIntRBU(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntBU(array, offset, value);\n+    }\n+\n+    static long getLongB(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff) << 56)\n+             | (((long) array[offset + 1] & 0xff) << 48)\n+             | (((long) array[offset + 2] & 0xff) << 40)\n+             | (((long) array[offset + 3] & 0xff) << 32)\n+             | (((long) array[offset + 4] & 0xff) << 24)\n+             | (((long) array[offset + 5] & 0xff) << 16)\n+             | (((long) array[offset + 6] & 0xff) << 8)\n+             | (((long) array[offset + 7] & 0xff)     );\n+    }\n+\n+    static long getLongBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n+    }\n+\n+    public static long getLongL(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff)      )\n+             | (((long) array[offset + 1] & 0xff) <<  8)\n+             | (((long) array[offset + 2] & 0xff) << 16)\n+             | (((long) array[offset + 3] & 0xff) << 24)\n+             | (((long) array[offset + 4] & 0xff) << 32)\n+             | (((long) array[offset + 5] & 0xff) << 40)\n+             | (((long) array[offset + 6] & 0xff) << 48)\n+             | (((long) array[offset + 7] & 0xff) << 56);\n+    }\n+\n+    static long getLongLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n+    }\n+\n+    static long getLongRB(byte[] array, int offset) {\n+        return getLongB(array, offset);\n+    }\n+\n+    static long getLongRBU(byte[] array, int offset) {\n+        return getLongBU(array, offset);\n+    }\n+\n+    static long getLongRL(byte[] array, int offset) {\n+        return getLongL(array, offset);\n+    }\n+\n+    static long getLongRLU(byte[] array, int offset) {\n+        return getLongLU(array, offset);\n+    }\n+\n+    static void setLongB(byte[] array, int offset, long value) {\n+        array[offset]     = (byte) (value >> 56);\n+        array[offset + 1] = (byte) (value >> 48);\n+        array[offset + 2] = (byte) (value >> 40);\n+        array[offset + 3] = (byte) (value >> 32);\n+        array[offset + 4] = (byte) (value >> 24);\n+        array[offset + 5] = (byte) (value >> 16);\n+        array[offset + 6] = (byte) (value >>  8);\n+        array[offset + 7] = (byte) (value      );\n+    }\n+\n+    public static void setLongL(byte[] array, int offset, long value) {\n+        array[offset]     = (byte)  value       ;\n+        array[offset + 1] = (byte) (value >> 8 );\n+        array[offset + 2] = (byte) (value >> 16);\n+        array[offset + 3] = (byte) (value >> 24);\n+        array[offset + 4] = (byte) (value >> 32);\n+        array[offset + 5] = (byte) (value >> 40);\n+        array[offset + 6] = (byte) (value >> 48);\n+        array[offset + 7] = (byte) (value >> 56);\n+    }\n+\n+    public static void setLongRL(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongL(array, offset, value);\n+    }\n+\n+    public static void setLongRLU(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongLU(array, offset, value);\n+    }\n+\n+    public static void setLongRB(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongB(array, offset, value);\n+    }\n+\n+    public static void setLongRBU(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongBU(array, offset, value);\n+    }\n+\n+    public static void setLongBU(byte[] array, int offset, long value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte) (value >> 56));\n+        UNSAFE.putByte(array, address + 1, (byte) (value >> 48));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 40));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 32));\n+        UNSAFE.putByte(array, address + 4, (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 5, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 6, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 7, (byte)  value       );\n+    }\n+\n+    public static void setLongLU(byte[] array, int offset, long value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte)  value       );\n+        UNSAFE.putByte(array, address + 1, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 4, (byte) (value >> 32));\n+        UNSAFE.putByte(array, address + 5, (byte) (value >> 40));\n+        UNSAFE.putByte(array, address + 6, (byte) (value >> 48));\n+        UNSAFE.putByte(array, address + 7, (byte) (value >> 56));\n+    }\n+\n+    public static int getIntLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+    }\n+\n+    public static char getCharB(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff) << 8)\n+                    | ((val[index + 1] & 0xff)));\n+    }\n+\n+    public static char getCharBR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharB(val, index));\n+    }\n+\n+    public static char getCharL(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff))\n+                    | ((val[index + 1] & 0xff) << 8));\n+    }\n+\n+    public static char getCharLR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharL(val, index));\n+    }\n+\n+    public static char getCharBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff) << 8)\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff)     ));\n+    }\n+\n+    public static char getCharLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff)     )\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff) << 8));\n+    }\n+\n+    public void putChars4B(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        putShortB(bytes, offset    , c0);\n+        putShortB(bytes, offset + 1, c1);\n+        putShortB(bytes, offset + 2, c2);\n+        putShortB(bytes, offset + 3, c3);\n+    }\n+\n+    public void putChars4BU(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        putShortBU(bytes, offset    , c0);\n+        putShortBU(bytes, offset + 1, c1);\n+        putShortBU(bytes, offset + 2, c2);\n+        putShortBU(bytes, offset + 3, c3);\n+    }\n+\n+    public void putChars4BV(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        offset <<= 1;\n+        CHAR_B.set(bytes, offset    , c0);\n+        CHAR_B.set(bytes, offset + 2, c1);\n+        CHAR_B.set(bytes, offset + 4, c2);\n+        CHAR_B.set(bytes, offset + 6, c3);\n+    }\n+\n+    public void putChars4L(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        putShortL(bytes, offset    , c0);\n+        putShortL(bytes, offset + 1, c1);\n+        putShortL(bytes, offset + 2, c2);\n+        putShortL(bytes, offset + 3, c3);\n+    }\n+\n+    public void putChars4LV(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        offset <<= 1;\n+        CHAR_L.set(bytes, offset    , c0);\n+        CHAR_L.set(bytes, offset + 2, c1);\n+        CHAR_L.set(bytes, offset + 4, c2);\n+        CHAR_L.set(bytes, offset + 6, c3);\n+    }\n+\n+    public void putChars4LU(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        putShortLU(bytes, offset    , c0);\n+        putShortLU(bytes, offset + 1, c1);\n+        putShortLU(bytes, offset + 2, c2);\n+        putShortLU(bytes, offset + 3, c3);\n+    }\n+\n+    public void putChars4C(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        UNSAFE.putChar(bytes, address    , c0);\n+        UNSAFE.putChar(bytes, address + 2, c1);\n+        UNSAFE.putChar(bytes, address + 4, c2);\n+        UNSAFE.putChar(bytes, address + 6, c3);\n+    }\n+\n+    public void putChars4S(byte[] bytes, int offset) {\n+        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        UNSAFE.putShort(bytes, address    , (short) c0);\n+        UNSAFE.putShort(bytes, address + 2, (short) c1);\n+        UNSAFE.putShort(bytes, address + 4, (short) c2);\n+        UNSAFE.putShort(bytes, address + 6, (short) c3);\n+    }\n+\n+    private static void putShortB(byte[] val, int index, int c) {\n+        index <<= 1;\n+        val[index    ] = (byte)(c >> 8);\n+        val[index + 1] = (byte)(c     );\n+    }\n+\n+    public static void putShortBU(byte[] array, int offset, int c) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        UNSAFE.putByte(array, address    , (byte) (c >>  8));\n+        UNSAFE.putByte(array, address + 1, (byte) (c      ));\n+    }\n+\n+    private static void putShortL(byte[] val, int index, int c) {\n+        index <<= 1;\n+        val[index    ] = (byte)(c     );\n+        val[index + 1] = (byte)(c >> 8);\n+    }\n+\n+    public static void putShortLU(byte[] array, int offset, int c) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        UNSAFE.putByte(array, address    , (byte) (c     ));\n+        UNSAFE.putByte(array, address + 1, (byte) (c >> 8));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStoreBench.java","additions":1132,"deletions":0,"binary":false,"changes":1132,"status":"added"}]}