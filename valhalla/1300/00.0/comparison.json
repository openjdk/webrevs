{"files":[{"patch":"@@ -393,2 +393,2 @@\n-    common.boot_jdk_version = \"22\";\n-    common.boot_jdk_build_number = \"36\";\n+    common.boot_jdk_version = \"23\";\n+    common.boot_jdk_build_number = \"37\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"22 23 24\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"23 24\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2716,1 +2716,1 @@\n-      \/\/ Fix up any out-of-range offsets.\n+      \/* Fix up any out-of-range offsets. *\/\n@@ -2757,5 +2757,1 @@\n-      \/\/ Fix up any out-of-range offsets.\n-      assert_different_registers(rscratch1, base);\n-      Address addr = Address(base, disp);\n-      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n-      (masm->*insn)(reg, T, addr);\n+      (masm->*insn)(reg, T, Address(base, disp));\n@@ -2816,1 +2812,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n@@ -2824,1 +2820,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n@@ -2832,1 +2828,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n@@ -2840,1 +2836,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n@@ -2848,1 +2844,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n@@ -2856,1 +2852,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n@@ -2864,1 +2860,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n@@ -2872,1 +2868,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n@@ -2880,1 +2876,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n@@ -2888,1 +2884,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n@@ -2896,1 +2892,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n@@ -2904,1 +2900,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n@@ -2912,1 +2908,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n@@ -2920,1 +2916,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n@@ -2928,1 +2924,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n@@ -2936,1 +2932,1 @@\n-  enc_class aarch64_enc_strb0(memory mem) %{\n+  enc_class aarch64_enc_strb0(memory1 mem) %{\n@@ -2943,1 +2939,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n@@ -2951,1 +2947,1 @@\n-  enc_class aarch64_enc_strh0(memory mem) %{\n+  enc_class aarch64_enc_strh0(memory2 mem) %{\n@@ -2958,1 +2954,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n@@ -2966,1 +2962,1 @@\n-  enc_class aarch64_enc_strw0(memory mem) %{\n+  enc_class aarch64_enc_strw0(memory4 mem) %{\n@@ -2973,1 +2969,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n@@ -2988,1 +2984,1 @@\n-  enc_class aarch64_enc_str0(memory mem) %{\n+  enc_class aarch64_enc_str0(memory8 mem) %{\n@@ -2995,1 +2991,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n@@ -3003,1 +2999,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n@@ -3011,1 +3007,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n@@ -3213,1 +3209,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n@@ -3241,1 +3237,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n@@ -4200,1 +4196,1 @@\n-\/\/ Offset for immediate loads and stores\n+\/\/ Offset for scaled or unscaled immediate loads and stores\n@@ -4203,1 +4199,51 @@\n-  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset1()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset2()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset4()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset8()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset16()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n@@ -4221,0 +4267,50 @@\n+operand immLoffset1()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset2()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset4()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset8()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset16()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5133,1 +5229,15 @@\n-operand indOffI(iRegP reg, immIOffset off)\n+operand indOffI1(iRegP reg, immIOffset1 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI2(iRegP reg, immIOffset2 off)\n@@ -5147,1 +5257,99 @@\n-operand indOffL(iRegP reg, immLOffset off)\n+operand indOffI4(iRegP reg, immIOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI8(iRegP reg, immIOffset8 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI16(iRegP reg, immIOffset16 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL1(iRegP reg, immLoffset1 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL2(iRegP reg, immLoffset2 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL4(iRegP reg, immLoffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL8(iRegP reg, immLoffset8 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL16(iRegP reg, immLoffset16 off)\n@@ -5523,1 +5731,4 @@\n-opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n+opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n+opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n+opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n+opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n@@ -5535,3 +5746,17 @@\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n-               indOffLN, indirectX2P, indOffX2P);\n+opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n+\n+opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n+\n+opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n+opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n+\/\/ All of the memory operands. For the pipeline description.\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n+               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n@@ -6239,1 +6464,1 @@\n-instruct loadB(iRegINoSp dst, memory mem)\n+instruct loadB(iRegINoSp dst, memory1 mem)\n@@ -6253,1 +6478,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory mem)\n+instruct loadB2L(iRegLNoSp dst, memory1 mem)\n@@ -6267,1 +6492,1 @@\n-instruct loadUB(iRegINoSp dst, memory mem)\n+instruct loadUB(iRegINoSp dst, memory1 mem)\n@@ -6281,1 +6506,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory mem)\n+instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n@@ -6295,1 +6520,1 @@\n-instruct loadS(iRegINoSp dst, memory mem)\n+instruct loadS(iRegINoSp dst, memory2 mem)\n@@ -6309,1 +6534,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory mem)\n+instruct loadS2L(iRegLNoSp dst, memory2 mem)\n@@ -6323,1 +6548,1 @@\n-instruct loadUS(iRegINoSp dst, memory mem)\n+instruct loadUS(iRegINoSp dst, memory2 mem)\n@@ -6337,1 +6562,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory mem)\n+instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n@@ -6351,1 +6576,1 @@\n-instruct loadI(iRegINoSp dst, memory mem)\n+instruct loadI(iRegINoSp dst, memory4 mem)\n@@ -6365,1 +6590,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory mem)\n+instruct loadI2L(iRegLNoSp dst, memory4 mem)\n@@ -6379,1 +6604,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n@@ -6393,1 +6618,1 @@\n-instruct loadL(iRegLNoSp dst, memory mem)\n+instruct loadL(iRegLNoSp dst, memory8 mem)\n@@ -6407,1 +6632,1 @@\n-instruct loadRange(iRegINoSp dst, memory mem)\n+instruct loadRange(iRegINoSp dst, memory4 mem)\n@@ -6420,1 +6645,1 @@\n-instruct loadP(iRegPNoSp dst, memory mem)\n+instruct loadP(iRegPNoSp dst, memory8 mem)\n@@ -6434,1 +6659,1 @@\n-instruct loadN(iRegNNoSp dst, memory mem)\n+instruct loadN(iRegNNoSp dst, memory4 mem)\n@@ -6448,1 +6673,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory mem)\n+instruct loadKlass(iRegPNoSp dst, memory8 mem)\n@@ -6462,1 +6687,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory mem)\n+instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n@@ -6476,1 +6701,1 @@\n-instruct loadF(vRegF dst, memory mem)\n+instruct loadF(vRegF dst, memory4 mem)\n@@ -6490,1 +6715,1 @@\n-instruct loadD(vRegD dst, memory mem)\n+instruct loadD(vRegD dst, memory8 mem)\n@@ -6694,1 +6919,1 @@\n-instruct storeimmCM0(immI0 zero, memory mem)\n+instruct storeimmCM0(immI0 zero, memory1 mem)\n@@ -6709,1 +6934,1 @@\n-instruct storeimmCM0_ordered(immI0 zero, memory mem)\n+instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n@@ -6724,1 +6949,1 @@\n-instruct storeB(iRegIorL2I src, memory mem)\n+instruct storeB(iRegIorL2I src, memory1 mem)\n@@ -6738,1 +6963,1 @@\n-instruct storeimmB0(immI0 zero, memory mem)\n+instruct storeimmB0(immI0 zero, memory1 mem)\n@@ -6752,1 +6977,1 @@\n-instruct storeC(iRegIorL2I src, memory mem)\n+instruct storeC(iRegIorL2I src, memory2 mem)\n@@ -6765,1 +6990,1 @@\n-instruct storeimmC0(immI0 zero, memory mem)\n+instruct storeimmC0(immI0 zero, memory2 mem)\n@@ -6780,1 +7005,1 @@\n-instruct storeI(iRegIorL2I src, memory mem)\n+instruct storeI(iRegIorL2I src, memory4 mem)\n@@ -6793,1 +7018,1 @@\n-instruct storeimmI0(immI0 zero, memory mem)\n+instruct storeimmI0(immI0 zero, memory4 mem)\n@@ -6807,1 +7032,1 @@\n-instruct storeL(iRegL src, memory mem)\n+instruct storeL(iRegL src, memory8 mem)\n@@ -6821,1 +7046,1 @@\n-instruct storeimmL0(immL0 zero, memory mem)\n+instruct storeimmL0(immL0 zero, memory8 mem)\n@@ -6835,1 +7060,1 @@\n-instruct storeP(iRegP src, memory mem)\n+instruct storeP(iRegP src, memory8 mem)\n@@ -6849,1 +7074,1 @@\n-instruct storeimmP0(immP0 zero, memory mem)\n+instruct storeimmP0(immP0 zero, memory8 mem)\n@@ -6863,1 +7088,1 @@\n-instruct storeN(iRegN src, memory mem)\n+instruct storeN(iRegN src, memory4 mem)\n@@ -6876,1 +7101,1 @@\n-instruct storeImmN0(immN0 zero, memory mem)\n+instruct storeImmN0(immN0 zero, memory4 mem)\n@@ -6890,1 +7115,1 @@\n-instruct storeF(vRegF src, memory mem)\n+instruct storeF(vRegF src, memory4 mem)\n@@ -6907,1 +7132,1 @@\n-instruct storeD(vRegD src, memory mem)\n+instruct storeD(vRegD src, memory8 mem)\n@@ -6921,1 +7146,1 @@\n-instruct storeNKlass(iRegN src, memory mem)\n+instruct storeNKlass(iRegN src, memory4 mem)\n@@ -6940,1 +7165,1 @@\n-instruct prefetchalloc( memory mem ) %{\n+instruct prefetchalloc( memory8 mem ) %{\n@@ -7512,1 +7737,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n@@ -7553,1 +7778,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n@@ -16758,1 +16983,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n@@ -16795,1 +17020,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n@@ -16832,1 +17057,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n@@ -16870,1 +17095,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":309,"deletions":84,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -1221,2 +1221,2 @@\n-    __ ldrb(rscratch1, Address(op->klass()->as_register(),\n-                               InstanceKlass::init_state_offset()));\n+    __ lea(rscratch1, Address(op->klass()->as_register(), InstanceKlass::init_state_offset()));\n+    __ ldarb(rscratch1, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1881,1 +1881,2 @@\n-  ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));\n+  lea(scratch, Address(klass, InstanceKlass::init_state_offset()));\n+  ldarb(scratch, scratch);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -39,1 +40,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7345,0 +7345,22 @@\n+  \/\/ load Method* target of MethodHandle\n+  \/\/ j_rarg0 = jobject receiver\n+  \/\/ rmethod = result\n+  address generate_upcall_stub_load_target() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    address start = __ pc();\n+\n+    __ resolve_global_jobject(j_rarg0, rscratch1, rscratch2);\n+      \/\/ Load target method from receiver\n+    __ load_heap_oop(rmethod, Address(j_rarg0, java_lang_invoke_MethodHandle::form_offset()), rscratch1, rscratch2);\n+    __ load_heap_oop(rmethod, Address(rmethod, java_lang_invoke_LambdaForm::vmentry_offset()), rscratch1, rscratch2);\n+    __ load_heap_oop(rmethod, Address(rmethod, java_lang_invoke_MemberName::method_offset()), rscratch1, rscratch2);\n+    __ access_load_at(T_ADDRESS, IN_HEAP, rmethod,\n+                      Address(rmethod, java_lang_invoke_ResolvedMethodName::vmtarget_offset()),\n+                      noreg, noreg);\n+    __ str(rmethod, Address(rthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8402,0 +8424,1 @@\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -71,1 +72,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -2007,7 +2008,15 @@\n-  aep = __ pc();  __ push_ptr();  __ b(L);\n-  fep = __ pc();  __ push_f();    __ b(L);\n-  dep = __ pc();  __ push_d();    __ b(L);\n-  lep = __ pc();  __ push_l();    __ b(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ b(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f();\n+      __ b(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d();\n+      __ b(L);\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ b(L);\n+  bep = cep = sep = iep = __ pc();     \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();     \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -52,1 +53,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -951,0 +951,1 @@\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2277,0 +2277,1 @@\n+    \/\/ acquire barrier included in membar_storestore() which follows the allocation immediately.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2353,0 +2353,1 @@\n+    \/\/ init_state needs acquire, but S390 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1618,0 +1618,1 @@\n+    \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-    testl(monitor, monitor);            \/\/ Fast Unlock ZF = 0\n+    orl(t, 1); \/\/ Fast Unlock ZF = 0\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5400,1 +5400,2 @@\n-  \/\/ Fast path check: class is fully initialized\n+  \/\/ Fast path check: class is fully initialized.\n+  \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -3815,0 +3816,22 @@\n+\/\/ load Method* target of MethodHandle\n+\/\/ j_rarg0 = jobject receiver\n+\/\/ rbx = result\n+address StubGenerator::generate_upcall_stub_load_target() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+  address start = __ pc();\n+\n+  __ resolve_global_jobject(j_rarg0, r15_thread, rscratch1);\n+    \/\/ Load target method from receiver\n+  __ load_heap_oop(rbx, Address(j_rarg0, java_lang_invoke_MethodHandle::form_offset()), rscratch1);\n+  __ load_heap_oop(rbx, Address(rbx, java_lang_invoke_LambdaForm::vmentry_offset()), rscratch1);\n+  __ load_heap_oop(rbx, Address(rbx, java_lang_invoke_MemberName::method_offset()), rscratch1);\n+  __ access_load_at(T_ADDRESS, IN_HEAP, rbx,\n+                    Address(rbx, java_lang_invoke_ResolvedMethodName::vmtarget_offset()),\n+                    noreg, noreg);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -4128,0 +4151,1 @@\n+  StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n@@ -4333,2 +4357,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4339,1 +4363,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4342,1 +4366,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4347,2 +4371,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4352,1 +4376,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4355,1 +4379,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4358,1 +4382,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4361,1 +4385,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4364,1 +4388,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4367,1 +4391,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -623,0 +623,1 @@\n+  address generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4370,0 +4370,1 @@\n+  \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+#ifndef PRODUCT\n@@ -456,0 +457,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -655,1 +655,1 @@\n-  trace_new_stub(blob, \"UpcallStub\");\n+  trace_new_stub(blob, \"UpcallStub - \", name);\n@@ -804,0 +804,4 @@\n+  st->print_cr(\"Frame data offset: %d\", (int) _frame_data_offset);\n+  oop recv = JNIHandles::resolve(_receiver);\n+  st->print(\"Receiver MH=\");\n+  recv->print_on(st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -334,1 +334,2 @@\n-      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+      \/\/ Pre-barriers are unnecessary for tightly-coupled initialization stores.\n+      access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4389,1 +4389,1 @@\n-  _init_state = state;\n+  Atomic::release_store(&_init_state, state);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -601,6 +601,6 @@\n-  bool is_loaded() const                   { return _init_state >= loaded; }\n-  bool is_linked() const                   { return _init_state >= linked; }\n-  bool is_initialized() const              { return _init_state == fully_initialized; }\n-  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n-  bool is_being_initialized() const        { return _init_state == being_initialized; }\n-  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_loaded() const                   { return init_state() >= loaded; }\n+  bool is_linked() const                   { return init_state() >= linked; }\n+  bool is_initialized() const              { return init_state() == fully_initialized; }\n+  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n+  bool is_being_initialized() const        { return init_state() == being_initialized; }\n+  bool is_in_error_state() const           { return init_state() == initialization_error; }\n@@ -608,1 +608,1 @@\n-  ClassState  init_state() const           { return _init_state; }\n+  ClassState  init_state() const           { return Atomic::load_acquire(&_init_state); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -398,0 +398,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -401,0 +407,144 @@\n+\/\/ Try to convert a serial of additions into a single multiplication. Also convert `(a * CON) + a` to `(CON + 1) * a` as\n+\/\/ a side effect. On success, a new MulNode is returned.\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n+\n+  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; \/\/ +1 for the in2 term\n+\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a + a`. On success, return `a` and set `2` as `multiplier`.\n+\/\/ The method matches `n` for pattern: AddNode(a, a).\n+Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    *multiplier = 2;\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a << CON`. On success, return `a` and set `1 << CON` as `multiplier`.\n+\/\/ Match `n` for pattern: LShiftNode(a, CON).\n+\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n+Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = ((jlong) 1 << con->get_int());\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `CON * a`. On success, return `a` and set `CON` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - MulNode(CON, a)\n+\/\/     - MulNode(a, CON)\n+Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we might as match MulNode(a, CON), too.\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ swap ConNode to lhs for easier matching\n+    if (!con->is_Con()) {\n+      swap(con, base);\n+    }\n+\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = con->get_integer_as_long(bt);\n+    return base;\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return `a` and set `(1 << CON1) + (1 << CON2)` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+\/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+\/\/ given that lhs is different from rhs.\n+\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0). Calling this function with `multiplier`\n+\/\/ being null is safe.\n+Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    Node* lhs = n->in(1);\n+    Node* rhs = n->in(2);\n+\n+    \/\/ swap LShiftNode to lhs for easier matching\n+    if (lhs->Opcode() != Op_LShift(bt)) {\n+      swap(lhs, rhs);\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), *)?\n+    if (lhs->Opcode() != Op_LShift(bt) || !lhs->in(2)->is_Con()) {\n+      return nullptr;\n+    }\n+\n+    jlong lhs_multiplier = 0;\n+    if (multiplier != nullptr) {\n+      Node* con = lhs->in(2);\n+      if (con->is_top()) {\n+        return nullptr;\n+      }\n+\n+      lhs_multiplier = (jlong) 1 << con->get_int();\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), a)?\n+    if (lhs->in(1) == rhs) {\n+      if (multiplier != nullptr) {\n+        *multiplier = lhs_multiplier + 1;\n+      }\n+\n+      return rhs;\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n+    if (rhs->Opcode() == Op_LShift(bt) && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n+      if (multiplier != nullptr) {\n+        Node* con = rhs->in(2);\n+        if (con->is_top()) {\n+          return nullptr;\n+        }\n+\n+        *multiplier = lhs_multiplier + ((jlong) 1 << con->get_int());\n+      }\n+\n+      return lhs->in(1);\n+    }\n+    return nullptr;\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -73,0 +73,8 @@\n+  develop(bool, StressBailout, false,                                       \\\n+          \"Perform bailouts randomly at C2 failing() checks\")               \\\n+                                                                            \\\n+  develop(uint, StressBailoutMean, 100000,                                  \\\n+          \"The expected number of failing() checks made until \"             \\\n+          \"a random bailout.\")                                              \\\n+          range(1, max_juint)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -771,1 +771,1 @@\n-          if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+          if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,0 +482,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -554,0 +557,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps) {\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout) {\n@@ -814,1 +814,1 @@\n-      record_method_not_compilable(ss.as_string());\n+      record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n@@ -1000,1 +1000,1 @@\n-  if (StressLCM || StressGCM) {\n+  if (StressLCM || StressGCM || StressBailout) {\n@@ -1045,0 +1045,1 @@\n+  _phase_verify_ideal_loop = false;\n@@ -1139,1 +1140,1 @@\n-  assert(failing() || s == start(), \"should be StartNode\");\n+  assert(failing_internal() || s == start(), \"should be StartNode\");\n@@ -1149,1 +1150,1 @@\n-  assert (!failing(), \"Must not have pending failure. Reason is: %s\", failure_reason());\n+  assert (!failing_internal() || C->failure_is_artificial(), \"Must not have pending failure. Reason is: %s\", failure_reason());\n@@ -1513,6 +1514,12 @@\n-      if (!ik->equals(canonical_holder) || tj->offset() != offset) {\n-        if( is_known_inst ) {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, Type::Offset(offset), to->instance_id());\n-        } else {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, Type::Offset(offset));\n-        }\n+      assert(tj->offset() == offset, \"no change to offset expected\");\n+      bool xk = to->klass_is_exact();\n+      int instance_id = to->instance_id();\n+\n+      \/\/ If the input type's class is the holder: if exact, the type only includes interfaces implemented by the holder\n+      \/\/ but if not exact, it may include extra interfaces: build new type from the holder class to make sure only\n+      \/\/ its interfaces are included.\n+      if (xk && ik->equals(canonical_holder)) {\n+        assert(tj == TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id), \"exact type should be canonical type\");\n+      } else {\n+        assert(xk || !is_known_inst, \"Known instance should be exact type\");\n+        tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, Type::Offset(offset), instance_id);\n@@ -2601,1 +2608,1 @@\n-      assert(!failing(), \"inconsistent\");\n+      assert(!failing_internal() || failure_is_artificial(), \"inconsistent\");\n@@ -2647,1 +2654,1 @@\n-      assert(!failing(), \"inconsistent\");\n+      assert(!failing_internal() || failure_is_artificial(), \"inconsistent\");\n@@ -3444,0 +3451,3 @@\n+  if (failing()) {\n+    return;\n+  }\n@@ -4853,1 +4863,1 @@\n-void Compile::record_failure(const char* reason) {\n+void Compile::record_failure(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures)) {\n@@ -4863,0 +4873,2 @@\n+  } else {\n+    assert(!StressBailout || allow_multiple_failures, \"should have handled previous failure.\");\n@@ -4890,1 +4902,3 @@\n-  if (_compile->failing()) return;\n+  if (_compile->failing_internal()) {\n+    return; \/\/ timing code, not stressing bailouts.\n+  }\n@@ -5609,0 +5623,16 @@\n+#ifdef ASSERT\n+\/\/ Failures are geometrically distributed with probability 1\/StressBailoutMean.\n+bool Compile::fail_randomly() {\n+  if ((random() % StressBailoutMean) != 0) {\n+    return false;\n+  }\n+  record_failure(\"StressBailout\");\n+  return true;\n+}\n+\n+bool Compile::failure_is_artificial() {\n+  assert(failing_internal(), \"should be failing\");\n+  return C->failure_reason_is(\"StressBailout\");\n+}\n+#endif\n+\n@@ -5696,1 +5726,1 @@\n-  if (failing()) { return; }\n+  if (failing_internal()) { return; } \/\/ failing_internal to not stress bailouts from printing code.\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -401,0 +401,2 @@\n+  DEBUG_ONLY(bool       _phase_verify_ideal_loop;) \/\/ Are we in PhaseIdealLoop verification?\n+\n@@ -808,0 +810,6 @@\n+#ifdef ASSERT\n+  bool       phase_verify_ideal_loop() const { return _phase_verify_ideal_loop; }\n+  void   set_phase_verify_ideal_loop() { _phase_verify_ideal_loop = true; }\n+  void reset_phase_verify_ideal_loop() { _phase_verify_ideal_loop = false; }\n+#endif\n+\n@@ -844,1 +852,1 @@\n-  bool        failing() const        {\n+  bool        failing_internal() const {\n@@ -856,0 +864,21 @@\n+  bool failing() {\n+    if (failing_internal()) {\n+      return true;\n+    }\n+#ifdef ASSERT\n+    \/\/ Disable stress code for PhaseIdealLoop verification (would have cascading effects).\n+    if (phase_verify_ideal_loop()) {\n+      return false;\n+    }\n+    if (StressBailout) {\n+      return fail_randomly();\n+    }\n+#endif\n+    return false;\n+  }\n+\n+#ifdef ASSERT\n+  bool fail_randomly();\n+  bool failure_is_artificial();\n+#endif\n+\n@@ -863,2 +892,2 @@\n-  void record_failure(const char* reason);\n-  void record_method_not_compilable(const char* reason) {\n+  void record_failure(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures = false));\n+  void record_method_not_compilable(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures = false)) {\n@@ -867,1 +896,1 @@\n-    record_failure(reason);\n+    record_failure(reason DEBUG_ONLY(COMMA allow_multiple_failures));\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -749,0 +749,15 @@\n+\n+  \/\/ We don't optimize the memory graph for pinned loads, so we may need to raise the\n+  \/\/ root of our search tree through the corresponding slices of MergeMem nodes to\n+  \/\/ get to the node that really creates the memory state for this slice.\n+  if (load_alias_idx >= Compile::AliasIdxRaw) {\n+    while (initial_mem->is_MergeMem()) {\n+      MergeMemNode* mm = initial_mem->as_MergeMem();\n+      Node* p = mm->memory_at(load_alias_idx);\n+      if (p != mm->base_memory()) {\n+        initial_mem = p;\n+      } else {\n+        break;\n+      }\n+    }\n+  }\n@@ -1515,2 +1530,2 @@\n-        assert(false, \"graph should be schedulable\");\n-        C->record_method_not_compilable(\"late schedule failed: incorrect graph\");\n+        assert(C->failure_is_artificial(), \"graph should be schedulable\");\n+        C->record_method_not_compilable(\"late schedule failed: incorrect graph\" DEBUG_ONLY(COMMA true));\n@@ -1696,2 +1711,2 @@\n-        assert(false, \"local schedule failed\");\n-        C->record_method_not_compilable(\"local schedule failed\");\n+        assert(C->failure_is_artificial(), \"local schedule failed\");\n+        C->record_method_not_compilable(\"local schedule failed\" DEBUG_ONLY(COMMA true));\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -355,1 +355,3 @@\n-  if (failing())  return;  \/\/ dying anyway...\n+  if (failing_internal()) {\n+    return;  \/\/ dying anyway...\n+  }\n@@ -461,1 +463,1 @@\n-  if (failing()) { stop(); return top(); }\n+  if (failing_internal()) { stop(); return top(); }\n@@ -1622,0 +1624,2 @@\n+  \/\/ Fix 8344108 and renable the commented assert\n+  \/\/assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -1652,0 +1656,2 @@\n+  \/\/ Fix 8344108 and renable the commented assert\n+  \/\/assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -2222,1 +2228,3 @@\n-  if (failing())  stop();\n+  if (failing_internal()) {\n+    stop();\n+  }\n@@ -3215,1 +3223,1 @@\n-                                    T_BYTE, MemNode::unordered);\n+                                    T_BYTE, MemNode::acquire);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    assert(failing() || !has_exceptions(),\n+    assert(failing_internal() || !has_exceptions(),\n@@ -196,0 +196,1 @@\n+  bool failing_internal() const { return C->failing_internal(); }\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-      assert(false, \"graph should be schedulable\");\n+      assert(C->failure_is_artificial(), \"graph should be schedulable\");\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3105,1 +3105,1 @@\n-    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n+    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::acquire);\n@@ -3165,1 +3165,0 @@\n-    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n@@ -3168,2 +3167,2 @@\n-    access_store_at(nullptr, jt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    access_store_at(nullptr, vt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n@@ -3531,1 +3530,3 @@\n-  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset,\n+                                             _gvn.type(threadObj_epoch_offset)->isa_ptr(),\n+                                             TypeInt::CHAR, T_CHAR,\n@@ -3550,1 +3551,2 @@\n-  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, _gvn.type(vthread_epoch_offset)->is_ptr(),\n+                                           TypeInt::CHAR, T_CHAR,\n@@ -3796,1 +3798,1 @@\n-  Node* epoch_raw = access_load_at(thread, epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* epoch_raw = access_load_at(thread, epoch_offset, _gvn.type(epoch_offset)->is_ptr(), TypeInt::CHAR, T_CHAR,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1136,0 +1136,1 @@\n+    DEBUG_ONLY(C->set_phase_verify_ideal_loop();)\n@@ -1137,0 +1138,1 @@\n+    DEBUG_ONLY(C->reset_phase_verify_ideal_loop();)\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,0 +241,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -322,0 +325,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -326,0 +332,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -421,1 +430,1 @@\n-      assert(_mach_null != nullptr, \"\");\n+      assert(_mach_null != nullptr || C->failure_is_artificial(), \"\"); \/\/ bailouts are handled below.\n@@ -439,1 +448,1 @@\n-    C->record_method_not_compilable(ss.as_string());\n+    C->record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n@@ -1481,0 +1490,3 @@\n+      if (C->failing()) {\n+        return nullptr;\n+      }\n@@ -1486,0 +1498,3 @@\n+      if (C->failing()) {\n+        return nullptr;\n+      }\n@@ -2730,0 +2745,4 @@\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"already failing.\");\n+  if (C->failing()) {\n+    return nullptr;\n+  }\n@@ -2760,1 +2779,4 @@\n-  assert(mspill != nullptr, \"matching failed: %d\", ideal_reg);\n+  assert(mspill != nullptr || C->failure_is_artificial(), \"matching failed: %d\", ideal_reg);\n+  if (C->failing()) {\n+    return nullptr;\n+  }\n@@ -2906,1 +2928,1 @@\n-  assert(!C->failing(), \"sanity\");\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1787,1 +1787,1 @@\n-      assert(!C->failing(), \"Should not reach here if failing.\");\n+      assert(!C->failing_internal() || C->failure_is_artificial(), \"Should not reach here if failing.\");\n@@ -3496,1 +3496,1 @@\n-  assert (!C->failing(), \"Must not have pending failure. Reason is: %s\", C->failure_reason());\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"Must not have pending failure. Reason is: %s\", C->failure_reason());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  bool failing()                { return C->failing(); }\n+  bool failing() const { return C->failing_internal(); } \/\/ might have cascading effects, not stressing bailouts for now.\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3062,0 +3062,1 @@\n+    ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n@@ -3064,1 +3065,1 @@\n-    MutexLocker mu(Threads_lock);\n+    MutexLocker ml(Threads_lock);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2250,1 +2250,2 @@\n-  return HeapShared::can_write();\n+  return HeapShared::can_write()\n+      && ArchiveHeapLoader::can_use(); \/\/ work-around JDK-8341371\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -745,0 +745,2 @@\n+    } else if (_cb->is_upcall_stub()) {\n+      st->print(\"v  ~UpcallStub::%s \" PTR_FORMAT, _cb->name(), p2i(pc()));\n@@ -1160,0 +1162,13 @@\n+void frame::oops_upcall_do(OopClosure* f, const RegisterMap* map) const {\n+  assert(map != nullptr, \"map must be set\");\n+  if (map->include_argument_oops()) {\n+    \/\/ Upcall stubs call a MethodHandle impl method of which only the receiver\n+    \/\/ is ever an oop.\n+    \/\/ Currently we should not be able to get here, since there are no\n+    \/\/ safepoints in the one resolve stub we can get into (handle_wrong_method)\n+    \/\/ Leave this here as a trap in case we ever do:\n+    ShouldNotReachHere(); \/\/ not implemented\n+  }\n+  _cb->as_upcall_stub()->oops_do(f, *this);\n+}\n+\n@@ -1191,1 +1206,1 @@\n-    _cb->as_upcall_stub()->oops_do(f, *this);\n+    oops_upcall_do(f, map);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -468,0 +468,1 @@\n+  void oops_upcall_do(OopClosure* f, const RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2035,0 +2035,4 @@\n+                                                                            \\\n+  product(bool, UseThreadsLockThrottleLock, true, DIAGNOSTIC,               \\\n+          \"Use an extra lock during Thread start and exit to alleviate\"     \\\n+          \"contention on Threads_lock.\")                                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n@@ -194,0 +194,1 @@\n+address StubRoutines::_upcall_stub_load_target = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -300,2 +300,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n@@ -304,0 +304,1 @@\n+  static address _upcall_stub_load_target;\n@@ -512,0 +513,5 @@\n+  static address upcall_stub_load_target() {\n+    assert(_upcall_stub_load_target != nullptr, \"not implemented\");\n+    return _upcall_stub_load_target;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1032,1 +1032,3 @@\n-  { MonitorLocker ml(Threads_lock);\n+  {\n+    ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+    MonitorLocker ml(Threads_lock);\n@@ -1080,1 +1082,1 @@\n-  } \/\/ unlock Threads_lock\n+  } \/\/ unlock Threads_lock and ThreadsLockThrottle_lock\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -37,0 +38,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -41,0 +44,3 @@\n+import static jdk.internal.util.ModifiedUtf.putChar;\n+import static jdk.internal.util.ModifiedUtf.utfLen;\n+\n@@ -207,0 +213,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -929,1 +936,1 @@\n-        bout.writeUTF(str);\n+        bout.writeUTFInternal(str, false);\n@@ -1361,8 +1368,1 @@\n-        long utflen = bout.getUTFLength(str);\n-        if (utflen <= 0xFFFF) {\n-            bout.writeByte(TC_STRING);\n-            bout.writeUTF(str, utflen);\n-        } else {\n-            bout.writeByte(TC_LONGSTRING);\n-            bout.writeLongUTF(str, utflen);\n-        }\n+        bout.writeUTFInternal(str, true);\n@@ -2041,11 +2041,12 @@\n-        public void writeBytes(String s) throws IOException {\n-            int endoff = s.length();\n-            int cpos = 0;\n-            int csize = 0;\n-            for (int off = 0; off < endoff; ) {\n-                if (cpos >= csize) {\n-                    cpos = 0;\n-                    csize = Math.min(endoff - off, CHAR_BUF_SIZE);\n-                    s.getChars(off, off + csize, cbuf, 0);\n-                }\n-                if (pos >= MAX_BLOCK_SIZE) {\n+        @SuppressWarnings(\"deprecation\")\n+        void writeBytes(String s, int len) throws IOException {\n+            int pos = this.pos;\n+            for (int strpos = 0; strpos < len;) {\n+                int rem = MAX_BLOCK_SIZE - pos;\n+                int csize = Math.min(len - strpos, rem);\n+                s.getBytes(strpos, strpos + csize, buf, pos);\n+                pos += csize;\n+                strpos += csize;\n+\n+                if (pos == MAX_BLOCK_SIZE) {\n+                    this.pos = pos;\n@@ -2053,0 +2054,1 @@\n+                    pos = 0;\n@@ -2054,6 +2056,5 @@\n-                int n = Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);\n-                int stop = pos + n;\n-                while (pos < stop) {\n-                    buf[pos++] = (byte) cbuf[cpos++];\n-                }\n-                off += n;\n+            this.pos = pos;\n+        }\n+\n+        public void writeBytes(String s) throws IOException {\n+            writeBytes(s, s.length());\n@@ -2073,2 +2074,41 @@\n-        public void writeUTF(String s) throws IOException {\n-            writeUTF(s, getUTFLength(s));\n+        public void writeUTF(String str) throws IOException {\n+            writeUTFInternal(str, false);\n+        }\n+\n+        private void writeUTFInternal(String str, boolean writeHeader) throws IOException {\n+            int strlen = str.length();\n+            int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+            int utflen = utfLen(str, countNonZeroAscii);\n+            if (utflen <= 0xFFFF) {\n+                if(writeHeader) {\n+                    writeByte(TC_STRING);\n+                }\n+                writeShort(utflen);\n+            } else {\n+                if(writeHeader) {\n+                    writeByte(TC_LONGSTRING);\n+                }\n+                writeLong(utflen);\n+            }\n+\n+            if (countNonZeroAscii != 0) {\n+                writeBytes(str, countNonZeroAscii);\n+            }\n+            if (countNonZeroAscii != strlen) {\n+                writeMoreUTF(str, countNonZeroAscii);\n+            }\n+        }\n+\n+        private void writeMoreUTF(String str, int stroff) throws IOException {\n+            int pos = this.pos;\n+            for (int strlen = str.length(); stroff < strlen;) {\n+                char c = str.charAt(stroff++);\n+                int csize = c != 0 && c < 0x80 ? 1 : c >= 0x800 ? 3 : 2;\n+                if (pos + csize >= MAX_BLOCK_SIZE) {\n+                    this.pos = pos;\n+                    drain();\n+                    pos = 0;\n+                }\n+                pos = putChar(buf, pos, c);\n+            }\n+            this.pos = pos;\n@@ -2200,106 +2240,0 @@\n-\n-        \/**\n-         * Returns the length in bytes of the UTF encoding of the given string.\n-         *\/\n-        long getUTFLength(String s) {\n-            int len = s.length();\n-            long utflen = 0;\n-            for (int off = 0; off < len; ) {\n-                int csize = Math.min(len - off, CHAR_BUF_SIZE);\n-                s.getChars(off, off + csize, cbuf, 0);\n-                for (int cpos = 0; cpos < csize; cpos++) {\n-                    char c = cbuf[cpos];\n-                    if (c >= 0x0001 && c <= 0x007F) {\n-                        utflen++;\n-                    } else if (c > 0x07FF) {\n-                        utflen += 3;\n-                    } else {\n-                        utflen += 2;\n-                    }\n-                }\n-                off += csize;\n-            }\n-            return utflen;\n-        }\n-\n-        \/**\n-         * Writes the given string in UTF format.  This method is used in\n-         * situations where the UTF encoding length of the string is already\n-         * known; specifying it explicitly avoids a prescan of the string to\n-         * determine its UTF length.\n-         *\/\n-        void writeUTF(String s, long utflen) throws IOException {\n-            if (utflen > 0xFFFFL) {\n-                throw new UTFDataFormatException();\n-            }\n-            writeShort((int) utflen);\n-            if (utflen == (long) s.length()) {\n-                writeBytes(s);\n-            } else {\n-                writeUTFBody(s);\n-            }\n-        }\n-\n-        \/**\n-         * Writes given string in \"long\" UTF format.  \"Long\" UTF format is\n-         * identical to standard UTF, except that it uses an 8 byte header\n-         * (instead of the standard 2 bytes) to convey the UTF encoding length.\n-         *\/\n-        void writeLongUTF(String s) throws IOException {\n-            writeLongUTF(s, getUTFLength(s));\n-        }\n-\n-        \/**\n-         * Writes given string in \"long\" UTF format, where the UTF encoding\n-         * length of the string is already known.\n-         *\/\n-        void writeLongUTF(String s, long utflen) throws IOException {\n-            writeLong(utflen);\n-            if (utflen == (long) s.length()) {\n-                writeBytes(s);\n-            } else {\n-                writeUTFBody(s);\n-            }\n-        }\n-\n-        \/**\n-         * Writes the \"body\" (i.e., the UTF representation minus the 2-byte or\n-         * 8-byte length header) of the UTF encoding for the given string.\n-         *\/\n-        private void writeUTFBody(String s) throws IOException {\n-            int limit = MAX_BLOCK_SIZE - 3;\n-            int len = s.length();\n-            for (int off = 0; off < len; ) {\n-                int csize = Math.min(len - off, CHAR_BUF_SIZE);\n-                s.getChars(off, off + csize, cbuf, 0);\n-                for (int cpos = 0; cpos < csize; cpos++) {\n-                    char c = cbuf[cpos];\n-                    if (pos <= limit) {\n-                        if (c <= 0x007F && c != 0) {\n-                            buf[pos++] = (byte) c;\n-                        } else if (c > 0x07FF) {\n-                            buf[pos + 2] = (byte) (0x80 | ((c >> 0) & 0x3F));\n-                            buf[pos + 1] = (byte) (0x80 | ((c >> 6) & 0x3F));\n-                            buf[pos + 0] = (byte) (0xE0 | ((c >> 12) & 0x0F));\n-                            pos += 3;\n-                        } else {\n-                            buf[pos + 1] = (byte) (0x80 | ((c >> 0) & 0x3F));\n-                            buf[pos + 0] = (byte) (0xC0 | ((c >> 6) & 0x1F));\n-                            pos += 2;\n-                        }\n-                    } else {    \/\/ write one byte at a time to normalize block\n-                        if (c <= 0x007F && c != 0) {\n-                            write(c);\n-                        } else if (c > 0x07FF) {\n-                            write(0xE0 | ((c >> 12) & 0x0F));\n-                            write(0x80 | ((c >> 6) & 0x3F));\n-                            write(0x80 | ((c >> 0) & 0x3F));\n-                        } else {\n-                            write(0xC0 | ((c >> 6) & 0x1F));\n-                            write(0x80 | ((c >> 0) & 0x3F));\n-                        }\n-                    }\n-                }\n-                off += csize;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":68,"deletions":134,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.classfile.FieldBuilder;\n@@ -45,1 +44,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -62,1 +60,0 @@\n-import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -64,0 +61,1 @@\n+\n@@ -67,2 +65,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -73,0 +69,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -83,1 +80,1 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n@@ -108,1 +105,0 @@\n-    private final String[] argNames;                 \/\/ Generated names for the constructor arguments\n@@ -186,0 +182,2 @@\n+        ClassDesc[] argDescs;\n+        MethodTypeDesc constructorTypeDesc;\n@@ -187,1 +185,0 @@\n-            argNames = new String[parameterCount];\n@@ -190,1 +187,0 @@\n-                argNames[i] = \"arg$\" + (i + 1);\n@@ -193,0 +189,1 @@\n+            constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -194,1 +191,1 @@\n-            argNames = EMPTY_STRING_ARRAY;\n+            constructorTypeDesc = MTD_void;\n@@ -197,1 +194,6 @@\n-        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n+        this.argDescs = argDescs;\n+        this.constructorTypeDesc = constructorTypeDesc;\n+    }\n+\n+    private static String argName(int i) {\n+        return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n@@ -332,1 +334,1 @@\n-                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n+                    clb.withField(argName(i), argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -413,4 +415,3 @@\n-                            cob.aload(0);\n-                            Class<?> argType = factoryType.parameterType(i);\n-                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n-                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                            cob.aload(0)\n+                               .loadLocal(TypeKind.from(factoryType.parameterType(i)), cob.parameterSlot(i))\n+                               .putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -468,1 +469,1 @@\n-                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -525,1 +526,1 @@\n-                for (int i = 0; i < argNames.length; i++) {\n+                for (int i = 0; i < argDescs.length; i++) {\n@@ -527,1 +528,1 @@\n-                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -377,7 +377,6 @@\n-            clb.withSuperclass(CD_Object);\n-            clb.withFlags((PreviewFeatures.isEnabled() ? ACC_IDENTITY  : 0) | ACC_FINAL | ACC_SYNTHETIC);\n-            clb.withInterfaceSymbols(ifaceDesc);\n-\n-            \/\/ static and instance fields\n-            clb.withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-            clb.withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            clb.withSuperclass(CD_Object)\n+               .withFlags((PreviewFeatures.isEnabled() ? ACC_IDENTITY  : 0) | ACC_FINAL | ACC_SYNTHETIC)\n+               .withInterfaceSymbols(ifaceDesc)\n+               \/\/ static and instance fields\n+               .withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL)\n+               .withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n@@ -390,3 +389,3 @@\n-                cob.loadConstant(ifaceDesc);\n-                cob.putstatic(proxyDesc, TYPE_NAME, CD_Class);\n-                cob.return_();\n+                cob.loadConstant(ifaceDesc)\n+                   .putstatic(proxyDesc, TYPE_NAME, CD_Class)\n+                   .return_();\n@@ -397,11 +396,9 @@\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-\n-                \/\/ call ensureOriginalLookup to verify the given Lookup has access\n-                cob.aload(1);\n-                cob.invokestatic(proxyDesc, \"ensureOriginalLookup\", MTD_void_Lookup);\n-\n-                \/\/ this.target = target;\n-                cob.aload(0);\n-                cob.aload(2);\n-                cob.putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n+                cob.aload(0)\n+                   .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                   \/\/ call ensureOriginalLookup to verify the given Lookup has access\n+                   .aload(1)\n+                   .invokestatic(proxyDesc, ENSURE_ORIGINAL_LOOKUP, MTD_void_Lookup)\n+                   \/\/ this.target = target;\n+                   .aload(0)\n+                   .aload(2)\n+                   .putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n@@ -412,5 +409,5 @@\n-                    cob.aload(0);\n-                    cob.aload(3);\n-                    cob.loadConstant(mi.desc);\n-                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n-                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                    cob.aload(0)\n+                       .aload(3)\n+                       .loadConstant(mi.desc)\n+                       .invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType)\n+                       .putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -429,20 +426,20 @@\n-                cob.aload(0);\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n-                cob.loadConstant(proxyDesc);\n-                cob.if_acmpne(failLabel);\n-                \/\/ check original access\n-                cob.aload(0);\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n-                cob.loadConstant(Lookup.ORIGINAL);\n-                cob.iand();\n-                cob.ifeq(failLabel);\n-                \/\/ success\n-                cob.return_();\n-                \/\/ throw exception\n-                cob.labelBinding(failLabel);\n-                cob.new_(CD_IllegalAccessException);\n-                cob.dup();\n-                cob.aload(0); \/\/ lookup\n-                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n-                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n-                cob.athrow();\n+                cob.aload(0)\n+                   .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                   .loadConstant(proxyDesc)\n+                   .if_acmpne(failLabel)\n+                   \/\/ check original access\n+                   .aload(0)\n+                   .invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int)\n+                   .loadConstant(Lookup.ORIGINAL)\n+                   .iand()\n+                   .ifeq(failLabel)\n+                   \/\/ success\n+                   .return_()\n+                   \/\/ throw exception\n+                   .labelBinding(failLabel)\n+                   .new_(CD_IllegalAccessException)\n+                   .dup()\n+                   .aload(0) \/\/ lookup\n+                   .invokevirtual(CD_Object, \"toString\", MTD_String)\n+                   .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                   .athrow();\n@@ -457,2 +454,2 @@\n-                                    bcb.aload(0);\n-                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    bcb.aload(0)\n+                                       .getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -463,2 +460,2 @@\n-                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n-                                    bcb.return_(TypeKind.from(mi.desc.returnType()));\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc)\n+                                       .return_(TypeKind.from(mi.desc.returnType()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":47,"deletions":50,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -58,0 +57,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -89,7 +89,7 @@\n-            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n-            ConstantDescs.CD_Object,\n-            ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n-            ConstantDescs.CD_Object,\n-            ConstantDescs.CD_int,\n+            MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(CD_int,\n+            CD_Object,\n+            CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(CD_int,\n+            CD_Object,\n+            CD_int,\n@@ -97,1 +97,1 @@\n-            ConstantDescs.CD_List);\n+            CD_List);\n@@ -487,5 +487,5 @@\n-            cb.iload(RESTART_IDX);\n-            cb.loadConstant(labelConstants.length + 1);\n-            cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n-            cb.pop();\n-            cb.aload(SELECTOR_OBJ);\n+            cb.iload(RESTART_IDX)\n+              .loadConstant(labelConstants.length + 1)\n+              .invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR)\n+              .pop()\n+              .aload(SELECTOR_OBJ);\n@@ -493,4 +493,4 @@\n-            cb.ifnonnull(nonNullLabel);\n-            cb.iconst_m1();\n-            cb.ireturn();\n-            cb.labelBinding(nonNullLabel);\n+            cb.ifnonnull(nonNullLabel)\n+              .iconst_m1()\n+              .ireturn()\n+              .labelBinding(nonNullLabel);\n@@ -499,1 +499,1 @@\n-                        .ireturn();\n+                  .ireturn();\n@@ -538,3 +538,3 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(Wrapper.forBasicType(classLabel).wrapperClassDescriptor());\n-                            cb.ifeq(next);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(Wrapper.forBasicType(classLabel).wrapperClassDescriptor())\n+                              .ifeq(next);\n@@ -545,2 +545,2 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(ConstantDescs.CD_Number);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(CD_Number);\n@@ -553,2 +553,2 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .checkcast(CD_Number);\n@@ -556,1 +556,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -558,1 +558,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                                        MethodTypeDesc.of(CD_long));\n@@ -560,1 +560,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -562,1 +562,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                                        MethodTypeDesc.of(CD_float));\n@@ -564,1 +564,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -566,1 +566,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n+                                        MethodTypeDesc.of(CD_double));\n@@ -569,1 +569,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -571,9 +571,9 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n-                                cb.goto_(compare);\n-                                cb.labelBinding(notNumber);\n-                                cb.aload(SELECTOR_OBJ);\n-                                cb.instanceOf(ConstantDescs.CD_Character);\n-                                cb.ifeq(next);\n-                                cb.aload(SELECTOR_OBJ);\n-                                cb.checkcast(ConstantDescs.CD_Character);\n-                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        MethodTypeDesc.of(CD_int))\n+                                  .goto_(compare)\n+                                  .labelBinding(notNumber)\n+                                  .aload(SELECTOR_OBJ)\n+                                  .instanceOf(CD_Character)\n+                                  .ifeq(next)\n+                                  .aload(SELECTOR_OBJ)\n+                                  .checkcast(CD_Character)\n+                                  .invokevirtual(CD_Character,\n@@ -581,2 +581,2 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n-                                cb.labelBinding(compare);\n+                                        MethodTypeDesc.of(CD_char))\n+                                  .labelBinding(compare);\n@@ -589,2 +589,2 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, classDesc(typePair.from)));\n-                            cb.ifeq(next);\n+                                    MethodTypeDesc.of(CD_boolean, classDesc(typePair.from)))\n+                              .ifeq(next);\n@@ -595,3 +595,3 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(classLabelConstableOpt.orElseThrow());\n-                            cb.ifeq(next);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(classLabelConstableOpt.orElseThrow())\n+                              .ifeq(next);\n@@ -599,3 +599,3 @@\n-                            cb.aload(EXTRA_CLASS_LABELS);\n-                            cb.loadConstant(extraClassLabels.size());\n-                            cb.invokeinterface(ConstantDescs.CD_List,\n+                            cb.aload(EXTRA_CLASS_LABELS)\n+                              .loadConstant(extraClassLabels.size())\n+                              .invokeinterface(CD_List,\n@@ -603,5 +603,5 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                            ConstantDescs.CD_int));\n-                            cb.checkcast(ConstantDescs.CD_Class);\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    MethodTypeDesc.of(CD_Object,\n+                                            CD_int))\n+                              .checkcast(CD_Class)\n+                              .aload(SELECTOR_OBJ)\n+                              .invokevirtual(CD_Class,\n@@ -609,3 +609,3 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                            ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n+                                    MethodTypeDesc.of(CD_boolean,\n+                                            CD_Object))\n+                              .ifeq(next);\n@@ -618,3 +618,3 @@\n-                    cb.aload(ENUM_CACHE);\n-                    cb.loadConstant(enumIdx);\n-                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                    cb.aload(ENUM_CACHE)\n+                      .loadConstant(enumIdx)\n+                      .invokestatic(CD_Integer,\n@@ -622,4 +622,4 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                    ConstantDescs.CD_int));\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokeinterface(CD_BiPredicate,\n+                            MethodTypeDesc.of(CD_Integer,\n+                                    CD_int))\n+                      .aload(SELECTOR_OBJ)\n+                      .invokeinterface(CD_BiPredicate,\n@@ -627,4 +627,4 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -632,3 +632,3 @@\n-                    cb.ldc(stringLabel);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                    cb.ldc(stringLabel)\n+                      .aload(SELECTOR_OBJ)\n+                      .invokevirtual(CD_Object,\n@@ -636,3 +636,3 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -642,6 +642,6 @@\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.instanceOf(ConstantDescs.CD_Number);\n-                    cb.ifeq(notNumber);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.checkcast(ConstantDescs.CD_Number);\n-                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                    cb.aload(SELECTOR_OBJ)\n+                      .instanceOf(CD_Number)\n+                      .ifeq(notNumber)\n+                      .aload(SELECTOR_OBJ)\n+                      .checkcast(CD_Number)\n+                      .invokevirtual(CD_Number,\n@@ -649,9 +649,9 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_int));\n-                    cb.goto_(compare);\n-                    cb.labelBinding(notNumber);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.instanceOf(ConstantDescs.CD_Character);\n-                    cb.ifeq(next);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.checkcast(ConstantDescs.CD_Character);\n-                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            MethodTypeDesc.of(CD_int))\n+                      .goto_(compare)\n+                      .labelBinding(notNumber)\n+                      .aload(SELECTOR_OBJ)\n+                      .instanceOf(CD_Character)\n+                      .ifeq(next)\n+                      .aload(SELECTOR_OBJ)\n+                      .checkcast(CD_Character)\n+                      .invokevirtual(CD_Character,\n@@ -659,2 +659,2 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_char));\n-                    cb.labelBinding(compare);\n+                            MethodTypeDesc.of(CD_char))\n+                      .labelBinding(compare)\n@@ -662,2 +662,2 @@\n-                    cb.loadConstant(integerLabel);\n-                    cb.if_icmpne(next);\n+                      .loadConstant(integerLabel)\n+                      .if_icmpne(next);\n@@ -677,3 +677,3 @@\n-                                    caseLabelWrapper.basicClassDescriptor()));\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                                    caseLabelWrapper.basicClassDescriptor()))\n+                      .aload(SELECTOR_OBJ)\n+                      .invokevirtual(CD_Object,\n@@ -681,3 +681,3 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -688,2 +688,2 @@\n-                cb.loadConstant(idx);\n-                cb.ireturn();\n+                cb.loadConstant(idx)\n+                  .ireturn();\n@@ -691,3 +691,3 @@\n-            cb.labelBinding(dflt);\n-            cb.loadConstant(labelConstants.length);\n-            cb.ireturn();\n+            cb.labelBinding(dflt)\n+              .loadConstant(labelConstants.length)\n+              .ireturn();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":107,"deletions":107,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -1864,0 +1864,4 @@\n+        if (bestSoFar.kind == AMBIGUOUS) {\n+            AmbiguityError a_err = (AmbiguityError)bestSoFar.baseSymbol();\n+            bestSoFar = a_err.mergeAbstracts(site);\n+        }\n@@ -2768,1 +2772,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2800,1 +2804,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2924,1 +2928,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2983,1 +2987,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -3514,12 +3518,0 @@\n-        @Override\n-        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n-            Symbol sym = doLookup(env, phase);\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n-            return sym;\n-        }\n-\n-        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n-\n@@ -3572,4 +3564,0 @@\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1654,0 +1654,179 @@\n+#ifdef DEBUG\n+\/\/ APIs that can be called when debugging the debug agent\n+\n+#define check_jvmti_status(err, msg) \\\n+  if (err != JVMTI_ERROR_NONE) { \\\n+      EXIT_ERROR(err, msg); \\\n+  }\n+\n+char*\n+translateThreadState(jint flags) {\n+    char str[15 * 20];\n+    str[0] = '\\0';\n+\n+    if (flags & JVMTI_THREAD_STATE_ALIVE) {\n+        strcat(str, \" ALIVE\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_TERMINATED) {\n+        strcat(str, \" TERMINATED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_RUNNABLE) {\n+        strcat(str, \" RUNNABLE\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING) {\n+        strcat(str, \" WAITING\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) {\n+        strcat(str, \" WAITING_INDEFINITELY\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) {\n+        strcat(str, \" WAITING_WITH_TIMEOUT\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_SLEEPING) {\n+        strcat(str, \" SLEEPING\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) {\n+        strcat(str, \" IN_OBJECT_WAIT\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_PARKED) {\n+        strcat(str, \" PARKED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) {\n+        strcat(str, \" BLOCKED_ON_MONITOR_ENTER\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_SUSPENDED) {\n+        strcat(str, \" SUSPENDED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_INTERRUPTED) {\n+        strcat(str, \" INTERRUPTED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_IN_NATIVE) {\n+        strcat(str, \" IN_NATIVE\");\n+    }\n+\n+    if (strlen(str) == 0) {\n+        strcpy(str, \"<none>\");\n+    }\n+\n+    char* tstate = (char*)jvmtiAllocate((int)strlen(str) + 1);\n+    strcpy(tstate, str);\n+\n+    return tstate;\n+}\n+\n+char*\n+getThreadName(jthread thread) {\n+    jvmtiThreadInfo thr_info;\n+    jvmtiError err;\n+\n+    memset(&thr_info, 0, sizeof(thr_info));\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+        (gdata->jvmti, thread, &thr_info);\n+    if (err == JVMTI_ERROR_WRONG_PHASE || err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+        return NULL; \/\/ VM or target thread completed its work\n+    }\n+    check_jvmti_status(err, \"getThreadName: error in JVMTI GetThreadInfo call\");\n+\n+    char* tname = thr_info.name;\n+    if (tname == NULL) {\n+        const char* UNNAMED_STR = \"<Unnamed thread>\";\n+        size_t UNNAMED_LEN = strlen(UNNAMED_STR);\n+        tname = (char*)jvmtiAllocate((int)UNNAMED_LEN + 1);\n+        strcpy(tname, UNNAMED_STR);\n+    }\n+    return tname;\n+}\n+\n+char*\n+getMethodName(jmethodID method) {\n+    char*  mname = NULL;\n+    jvmtiError err;\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n+        (gdata->jvmti, method, &mname, NULL, NULL);\n+    check_jvmti_status(err, \"getMethodName: error in JVMTI GetMethodName call\");\n+\n+    return mname;\n+}\n+\n+static char*\n+get_method_class_name(jmethodID method) {\n+    jclass klass = NULL;\n+    char*  cname = NULL;\n+    char*  result = NULL;\n+    jvmtiError err;\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n+        (gdata->jvmti, method, &klass);\n+    check_jvmti_status(err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetClassSignature)\n+        (gdata->jvmti, klass, &cname, NULL);\n+    check_jvmti_status(err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n+\n+    size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n+    result = (char*)jvmtiAllocate((int)len + 1);\n+    strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n+    result[len] = '\\0';\n+    jvmtiDeallocate((void*)cname);\n+    return result;\n+}\n+\n+static void\n+print_method(jmethodID method, jint depth) {\n+    char*  cname = NULL;\n+    char*  mname = NULL;\n+    char*  msign = NULL;\n+    jvmtiError err;\n+\n+    cname = get_method_class_name(method);\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n+        (gdata->jvmti, method, &mname, &msign, NULL);\n+    check_jvmti_status(err, \"print_method: error in JVMTI GetMethodName\");\n+\n+    tty_message(\"%2d: %s: %s%s\", depth, cname, mname, msign);\n+    jvmtiDeallocate((void*)cname);\n+    jvmtiDeallocate((void*)mname);\n+    jvmtiDeallocate((void*)msign);\n+}\n+\n+#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n+\n+void\n+printStackTrace(jthread thread) {\n+    jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n+    char* tname = getThreadName(thread);\n+    jint count = 0;\n+\n+    jvmtiError err = JVMTI_FUNC_PTR(gdata->jvmti,GetStackTrace)\n+        (gdata->jvmti, thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n+    check_jvmti_status(err, \"printStackTrace: error in JVMTI GetStackTrace\");\n+\n+    tty_message(\"JVMTI Stack Trace for thread %s: frame count: %d\", tname, count);\n+    for (int depth = 0; depth < count; depth++) {\n+        print_method(frames[depth].method, depth);\n+    }\n+    jvmtiDeallocate((void*)tname);\n+}\n+\n+void\n+printThreadInfo(jthread thread) {\n+    jvmtiThreadInfo thread_info;\n+    jint thread_state;\n+    jvmtiError err;\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+        (gdata->jvmti, thread, &thread_info);\n+    check_jvmti_status(err, \"Error in GetThreadInfo\");\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadState)\n+        (gdata->jvmti, thread, &thread_state);\n+    check_jvmti_status(err, \"Error in GetThreadState\");\n+    const char* state = translateThreadState(thread_state);\n+    tty_message(\"Thread: %p, name: %s, state(%x): %s, attrs: %s %s\",\n+                thread, thread_info.name, thread_state, state,\n+                (isVThread(thread) ? \"virtual\": \"platform\"),\n+                (thread_info.is_daemon ? \"daemon\": \"\"));\n+}\n+\n+#endif \/* DEBUG*\/\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":179,"deletions":0,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+applications\/ctw\/modules\/java_base_2.java 8341831 linux-x64\n+\n@@ -56,1 +58,0 @@\n-compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -127,0 +128,1 @@\n+containers\/docker\/TestJcmdWithSideCar.java 8341518 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xint -XX:+PrintInlineLayout runtime.valhalla.inlinetypes.ValueCopyingTest\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout runtime.valhalla.inlinetypes.ValueCopyingTest\n@@ -102,1 +102,1 @@\n-}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueCopyingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-java\/awt\/Frame\/InitialIconifiedTest.java 8203920 macosx-all,linux-all\n+java\/awt\/Frame\/InitialIconifiedTest.java 7144049,8203920 macosx-all,linux-all\n@@ -126,0 +126,1 @@\n+java\/awt\/Frame\/FocusTest.java 8341480 macosx-all\n@@ -131,0 +132,2 @@\n+java\/awt\/dnd\/DragExitBeforeDropTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DragThresholdTest.java 8076299 macosx-all\n@@ -213,0 +216,3 @@\n+java\/awt\/TrayIcon\/MouseMoveTest.java 8203053 linux-all\n+java\/awt\/TrayIcon\/TrayIconKeySelectTest.java 8341557 windows-all\n+java\/awt\/TrayIcon\/TrayIconTest.java 8341559 generic-all\n@@ -436,0 +442,1 @@\n+java\/awt\/Mouse\/MouseClickCount.java 8017182 macosx-all\n@@ -470,0 +477,3 @@\n+java\/awt\/dnd\/DragSourceMotionListenerTest.java 8225131 windows-all\n+java\/awt\/dnd\/RejectDragTest.java 7124259 macosx-all\n+java\/awt\/dnd\/DnDHTMLToOutlookTest\/DnDHTMLToOutlookTest.java 8027424 generic-all\n@@ -673,1 +683,0 @@\n-javax\/swing\/JTabbedPane\/8007563\/Test8007563.java 8051591 generic-all\n@@ -816,0 +825,4 @@\n+java\/awt\/Checkbox\/CheckboxBoxSizeTest.java 8340870 windows-all\n+java\/awt\/Checkbox\/CheckboxIndicatorSizeTest.java 8340870 windows-all\n+java\/awt\/Checkbox\/CheckboxNullLabelTest.java 8340870 windows-all\n+java\/awt\/dnd\/WinMoveFileToShellTest.java 8341665 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -392,1 +392,2 @@\n-    -java\/foreign\/TestMatrix.java\n+    -java\/foreign\/TestMatrix.java \\\n+    -java\/foreign\/TestUpcallStress.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -388,0 +388,1 @@\n+        vmOptFinalFlag(map, \"UnlockExperimentalVMOptions\");\n@@ -482,0 +483,2 @@\n+        String PARALLELGC_ENABLED = \"-XX:+UseParallelGC\";\n+        String SERIALGC_ENABLED = \"-XX:+UseSerialGC\";\n@@ -487,1 +490,1 @@\n-                !opt.equals(G1GC_ENABLED)) {\n+                !opt.equals(G1GC_ENABLED) && !opt.equals(PARALLELGC_ENABLED) && !opt.equals(SERIALGC_ENABLED)) {\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}