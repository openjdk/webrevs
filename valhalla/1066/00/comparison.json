{"files":[{"patch":"@@ -191,0 +191,13 @@\n+    public static boolean isSupported(Feature feature, int majorVersion) {\n+        Source source = null;\n+        for (Target target : Target.values()) {\n+            if (majorVersion == target.majorVersion) {\n+                source = lookup(target.name);\n+            }\n+        }\n+        if (source != null) {\n+            return feature.allowedInSource(source);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+        jdk.jdeps,\n@@ -247,0 +248,1 @@\n+        jdk.jdeps,\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.jvm.ClassFile;\n@@ -44,0 +47,1 @@\n+\n@@ -151,1 +155,1 @@\n-        writeModifiers(getClassModifiers(cm.flags().flagsMask()));\n+        writeModifiers(getClassModifiers(cm.flags().flagsMask(), classModel.majorVersion(), classModel.minorVersion()));\n@@ -777,0 +781,10 @@\n+    private static Set<String> getClassModifiers(int mask, int majorVersion, int minorVersion) {\n+        boolean previewClassFile = minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n+        Set<String> result = getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask).flags());\n+        if ((mask & ACC_INTERFACE) == 0 && Source.isSupported(Source.Feature.VALUE_CLASSES, majorVersion) && previewClassFile) {\n+            result.add(\"value\");\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -79,8 +79,0 @@\n-# javac Valhalla\n-tools\/javac\/Diagnostics\/8043251\/T8043251.java                                   8301662    generic-all\n-\n-tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java                       8323786    generic-all\n-tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java    8325322    generic-all\n-\n-\n-\n@@ -92,3 +84,0 @@\n-\n-# Valhalla\n-tools\/javap\/8006334\/JavapTaskCtorFailWithNPE.java                               8323789    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T8043251.java:9:42: compiler.err.cant.apply.symbol.noargs: kindname.method, identity, kindname.interface, java.util.function.Function<T,R>, (compiler.misc.wrong.number.type.args: 1)\n+T8043251.java:9:42: compiler.err.cant.apply.symbol.noargs: kindname.method, identity, java.util.function.Function<T,R>, (compiler.misc.wrong.number.type.args: 1)\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8043251\/T8043251.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8205910\n- * @summary Complain when `this' of a value class is leaked from constructor before all instance fields are definitely assigned.\n- * @compile\/fail\/ref=CheckThisLeak.out -XDrawDiagnostics -XDdev CheckThisLeak.java\n- * @ignore\n- *\/\n-\n-value class V {\n-\n-    private final int x, ymx;\n-\n-    V(int x, int y) {\n-\n-        OK();                       \/\/ OK to call static methods.\n-        this.OK();                  \/\/ OK to call static methods.\n-\n-        validate();                 \/\/ BAD to call instance method DU = {x, ymx}\n-        this.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n-        V.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n-\n-        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-\n-        V v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-        v = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-\n-        ymx = y - x;                \/\/ OK, implicit this for field write.\n-        int l = this.ymx;           \/\/ OK, explicit this for DA field read.\n-\n-        OK();                       \/\/ OK to call static methods.\n-        this.OK();                  \/\/ OK to call static methods.\n-\n-        validate();                 \/\/ BAD to call instance method DU = {x}\n-        this.validate();            \/\/ BAD to call instance method DU = {x}\n-        V.this.validate();          \/\/ BAD to call instance method DU = {x}\n-\n-        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n-        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n-\n-        v = this;                   \/\/ BAD to create alias  DU = {x}\n-        v = V.this;                 \/\/ BAD to create alias  DU = {x}\n-\n-        this.x = x;\n-\n-        \/\/ ALL fields are assigned now.\n-\n-        OK();                       \/\/ OK to call static methods.\n-        this.OK();                  \/\/ OK to call static methods.\n-\n-        validate();                 \/\/ OK: DU = {}\n-        this.validate();            \/\/ OK: DU = {}\n-        V.this.validate();          \/\/ OK: DU = {}\n-\n-        System.out.println(this);   \/\/ OK: DU = {}\n-        System.out.println(V.this); \/\/ OK: DU = {}\n-\n-        v = this;                   \/\/ OK: DU = {}\n-        v = V.this;                 \/\/ OK: DU = {}\n-        assert (this.x > 0);        \/\/ OK: DU = {}\n-        assert (this.y() > 0);      \/\/ OK: DU = {}\n-    }\n-\n-    V() { \/\/ non-initial constructor. All, statements below are OK.\n-        this(10, 20);\n-        OK();\n-        this.OK();\n-\n-        validate();\n-        this.validate();\n-        V.this.validate();\n-\n-        System.out.println(this);\n-        System.out.println(V.this);\n-\n-        V v = this;\n-        v = V.this;\n-\n-        int l = this.ymx;\n-\n-        assert (this.x > 0);\n-        assert (this.y() > 0);\n-    }\n-\n-    static void OK() {\n-    }\n-\n-    int x() {\n-        return x;\n-    }\n-\n-    int y() {\n-        return ymx + x;\n-    }\n-\n-    void validate() {\n-        assert (x() > 0 && y() > 0);\n-    }\n-\n-    public static void main(String... av) {\n-        V z = new V(1, 10);\n-        assert (z.x() == 1);\n-        assert (z.y() == 10);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-CheckThisLeak.java:17:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:18:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:19:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:21:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:22:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:24:23: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:25:22: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:33:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:34:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:35:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:37:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:38:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:40:21: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:41:22: compiler.err.this.exposed.prematurely\n-14 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.out","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,1270 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * PrimitiveClassesCompilationTests\n- *\n- * @test\n- * @bug 8297207\n- * @summary Negative compilation tests, and positive compilation (smoke) tests for Primitive Classes\n- * @library \/lib\/combo \/tools\/lib\n- * @modules\n- *     jdk.compiler\/com.sun.tools.javac.util\n- *     jdk.compiler\/com.sun.tools.javac.api\n- *     jdk.compiler\/com.sun.tools.javac.main\n- *     jdk.compiler\/com.sun.tools.javac.code\n- *     jdk.jdeps\/com.sun.tools.classfile\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run testng PrimitiveClassesCompilationTests\n- * @ignore\n- *\/\n-\n-import java.io.File;\n-\n-import java.util.List;\n-\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-\n-import com.sun.tools.javac.code.Flags;\n-\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.Test;\n-\n-import tools.javac.combo.CompilationTestCase;\n-\n-import toolbox.ToolBox;\n-\n-@Test\n-public class PrimitiveClassesCompilationTests extends CompilationTestCase {\n-\n-    private static String[] DEFAULT_OPTIONS = {};\n-\n-    ToolBox tb = new ToolBox();\n-\n-    public PrimitiveClassesCompilationTests() {\n-        setDefaultFilename(\"PrimitiveClassTest.java\");\n-        setCompileOptions(DEFAULT_OPTIONS);\n-    }\n-\n-    public void testSupers() {\n-        assertOK(\n-                \"\"\"\n-                interface GoodSuperInterface {}\n-                abstract class GoodSuper extends Object {}\n-                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n-                \"\"\");\n-\n-        assertOK(\n-                \"\"\"\n-                abstract class Integer extends Number {\n-                    public double doubleValue() { return 0; }\n-                    public float floatValue() { return 0; }\n-                    public long longValue() { return 0; }\n-                    public int intValue() { return 0; }\n-                }\n-                primitive class PC extends Integer {}\n-                \"\"\");\n-\n-        assertOK(\n-                \"\"\"\n-                primitive class PC extends Number {\n-                    public double doubleValue() { return 0; }\n-                    public float floatValue() { return 0; }\n-                    public long longValue() { return 0; }\n-                    public int intValue() { return 0; }\n-                }\n-                \"\"\");\n-\n-        assertOK(\n-                \"\"\"\n-                abstract class SuperWithStaticField {\n-                    static int x;\n-                }\n-                primitive class PC extends SuperWithStaticField {}\n-                \"\"\");\n-\n-        assertOK(\n-                \"\"\"\n-                abstract class SuperWithEmptyNoArgCtor {\n-                    public SuperWithEmptyNoArgCtor() {\n-                        \/\/ Programmer supplied ctor but injected super call\n-                    }\n-                }\n-                abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n-                    public SuperWithEmptyNoArgCtor_01() {\n-                        super();  \/\/ programmer coded chaining no-arg constructor\n-                    }\n-                }\n-                abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n-                    \/\/ Synthesized chaining no-arg constructor\n-                }\n-                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.concrete.supertype.for.value.class\",\n-                \"\"\"\n-                class BadSuper {}\n-                primitive class PC extends BadSuper {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.instance.field.not.allowed\",\n-                \"\"\"\n-                abstract class SuperWithInstanceField {\n-                    int x;\n-                }\n-                abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n-                primitive class PC extends SuperWithInstanceField_01 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\",\n-                \"\"\"\n-                abstract class SuperWithNonEmptyNoArgCtor {\n-                    public SuperWithNonEmptyNoArgCtor() {\n-                        System.out.println(\"Non-Empty\");\n-                    }\n-                }\n-                abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n-                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract class SuperWithArgedCtor {\n-                    public SuperWithArgedCtor() {}\n-                    public SuperWithArgedCtor(String s) {\n-                    }\n-                }\n-                abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n-                primitive class PC extends SuperWithArgedCtor_01 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n-                \"\"\"\n-                abstract class SuperWithInstanceInit {\n-                    {\n-                        System.out.println(\"Disqualified from being super\");\n-                    }\n-                }\n-                abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n-                    {\n-                        \/\/ Not disqualified since it is a meaningless empty block.\n-                    }\n-                }\n-                primitive class PC extends SuperWithInstanceInit_01 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.super.class.method.cannot.be.synchronized\",\n-                \"\"\"\n-                abstract class SuperWithSynchronizedMethod {\n-                    synchronized void foo() {}\n-                }\n-                abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {}\n-                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract class InnerSuper {}\n-                }\n-                primitive class PC extends Outer.InnerSuper {}\n-                \"\"\");\n-    }\n-\n-    public void testFinalFields() {\n-        String[] sources = new String[] {\n-                \"\"\"\n-                primitive class Test {\n-                    final int x = 10;\n-                    Test() {\n-                        x = 10;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive class Test {\n-                    final int x = 10;\n-                    void foo() {\n-                        x = 10;\n-                    }\n-                }\n-                \"\"\"\n-        };\n-        for (String source : sources) {\n-            assertFail(\"compiler.err.cant.assign.val.to.var\", source);\n-        }\n-\n-        assertFail(\"compiler.err.var.might.already.be.assigned\",\n-                \"\"\"\n-                primitive class Test {\n-                    final int x;\n-                    Test() {\n-                        x = 10;\n-                        x = 10;\n-                    }\n-                }\n-                \"\"\"\n-        );\n-    }\n-\n-    public void testWithFieldNeg() {\n-        String[] sources = new String[] {\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    primitive final class B {\n-                        final A a = A.default;\n-                        void foo(A a) {\n-                            a.x = 100;\n-                        }\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    static final int sx = 10;\n-                    primitive final class B {\n-                        final A a = A.default;\n-                        void foo(A a) {\n-                            a.sx = 100;\n-                        }\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    primitive final class B {\n-                        final A a = A.default;\n-                    }\n-                    void withfield(B b) {\n-                            b.a.x = 11;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo(A a) {\n-                        a.x = 100;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo(A a) {\n-                        (a).x = 100;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo(final A fa) {\n-                        fa.x = 100;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo() {\n-                        x = 100;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo() {\n-                        this.x = 100;\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                primitive final class A {\n-                    final int x = 10;\n-                    void foo() {\n-                        A.this.x = 100;\n-                    }\n-                }\n-                \"\"\",\n-        };\n-        for (String source : sources) {\n-            assertFail(\"compiler.err.cant.assign.val.to.var\", source);\n-        }\n-    }\n-\n-    public void testIllegalModifiers() {\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                class Test {\n-                    primitive public void m() {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        int[] ia = new primitive int[10];\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        new primitive String(\"Hello\");\n-                    }\n-                }\n-                \"\"\");\n-        \/*\n-        \/\/ this test is passing, not sure if this is correct\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                class Test {\n-                    interface I {}\n-                    void m() {\n-                        new primitive I() {};\n-                    }\n-                }\n-                \"\"\");\n-        *\/\n-    }\n-\n-    public void testPrimitivesAsTypeParams() {\n-        String[] sources = new String[] {\n-                \"\"\"\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n-                    ArrayList<ValueOverGenericsTest> ax = null;\n-                }\n-                \"\"\",\n-                \"\"\"\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n-                    void foo(ArrayList<? extends ValueOverGenericsTest> p) {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n-                    void foo() {\n-                        new <ValueOverGenericsTest> ArrayList<Object>();\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n-                    void foo() {\n-                        this.<ValueOverGenericsTest>foo();\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n-                    void foo() {\n-                        Object o = (ValueOverGenericsTest & Serializable) null;\n-                    }\n-                }\n-                \"\"\",\n-        };\n-        for (String source : sources) {\n-            assertFail(\"compiler.err.type.found.req\", source);\n-        }\n-    }\n-\n-    public void testLocalPrimitiveClasses() {\n-        assertFail(\"compiler.err.cant.inherit.from.final\",\n-                \"\"\"\n-                class ValueModifierTest {\n-                    interface Value {}\n-                    void goo() {\n-                        primitive class Value {}\n-                        new Value() {};\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.inherit.from.final\",\n-                \"\"\"\n-                class ValueModifierTest {\n-                    interface Value {}\n-                    void goo() {\n-                        primitive class Value {}\n-                        new primitive Value() {};\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testDefaultOnUnknownClass() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        Object o = Unknown.default;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        Object o = Unknown1.Unknown2.default;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testUncheckedDefaultWarning() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-Xlint:all\"};\n-            setCompileOptions(testOptions);\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    primitive class UncheckedDefault<E> {\n-                        void m() {\n-                            UncheckedDefault<String> foo = UncheckedDefault.default;\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n-\n-    public void testRefProjection() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC x) {\n-                        PC.ref xq = null;\n-                        xq = x;\n-                        xq = (PC.ref) x;\n-                        xq = (PC) x;\n-                        x = xq;\n-                        x = (PC.ref) xq;\n-                        x = (PC) xq;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC[] xa = new PC[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref [] xqa = new PC.ref[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa) {\n-                        PC.ref[] xqa = xa;\n-                        xqa = (PC.ref[]) xa;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = xqa;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = (PC[]) xqa;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testSuperInvocation() {\n-        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n-                \"\"\"\n-                primitive class PC {\n-                    PC(String s) {\n-                        super();  \/\/ Error.\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testProjectionInstantiation() {\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.ref();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.val();\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.ref::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.val::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testOverloadResolution() {\n-        assertFail(\"compiler.err.ref.ambiguous\",\n-                \"\"\"\n-                class OverloadingPhaseTest {\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n-                        return \"\";\n-                    }\n-                    static String roo(V.ref v, Integer i) {\n-                        return \"\";\n-                    }\n-                    void m(V o) {\n-                        String result = roo(o, 0);\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.ref.ambiguous\",\n-                \"\"\"\n-                class OverloadingPhaseTest {\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n-                        return \"\";\n-                    }\n-                    static String roo(V.ref v, Integer i) {\n-                        return \"\";\n-                    }\n-                    void m(V o) {\n-                        String result = roo(o, Integer.valueOf(0));\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testNoVolatileFields() {\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                primitive class Bar {\n-                    volatile int i = 0;\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testDualPath() {\n-        assertFail(\"compiler.err.already.defined\",\n-                \"\"\"\n-                primitive class DualPathInnerType  {\n-                    class Inner { }\n-\n-                    static DualPathInnerType.Inner xi = new DualPathInnerType().new Inner();\n-                    DualPathInnerType.ref.Inner xri = xi;\n-\n-                    void f (DualPathInnerType.Inner xri) {}\n-                    void f (DualPathInnerType.ref.Inner xri) {}\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testGenericArray() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-Xlint:all\"};\n-            setCompileOptions(testOptions);\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo() {\n-                                Value<T>[] v = new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo() {\n-                                Value<Test>[] vx = new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo() {\n-                                Value<String>[] vs = new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo(Value<T>[] v) {\n-                                v = (Value<T> []) new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo(Value<Test>[] vx) {\n-                                vx = (Value<Test>[]) new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo(Value<String>[] vs) {\n-                                vs = (Value<String>[]) new Value[1];\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    class Test {\n-                        primitive class Value<T> {\n-                            T t = null;\n-                            void foo(Value<Test>[] vx, Value<String>[] vs) {\n-                                vx = vs;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n-\n-    public void testAdditionalGenericTests() {\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo() {\n-                        GenericInlineTest<String, Integer> g = new GenericInlineTest<String, Integer>();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, High<String, Integer> h1) {\n-                        h1 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, High<Integer, String> h2) {\n-                        h2 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Mid<String, Integer> m1) {\n-                        m1 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Mid<Integer, String> m2) {\n-                        m2 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Low<String, Integer> l1) {\n-                        l1 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n-                        l2 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n-                        l2 = g;\n-                        g = l2;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n-                        l2 = g;\n-                        g = (GenericInlineTest<String, Integer>) l2;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n-                        r1 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n-                        r2 = g;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n-                        r1 = g;\n-                        g = r1;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n-                        r2 = g;\n-                        g = r2;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                abstract class Low<T, U> {}\n-                abstract class Mid<T, U> extends Low<U, T> {}\n-                abstract class High<T, U> extends Mid<U, T> {}\n-\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n-                        r2 = g;\n-                        g = (GenericInlineTest<String, Integer>) r2;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testValRefTokensNegative() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    ValRefTokensNegativeTest.ref aa = null;\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    EmptyValue empty = EmptyValue.default;\n-\n-                    static class ValRefTokensTestWrapper {\n-                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-                    }\n-\n-                    public EmptyValue test(int x) {\n-                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-                        return x == 0 ? w.val.empty : w.ref.empty;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int valx() {\n-                        return EmptyValue.val.x;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int refx() {\n-                        return EmptyValue.ref.x;\n-                    }\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testPrimitiveAsTypeName() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--source\", \"16\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.primitive.classes.not.supported\",\n-                    \"\"\"\n-                    class primitive {\n-                        primitive x;\n-                        primitive foo(int l) {}\n-                        Object o = new primitive primitive() {};\n-                    }\n-                    \"\"\");\n-            setCompileOptions(previousOptions);\n-            assertFail(\"compiler.err.restricted.type.not.allowed\",\n-                    \"\"\"\n-                    class primitive {}\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n-\n-    public void testMiscThisLeak() {\n-        assertFail(\"compiler.err.this.exposed.prematurely\",\n-                \"\"\"\n-                class MiscThisLeak {\n-                    interface I {\n-                        void foo();\n-                    }\n-                    primitive class V {\n-                        int f;\n-                        V() {\n-                            I i = this::foo;\n-                        }\n-\n-                        void foo() {}\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class MiscThisLeak {\n-                    interface I {\n-                        void foo();\n-                    }\n-                    primitive class V {\n-                        int f;\n-                        V() {\n-                            I i = MiscThisLeak.this::foo;\n-                            f = 10;\n-                        }\n-\n-                        void foo() {}\n-                    }\n-                    void foo() {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.this.exposed.prematurely\",\n-                \"\"\"\n-                class MiscThisLeak {\n-                    interface I {\n-                        void foo();\n-                    }\n-                    primitive class V {\n-                        class K {}\n-                        int f;\n-                        V() {\n-                            new K();\n-                            f = 10;\n-                        }\n-\n-                        void foo() {}\n-                    }\n-                    void foo() {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.this.exposed.prematurely\",\n-                \"\"\"\n-                class MiscThisLeak {\n-                    interface I {\n-                        void foo();\n-                    }\n-                    primitive class V {\n-                        class K {}\n-                        int f;\n-                        V() {\n-                            this.new K();\n-                            f = 10;\n-                        }\n-\n-                        void foo() {}\n-                    }\n-                    void foo() {}\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class MiscThisLeak {\n-                    interface I {\n-                        void foo();\n-                    }\n-                    primitive class V {\n-                        class K {}\n-                        int f;\n-                        V() {\n-                            f = 10;\n-                            I i = this::foo;\n-                        }\n-                        void foo() {}\n-                    }\n-                    void foo() {}\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testCovariantArrayTest() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                class CovariantArrayTest {\n-                    primitive class V {\n-                        public final int v1;\n-                        private V () { v1 = 0; }\n-                    }\n-                    void m(int[] ia, Object[] oa) {\n-                        oa = (Object[])ia;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                class CovariantArrayTest {\n-                    primitive class V {\n-                        public final int v1;\n-                        private V () { v1 = 0; }\n-                    }\n-                    void m(int[] ia, Object[] oa) {\n-                        oa = ia;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class CovariantArrayTest {\n-                    primitive class V {\n-                        public final int v1;\n-                        private V () { v1 = 0; }\n-                    }\n-                    void m(int[] ia, Object[] oa) {\n-                        V[] va = new V[1];\n-                        Object[] oa2 = (Object[])va;\n-                        oa2 = va;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                class CovariantArrayTest {\n-                    primitive class V {\n-                        public final int v1;\n-                        private V () { v1 = 0; }\n-                    }\n-                    void m(int[] ia, Object[] oa) {\n-                        V[] va = new V[1];\n-                        Object[] oa2 = (Object[])va;\n-                        oa2 = va;\n-                        va = oa2;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class CovariantArrayTest {\n-                    primitive class V {\n-                        public final int v1;\n-                        private V () { v1 = 0; }\n-                    }\n-                    void m(int[] ia, Object[] oa) {\n-                        V[] va = new V[1];\n-                        Object[] oa2 = (Object[])va;\n-                        oa2 = va;\n-                        va = (V[]) oa2;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testConflictingSuperInterface() {\n-        assertFail(\"compiler.err.cant.inherit.diff.arg\",\n-                \"\"\"\n-                class ConflictingSuperInterfaceTest {\n-                    interface I<T> {}\n-                    static abstract class S implements I<String> {}\n-                    primitive static class Foo extends S implements I<Integer> {\n-                        String s = \"\";\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testClassLiteralTypingNegativeTest() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.val xv = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.ref xr = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":0,"deletions":1270,"binary":false,"changes":1270,"status":"deleted"},{"patch":"@@ -64,7 +64,1 @@\n-         \"flags: (0x0050) ACC_FINAL, ACC_VALUE\",\n-\n-         \"0: new           #8                  \/\/ class ValueCreationTest$Point\",\n-\n-\n-\n-         \/\/ Check that constructor has been lowered into a static factory method\n+         \"flags: (0x0010) ACC_FINAL\",\n@@ -75,8 +69,7 @@\n-         \"1: invokespecial #1                  \/\/ Method java\/lang\/Object.\\\"<init>\\\":()V\",\n-         \"4: aload_0\",\n-         \"5: iload_1\",\n-         \"6: putfield      #7                  \/\/ Field x:I\",\n-         \"9: aload_0\",\n-        \"10: iload_2\",\n-        \"11: putfield      #13                 \/\/ Field y:I\",\n-        \"14: return\"\n+         \"1: iload_1\",\n+         \"2: putfield      #1                  \/\/ Field x:I\",\n+         \"5: aload_0\",\n+         \"6: iload_2\",\n+         \"7: putfield      #7                  \/\/ Field y:I\",\n+        \"10: aload_0\",\n+        \"11: invokespecial #10                 \/\/ Method java\/lang\/Object.\\\"<init>\\\":()V\",\n@@ -84,1 +77,0 @@\n-\n@@ -87,1 +79,1 @@\n-     void runCheck(String [] params, String [] expectedOut) {\n+    void runCheck(String [] params, String [] expectedOut) {\n@@ -102,3 +94,3 @@\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n+        if (errors > 0) {\n+            throw new AssertionError(\"Unexpected javap output: \" + out);\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -615,0 +615,42 @@\n+    @Test\n+    void testThisCallingConstructor() throws Exception {\n+        \/\/ make sure that this() calling constructors doesn't initialize final fields\n+        String source =\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        this(0);\n+                    }\n+\n+                    Test(int i) {\n+                        this.i = i;\n+                    }\n+                }\n+                \"\"\";\n+        File dir = assertOK(true, source);\n+        File fileEntry = dir.listFiles()[0];\n+        ClassFile classFile = ClassFile.read(fileEntry);\n+        String expectedCodeSequenceThisCallingConst = \"aload_0,iconst_0,invokespecial,return,\";\n+        String expectedCodeSequenceNonThisCallingConst = \"aload_0,iload_1,putfield,aload_0,invokespecial,return,\";\n+        for (Method method : classFile.methods) {\n+            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                if (method.descriptor.getParameterCount(classFile.constant_pool) == 0) {\n+                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                    String foundCodeSequence = \"\";\n+                    for (Instruction inst: code.getInstructions()) {\n+                        foundCodeSequence += inst.getMnemonic() + \",\";\n+                    }\n+                    Assert.check(expectedCodeSequenceThisCallingConst.equals(foundCodeSequence));\n+                } else {\n+                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                    String foundCodeSequence = \"\";\n+                    for (Instruction inst: code.getInstructions()) {\n+                        foundCodeSequence += inst.getMnemonic() + \",\";\n+                    }\n+                    Assert.check(expectedCodeSequenceNonThisCallingConst.equals(foundCodeSequence));\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        \"public identity class JavapTaskCtorFailWithNPE {\\n\" +\n+        \"public class JavapTaskCtorFailWithNPE {\\n\" +\n","filename":"test\/langtools\/tools\/javap\/8006334\/JavapTaskCtorFailWithNPE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}