{"files":[{"patch":"@@ -26,0 +26,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -39,1 +41,2 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+import static test.java.lang.invoke.lib.InstructionHelper.classDesc;\n@@ -45,1 +48,2 @@\n- * @modules java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.value\n@@ -47,2 +51,2 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -52,1 +56,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -62,1 +66,2 @@\n- * @modules java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.value\n@@ -64,2 +69,2 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -69,1 +74,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -79,1 +84,2 @@\n- * @modules java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.value\n@@ -81,2 +87,2 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -86,1 +92,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -96,1 +102,2 @@\n- * @modules java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.value\n@@ -98,2 +105,2 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -103,1 +110,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -114,1 +121,2 @@\n- * @modules java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.value\n@@ -116,2 +124,2 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -121,1 +129,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -284,1 +292,1 @@\n-    static final String GET_OOP_MAP_DESC = \"()[Ljava\/lang\/Object;\";\n+    static final MethodTypeDesc GET_OOP_MAP_DESC = MethodTypeDesc.ofDescriptor(\"()[Ljava\/lang\/Object;\");\n@@ -376,1 +384,1 @@\n-            MethodHandle moveValueThroughStackAndLvt = OldInstructionHelper.loadCode(\n+            MethodHandle moveValueThroughStackAndLvt = InstructionHelper.buildMethodHandle(\n@@ -383,1 +391,1 @@\n-                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ Stack\n+                        .invokestatic(classDesc(InlineOops.class), \"doGc\", MethodTypeDesc.ofDescriptor(\"()V\")) \/\/ Stack\n@@ -385,1 +393,1 @@\n-                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ LVT\n+                        .invokestatic(classDesc(InlineOops.class), \"doGc\", MethodTypeDesc.ofDescriptor(\"()V\")) \/\/ LVT\n@@ -390,1 +398,1 @@\n-                        .invokestatic(InlineOops.class, \"doGc\", \"()V\", false) \/\/ Stack,LVT\n+                        .invokestatic(classDesc(InlineOops.class), \"doGc\", MethodTypeDesc.ofDescriptor(\"()V\")) \/\/ Stack,LVT\n@@ -617,1 +625,1 @@\n-                OldInstructionHelper.loadCode(\n+                InstructionHelper.buildMethodHandle(\n@@ -621,1 +629,1 @@\n-                            .new_(FooValue.class)\n+                            .new_(classDesc(FooValue.class))\n@@ -623,1 +631,1 @@\n-                            .invokespecial(FooValue.class, \"<init>\", \"()V\", false)\n+                            .invokespecial(classDesc(FooValue.class), \"<init>\", MethodTypeDesc.ofDescriptor(\"()V\"))\n@@ -626,1 +634,1 @@\n-                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .invokestatic(classDesc(InlineOops.class), GET_OOP_MAP_NAME, GET_OOP_MAP_DESC)\n@@ -631,1 +639,1 @@\n-                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .invokestatic(classDesc(InlineOops.class), GET_OOP_MAP_NAME, GET_OOP_MAP_DESC)\n@@ -633,1 +641,1 @@\n-                            .new_(FooValue.class)\n+                            .new_(classDesc(FooValue.class))\n@@ -635,1 +643,1 @@\n-                            .invokespecial(FooValue.class, \"<init>\", \"()V\", false)\n+                            .invokespecial(classDesc(FooValue.class), \"<init>\", MethodTypeDesc.ofDescriptor(\"()V\"))\n@@ -639,1 +647,1 @@\n-                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .invokestatic(classDesc(InlineOops.class), GET_OOP_MAP_NAME, GET_OOP_MAP_DESC)\n@@ -646,1 +654,1 @@\n-                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .invokestatic(classDesc(InlineOops.class), GET_OOP_MAP_NAME, GET_OOP_MAP_DESC)\n@@ -662,1 +670,1 @@\n-                OldInstructionHelper.loadCode(LOOKUP, \"exerciseVBytecodeExprStackWithRefs\", mt,\n+                InstructionHelper.buildMethodHandle(LOOKUP, \"exerciseVBytecodeExprStackWithRefs\", mt,\n@@ -670,1 +678,1 @@\n-                            .invokestatic(InlineOops.class, GET_OOP_MAP_NAME, GET_OOP_MAP_DESC, false)\n+                            .invokestatic(classDesc(InlineOops.class), GET_OOP_MAP_NAME, GET_OOP_MAP_DESC)\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":45,"deletions":37,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +34,1 @@\n+import java.time.chrono.ThaiBuddhistChronology;\n@@ -39,4 +42,2 @@\n-\n-import jdk.experimental.bytecode.MacroCodeBuilder;\n-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;\n-import jdk.experimental.bytecode.TypeTag;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.TypeKind;\n@@ -47,1 +48,0 @@\n-import jdk.test.lib.Utils;\n@@ -50,1 +50,3 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n+\n+import test.java.lang.invoke.lib.InstructionHelper;\n+import static test.java.lang.invoke.lib.InstructionHelper.classDesc;\n@@ -56,1 +58,1 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n@@ -58,1 +60,2 @@\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ *          java.base\/jdk.internal.classfile\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -60,1 +63,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -63,1 +66,0 @@\n- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false\n@@ -65,1 +67,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla --enable-preview\n@@ -68,1 +70,0 @@\n- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false\n@@ -77,1 +78,1 @@\n-    TestValue1[] inlineArray;\n+    TestValue1[] valueArray;\n@@ -293,1 +294,1 @@\n-                \/\/ testExecutionStackToInlineArray(testClasses[i], containerClasses[i]);\n+                testExecutionStackToInlineArray(testClasses[i], containerClasses[i]);\n@@ -304,3 +305,5 @@\n-        String sig = \"()L\" + inlineClass.getName() + \";\";\n-        final String signature = sig.replace('.', '\/');\n-        MethodHandle fromExecStackToLocalVar = OldInstructionHelper.loadCode(\n+        String sig = \"()L\" + inlineClass.getName().replace('.', '\/') + \";\";\n+        final MethodTypeDesc voidReturnClass = MethodTypeDesc.ofDescriptor(sig);\n+        final ClassDesc systemClassDesc = classDesc(System.class);\n+        final ClassDesc inlineClassDesc = classDesc(inlineClass);\n+        MethodHandle fromExecStackToLocalVar = InstructionHelper.buildMethodHandle(\n@@ -311,1 +314,1 @@\n-                    CODE.invokestatic(System.class, \"gc\", \"()V\", false);\n+                    CODE.invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"));\n@@ -316,1 +319,1 @@\n-                        .invokestatic(inlineClass, \"getInstance\", signature, false)\n+                        .invokestatic(inlineClassDesc, \"getInstance\", voidReturnClass)\n@@ -320,1 +323,1 @@\n-                        .invokestatic(inlineClass, \"getNonBufferedInstance\", signature, false)\n+                        .invokestatic(inlineClassDesc, \"getNonBufferedInstance\", voidReturnClass)\n@@ -323,1 +326,2 @@\n-                    CODE.invokestatic(System.class, \"gc\", \"()V\", false);\n+                    CODE.invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"));\n+                    Label endLabel = CODE.newLabel();\n@@ -327,1 +331,1 @@\n-                        .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                        .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -329,1 +333,1 @@\n-                        .ifcmp(TypeTag.I, CondKind.NE, \"end\");\n+                        .if_icmpne(endLabel);\n@@ -334,2 +338,2 @@\n-                    .return_(TypeTag.Z)\n-                    .label(\"end\")\n+                    .returnInstruction(TypeKind.BooleanType)\n+                    .labelBinding(endLabel)\n@@ -337,1 +341,1 @@\n-                    .return_(TypeTag.Z);\n+                    .returnInstruction(TypeKind.BooleanType);\n@@ -346,5 +350,7 @@\n-        String sig = \"()L\" + inlineClass.getName() + \";\";\n-        final String methodSignature = sig.replace('.', '\/');\n-        final String fieldLSignature = \"L\" + inlineClass.getName().replace('.', '\/') + \";\";\n-        System.out.println(methodSignature);\n-        MethodHandle fromExecStackToFields = OldInstructionHelper.loadCode(\n+        String sig = \"()L\" + inlineClass.getName().replace('.', '\/') + \";\";\n+        final MethodTypeDesc voidReturnClass = MethodTypeDesc.ofDescriptor(sig);\n+        final ClassDesc systemClassDesc = classDesc(System.class);\n+        final ClassDesc inlineClassDesc = classDesc(inlineClass);\n+        final ClassDesc containerClassDesc = classDesc(containerClass);\n+\n+        MethodHandle fromExecStackToFields = InstructionHelper.buildMethodHandle(\n@@ -355,0 +361,3 @@\n+                    Label loop = CODE.newLabel();\n+                    Label end = CODE.newLabel();\n+                    Label failed = CODE.newLabel();\n@@ -356,2 +365,2 @@\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .new_(containerClass)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"), false)\n+                    .new_(containerClassDesc)\n@@ -359,2 +368,2 @@\n-                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESPECIAL, containerClass, \"<init>\", \"()V\", false)\n-                    .astore_1()\n+                    .invokespecial(containerClassDesc, \"<init>\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .astore(1)\n@@ -362,3 +371,3 @@\n-                    .istore_2()\n-                    .label(\"loop\")\n-                    .iload_2()\n+                    .istore(2)\n+                    .labelBinding(loop)\n+                    .iload(2)\n@@ -366,8 +375,8 @@\n-                    .ifcmp(TypeTag.I, CondKind.EQ, \"end\")\n-                    .aload_1()\n-                    .invokestatic(inlineClass, \"getInstance\", methodSignature, false)\n-                    .putfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .aload_1()\n-                    .getfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n-                    .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                    .if_icmpeq(end)\n+                    .aload(1)\n+                    .invokestatic(inlineClassDesc, \"getInstance\", voidReturnClass)\n+                    .putfield(containerClassDesc, \"nonStaticInlineField\", inlineClassDesc)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .aload(1)\n+                    .getfield(containerClassDesc, \"nonStaticInlineField\", inlineClassDesc)\n+                    .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -375,8 +384,8 @@\n-                    .ifcmp(TypeTag.I, CondKind.NE, \"failed\")\n-                    .aload_1()\n-                    .invokestatic(inlineClass, \"getNonBufferedInstance\", methodSignature, false)\n-                    .putfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .aload_1()\n-                    .getfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n-                    .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                    .if_icmpne(failed)\n+                    .aload(1)\n+                    .invokestatic(inlineClassDesc, \"getNonBufferedInstance\", voidReturnClass)\n+                    .putfield(containerClassDesc, \"nonStaticInlineField\", inlineClassDesc)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .aload(1)\n+                    .getfield(containerClassDesc, \"nonStaticInlineField\", inlineClassDesc)\n+                    .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -384,7 +393,7 @@\n-                    .ifcmp(TypeTag.I, CondKind.NE, \"failed\")\n-                    .invokestatic(inlineClass, \"getInstance\", methodSignature, false)\n-                    .putstatic(containerClass, \"staticInlineField\", fieldLSignature)\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .getstatic(containerClass, \"staticInlineField\", fieldLSignature)\n-                    .checkcast(inlineClass)\n-                    .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                    .if_icmpne(failed)\n+                    .invokestatic(inlineClassDesc, \"getInstance\", voidReturnClass)\n+                    .putstatic(containerClassDesc, \"staticInlineField\", inlineClassDesc)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .getstatic(containerClassDesc, \"staticInlineField\", inlineClassDesc)\n+                    .checkcast(inlineClassDesc)\n+                    .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -392,7 +401,7 @@\n-                    .ifcmp(TypeTag.I, CondKind.NE, \"failed\")\n-                    .invokestatic(inlineClass, \"getNonBufferedInstance\", methodSignature, false)\n-                    .putstatic(containerClass, \"staticInlineField\", fieldLSignature)\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .getstatic(containerClass, \"staticInlineField\", fieldLSignature)\n-                    .checkcast(inlineClass)\n-                    .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                    .if_icmpne(failed)\n+                    .invokestatic(inlineClassDesc, \"getNonBufferedInstance\", voidReturnClass)\n+                    .putstatic(containerClassDesc, \"staticInlineField\", inlineClassDesc)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .getstatic(containerClassDesc, \"staticInlineField\", inlineClassDesc)\n+                    .checkcast(inlineClassDesc)\n+                    .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -400,1 +409,1 @@\n-                    .ifcmp(TypeTag.I, CondKind.NE, \"failed\")\n+                    .if_icmpne(failed)\n@@ -402,2 +411,2 @@\n-                    .goto_(\"loop\")\n-                    .label(\"end\")\n+                    .goto_(loop)\n+                    .labelBinding(end)\n@@ -405,2 +414,2 @@\n-                    .return_(TypeTag.Z)\n-                    .label(\"failed\")\n+                    .returnInstruction(TypeKind.BooleanType)\n+                    .labelBinding(failed)\n@@ -408,1 +417,1 @@\n-                    .return_(TypeTag.Z);\n+                    .returnInstruction(TypeKind.BooleanType);\n@@ -417,5 +426,7 @@\n-        String sig = \"()L\" + inlineClass.getName() + \";\";\n-        final String signature = sig.replace('.', '\/');\n-        final String arraySignature = \"[L\" + inlineClass.getName().replace('.', '\/') + \";\";\n-        System.out.println(arraySignature);\n-        MethodHandle fromExecStackToInlineArray = OldInstructionHelper.loadCode(\n+        String sig = \"()L\" + inlineClass.getName().replace('.', '\/') + \";\";\n+        final MethodTypeDesc voidReturnClass = MethodTypeDesc.ofDescriptor(sig);\n+        final ClassDesc systemClassDesc = classDesc(System.class);\n+        final ClassDesc inlineClassDesc = classDesc(inlineClass);\n+        final ClassDesc containerClassDesc = classDesc(containerClass);\n+\n+        MethodHandle fromExecStackToInlineArray = InstructionHelper.buildMethodHandle(\n@@ -426,0 +437,5 @@\n+                    Label loop1 = CODE.newLabel();\n+                    Label loop2 = CODE.newLabel();\n+                    Label end1 = CODE.newLabel();\n+                    Label end2 = CODE.newLabel();\n+                    Label failed = CODE.newLabel();\n@@ -427,2 +443,2 @@\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n-                    .new_(containerClass)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .new_(containerClassDesc)\n@@ -430,2 +446,2 @@\n-                    .invoke(MacroCodeBuilder.InvocationKind.INVOKESTATIC, containerClass, \"<vnew>\", \"()V\", false)\n-                    .astore_1()\n+                    .invokespecial(containerClassDesc, \"<init>\", MethodTypeDesc.ofDescriptor(\"()V\"))\n+                    .astore(1)\n@@ -433,4 +449,4 @@\n-                    .anewarray(inlineClass)\n-                    .astore_2()\n-                    .aload_2()\n-                    .aload_1()\n+                    .anewarray(inlineClassDesc)\n+                    .astore(2)\n+                    .aload(2)\n+                    .aload(1)\n@@ -438,1 +454,1 @@\n-                    .putfield(containerClass, \"valueArray\", arraySignature)\n+                    .putfield(containerClassDesc, \"valueArray\", inlineClassDesc.arrayType())\n@@ -440,8 +456,8 @@\n-                    .istore_3()\n-                    .label(\"loop1\")\n-                    .iload_3()\n-                    .ldc(ITERATIONS)\n-                    .ifcmp(TypeTag.I, CondKind.GE, \"end1\")\n-                    .aload_2()\n-                    .iload_3()\n-                    .invokestatic(inlineClass, \"getInstance\", signature, false)\n+                    .istore(3)\n+                    .labelBinding(loop1)\n+                    .iload(3)\n+                    .ldc(ITERATIONS *3)\n+                    .if_icmpge(end1)\n+                    .aload(2)\n+                    .iload(3)\n+                    .invokestatic(inlineClassDesc, \"getInstance\", voidReturnClass)\n@@ -450,3 +466,3 @@\n-                    .aload_2()\n-                    .iload_3()\n-                    .invokestatic(inlineClass, \"getNonBufferedInstance\", signature, false)\n+                    .aload(2)\n+                    .iload(3)\n+                    .invokestatic(inlineClassDesc, \"getNonBufferedInstance\", voidReturnClass)\n@@ -455,3 +471,5 @@\n-                    .aload_2()\n-                    .iload_3()\n-                    .aconst_init(inlineClass)\n+                    .aload(2)\n+                    .iload(3)\n+                    .new_(inlineClassDesc)\n+                    .dup()\n+                    .invokespecial(inlineClassDesc, \"<init>\", MethodTypeDesc.ofDescriptor(\"()V\"))\n@@ -460,3 +478,3 @@\n-                    .goto_(\"loop1\")\n-                    .label(\"end1\")\n-                    .invokestatic(System.class, \"gc\", \"()V\", false)\n+                    .goto_(loop1)\n+                    .labelBinding(end1)\n+                    .invokestatic(systemClassDesc, \"gc\", MethodTypeDesc.ofDescriptor(\"()V\"))\n@@ -464,3 +482,3 @@\n-                    .istore_3()\n-                    .label(\"loop2\")\n-                    .iload_3()\n+                    .istore(3)\n+                    .labelBinding(loop2)\n+                    .iload(3)\n@@ -468,3 +486,3 @@\n-                    .ifcmp(TypeTag.I, CondKind.GE, \"end2\")\n-                    .aload_2()\n-                    .iload_3()\n+                    .if_icmpge(end2)\n+                    .aload(2)\n+                    .iload(3)\n@@ -472,1 +490,1 @@\n-                    .invokevirtual(inlineClass, \"verify\", \"()Z\", false)\n+                    .invokevirtual(inlineClassDesc, \"verify\", MethodTypeDesc.ofDescriptor(\"()Z\"))\n@@ -474,1 +492,1 @@\n-                    .ifcmp(TypeTag.I, CondKind.NE, \"failed\")\n+                    .if_icmpne(failed)\n@@ -476,2 +494,2 @@\n-                    .goto_(\"loop2\")\n-                    .label(\"end2\")\n+                    .goto_(loop2)\n+                    .labelBinding(end2)\n@@ -479,2 +497,2 @@\n-                    .return_(TypeTag.Z)\n-                    .label(\"failed\")\n+                    .returnInstruction(TypeKind.BooleanType)\n+                    .labelBinding(failed)\n@@ -482,1 +500,1 @@\n-                    .return_(TypeTag.Z);\n+                    .returnInstruction(TypeKind.BooleanType);\n@@ -488,0 +506,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":137,"deletions":118,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -31,4 +31,4 @@\n- * @summary Check object method implemented by the VM behave with inline types\n- * @modules java.base\/jdk.internal.value\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @summary Check object methods implemented by the VM behave with value types\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @modules java.base\/jdk.internal.classfile\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -36,3 +36,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n- * @run main\/othervm -XX:+EnableValhalla -XX:-UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n- * @run main\/othervm -XX:+EnableValhalla -noverify runtime.valhalla.inlinetypes.ObjectMethods noverify\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+UseCompressedClassPointers --enable-preview runtime.valhalla.inlinetypes.ObjectMethods\n+ * @run main\/othervm -XX:+EnableValhalla -XX:-UseCompressedClassPointers --enable-preview runtime.valhalla.inlinetypes.ObjectMethods\n+ * @run main\/othervm -XX:+EnableValhalla -noverify --enable-preview runtime.valhalla.inlinetypes.ObjectMethods noverify\n@@ -134,9 +134,9 @@\n-            OldInstructionHelper.loadCode(MethodHandles.lookup(),\n-                                        \"mismatchedMonitorExit\",\n-                                        MethodType.methodType(Void.TYPE, Object.class),\n-                                        CODE->{\n-                                            CODE\n-                                                .aload(0)\n-                                                .monitorexit()\n-                                                .return_();\n-                                        }).invokeExact(val);\n+            InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+                                                \"mismatchedMonitorExit\",\n+                                                MethodType.methodType(Void.TYPE, Object.class),\n+                                                CODE-> {\n+                                                    CODE\n+                                                    .aload(0)\n+                                                    .monitorexit();\n+                                                    CODE.return_();\n+                                                }).invokeExact(val);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package runtime.valhalla.inlinetypes;\n-\n-import java.lang.invoke.*;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import static jdk.test.lib.Asserts.*;\n-\n-import jdk.experimental.bytecode.*;\n-\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n-\n-\/**\n- * @ignore\n- * @test TestBytecodeLib\n- * @summary Check bytecode test library generates the correct code for Valhalla changes to JVMS\n- * @modules java.base\/jdk.internal.value\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n- * @compile -XDenablePrimitiveClasses Point.java TestBytecodeLib.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.TestBytecodeLib\n- *\/\n-\n-public class TestBytecodeLib {\n-\n-    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n-\n-    public static void main(String[] args) throws Throwable {\n-        testAnewarrayDesc();\n-        testCheckcastDesc();\n-        \/\/ No support in test library for \"ldc(Class<?>)\" at all in this incarnation of the API, skip it\n-        testMultianewarrayDesc();\n-    }\n-\n-    \/\/ anewarray accepts reference and inline reference type\n-    \/\/ checkcast for arrays accepts reference and inline reference array type\n-    static void testAnewarrayDesc() throws Throwable {\n-        Class<?> lClass = Point.ref.class;\n-        Class<?> qClass = Point.val.class;\n-\n-        String methodName = \"anewarrayLQClass\";\n-        MethodType methodType = MethodType.methodType(void.class);\n-        byte[] codeBytes = OldInstructionHelper.buildCode(LOOKUP, methodName, methodType,\n-            CODE -> {\n-                CODE\n-                .iconst_3()\n-                .anewarray(lClass)\n-                .checkcast(Point.ref[].class)\n-                .pop()\n-                .iconst_3()\n-                .anewarray(qClass)\n-                .checkcast(Point.val[].class)\n-                .pop()\n-                .return_();\n-            }\n-        );\n-\n-        \/\/ Verify correct byte-code\n-        dumpBytes(methodName + \".class\", codeBytes);\n-\n-        \/\/ Verify it works\n-        OldInstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n-    }\n-\n-    \/\/ checkcast accepts reference and inline reference type\n-    static void testCheckcastDesc() throws Throwable {\n-        Class<?> lClass = Point.ref.class;\n-        Class<?> qClass = Point.val.class;\n-\n-        String methodName = \"checkcastLQClass\";\n-        MethodType methodType = MethodType.methodType(void.class);\n-        byte[] codeBytes = OldInstructionHelper.buildCode(LOOKUP, methodName, methodType,\n-            CODE -> {\n-                CODE\n-                .aconst_init(Point.class)\n-                .checkcast(lClass) \/\/ expect no descriptor here\n-                .checkcast(qClass) \/\/ expect Q-type descriptor here\n-                .pop()\n-                .return_();\n-            }\n-        );\n-\n-        \/\/ Verify correct byte-code\n-        dumpBytes(methodName + \".class\", codeBytes);\n-\n-        \/\/ Verify it works\n-        OldInstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n-    }\n-\n-    \/\/ multianewarray accepts reference and inline reference type...it naturally does, but...\n-    \/\/ checkcast for multidim arrays accepts reference and inline reference array type\n-    static void testMultianewarrayDesc() throws Throwable {\n-        Class<?> lClass = Point.ref[][].class;\n-        Class<?> qClass = Point.val[][].class;\n-\n-        String methodName = \"multianewarrayLQClass\";\n-        MethodType methodType = MethodType.methodType(void.class);\n-        byte dimCnt = (byte) 2;\n-        byte[] codeBytes = OldInstructionHelper.buildCode(LOOKUP, methodName, methodType,\n-            CODE -> {\n-                CODE\n-                .iconst_3()\n-                .iconst_4()\n-                .multianewarray(lClass, dimCnt)\n-                .checkcast(lClass)\n-                .pop()\n-                .iconst_3()\n-                .iconst_4()\n-                .multianewarray(qClass, dimCnt)\n-                .checkcast(qClass)\n-                .pop()\n-                .return_();\n-            }\n-        );\n-\n-        \/\/ Verify correct byte-code\n-        dumpBytes(methodName + \".class\", codeBytes);\n-\n-        \/\/ Verify it works\n-        OldInstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n-    }\n-\n-    \/*\n-        Dump the resulting bytes for inspection.\n-\n-        TODO: Would prefer programmtic use of ClassReader for verification, but only\n-        when the JVMS on q-types is less fluid (since it is a lot of work),\n-        so manual inspection for now.\n-\n-        Dump in the dir above \"test-support\/<test-suite-run>\/scratch\/<n>\" so it doesn't get clean up at end of run,\n-        and use a directory \"DUMP_CLASS_FILES\" (in keeping with MethodHandles classfile dump)\n-     *\/\n-    static void dumpBytes(String name, byte[] bytes) throws java.io.IOException {\n-        Path path = Paths.get(\"..\/DUMP_CLASS_FILES\");\n-        Files.createDirectories(path);\n-        path = path.resolve(name);\n-        System.out.println(\"Dump: \" + path);\n-        Files.write(path, bytes);\n-    }\n-\n-\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestBytecodeLib.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -26,5 +26,8 @@\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.TypeKind;\n-\n-import java.lang.constant.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +37,1 @@\n+import static java.lang.invoke.MethodType.fromMethodDescriptorString;\n@@ -35,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -36,1 +41,4 @@\n-import static java.lang.invoke.MethodType.fromMethodDescriptorString;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n@@ -138,0 +146,23 @@\n+\n+\n+    public static MethodHandle buildMethodHandle(MethodHandles.Lookup l, String methodName, MethodType methodType, Consumer<? super CodeBuilder> builder) {\n+        ClassDesc genClassDesc = classDesc(l.lookupClass(), \"$Code_\" + COUNT.getAndIncrement());\n+        return buildMethodHandle(l, genClassDesc, methodName, methodType, builder);\n+    }\n+\n+    public static MethodHandle buildMethodHandle(MethodHandles.Lookup l, ClassDesc classDesc, String methodName, MethodType methodType, Consumer<? super CodeBuilder> builder) {\n+        try {\n+            byte[] bytes = Classfile.of().build(classDesc, classBuilder -> {\n+                classBuilder.withMethod(methodName,\n+                                        MethodTypeDesc.ofDescriptor(methodType.toMethodDescriptorString()),\n+                                        Classfile.ACC_PUBLIC + Classfile.ACC_STATIC,\n+                                        methodBuilder -> methodBuilder.withCode(builder));\n+            });\n+            Class<?> clazz = l.defineClass(bytes);\n+            return l.findStatic(clazz, methodName, methodType);\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new RuntimeException(\"Failed to buildMethodHandle: \" + methodName + \" type \" + methodType);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"}]}