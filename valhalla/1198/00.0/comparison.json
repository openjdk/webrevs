{"files":[{"patch":"@@ -14,1 +14,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.S|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,0 +148,8 @@\n+  ifneq ($(COMPARE_BUILD), )\n+    DEBUG_CDS_ARCHIVE := true\n+  endif\n+\n+  ifeq ($(DEBUG_CDS_ARCHIVE), true)\n+    $1_$2_CDS_DUMP_FLAGS += -Xlog:cds+map*=trace:file=$$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE).cdsmap:none:filesize=0\n+  endif\n+\n","filename":"make\/Images.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-    ARGS := --always-make WORKSPACE=java SHARED=false, \\\n+    ARGS := --always-make WORKSPACE=java, \\\n@@ -276,1 +276,1 @@\n-    ARGS := --always-make WORKSPACE=hotspot SHARED=false, \\\n+    ARGS := --always-make WORKSPACE=hotspot, \\\n@@ -281,1 +281,1 @@\n-    ARGS := --always-make WORKSPACE=native SHARED=false, \\\n+    ARGS := --always-make WORKSPACE=native, \\\n@@ -286,21 +286,1 @@\n-    ARGS := --always-make SHARED=false, \\\n-))\n-\n-$(eval $(call SetupTarget, eclipse-shared-java-env, \\\n-    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n-    ARGS := --always-make WORKSPACE=java SHARED=true, \\\n-))\n-\n-$(eval $(call SetupTarget, eclipse-shared-hotspot-env, \\\n-    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n-    ARGS := --always-make WORKSPACE=hotspot SHARED=true, \\\n-))\n-\n-$(eval $(call SetupTarget, eclipse-shared-native-env, \\\n-    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n-    ARGS := --always-make WORKSPACE=native SHARED=true, \\\n-))\n-\n-$(eval $(call SetupTarget, eclipse-shared-mixed-env, \\\n-    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n-    ARGS := --always-make SHARED=true, \\\n+    ARGS := --always-make, \\\n@@ -954,0 +934,5 @@\n+  # On Windows, we need to copy tzmappings generated by gensrc\n+  ifeq ($(call isTargetOs, windows), true)\n+    java.base-copy: java.base-gensrc\n+  endif\n+\n","filename":"make\/Main.gmk","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -4108,1 +4108,1 @@\n-  if (UseNeon) {\n+    { \/\/ Neon code start\n@@ -4240,1 +4240,1 @@\n-  }\n+    } \/\/ Neon code end\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,2 @@\n-          \"Enable RTM lock eliding for inflated locks in compiled code\")    \\\n+          \"(Deprecated) Enable RTM lock eliding for inflated locks \"        \\\n+          \"in compiled code\")                                               \\\n@@ -166,1 +167,2 @@\n-          \"Perform deopt and recompilation based on RTM abort ratio\")       \\\n+          \"(Deprecated) Perform deopt and recompilation based on \"          \\\n+          \"RTM abort ratio\")                                                \\\n@@ -169,1 +171,1 @@\n-          \"Number of RTM retries on lock abort or busy\")                    \\\n+          \"(Deprecated) Number of RTM retries on lock abort or busy\")       \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -9702,15 +9702,0 @@\n-instruct vlshift_mem_masked(vec dst, memory src2, kReg mask) %{\n-  match(Set dst (LShiftVS (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (LShiftVI (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (LShiftVL (Binary dst (LoadVector src2)) mask));\n-  format %{ \"vplshift_masked $dst, $dst, $src2, $mask\\t! lshift masked operation\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int opc = this->ideal_Opcode();\n-    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n-                   $dst$$XMMRegister, $src2$$Address, true, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -9764,15 +9749,0 @@\n-instruct vrshift_mem_masked(vec dst, memory src2, kReg mask) %{\n-  match(Set dst (RShiftVS (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (RShiftVI (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (RShiftVL (Binary dst (LoadVector src2)) mask));\n-  format %{ \"vprshift_masked $dst, $dst, $src2, $mask\\t! rshift masked operation\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int opc = this->ideal_Opcode();\n-    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n-                   $dst$$XMMRegister, $src2$$Address, true, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -9826,15 +9796,0 @@\n-instruct vurshift_mem_masked(vec dst, memory src2, kReg mask) %{\n-  match(Set dst (URShiftVS (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (URShiftVI (Binary dst (LoadVector src2)) mask));\n-  match(Set dst (URShiftVL (Binary dst (LoadVector src2)) mask));\n-  format %{ \"vpurshift_masked $dst, $dst, $src2, $mask\\t! urshift masked operation\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int opc = this->ideal_Opcode();\n-    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n-                   $dst$$XMMRegister, $src2$$Address, true, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1150,11 +1150,9 @@\n-        if (TieredCompilation) {\n-          \/\/ If there is an old version we're done with it\n-          CompiledMethod* old = method->code();\n-          if (TraceMethodReplacement && old != nullptr) {\n-            ResourceMark rm;\n-            char *method_name = method->name_and_sig_as_C_string();\n-            tty->print_cr(\"Replacing method %s\", method_name);\n-          }\n-          if (old != nullptr) {\n-            old->make_not_used();\n-          }\n+        \/\/ If there is an old version we're done with it\n+        CompiledMethod* old = method->code();\n+        if (TraceMethodReplacement && old != nullptr) {\n+          ResourceMark rm;\n+          char *method_name = method->name_and_sig_as_C_string();\n+          tty->print_cr(\"Replacing method %s\", method_name);\n+        }\n+        if (old != nullptr) {\n+          old->make_not_used();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3572,2 +3572,1 @@\n-      RecordComponent::allocate(_loader_data, name_index, descriptor_index,\n-                                attributes_count, generic_sig_index,\n+      RecordComponent::allocate(_loader_data, name_index, descriptor_index, generic_sig_index,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1563,0 +1563,1 @@\n+int java_lang_Thread::_interruptLock_offset;\n@@ -1576,0 +1577,1 @@\n+  macro(_interruptLock_offset, k, \"interruptLock\", object_signature, false); \\\n@@ -1658,0 +1660,3 @@\n+oop java_lang_Thread::interrupt_lock(oop java_thread) {\n+  return java_thread->obj_field(_interruptLock_offset);\n+}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -361,0 +361,1 @@\n+  static int _interruptLock_offset;\n@@ -380,0 +381,2 @@\n+  \/\/ interruptLock\n+  static oop interrupt_lock(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -729,3 +729,3 @@\n-  \/\/ Check if the protection domain is present it has the right access\n-    \/\/ Verify protection domain. If it fails an exception is thrown\n-    dictionary->validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    \/\/ A SecurityManager (if installed) may prevent this protection_domain from accessing loaded_class\n+    \/\/ by throwing a SecurityException.\n+    dictionary->check_package_access(loaded_class, class_loader, protection_domain, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1174,5 +1174,7 @@\n-  \/\/ A request has been made for compilation.  Before we do any\n-  \/\/ real work, check to see if the method has been compiled\n-  \/\/ in the meantime with a definitive result.\n-  if (compilation_is_complete(method, osr_bci, comp_level)) {\n-    return;\n+  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+    \/\/ A request has been made for compilation.  Before we do any\n+    \/\/ real work, check to see if the method has been compiled\n+    \/\/ in the meantime with a definitive result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n+    }\n@@ -1223,5 +1225,7 @@\n-    \/\/ We need to check again to see if the compilation has\n-    \/\/ completed.  A previous compilation may have registered\n-    \/\/ some result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n+    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+      \/\/ We need to check again to see if the compilation has\n+      \/\/ completed.  A previous compilation may have registered\n+      \/\/ some result.\n+      if (compilation_is_complete(method, osr_bci, comp_level)) {\n+        return;\n+      }\n@@ -1376,1 +1380,2 @@\n-    if (method_code != nullptr && method_code->is_nmethod()) {\n+    if (method_code != nullptr && method_code->is_nmethod()\n+                      && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -143,8 +143,0 @@\n-double PSParallelCompact::_dwl_mean;\n-double PSParallelCompact::_dwl_std_dev;\n-double PSParallelCompact::_dwl_first_term;\n-double PSParallelCompact::_dwl_adjustment;\n-#ifdef  ASSERT\n-bool   PSParallelCompact::_dwl_initialized = false;\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -835,1 +827,0 @@\n-  initialize_dead_wood_limiter();\n@@ -871,10 +862,0 @@\n-void PSParallelCompact::initialize_dead_wood_limiter()\n-{\n-  const size_t max = 100;\n-  _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) \/ 100.0;\n-  _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) \/ 100.0;\n-  _dwl_first_term = 1.0 \/ (sqrt(2.0 * M_PI) * _dwl_std_dev);\n-  DEBUG_ONLY(_dwl_initialized = true;)\n-  _dwl_adjustment = normal_distribution(1.0);\n-}\n-\n@@ -1011,54 +992,0 @@\n-\/\/ Return a fraction indicating how much of the generation can be treated as\n-\/\/ \"dead wood\" (i.e., not reclaimed).  The function uses a normal distribution\n-\/\/ based on the density of live objects in the generation to determine a limit,\n-\/\/ which is then adjusted so the return value is min_percent when the density is\n-\/\/ 1.\n-\/\/\n-\/\/ The following table shows some return values for a different values of the\n-\/\/ standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and\n-\/\/ min_percent is 1.\n-\/\/\n-\/\/                          fraction allowed as dead wood\n-\/\/         -----------------------------------------------------------------\n-\/\/ density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95\n-\/\/ ------- ---------- ---------- ---------- ---------- ---------- ----------\n-\/\/ 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000\n-\/\/ 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941\n-\/\/ 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272\n-\/\/ 0.15000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066\n-\/\/ 0.20000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975\n-\/\/ 0.25000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313\n-\/\/ 0.30000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132\n-\/\/ 0.35000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289\n-\/\/ 0.40000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500\n-\/\/ 0.45000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386\n-\/\/ 0.50000 0.13832410 0.11599237 0.09847664 0.08456518 0.07338887 0.06431510\n-\/\/ 0.55000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386\n-\/\/ 0.60000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500\n-\/\/ 0.65000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289\n-\/\/ 0.70000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132\n-\/\/ 0.75000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313\n-\/\/ 0.80000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975\n-\/\/ 0.85000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066\n-\/\/ 0.90000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272\n-\/\/ 0.95000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941\n-\/\/ 1.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000\n-\n-double PSParallelCompact::dead_wood_limiter(double density, size_t min_percent)\n-{\n-  assert(_dwl_initialized, \"uninitialized\");\n-\n-  \/\/ The raw limit is the value of the normal distribution at x = density.\n-  const double raw_limit = normal_distribution(density);\n-\n-  \/\/ Adjust the raw limit so it becomes the minimum when the density is 1.\n-  \/\/\n-  \/\/ First subtract the adjustment value (which is simply the precomputed value\n-  \/\/ normal_distribution(1.0)); this yields a value of 0 when the density is 1.\n-  \/\/ Then add the minimum value, so the minimum is returned when the density is\n-  \/\/ 1.  Finally, prevent negative values, which occur when the mean is not 0.5.\n-  const double min = double(min_percent) \/ 100.0;\n-  const double limit = raw_limit - _dwl_adjustment + min;\n-  return MAX2(limit, 0.0);\n-}\n-\n@@ -1095,61 +1022,0 @@\n-ParallelCompactData::RegionData*\n-PSParallelCompact::dead_wood_limit_region(const RegionData* beg,\n-                                          const RegionData* end,\n-                                          size_t dead_words)\n-{\n-  ParallelCompactData& sd = summary_data();\n-  size_t left = sd.region(beg);\n-  size_t right = end > beg ? sd.region(end) - 1 : left;\n-\n-  \/\/ Binary search.\n-  while (left < right) {\n-    \/\/ Equivalent to (left + right) \/ 2, but does not overflow.\n-    const size_t middle = left + (right - left) \/ 2;\n-    RegionData* const middle_ptr = sd.region(middle);\n-    HeapWord* const dest = middle_ptr->destination();\n-    HeapWord* const addr = sd.region_to_addr(middle);\n-    assert(dest != nullptr, \"sanity\");\n-    assert(dest <= addr, \"must move left\");\n-\n-    const size_t dead_to_left = pointer_delta(addr, dest);\n-    if (middle > left && dead_to_left > dead_words) {\n-      right = middle - 1;\n-    } else if (middle < right && dead_to_left < dead_words) {\n-      left = middle + 1;\n-    } else {\n-      return middle_ptr;\n-    }\n-  }\n-  return sd.region(left);\n-}\n-\n-\/\/ The result is valid during the summary phase, after the initial summarization\n-\/\/ of each space into itself, and before final summarization.\n-inline double\n-PSParallelCompact::reclaimed_ratio(const RegionData* const cp,\n-                                   HeapWord* const bottom,\n-                                   HeapWord* const top,\n-                                   HeapWord* const new_top)\n-{\n-  ParallelCompactData& sd = summary_data();\n-\n-  assert(cp != nullptr, \"sanity\");\n-  assert(bottom != nullptr, \"sanity\");\n-  assert(top != nullptr, \"sanity\");\n-  assert(new_top != nullptr, \"sanity\");\n-  assert(top >= new_top, \"summary data problem?\");\n-  assert(new_top > bottom, \"space is empty; should not be here\");\n-  assert(new_top >= cp->destination(), \"sanity\");\n-  assert(top >= sd.region_to_addr(cp), \"sanity\");\n-\n-  HeapWord* const destination = cp->destination();\n-  const size_t dense_prefix_live  = pointer_delta(destination, bottom);\n-  const size_t compacted_region_live = pointer_delta(new_top, destination);\n-  const size_t compacted_region_used = pointer_delta(top,\n-                                                     sd.region_to_addr(cp));\n-  const size_t reclaimable = compacted_region_used - compacted_region_live;\n-\n-  const double divisor = dense_prefix_live + 1.25 * compacted_region_live;\n-  return double(reclaimable) \/ divisor;\n-}\n-\n@@ -1205,35 +1071,14 @@\n-  const size_t space_live = pointer_delta(new_top, bottom);\n-  const size_t space_used = space->used_in_words();\n-  const size_t space_capacity = space->capacity_in_words();\n-\n-  const double density = double(space_live) \/ double(space_capacity);\n-  const size_t min_percent_free = MarkSweepDeadRatio;\n-  const double limiter = dead_wood_limiter(density, min_percent_free);\n-  const size_t dead_wood_max = space_used - space_live;\n-  const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),\n-                                      dead_wood_max);\n-\n-  log_develop_debug(gc, compaction)(\n-      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n-      \"space_cap=\" SIZE_FORMAT,\n-      space_live, space_used,\n-      space_capacity);\n-  log_develop_debug(gc, compaction)(\n-      \"dead_wood_limiter(%6.4f, \" SIZE_FORMAT \")=%6.4f \"\n-      \"dead_wood_max=\" SIZE_FORMAT \" dead_wood_limit=\" SIZE_FORMAT,\n-      density, min_percent_free, limiter,\n-      dead_wood_max, dead_wood_limit);\n-\n-  \/\/ Locate the region with the desired amount of dead space to the left.\n-  const RegionData* const limit_cp =\n-    dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);\n-\n-  \/\/ Scan from the first region with dead space to the limit region and find the\n-  \/\/ one with the best (largest) reclaimed ratio.\n-  double best_ratio = 0.0;\n-  const RegionData* best_cp = full_cp;\n-  for (const RegionData* cp = full_cp; cp < limit_cp; ++cp) {\n-    double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);\n-    if (tmp_ratio > best_ratio) {\n-      best_cp = cp;\n-      best_ratio = tmp_ratio;\n+  \/\/ Iteration starts with the region *after* the full-region-prefix-end.\n+  const RegionData* const start_region = full_cp;\n+  \/\/ If final region is not full, iteration stops before that region,\n+  \/\/ because fill_dense_prefix_end assumes that prefix_end <= top.\n+  const RegionData* const end_region = sd.addr_to_region_ptr(space->top());\n+  assert(start_region <= end_region, \"inv\");\n+\n+  size_t max_waste = space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n+  const RegionData* cur_region = start_region;\n+  for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+    assert(region_size >= cur_region->data_size(), \"inv\");\n+    size_t dead_size = region_size - cur_region->data_size();\n+    if (max_waste < dead_size) {\n+      break;\n@@ -1241,0 +1086,1 @@\n+    max_waste -= dead_size;\n@@ -1243,1 +1089,5 @@\n-  return sd.region_to_addr(best_cp);\n+  HeapWord* const prefix_end = sd.region_to_addr(cur_region);\n+  assert(sd.is_region_aligned(prefix_end), \"postcondition\");\n+  assert(prefix_end >= sd.region_to_addr(full_cp), \"in-range\");\n+  assert(prefix_end <= space->top(), \"in-range\");\n+  return prefix_end;\n@@ -1260,4 +1110,13 @@\n-  \/\/ Since both markword and klass takes 1 heap word, the min-obj-size is 2\n-  \/\/ heap words.\n-  \/\/ If min-fill-size decreases to 1, this whole method becomes redundant.\n-  assert(CollectedHeap::min_fill_size() == 2, \"inv\");\n+  \/\/ Comparing two sizes to decide if filling is required:\n+  \/\/\n+  \/\/ The size of the filler (min-obj-size) is 2 heap words with the default\n+  \/\/ MinObjAlignment, since both markword and klass take 1 heap word.\n+  \/\/\n+  \/\/ The size of the gap (if any) right before dense-prefix-end is\n+  \/\/ MinObjAlignment.\n+  \/\/\n+  \/\/ Need to fill in the gap only if it's smaller than min-obj-size, and the\n+  \/\/ filler obj will extend to next region.\n+\n+  \/\/ Note: If min-fill-size decreases to 1, this whole method becomes redundant.\n+  assert(CollectedHeap::min_fill_size() >= 2, \"inv\");\n@@ -1265,3 +1124,2 @@\n-  \/\/ In 32-bit system, min-obj-alignment is >= 8 bytes, so the gap (if any)\n-  \/\/ right before denses-prefix must be greater than min-fill-size; nothing to\n-  \/\/ do.\n+  \/\/ In 32-bit system, each heap word is 4 bytes, so MinObjAlignment == 2.\n+  \/\/ The gap is always equal to min-fill-size, so nothing to do.\n@@ -1270,0 +1128,4 @@\n+  if (MinObjAlignment > 1) {\n+    return;\n+  }\n+  assert(CollectedHeap::min_fill_size() == 2, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":39,"deletions":177,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                                      size_t* actual_size);\n+                                      size_t* actual_size) = 0;\n@@ -349,4 +349,1 @@\n-  virtual size_t unsafe_max_tlab_alloc(Thread *thr) const {\n-    guarantee(false, \"thread-local allocation buffers not supported\");\n-    return 0;\n-  }\n+  virtual size_t unsafe_max_tlab_alloc(Thread *thr) const = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,0 @@\n-    DO_DISCOVERED_AND_DISCOVERY, \/\/ Apply closure to discovered field and do discovery\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -841,0 +841,8 @@\n+  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker,\n+  \/\/ because the directives can be updated.\n+  void clear_directive_flags() {\n+    set_has_matching_directives(false);\n+    clear_is_not_c1_compilable();\n+    clear_is_not_c2_compilable();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,2 +61,3 @@\n-   status(has_scalarized_args         , 1 << 16) \\\n-   status(has_scalarized_return       , 1 << 17) \\\n+   status(has_matching_directives     , 1 << 16) \/* Temporary mark, used only when methods are to be refreshed to reflect a compiler directives update *\/ \\\n+   status(has_scalarized_args         , 1 << 17) \\\n+   status(has_scalarized_return       , 1 << 18) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-static Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1103,0 +1103,8 @@\n+Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxLNode(phase->C, a, b);\n+  } else {\n+    return new MinLNode(phase->C, a, b);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1627,2 +1627,4 @@\n-      \/\/ Also record the actual load (LoadN) in case ld is DecodeN\n-      assert(ld->in(1)->Opcode() == Op_LoadN, \"Assumption invalid: input to DecodeN is not LoadN\");\n+      \/\/ Also record the actual load (LoadN) in case ld is DecodeN. In some\n+      \/\/ rare corner cases, ld->in(1) can be something other than LoadN (e.g.,\n+      \/\/ a Phi). Recording such cases is still perfectly sound, but may be\n+      \/\/ unnecessary and result in some minor IGVN overhead.\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1054,0 +1054,4 @@\n+  if (adjusted_val->is_top() || adjusted_lim->is_top()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1720,2 +1720,2 @@\n-  int extract_long_range_checks(const IdealLoopTree* loop, jlong stride_con, int iters_limit, PhiNode* phi,\n-                                      Node_List &range_checks);\n+  int extract_long_range_checks(const IdealLoopTree* loop, jint stride_con, int iters_limit, PhiNode* phi,\n+                                Node_List &range_checks);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,1 +263,1 @@\n-    st->print(\" profiled at: \");\n+    st->print(\" profiled at:\");\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -518,1 +518,0 @@\n-      assert(component->attributes_count() > 0, \"Bad component attributes count\");\n@@ -535,1 +534,5 @@\n-    write_u2(component->attributes_count());\n+    u2 attributes_count = (component->generic_signature_index() != 0 ? 1 : 0)\n+                        + (component->annotations() != nullptr ? 1 : 0)\n+                        + (component->type_annotations() != nullptr ? 1 : 0);\n+\n+    write_u2(attributes_count);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1366,10 +1366,2 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n-    if (java_thread != nullptr) {\n-      VirtualThreadGetOwnedMonitorInfoClosure op(this,\n-                                                 Handle(calling_thread, thread_oop),\n-                                                 owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n-  } else {\n+  if (java_thread != nullptr) {\n+    Handle thread_handle(calling_thread, thread_oop);\n@@ -1381,11 +1373,4 @@\n-\n-    if (java_thread == calling_thread) {\n-      \/\/ It is only safe to make a direct call on the current thread.\n-      \/\/ All other usage needs to use a direct handshake for safety.\n-      err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);\n-    } else {\n-      \/\/ get owned monitors info with handshake\n-      GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+    err = op.result();\n@@ -1439,10 +1424,2 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n-    if (java_thread != nullptr) {\n-      VirtualThreadGetOwnedMonitorInfoClosure op(this,\n-                                                 Handle(calling_thread, thread_oop),\n-                                                 owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n-  } else {\n+  if (java_thread != nullptr) {\n+    Handle thread_handle(calling_thread, thread_oop);\n@@ -1454,11 +1431,4 @@\n-\n-    if (java_thread == calling_thread) {\n-      \/\/ It is only safe to make a direct call on the current thread.\n-      \/\/ All other usage needs to use a direct handshake for safety.\n-      err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);\n-    } else {\n-      \/\/ get owned monitors info with handshake\n-      GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+    err = op.result();\n@@ -1466,0 +1436,1 @@\n+\n@@ -1495,5 +1466,1 @@\n-  JavaThread* calling_thread = JavaThread::current();\n-  HandleMark hm(calling_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(calling_thread);\n+  JavaThread* current = JavaThread::current();\n@@ -1501,6 +1468,1 @@\n-  JavaThread* java_thread = nullptr;\n-  oop thread_oop = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n+  *monitor_ptr = nullptr;\n@@ -1508,25 +1470,4 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n-    if (java_thread != nullptr) {\n-      GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ true);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    } else {\n-      *monitor_ptr = nullptr;\n-      if (!JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n-        err = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-      }\n-    }\n-    return err;\n-  }\n-  if (java_thread == calling_thread) {\n-    \/\/ It is only safe to make a direct call on the current thread.\n-    \/\/ All other usage needs to use a direct handshake for safety.\n-    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr, \/* is_virtual *\/ false);\n-  } else {\n-    \/\/ get contended monitor information with handshake\n-    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ false);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-  return err;\n+  \/\/ get contended monitor information with handshake\n+  GetCurrentContendedMonitorClosure op(this, current, monitor_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":78,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -85,6 +85,4 @@\n-\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n-\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n-\/\/ it is expected that we are not allowed to touch the underlying memory\n-\/\/ that might have gotten unmapped. Therefore, we check at the entry\n-\/\/ to unsafe functions, if we have such async exception conditions,\n-\/\/ and return immediately if that is the case.\n+\/\/ All memory access methods (e.g. getInt, copyMemory) must use this macro.\n+\/\/ We call these methods \"scoped\" methods, as access to these methods is\n+\/\/ typically governed by a \"scope\" (a MemorySessionImpl object), and no\n+\/\/ access is allowed when the scope is no longer alive.\n@@ -92,6 +90,6 @@\n-\/\/ We can't have safepoints in this code.\n-\/\/ It would be problematic if an async exception handshake were installed later on\n-\/\/ during another safepoint in the function, but before the memory access happens,\n-\/\/ as the memory will be freed after the handshake is installed. We must notice\n-\/\/ the installed handshake and return early before doing the memory access to prevent\n-\/\/ accesses to freed memory.\n+\/\/ Closing a scope object (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async exception during a safepoint. When that happens,\n+\/\/ scoped methods are not allowed to touch the underlying memory (as that\n+\/\/ memory might have been released). Therefore, when entering a scoped method\n+\/\/ we check if an async exception has been installed, and return immediately\n+\/\/ if that is the case.\n@@ -99,5 +97,8 @@\n-\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n-\/\/ state. Since we rely on a handshake to check for threads that are accessing\n-\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n-\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n-\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n+\/\/ As a rule, we disallow safepoints in the middle of a scoped method.\n+\/\/ If an async exception handshake were installed in such a safepoint,\n+\/\/ memory access might still occur before the handshake is honored by\n+\/\/ the accessing thread.\n+\/\/\n+\/\/ Corollary: as threads in native state are considered to be at a safepoint,\n+\/\/ scoped methods must NOT be executed while in the native thread state.\n+\/\/ Because of this, there can be no UNSAFE_LEAF_SCOPED.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -505,1 +505,5 @@\n-\n+#if defined(X86)\n+  { \"UseRTMLocking\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"UseRTMDeopt\",                  JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"RTMRetryCount\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+#endif \/\/ X86\n@@ -534,0 +538,3 @@\n+\n+  { \"ParallelOldDeadWoodLimiterMean\",   JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"ParallelOldDeadWoodLimiterStdDev\", JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2010,1 +2010,1 @@\n-  product(int, LockingMode, LM_LEGACY,                                      \\\n+  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n@@ -2013,2 +2013,2 @@\n-          \"1: monitors & legacy stack-locking (LM_LEGACY, default), \"       \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n+          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,0 +193,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+  oop result = vthread();\n+  if (result == nullptr) {\n+    result = threadObj();\n+  }\n+  return result;\n+}\n+\n@@ -548,1 +558,0 @@\n-\n@@ -583,0 +592,2 @@\n+  return interrupted;\n+}\n@@ -584,0 +595,28 @@\n+\/\/ This is only for use by JVMTI RawMonitorWait. It emulates the actions of\n+\/\/ the Java code in Object::wait which are not present in RawMonitorWait.\n+bool JavaThread::get_and_clear_interrupted() {\n+  if (!is_interrupted(false)) {\n+    return false;\n+  }\n+  oop thread_oop = vthread_or_thread();\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+\n+  if (!is_virtual) {\n+    return is_interrupted(true);\n+  }\n+  \/\/ Virtual thread: clear interrupt status for both virtual and\n+  \/\/ carrier threads under the interruptLock protection.\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+  Handle thread_h(current, thread_oop);\n+  ObjectLocker lock(Handle(current, java_lang_Thread::interrupt_lock(thread_h())), current);\n+\n+  \/\/ re-check the interrupt status under the interruptLock protection\n+  bool interrupted = java_lang_Thread::interrupted(thread_h());\n+\n+  if (interrupted) {\n+    assert(this == Thread::current(), \"only the current thread can clear\");\n+    java_lang_Thread::set_interrupted(thread_h(), false);  \/\/ clear for virtual\n+    java_lang_Thread::set_interrupted(threadObj(), false); \/\/ clear for carrier\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  oop vthread_or_thread() const;\n@@ -1158,0 +1159,4 @@\n+  \/\/ This is only for use by JVMTI RawMonitorWait. It emulates the actions of\n+  \/\/ the Java code in Object::wait which are not present in RawMonitorWait.\n+  bool get_and_clear_interrupted();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n@@ -514,7 +511,0 @@\n-bool SafepointSynchronize::is_cleanup_needed() {\n-  \/\/ Need a safepoint if some inline cache buffers is non-empty\n-  if (StringTable::needs_rehashing()) return true;\n-  if (SymbolTable::needs_rehashing()) return true;\n-  return false;\n-}\n-\n@@ -552,8 +542,0 @@\n-    if (SymbolTable::rehash_table_expects_safepoint_rehashing()) {\n-      workers++;\n-    }\n-\n-    if (StringTable::rehash_table_expects_safepoint_rehashing()) {\n-      workers++;\n-    }\n-\n@@ -568,15 +550,0 @@\n-    \/\/ These tasks are ordered by relative length of time to execute so that potentially longer tasks start first.\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH)) {\n-      if (SymbolTable::needs_rehashing()) {\n-        Tracer t(\"rehashing symbol table\");\n-        SymbolTable::rehash_table();\n-      }\n-    }\n-\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_STRING_TABLE_REHASH)) {\n-      if (StringTable::needs_rehashing()) {\n-        Tracer t(\"rehashing string table\");\n-        StringTable::rehash_table();\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-  template(Cleanup)                               \\\n@@ -109,0 +108,2 @@\n+  template(RehashStringTable)                     \\\n+  template(RehashSymbolTable)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n@@ -106,0 +108,8 @@\n+void VM_RehashStringTable::doit() {\n+  StringTable::rehash_table();\n+}\n+\n+void VM_RehashSymbolTable::doit() {\n+  SymbolTable::rehash_table();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,5 +57,0 @@\n-class VM_Cleanup: public VM_EmptyOperation {\n- public:\n-  VMOp_Type type() const { return VMOp_Cleanup; }\n-};\n-\n@@ -101,0 +96,14 @@\n+class VM_RehashStringTable : public VM_Operation {\n+ public:\n+  VM_RehashStringTable() {}\n+  VMOp_Type type() const                         { return VMOp_RehashStringTable; }\n+  void doit();\n+};\n+\n+class VM_RehashSymbolTable : public VM_Operation {\n+ public:\n+  VM_RehashSymbolTable() {}\n+  VMOp_Type type() const                         { return VMOp_RehashSymbolTable; }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -926,1 +927,3 @@\n-  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n+\n@@ -928,0 +931,1 @@\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -932,0 +936,37 @@\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches(true);\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+}\n+\n+CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+  _dcmdparser.add_dcmd_option(&_refresh);\n+}\n+\n+void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n+  \/\/ Need to mark the methods twice, to account for the method that doesn't match\n+  \/\/ the directives anymore\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches();\n+\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n+\n+    CodeCache::mark_directives_matches();\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n+  }\n+}\n+\n+CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -935,1 +976,14 @@\n-  DirectivesStack::pop(1);\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches(true);\n+    DirectivesStack::pop(1);\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::pop(1);\n+  }\n+}\n+\n+CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -939,1 +993,7 @@\n-  DirectivesStack::clear();\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches();\n+    DirectivesStack::clear();\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::clear();\n+  }\n@@ -941,0 +1001,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":64,"deletions":3,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -716,1 +716,3 @@\n-class CompilerDirectivesRemoveDCmd : public DCmd {\n+class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -718,1 +720,2 @@\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n@@ -739,0 +742,1 @@\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -740,1 +744,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -759,1 +763,27 @@\n-class CompilerDirectivesClearDCmd : public DCmd {\n+class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _filename;\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.directives_replace\";\n+  }\n+  static const char* description() {\n+    return \"Clear directives stack, and load new compiler directives from file.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class CompilerDirectivesClearDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -761,1 +791,2 @@\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -382,0 +382,3 @@\n+#define RANGEFMT              \"[\" PTR_FORMAT \" - \" PTR_FORMAT \"), (\" SIZE_FORMAT \" bytes)\"\n+#define RANGEFMTARGS(p1, size) p2i(p1), p2i(p1 + size), size\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2698,0 +2698,5 @@\n+\n+            @Override\n+            public boolean allowSecurityManager() {\n+                return System.allowSecurityManager();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -471,1 +471,2 @@\n-                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n+                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class ||\n+                                selectorType == Long.class || selectorType == Float.class || selectorType == Double.class) {\n@@ -478,1 +479,1 @@\n-                            if (selectorType == long.class) {\n+                            if (selectorType == long.class || selectorType == Long.class) {\n@@ -482,1 +483,1 @@\n-                            } else if (selectorType == float.class) {\n+                            } else if (selectorType == float.class || selectorType == Float.class) {\n@@ -486,1 +487,1 @@\n-                            } else if (selectorType == double.class) {\n+                            } else if (selectorType == double.class || selectorType == Double.class) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -602,0 +602,6 @@\n+\n+    \/**\n+     * Is a security manager already set or allowed to be set\n+     * (using -Djava.security.manager=allow)?\n+     *\/\n+    boolean allowSecurityManager();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-        @JEP(number=0, title=\"Test Feature\")\n+        @JEP(number=2_147_483_647, title=\"Test Feature\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2505,0 +2505,3 @@\n+            if (tree.expr != null) {\n+                attribExpr(tree.expr, env, env.info.yieldResult.pt);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2997,3 +2997,1 @@\n-                exactnessCheck = make\n-                        .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1)))\n-                        .setType(syms.booleanType);\n+                exactnessCheck = make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1));\n@@ -3002,3 +3000,5 @@\n-                JCExpression nullCheck = makeBinary(NE,\n-                        make.Ident(dollar_s),\n-                        makeNull());\n+                JCExpression nullCheck =\n+                        makeBinary(NE,\n+                            make.Ident(dollar_s),\n+                            makeNull());\n+\n@@ -3006,3 +3006,1 @@\n-                    exactnessCheck = make\n-                            .LetExpr(List.of(var), nullCheck)\n-                            .setType(syms.booleanType);\n+                    exactnessCheck = nullCheck;\n@@ -3010,2 +3008,4 @@\n-                    exactnessCheck = getExactnessCheck(tree,\n-                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                    exactnessCheck =\n+                        makeBinary(AND,\n+                            nullCheck,\n+                            getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n@@ -3013,3 +3013,6 @@\n-                    exactnessCheck = make.at(tree.pos())\n-                            .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n-                            .setType(syms.booleanType);\n+                    exactnessCheck =\n+                        makeBinary(AND,\n+                            nullCheck,\n+                            make.at(tree.pos())\n+                                .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                                .setType(syms.booleanType));\n@@ -3017,5 +3020,0 @@\n-\n-                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n-                        nullCheck,\n-                        exactnessCheck))\n-                        .setType(syms.booleanType);\n@@ -3024,7 +3022,1 @@\n-                JCIdent argument = make.Ident(dollar_s);\n-\n-                JCExpression exactnessCheckCall =\n-                        getExactnessCheck(tree, argument);\n-\n-                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n-                        .setType(syms.booleanType);\n+                exactnessCheck = getExactnessCheck(tree, make.Ident(dollar_s));\n@@ -3033,1 +3025,2 @@\n-            result = exactnessCheck;\n+            result = make.LetExpr(List.of(var), exactnessCheck)\n+                    .setType(syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2917,0 +2917,1 @@\n+                        boolean inTypeArgs = false;\n@@ -2922,1 +2923,3 @@\n-                                case COMMA: if (balance == 1) hasComma = true; break;\n+                                case COMMA: if (balance == 1 && !inTypeArgs) hasComma = true; break;\n+                                case LT: inTypeArgs = true; break;\n+                                case GT: inTypeArgs = false;\n@@ -4005,1 +4008,1 @@\n-                semiList.append(toP(F.at(token.pos).Skip()));\n+                int pos = token.pos;\n@@ -4007,0 +4010,1 @@\n+                semiList.append(toP(F.at(pos).Skip()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -875,0 +875,5 @@\n+    public static final String MAX_VL = VECTOR_PREFIX + \"MAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(MAX_VL, \"MaxV\", TYPE_LONG);\n+    }\n+\n@@ -935,0 +940,5 @@\n+    public static final String MIN_VL = VECTOR_PREFIX + \"MIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(MIN_VL, \"MinV\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,4 +82,1 @@\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and exit with\n-     * either status 95 or 97 (JCK-like exit status).\n-     *\/\n+\n@@ -87,2 +84,5 @@\n-        int exitCode = run(argv,System.out);\n-        System.exit(exitCode + 95\/*STATUS_TEMP*\/);\n+        int result = run(argv,System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"TEST FAILED with result \" + result);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/Accessible\/modifiers\/modifiers001.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-java\/awt\/Focus\/NonFocusableWindowTest\/NonfocusableOwnerTest.java 8280392 windows-x64\n@@ -434,1 +433,0 @@\n-java\/awt\/Frame\/DisposeParentGC\/DisposeParentGC.java 8079786 macosx-all\n@@ -793,1 +791,1 @@\n-javax\/swing\/JTabbedPane\/4666224\/bug4666224.html 8144124  macosx-all\n+javax\/swing\/JTabbedPane\/4666224\/bug4666224.java 8144124  macosx-all\n@@ -801,1 +799,0 @@\n-java\/awt\/dnd\/DnDFileGroupDescriptor\/DnDFileGroupDescriptor.html 8080185 macosx-all,linux-all\n@@ -806,2 +803,1 @@\n-java\/awt\/TrayIcon\/DblClickActionEventTest\/DblClickActionEventTest.html 8203867 macosx-all\n-java\/awt\/Frame\/FrameStateTest\/FrameStateTest.html 8203920 macosx-all,linux-all\n+java\/awt\/Frame\/FrameStateTest\/FrameStateTest.java 8203920 macosx-all,linux-all\n@@ -809,1 +805,1 @@\n-java\/awt\/font\/TextLayout\/TestJustification.html 8250791 macosx-all\n+java\/awt\/font\/TextLayout\/TestJustification.java 8250791 macosx-all\n@@ -812,1 +808,0 @@\n-java\/awt\/FileDialog\/RegexpFilterTest\/RegexpFilterTest.html 7187728 macosx-all,linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-    security\/infra\/java\/security\/cert\/CertPathValidator\/certification\n+    security\/infra\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -423,1 +423,2 @@\n-     * @return true if compiler in use supports RTM and false otherwise.\n+     * @return \"true\" if compiler in use supports RTM and \"false\" otherwise.\n+     * Note: Lightweight locking does not support RTM (for now).\n@@ -429,1 +430,2 @@\n-            (Platform.isX86() || Platform.isX64() || Platform.isPPC())) {\n+            (Platform.isX86() || Platform.isX64() || Platform.isPPC()) &&\n+            is_LM_LIGHTWEIGHT().equals(\"false\")) {\n@@ -485,0 +487,28 @@\n+    \/**\n+     * @return LockingMode.\n+     *\/\n+    protected String vmLockingMode() {\n+        return \"\" + WB.getIntVMFlag(\"LockingMode\");\n+    }\n+\n+    \/**\n+     * @return \"true\" if LockingMode == 0 (LM_MONITOR)\n+     *\/\n+    protected String is_LM_MONITOR() {\n+        return \"\" + vmLockingMode().equals(\"0\");\n+    }\n+\n+    \/**\n+     * @return \"true\" if LockingMode == 1 (LM_LEGACY)\n+     *\/\n+    protected String is_LM_LEGACY() {\n+        return \"\" + vmLockingMode().equals(\"1\");\n+    }\n+\n+    \/**\n+     * @return \"true\" if LockingMode == 2 (LM_LIGHTWEIGHT)\n+     *\/\n+    protected String is_LM_LIGHTWEIGHT() {\n+        return \"\" + vmLockingMode().equals(\"2\");\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869 8235876\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339\n@@ -114,0 +114,21 @@\n+    @Test\n+    public void testHelloWorldInPackageWithStaticImport(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                \"\"\"\n+                package hello;\n+                import static hello.Helper.*;\n+                import java.util.Arrays;\n+                class World {\n+                    public static void main(String... args) {\n+                        m(args);\n+                    }\n+                }\n+                class Helper {\n+                    static void m(String... args) {\n+                        System.out.println(\"Hello World! \" + Arrays.toString(args));\n+                    }\n+                }\n+                \"\"\");\n+        testSuccess(base.resolve(\"hello\").resolve(\"World.java\"), \"Hello World! [1, 2, 3]\\n\");\n+    }\n+\n@@ -304,1 +325,1 @@\n-        Files.write(file, List.of(\"package p;\"));\n+        Files.write(file, List.of(\"package p; class MismatchOfPathAndPackage {}\"));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaFileObject;\n+import java.util.List;\n+\n@@ -86,0 +90,12 @@\n+    \/\/ potential not-exhaustive errors are expected and filtered out in `doWork`\n+    private static final String test3 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    switch(in) {\n+                       case #{TYPE2} x -> {}\n+                    }\n+                }\n+            }\n+            \"\"\";\n+\n@@ -91,1 +107,1 @@\n-                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+                .withOption(\"-source\").withOption(JAVA_VERSION);\n@@ -96,1 +112,6 @@\n-                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+                .withOption(\"-source\").withOption(JAVA_VERSION);\n+\n+        ComboTask task3 = newCompilationTask()\n+                .withSourceFromTemplate(test3.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);\n@@ -100,5 +121,12 @@\n-                if (result1.hasErrors() ^ result2.hasErrors()) {\n-                    throw new AssertionError(\"Unexpected result: \" +\n-                            \"\\n task1: \" + result1.hasErrors() + \", info: \" + result1.compilationInfo() +\n-                            \"\\n task1: \" + result2.hasErrors() + \", info: \" + result2.compilationInfo());\n-                }\n+                task3.generate(result3 -> {\n+                    List<Diagnostic<? extends JavaFileObject>> list1 = result1.diagnosticsForKind(Diagnostic.Kind.ERROR);\n+                    List<Diagnostic<? extends JavaFileObject>> list2 = result2.diagnosticsForKind(Diagnostic.Kind.ERROR);\n+                    List<Diagnostic<? extends JavaFileObject>> list3 = result3.diagnosticsForKind(Diagnostic.Kind.ERROR).stream().filter(e -> !e.getCode().equals(\"compiler.err.not.exhaustive.statement\")).toList();\n+                    if (!(list1.size() == list2.size() && list3.size() == list2.size())) {\n+                        throw new AssertionError(\"Unexpected result: \" +\n+                                \"\\n task1: \" + result1.hasErrors() + \", info: \" + result1.compilationInfo() +\n+                                \"\\n task2: \" + result2.hasErrors() + \", info: \" + result2.compilationInfo() +\n+                                \"\\n task3: \" + result3.hasErrors() + \", info: \" + result3.compilationInfo()\n+                        );\n+                    }\n+                });\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,5 @@\n+            JavaThing coder = getField(\"coder\");\n+            boolean compact = false;\n+            if (coder instanceof JavaByte) {\n+                compact = ((JavaByte)coder).value == 0;\n+            }\n@@ -198,1 +203,1 @@\n-                return ((JavaValueArray)value).valueAsString();\n+                return ((JavaValueArray)value).valueAsString(compact);\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -371,0 +372,12 @@\n+    private static final int STRING_HI_BYTE_SHIFT;\n+    private static final int STRING_LO_BYTE_SHIFT;\n+    static {\n+        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n+            STRING_HI_BYTE_SHIFT = 8;\n+            STRING_LO_BYTE_SHIFT = 0;\n+        } else {\n+            STRING_HI_BYTE_SHIFT = 0;\n+            STRING_LO_BYTE_SHIFT = 8;\n+        }\n+    }\n+\n@@ -372,1 +385,1 @@\n-    public String valueAsString() {\n+    public String valueAsString(boolean compact) {\n@@ -375,3 +388,14 @@\n-            byte[] bytes = new byte[things.length];\n-            for (int i = 0; i < things.length; i++) {\n-                bytes[i] = ((JavaByte)things[i]).value;\n+            if (compact) {\n+                byte[] bytes = new byte[things.length];\n+                for (int i = 0; i < things.length; i++) {\n+                    bytes[i] = ((JavaByte)things[i]).value;\n+                }\n+                return new String(bytes);\n+            } else {\n+                char[] chars = new char[things.length \/ 2];\n+                for (int i = 0; i < things.length; i += 2) {\n+                    int b1 = ((JavaByte)things[i]).value     << STRING_HI_BYTE_SHIFT;\n+                    int b2 = ((JavaByte)things[i + 1]).value << STRING_LO_BYTE_SHIFT;\n+                    chars[i \/ 2] = (char)(b1 | b2);\n+                }\n+                return new String(chars);\n@@ -379,1 +403,0 @@\n-            return new String(bytes);\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"}]}