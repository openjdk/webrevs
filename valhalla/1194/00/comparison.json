{"files":[{"patch":"@@ -117,2 +117,1 @@\n-  Node_List unswitch_iffs;\n-  if (phase->find_unswitch_candidate(this, unswitch_iffs) == nullptr) {\n+  if (no_unswitch_candidate()) {\n@@ -126,0 +125,7 @@\n+\/\/ Check the absence of any If node that can be used for Loop Unswitching. In that case, no Loop Unswitching can be done.\n+bool IdealLoopTree::no_unswitch_candidate() const {\n+  ResourceMark rm;\n+  Node_List dont_care;\n+  return _phase->find_unswitch_candidates(this, dont_care) == nullptr;\n+}\n+\n@@ -127,2 +133,39 @@\n-\/\/ one in the loop body. Return the \"unswitch candidate\" If to apply Loop Unswitching on.\n-IfNode* PhaseIdealLoop::find_unswitch_candidate(const IdealLoopTree* loop, Node_List& unswitch_iffs) const {\n+\/\/ one in the loop body as \"unswitch candidate\" to apply Loop Unswitching on.\n+\/\/ Depending on whether we find such a candidate and if we do, whether it's a flat array check, we do the following:\n+\/\/ (1) Candidate is not a flat array check:\n+\/\/     Return the unique unswitch candidate.\n+\/\/ (2) Candidate is a flat array check:\n+\/\/     Collect all remaining non-loop-exiting flat array checks in the loop body in the provided 'flat_array_checks'\n+\/\/     list in order to create an unswitched loop version without any flat array checks and a version with checks\n+\/\/     (i.e. same as original loop). Return the initially found candidate which could be unique if no further flat array\n+\/\/     checks are found.\n+\/\/ (3) No candidate is initially found:\n+\/\/     As in (2), we collect all non-loop-exiting flat array checks in the loop body in the provided 'flat_array_checks'\n+\/\/     list. Pick the first collected flat array check as unswitch candidate, which could be unique, and return it (a).\n+\/\/     If there are no flat array checks, we cannot apply Loop Unswitching (b).\n+\/\/\n+\/\/ Note that for both (2) and (3a), if there are multiple flat array checks, then the candidate's FlatArrayCheckNode is\n+\/\/ later updated in Loop Unswitching to perform a flat array check on all collected flat array checks.\n+IfNode* PhaseIdealLoop::find_unswitch_candidates(const IdealLoopTree* loop, Node_List& flat_array_checks) const {\n+  IfNode* unswitch_candidate = find_unswitch_candidate_from_idoms(loop);\n+  if (unswitch_candidate != nullptr && !unswitch_candidate->is_flat_array_check(&_igvn)) {\n+    \/\/ Case (1)\n+    return unswitch_candidate;\n+  }\n+\n+  collect_flat_array_checks(loop, flat_array_checks);\n+  if (unswitch_candidate != nullptr) {\n+    \/\/ Case (2)\n+    assert(unswitch_candidate->is_flat_array_check(&_igvn), \"is a flat array check\");\n+    return unswitch_candidate;\n+  } else if (flat_array_checks.size() > 0) {\n+    \/\/ Case (3a): Pick first one found as candidate (there could be multiple).\n+    return flat_array_checks[0]->as_If();\n+  }\n+\n+  \/\/ Case (3b): No suitable unswitch candidate found.\n+  return nullptr;\n+}\n+\n+\/\/ Find an unswitch candidate by following the idom chain from the loop back edge.\n+IfNode* PhaseIdealLoop::find_unswitch_candidate_from_idoms(const IdealLoopTree* loop) const {\n@@ -152,16 +195,11 @@\n-  if (unswitch_candidate != nullptr) {\n-    unswitch_iffs.push(unswitch_candidate);\n-  }\n-\n-  \/\/ Collect all non-flat array checks for unswitching to create a fast loop\n-  \/\/ without checks (only non-flat array accesses) and a slow loop with checks.\n-  if (unswitch_candidate == nullptr || unswitch_candidate->is_flat_array_check(&_igvn)) {\n-    for (uint i = 0; i < loop->_body.size(); i++) {\n-      IfNode* n = loop->_body.at(i)->isa_If();\n-      if (n != nullptr && n != unswitch_candidate && n->is_flat_array_check(&_igvn) &&\n-          loop->is_invariant(n->in(1)) && !loop->is_loop_exit(n)) {\n-        unswitch_iffs.push(n);\n-        if (unswitch_candidate == nullptr) {\n-          unswitch_candidate = n;\n-        }\n-      }\n+  return unswitch_candidate;\n+}\n+\n+\/\/ Collect all flat array checks in the provided 'flat_array_checks' list.\n+void PhaseIdealLoop::collect_flat_array_checks(const IdealLoopTree* loop, Node_List& flat_array_checks) const {\n+  assert(flat_array_checks.size() == 0, \"should be empty initially\");\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n+    Node* next = loop->_body.at(i);\n+    if (next->is_If() && next->as_If()->is_flat_array_check(&_igvn) && loop->is_invariant(next->in(1)) &&\n+        !loop->is_loop_exit(next)) {\n+      flat_array_checks.push(next);\n@@ -170,1 +208,0 @@\n-  return unswitch_candidate;\n@@ -173,0 +210,132 @@\n+\/\/ This class represents an \"unswitch candidate\" which is an If that can be used to perform Loop Unswitching on. If the\n+\/\/ candidate is a flat array check candidate, then we also collect all remaining non-loop-exiting flat array checks.\n+\/\/ These are candidates as well. We want to get rid of all these flat array checks in the true-path-loop for the\n+\/\/ following reason:\n+\/\/\n+\/\/ FlatArrayCheckNodes are used with array accesses to switch between a flat and a non-flat array access. We want\n+\/\/ the performance impact on non-flat array accesses to be as small as possible. We therefore create the following\n+\/\/ loops in Loop Unswitching:\n+\/\/ - True-path-loop:  We remove all non-loop-exiting flat array checks to get a loop with only non-flat array accesses\n+\/\/                    (i.e. a fast path loop).\n+\/\/ - False-path-loop: We keep all flat array checks in this loop (i.e. a slow path loop).\n+class UnswitchCandidate : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const Node_List& _old_new;\n+  Node* const _original_loop_entry;\n+  \/\/ If _candidate is a flat array check, this list contains all non-loop-exiting flat array checks in the loop body.\n+  Node_List _flat_array_check_candidates;\n+  IfNode* const _candidate;\n+\n+ public:\n+  UnswitchCandidate(IdealLoopTree* loop, const Node_List& old_new)\n+      : _phase(loop->_phase),\n+        _old_new(old_new),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _flat_array_check_candidates(),\n+        _candidate(find_unswitch_candidate(loop)) {}\n+  NONCOPYABLE(UnswitchCandidate);\n+\n+  IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n+    IfNode* unswitch_candidate = _phase->find_unswitch_candidates(loop, _flat_array_check_candidates);\n+    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n+    assert(_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n+    return unswitch_candidate;\n+  }\n+\n+  IfNode* candidate() const {\n+    return _candidate;\n+  }\n+\n+  \/\/ Is the candidate a flat array check and are there other flat array checks as well?\n+  bool has_multiple_flat_array_check_candidates() const {\n+    return _flat_array_check_candidates.size() > 1;\n+  }\n+\n+  \/\/ Remove all candidates from the true-path-loop which are now dominated by the loop selector\n+  \/\/ (i.e. 'true_path_loop_proj'). The removed candidates are folded in the next IGVN round.\n+  void update_in_true_path_loop(IfTrueNode* true_path_loop_proj) const {\n+    remove_from_loop(true_path_loop_proj, _candidate);\n+    if (has_multiple_flat_array_check_candidates()) {\n+      remove_flat_array_checks(true_path_loop_proj);\n+    }\n+  }\n+\n+  \/\/ Remove a unique candidate from the false-path-loop which is now dominated by the loop selector\n+  \/\/ (i.e. 'false_path_loop_proj'). The removed candidate is folded in the next IGVN round. If there are multiple\n+  \/\/ candidates (i.e. flat array checks), then we leave them in the false-path-loop and only mark the loop such that it\n+  \/\/ is not unswitched anymore in later loop opts rounds.\n+  void update_in_false_path_loop(IfFalseNode* false_path_loop_proj, LoopNode* false_path_loop) const {\n+    if (has_multiple_flat_array_check_candidates()) {\n+      \/\/ Leave the flat array checks in the false-path-loop and prevent it from being unswitched again based on these\n+      \/\/ checks.\n+      false_path_loop->mark_flat_arrays();\n+    } else {\n+      remove_from_loop(false_path_loop_proj, _old_new[_candidate->_idx]->as_If());\n+    }\n+  }\n+\n+ private:\n+  void remove_from_loop(IfProjNode* dominating_proj, IfNode* candidate) const {\n+    _phase->igvn().rehash_node_delayed(candidate);\n+    _phase->dominated_by(dominating_proj, candidate);\n+  }\n+\n+  void remove_flat_array_checks(IfProjNode* dominating_proj) const {\n+    for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+      IfNode* flat_array_check = _flat_array_check_candidates.at(i)->as_If();\n+      _phase->igvn().rehash_node_delayed(flat_array_check);\n+      _phase->dominated_by(dominating_proj, flat_array_check);\n+    }\n+  }\n+\n+ public:\n+  \/\/ Merge all flat array checks into a single new BoolNode and return it.\n+  BoolNode* merge_flat_array_checks() const {\n+    assert(has_multiple_flat_array_check_candidates(), \"must have multiple flat array checks to merge\");\n+    assert(_candidate->in(1)->as_Bool()->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n+    BoolNode* merged_flat_array_check_bool = create_bool_node();\n+    create_flat_array_check_node(merged_flat_array_check_bool);\n+    return merged_flat_array_check_bool;\n+  }\n+\n+ private:\n+  BoolNode* create_bool_node() const {\n+    BoolNode* merged_flat_array_check_bool = _candidate->in(1)->clone()->as_Bool();\n+    _phase->register_new_node(merged_flat_array_check_bool, _original_loop_entry);\n+    return merged_flat_array_check_bool;\n+  }\n+\n+  void create_flat_array_check_node(BoolNode* merged_flat_array_check_bool) const {\n+    FlatArrayCheckNode* cloned_flat_array_check = merged_flat_array_check_bool->in(1)->clone()->as_FlatArrayCheck();\n+    _phase->register_new_node(cloned_flat_array_check, _original_loop_entry);\n+    merged_flat_array_check_bool->set_req(1, cloned_flat_array_check);\n+    set_flat_array_check_inputs(cloned_flat_array_check);\n+  }\n+\n+  \/\/ Combine all checks into a single one that fails if one array is flat.\n+  void set_flat_array_check_inputs(FlatArrayCheckNode* cloned_flat_array_check) const {\n+    assert(cloned_flat_array_check->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n+    cloned_flat_array_check->add_req_batch(_phase->C->top(), _flat_array_check_candidates.size() - 1);\n+    for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+      Node* array = _flat_array_check_candidates.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::ArrayOrKlass);\n+      cloned_flat_array_check->set_req(FlatArrayCheckNode::ArrayOrKlass + i, array);\n+    }\n+  }\n+\n+ public:\n+#ifndef PRODUCT\n+  void trace_flat_array_checks() const {\n+    if (has_multiple_flat_array_check_candidates()) {\n+      tty->print_cr(\"- Unswitched and Merged Flat Array Checks:\");\n+      for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+        Node* unswitch_iff = _flat_array_check_candidates.at(i);\n+        Node* cloned_unswitch_iff = _old_new[unswitch_iff->_idx];\n+        assert(cloned_unswitch_iff != nullptr, \"must exist\");\n+        tty->print_cr(\"  - %d %s  ->  %d %s\", unswitch_iff->_idx, unswitch_iff->Name(),\n+                      cloned_unswitch_iff->_idx, cloned_unswitch_iff->Name());\n+      }\n+    }\n+  }\n+#endif \/\/ NOT PRODUCT\n+};\n+\n@@ -180,3 +349,1 @@\n-  Node_List _unswitch_iffs;\n-  IfNode* const _unswitch_candidate;\n-  const bool _flat_array_checks;\n+  const UnswitchCandidate& _unswitch_candidate;\n@@ -187,1 +354,3 @@\n-  enum PathToLoop { TRUE_PATH, FALSE_PATH };\n+  enum PathToLoop {\n+    TRUE_PATH, FALSE_PATH\n+  };\n@@ -190,1 +359,1 @@\n-  UnswitchedLoopSelector(IdealLoopTree* loop)\n+  UnswitchedLoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n@@ -194,3 +363,1 @@\n-        _unswitch_iffs(),\n-        _unswitch_candidate(find_unswitch_candidate(loop)),\n-        _flat_array_checks(_unswitch_iffs.size() > 1),\n+        _unswitch_candidate(unswitch_candidate),\n@@ -204,7 +371,0 @@\n-  IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n-    IfNode* unswitch_candidate = _phase->find_unswitch_candidate(loop, _unswitch_iffs);\n-    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n-    assert(_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n-    return unswitch_candidate;\n-  }\n-\n@@ -212,26 +372,0 @@\n-    IfNode* unswitch_iff = _unswitch_iffs.at(0)->as_If();\n-    BoolNode* bol = unswitch_iff->in(1)->as_Bool();\n-    if (_unswitch_iffs.size() > 1) {\n-      \/\/ Flat array checks are used on array access to switch between\n-      \/\/ a legacy object array access and a flat inline type array\n-      \/\/ access. We want the performance impact on legacy accesses to be\n-      \/\/ as small as possible so we make two copies of the loop: a fast\n-      \/\/ one where all accesses are known to be legacy, a slow one where\n-      \/\/ some accesses are to flat arrays. Flat array checks\n-      \/\/ can be removed from the fast loop (true proj) but not from the\n-      \/\/ slow loop (false proj) as it can have a mix of flat\/legacy accesses.\n-      assert(bol->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n-      bol = bol->clone()->as_Bool();\n-      _phase->register_new_node(bol, _original_loop_entry);\n-      FlatArrayCheckNode* cmp = bol->in(1)->clone()->as_FlatArrayCheck();\n-      _phase->register_new_node(cmp, _original_loop_entry);\n-      bol->set_req(1, cmp);\n-      \/\/ Combine all checks into a single one that fails if one array is a flat array\n-      assert(cmp->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n-      cmp->add_req_batch(_phase->C->top(), _unswitch_iffs.size() - 1);\n-      for (uint i = 0; i < _unswitch_iffs.size(); i++) {\n-        Node* array = _unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::ArrayOrKlass);\n-        cmp->set_req(FlatArrayCheckNode::ArrayOrKlass + i, array);\n-      }\n-    }\n-\n@@ -240,1 +374,8 @@\n-    IfNode* selector_if = IfNode::make_with_same_profile(_unswitch_candidate, _original_loop_entry, bol);\n+    IfNode* unswitch_candidate_if = _unswitch_candidate.candidate();\n+    BoolNode* selector_bool;\n+    if (_unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n+      selector_bool = _unswitch_candidate.merge_flat_array_checks();\n+    } else {\n+      selector_bool = unswitch_candidate_if->in(1)->as_Bool();\n+    }\n+    IfNode* selector_if = IfNode::make_with_same_profile(unswitch_candidate_if, _original_loop_entry, selector_bool);\n@@ -258,4 +399,0 @@\n-  IfNode* unswitch_candidate() const {\n-    return _unswitch_candidate;\n-  }\n-\n@@ -273,8 +410,0 @@\n-\n-  bool has_flat_array_checks() const {\n-    return _flat_array_checks;\n-  }\n-\n-  const Node_List& unswitch_iffs() const {\n-    return _unswitch_iffs;\n-  }\n@@ -326,22 +455,0 @@\n-  \/\/ Remove the unswitch candidate If nodes in both unswitched loop versions which are now dominated by the loop selector\n-  \/\/ If node. Keep the true-path-path in the true-path-loop and the false-path-path in the false-path-loop by setting\n-  \/\/ the bool input accordingly. The unswitch candidate If nodes are folded in the next IGVN round.\n-  void remove_unswitch_candidate_from_loops(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    const Node_List& unswitch_iffs = unswitched_loop_selector.unswitch_iffs();\n-    for (uint i = 0; i < unswitch_iffs.size(); i++) {\n-      IfNode* iff = unswitch_iffs.at(i)->as_If();\n-      _phase->igvn().rehash_node_delayed(iff);\n-      _phase->dominated_by(unswitched_loop_selector.true_path_loop_proj(), iff);\n-    }\n-\n-    if (unswitched_loop_selector.has_flat_array_checks()) {\n-      \/\/ Leave the flat array checks in the slow loop and\n-      \/\/ prevent it from being unswitched again based on these checks.\n-      old_to_new(_loop_head)->as_Loop()->mark_flat_arrays();\n-    } else {\n-      IfNode* unswitching_candidate_clone = _old_new[unswitched_loop_selector.unswitch_candidate()->_idx]->as_If();\n-      _phase->igvn().rehash_node_delayed(unswitching_candidate_clone);\n-      _phase->dominated_by(unswitched_loop_selector.false_path_loop_proj(), unswitching_candidate_clone);\n-    }\n-  }\n-\n@@ -364,1 +471,0 @@\n-\n@@ -366,1 +472,0 @@\n-\n@@ -368,1 +473,0 @@\n-    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n@@ -382,3 +486,1 @@\n-  const UnswitchedLoopSelector unswitched_loop_selector(loop);\n-\n-  NOT_PRODUCT(trace_loop_unswitching_count(loop, original_head, unswitched_loop_selector.unswitch_iffs());)\n+  NOT_PRODUCT(trace_loop_unswitching_count(loop, original_head);)\n@@ -389,0 +491,2 @@\n+  const UnswitchCandidate unswitch_candidate(loop, old_new);\n+  const UnswitchedLoopSelector unswitched_loop_selector(loop, unswitch_candidate);\n@@ -392,1 +496,4 @@\n-  hoist_invariant_check_casts(loop, old_new, unswitched_loop_selector);\n+  unswitch_candidate.update_in_true_path_loop(unswitched_loop_selector.true_path_loop_proj());\n+  unswitch_candidate.update_in_false_path_loop(unswitched_loop_selector.false_path_loop_proj(),\n+                                               old_new[original_head->_idx]->as_Loop());\n+  hoist_invariant_check_casts(loop, old_new, unswitch_candidate, unswitched_loop_selector.selector());\n@@ -398,1 +505,1 @@\n-  NOT_PRODUCT(trace_loop_unswitching_result(unswitched_loop_selector, original_head, new_head, old_new);)\n+  NOT_PRODUCT(trace_loop_unswitching_result(unswitched_loop_selector, unswitch_candidate, original_head, new_head);)\n@@ -426,2 +533,1 @@\n-void PhaseIdealLoop::trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head,\n-                                                  const Node_List& unswitch_iffs) {\n+void PhaseIdealLoop::trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head) {\n@@ -431,4 +537,0 @@\n-    for (uint i = 0; i < unswitch_iffs.size(); i++) {\n-      unswitch_iffs.at(i)->dump(3);\n-      tty->cr();\n-    }\n@@ -439,2 +541,2 @@\n-                                                   const LoopNode* original_head, const LoopNode* new_head,\n-                                                   const Node_List& old_new) {\n+                                                   const UnswitchCandidate& unswitch_candidate,\n+                                                   const LoopNode* original_head, const LoopNode* new_head) {\n@@ -442,1 +544,1 @@\n-    IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n+    IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n@@ -445,1 +547,1 @@\n-    tty->print_cr(\"- Unswitch-Candidate-If: %d %s\", unswitch_candidate->_idx, unswitch_candidate->Name());\n+    tty->print_cr(\"- Unswitch-Candidate-If: %d %s\", unswitch_candidate_if->_idx, unswitch_candidate_if->Name());\n@@ -449,11 +551,1 @@\n-    if (unswitched_loop_selector.has_flat_array_checks()) {\n-      const Node_List& unswitch_iffs = unswitched_loop_selector.unswitch_iffs();\n-      tty->print_cr(\"- Unswitched Flat Array Checks:\");\n-      for (uint i = 0; i < unswitch_iffs.size(); i++) {\n-        Node* unswitch_iff = unswitch_iffs.at(i);\n-        Node* cloned_unswitch_iff = old_new[unswitch_iff->_idx];\n-        assert(cloned_unswitch_iff != nullptr, \"must exist\");\n-        tty->print_cr(\"  - %d %s  ->  %d %s\", unswitch_iff->_idx, unswitch_iff->Name(),\n-                                             cloned_unswitch_iff->_idx, cloned_unswitch_iff->Name());\n-      }\n-    }\n+    unswitch_candidate.trace_flat_array_checks();\n@@ -475,3 +567,2 @@\n-                                                 const UnswitchedLoopSelector& unswitched_loop_selector) {\n-  IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n-  IfNode* loop_selector = unswitched_loop_selector.selector();\n+                                                 const UnswitchCandidate& unswitch_candidate,\n+                                                 const IfNode* loop_selector) {\n@@ -480,2 +571,3 @@\n-  for (DUIterator_Fast imax, i = unswitch_candidate->fast_outs(imax); i < imax; i++) {\n-    IfProjNode* proj = unswitch_candidate->fast_out(i)->as_IfProj();\n+  const IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n+  for (DUIterator_Fast imax, i = unswitch_candidate_if->fast_outs(imax); i < imax; i++) {\n+    IfProjNode* proj = unswitch_candidate_if->fast_out(i)->as_IfProj();\n@@ -496,2 +588,3 @@\n-      \/\/ Same for the clone\n-      if (!unswitched_loop_selector.has_flat_array_checks()) {\n+      \/\/ Same for the false-path-loop if there are not multiple flat array checks (in that case we leave the\n+      \/\/ false-path-loop unchanged).\n+      if (!unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n@@ -508,1 +601,1 @@\n-  for(int i = loop->_body.size() - 1; i >= 0 ; i--) {\n+  for (int i = loop->_body.size() - 1; i >= 0; i--) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":227,"deletions":134,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class UnswitchCandidate;\n@@ -694,0 +695,1 @@\n+  bool no_unswitch_candidate() const;\n@@ -1425,2 +1427,2 @@\n-  \/\/ Find candidate \"if\" for unswitching\n-  IfNode* find_unswitch_candidate(const IdealLoopTree* loop, Node_List& unswitch_iffs) const;\n+  IfNode* find_unswitch_candidates(const IdealLoopTree* loop, Node_List& flat_array_checks) const;\n+  IfNode* find_unswitch_candidate_from_idoms(const IdealLoopTree* loop) const;\n@@ -1433,1 +1435,1 @@\n-                                   const UnswitchedLoopSelector& unswitched_loop_selector);\n+                                   const UnswitchCandidate& unswitch_candidate, const IfNode* loop_selector);\n@@ -1438,1 +1440,1 @@\n-  static void trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head, const Node_List& unswitch_iffs);\n+  static void trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head);\n@@ -1441,2 +1443,2 @@\n-                                            const LoopNode* original_head, const LoopNode* new_head,\n-                                            const Node_List& old_new);\n+                                            const UnswitchCandidate& unswitch_candidate,\n+                                            const LoopNode* original_head, const LoopNode* new_head);\n@@ -1777,0 +1779,2 @@\n+\n+  void collect_flat_array_checks(const IdealLoopTree* loop, Node_List& flat_array_checks) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"}]}