{"files":[{"patch":"@@ -188,0 +188,3 @@\n+    \/\/ COH: Markword contains class pointer which is only known at runtime.\n+    \/\/ Valhalla: Could have value class which has a different prototype header to a normal object.\n+    \/\/ In both cases, we need to fetch dynamically.\n@@ -191,0 +194,1 @@\n+    \/\/ Otherwise: Can use the statically computed prototype header which is the same for every object.\n@@ -196,0 +200,2 @@\n+    \/\/ COH: Markword already contains class pointer. Nothing else to do.\n+    \/\/ Otherwise: Fetch klass pointer following the markword\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7170,0 +7170,1 @@\n+      klass = tmp1;\n@@ -7175,2 +7176,1 @@\n-      \/\/ tmp1 holds klass preserved above\n-      ldr(tmp1, Address(tmp1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      ldr(tmp1, Address(klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/\/ COH: Markword contains class pointer which is only known at runtime.\n+    \/\/ Valhalla: Could have value class which has a different prototype header to a normal object.\n+    \/\/ In both cases, we need to fetch dynamically.\n@@ -169,0 +172,1 @@\n+    \/\/ Otherwise: Can use the statically computed prototype header which is the same for every object.\n@@ -171,6 +175,10 @@\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    movptr(t1, klass);\n-    encode_klass_not_null(t1, rscratch1);\n-    movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n-  } else if (!UseCompactObjectHeaders) {\n-    movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+  if (!UseCompactObjectHeaders) {\n+    \/\/ COH: Markword already contains class pointer. Nothing else to do.\n+    \/\/ Otherwise: Fetch klass pointer following the markword\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      movptr(t1, klass);\n+      encode_klass_not_null(t1, rscratch1);\n+      movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n+    } else {\n+      movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -6036,0 +6036,1 @@\n+    Register klass = rbx;\n@@ -6038,2 +6039,2 @@\n-      movptr(mark_word, Address(rbx, Klass::prototype_header_offset()));\n-      movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+      movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+      movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), mark_word);\n@@ -6046,1 +6047,1 @@\n-        mov(r13, rbx);\n+        mov(r13, klass);\n@@ -6048,1 +6049,2 @@\n-      store_klass(buffer_obj, rbx, rscratch1);\n+      store_klass(buffer_obj, klass, rscratch1);\n+      klass = r13;\n@@ -6054,1 +6056,1 @@\n-      movptr(rbx, Address(r13, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      movptr(rbx, Address(klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+      assert(ary_src->is_flat(), \"src and dest must be flat\");\n@@ -314,0 +315,2 @@\n+      src_elem = T_FLAT_ELEMENT;\n+      dest_elem = T_FLAT_ELEMENT;\n@@ -315,1 +318,2 @@\n-    uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);\n+\n+    const uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);\n@@ -825,2 +829,9 @@\n-  uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);\n-  uint elemsize = ary_t->is_flat() ? ary_t->flat_elem_size() : type2aelembytes(ary_elem);\n+  uint header;\n+  uint elem_size;\n+  if (ary_t->is_flat()) {\n+    header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+    elem_size = ary_t->flat_elem_size();\n+  } else {\n+    header = arrayOopDesc::base_offset_in_bytes(ary_elem);\n+    elem_size = type2aelembytes(ary_elem);\n+  }\n@@ -828,4 +839,4 @@\n-  jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t->_lo) + len_t->_lo) * elemsize + header;\n-  jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t->_hi) + len_t->_hi) * elemsize + header;\n-  jlong dest_pos_lo = ((jlong)dest_pos_t->_lo) * elemsize + header;\n-  jlong dest_pos_hi = ((jlong)dest_pos_t->_hi) * elemsize + header;\n+  jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t->_lo) + len_t->_lo) * elem_size + header;\n+  jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t->_hi) + len_t->_hi) * elem_size + header;\n+  jlong dest_pos_lo = ((jlong)dest_pos_t->_lo) * elem_size + header;\n+  jlong dest_pos_hi = ((jlong)dest_pos_t->_hi) * elem_size + header;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1850,0 +1850,1 @@\n+  uint header;\n@@ -1857,0 +1858,1 @@\n+    header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n@@ -1859,0 +1861,1 @@\n+    header = arrayOopDesc::base_offset_in_bytes(elembt);\n@@ -1860,1 +1863,0 @@\n-  uint header = arrayOopDesc::base_offset_in_bytes(elembt);\n@@ -3799,1 +3801,2 @@\n-  if (check_lock) {\n+  if (check_lock && !UseCompactObjectHeaders) {\n+    \/\/ COH: Locking does not override the markword with a tagged pointer. We can directly read from the markword.\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -901,0 +901,1 @@\n+  uint header_size;\n@@ -903,0 +904,1 @@\n+    header_size = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n@@ -905,0 +907,1 @@\n+    header_size = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n@@ -909,1 +912,1 @@\n-    intptr_t elem_offset = arrayOopDesc::base_offset_in_bytes(basic_elem_type) + elem_idx * elem_size;\n+    intptr_t elem_offset = header_size + elem_idx * elem_size;\n@@ -2663,5 +2666,16 @@\n-    Node* mark_node = makecon(TypeRawPtr::make((address)markWord::inline_type_prototype().value()));\n-    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::mark_offset_in_bytes(), mark_node, T_ADDRESS);\n-    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n-    if (UseCompressedClassPointers) {\n-      fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);\n+    Node* mark_word_node;\n+    if (UseCompactObjectHeaders) {\n+      \/\/ COH: We need to load the prototype from the klass at runtime since it encodes the klass pointer already.\n+      mark_word_node = make_load(fast_oop_ctrl, fast_oop_rawmem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeRawPtr::BOTTOM, T_ADDRESS);\n+    } else {\n+      \/\/ Otherwise, use the static prototype.\n+      mark_word_node = makecon(TypeRawPtr::make((address)markWord::inline_type_prototype().value()));\n+    }\n+\n+    fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::mark_offset_in_bytes(), mark_word_node, T_ADDRESS);\n+    if (!UseCompactObjectHeaders) {\n+      \/\/ COH: Everything is encoded in the mark word, so nothing left to do.\n+      fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+      if (UseCompressedClassPointers) {\n+        fast_oop_rawmem = make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, oopDesc::klass_gap_offset_in_bytes(), intcon(0), T_INT);\n+      }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+  const TypeAryPtr* array_type = _igvn.type(ary)->isa_aryptr();\n+  if (array_type != nullptr && array_type->is_aryptr()->is_flat()) {\n+    \/\/ Use T_FLAT_ELEMENT to get proper alignment with COH when fetching the array element address.\n+    elembt = T_FLAT_ELEMENT;\n+  }\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1193,1 +1193,0 @@\n-      uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5663,1 +5663,1 @@\n-    uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+    uint header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,34 +142,0 @@\n-# Valhalla + COH\n-compiler\/c2\/autovectorization\/TestIndexOverflowIR.java                          8348568 generic-all\n-compiler\/c2\/irTests\/stringopts\/TestArrayCopySelect.java                         8348568 generic-all\n-compiler\/c2\/irTests\/TestVectorConditionalMove.java                              8348568 generic-all\n-compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java                      8348568 generic-all\n-compiler\/c2\/irTests\/TestVectorizationNotRun.java                                8348568 generic-all\n-compiler\/c2\/TestCastX2NotProcessedIGVN.java                                     8348568 generic-all\n-compiler\/loopopts\/superword\/TestAlignVector.java                                8348568 generic-all\n-compiler\/loopopts\/superword\/TestAlignVector.java#NoAlignVector-COH              8348568 generic-all\n-compiler\/loopopts\/superword\/TestAlignVector.java#VerifyAlignVector-COH          8348568 generic-all\n-compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java       8348568 generic-all\n-compiler\/loopopts\/superword\/TestMulAddS2I.java                                  8348568 generic-all\n-compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java               8348568 generic-all\n-compiler\/loopopts\/superword\/TestSplitPacks.java                                 8348568 generic-all\n-compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java     8348568 generic-all\n-compiler\/vectorization\/TestFloatConversionsVector.java                          8348568 generic-all\n-compiler\/vectorization\/runner\/ArrayTypeConvertTest.java                         8348568 generic-all\n-compiler\/vectorization\/runner\/LoopCombinedOpTest.java                           8348568 generic-all\n-compiler\/vectorization\/runner\/VectorizationTestRunner.java                      8348568 generic-all\n-runtime\/FieldLayout\/TestOopMapSizeMinimal.java#no_coops_ccptr_coh               8348568 generic-all\n-\n-gc\/stress\/gcbasher\/TestGCBasherWithParallel.java                                8348568 generic-all\n-\n-gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh                     8348568 generic-all\n-gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh-large-class-space   8348568 generic-all\n-gtest\/MetaspaceGtests.java#UseCompactObjectHeaders                              8348568 generic-all\n-\n-runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java               8348568 generic-all\n-runtime\/FieldLayout\/BaseOffsets.java#no-coops-with-coh                          8348568 generic-all\n-runtime\/FieldLayout\/BaseOffsets.java#with-coop--with-coh                        8348568 generic-all\n-runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh                            8348568 generic-all\n-runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh                          8348568 generic-all\n-runtime\/cds\/appcds\/TestZGCWithCDS.java                                          8348568 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3084,0 +3084,42 @@\n+    static value class Test127aValue {\n+        int x;\n+\n+        Test127aValue(int x) {\n+            this.x = x;\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static Test127aValue valueTest127a = new Test127aValue(34);\n+    static final Test127aValue[] srcTest127a = (Test127aValue[])ValueClass.newNullRestrictedNonAtomicArray(Test127aValue.class, 8, valueTest127a);\n+    static final Test127aValue[] destTest127a = (Test127aValue[])ValueClass.newNullRestrictedNonAtomicArray(Test127aValue.class, 8, valueTest127a);\n+\n+\n+    @Test\n+    public void test127a(int srcPos, int destPos, int len) {\n+        System.arraycopy(srcTest127a, srcPos, destTest127a, destPos, len);\n+    }\n+\n+    \/\/ Ensure that System.arraycopy() is working properly with COH.\n+    @Run(test = \"test127a\")\n+    @Warmup(10000)\n+    public void test127a_verifier() {\n+        test127a(0,1, 7);\n+        for (int i = 0; i < 7; ++i) {\n+            Asserts.assertEQ(srcTest127a[i], destTest127a[i + 1]);\n+        }\n+        Asserts.assertEQ(valueTest127a, destTest127a[0]);\n+    }\n+\n+    static void verifyTest127a(Object[] src, Object[] dst, int len, int offset) {\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i], dst[i + offset]);\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(src[i], dst[i + offset]);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"}]}