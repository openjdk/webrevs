{"files":[{"patch":"@@ -93,1 +93,0 @@\n-\n@@ -120,0 +119,44 @@\n+################################################################################\n+# Setup compilation for value classes in the module\n+# TBD: When $(DOCLINT) was included there was an NPE in JavacTypes.getOverriddenMethods\n+\n+# Directory and file name suffix for jar file containing value classes\n+VALUECLASSES_STR := valueclasses\n+\n+ifneq ($(COMPILER), bootjdk)\n+  MODULE_VALUECLASS_SRC_DIRS := $(call FindModuleValueClassSrcDirs, $(MODULE))\n+  MODULE_VALUECLASS_SOURCEPATH := $(call GetModuleValueClassSrcPath)\n+\n+  ifneq ($(MODULE_VALUECLASS_SRC_DIRS),)\n+    $(eval $(call SetupJavaCompilation, $(MODULE)-$(VALUECLASSES_STR), \\\n+        SMALL_JAVA := false, \\\n+        MODULE := $(MODULE), \\\n+        SRC := $(wildcard $(MODULE_VALUECLASS_SRC_DIRS)), \\\n+        INCLUDES := $(JDK_USER_DEFINED_FILTER), \\\n+        FAIL_NO_SRC := $(FAIL_NO_SRC), \\\n+        BIN := $(SUPPORT_OUTPUTDIR)\/$(VALUECLASSES_STR)\/, \\\n+        JAR := $(JDK_OUTPUTDIR)\/lib\/$(VALUECLASSES_STR)\/$(MODULE)-$(VALUECLASSES_STR).jar, \\\n+        HEADERS := $(SUPPORT_OUTPUTDIR)\/headers, \\\n+        DISABLED_WARNINGS := $(DISABLED_WARNINGS_java), \\\n+        EXCLUDES := $(EXCLUDES), \\\n+        EXCLUDE_FILES := $(EXCLUDE_FILES) \\\n+        KEEP_ALL_TRANSLATIONS := $(KEEP_ALL_TRANSLATIONS), \\\n+        DEPENDS := $($(MODULE)), \\\n+        JAVAC_FLAGS := \\\n+            $(JAVAC_FLAGS) \\\n+            --module-source-path $(MODULE_VALUECLASS_SOURCEPATH) \\\n+            --module-path $(JDK_OUTPUTDIR)\/modules \\\n+            --system none, \\\n+    ))\n+\n+    TARGETS += $($(MODULE)-$(VALUECLASSES_STR))\n+\n+    $(eval $(call SetupCopyFiles, $(MODULE)-copy-valueclass-jar, \\\n+        FILES := $(JDK_OUTPUTDIR)\/lib\/$(VALUECLASSES_STR)\/$(MODULE)-$(VALUECLASSES_STR).jar, \\\n+        DEST := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE)\/$(VALUECLASSES_STR), \\\n+    ))\n+\n+    TARGETS += $($(MODULE)-copy-valueclass-jar)\n+  endif\n+endif\n+\n","filename":"make\/CompileJavaModules.gmk","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,4 @@\n+GENERATED_VALUE_CLASS_SUBDIRS += \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc-valueclasses \\\n+    #\n+\n@@ -149,0 +153,6 @@\n+# Find value class source dirs for a particular module  (only generated)\n+# $1 - Module to find source dirs for\n+FindModuleValueClassSrcDirs = \\\n+    $(strip $(wildcard \\\n+        $(addsuffix \/$(strip $1), $(GENERATED_VALUE_CLASS_SUBDIRS))))\n+\n@@ -166,0 +176,6 @@\n+\n+# Construct the complete module source path for value classes\n+GetModuleValueClassSrcPath = \\\n+    $(call PathList, \\\n+        $(addsuffix \/*, $(GENERATED_VALUE_CLASS_SUBDIRS) $(GENERATED_SRC_DIRS) $(IMPORT_MODULES_SRC)) \\\n+        $(foreach sub, $(SRC_SUBDIRS), $(addsuffix \/*\/$(sub), $(TOP_SRC_DIRS))))\n","filename":"make\/common\/Modules.gmk","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+include gensrc\/GensrcValueClasses.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#\n+\n+################################################################################\n+# Generate the value class replacements for selected java.base source files\n+\n+java.base-VALUE_CLASS-REPLACEMENTS := \\\n+    java\/util\/Optional.java \\\n+    java\/util\/OptionalInt.java \\\n+    java\/util\/OptionalLong.java \\\n+    java\/util\/OptionalDouble.java \\\n+    java\/time\/LocalDate.java \\\n+    java\/time\/LocalDateTime.java \\\n+    java\/time\/LocalTime.java \\\n+    java\/time\/Duration.java \\\n+    java\/time\/Instant.java \\\n+    java\/time\/MonthDay.java \\\n+    java\/time\/ZonedDateTime.java \\\n+    java\/time\/OffsetDateTime.java \\\n+    java\/time\/OffsetTime.java \\\n+    java\/time\/YearMonth.java \\\n+    java\/time\/Year.java \\\n+    java\/time\/Period.java \\\n+    #\n+\n+java.base-VALUE-CLASS-FILES := \\\n+    $(foreach f, $(java.base-VALUE_CLASS-REPLACEMENTS), $(addprefix $(TOPDIR)\/src\/java.base\/share\/classes\/, $(f)))\n+\n+$(eval $(call SetupTextFileProcessing, JAVA_BASE_VALUECLASS_REPLACEMENTS, \\\n+    SOURCE_FILES := $(java.base-VALUE-CLASS-FILES), \\\n+    SOURCE_BASE_DIR := $(TOPDIR)\/src\/java.base\/share\/classes, \\\n+    OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc-valueclasses\/java.base\/, \\\n+    REPLACEMENTS := \\\n+        public final class => public final value class, \\\n+))\n+\n+TARGETS += $(JAVA_BASE_VALUECLASS_REPLACEMENTS)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcValueClasses.gmk","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+#include <string.h>\n@@ -1926,1 +1927,0 @@\n-unsigned int patch_mod_count = 0;\n@@ -2103,2 +2103,0 @@\n-  bool patch_mod_javabase = false;\n-\n@@ -2118,1 +2116,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2125,1 +2123,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2131,1 +2129,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n@@ -2138,1 +2136,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2152,1 +2150,1 @@\n-  result = finalize_vm_init_args(patch_mod_javabase);\n+  result = finalize_vm_init_args();\n@@ -2205,1 +2203,1 @@\n-int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {\n+int Arguments::process_patch_mod_option(const char* patch_mod_tail) {\n@@ -2221,1 +2219,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);\n+      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/);\n@@ -2223,3 +2221,0 @@\n-      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n-        return JNI_ENOMEM;\n-      }\n@@ -2233,0 +2228,64 @@\n+\/\/ VALUECLASS_STR must match string used in the build\n+#define VALUECLASS_STR \"valueclasses\"\n+#define VALUECLASS_JAR \"-\" VALUECLASS_STR \".jar\"\n+\n+\/\/ Finalize --patch-module args and --enable-preview related to value class module patches.\n+\/\/ Create all numbered properties passing module patches.\n+int Arguments::finalize_patch_module() {\n+  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n+  \/\/ are to be patched into the module.\n+  \/\/ For each <module>-valueclasses.jar in <JAVA_HOME>\/lib\/valueclasses\/\n+  \/\/ appends the equivalent of --patch-module <module>=<JAVA_HOME>\/lib\/valueclasses\/<module>-valueclasses.jar\n+  if (enable_preview() && EnableValhalla) {\n+    char * valueclasses_dir = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+    const char * fileSep = os::file_separator();\n+\n+    jio_snprintf(valueclasses_dir, JVM_MAXPATHLEN, \"%s%slib%s\" VALUECLASS_STR \"%s\",\n+                 Arguments::get_java_home(), fileSep, fileSep, fileSep);\n+    DIR* dir = os::opendir(valueclasses_dir);\n+    if (dir != nullptr) {\n+      char * module_name = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+      char * path = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+\n+      for (dirent * entry = os::readdir(dir); entry != nullptr; entry = os::readdir(dir)) {\n+        \/\/ Test if file ends-with \"-valueclasses.jar\"\n+        int len = (int)strlen(entry->d_name) - (sizeof(VALUECLASS_JAR) - 1);\n+        if (len <= 0 || strcmp(&entry->d_name[len], VALUECLASS_JAR) != 0) {\n+          continue;         \/\/ too short or not the expected suffix\n+        }\n+\n+        strcpy(module_name, entry->d_name);\n+        module_name[len] = '\\0';     \/\/ truncate to just module-name\n+\n+        jio_snprintf(path, JVM_MAXPATHLEN, \"%s%s\", valueclasses_dir, &entry->d_name);\n+        add_patch_mod_prefix(module_name, path, true \/* append *\/);\n+        log_info(class)(\"--enable-preview appending value classes for module %s: %s\", module_name, entry->d_name);\n+      }\n+      FreeHeap(module_name);\n+      FreeHeap(path);\n+      os::closedir(dir);\n+    }\n+    FreeHeap(valueclasses_dir);\n+  }\n+\n+  \/\/ Create numbered properties for each module that has been patched either\n+  \/\/ by --patch-module or --enable-preview\n+  \/\/ Format is \"jdk.module.patch.<n>=<module_name>=<path>\"\n+  if (_patch_mod_prefix != nullptr) {\n+    char * prop_value = AllocateHeap(JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, mtArguments);\n+    unsigned int patch_mod_count = 0;\n+\n+    for (GrowableArrayIterator<ModulePatchPath *> it = _patch_mod_prefix->begin();\n+            it != _patch_mod_prefix->end(); ++it) {\n+      jio_snprintf(prop_value, JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, \"%s=%s\",\n+                   (*it)->module_name(), (*it)->path_string());\n+      if (!create_numbered_module_property(\"jdk.module.patch\", prop_value, patch_mod_count++)) {\n+        FreeHeap(prop_value);\n+        return JNI_ENOMEM;\n+      }\n+    }\n+    FreeHeap(prop_value);\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2287,1 +2346,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin) {\n@@ -2412,1 +2471,1 @@\n-      int res = process_patch_mod_option(tail, patch_mod_javabase);\n+      int res = process_patch_mod_option(tail);\n@@ -2941,12 +3000,7 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {\n-  \/\/ For java.base check for duplicate --patch-module options being specified on the command line.\n-  \/\/ This check is only required for java.base, all other duplicate module specifications\n-  \/\/ will be checked during module system initialization.  The module system initialization\n-  \/\/ will throw an ExceptionInInitializerError if this situation occurs.\n-  if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n-    if (*patch_mod_javabase) {\n-      vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n-    } else {\n-      *patch_mod_javabase = true;\n-    }\n-  }\n+bool match_module(void *module_name, ModulePatchPath *patch) {\n+  return (strcmp((char *)module_name, patch->module_name()) == 0);\n+}\n+\n+bool Arguments::patch_mod_javabase() {\n+    return _patch_mod_prefix != nullptr && _patch_mod_prefix->find((void*)JAVA_BASE_NAME, match_module) >= 0;\n+}\n@@ -2954,0 +3008,1 @@\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append) {\n@@ -2955,1 +3010,1 @@\n-  if (_patch_mod_prefix == NULL) {\n+  if (_patch_mod_prefix == nullptr) {\n@@ -2959,1 +3014,16 @@\n-  _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  \/\/ Scan patches for matching module\n+  int i = _patch_mod_prefix->find((void*)module_name, match_module);\n+  if (i == -1) {\n+    _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  } else {\n+    if (allow_append) {\n+      \/\/ append path to existing module entry\n+      _patch_mod_prefix->at(i)->append_path(path);\n+    } else {\n+      if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+        vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n+      } else {\n+        vm_exit_during_initialization(\"Cannot specify a module more than once to --patch-module\", module_name);\n+      }\n+    }\n+  }\n@@ -3002,1 +3072,1 @@\n-jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {\n+jint Arguments::finalize_vm_init_args() {\n@@ -3085,0 +3155,5 @@\n+  \/\/ finalize --module-patch and related --enable-preview\n+  if (finalize_patch_module() != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3121,1 +3196,1 @@\n-  if (UseSharedSpaces && patch_mod_javabase) {\n+  if (UseSharedSpaces && patch_mod_javabase()) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":107,"deletions":32,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  inline void append_path(const char* path) { _path->append_value(path); }\n@@ -398,1 +399,1 @@\n-  static int process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase);\n+  static int process_patch_mod_option(const char* patch_mod_tail);\n@@ -434,2 +435,2 @@\n-  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin);\n-  static jint finalize_vm_init_args(bool patch_mod_javabase);\n+  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin);\n+  static jint finalize_vm_init_args();\n@@ -603,1 +604,3 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path, bool* patch_mod_javabase);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path, bool allow_append);\n+  static bool patch_mod_javabase();\n+  static int finalize_patch_module();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -529,1 +529,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -428,1 +428,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,1 +444,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,1 +283,0 @@\n-        super();\n@@ -295,1 +294,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeParseContext.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimePrintContext.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -224,2 +224,0 @@\n-        super();\n-\n@@ -289,2 +287,0 @@\n-        super();\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/ZoneRules.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Module system initialization exception results if a module is specificed twice to --patch-module.\n+ * @summary If a module is specificed twice to --patch-module, it should print an error\n@@ -38,1 +38,0 @@\n-  \/\/ The module system initialization should generate an ExceptionInInitializerError\n@@ -40,0 +39,1 @@\n+  \/\/ The launcher should print an error.\n@@ -47,1 +47,1 @@\n-    output.shouldContain(\"java.lang.ExceptionInInitializerError\");\n+    output.shouldContain(\"Cannot specify a module more than once to --patch-module\");\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/PatchModule\/PatchModuleDupModule.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore  TBD: Resolution of -XX:-EnableValhalla\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/BadACCValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-abstract class AbstractClassWithFieldWithNoIdentityModifier {\n-    int i;\n-}\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/AbstractClassWithFieldWithNoIdentityModifier.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+ * @run main\/othervm --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:DiagnoseSyncOnValueBasedClasses=2 jdk.jfr.event.runtime.TestSyncOnValueBasedClassEvent\n@@ -47,1 +48,1 @@\n-                                     \"java\/time\/Duration\", \"java\/util\/OptionalInt\", \"java\/lang\/Runtime$Version\"};\n+                                     \"java\/lang\/Runtime$Version\"};\n@@ -60,2 +61,0 @@\n-        testObjects.add(Duration.ofMillis(5));\n-        testObjects.add(OptionalInt.of(10));\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,0 +138,19 @@\n+    \/**\n+     * Test with --patch-module options patching the same module (not java.base).\n+     *\n+     *\/\n+    public void testDuplicateModuleLogging() throws Exception {\n+        int exitValue =\n+            executeTestJava(\"--patch-module\", \"java.logging=\" + PATCHES1_DIR.resolve(\"java.base\"),\n+                            \"--patch-module\", \"java.logging=\" + PATCHES2_DIR.resolve(\"java.base\"),\n+                            \"--module-path\", MODS_DIR.toString(),\n+                            \"-m\", \"test\/jdk.test.Main\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                \/\/ error output by VM\n+                .shouldContain(\"Cannot specify a module more than once to --patch-module: java.logging\")\n+                .getExitValue();\n+\n+        assertTrue(exitValue != 0);\n+    }\n+\n","filename":"test\/jdk\/tools\/launcher\/modules\/patch\/basic\/PatchTestWarningError.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.ParameterizedTest;\n+\n+import jdk.internal.misc.PreviewFeatures;\n+import jdk.internal.misc.ValhallaFeatures;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.MonthDay;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalInt;\n+import java.util.OptionalLong;\n+import java.time.Period;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZonedDateTime;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that classes are value classes or not depending on --enable-preview\n+ * @run junit\/othervm -Xlog --enable-preview UseValueClassTest\n+ * @run junit\/othervm -Xlog UseValueClassTest\n+ *\/\n+\n+public class UseValueClassTest {\n+\n+    \/\/ Classes to be checked\n+    private static Stream<Class<?>> classProvider() {\n+        Class<?>[] classes = {\n+                Duration.class,\n+                Instant.class,\n+                LocalDate.class,\n+                LocalDateTime.class,\n+                LocalTime.class,\n+                MonthDay.class,\n+                OffsetDateTime.class,\n+                OffsetTime.class,\n+                Optional.class,\n+                OptionalDouble.class,\n+                OptionalInt.class,\n+                OptionalLong.class,\n+                Period.class,\n+                Year.class,\n+                YearMonth.class,\n+                ZonedDateTime.class,\n+        };\n+        return Arrays.stream(classes, 0, classes.length);\n+    }\n+\n+    \/**\n+     * Verify that the class is a value class if --enable-preview and -XX:+EnableValhallait true\n+     * @param clazz a class\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"classProvider\")\n+    public void testValue(Class<?> clazz) {\n+        System.out.printf(\"isPreview: %s, Valhalla.isEnabled: %s%n\",\n+                PreviewFeatures.isEnabled(), ValhallaFeatures.isEnabled());\n+        assertEquals(PreviewFeatures.isEnabled() && ValhallaFeatures.isEnabled(),\n+                clazz.isValue(), clazz.getName());\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UseValueClassTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}