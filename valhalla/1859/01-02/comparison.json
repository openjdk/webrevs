{"files":[{"patch":"@@ -166,0 +166,1 @@\n+    public final Type objectsType;\n@@ -562,0 +563,1 @@\n+        objectsType = enterClass(\"java.util.Objects\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+import static com.sun.tools.javac.tree.JCTree.Tag.NULLCHK2;\n@@ -763,1 +764,1 @@\n-            if (!oldNewClazz.args.isEmpty() && oldNewClazz.args.head.hasTag(NULLCHK)) {\n+            if (!oldNewClazz.args.isEmpty() && (oldNewClazz.args.head.hasTag(NULLCHK) || oldNewClazz.args.head.hasTag(NULLCHK2))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3510,0 +3510,6 @@\n+        return makeNullCheck(arg, false);\n+    }\n+\n+    \/** Make an attributed null check tree.\n+     *\/\n+    public JCExpression makeNullCheck(JCExpression arg, boolean nullRestricted) {\n@@ -3517,2 +3523,3 @@\n-        JCUnary tree = make.at(arg.pos).Unary(NULLCHK, arg);\n-        tree.operator = operators.resolveUnary(arg, NULLCHK, arg.type);\n+        JCTree.Tag optag = !nullRestricted ? NULLCHK : NULLCHK2;\n+        JCUnary tree = make.at(arg.pos).Unary(optag, arg);\n+        tree.operator = operators.resolveUnary(arg, optag, arg.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -687,0 +687,2 @@\n+                        .addUnaryOperator(OBJECT, OBJECT, nullchk),\n+                new UnaryReferenceOperator(Tag.NULLCHK2)\n@@ -841,0 +843,1 @@\n+        setOperatorName(Tag.NULLCHK2, \"<*nullchk2*>\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Operators.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -418,0 +418,1 @@\n+            case NULLCHK2:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            return attr.makeNullCheck(tree);\n+            return attr.makeNullCheck(tree, true);\n@@ -1072,1 +1072,1 @@\n-        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK)\n+        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK || tree.getTag() == Tag.NULLCHK2)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,0 +145,12 @@\n+        String opt = Options.instance(context).get(\"useRuntimeChecks\");\n+        if (target.hasRuntimeChecks()) {\n+            if (opt == null) {\n+                opt = \"true\";\n+            }\n+        } else {\n+            if (opt != null && !\"false\".equals(opt)) {\n+                Assert.error(\"using java.lang.runtime.Checks is requested on a platform that does not support it.\");\n+            }\n+            opt = \"false\";\n+        }\n+        hasRuntimeChecks = opt.equals(\"true\");\n@@ -155,0 +167,1 @@\n+    private final boolean hasRuntimeChecks;\n@@ -2331,0 +2344,1 @@\n+            case NULLCHK2:\n@@ -2333,1 +2347,1 @@\n-                genNullCheck(tree);\n+                genNullCheck(tree, tree.getTag() == NULLCHK2);\n@@ -2343,0 +2357,4 @@\n+        genNullCheck(tree, false);\n+    }\n+\n+    private void genNullCheck(JCTree tree, boolean nullRestricted) {\n@@ -2344,2 +2362,8 @@\n-        callMethod(tree.pos(), syms.checksType, names.nullCheck,\n-                List.of(syms.objectType), true);\n+        if (!nullRestricted || !hasRuntimeChecks) {\n+            callMethod(tree.pos(), syms.objectsType, names.requireNonNull,\n+                    List.of(syms.objectType), true);\n+            code.emitop0(pop);\n+        } else {\n+            callMethod(tree.pos(), syms.checksType, names.nullCheck,\n+                    List.of(syms.objectType), true);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -264,0 +264,6 @@\n+\n+    \/** Does the target JDK defines class j.l.runtime.Checks?\n+     *\/\n+    public boolean hasRuntimeChecks() {\n+        return compareTo(JDK1_26) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -343,0 +343,4 @@\n+        \/** unary operator for null reference checks, only used internally\n+         *  for null restricted types\n+         *\/\n+        NULLCHK2,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1314,0 +1314,1 @@\n+            case NULLCHK2: return \"<*nullchk2*>\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1180,1 +1180,2 @@\n-        case NULLCHK: return postfixPrec;\n+        case NULLCHK:\n+        case NULLCHK2: return postfixPrec;\n@@ -1319,0 +1320,1 @@\n+        case NULLCHK2:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+    public final Name requireNonNull;\n@@ -402,0 +403,1 @@\n+        requireNonNull = fromString(\"requireNonNull\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}