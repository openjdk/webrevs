{"files":[{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class consists of {@code static} utility methods for checking\n+ * if any of their arguments is {@code null}.\n+ *\n+ * @since valhalla\n+ *\/\n+public final class Checks {\n+    private Checks() {\n+        throw new AssertionError(\"can't instantiate java.lang.runtime.Checks\");\n+    }\n+\n+    \/**\n+     * Checks that the specified object reference is not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj obj) {\n+     *     Checks.nullCheck(obj);\n+     *     this.obj = obj;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj the object reference to check for nullity\n+     * @throws NullPointerException if {@code obj} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj) {\n+        if (obj == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2) {\n+     *     Checks.nullCheck(obj1, obj2);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1} or {@code obj2} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2) {\n+        if (obj1 == null || obj2 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3) {\n+     *     Checks.nullCheck(obj1, obj2, obj3);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2} or\n+     * {@code obj3} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3) {\n+        if (obj1 == null || obj2 == null || obj3 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3, Obj4 obj4) {\n+     *     Checks.nullCheck(obj1, obj2, obj3, obj4);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     *     this.obj4 = obj4;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @param obj4 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2},\n+     * {@code obj3} or {@code obj4} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3, Object obj4) {\n+        if (obj1 == null || obj2 == null || obj3 == null || obj4 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3, Obj4 obj4, Obj5 obj5) {\n+     *     Checks.nullCheck(obj1, obj2, obj3, obj4, obj5);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     *     this.obj4 = obj4;\n+     *     this.obj5 = obj5;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @param obj4 an object reference to check for nullity\n+     * @param obj5 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2},\n+     * {@code obj3}, {@code obj4} or {@code obj5} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3, Object obj4, Object obj5) {\n+        if (obj1 == null || obj2 == null || obj3 == null || obj4 == null || obj5 == null)\n+            throw new NullPointerException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Checks.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -255,0 +255,1 @@\n+    public final Type checksType;\n@@ -664,0 +665,1 @@\n+        checksType = enterClass(\"java.lang.runtime.Checks\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+import static com.sun.tools.javac.tree.JCTree.Tag.NULLCHK2;\n@@ -763,1 +764,1 @@\n-            if (!oldNewClazz.args.isEmpty() && oldNewClazz.args.head.hasTag(NULLCHK)) {\n+            if (!oldNewClazz.args.isEmpty() && (oldNewClazz.args.head.hasTag(NULLCHK) || oldNewClazz.args.head.hasTag(NULLCHK2))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3510,0 +3510,6 @@\n+        return makeNullCheck(arg, false);\n+    }\n+\n+    \/** Make an attributed null check tree.\n+     *\/\n+    public JCExpression makeNullCheck(JCExpression arg, boolean nullRestricted) {\n@@ -3517,1 +3523,1 @@\n-        JCTree.Tag optag = NULLCHK;\n+        JCTree.Tag optag = !nullRestricted ? NULLCHK : NULLCHK2;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -687,1 +687,4 @@\n-                        .addUnaryOperator(OBJECT, OBJECT, nullchk));\n+                        .addUnaryOperator(OBJECT, OBJECT, nullchk),\n+                new UnaryReferenceOperator(Tag.NULLCHK2)\n+                        .addUnaryOperator(OBJECT, OBJECT, nullchk)\n+        );\n@@ -840,0 +843,1 @@\n+        setOperatorName(Tag.NULLCHK2, \"<*nullchk2*>\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Operators.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -418,0 +418,1 @@\n+            case NULLCHK2:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            return attr.makeNullCheck(tree);\n+            return attr.makeNullCheck(tree, true);\n@@ -1072,1 +1072,1 @@\n-        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK)\n+        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK || tree.getTag() == Tag.NULLCHK2)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,0 +145,12 @@\n+        String opt = Options.instance(context).get(\"useRuntimeChecks\");\n+        if (target.hasRuntimeChecks()) {\n+            if (opt == null) {\n+                opt = \"true\";\n+            }\n+        } else {\n+            if (opt != null && !\"false\".equals(opt)) {\n+                Assert.error(\"using java.lang.runtime.Checks is requested on a platform that does not support it.\");\n+            }\n+            opt = \"false\";\n+        }\n+        hasRuntimeChecks = opt.equals(\"true\");\n@@ -155,0 +167,1 @@\n+    private final boolean hasRuntimeChecks;\n@@ -2331,0 +2344,1 @@\n+            case NULLCHK2:\n@@ -2333,1 +2347,1 @@\n-                genNullCheck(tree);\n+                genNullCheck(tree, tree.getTag() == NULLCHK2);\n@@ -2343,0 +2357,4 @@\n+        genNullCheck(tree, false);\n+    }\n+\n+    private void genNullCheck(JCTree tree, boolean nullRestricted) {\n@@ -2344,3 +2362,8 @@\n-        callMethod(tree.pos(), syms.objectsType, names.requireNonNull,\n-                   List.of(syms.objectType), true);\n-        code.emitop0(pop);\n+        if (!nullRestricted || !hasRuntimeChecks) {\n+            callMethod(tree.pos(), syms.objectsType, names.requireNonNull,\n+                    List.of(syms.objectType), true);\n+            code.emitop0(pop);\n+        } else {\n+            callMethod(tree.pos(), syms.checksType, names.nullCheck,\n+                    List.of(syms.objectType), true);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -264,0 +264,6 @@\n+\n+    \/** Does the target JDK defines class j.l.runtime.Checks?\n+     *\/\n+    public boolean hasRuntimeChecks() {\n+        return compareTo(JDK1_26) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -343,0 +343,4 @@\n+        \/** unary operator for null reference checks, only used internally\n+         *  for null restricted types\n+         *\/\n+        NULLCHK2,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1314,0 +1314,1 @@\n+            case NULLCHK2: return \"<*nullchk2*>\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1180,1 +1180,2 @@\n-        case NULLCHK: return postfixPrec;\n+        case NULLCHK:\n+        case NULLCHK2: return postfixPrec;\n@@ -1319,0 +1320,1 @@\n+        case NULLCHK2:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+    public final Name nullCheck;\n@@ -441,0 +442,1 @@\n+        nullCheck = fromString(\"nullCheck\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}