{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,20 +30,0 @@\n-int ciInlineKlass::compute_nonstatic_fields() {\n-  int result = ciInstanceKlass::compute_nonstatic_fields();\n-\n-  \/\/ Abstract value classes can also have declared fields.\n-  ciInstanceKlass* super_klass = super();\n-  GrowableArray<ciField*>* super_klass_fields = nullptr;\n-  if (super_klass != nullptr && super_klass->has_nonstatic_fields()) {\n-    int super_flen = super_klass->nof_nonstatic_fields();\n-    super_klass_fields = super_klass->_nonstatic_fields;\n-    assert(super_flen == 0 || super_klass_fields != nullptr, \"first get nof_fields\");\n-  }\n-\n-  \/\/ Compute declared non-static fields (without flattening of inline type fields)\n-  GrowableArray<ciField*>* fields = nullptr;\n-  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(super_klass_fields, false \/* no flattening *\/);)\n-  Arena* arena = CURRENT_ENV->arena();\n-  _declared_nonstatic_fields = (fields != nullptr) ? fields : new (arena) GrowableArray<ciField*>(arena, 0, 0, 0);\n-  return result;\n-}\n-\n@@ -55,25 +35,0 @@\n-\/\/ Returns the index of the field with the given offset. If the field at 'offset'\n-\/\/ belongs to a flat field, return the index of the field in the inline type of the flat field.\n-int ciInlineKlass::field_index_by_offset(int offset) {\n-  assert(contains_field_offset(offset), \"invalid field offset\");\n-  int best_offset = 0;\n-  int best_index = -1;\n-  \/\/ Search the field with the given offset\n-  for (int i = 0; i < nof_declared_nonstatic_fields(); ++i) {\n-    int field_offset = _declared_nonstatic_fields->at(i)->offset_in_bytes();\n-    if (field_offset == offset) {\n-      \/\/ Exact match\n-      return i;\n-    } else if (field_offset < offset && field_offset > best_offset) {\n-      \/\/ No exact match. Save the index of the field with the closest offset that\n-      \/\/ is smaller than the given field offset. This index corresponds to the\n-      \/\/ flat field that holds the field we are looking for.\n-      best_offset = field_offset;\n-      best_index = i;\n-    }\n-  }\n-  assert(best_index >= 0, \"field not found\");\n-  assert(best_offset == offset || _declared_nonstatic_fields->at(best_index)->type()->is_inlinetype(), \"offset should match for non-inline types\");\n-  return best_index;\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":46,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-  \/\/ Fields declared in the bytecode (without nested fields in flat fields)\n-  GrowableArray<ciField*>* _declared_nonstatic_fields;\n@@ -50,1 +48,1 @@\n-  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k), _declared_nonstatic_fields(nullptr) {\n+  ciInlineKlass(Klass* h_k) : ciInstanceKlass(h_k) {\n@@ -57,1 +55,0 @@\n-  int compute_nonstatic_fields();\n@@ -63,13 +60,0 @@\n-  int nof_declared_nonstatic_fields() {\n-    if (_declared_nonstatic_fields == nullptr) {\n-      compute_nonstatic_fields();\n-    }\n-    return _declared_nonstatic_fields->length();\n-  }\n-\n-  \/\/ ith non-static declared field (presented by ascending address)\n-  ciField* declared_nonstatic_field_at(int i) {\n-    assert(_declared_nonstatic_fields != nullptr, \"should be initialized\");\n-    return _declared_nonstatic_fields->at(i);\n-  }\n-\n@@ -78,1 +62,0 @@\n-  int field_index_by_offset(int offset);\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -71,1 +71,2 @@\n-  _nonstatic_fields = nullptr; \/\/ initialized lazily by compute_nonstatic_fields:\n+  _declared_nonstatic_fields = nullptr; \/\/ initialized lazily by compute_nonstatic_fields\n+  _nonstatic_fields = nullptr;          \/\/ initialized lazily by compute_nonstatic_fields\n@@ -73,1 +74,1 @@\n-  _implementor = nullptr; \/\/ we will fill these lazily\n+  _implementor = nullptr;               \/\/ we will fill these lazily\n@@ -127,1 +128,2 @@\n-  _nonstatic_fields = nullptr;         \/\/ initialized lazily by compute_nonstatic_fields\n+  _declared_nonstatic_fields = nullptr; \/\/ initialized lazily by compute_nonstatic_fields\n+  _nonstatic_fields = nullptr;          \/\/ initialized lazily by compute_nonstatic_fields\n@@ -403,3 +405,3 @@\n-      ciField* field = _nonstatic_fields->at(i);\n-      int  field_off = field->offset_in_bytes();\n-      if (field_off == field_offset)\n+      ciField* field = nonstatic_field_at(i);\n+      int field_off = field->offset_in_bytes();\n+      if (field_off == field_offset) {\n@@ -407,0 +409,1 @@\n+      }\n@@ -410,0 +413,1 @@\n+\n@@ -421,4 +425,7 @@\n-  if (super() != nullptr && super()->has_nonstatic_fields()) {\n-    ciField* f = super()->get_non_flat_field_by_offset(field_offset);\n-    if (f != nullptr) {\n-      return f;\n+  for (int i = 0, len = nof_declared_nonstatic_fields(); i < len; i++) {\n+    ciField* field = declared_nonstatic_field_at(i);\n+    int field_off = field->offset_in_bytes();\n+    if (field_off == field_offset) {\n+      return field;\n+    } else if (field_off > field_offset) {\n+      break;\n@@ -427,0 +434,2 @@\n+  return nullptr;\n+}\n@@ -428,9 +437,16 @@\n-  VM_ENTRY_MARK;\n-  InstanceKlass* k = get_instanceKlass();\n-  Arena* arena = CURRENT_ENV->arena();\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static())  continue;\n-    fieldDescriptor& fd = fs.field_descriptor();\n-    if (fd.offset() == field_offset) {\n-      ciField* f = new (arena) ciField(&fd);\n-      return f;\n+int ciInstanceKlass::field_index_by_offset(int offset) {\n+  assert(contains_field_offset(offset), \"invalid field offset\");\n+  int best_offset = 0;\n+  int best_index = -1;\n+  \/\/ Search the field with the given offset\n+  for (int i = 0; i < nof_declared_nonstatic_fields(); ++i) {\n+    int field_offset = declared_nonstatic_field_at(i)->offset_in_bytes();\n+    if (field_offset == offset) {\n+      \/\/ Exact match\n+      return i;\n+    } else if (field_offset < offset && field_offset > best_offset) {\n+      \/\/ No exact match. Save the index of the field with the closest offset that\n+      \/\/ is smaller than the given field offset. This index corresponds to the\n+      \/\/ flat field that holds the field we are looking for.\n+      best_offset = field_offset;\n+      best_index = i;\n@@ -439,2 +455,3 @@\n-\n-  return nullptr;\n+  assert(best_index >= 0, \"field not found\");\n+  assert(best_offset == offset || declared_nonstatic_field_at(best_index)->type()->is_inlinetype(), \"offset should match for non-inline types\");\n+  return best_index;\n@@ -462,3 +479,3 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciInstanceKlass::compute_nonstatic_fields\n-int ciInstanceKlass::compute_nonstatic_fields() {\n+const GrowableArray<ciField*> empty_field_array(0, MemTag::mtCompiler);\n+\n+void ciInstanceKlass::compute_nonstatic_fields() {\n@@ -467,2 +484,4 @@\n-  if (_nonstatic_fields != nullptr)\n-    return _nonstatic_fields->length();\n+  if (_nonstatic_fields != nullptr) {\n+    assert(_declared_nonstatic_fields != nullptr, \"must be initialized at the same time, class %s\", name()->as_utf8());\n+    return;\n+  }\n@@ -471,3 +490,3 @@\n-    Arena* arena = CURRENT_ENV->arena();\n-    _nonstatic_fields = new (arena) GrowableArray<ciField*>(arena, 0, 0, nullptr);\n-    return 0;\n+    _declared_nonstatic_fields = &empty_field_array;\n+    _nonstatic_fields = &empty_field_array;\n+    return;\n@@ -478,6 +497,5 @@\n-  GrowableArray<ciField*>* super_fields = nullptr;\n-  if (super != nullptr && super->has_nonstatic_fields()) {\n-    int super_flen   = super->nof_nonstatic_fields();\n-    super_fields = super->_nonstatic_fields;\n-    assert(super_flen == 0 || super_fields != nullptr, \"first get nof_fields\");\n-  }\n+  assert(super != nullptr, \"must have a super class, current class: %s\", name()->as_utf8());\n+  super->compute_nonstatic_fields();\n+  const GrowableArray<ciField*>* super_declared_fields = super->_declared_nonstatic_fields;;\n+  const GrowableArray<ciField*>* super_fields = super->_nonstatic_fields;\n+  assert(super_declared_fields != nullptr && super_fields != nullptr, \"must have been initialized, current class: %s, super class: %s\", name()->as_utf8(), super->name()->as_utf8());\n@@ -485,1 +503,0 @@\n-  GrowableArray<ciField*>* fields = nullptr;\n@@ -487,15 +504,2 @@\n-      fields = compute_nonstatic_fields_impl(super_fields);\n-    });\n-\n-  if (fields == nullptr) {\n-    \/\/ This can happen if this class (java.lang.Class) has invisible fields.\n-    if (super_fields != nullptr) {\n-      _nonstatic_fields = super_fields;\n-      return super_fields->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  _nonstatic_fields = fields;\n-  return fields->length();\n+    compute_nonstatic_fields_impl(super_declared_fields, super_fields);\n+  });\n@@ -504,1 +508,2 @@\n-GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool is_flat) {\n+void ciInstanceKlass::compute_nonstatic_fields_impl(const GrowableArray<ciField*>* super_declared_fields, const GrowableArray<ciField*>* super_fields) {\n+  assert(_declared_nonstatic_fields == nullptr && _nonstatic_fields == nullptr, \"initialized already\");\n@@ -507,7 +512,0 @@\n-  int flen = 0;\n-  GrowableArray<ciField*>* fields = nullptr;\n-  InstanceKlass* k = get_instanceKlass();\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static())  continue;\n-    flen += 1;\n-  }\n@@ -515,3 +513,18 @@\n-  \/\/ allocate the array:\n-  if (flen == 0 && !is_inlinetype()) {\n-    return nullptr;  \/\/ return nothing if none are locally declared\n+  InstanceKlass* this_klass = get_instanceKlass();\n+  int declared_field_num = 0;\n+  int field_num = 0;\n+  for (JavaFieldStream fs(this_klass); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      continue;\n+    }\n+\n+    declared_field_num++;\n+\n+    fieldDescriptor& fd = fs.field_descriptor();\n+    if (fd.is_flat()) {\n+      InlineKlass* k = this_klass->get_inline_type_field_klass(fd.index());\n+      ciInlineKlass* vk = CURRENT_ENV->get_klass(k)->as_inline_klass();\n+      field_num += vk->nof_nonstatic_fields();\n+    } else {\n+      field_num++;\n+    }\n@@ -519,2 +532,5 @@\n-  if (super_fields != nullptr) {\n-    flen += super_fields->length();\n+\n+  GrowableArray<ciField*>* tmp_declared_fields = nullptr;\n+  if (declared_field_num != 0) {\n+    tmp_declared_fields = new (arena) GrowableArray<ciField*>(arena, declared_field_num + super_declared_fields->length(), 0, nullptr);\n+    tmp_declared_fields->appendAll(super_declared_fields);\n@@ -522,3 +538,5 @@\n-  fields = new (arena) GrowableArray<ciField*>(arena, flen, 0, nullptr);\n-  if (super_fields != nullptr) {\n-    fields->appendAll(super_fields);\n+\n+  GrowableArray<ciField*>* tmp_fields = nullptr;\n+  if (field_num != 0) {\n+    tmp_fields = new (arena) GrowableArray<ciField*>(arena, field_num + super_fields->length(), 0, nullptr);\n+    tmp_fields->appendAll(super_fields);\n@@ -527,2 +545,9 @@\n-  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static())  continue;\n+  \/\/ For later assertion\n+  declared_field_num += super_declared_fields->length();\n+  field_num += super_fields->length();\n+\n+  for (JavaFieldStream fs(this_klass); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      continue;\n+    }\n+\n@@ -530,2 +555,6 @@\n-    if (fd.is_flat() && is_flat) {\n-      \/\/ Inline type fields are embedded\n+    ciField* declared_field = new (arena) ciField(&fd);\n+    assert(tmp_declared_fields != nullptr, \"should be initialized\");\n+    tmp_declared_fields->append(declared_field);\n+\n+    if (fd.is_flat()) {\n+      \/\/ Flat fields are embedded\n@@ -533,1 +562,0 @@\n-      \/\/ Get InlineKlass and adjust number of fields\n@@ -536,1 +564,0 @@\n-      flen += vk->nof_nonstatic_fields() - 1;\n@@ -546,1 +573,2 @@\n-        fields->append(field);\n+        assert(tmp_fields != nullptr, \"should be initialized\");\n+        tmp_fields->append(field);\n@@ -549,2 +577,2 @@\n-      ciField* field = new (arena) ciField(&fd);\n-      fields->append(field);\n+      assert(tmp_fields != nullptr, \"should be initialized\");\n+      tmp_fields->append(declared_field);\n@@ -553,3 +581,19 @@\n-  assert(fields->length() == flen, \"sanity\");\n-  fields->sort(sort_field_by_offset);\n-  return fields;\n+\n+  \/\/ Now sort them by offset, ascending. In principle, they could mix with superclass fields.\n+  if (tmp_declared_fields != nullptr) {\n+    assert(tmp_declared_fields->length() == declared_field_num, \"sanity check failed for class: %s, number of declared fields: %d, expected: %d\",\n+           name()->as_utf8(), tmp_declared_fields->length(), declared_field_num);\n+    tmp_declared_fields->sort(sort_field_by_offset);\n+    _declared_nonstatic_fields = tmp_declared_fields;\n+  } else {\n+    _declared_nonstatic_fields = super_declared_fields;\n+  }\n+\n+  if (tmp_fields != nullptr) {\n+    assert(tmp_fields->length() == field_num, \"sanity check failed for class: %s, number of fields: %d, expected: %d\",\n+           name()->as_utf8(), tmp_fields->length(), field_num);\n+    tmp_fields->sort(sort_field_by_offset);\n+    _nonstatic_fields = tmp_fields;\n+  } else {\n+    _nonstatic_fields = super_fields;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":123,"deletions":79,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -70,3 +70,10 @@\n- public:\n-  GrowableArray<ciField*>* _nonstatic_fields;  \/\/ ordered by JavaFieldStream\n- private:\n+\n+  \/\/ Fields declared in the bytecode (without nested fields in flat fields), ordered by\n+  \/\/ offset.\n+  const GrowableArray<ciField*>* _declared_nonstatic_fields;\n+\n+  \/\/ Fields laid out in memory (flat fields are expanded into their components). The ciField object\n+  \/\/ for each primitive component has the holder being this ciInstanceKlass or one of its\n+  \/\/ superclasses, ordered by offset.\n+  const GrowableArray<ciField*>* _nonstatic_fields;\n+\n@@ -109,2 +116,2 @@\n-  virtual int compute_nonstatic_fields();\n-  GrowableArray<ciField*>* compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool flatten = true);\n+  void compute_nonstatic_fields();\n+  void compute_nonstatic_fields_impl(const GrowableArray<ciField*>* super_declared_fields, const GrowableArray<ciField*>* super_fields);\n@@ -208,1 +215,1 @@\n-  \/\/ get field descriptor at field_offset ignoring flattening\n+  \/\/ Get field descriptor at field_offset ignoring flattening\n@@ -210,0 +217,10 @@\n+  \/\/ Get the index of the declared field that contains this offset\n+  int field_index_by_offset(int offset);\n+\n+  \/\/ Total number of nonstatic fields (including inherited)\n+  int nof_declared_nonstatic_fields() {\n+    if (_declared_nonstatic_fields == nullptr) {\n+      compute_nonstatic_fields();\n+    }\n+    return _declared_nonstatic_fields->length();\n+  }\n@@ -211,1 +228,0 @@\n-  \/\/ total number of nonstatic fields (including inherited):\n@@ -214,3 +230,1 @@\n-      return compute_nonstatic_fields();\n-    } else {\n-      return _nonstatic_fields->length();\n+      compute_nonstatic_fields();\n@@ -218,0 +232,1 @@\n+    return _nonstatic_fields->length();\n@@ -229,1 +244,5 @@\n-  \/\/ nth nonstatic field (presented by ascending address)\n+  ciField* declared_nonstatic_field_at(int i) {\n+    assert(_declared_nonstatic_fields != nullptr, \"should be initialized\");\n+    return _declared_nonstatic_fields->at(i);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"}]}