{"files":[{"patch":"@@ -34,0 +34,20 @@\n+ciConstant ciConstant::make_zero_or_null(BasicType bt) {\n+  switch (bt) {\n+  case T_FLOAT: return ciConstant((jfloat).0f);\n+  case T_DOUBLE: return ciConstant((jdouble).0);\n+  case T_LONG: return ciConstant((jlong)0L);\n+  case T_BOOLEAN:\n+  case T_CHAR:\n+  case T_BYTE:\n+  case T_SHORT:\n+  case T_INT:\n+    return ciConstant(bt, 0);\n+  case T_OBJECT:\n+  case T_ARRAY:\n+    return ciConstant(bt, CURRENT_ENV->get_object(nullptr));\n+  default:\n+    ShouldNotReachHere();\n+    return ciConstant();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciConstant.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+  static ciConstant make_zero_or_null(BasicType);\n","filename":"src\/hotspot\/share\/ci\/ciConstant.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-    _constant_value = mirror->field_value_impl(type()->basic_type(), offset_in_bytes());\n+    _constant_value = mirror->field_value_impl(type()->basic_type(), offset_in_bytes(), false);\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+  ciInstanceKlass* original_holder() const { return _original_holder; }\n@@ -113,3 +114,0 @@\n-  \/\/ How big is this field in memory?\n-  int size_in_bytes() { return type2aelembytes(layout_type()); }\n-\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,36 +33,0 @@\n-ciConstant ciFlatArray::null_marker_of_element_by_offset_impl(arrayOop ary, int index) {\n-  if (ary == nullptr) {\n-    return ciConstant();\n-  }\n-  assert(ary->is_array(), \"\");\n-  if (index < 0 || index >= ary->length()) {\n-    return ciConstant();\n-  }\n-    assert(ary->is_objArray(), \"\");\n-    flatArrayOop objary = (flatArrayOop) ary;\n-    jboolean elem = objary->null_marker_of_obj_at(index);\n-    return ciConstant(T_BOOLEAN, elem);\n-}\n-\n-ciConstant ciFlatArray::check_constant_null_marker_cache(int off) {\n-  if (_constant_null_markers != nullptr) {\n-    for (int i = 0; i < _constant_null_markers->length(); ++i) {\n-      ConstantValue cached_val = _constant_null_markers->at(i);\n-      if (cached_val.off() == off) {\n-        return cached_val.value();\n-      }\n-    }\n-  }\n-  return ciConstant();\n-}\n-\n-void ciFlatArray::add_to_constant_null_marker_cache(int off, ciConstant val) {\n-  assert(val.is_valid(), \"value must be valid\");\n-  assert(!check_constant_value_cache(off, val.basic_type()).is_valid(), \"duplicate\");\n-  if (_constant_null_markers == nullptr) {\n-    Arena* arena = CURRENT_ENV->arena();\n-    _constant_null_markers = new (arena) GrowableArray<ConstantValue>(arena, 1, 0, ConstantValue());\n-  }\n-  _constant_null_markers->append(ConstantValue(off, val));\n-}\n-\n@@ -72,8 +36,3 @@\n-  ciConstant value = check_constant_null_marker_cache(index);\n-  if (value.is_valid()) {\n-    return value;\n-  }\n-  GUARDED_VM_ENTRY(\n-      value = null_marker_of_element_by_offset_impl(get_arrayOop(), index);)\n-  add_to_constant_null_marker_cache(index, value);\n-  return value;\n+  ciConstant nm = field_value(index, nullptr);\n+  postcond(!nm.is_valid() || nm.basic_type() == T_BOOLEAN);\n+  return nm;\n@@ -139,1 +98,4 @@\n-      return ciConstant();\n+      if (field == nullptr) {\n+        return ciConstant::make_zero_or_null(T_BOOLEAN);\n+      }\n+      return ciConstant::make_zero_or_null(field->type()->basic_type());\n@@ -144,1 +106,1 @@\n-      return inst->null_marker_value();\n+      return ciConstant(T_BOOLEAN, 1);\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.cpp","additions":8,"deletions":46,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n-\n-private:\n-  ciConstant null_marker_of_element_by_offset_impl(arrayOop ary, int index);\n-  ciConstant check_constant_null_marker_cache(int off);\n-  void add_to_constant_null_marker_cache(int off, ciConstant val);\n-\n-  GrowableArray<ConstantValue>* _constant_null_markers = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"oops\/fieldStreams.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -62,1 +64,1 @@\n-ciConstant ciInstance::field_value_impl(BasicType field_btype, int offset) {\n+ciConstant ciInstance::field_value_impl(BasicType field_btype, int offset, bool field_is_flat) {\n@@ -81,1 +83,20 @@\n-      oop o = obj->obj_field(offset);\n+      if (field_is_flat) {\n+        InstanceKlass* holder = InstanceKlass::cast(obj->klass());\n+        int index = -1;\n+        for (JavaFieldStream fs(holder); !fs.done(); fs.next()) {\n+          if (!fs.access_flags().is_static() && fs.offset() == offset) {\n+            index = fs.index();\n+            break;\n+          }\n+        }\n+        assert(index != -1, \"no field at given offset\");\n+        InlineLayoutInfo* layout_info = holder->inline_layout_info_adr(index);\n+        InlineKlass* vk = layout_info->klass();\n+        oop res = vk->read_payload_from_addr(obj, offset, layout_info->kind(), THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+          return ciConstant();\n+        }\n+        value = ciConstant(field_btype, CURRENT_ENV->get_object(res));\n+      } else {\n+        oop o = obj->obj_field(offset);\n@@ -83,6 +104,6 @@\n-      \/\/ A field will be \"constant\" if it is known always to be\n-      \/\/ a non-null reference to an instance of a particular class,\n-      \/\/ or to a particular array.  This can happen even if the instance\n-      \/\/ or array is not perm.  In such a case, an \"unloaded\" ciArray\n-      \/\/ or ciInstance is created.  The compiler may be able to use\n-      \/\/ information about the object's class (which is exact) or length.\n+        \/\/ A field will be \"constant\" if it is known always to be\n+        \/\/ a non-null reference to an instance of a particular class,\n+        \/\/ or to a particular array.  This can happen even if the instance\n+        \/\/ or array is not perm.  In such a case, an \"unloaded\" ciArray\n+        \/\/ or ciInstance is created.  The compiler may be able to use\n+        \/\/ information about the object's class (which is exact) or length.\n@@ -90,4 +111,5 @@\n-      if (o == nullptr) {\n-        value = ciConstant(field_btype, ciNullObject::make());\n-      } else {\n-        value = ciConstant(field_btype, CURRENT_ENV->get_object(o));\n+        if (o == nullptr) {\n+          value = ciConstant(field_btype, ciNullObject::make());\n+        } else {\n+          value = ciConstant(field_btype, CURRENT_ENV->get_object(o));\n+        }\n@@ -104,9 +126,0 @@\n-\/\/ Constant value of the null marker.\n-ciConstant ciInstance::null_marker_value() {\n-  if (!klass()->is_inlinetype()) {\n-    return ciConstant();\n-  }\n-  ciInlineKlass* ik = klass()->as_inline_klass();\n-  return field_value_impl(T_BOOLEAN, ik->null_marker_offset_in_payload() + ik->payload_offset());\n-}\n-\n@@ -116,1 +129,8 @@\n-\/\/ Constant value of a field.\n+\/\/ Constant value of a field. The field can be flat, in which case a cached copy\n+\/\/ of the value object is returned. Since stable fields are \"constant\" but not\n+\/\/ really, we need to cache the value of fields so that the compiler will observe\n+\/\/ only one value. We also need to ensure that sub-fields (flattened fields) from\n+\/\/ a single stable field of value class type will be observed to be consistent with\n+\/\/ each other. To do so, we need to always fetch the declared field containing the\n+\/\/ desired field. If we want a sub-field of a flat field, we then extract the field\n+\/\/ out of the cached copy.\n@@ -122,0 +142,30 @@\n+  ciInstanceKlass* klass = this->klass()->as_instance_klass();\n+  ciField* containing_field;\n+  if (field->original_holder() == nullptr) {\n+    containing_field = field;\n+  } else {\n+    int containing_field_idx = klass->field_index_by_offset(field->offset_in_bytes());\n+    containing_field = klass->declared_nonstatic_field_at(containing_field_idx);\n+  }\n+  ciConstant containing_field_value = field_value_impl(containing_field->type()->basic_type(), containing_field->offset_in_bytes(), containing_field->is_flat());\n+  if (!containing_field_value.is_valid()) {\n+    return ciConstant();\n+  }\n+  if (field->original_holder() == nullptr) {\n+    return containing_field_value;\n+  } else {\n+    ciObject* obj = containing_field_value.as_object();\n+    if (obj->is_instance()) {\n+      ciInstance* inst = obj->as_instance();\n+      \/\/ inst->klass() must be an inline klass since it is the value of a flat field.\n+      ciInlineKlass* inst_klass = inst->klass()->as_inline_klass();\n+      ciField* field_in_value_klass = inst_klass->get_field_by_offset(inst_klass->payload_offset() + field->offset_in_bytes() - containing_field->offset_in_bytes(), false);\n+      return inst->non_flat_field_value(field_in_value_klass);\n+    } else if (obj->is_null_object()) {\n+      return ciConstant::make_zero_or_null(field->type()->basic_type());\n+    }\n+    \/\/ obj should not be an array since we are trying to get a field inside it\n+    ShouldNotReachHere();\n+    return ciConstant();\n+  }\n+}\n@@ -123,1 +173,43 @@\n-  return field_value_impl(field->type()->basic_type(), field->offset_in_bytes());\n+\/\/ Extract a field from a value object.\n+\/\/ This won't cache. Must be used only on cached values.\n+ciConstant ciInstance::non_flat_field_value(ciField* field) {\n+  precond(klass()->is_inlinetype());\n+  precond(!field->is_flat());\n+  int offset = field->offset_in_bytes();\n+  BasicType field_btype = field->type()->basic_type();\n+\n+  ciConstant value;\n+  VM_ENTRY_MARK;\n+  oop obj = get_oop();\n+  assert(obj != nullptr, \"bad oop\");\n+  switch(field_btype) {\n+  case T_BYTE:    value = ciConstant(field_btype, obj->byte_field(offset)); break;\n+  case T_CHAR:    value = ciConstant(field_btype, obj->char_field(offset)); break;\n+  case T_SHORT:   value = ciConstant(field_btype, obj->short_field(offset)); break;\n+  case T_BOOLEAN: value = ciConstant(field_btype, obj->bool_field(offset)); break;\n+  case T_INT:     value = ciConstant(field_btype, obj->int_field(offset)); break;\n+  case T_FLOAT:   value = ciConstant(obj->float_field(offset)); break;\n+  case T_DOUBLE:  value = ciConstant(obj->double_field(offset)); break;\n+  case T_LONG:    value = ciConstant(obj->long_field(offset)); break;\n+  case T_OBJECT:  \/\/ fall through\n+  case T_ARRAY: {\n+    oop o = obj->obj_field(offset);\n+\n+    \/\/ A field will be \"constant\" if it is known always to be\n+    \/\/ a non-null reference to an instance of a particular class,\n+    \/\/ or to a particular array.  This can happen even if the instance\n+    \/\/ or array is not perm.  In such a case, an \"unloaded\" ciArray\n+    \/\/ or ciInstance is created.  The compiler may be able to use\n+    \/\/ information about the object's class (which is exact) or length.\n+\n+    if (o == nullptr) {\n+      value = ciConstant(field_btype, ciNullObject::make());\n+    } else {\n+      value = ciConstant(field_btype, CURRENT_ENV->get_object(o));\n+    }\n+    break;\n+  }\n+  default:\n+    fatal(\"no field value: %s\", type2name(field_btype));\n+  }\n+  return value;\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":115,"deletions":23,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-  ciConstant field_value_impl(BasicType field_btype, int offset);\n+  ciConstant field_value_impl(BasicType field_btype, int offset, bool field_is_flat);\n+  ciConstant non_flat_field_value(ciField* field);\n@@ -68,1 +69,0 @@\n-  ciConstant null_marker_value();\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -441,1 +441,0 @@\n-  assert(contains_field_offset(offset), \"invalid field offset\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2101,7 +2101,4 @@\n-      \/\/ constant folding when fields are constant. But if the flattened field being accessed is read-only\n-      \/\/ then no concurrent writes can happen and non-atomic loads are fine, allowing better optimizations.\n-      \/\/ A way for fields to be read-only is to be stable and already initialized. Here, we check if the\n-      \/\/ field being accessed is stable, and if the null marker of the field\/array element is non-zero.\n-      \/\/ If so, we know that the stable value was initialized away from the default value (null), and\n-      \/\/ that we can assume it's read-only, so can the load can be performed non-atomically.\n-      bool non_atomic_is_fine = false;\n+      \/\/ constant folding when fields are constant. If we can get a constant object from which we are\n+      \/\/ flat-loading, we can simply replace the loads at compilation-time by the field of the constant\n+      \/\/ object.\n+      ciInstance* loaded_from = nullptr;\n@@ -2111,2 +2108,0 @@\n-        ciInstance* holder = oop != nullptr && oop->is_instance() ? oop->as_instance() : nullptr;\n-        ciArray* array = oop != nullptr && oop->is_array() ? oop->as_array() : nullptr;\n@@ -2115,1 +2110,2 @@\n-        if (holder != nullptr) {\n+        if (oop != nullptr && oop->is_instance()) {\n+          ciInstance* holder = oop->as_instance();\n@@ -2118,5 +2114,12 @@\n-          const ciField* field = iklass->get_non_flat_field_by_offset(off);\n-          ciField* nm_field = iklass->get_field_by_offset(field->null_marker_offset(), false);\n-          ciConstant cst = nm_field != nullptr ? holder->field_value(nm_field) : ciConstant() \/* invalid *\/;\n-          non_atomic_is_fine = field->is_stable() && cst.is_valid() && cst.as_boolean();\n-        } else if (array != nullptr) {\n+          ciField* field = iklass->get_non_flat_field_by_offset(off);\n+\n+          if (field->is_stable()) {\n+            ciConstant fv = holder->field_value(field);\n+            if (is_reference_type(fv.basic_type()) && fv.as_object()->is_instance()) {\n+              \/\/ The field value is an object, not null. We can use stability.\n+              loaded_from = fv.as_object()->as_instance();\n+            }\n+          }\n+        } else if (oop != nullptr && oop->is_array()) {\n+          ciArray* array = oop->as_array();\n+          ciConstant elt = array->element_value_by_offset(off);\n@@ -2124,2 +2127,3 @@\n-          ciConstant elt = ((ciFlatArray*)array)->null_marker_of_element_by_offset(off);\n-          non_atomic_is_fine = aryptr->is_stable() && elt.is_valid() && !elt.is_null_or_zero();\n+          if (aryptr->is_stable() && is_reference_type(elt.basic_type()) && elt.as_object()->is_instance()) {\n+            loaded_from = elt.as_object()->as_instance();\n+          }\n@@ -2129,2 +2133,2 @@\n-      if (non_atomic_is_fine) {\n-        loadn->expand_non_atomic(igvn);\n+      if (loaded_from != nullptr) {\n+        loadn->expand_constant(igvn, loaded_from);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1661,0 +1661,48 @@\n+bool LoadFlatNode::expand_constant(PhaseIterGVN& igvn, ciInstance* inst) const {\n+  precond(inst != nullptr);\n+  assert(igvn.delay_transform(), \"transformation must be delayed\");\n+  if ((_decorators & C2_MISMATCHED) != 0) {\n+    return false;\n+  }\n+\n+  GraphKit kit(jvms(), &igvn);\n+  kit.set_all_memory(kit.reset_memory());\n+\n+  for (int i = 0; i < _vk->nof_nonstatic_fields(); i++) {\n+    ProjNode* proj_out = proj_out_or_null(TypeFunc::Parms + i);\n+    if (proj_out == nullptr) {\n+      continue;\n+    }\n+\n+    ciField* field = _vk->nonstatic_field_at(i);\n+    BasicType bt = field->type()->basic_type();\n+    if (inst == nullptr) {\n+      Node* cst_node = igvn.zerocon(bt);\n+      igvn.replace_node(proj_out, cst_node);\n+    } else {\n+      bool is_unsigned_load = bt == T_BOOLEAN || bt == T_CHAR;\n+      const Type* cst_type = Type::make_constant_from_field(field, inst, bt, is_unsigned_load);\n+      Node* cst_node = igvn.makecon(cst_type);\n+      igvn.replace_node(proj_out, cst_node);\n+    }\n+  }\n+\n+  if (!_null_free) {\n+    ProjNode* proj_out = proj_out_or_null(TypeFunc::Parms + _vk->nof_nonstatic_fields());\n+    if (proj_out != nullptr) {\n+      igvn.replace_node(proj_out, igvn.intcon(1));\n+    }\n+  }\n+\n+  Node* old_ctrl = proj_out_or_null(TypeFunc::Control);\n+  if (old_ctrl != nullptr) {\n+    igvn.replace_node(old_ctrl, kit.control());\n+  }\n+  Node* old_mem = proj_out_or_null(TypeFunc::Memory);\n+  Node* new_mem = kit.reset_memory();\n+  if (old_mem != nullptr) {\n+    igvn.replace_node(old_mem, new_mem);\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+  bool expand_constant(PhaseIterGVN& igvn, ciInstance* inst) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -403,1 +403,6 @@\n-  \/\/ Decode the results of GraphKit::array_element_address.\n+  if (!array->is_null_free()) {\n+    ciConstant nm_value = array->null_marker_of_element_by_offset(off);\n+    if (!nm_value.is_valid() || !nm_value.as_boolean()) {\n+      return nullptr;\n+    }\n+  }\n@@ -406,1 +411,1 @@\n-    return nullptr; \/\/ wrong offset, or the array element at offset off is null.\n+    return nullptr; \/\/ wrong offset\n@@ -413,2 +418,1 @@\n-  if (con.is_valid() &&          \/\/ not a mismatched access\n-      !con.is_null_or_zero()) {  \/\/ not a default value\n+  if (con.is_valid()) { \/\/ not a mismatched access\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}