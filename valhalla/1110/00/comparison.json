{"files":[{"patch":"@@ -261,1 +261,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_flat_array_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_null_free_array_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-    case new_flat_array_id:\n+    case new_null_free_array_id:\n@@ -715,1 +715,1 @@\n-          __ set_info(\"new_flat_array\", dont_gc_arguments);\n+          __ set_info(\"new_null_free_array\", dont_gc_arguments);\n@@ -738,3 +738,1 @@\n-          case new_flat_array_id:\n-            \/\/ TODO 8325106 Fix comment\n-            \/\/ new \"[QVT;\"\n+          case new_null_free_array_id:\n@@ -762,2 +760,2 @@\n-          assert(id == new_flat_array_id, \"must be\");\n-          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_flat_array), klass, length);\n+          assert(id == new_null_free_array_id, \"must be\");\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_null_free_array), klass, length);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_flat_array_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_null_free_array_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-    case new_flat_array_id:\n+    case new_null_free_array_id:\n@@ -1084,1 +1084,1 @@\n-          __ set_info(\"new_flat_array\", dont_gc_arguments);\n+          __ set_info(\"new_null_free_array\", dont_gc_arguments);\n@@ -1107,3 +1107,1 @@\n-          case new_flat_array_id:\n-            \/\/ TODO 8325106 Fix comment\n-            \/\/ new \"[QVT;\"\n+          case new_null_free_array_id:\n@@ -1131,2 +1129,2 @@\n-          assert(id == new_flat_array_id, \"must be\");\n-          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_flat_array), klass, length);\n+          assert(id == new_null_free_array_id, \"must be\");\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_null_free_array), klass, length);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2023,1 +2023,1 @@\n-              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset_in_bytes());\n+              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset_in_bytes(), state_before);\n@@ -2049,0 +2049,3 @@\n+              if (has_pending_field_access()) {\n+                state_before = pending_field_access()->state_before();\n+              }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+  ValueStack*      _state_before;\n+\n@@ -44,2 +46,2 @@\n-  DelayedFieldAccess(Value obj, ciInstanceKlass* holder, int offset)\n-  : _obj(obj), _holder(holder) , _offset(offset) { }\n+  DelayedFieldAccess(Value obj, ciInstanceKlass* holder, int offset, ValueStack* state_before)\n+  : _obj(obj), _holder(holder) , _offset(offset), _state_before(state_before) { }\n@@ -47,1 +49,1 @@\n-  Value obj() const               { return _obj; }\n+  Value obj() const { return _obj; }\n@@ -49,2 +51,3 @@\n-  int offset() const              { return _offset; }\n-  void inc_offset(int offset)     { _offset += offset; }\n+  int offset() const { return _offset; }\n+  void inc_offset(int offset) { _offset += offset; }\n+  ValueStack* state_before() const { return _state_before; }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-        \/\/ TODO 8325106 Fix comment\n-        \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n+        \/\/ Due to array covariance, the runtime type might be a flat array.\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-uint Runtime1::_new_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_new_null_free_array_slowcase_cnt = 0;\n@@ -432,2 +432,2 @@\n-JRT_ENTRY(void, Runtime1::new_flat_array(JavaThread* current, Klass* array_klass, jint length))\n-  NOT_PRODUCT(_new_flat_array_slowcase_cnt++;)\n+JRT_ENTRY(void, Runtime1::new_null_free_array(JavaThread* current, Klass* array_klass, jint length))\n+  NOT_PRODUCT(_new_null_free_array_slowcase_cnt++;)\n@@ -1699,1 +1699,1 @@\n-  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %u\", _new_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _new_null_free_array_slowcase_cnt: %u\", _new_null_free_array_slowcase_cnt);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  stub(new_flat_array)               \\\n+  stub(new_null_free_array)          \\\n@@ -111,1 +111,1 @@\n-  static uint _new_flat_array_slowcase_cnt;\n+  static uint _new_null_free_array_slowcase_cnt;\n@@ -157,1 +157,1 @@\n-  static void new_flat_array (JavaThread* current, Klass* klass, jint length);\n+  static void new_null_free_array(JavaThread* current, Klass* klass, jint length);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    if (is_null_free_array != nullptr && (k->is_flatArray_klass() || (k->is_objArray_klass() && ObjArrayKlass::cast(k)->is_null_free_array_klass()))) {\n+    if (is_null_free_array != nullptr && (k->is_flatArray_klass() || (k->is_objArray_klass() && k->is_null_free_array_klass()))) {\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+\n+bool ciObjArrayKlass::is_elem_null_free() const {\n+  GUARDED_VM_ENTRY(return get_Klass()->is_null_free_array_klass();)\n+}\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+\n+  virtual bool is_elem_null_free() const;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,0 +317,2 @@\n+    VectorSet visited;\n+    visited.set(oop->_idx);\n@@ -323,1 +325,1 @@\n-        if (in->is_Phi()) {\n+        if (in->is_Phi() && !visited.test_set(in->_idx)) {\n@@ -538,0 +540,7 @@\n+  \/\/ TODO 8325106\n+  \/*\n+  if (inline_klass()->is_initialized() && inline_klass()->is_empty()) {\n+    assert(false, \"Should not buffer empty inline klass\");\n+  }\n+  *\/\n+\n@@ -808,3 +817,1 @@\n-  \/\/ TODO 8325106 we should be able to set buffered here for non-larvals, right?\n-  \/\/vt->set_is_buffered(gvn, vk->is_initialized());\n-  vt->set_is_buffered(gvn, false);\n+  vt->set_is_buffered(gvn, vk->is_initialized() && !is_larval);\n@@ -1234,0 +1241,1 @@\n+  \/\/ TODO 8332886 Really needed? GVN is disabled anyway.\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -198,8 +198,0 @@\n-  Node* obj = peek();\n-  const Type* obj_type = gvn().type(obj);\n-  if (obj_type->is_inlinetypeptr()) {\n-    uncommon_trap(Deoptimization::Reason_class_check,\n-                  Deoptimization::Action_none);\n-    return;\n-  }\n-\n@@ -207,1 +199,1 @@\n-  obj = null_check(obj);\n+  Node* obj = null_check(peek());\n@@ -211,0 +203,6 @@\n+  {\n+    \/\/ Synchronizing on an inline type is not allowed\n+    BuildCutout unless(this, inline_type_test(obj, \/* is_inline = *\/ false), PROB_MAX);\n+    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2270,43 +2270,0 @@\n-void PhaseMacroExpand::inline_type_guard(Node** ctrl, LockNode* lock) {\n-  Node* obj = lock->obj_node();\n-  const TypePtr* obj_type = _igvn.type(obj)->make_ptr();\n-  if (!obj_type->can_be_inline_type()) {\n-    return;\n-  }\n-  Node* mark = make_load(*ctrl, lock->memory(), obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-  Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n-  Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));\n-  Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));\n-  Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n-  Node* unc_ctrl = generate_slow_guard(ctrl, bol, nullptr);\n-\n-  int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n-  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n-  const TypePtr* no_memory_effects = nullptr;\n-  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n-                                         no_memory_effects);\n-  unc->init_req(TypeFunc::Control, unc_ctrl);\n-  unc->init_req(TypeFunc::I_O, lock->i_o());\n-  unc->init_req(TypeFunc::Memory, lock->memory());\n-  unc->init_req(TypeFunc::FramePtr,  lock->in(TypeFunc::FramePtr));\n-  unc->init_req(TypeFunc::ReturnAdr, lock->in(TypeFunc::ReturnAdr));\n-  unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n-  unc->set_cnt(PROB_UNLIKELY_MAG(4));\n-  unc->copy_call_debug_info(&_igvn, lock);\n-\n-  assert(unc->peek_monitor_box() == lock->box_node(), \"wrong monitor\");\n-  assert((obj_type->is_inlinetypeptr() && unc->peek_monitor_obj()->is_SafePointScalarObject()) ||\n-         (obj->is_InlineType() && obj->in(1) == unc->peek_monitor_obj()) ||\n-         (obj == unc->peek_monitor_obj()), \"wrong monitor\");\n-\n-  \/\/ pop monitor and push obj back on stack: we trap before the monitorenter\n-  unc->pop_monitor();\n-  unc->grow_stack(unc->jvms(), 1);\n-  unc->set_stack(unc->jvms(), unc->jvms()->stk_size()-1, obj);\n-  _igvn.register_new_node_with_optimizer(unc);\n-\n-  unc_ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));\n-  Node* halt = _igvn.transform(new HaltNode(unc_ctrl, lock->in(TypeFunc::FramePtr), \"monitor enter on inline type\"));\n-  _igvn.add_input_to(C->root(), halt);\n-}\n-\n@@ -2359,3 +2316,0 @@\n-    \/\/ Deoptimize and re-execute if object is an inline type\n-    inline_type_guard(&ctrl, alock->as_Lock());\n-\n@@ -2422,3 +2376,0 @@\n-  \/\/ Deoptimize and re-execute if object is an inline type\n-  inline_type_guard(&slow_path, lock);\n-\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  void inline_type_guard(Node** ctrl, LockNode* lock);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6515,1 +6515,0 @@\n-  \/\/ TODO 8325106 remove?\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-    private static final String START = \"(\\\\d+ (.*\";\n-    private static final String MID = \".*)+ ===.*\";\n+    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    private static final String MID = \".*)+(\\\\s){2}===.*\";\n@@ -65,1 +65,1 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R(.*(decode|mov|nop).*\\\\R)*.*(cmp|CMP|CLR))\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-\/\/ TODO 8325106 Investigate why this suddenly started to throw java.lang.OutOfMemoryError without -Xmx200m\n-\/\/ and -XX:-UseCompressedOops -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=0 -Xmx20m -Xmn1m -XX:G1HeapRegionSize=1m -XX:-ReduceInitialCardMarks\n-\n@@ -34,1 +31,1 @@\n- * @run main\/othervm -Xmx200m TestArrayAccessDeopt\n+ * @run main TestArrayAccessDeopt\n@@ -38,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -76,1 +75,1 @@\n-        va[0] = (MyValue1)vt;\n+        va[0] = (MyValue1)Objects.requireNonNull(vt);\n@@ -88,1 +87,1 @@\n-        va[0] = (MyValue1)vt;\n+        va[0] = Objects.requireNonNull(vt);\n@@ -107,1 +106,1 @@\n-            oa.shouldNotContain(\"Uncommon trap occurred\");\n+            oa.shouldNotContain(\"UNCOMMON TRAP\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayAccessDeopt.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-\/\/ TODO 8325106 Fix and enable _arraycopy intrinsic for this test (fails with -XX:-TieredCompilation). We need more test coverage because other tests don't seem to trigger the failure.\n-\n@@ -34,2 +32,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraycopy\n- *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n@@ -39,2 +36,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraycopy\n- *                   -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.valhalla.inlinetypes.TestArrayCopyWithOops::test*\n@@ -44,2 +40,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraycopy\n- *                   compiler.valhalla.inlinetypes.TestArrayCopyWithOops\n+ * @run main\/othervm compiler.valhalla.inlinetypes.TestArrayCopyWithOops\n@@ -141,2 +136,0 @@\n-    \/\/ TODO 8325106 test9\/test11 and test10\/test12 are equivalent\n-    \/\/ Using ManyOops[].class in both test9\/11 and running with -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline triggers an exception\n@@ -144,2 +137,1 @@\n-        ManyOops[] src = createValueClassArray();\n-        return Arrays.copyOf(src, LEN, src.getClass());\n+        return Arrays.copyOf(createValueClassArray(), LEN, ManyOops[].class);\n@@ -158,1 +150,2 @@\n-        return Arrays.copyOf(createObjectArray(), LEN, Object[].class);\n+        Object[] src = createObjectArray();\n+        return Arrays.copyOf(createObjectArray(), LEN, src.getClass());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2343,0 +2343,2 @@\n+    static final MyValue1[] nullFreeArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+\n@@ -2349,2 +2351,2 @@\n-        \/\/ stored null and therefore the array can't be an value class array.\n-        return (MyValue1[])array;\n+        \/\/ stored null and therefore the array can't be a null-free value class array.\n+        return nullFreeArray.getClass().cast(array);\n@@ -2377,2 +2379,2 @@\n-        \/\/ stored null and therefore the array can't be an value class array.\n-        MyValue1[] casted = (MyValue1[])array;\n+        \/\/ stored null and therefore the array can't be a null-free value class array.\n+        MyValue1[] casted = nullFreeArray.getClass().cast(array);\n@@ -2510,2 +2512,1 @@\n-    \/\/ TODO 8325106 This fails to detect the \"movq    R10, precise [compiler\/valhalla\/inlinetypes\/MyValue1\" shape, also affects mainline\n-    \/\/ @IR(counts = { IRNode.CHECKCAST_ARRAY, \"= 1\" })\n+    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n@@ -2520,0 +2521,1 @@\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n@@ -2522,0 +2524,28 @@\n+        Asserts.assertTrue(test101(array3));\n+    }\n+\n+    \/\/ Test that CHECKCAST_ARRAY matching works as expected with null-free arrays\n+    @Test\n+    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    public Object test101NullFree(Object[] array) {\n+        return nullFreeArray.getClass().cast(array);\n+    }\n+\n+    @Run(test = \"test101NullFree\")\n+    public void test101NullFree_verifier() {\n+        MyValue1[] array1 = new MyValue1[1];\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        try {\n+            test101NullFree(array1);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test101NullFree(array2);\n+            throw new RuntimeException(\"Should throw ClassCastException\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        test101NullFree(array3);\n@@ -3092,2 +3122,1 @@\n-    \/\/ TODO 8325106 Shouldn't profiling determine that the array is null restricted?\n-    \/\/@IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD})\n@@ -3116,2 +3145,1 @@\n-    \/\/ TODO 8325106 Shouldn't profiling determine that the array is null restricted?\n-    \/\/@IR(failOn = {ALLOC, ALLOCA, LOAD, STORE})\n+    @IR(failOn = {ALLOC, ALLOCA, LOAD})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -180,1 +180,0 @@\n-    \/\/ TODO 8325106 We are hitting 8314999 here and sometimes fail to detect two allocations although there are two.\n@@ -212,0 +211,1 @@\n+static MyValue1 tmp = null;\n@@ -218,4 +218,3 @@\n-    \/\/ TODO 8325106\n-    \/\/ @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n-    \/\/     counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n-    \/\/     failOn = {LOAD, TRAP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n+        failOn = {LOAD, TRAP})\n@@ -230,0 +229,1 @@\n+            v.hashInterpreted();\n@@ -515,3 +515,3 @@\n-    \/\/ TODO 8325106 We already buffer the larval and we had to disable InlineTypeNode::remove_redundant_allocations for larvals\n-\/\/    @IR(counts = {ALLOC, \"= 2\"},\n-\/\/        failOn = TRAP)\n+    \/\/ TODO 8332886 Re-enable this\n+    \/\/ @IR(counts = {ALLOC, \"= 2\"},\n+    \/\/     failOn = TRAP)\n@@ -647,1 +647,1 @@\n-    \/\/ TODO 8325106 With incremental inlining, we already buffer the larval and we had to disable InlineTypeNode::remove_redundant_allocations for larvals\n+    \/\/ TODO 8332886 Remove the AlwaysIncrementalInline=false condition\n@@ -892,2 +892,0 @@\n-\/\/ TODO 8325106: Re-enable once JDK-8327695 is fixed\n-\/*\n@@ -913,1 +911,0 @@\n-*\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1113,2 +1113,1 @@\n-\/\/ TODO 8325106\n-\/\/    @IR(failOn = {ALLOC, STORE, TRAP})\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,1 +78,2 @@\n-                .addFlags(\"--enable-preview\",\n+                \/\/ TODO 8331912 Remove -XX:-ExpandSubTypeCheckAtParseTime\n+                .addFlags(\"--enable-preview\", \"-XX:-ExpandSubTypeCheckAtParseTime\",\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-            \/\/ TODO 8325106 Triggers \"nothing between inner and outer loop\" assert\n+            \/\/ TODO 8332814 This triggers the \"nothing between inner and outer loop\" assert\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1374,2 +1374,0 @@\n-    \/\/ TODO 8325106 Re-enable\n-    \/*\n@@ -1394,1 +1392,0 @@\n-    *\/\n@@ -3759,2 +3756,0 @@\n-    \/\/ TODO 8325106\n-    \/*\n@@ -3766,1 +3761,0 @@\n-    *\/\n@@ -4048,3 +4042,1 @@\n-    \/\/ TODO 8325106 With incremental inlining, we already buffer the larval which can't use the default oop because it might be overridden.\n-    @IR(applyIf = {\"AlwaysIncrementalInline\", \"false\"},\n-        failOn = {ALLOC_G})\n+    @IR(failOn = {ALLOC_G})\n@@ -4131,2 +4123,0 @@\n-    \/\/ TODO 8325106\n-    \/*\n@@ -4135,1 +4125,0 @@\n-    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    static abstract class NonValueAbstract {\n+    static abstract value class ValueAbstract {\n@@ -141,1 +141,1 @@\n-    static class NonValueClass1 extends NonValueAbstract {\n+    static class NonValueClass1 extends ValueAbstract {\n@@ -149,1 +149,1 @@\n-    static class NonValueClass2 extends NonValueAbstract {\n+    static class NonValueClass2 extends ValueAbstract {\n@@ -264,1 +264,1 @@\n-    public void test6_helper(NonValueAbstract[] arg) {\n+    public void test6_helper(ValueAbstract[] arg) {\n@@ -271,1 +271,0 @@\n-    \/\/ TODO 8325106 double-check rule modifications done by 8325660\n@@ -275,3 +274,3 @@\n-        counts = {CALL, \"= 3\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n-    public Object test6(NonValueAbstract[] array) {\n-        NonValueAbstract v = array[0];\n+        counts = {CALL, \"= 4\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n+    public Object test6(ValueAbstract[] array) {\n+        ValueAbstract v = array[0];\n@@ -298,1 +297,1 @@\n-    public void test7_helper(Object arg) {\n+    public void test7_helper(ValueAbstract arg) {\n@@ -305,1 +304,0 @@\n-    \/\/ TODO 8325106 double-check rule modifications done by 8325660\n@@ -307,1 +305,1 @@\n-        counts = {CALL, \"= 3\", CLASS_CHECK_TRAP, \"= 0\", NULL_CHECK_TRAP, \"= 1\", RANGE_CHECK_TRAP, \"= 1\"})\n+        counts = {CALL, \"= 4\", CLASS_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\", RANGE_CHECK_TRAP, \"= 1\"})\n@@ -309,3 +307,3 @@\n-        counts = {CALL, \"= 3\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n-    public Object test7(NonValueAbstract[] array) {\n-        NonValueAbstract v = array[0];\n+        counts = {CALL, \"= 4\", RANGE_CHECK_TRAP, \"= 1\", NULL_CHECK_TRAP, \"= 1\"})\n+    public Object test7(ValueAbstract[] array) {\n+        ValueAbstract v = array[0];\n@@ -481,3 +479,1 @@\n-\/\/ TODO 8325106\n-\/\/    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n-    @IR(applyIf = {\"UseArrayLoadStoreProfile\", \"true\"},\n+    @IR(applyIfOr = {\"UseArrayLoadStoreProfile\", \"true\", \"TypeProfileLevel\", \"= 222\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2239,1 +2239,1 @@\n-\/\/ TODO 8325106 Fails because they are not compilable with Scenario 3, probably we run out of nodes ...\n+\/\/ TODO 8325632 Fails with -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n@@ -2241,0 +2241,1 @@\n+\n@@ -2380,2 +2381,0 @@\n-\/\/ TODO 8325106 Fails because they are not compilable with Scenario 3, probably we run out of nodes ...\n-\/*\n@@ -2384,2 +2383,1 @@\n-    \/\/ TODO 8325106 Fails with Scenario 5\n-    \/\/ @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n@@ -2411,1 +2409,0 @@\n-*\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -558,8 +558,1 @@\n-                MyValue13Holder holder = new MyValue13Holder();\n-                try {\n-                    test13(holder);\n-\/\/ TODO 8325106\n-\/\/                    Asserts.fail(\"Should have thrown InstantiationError\");\n-                } catch (InstantiationError e) {\n-                    \/\/ OK\n-                }\n+                test13(new MyValue13Holder());\n@@ -604,8 +597,1 @@\n-                MyValue15Holder holder = new MyValue15Holder();\n-                try {\n-                    test15(holder);\n-\/\/ TODO 8325106\n-\/\/                    Asserts.fail(\"Should have thrown InstantiationError\");\n-                } catch (InstantiationError e) {\n-                    \/\/ OK\n-                }\n+                test15(new MyValue15Holder());\n@@ -642,7 +628,1 @@\n-                try {\n-                    test16(false);\n-\/\/ TODO 8325106\n-\/\/                    Asserts.fail(\"Should have thrown IncompatibleClassChangeError\");\n-                } catch (IncompatibleClassChangeError e) {\n-                    \/\/ OK\n-                }\n+                test16(false);\n@@ -675,7 +655,1 @@\n-                try {\n-                    test17(false);\n-\/\/ TODO 8325106\n-\/\/                    Asserts.fail(\"Should have thrown IncompatibleClassChangeError\");\n-                } catch (IncompatibleClassChangeError e) {\n-                    \/\/ OK\n-                }\n+                test17(false);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":4,"deletions":30,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -819,1 +819,1 @@\n-com\/sun\/jdi\/EATests.java 8331766 generic-all\n+com\/sun\/jdi\/EATests.java#id0 8331766 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}