{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -228,1 +229,2 @@\n-                              Constable {\n+                              Constable,\n+                              RuntimeType<T> {\n@@ -718,0 +720,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n@@ -4197,1 +4211,1 @@\n-        if (obj != null && !isInstance(obj))\n+        if (!canCast(obj))\n@@ -4206,0 +4220,14 @@\n+    \/**\n+     * Tests whether a cast to this class or interface will succeed.\n+     *\/\n+    public boolean canCast(Object obj) {\n+        return obj == null || isInstance(obj);\n+    }\n+\n+    \/**\n+     * Returns this {@code Class}.\n+     *\/\n+    public Class<T> baseClass() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -119,0 +120,13 @@\n+    \/**\n+     * Returns a {@link RuntimeType} for the null-restricted type of {@code cls}.\n+     *\n+     * @param lookup unused\n+     * @param name unused\n+     * @param type the required result type (must be {@code RuntimeType.class})\n+     * @param cls the class, interface, or array type to be null-restricted\n+     * @return the null-restricted {@code RuntimeType}\n+     *\/\n+    public static RuntimeType<?> nullRestrictedClass(MethodHandles.Lookup lookup, String name, Class<?> type, Class<?> cls) {\n+        return RuntimeType.nullRestricted(cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,0 +129,7 @@\n+\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    public static final int ACC_NON_ATOMIC = 0x0002;\n@@ -127,0 +128,7 @@\n+    \/** Flag is set for a class symbol if it defines one or more non-empty\n+     *  instance initializer block(s). This is relevenat only for class symbols\n+     *  that originate from source types. For binary types the instance initializer\n+     *  blocks are \"normalized\" into the constructors.\n+     *\/\n+    public static final int HASINITBLOCK         = 1<<18; \/\/ ClassSymbols\n+\n@@ -428,0 +436,5 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    public static final int IMPLICIT    = 1<<59; \/\/ MethodSymbols\n+\n@@ -451,0 +464,1 @@\n+        ImplicitConstructorFlags          = PUBLIC | IMPLICIT,\n@@ -464,1 +478,1 @@\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -491,0 +505,1 @@\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n@@ -531,0 +546,1 @@\n+        HASINITBLOCK(Flags.HASINITBLOCK),\n@@ -538,0 +554,1 @@\n+        IMPLICIT(Flags.IMPLICIT),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+        res.append(nullMarker(t));\n@@ -193,0 +194,4 @@\n+    private String nullMarker(Type t) {\n+        return t.getNullMarker().typeSuffix();\n+    }\n+\n@@ -235,0 +240,1 @@\n+            buf.append(nullMarker(t));\n@@ -238,0 +244,1 @@\n+            buf.append(nullMarker(t));\n@@ -288,1 +295,1 @@\n-        return s;\n+        return s + nullMarker(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+        NULL_RESTRICTED_TYPES(JDK23, Fragments.FeatureNullRestrictedTypes, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,0 +359,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n@@ -474,0 +482,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1334,0 +1348,2 @@\n+        private boolean hasImplicitConstructor = false;\n+\n@@ -1699,0 +1715,29 @@\n+\n+        public boolean hasImplicitConstructor() {\n+            if (hasImplicitConstructor) {\n+                return true;\n+            } else {\n+                if (getImplicitConstructor() != null) {\n+                    hasImplicitConstructor = true;\n+                }\n+                return hasImplicitConstructor;\n+            }\n+        }\n+\n+        public void implicitConstructorFound() {\n+            hasImplicitConstructor = true;\n+        }\n+\n+        private MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isConstructor()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+    public final Type looselyConsistentValueType;\n+    public final Type reflectArrayType;\n@@ -658,0 +660,3 @@\n+        \/\/ for value objects\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n+        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -242,0 +243,4 @@\n+    public boolean hasImplicitConstructor() {\n+        return false;\n+    }\n+\n@@ -541,0 +546,1 @@\n+        sb.append(getNullMarker().typeSuffix());\n@@ -745,0 +751,18 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == getNullMarker()) return this;\n+        Type base = dropMetadata(TypeMetadata.NullMarker.class);\n+        return (nullMarker == NullMarker.UNSPECIFIED) ?\n+                base :\n+                base.addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+    }\n+\n+    public NullMarker getNullMarker() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null ?\n+                nm.nullMarker() : NullMarker.UNSPECIFIED;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1106,0 +1130,2 @@\n+            buf.append(getNullMarker().typeSuffix());\n+\n@@ -1115,1 +1141,2 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                \/\/ invoking sym.flags() below can provoke symbol completion\n+                if (sym.name.isEmpty() && (sym.flags_field & COMPOUND) != 0) {\n@@ -1187,0 +1214,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n+        }\n+\n@@ -1418,0 +1450,1 @@\n+                sb.append(t.getNullMarker().typeSuffix());\n@@ -2174,0 +2207,3 @@\n+                if (types.isParametric(qtype)) {\n+                    bound2 = bound2.asNullMarked(bound.getNullMarker());\n+                }\n@@ -2178,1 +2214,2 @@\n-                    if (types.isSameType(b, bound2)) return;\n+                    if (b.getNullMarker() == bound2.getNullMarker() &&\n+                            types.isSameType(b, bound2)) return;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -106,0 +107,4 @@\n+    \/* are nullable and null-restricted types allowed? *\/\n+    private boolean allowNullRestrictedTypes;\n+    private boolean tvarUnspecifiedNullity;\n+\n@@ -131,0 +136,3 @@\n+        Preview preview = Preview.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -133,0 +141,1 @@\n+        tvarUnspecifiedNullity = options.isSet(\"tvarUnspecifiedNullity\");\n@@ -1029,0 +1038,1 @@\n+                boolean result;\n@@ -1030,1 +1040,1 @@\n-                    return isSameType(elemtype(t), elemtype(s));\n+                    result = isSameType(elemtype(t), elemtype(s));\n@@ -1032,1 +1042,4 @@\n-                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    result = isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                }\n+                if (result && allowNullRestrictedTypes && hasNarrowerNullability(s, t)) {\n+                    warn.warn(LintCategory.NULL);\n@@ -1034,1 +1047,2 @@\n-            } else if (isSubtype(t, s, capture)) {\n+                return result;\n+            } else if (isSubtype(t, s, capture, warn)) {\n@@ -1084,0 +1098,8 @@\n+    public boolean isSubtype(Type t, Type s, boolean capture, Warner warner) {\n+        try {\n+            pushWarner(warner);\n+            return isSubtype(t, s, capture);\n+        } finally {\n+            popWarner();\n+        }\n+    }\n@@ -1085,1 +1107,4 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            if (allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                warnStack.head.warn(LintCategory.NULL);\n+            }\n@@ -1087,0 +1112,1 @@\n+        }\n@@ -1127,1 +1153,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (isNonNullable(s)) {\n+                         return false;\n+                     }\n@@ -1129,2 +1158,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1195,1 +1225,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1200,0 +1230,4 @@\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1204,0 +1238,1 @@\n+                boolean result = false;\n@@ -1206,1 +1241,1 @@\n-                        return isSameType(t.elemtype, elemtype(s));\n+                        result = isSameType(t.elemtype, elemtype(s));\n@@ -1208,1 +1243,1 @@\n-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                        result = isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1211,1 +1246,1 @@\n-                if (s.hasTag(CLASS)) {\n+                if (!result && s.hasTag(CLASS)) {\n@@ -1213,1 +1248,1 @@\n-                    return sname == names.java_lang_Object\n+                    result = sname == names.java_lang_Object\n@@ -1218,1 +1253,5 @@\n-                return false;\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+\n+                return result;\n@@ -1359,1 +1398,4 @@\n-                if (t.equalsIgnoreMetadata(s))\n+                if (t.equalsIgnoreMetadata(s)) {\n+                    if (allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                        warnStack.head.warn(LintCategory.NULL);\n+                    }\n@@ -1361,0 +1403,1 @@\n+                }\n@@ -1427,3 +1470,7 @@\n-                return t.tsym == s.tsym\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                boolean equal = t.tsym == s.tsym\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                if (equal && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return equal;\n@@ -1434,8 +1481,13 @@\n-                if (t == s)\n-                    return true;\n-\n-                if (s.isPartial())\n-                    return visit(s, t);\n-\n-                return s.hasTag(ARRAY)\n-                    && containsTypeEquivalent(t.elemtype, elemtype(s));\n+                boolean result;\n+                if (t == s) {\n+                    result = true;\n+                } else if (s.isPartial()) {\n+                    result = visit(s, t);\n+                } else {\n+                    result = s.hasTag(ARRAY) &&\n+                            containsTypeEquivalent(t.elemtype, elemtype(s));\n+                }\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1743,1 +1795,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !isNonNullable(t)))\n@@ -2153,0 +2205,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -2338,0 +2400,4 @@\n+                            } else if (baseParams.length() != ownerParams.length()) {\n+                                \/\/ rare type, recovery\n+                                return subst(sym.type, ownerParams,\n+                                        baseParams.map(ta -> ta.asNullMarked(NullMarker.UNSPECIFIED)));\n@@ -2339,1 +2405,9 @@\n-                                return subst(sym.type, ownerParams, baseParams);\n+                                ListBuffer<Type> newBaseParams = new ListBuffer<>();\n+                                for (Type tvar : ownerParams) {\n+                                    Type baseParam = isParametric(tvar) ?\n+                                            baseParams.head :\n+                                            baseParams.head.asNullMarked(NullMarker.UNSPECIFIED);\n+                                    newBaseParams.add(baseParam);\n+                                    baseParams = baseParams.tail;\n+                                }\n+                                return subst(sym.type, ownerParams, newBaseParams.toList());\n@@ -2436,1 +2510,1 @@\n-                            return s.dropMetadata(Annotations.class);\n+                            return s.dropMetadata(Annotations.class).dropMetadata(TypeMetadata.NullMarker.class);\n@@ -2481,1 +2555,7 @@\n-        };\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n+            Type erased = super.visitArrayType(t, aBoolean);\n+            return combineMetadata(erased, t);\n+        }\n+    };\n@@ -2824,1 +2904,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -3987,0 +4076,1 @@\n+        NullMarker nullMarker = NullMarker.NOT_NULL;\n@@ -3991,0 +4081,3 @@\n+            if (t.getNullMarker().ordinal() > nullMarker.ordinal()) {\n+                nullMarker = t.getNullMarker();\n+            }\n@@ -4040,1 +4133,2 @@\n-            return new ArrayType(lub(elements), syms.arrayClass);\n+            return new ArrayType(lub(elements), syms.arrayClass)\n+                    .asNullMarked(nullMarker);\n@@ -4075,1 +4169,2 @@\n-            return compoundMin(candidates);\n+            return compoundMin(candidates)\n+                    .asNullMarked(nullMarker);\n@@ -4127,1 +4222,4 @@\n-        else if (t.isPrimitive() || s.isPrimitive())\n+\n+        final NullMarker nullMarker = t.getNullMarker().ordinal() < s.getNullMarker().ordinal() ?\n+                    t.getNullMarker() : s.getNullMarker();\n+        if (t.isPrimitive() || s.isPrimitive())\n@@ -4130,1 +4228,1 @@\n-            return t;\n+            return t.asNullMarked(nullMarker);\n@@ -4132,1 +4230,1 @@\n-            return s;\n+            return s.asNullMarked(nullMarker);\n@@ -4135,1 +4233,1 @@\n-        return glbFlattened(closure, t);\n+        return glbFlattened(closure, t).asNullMarked(nullMarker);\n@@ -5195,0 +5293,4 @@\n+                    NullMarker nullMarker = type.getNullMarker();\n+                    if (nullMarker != NullMarker.UNSPECIFIED) {\n+                        append(nullMarker.typeSuffix().charAt(0));\n+                    }\n@@ -5201,0 +5303,4 @@\n+                    NullMarker nmArray = at.getNullMarker();\n+                    if (nmArray != NullMarker.UNSPECIFIED) {\n+                        append(nmArray.typeSuffix().charAt(0));\n+                    }\n@@ -5240,0 +5346,8 @@\n+                    if (Types.this.isDeclaredParametric(type)) {\n+                        append('=');\/\/ '*' is already used for wildcards\n+                    } else {\n+                        NullMarker nmTV = type.getNullMarker();\n+                        if (nmTV != NullMarker.UNSPECIFIED) {\n+                            append(nmTV.typeSuffix().charAt(0));\n+                        }\n+                    }\n@@ -5341,0 +5455,45 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+\n+    public boolean isNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC ||\n+                (type.hasTag(TYPEVAR) && type.getNullMarker() == NullMarker.UNSPECIFIED && !tvarUnspecifiedNullity);\n+    }\n+\n+    public boolean isDeclaredParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified(Type type) {\n+        return type.getNullMarker() == NullMarker.UNSPECIFIED &&\n+                (!type.hasTag(TYPEVAR) || tvarUnspecifiedNullity);\n+    }\n+\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return true;\n+        }\n+        return t.getNullMarker() == s.getNullMarker();\n+    }\n+\n+    \/**\n+     * Does t have narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return false;\n+        }\n+        return t.getNullMarker().ordinal() < s.getNullMarker().ordinal();\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":195,"deletions":36,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -186,0 +187,3 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        allowNullRestrictedTypesForValueClassesOnly = options.isSet(\"allowNullRestrictedTypesForValueClassesOnly\");\n@@ -215,0 +219,8 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n+    \/** Are null-restricted types allowed for value classes only\n+     *\/\n+    private final boolean allowNullRestrictedTypesForValueClassesOnly;\n+\n@@ -330,1 +342,3 @@\n-                v.owner.isValueClass() &&\n+                \/\/ it is OK, in value classes, instance initializer blocks will go after super() anyways\n+                ((v.owner.isValueClass() && !env.info.instanceInitializerBlock) ||\n+                        types.isNonNullable(v.type)) &&\n@@ -753,0 +767,4 @@\n+        if (allowNullRestrictedTypes && tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1187,0 +1205,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1358,0 +1384,14 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if (allowNullRestrictedTypesForValueClassesOnly &&\n+                        ((types.isNonNullable(result) || types.isNonNullable(elemOrType)) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor()))) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -1457,0 +1497,3 @@\n+                if (tree.stats.size() > 0) {\n+                    env.info.scope.owner.flags_field |= HASINITBLOCK;\n+                }\n@@ -2939,1 +2982,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2941,0 +2984,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3123,0 +3170,1 @@\n+            List<NullMarker> nullMarkers = tree.nullMarkers.reverse();\n@@ -3125,1 +3173,3 @@\n-                owntype = new ArrayType(owntype, syms.arrayClass);\n+                owntype = new ArrayType(owntype, syms.arrayClass)\n+                        .asNullMarked(nullMarkers.head);\n+                nullMarkers = nullMarkers.tail;\n@@ -4404,0 +4454,10 @@\n+        \/\/ check nullness of site\n+        if (types.isNullable(site)) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (types.isParametric(site)) {\n+            \/\/ see JDK-8339087\n+            \/\/chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4713,0 +4773,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5359,0 +5424,5 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes && env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5540,0 +5610,1 @@\n+                chk.checkConstraintsOfValueClassesWithImplicitConst((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2204,1 +2204,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableField(sym));\n@@ -2213,0 +2214,14 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (types.isNonNullable(sym.type) || types.isParametric(sym.type)));\n+        }\n+\n+        boolean isUninitializedNonNullableField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            types.isNonNullable(sym.type));\n+        }\n+\n@@ -2301,0 +2316,8 @@\n+                if (isUninitializedNonNullableField(sym)) {\n+                    if (types.isNonNullable(sym.type)) {\n+                        log.error(pos, Errors.NonNullableShouldBeInitialized);\n+                    } else {\n+                        \/\/ see JDK-8339087\n+                        \/\/log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                    }\n+                } else {\n@@ -2302,0 +2325,1 @@\n+                }\n@@ -2552,1 +2576,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1473,1 +1473,4 @@\n-                return filterBounds(uv, inferenceContext).head;\n+                Infer infer = inferenceContext.infer;\n+                List<Type> eqbounds = filterBounds(uv, inferenceContext);\n+                return eqbounds.tail.tail == null  ?\n+                        eqbounds.head : infer.types.lub(eqbounds);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    private final boolean allowNullRestrictedTypes;\n@@ -146,0 +147,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -4268,0 +4271,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4269,1 +4274,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4271,0 +4277,2 @@\n+            noOfDims++;\n+        }\n@@ -4272,1 +4280,26 @@\n-        result = tree;\n+        if (!allowNullRestrictedTypes || tree.elemtype == null || !types.isNonNullable(originalElemType.type)) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -183,0 +184,21 @@\n+    JCExpression generateNullCheckIfNeeded(JCExpression tree) {\n+        if (expectedNullness == NullMarker.NOT_NULL && !types.isNonNullable(tree.type)) {\n+            return attr.makeNullCheck(tree);\n+        }\n+        return tree;\n+    }\n+\n+    \/** Translate method argument list, casting each argument\n+     *  to its corresponding type in a list of target types.\n+     *  @param _args               The method argument list.\n+     *  @param parameters          The list of target types.\n+     *  @param varargsElement      The erasure of the varargs element type,\n+     *                             or null if translating a non-varargs invocation\n+     *\/\n+    <T extends JCTree> List<T> translateArgs(List<T> _args,\n+                                             List<Type> parameters,\n+                                             Type varargsElement) {\n+        return translateArgs(_args, parameters, parameters.map(t -> NullMarker.UNSPECIFIED),\n+                varargsElement, NullMarker.UNSPECIFIED);\n+    }\n+\n@@ -185,4 +207,6 @@\n-     *  @param _args            The method argument list.\n-     *  @param parameters       The list of target types.\n-     *  @param varargsElement   The erasure of the varargs element type,\n-     *  or null if translating a non-varargs invocation\n+     *  @param _args                      The method argument list.\n+     *  @param parameters                 The list of target types (after erasure).\n+     *  @param paramsNullMarkers          The list of null markers of the target types\n+     *  @param varargsElement             The erasure of the varargs element type,\n+     *                                    or null if translating a non-varargs invocation\n+     *  @param varargsElementNullMarker   The null marker of the varargs element type\n@@ -192,1 +216,3 @@\n-                                           Type varargsElement) {\n+                                           List<NullMarker> paramsNullMarkers,\n+                                           Type varargsElement,\n+                                           NullMarker varargsElementNullMarker) {\n@@ -196,1 +222,1 @@\n-            args.head = translate(args.head, parameters.head);\n+            args.head = translate(args.head, parameters.head, paramsNullMarkers.head);\n@@ -199,0 +225,1 @@\n+            paramsNullMarkers = paramsNullMarkers.tail;\n@@ -204,1 +231,1 @@\n-                args.head = translate(args.head, varargsElement);\n+                args.head = translate(args.head, varargsElement, varargsElementNullMarker);\n@@ -208,1 +235,1 @@\n-            args.head = translate(args.head, parameter);\n+            args.head = translate(args.head, parameter, paramsNullMarkers.head);\n@@ -444,0 +471,2 @@\n+    private NullMarker expectedNullness = NullMarker.UNSPECIFIED;\n+\n@@ -447,0 +476,4 @@\n+        return translate(tree, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> T translate(T tree, Type pt, NullMarker expectedNullness) {\n@@ -448,0 +481,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -450,0 +484,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -453,0 +488,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -459,0 +495,4 @@\n+        return translate(trees, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> List<T> translate(List<T> trees, Type pt, NullMarker expectedNullness) {\n@@ -460,0 +500,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -463,0 +504,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -466,0 +508,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -495,1 +538,1 @@\n-        tree.init = translate(tree.init, tree.sym.erasure(types));\n+        tree.init = translate(tree.init, tree.sym.erasure(types), tree.type.getNullMarker());\n@@ -860,0 +903,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -890,0 +934,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -920,0 +965,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -939,0 +985,2 @@\n+        List<NullMarker> paramsNullMarkers = meth.type.getParameterTypes().map(t->t.getNullMarker());\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -943,1 +991,3 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym) {\n+            \/\/ this is special case code only for j.l.Enum constructor and will effectively\n+            \/\/ set the argtypes to an empty list making the invocation to translateArgs a no-op\n@@ -945,0 +995,1 @@\n+        }\n@@ -952,1 +1003,1 @@\n-        tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);\n+        tree.args = translateArgs(tree.args, argtypes, paramsNullMarkers, tree.varargsElement, varargsElementNullMarker);\n@@ -957,0 +1008,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -978,0 +1030,1 @@\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -981,1 +1034,1 @@\n-            tree.args, argtypes, tree.varargsElement);\n+            tree.args, argtypes, tree.constructor.type.getParameterTypes().map(t->t.getNullMarker()), tree.varargsElement, varargsElementNullMarker);\n@@ -1003,1 +1056,1 @@\n-        tree.expr = translate(tree.expr, pt);\n+        tree.expr = translate(tree.expr, pt, expectedNullness);\n@@ -1009,0 +1062,3 @@\n+        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs);\n+        }\n@@ -1013,0 +1069,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1045,0 +1102,3 @@\n+        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n+            tree.expr = attr.makeNullCheck(tree.expr);\n+        }\n@@ -1067,0 +1127,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1081,0 +1142,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1103,0 +1165,1 @@\n+            result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1125,1 +1188,2 @@\n-            result = retype(tree, tree.sym.erasure(types), pt);\n+            result = generateNullCheckIfNeeded(tree);\n+            result = retype((JCExpression) result, tree.sym.erasure(types), pt);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -44,0 +45,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -60,0 +62,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -70,0 +71,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -571,0 +573,5 @@\n+        case '?': case '!' : case '=':\n+            char nmChar = (char)signature[sigp];\n+            sigp++;\n+            Type t = sigToType();\n+            return t == Type.noType ? t : t.asNullMarked(nmChar == '=' ? NullMarker.PARAMETRIC : NullMarker.of(String.valueOf(nmChar)));\n@@ -590,1 +597,0 @@\n-\n@@ -1078,1 +1084,0 @@\n-\n@@ -1359,0 +1364,30 @@\n+            new AttributeReader(names.ImplicitCreation, V66, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (((ClassSymbol)sym).hasImplicitConstructor()) { \/\/ there can only be one per class\n+                        throw badClassFile(\"attribute.must.be.unique\", names.ImplicitCreation);\n+                    }\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        ((ClassSymbol)sym).implicitConstructorFound();\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    \/\/ there is no point on setting the nullness or not has it will be set while parsing the signature\n+                }\n+            },\n@@ -2567,1 +2602,0 @@\n-\n@@ -2691,0 +2725,11 @@\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n+            flags &= ~STATIC;\n+            type = new MethodType(type.getParameterTypes(),\n+                    syms.voidType,\n+                    type.getThrownTypes(),\n+                    syms.methodClass);\n+            if (((ClassSymbol)currentOwner).hasImplicitConstructor() && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n+        }\n@@ -3312,0 +3357,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -3602,0 +3649,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        \/*if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }*\/\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && types.isNonNullable(symbol.type);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":101,"deletions":3,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -84,0 +85,4 @@\n+    \/** Switch: are null-restricted types allowed\n+     *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -144,0 +149,2 @@\n+    private final Symtab syms;\n+\n@@ -178,0 +185,1 @@\n+        syms = Symtab.instance(context);\n@@ -193,0 +201,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -367,0 +377,1 @@\n+             nullMarkersScanner.visit(sym.type, null) ||\n@@ -377,0 +388,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -380,0 +394,47 @@\n+    NullMarkersScanner nullMarkersScanner = new NullMarkersScanner();\n+    \/* we don't need to scan generic \/ parameterized types as we will be generating a signature for them anyways\n+     *\/\n+    class NullMarkersScanner extends Types.SimpleVisitor<Boolean, Void> {\n+\n+        @Override\n+        public Boolean visitType(Type t, Void ignore) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitClassType(ClassType t, Void ignore) {\n+            if (!t.isParameterized()) {\n+                if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitArrayType(ArrayType t, Void ignore) {\n+            if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                return true;\n+            }\n+            return visit(t.elemtype, ignore);\n+        }\n+\n+        @Override\n+        public Boolean visitMethodType(MethodType t, Void ignore) {\n+            for (Type arg : t.argtypes) {\n+                if (visit(arg, ignore)) {\n+                    return true;\n+                }\n+            }\n+            for (Type param : t.allparams()) {\n+                if (visit(param, ignore)) {\n+                    return true;\n+                }\n+            }\n+            if (visit(t.restype, ignore)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -948,0 +1009,27 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (allowNullRestrictedTypes && csym.isValueClass() && csym.hasImplicitConstructor()) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = \/*ACC_DEFAULT |*\/ (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (allowNullRestrictedTypes && sym.kind == VAR && types.isNonNullable(sym.type) && !sym.type.hasTag(ARRAY)) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            if (preview.isPreview(Source.Feature.VALUE_CLASSES)) {\n+                preview.markUsesPreview(null);\n+            }\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -1302,0 +1390,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                break;\n@@ -1733,0 +1825,4 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -208,0 +209,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -234,0 +237,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -279,0 +284,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -289,0 +298,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -296,0 +306,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -314,1 +325,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -318,1 +329,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -1244,1 +1255,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (allowNullRestrictedTypes && token.kind == QUES) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1558,0 +1580,5 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1572,0 +1599,5 @@\n+                            Token nullMarker = null;\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                nullMarker = token;\n+                                nextToken();\n+                            }\n@@ -1574,0 +1606,3 @@\n+                            if (nullMarker != null) {\n+                                setNullMarker(t, nullMarker);\n+                            }\n@@ -1814,1 +1849,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1823,0 +1863,4 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1901,0 +1945,17 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        checkSourceLevel(Feature.NULL_RESTRICTED_TYPES);\n+        ((JCNullableTypeExpression)exp).setNullMarker(nullMarker(tk));\n+    }\n+\n+    NullMarker nullMarker(Token tk) {\n+        return tk.kind == QUES ?\n+                NullMarker.NULLABLE :\n+                tk.kind == BANG ?\n+                        NullMarker.NOT_NULL :\n+                        NullMarker.PARAMETRIC;\n+    }\n+\n@@ -1965,1 +2026,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -2033,0 +2094,15 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2055,0 +2131,1 @@\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2057,0 +2134,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2059,0 +2137,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2077,0 +2161,1 @@\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2136,0 +2221,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG || (t == QUES && !isMode(NOQUES)) || t == STAR;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2498,0 +2587,5 @@\n+        Token nullMarker = null;\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            nullMarker = token;\n+            nextToken();\n+        }\n@@ -2500,0 +2594,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2597,0 +2694,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -2616,0 +2717,5 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                setNullMarker(t);\n+                nextToken();\n+            }\n+\n@@ -2712,0 +2818,1 @@\n+            ListBuffer<NullMarker> nullMarkers = new ListBuffer<>();\n@@ -2719,0 +2826,6 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                nullMarkers.add(nullMarker(token));\n+                nextToken();\n+            } else {\n+                nullMarkers.add(NullMarker.UNSPECIFIED);\n+            }\n@@ -2720,1 +2833,2 @@\n-                    || token.kind == MONKEYS_AT) {\n+                    || token.kind == MONKEYS_AT ||\n+                    (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind))) {\n@@ -2724,1 +2838,6 @@\n-                if (token.kind == RBRACKET) { \/\/ no dimension\n+                if (token.kind == RBRACKET) {\n+                    Token nullMarker = null;\n+                    if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        nullMarker = token;\n+                        nextToken();\n+                    }\n@@ -2726,0 +2845,3 @@\n+                    if (nullMarker != null) {\n+                        setNullMarker(elemtype, nullMarker);\n+                    }\n@@ -2730,0 +2852,6 @@\n+                    if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        nullMarkers.add(nullMarker(token));\n+                        nextToken();\n+                    } else {\n+                        nullMarkers.add(NullMarker.UNSPECIFIED);\n+                    }\n@@ -2740,1 +2868,1 @@\n-            JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));\n+            JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems, nullMarkers.toList()));\n@@ -2743,0 +2871,2 @@\n+            Assert.check(dims.length() == nullMarkers.length(), na);\n+\n@@ -3419,0 +3549,13 @@\n+                    } else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3433,0 +3576,2 @@\n+                case BANG:\n+                    if (allowNullRestrictedTypes && !peekToken(lookahead, LPAREN)) break;\n@@ -3619,0 +3764,4 @@\n+                if (isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3894,0 +4043,7 @@\n+        if (name == names.implicit) {\n+            if (allowValueClasses) {\n+                return Source.JDK23;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -5043,0 +5199,19 @@\n+\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":183,"deletions":8,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -3259,0 +3259,3 @@\n+compiler.misc.feature.null.restricted.types=\\\n+    nullable and null restricted types\n+\n@@ -4138,0 +4141,28 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n@@ -4165,0 +4196,48 @@\n+\n+### null-restricted types\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+compiler.err.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -1958,0 +1959,1 @@\n+        public List<NullMarker> nullMarkers;\n@@ -1960,2 +1962,3 @@\n-                           List<JCExpression> dims,\n-                           List<JCExpression> elems)\n+                             List<JCExpression> dims,\n+                             List<JCExpression> elems,\n+                             List<NullMarker> nullMarkers)\n@@ -1967,0 +1970,1 @@\n+            this.nullMarkers = nullMarkers;\n@@ -2560,1 +2564,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2697,1 +2701,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2806,1 +2810,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2831,1 +2835,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2889,0 +2893,45 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public JCNullableTypeExpression setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+            return this;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+\n+            public static NullMarker of(String typeSuffix) {\n+                return switch (typeSuffix) {\n+                    case \"!\" -> NOT_NULL;\n+                    case \"?\" -> NULLABLE;\n+                    case \"*\" -> PARAMETRIC;\n+                    case \"\" -> UNSPECIFIED;\n+                    default -> throw new AssertionError(\"invalid type suffix\");\n+                };\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+                if (!(tree instanceof JCArrayTypeTree) &&\n+                        tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n@@ -1558,0 +1562,1 @@\n+                print(((JCArrayTypeTree)elem).getNullMarker().typeSuffix());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -288,0 +288,6 @@\n+                void addValue(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.VALUE)) {\n+                        list.add(\"value\");\n+                    }\n+                }\n+\n@@ -299,0 +305,1 @@\n+                    addValue(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+\n@@ -229,0 +230,10 @@\n+\n+#nullable types\n+compiler.misc.feature.null.restricted.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.misc.attribute.must.be.unique                                   # bad class file\n+compiler.misc.attribute.not.applicable.to.field.type                     # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,17 @@\n+NullabilityInferenceTest.java:23:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:24:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:25:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:26:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:34:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:35:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:36:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:37:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:46:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:47:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:48:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+- compiler.note.unchecked.filename: NullabilityInferenceTest.java\n+- compiler.note.unchecked.recompile\n+- compiler.note.preview.filename: NullabilityInferenceTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityInferenceTest.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -65,0 +67,1 @@\n+\n@@ -881,1 +884,1 @@\n-        assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+        \/*assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n@@ -890,1 +893,1 @@\n-        );\n+        );*\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}