{"files":[{"patch":"@@ -60,0 +60,1 @@\n+import java.security.Permissions;\n@@ -61,0 +62,1 @@\n+import java.security.ProtectionDomain;\n@@ -75,0 +77,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -142,1 +145,2 @@\n- * class or interface (or for {@code void}) using a <i>class literal<\/i>.\n+ * class or interface (or for {@code void}) using a <dfn>class literal<\/dfn>\n+ * (JLS {@jls 15.8.2}).\n@@ -146,1 +150,1 @@\n- * System.out.println(\"The name of class Foo is: \"+Foo.class.getName());\n+ * System.out.println(\"The name of class Foo is: \" + Foo.class.getName()); \/\/ @highlight substring=\"Foo.class\"\n@@ -152,1 +156,1 @@\n- * is situated in a <em>nest<\/em>. A <a id=\"nest\">nest<\/a> is a set of\n+ * is situated in a <dfn>{@index \"nest\"}<\/dfn>. A <a id=\"nest\">nest<\/a> is a set of\n@@ -155,1 +159,2 @@\n- * The classes and interfaces are known as <em>nestmates<\/em>.\n+ * The classes and interfaces are known as <dfn>{@index \"nestmates\"}<\/dfn>\n+ * (JVMS {@jvms 4.7.29}).\n@@ -157,1 +162,1 @@\n- * <em>nest host<\/em>, and enumerates the other nestmates which\n+ * <dfn>nest host<\/dfn> (JVMS {@jvms 4.7.28}), and enumerates the other nestmates which\n@@ -169,1 +174,1 @@\n- * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <em>hidden<\/em>}\n+ * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <dfn>hidden<\/dfn>}\n@@ -218,1 +223,0 @@\n- * @jls 15.8.2 Class Literals\n@@ -1165,2 +1169,2 @@\n-    \/\/ Set by VM\n-    private transient Object classData;\n+    private transient Object classData; \/\/ Set by VM\n+    private transient Object[] signers; \/\/ Read by VM, mutable\n@@ -1300,1 +1304,1 @@\n-     * @jls 6.7 Fully Qualified Names\n+     * @jls 6.7 Fully Qualified Names and Canonical Names\n@@ -1514,1 +1518,1 @@\n-     * @jls 9.1.1. Interface Modifiers\n+     * @jls 9.1.1 Interface Modifiers\n@@ -1575,1 +1579,5 @@\n-    public native Object[] getSigners();\n+\n+    public Object[] getSigners() {\n+        var signers = this.signers;\n+        return signers == null ? null : signers.clone();\n+    }\n@@ -1580,1 +1588,5 @@\n-    native void setSigners(Object[] signers);\n+    void setSigners(Object[] signers) {\n+        if (!isPrimitive() && !isArray()) {\n+            this.signers = signers;\n+        }\n+    }\n@@ -2050,1 +2062,1 @@\n-     * @jls 14.3 Local Class Declarations\n+     * @jls 14.3 Local Class and Interface Declarations\n@@ -2063,1 +2075,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n@@ -2600,1 +2612,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n@@ -3278,4 +3290,0 @@\n-\n-    \/** protection domain returned when the internal domain is null *\/\n-    private static java.security.ProtectionDomain allPermDomain;\n-\n@@ -3302,1 +3310,1 @@\n-    public java.security.ProtectionDomain getProtectionDomain() {\n+    public ProtectionDomain getProtectionDomain() {\n@@ -3311,0 +3319,10 @@\n+    \/** Holder for the protection domain returned when the internal domain is null *\/\n+    private static class Holder {\n+        private static final ProtectionDomain allPermDomain;\n+        static {\n+            Permissions perms = new Permissions();\n+            perms.add(SecurityConstants.ALL_PERMISSION);\n+            allPermDomain = new ProtectionDomain(null, perms);\n+        }\n+    }\n+\n@@ -3312,2 +3330,2 @@\n-    java.security.ProtectionDomain protectionDomain() {\n-        java.security.ProtectionDomain pd = getProtectionDomain0();\n+    ProtectionDomain protectionDomain() {\n+        ProtectionDomain pd = getProtectionDomain0();\n@@ -3315,8 +3333,3 @@\n-            if (allPermDomain == null) {\n-                java.security.Permissions perms =\n-                    new java.security.Permissions();\n-                perms.add(SecurityConstants.ALL_PERMISSION);\n-                allPermDomain =\n-                    new java.security.ProtectionDomain(null, perms);\n-            }\n-            pd = allPermDomain;\n+            return Holder.allPermDomain;\n+        } else {\n+            return pd;\n@@ -3324,1 +3337,0 @@\n-        return pd;\n@@ -3330,1 +3342,1 @@\n-    private native java.security.ProtectionDomain getProtectionDomain0();\n+    private native ProtectionDomain getProtectionDomain0();\n@@ -4717,1 +4729,1 @@\n-            return \"[\" + componentType.descriptorString();\n+            return \"[\".concat(componentType.descriptorString());\n@@ -4730,5 +4742,1 @@\n-            return new StringBuilder(name.length() + 2)\n-                    .append('L')\n-                    .append(name)\n-                    .append(';')\n-                    .toString();\n+            return StringConcatHelper.concat(\"L\", name, \";\");\n@@ -4787,1 +4795,1 @@\n-                            : Optional.of(ClassDesc.ofDescriptor(descriptorString()));\n+                            : Optional.of(ConstantUtils.classDesc(this));\n@@ -4797,0 +4805,1 @@\n+     * @see Class##hiddenClasses Hidden Classes\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":49,"deletions":40,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -116,1 +117,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,4 +54,30 @@\n-    \/** The modifier {@code public} *\/          PUBLIC,\n-    \/** The modifier {@code protected} *\/       PROTECTED,\n-    \/** The modifier {@code private} *\/         PRIVATE,\n-    \/** The modifier {@code abstract} *\/        ABSTRACT,\n+    \/**\n+     * The modifier {@code public}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PUBLIC,\n+\n+    \/**\n+     * The modifier {@code protected}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PROTECTED,\n+\n+    \/**\n+     * The modifier {@code private}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PRIVATE,\n+\n+    \/**\n+     * The modifier {@code abstract}\n+     *\n+     * @jls 8.1.1.1 {@code abstract} Classes\n+     * @jls 8.4.3.1 {@code abstract} Methods\n+     * @jls 9.1.1.1 {@code abstract} Interfaces\n+     *\/\n+    ABSTRACT,\n+\n@@ -60,0 +86,2 @@\n+     *\n+     * @jls 9.4 Method Declarations\n@@ -63,1 +91,10 @@\n-    \/** The modifier {@code static} *\/          STATIC,\n+\n+    \/**\n+     * The modifier {@code static}\n+     *\n+     * @jls 8.1.1.4 {@code static} Classes\n+     * @jls 8.3.1.1 {@code static} Fields\n+     * @jls 8.4.3.2 {@code static} Methods\n+     * @jls 9.1.1.3 {@code static} Interfaces\n+     *\/\n+    STATIC,\n@@ -67,0 +104,3 @@\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 9.1.1.4 {@code sealed} and {@code non-sealed} Interfaces\n@@ -73,0 +113,3 @@\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 9.1.1.4 {@code sealed} and {@code non-sealed} Interfaces\n@@ -93,6 +136,45 @@\n-    \/** The modifier {@code final} *\/           FINAL,\n-    \/** The modifier {@code transient} *\/       TRANSIENT,\n-    \/** The modifier {@code volatile} *\/        VOLATILE,\n-    \/** The modifier {@code synchronized} *\/    SYNCHRONIZED,\n-    \/** The modifier {@code native} *\/          NATIVE,\n-    \/** The modifier {@code strictfp} *\/        STRICTFP;\n+    \/**\n+     * The modifier {@code final}\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 8.3.1.2 {@code final} Fields\n+     * @jls 8.4.3.3 {@code final} Methods\n+     *\/\n+    FINAL,\n+\n+    \/**\n+     * The modifier {@code transient}\n+     *\n+     * @jls 8.3.1.3 {@code transient} Fields\n+     *\/\n+    TRANSIENT,\n+\n+    \/**\n+     * The modifier {@code volatile}\n+     *\n+     * @jls 8.3.1.4 {@code volatile} Fields\n+     *\/\n+    VOLATILE,\n+\n+    \/**\n+     * The modifier {@code synchronized}\n+     *\n+     * @jls 8.4.3.6 {@code synchronized} Methods\n+     *\/\n+    SYNCHRONIZED,\n+\n+    \/**\n+     * The modifier {@code native}\n+     *\n+     * @jls 8.4.3.4 {@code native} Methods\n+     *\/\n+    NATIVE,\n+\n+    \/**\n+     * The modifier {@code strictfp}\n+     *\n+     * @jls 8.1.1.3 {@code strictfp} Classes\n+     * @jls 8.4.3.5 {@code strictfp} Methods\n+     * @jls 9.1.1.2 {@code strictfp} Interfaces\n+     *\/\n+    STRICTFP;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":94,"deletions":12,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -307,1 +307,6 @@\n-    public static final long LAMBDA_METHOD = 1L<<49;\n+    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+\n+    \/**\n+     * Flag that marks a synthetic local capture field in a local\/anon class\n+     *\/\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -207,2 +207,4 @@\n-            sb.append(annos);\n-            sb.append(' ');\n+            for (Attribute.TypeCompound anno : annos) {\n+                sb.append(anno);\n+                sb.append(' ');\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+\n+    \/**\n+      * 24, tbd\n+      *\/\n+    JDK24(\"24\"),\n@@ -211,0 +216,1 @@\n+        case JDK24  -> Target.JDK1_24;\n@@ -359,0 +365,1 @@\n+        case JDK24  -> RELEASE_24;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -530,1 +530,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n@@ -1574,15 +1590,0 @@\n-        public RecordComponent findRecordComponentToRemove(JCVariableDecl var) {\n-            RecordComponent toRemove = null;\n-            for (RecordComponent rc : recordComponents) {\n-                \/* it could be that a record erroneously declares two record components with the same name, in that\n-                 * case we need to use the position to disambiguate, but if we loaded the record from a class file\n-                 * all positions will be -1, in that case we have to ignore the position and match only based on the\n-                 * name\n-                 *\/\n-                if (rc.name == var.name && (var.pos == rc.pos || rc.pos == -1)) {\n-                    toRemove = rc;\n-                }\n-            }\n-            return toRemove;\n-        }\n-\n@@ -1594,3 +1595,10 @@\n-            if (existing != null) {\n-                recordComponents = List.filter(recordComponents, existing);\n-                recordComponents = recordComponents.append(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+            if (existing != null && !recordComponents.isEmpty()) {\n+                ListBuffer<RecordComponent> newRComps = new ListBuffer<>();\n+                for (RecordComponent rcomp : recordComponents) {\n+                    if (existing == rcomp) {\n+                        newRComps.add(rc = new RecordComponent(varSym, existing.ast, existing.isVarargs));\n+                    } else {\n+                        newRComps.add(rcomp);\n+                    }\n+                }\n+                recordComponents = newRComps.toList();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+    public final Type restrictedInternalType;\n@@ -627,0 +628,1 @@\n+        restrictedInternalType = enterSyntheticAnnotation(\"jdk.internal.javac.Restricted+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2402,1 +2402,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2457,4 +2457,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -45,0 +46,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -64,0 +66,2 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n+\n@@ -101,0 +105,1 @@\n+    public final boolean dumpStacktraceOnError;\n@@ -135,0 +140,1 @@\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -650,1 +656,1 @@\n-    public static class FunctionDescriptorLookupError extends RuntimeException {\n+    public static class FunctionDescriptorLookupError extends CompilerInternalException {\n@@ -655,1 +661,2 @@\n-        FunctionDescriptorLookupError() {\n+        FunctionDescriptorLookupError(boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -667,6 +674,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n@@ -825,1 +826,1 @@\n-            return new FunctionDescriptorLookupError().setMessage(diag);\n+            return new FunctionDescriptorLookupError(Types.this.dumpStacktraceOnError).setMessage(diag);\n@@ -5230,1 +5231,1 @@\n-    public abstract static class SignatureGenerator {\n+    public abstract class SignatureGenerator {\n@@ -5232,1 +5233,1 @@\n-        public static class InvalidSignatureException extends RuntimeException {\n+        public class InvalidSignatureException extends CompilerInternalException {\n@@ -5237,1 +5238,2 @@\n-            InvalidSignatureException(Type type) {\n+            InvalidSignatureException(Type type, boolean dumpStackTraceOnError) {\n+                super(dumpStackTraceOnError);\n@@ -5244,6 +5246,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -5252,2 +5248,0 @@\n-        private final Types types;\n-\n@@ -5259,5 +5253,1 @@\n-        protected SignatureGenerator(Types types) {\n-            this.types = types;\n-        }\n-\n-            throw new InvalidSignatureException(t);\n+            throw new InvalidSignatureException(t, Types.this.dumpStacktraceOnError);\n@@ -5356,1 +5346,1 @@\n-                    if (types.isDeclaredParametric(type)) {\n+                    if (Types.this.isDeclaredParametric(type)) {\n@@ -5396,1 +5386,1 @@\n-                        c.name == types.names.empty; \/\/ or anonymous\n+                        c.name == Types.this.names.empty; \/\/ or anonymous\n@@ -5398,1 +5388,1 @@\n-                        ? types.erasure(outer)\n+                        ? Types.this.erasure(outer)\n@@ -5420,1 +5410,1 @@\n-                List<Type> bounds = types.getBounds(tvar);\n+                List<Type> bounds = Types.this.getBounds(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+        initBlockType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);\n@@ -655,0 +656,1 @@\n+    final MethodType initBlockType;\n@@ -981,1 +983,0 @@\n-        env.info.ctorPrologue = false;\n@@ -1026,1 +1027,1 @@\n-        env.info.ctorPrologue = false;\n+        Assert.check(!env.info.ctorPrologue);\n@@ -1488,1 +1489,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, initBlockType,\n@@ -3606,14 +3607,0 @@\n-        \/* Map to hold 'fake' clinit methods. If a lambda is used to initialize a\n-         * static field and that lambda has type annotations, these annotations will\n-         * also be stored at these fake clinit methods.\n-         *\n-         * LambdaToMethod also use fake clinit methods so they can be reused.\n-         * Also as LTM is a phase subsequent to attribution, the methods from\n-         * clinits can be safely removed by LTM to save memory.\n-         *\/\n-        private Map<ClassSymbol, MethodSymbol> clinits = new HashMap<>();\n-\n-        public MethodSymbol removeClinit(ClassSymbol sym) {\n-            return clinits.remove(sym);\n-        }\n-\n@@ -3624,5 +3611,2 @@\n-         * is not a method, for example if the lambda is used to initialize\n-         * a field, then if the field is:\n-         *\n-         * - an instance field, we use the first constructor.\n-         * - a static field, we create a fake clinit method.\n+         * is not a method (e.g. if the lambda occurs in a field initializer), then\n+         * a synthetic method symbol owner is created.\n@@ -3634,1 +3618,3 @@\n-                \/\/field initializer\n+                \/\/ If the lambda is nested in a field initializer, we need to create a fake init method.\n+                \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n+                \/\/ init symbol's owner).\n@@ -3636,26 +3622,5 @@\n-                Symbol newScopeOwner = env.info.scope.owner;\n-                \/* if the field isn't static, then we can get the first constructor\n-                 * and use it as the owner of the environment. This is what\n-                 * LTM code is doing to look for type annotations so we are fine.\n-                 *\/\n-                if ((owner.flags() & STATIC) == 0) {\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n-                        newScopeOwner = s;\n-                        break;\n-                    }\n-                } else {\n-                    \/* if the field is static then we need to create a fake clinit\n-                     * method, this method can later be reused by LTM.\n-                     *\/\n-                    MethodSymbol clinit = clinits.get(enclClass);\n-                    if (clinit == null) {\n-                        Type clinitType = new MethodType(List.nil(),\n-                                syms.voidType, List.nil(), syms.methodClass);\n-                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,\n-                                names.clinit, clinitType, enclClass);\n-                        clinit.params = List.nil();\n-                        clinits.put(enclClass, clinit);\n-                    }\n-                    newScopeOwner = clinit;\n-                }\n-                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));\n+                Name initName = owner.isStatic() ? names.clinit : names.init;\n+                MethodSymbol initSym = new MethodSymbol(BLOCK | (owner.isStatic() ? STATIC : 0) | SYNTHETIC | PRIVATE,\n+                        initName, initBlockType, enclClass);\n+                initSym.params = List.nil();\n+                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(initSym)));\n@@ -4018,0 +3983,1 @@\n+            fExpr.owner = env.info.scope.owner;\n@@ -4303,0 +4269,4 @@\n+        if (tree.var.isImplicitlyTyped()) {\n+            setSyntheticVariableType(tree.var, type == Type.noType ? syms.errType\n+                                                                   : type);\n+        }\n@@ -4735,3 +4705,0 @@\n-            if (pt.isErroneous()) {\n-                return types.createErrorType(site);\n-            }\n@@ -4851,0 +4818,4 @@\n+            if (pt.isErroneous()) {\n+                owntype = types.createErrorType(owntype);\n+            }\n+\n@@ -5174,0 +5145,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n@@ -5344,1 +5323,12 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n+            WriteableScope newScope = env.info.scope;\n+\n+            if (env.tree instanceof JCClassDecl) {\n+                Symbol fakeOwner =\n+                    new MethodSymbol(BLOCK, names.empty, null,\n+                        env.info.scope.owner);\n+                newScope = newScope.dupUnshared(fakeOwner);\n+            }\n+\n+            Env<AttrContext> errEnv =\n+                    env.dup(env.tree,\n+                            env.info.dup(newScope));\n@@ -5372,0 +5362,2 @@\n+\n+        annotate.flush();\n@@ -5952,6 +5944,4 @@\n-                        if (at.getAnnotations().size() == 1) {\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));\n-                        } else {\n-                            ListBuffer<Attribute.Compound> comps = new ListBuffer<>();\n-                            for (JCAnnotation an : at.getAnnotations()) {\n-                                comps.add(an.attribute);\n+                        ListBuffer<Attribute.TypeCompound> onlyTypeAnnotationsBuf = new ListBuffer<>();\n+                        for (JCAnnotation an : at.getAnnotations()) {\n+                            if (chk.isTypeAnnotation(an, false)) {\n+                                onlyTypeAnnotationsBuf.add((Attribute.TypeCompound) an.attribute);\n@@ -5959,1 +5949,10 @@\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));\n+                        }\n+                        List<Attribute.TypeCompound> onlyTypeAnnotations = onlyTypeAnnotationsBuf.toList();\n+                        if (!onlyTypeAnnotations.isEmpty()) {\n+                            Fragment annotationFragment = onlyTypeAnnotations.size() == 1 ?\n+                                    Fragments.TypeAnnotation1(onlyTypeAnnotations.head) :\n+                                    Fragments.TypeAnnotation(onlyTypeAnnotations);\n+                            JCDiagnostic.AnnotatedType annotatedType = new JCDiagnostic.AnnotatedType(\n+                                    type.stripMetadata().annotatedType(onlyTypeAnnotations));\n+                            log.error(at.underlyingType.pos(), Errors.TypeAnnotationInadmissible(annotationFragment,\n+                                    type.tsym.owner, annotatedType));\n@@ -6127,0 +6126,13 @@\n+        @Override\n+        public void visitRecordPattern(JCRecordPattern that) {\n+            initTypeIfNeeded(that);\n+            if (that.record == null) {\n+                that.record = new ClassSymbol(0, TreeInfo.name(that.deconstructor),\n+                                              that.type, syms.noSymbol);\n+            }\n+            if (that.fullComponentTypes == null) {\n+                that.fullComponentTypes = List.nil();\n+            }\n+            super.visitRecordPattern(that);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":72,"deletions":60,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -790,1 +790,1 @@\n-            Set<Object> booleanLiterals = new HashSet<>();\n+            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n@@ -803,1 +803,1 @@\n-                            booleanLiterals.add(value);\n+                            booleanLiterals.remove(value);\n@@ -820,1 +820,1 @@\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n@@ -830,1 +830,1 @@\n-            boolean genericPatternsExpanded = false;\n+            boolean useHashes = true;\n@@ -836,1 +836,1 @@\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n@@ -843,1 +843,1 @@\n-                    if (!repeat && !genericPatternsExpanded) {\n+                    if (!repeat) {\n@@ -845,1 +845,1 @@\n-                        \/\/class B extends S1, S2\n+                        \/\/class B permits S1, S2\n@@ -847,1 +847,1 @@\n-                        \/\/this should be joined to R(B, S2),\n+                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n@@ -849,5 +849,8 @@\n-                        \/\/attempt to once expand all types to their transitive permitted types,\n-                        \/\/on all depth of nesting:\n-                        updatedPatterns = expandGenericPatterns(updatedPatterns);\n-                        genericPatternsExpanded = true;\n-                        repeat = !updatedPatterns.equals(patterns);\n+                        \/\/disable the use of hashing, and use subtyping in\n+                        \/\/reduceNestedPatterns to handle situations like this:\n+                        repeat = useHashes;\n+                        useHashes = false;\n+                    } else {\n+                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                        \/\/is enabled, as the hashing speeds up the process significantly:\n+                        useHashes = true;\n@@ -940,1 +943,1 @@\n-                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n+                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n@@ -976,1 +979,1 @@\n-        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n@@ -978,1 +981,1 @@\n-            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n@@ -1002,0 +1005,14 @@\n+        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+            if (root instanceof ClassSymbol clazz) {\n+                return List.of(clazz);\n+            } else if (root instanceof TypeVariableSymbol tvar) {\n+                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+                for (Type bound : tvar.getBounds()) {\n+                    result.appendList(baseClasses(bound.tsym));\n+                }\n+                return result.toList();\n+            } else {\n+                return List.nil();\n+            }\n+        }\n+\n@@ -1012,0 +1029,6 @@\n+         *\n+         * useHashes: when true, patterns will be subject to exact equivalence;\n+         *            when false, two binding patterns will be considered equivalent\n+         *            if one of them is more generic than the other one;\n+         *            when false, the processing will be significantly slower,\n+         *            as pattern hashes cannot be used to speed up the matching process\n@@ -1013,1 +1036,2 @@\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                             boolean useHashes) {\n@@ -1038,1 +1062,1 @@\n-                    var groupByHashes =\n+                    var groupEquivalenceCandidates =\n@@ -1043,2 +1067,2 @@\n-                             .collect(groupingBy(pd -> pd.hashCode(mismatchingCandidateFin)));\n-                    for (var candidates : groupByHashes.values()) {\n+                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                    for (var candidates : groupEquivalenceCandidates.values()) {\n@@ -1065,3 +1089,12 @@\n-                                        if (i != mismatchingCandidate &&\n-                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            continue NEXT_PATTERN;\n+                                        if (i != mismatchingCandidate) {\n+                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                                if (useHashes ||\n+                                                    \/\/when not using hashes,\n+                                                    \/\/check if rpOne.nested[i] is\n+                                                    \/\/a subtype of rpOther.nested[i]:\n+                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            }\n@@ -1075,1 +1108,1 @@\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns);\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n@@ -1082,1 +1115,3 @@\n-                                current.removeAll(join);\n+                                if (useHashes) {\n+                                    current.removeAll(join);\n+                                }\n@@ -1147,1 +1182,1 @@\n-                    covered &= isBpCovered(componentType[i], newNested);\n+                    covered &= checkCovered(componentType[i], List.of(newNested));\n@@ -1158,34 +1193,0 @@\n-        private Set<PatternDescription> expandGenericPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>(patterns);\n-            boolean modified;\n-            do {\n-                modified = false;\n-                for (PatternDescription pd : patterns) {\n-                    if (pd instanceof RecordPattern rpOne) {\n-                        for (int i = 0; i < rpOne.nested.length; i++) {\n-                            Set<PatternDescription> toExpand = Set.of(rpOne.nested[i]);\n-                            Set<PatternDescription> expanded = expandGenericPatterns(toExpand);\n-                            if (expanded != toExpand) {\n-                                expanded.removeAll(toExpand);\n-                                for (PatternDescription exp : expanded) {\n-                                    PatternDescription[] newNested = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[i] = exp;\n-                                    modified |= newPatterns.add(new RecordPattern(rpOne.recordType(), rpOne.fullComponentTypes(), newNested));\n-                                }\n-                            }\n-                        }\n-                    } else if (pd instanceof BindingPattern bp) {\n-                        Set<Symbol> permittedSymbols = allPermittedSubTypes((ClassSymbol) bp.type.tsym, cs -> true);\n-\n-                        if (!permittedSymbols.isEmpty()) {\n-                            for (Symbol permitted : permittedSymbols) {\n-                                \/\/TODO infer.instantiatePatternType(selectorType, csym); (?)\n-                                modified |= newPatterns.add(new BindingPattern(permitted.type));\n-                            }\n-                        }\n-                    }\n-                }\n-            } while (modified);\n-            return newPatterns;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":61,"deletions":60,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.util.CompilerInternalException;\n@@ -71,1 +72,1 @@\n-import java.util.Comparator;\n+import static com.sun.tools.javac.main.Option.DOE;\n@@ -100,0 +101,2 @@\n+    private final boolean dumpStacktraceOnError;\n+\n@@ -122,0 +125,1 @@\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -136,2 +140,2 @@\n-        InferenceException() {\n-            super(null);\n+        InferenceException(boolean dumpStacktrace) {\n+            super(null, dumpStacktrace);\n@@ -147,1 +151,1 @@\n-        InferenceException result = new InferenceException();\n+        InferenceException result = new InferenceException(dumpStacktraceOnError);\n@@ -1345,1 +1349,1 @@\n-        public static class NodeNotFoundException extends RuntimeException {\n+        class NodeNotFoundException extends CompilerInternalException {\n@@ -1350,1 +1354,2 @@\n-            public NodeNotFoundException(InferenceGraph graph) {\n+            public NodeNotFoundException(InferenceGraph graph, boolean dumpStacktraceOnError) {\n+                super(dumpStacktraceOnError);\n@@ -1353,6 +1358,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -1378,1 +1377,1 @@\n-                throw new NodeNotFoundException(g);\n+                throw new NodeNotFoundException(g, Infer.this.dumpStacktraceOnError);\n@@ -1453,1 +1452,1 @@\n-                throw new NodeNotFoundException(g);\n+                throw new NodeNotFoundException(g, Infer.this.dumpStacktraceOnError);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -38,0 +39,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -63,0 +65,1 @@\n+\n@@ -65,0 +68,1 @@\n+\n@@ -107,0 +111,1 @@\n+    private int variableIndex = 0;\n@@ -179,0 +184,5 @@\n+    \/**\n+     * The current expected return type.\n+     *\/\n+    Type currentRestype;\n+\n@@ -195,6 +205,0 @@\n-    \/** A map from local variable symbols to their translation (as per LambdaToMethod).\n-     * This is required when a capturing local class is created from a lambda (in which\n-     * case the captured symbols should be replaced with the translated lambda symbols).\n-     *\/\n-    Map<Symbol, Symbol> lambdaTranslationMap = null;\n-\n@@ -276,4 +280,1 @@\n-     *  from a local class. There is only one case; all other cases simply\n-     *  traverse down the tree. This class doesn't deal with the specific\n-     *  of Lower - it's an abstract visitor that is meant to be reused in\n-     *  order to share the local variable capture logic.\n+     *  from a local class.\n@@ -281,24 +282,1 @@\n-    abstract class BasicFreeVarCollector extends TreeScanner {\n-\n-        \/** Add all free variables of class c to fvs list\n-         *  unless they are already there.\n-         *\/\n-        abstract void addFreeVars(ClassSymbol c);\n-\n-        \/** If tree refers to a variable in owner of local class, add it to\n-         *  free variables list.\n-         *\/\n-        public void visitIdent(JCIdent tree) {\n-            visitSymbol(tree.sym);\n-        }\n-        \/\/ where\n-        abstract void visitSymbol(Symbol _sym);\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            addFreeVars(c);\n-            super.visitNewClass(tree);\n-        }\n+    class FreeVarCollector extends CaptureScanner {\n@@ -306,8 +284,2 @@\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);\n-            }\n-            super.visitApply(tree);\n+        FreeVarCollector(JCTree ownerTree) {\n+            super(ownerTree);\n@@ -316,40 +288,0 @@\n-        @Override\n-        public void visitYield(JCYield tree) {\n-            scan(tree.value);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Lower-specific subclass of {@code BasicFreeVarCollector}.\n-     *\/\n-    class FreeVarCollector extends BasicFreeVarCollector {\n-\n-        \/** The owner of the local class.\n-         *\/\n-        Symbol owner;\n-\n-        \/** The local class.\n-         *\/\n-        ClassSymbol clazz;\n-\n-        \/** The list of owner's variables accessed from within the local class,\n-         *  without any duplicates.\n-         *\/\n-        List<VarSymbol> fvs;\n-\n-        FreeVarCollector(ClassSymbol clazz) {\n-            this.clazz = clazz;\n-            this.owner = clazz.owner;\n-            this.fvs = List.nil();\n-        }\n-\n-        \/** Add free variable to fvs list unless it is already there.\n-         *\/\n-        private void addFreeVar(VarSymbol v) {\n-            for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail)\n-                if (l.head == v) return;\n-            fvs = fvs.prepend(v);\n-        }\n-\n-        @Override\n@@ -365,19 +297,0 @@\n-        @Override\n-        void visitSymbol(Symbol _sym) {\n-            Symbol sym = _sym;\n-            if (sym.kind == VAR || sym.kind == MTH) {\n-                if (sym != null && sym.owner != owner)\n-                    sym = proxies.get(sym);\n-                if (sym != null && sym.owner == owner) {\n-                    VarSymbol v = (VarSymbol)sym;\n-                    if (v.getConstValue() == null) {\n-                        addFreeVar(v);\n-                    }\n-                } else {\n-                    if (outerThisStack.head != null &&\n-                        outerThisStack.head != _sym)\n-                        visitSymbol(outerThisStack.head);\n-                }\n-            }\n-        }\n-\n@@ -389,4 +302,1 @@\n-            if (tree.encl == null &&\n-                c.hasOuterInstance() &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n+            addFreeVars(c);\n@@ -396,12 +306,0 @@\n-        \/** If tree refers to a qualified this or super expression\n-         *  for anything but the current class, add the outer this\n-         *  stack as a free variable.\n-         *\/\n-        public void visitSelect(JCFieldAccess tree) {\n-            if ((tree.name == names._this || tree.name == names._super) &&\n-                tree.selected.type.tsym != clazz &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitSelect(tree);\n-        }\n-\n@@ -413,6 +311,1 @@\n-                Symbol constructor = TreeInfo.symbol(tree.meth);\n-                ClassSymbol c = (ClassSymbol)constructor.owner;\n-                if (c.hasOuterInstance() &&\n-                    !tree.meth.hasTag(SELECT) &&\n-                    outerThisStack.head != null)\n-                    visitSymbol(outerThisStack.head);\n+                addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);\n@@ -422,15 +315,0 @@\n-\n-    }\n-\n-    ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {\n-        if (!c.isDirectlyOrIndirectlyLocal()) {\n-            return null;\n-        }\n-        Symbol currentOwner = c.owner;\n-        while (currentOwner.owner.kind.matches(KindSelector.TYP) && currentOwner.isDirectlyOrIndirectlyLocal()) {\n-            currentOwner = currentOwner.owner;\n-        }\n-        if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) && c.isSubClass(currentOwner, types)) {\n-            return (ClassSymbol)currentOwner;\n-        }\n-        return null;\n@@ -448,16 +326,4 @@\n-        if (c.owner.kind.matches(KindSelector.VAL_MTH) && !c.isStatic()) {\n-            FreeVarCollector collector = new FreeVarCollector(c);\n-            collector.scan(classDef(c));\n-            fvs = collector.fvs;\n-            freevarCache.put(c, fvs);\n-            return fvs;\n-        } else {\n-            ClassSymbol owner = ownerToCopyFreeVarsFrom(c);\n-            if (owner != null) {\n-                fvs = freevarCache.get(owner);\n-                freevarCache.put(c, fvs);\n-                return fvs;\n-            } else {\n-                return List.nil();\n-            }\n-        }\n+        FreeVarCollector collector = new FreeVarCollector(classDef(c));\n+        fvs = collector.analyzeCaptures().reverse();\n+        freevarCache.put(c, fvs);\n+        return fvs;\n@@ -1247,8 +1113,4 @@\n-            if (lambdaTranslationMap != null && lambdaTranslationMap.get(sym) != null) {\n-                return make.at(tree.pos).Ident(lambdaTranslationMap.get(sym));\n-            } else {\n-                \/\/ Otherwise replace the variable by its proxy.\n-                sym = proxies.get(sym);\n-                Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n-                tree = make.at(tree.pos).Ident(sym);\n-            }\n+            \/\/ Otherwise replace the variable by its proxy.\n+            sym = proxies.get(sym);\n+            Assert.check(sym != null && (sym.flags_field & FINAL) != 0);\n+            tree = make.at(tree.pos).Ident(sym);\n@@ -1339,8 +1201,0 @@\n-            } else if (sym.owner.kind == MTH && lambdaTranslationMap != null) {\n-                \/\/sym is a local variable - check the lambda translation map to\n-                \/\/see if sym has been translated to something else in the current\n-                \/\/scope (by LambdaToMethod)\n-                Symbol translatedSym = lambdaTranslationMap.get(sym.baseSymbol());\n-                if (translatedSym != null) {\n-                    tree = make.at(tree.pos).Ident(translatedSym);\n-                }\n@@ -1568,0 +1422,4 @@\n+    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner) {\n+        return freevarDefs(pos, freevars, owner, LOCAL_CAPTURE_FIELD);\n+    }\n+\n@@ -1581,1 +1439,6 @@\n-                flags, proxyName, v.erasure(types), owner);\n+                flags, proxyName, v.erasure(types), owner) {\n+                @Override\n+                public Symbol baseSymbol() {\n+                    return v;\n+                }\n+            };\n@@ -1607,1 +1470,1 @@\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n+        Type target = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -1893,1 +1756,0 @@\n-        Symbol c = sym.owner;\n@@ -1897,1 +1759,1 @@\n-            return make.at(pos).This(c.erasure(types));\n+            return make.at(pos).This(currentClass.erasure(types));\n@@ -2322,1 +2184,1 @@\n-            tree.pos, freevars(currentClass), currentClass, allowValueClasses && currentClass.isValueClass() ? STRICT : 0);\n+            tree.pos, freevars(currentClass), currentClass, allowValueClasses && currentClass.isValueClass() ? STRICT : LOCAL_CAPTURE_FIELD);\n@@ -2697,1 +2559,1 @@\n-            super(types);\n+            types.super();\n@@ -2793,0 +2655,1 @@\n+        Type prevRestype = currentRestype;\n@@ -2795,0 +2658,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -2796,0 +2660,1 @@\n+            currentRestype = types.erasure(tree.type.getReturnType());\n@@ -2798,0 +2663,1 @@\n+            variableIndex = 0;\n@@ -2800,0 +2666,1 @@\n+            currentRestype = prevRestype;\n@@ -2802,0 +2669,1 @@\n+            variableIndex = prevVariableIndex;\n@@ -2880,10 +2748,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap =\n-                    lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = (tree.sym.flags() & SYNTHETIC) != 0 &&\n-                        tree.sym.name.startsWith(names.lambda) ?\n-                        makeTranslationMap(tree) : null;\n-                super.visitMethodDef(tree);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            super.visitMethodDef(tree);\n@@ -2921,11 +2780,0 @@\n-    \/\/where\n-        private Map<Symbol, Symbol> makeTranslationMap(JCMethodDecl tree) {\n-            Map<Symbol, Symbol> translationMap = new HashMap<>();\n-            for (JCVariableDecl vd : tree.params) {\n-                Symbol p = vd.sym;\n-                if (p != p.baseSymbol()) {\n-                    translationMap.put(p.baseSymbol(), p);\n-                }\n-            }\n-            return translationMap;\n-        }\n@@ -2993,1 +2841,1 @@\n-                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -3140,1 +2988,1 @@\n-                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);\n+                thisArg = makeThis(tree.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3163,7 +3011,1 @@\n-            Map<Symbol, Symbol> prevLambdaTranslationMap = lambdaTranslationMap;\n-            try {\n-                lambdaTranslationMap = null;\n-                translate(tree.def);\n-            } finally {\n-                lambdaTranslationMap = prevLambdaTranslationMap;\n-            }\n+            translate(tree.def);\n@@ -3363,1 +3205,1 @@\n-                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);\n+                    thisArg = makeThis(tree.meth.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3389,0 +3231,3 @@\n+        if (tree.args.stream().anyMatch(c -> c == null)) {\n+            throw new AssertionError(\"Whooops before: \" + tree);\n+        }\n@@ -3431,0 +3276,3 @@\n+        Assert.check(!type.hasTag(VOID));\n+        if (type.hasTag(NONE))\n+            return tree;\n@@ -3876,0 +3724,1 @@\n+        int prevVariableIndex = variableIndex;\n@@ -3885,3 +3734,7 @@\n-        if (tree.init != null) tree.init = translate(tree.init, tree.type);\n-        result = tree;\n-        currentMethodSym = oldMethodSym;\n+        try {\n+            if (tree.init != null) tree.init = translate(tree.init, tree.type);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3899,2 +3752,8 @@\n-        super.visitBlock(tree);\n-        currentMethodSym = oldMethodSym;\n+        int prevVariableIndex = variableIndex;\n+        try {\n+            variableIndex = 0;\n+            super.visitBlock(tree);\n+        } finally {\n+            currentMethodSym = oldMethodSym;\n+            variableIndex = prevVariableIndex;\n+        }\n@@ -3927,2 +3786,18 @@\n-                                  types.erasure(currentMethodDef\n-                                                .restype.type));\n+                                  currentRestype);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        Type prevRestype = currentRestype;\n+        try {\n+            currentRestype = types.erasure(tree.getDescriptorType(types)).getReturnType();\n+            \/\/ represent void results as NO_TYPE, to avoid unnecessary boxing in boxIfNeeded\n+            if (currentRestype.hasTag(VOID))\n+                currentRestype = Type.noType;\n+            tree.body = tree.getBodyKind() == BodyKind.EXPRESSION ?\n+                    translate((JCExpression) tree.body, currentRestype) :\n+                    translate(tree.body);\n+        } finally {\n+            currentRestype = prevRestype;\n+        }\n@@ -4049,1 +3924,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4206,1 +4081,1 @@\n-                                               names.fromString(\"s\" + tree.pos + target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4212,1 +4087,1 @@\n-                                                 names.fromString(\"tmp\" + tree.pos + target.syntheticNameChar()),\n+                                                 names.fromString(\"tmp\" + variableIndex++ + target.syntheticNameChar()),\n@@ -4354,1 +4229,1 @@\n-                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               names.fromString(\"s\" + variableIndex++ + this.target.syntheticNameChar()),\n@@ -4442,1 +4317,1 @@\n-        if (tree.name == names._class) {\n+        if (tree.name == names._class && tree.selected.type.isPrimitiveOrVoid()) {\n@@ -4518,0 +4393,1 @@\n+            currentRestype = null;\n@@ -4547,0 +4423,1 @@\n+            currentRestype = null;\n@@ -4566,0 +4443,19 @@\n+\n+    \/\/ needed for the lambda deserialization method, which is expressed as a big switch on strings\n+    public JCMethodDecl translateMethod(Env<AttrContext> env, JCMethodDecl methodDecl, TreeMaker make) {\n+        try {\n+            this.attrEnv = env;\n+            this.make = make;\n+            this.currentClass = methodDecl.sym.enclClass();\n+            proxies = new HashMap<>();\n+            return translate(methodDecl);\n+        } finally {\n+            this.attrEnv = null;\n+            this.make = null;\n+            this.currentClass = null;\n+            \/\/ the two fields below are set when visiting the method\n+            this.currentMethodSym = null;\n+            this.currentMethodDef = null;\n+            this.proxies = null;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":115,"deletions":219,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -30,0 +32,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -31,0 +34,2 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.jvm.Target;\n@@ -48,0 +53,2 @@\n+import javax.lang.model.type.TypeKind;\n+\n@@ -77,0 +84,1 @@\n+    private final Target target;\n@@ -91,0 +99,1 @@\n+        target = Target.instance(context);\n@@ -583,0 +592,263 @@\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            Type t = types.skipTypeVars(tree.expr.type, false);\n+            Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n+            if (tree.kind == ReferenceKind.UNBOUND) {\n+                tree.expr = make.Type(receiverTarget);\n+            } else {\n+                tree.expr = translate(tree.expr, receiverTarget);\n+            }\n+            if (!tree.type.isIntersection()) {\n+                tree.type = erasure(tree.type);\n+            } else {\n+                tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n+            }\n+            result = tree;\n+        }\n+    }\n+    \/\/ where\n+    boolean needsVarArgsConversion(JCMemberReference tree) {\n+        return tree.varargsElement != null;\n+    }\n+\n+    \/**\n+     * @return Is this an array operation like clone()\n+     *\/\n+    boolean isArrayOp(JCMemberReference tree) {\n+        return tree.sym.owner == syms.arrayClass;\n+    }\n+\n+    boolean receiverAccessible(JCMemberReference tree) {\n+        \/\/hack needed to workaround 292 bug (7087658)\n+        \/\/when 292 issue is fixed we should remove this and change the backend\n+        \/\/code to always generate a method handle to an accessible method\n+        return tree.ownerAccessible;\n+    }\n+\n+    \/**\n+     * Erasure destroys the implementation parameter subtype\n+     * relationship for intersection types.\n+     * Have similar problems for union types too.\n+     *\/\n+    boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+        List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+        for (; tl.nonEmpty(); tl = tl.tail) {\n+            Type pt = tl.head;\n+            if (isIntersectionOrUnionType(pt))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean isIntersectionOrUnionType(Type t) {\n+        return switch (t.getKind()) {\n+            case INTERSECTION, UNION -> true;\n+            case TYPEVAR -> {\n+                TypeVar tv = (TypeVar) t;\n+                yield isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                          Symbol currentClass) {\n+        return ((targetReference.flags() & PROTECTED) != 0 &&\n+                targetReference.packge() != currentClass.packge());\n+    }\n+\n+    \/**\n+     * This method should be called only when target release <= 14\n+     * where LambdaMetaFactory does not spin nestmate classes.\n+     *\n+     * This method should be removed when --release 14 is not supported.\n+     *\/\n+    boolean isPrivateInOtherClass(JCMemberReference tree) {\n+        return (tree.sym.flags() & PRIVATE) != 0 &&\n+                !types.isSameType(\n+                        types.erasure(tree.sym.enclClass().asType()),\n+                        types.erasure(env.enclClass.sym.asType()));\n+    }\n+\n+    \/**\n+     * Does this reference need to be converted to a lambda\n+     * (i.e. var args need to be expanded or \"super\" is used)\n+     *\/\n+    boolean needsConversionToLambda(JCMemberReference tree) {\n+        return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                tree.hasKind(ReferenceKind.SUPER) ||\n+                needsVarArgsConversion(tree) ||\n+                isArrayOp(tree) ||\n+                (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, env.enclClass.sym) ||\n+                !receiverAccessible(tree) ||\n+                (tree.getMode() == ReferenceMode.NEW &&\n+                        tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                        (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+    }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, env.enclClass.sym);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.owner = tree.owner;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, receiverExpression), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = descPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ Use the descriptor parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            make.Ident(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            args.toList()).setType(tree.referentType.getReturnType());\n+\n+            TreeInfo.setVarargsElement(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                TreeInfo.setVarargsElement(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n@@ -925,18 +1197,0 @@\n-    public void visitReference(JCMemberReference tree) {\n-        Type t = types.skipTypeVars(tree.expr.type, false);\n-        Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n-        if (tree.kind == ReferenceKind.UNBOUND) {\n-            tree.expr = make.Type(receiverTarget);\n-        } else {\n-            tree.expr = translate(tree.expr, receiverTarget);\n-        }\n-        if (!tree.type.isIntersection()) {\n-            tree.type = erasure(tree.type);\n-        } else {\n-            tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n-        }\n-        if (tree.varargsElement != null)\n-            tree.varargsElement = erasure(tree.varargsElement);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":272,"deletions":18,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -1055,0 +1055,1 @@\n+                int fieldPos = 0;\n@@ -1070,2 +1071,2 @@\n-                     *  First, we find the record component by comparing its name and position with current field,\n-                     *  if any, and we mark it. Then we copy the annotations to the field so that annotations applicable only to the record component\n+                     *  First, we get the record component matching the field position. Then we copy the annotations\n+                     *  to the field so that annotations applicable only to the record component\n@@ -1076,1 +1077,1 @@\n-                    RecordComponent rc = sym.findRecordComponentToRemove(field);\n+                    RecordComponent rc = getRecordComponentAt(sym, fieldPos);\n@@ -1080,2 +1081,1 @@\n-                        List<JCAnnotation> originalAnnos = tc.copy(rc.getOriginalAnnos());\n-                        field.mods.annotations = originalAnnos;\n+                        field.mods.annotations = tc.copy(rc.getOriginalAnnos());\n@@ -1088,0 +1088,1 @@\n+                    fieldPos++;\n@@ -1102,0 +1103,12 @@\n+    \/\/ where\n+        private RecordComponent getRecordComponentAt(ClassSymbol sym, int componentPos) {\n+            int i = 0;\n+            for (RecordComponent rc : sym.getRecordComponents()) {\n+                if (i == componentPos) {\n+                    return rc;\n+                }\n+                i++;\n+            }\n+            return null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.stream.IntStream;\n@@ -65,0 +66,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -67,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -226,0 +230,6 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters,\n+     * for all parameters including synthetic and mandated ones.\n+     *\/\n+    int[] allParameterAccessFlags;\n+\n@@ -606,2 +616,14 @@\n-                                                         sbp - startSbp ));\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n+                                                         sbp - startSbp));\n+                List<Type> actuals = sigToTypes('>');\n+                List<Type> formals = ((ClassType)t.type.tsym.type).typarams_field;\n+                if (formals != null) {\n+                    if (actuals.isEmpty())\n+                        actuals = formals;\n+                }\n+                \/* actualsCp is final as it will be captured by the inner class below. We could avoid defining\n+                 * this additional local variable and depend on field ClassType::typarams_field which `actuals` is\n+                 * assigned to but then we would have a dependendy on the internal representation of ClassType which\n+                 * could change in the future\n+                 *\/\n+                final List<Type> actualsCp = actuals;\n+                outer = new ClassType(outer, actuals, t, List.nil()) {\n@@ -609,0 +631,1 @@\n+                        boolean typeArgsSet = false;\n@@ -638,1 +661,21 @@\n-                    };\n+\n+                        @Override\n+                        public List<Type> getTypeArguments() {\n+                            if (!typeArgsSet) {\n+                                typeArgsSet = true;\n+                                List<Type> formalsCp = ((ClassType)t.type.tsym.type).typarams_field;\n+                                if (formalsCp != null && !formalsCp.isEmpty()) {\n+                                    if (actualsCp.length() == formalsCp.length()) {\n+                                        List<Type> a = actualsCp;\n+                                        List<Type> f = formalsCp;\n+                                        while (a.nonEmpty()) {\n+                                            a.head = a.head.withTypeVar(f.head);\n+                                            a = a.tail;\n+                                            f = f.tail;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            return super.getTypeArguments();\n+                        }\n+                };\n@@ -1128,0 +1171,1 @@\n+                        allParameterAccessFlags = new int[numEntries];\n@@ -1130,0 +1174,1 @@\n+                        int allParamIndex = 0;\n@@ -1134,0 +1179,1 @@\n+                            allParameterAccessFlags[allParamIndex++] = flags;\n@@ -1564,1 +1610,1 @@\n-            } else if (proxy.type.tsym.flatName() == syms.restrictedType.tsym.flatName()) {\n+            } else if (proxy.type.tsym.flatName() == syms.restrictedInternalType.tsym.flatName()) {\n@@ -1618,1 +1664,10 @@\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", meth);\n+            \/\/the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations\n+            \/\/provide annotations for a different number of parameters, ignore:\n+            if (lintClassfile) {\n+                log.warning(LintCategory.CLASSFILE, Warnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            }\n+            for (int pnum = 0; pnum < numParameters; pnum++) {\n+                readAnnotations();\n+            }\n+            parameterAnnotations = null;\n+            return ;\n@@ -2337,3 +2392,11 @@\n-    private static void addTypeAnnotationsToSymbol(\n-            Symbol s, List<Attribute.TypeCompound> attributes) {\n-        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    private void addTypeAnnotationsToSymbol(Symbol s, List<Attribute.TypeCompound> attributes) {\n+        try {\n+            new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+        } catch (CompletionFailure ex) {\n+            JavaFileObject prev = log.useSource(currentClassFile);\n+            try {\n+                log.error(Errors.CantAttachTypeAnnotations(attributes, s.owner, s.name, ex.getDetailValue()));\n+            } finally {\n+                log.useSource(prev);\n+            }\n+        }\n@@ -2351,0 +2414,6 @@\n+        \/**\n+         * A supertype_index value of 65535 specifies that the annotation appears on the superclass\n+         * in an extends clause of a class declaration, see JVMS 4.7.20.1\n+         *\/\n+        public static final int SUPERCLASS_INDEX = 65535;\n+\n@@ -2360,1 +2429,1 @@\n-            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(SUPERCLASS_INDEX));\n@@ -2487,6 +2556,1 @@\n-            \/\/ Search the structure of the type to find the contained types at each type path\n-            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n-            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n-\n-            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n-            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+            type = new TypeAnnotationStructuralTypeMapping(attributesByPath).visit(type, List.nil());\n@@ -2521,2 +2585,4 @@\n-     * Visit all contained types, assembling a type path to represent the current location, and\n-     * record the types at each type path that need to be annotated.\n+     * A type mapping that rewrites the type to include type annotations.\n+     *\n+     * <p>This logic is similar to {@link Type.StructuralTypeMapping}, but also tracks the path to\n+     * the contained types being rewritten, and so cannot easily share the existing logic.\n@@ -2524,2 +2590,3 @@\n-    private static class TypeAnnotationLocator\n-            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+    private static final class TypeAnnotationStructuralTypeMapping\n+            extends Types.TypeMapping<List<TypeAnnotationPosition.TypePathEntry>> {\n+\n@@ -2527,2 +2594,1 @@\n-                          ListBuffer<Attribute.TypeCompound>> attributesByPath;\n-        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+                ListBuffer<Attribute.TypeCompound>> attributesByPath;\n@@ -2530,1 +2596,1 @@\n-        private TypeAnnotationLocator(\n+        private TypeAnnotationStructuralTypeMapping(\n@@ -2532,2 +2598,1 @@\n-                        attributesByPath,\n-                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+                    attributesByPath) {\n@@ -2535,1 +2600,0 @@\n-            this.attributesByType = attributesByType;\n@@ -2538,1 +2602,1 @@\n-        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+        public Type visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n@@ -2545,3 +2609,4 @@\n-            List<ClassType> enclosing = List.nil();\n-            for (Type curr = t;\n-                    curr != null && curr != Type.noType;\n+            Type outer = t.getEnclosingType();\n+            Type outer1 = outer != Type.noType ? visit(outer, path) : outer;\n+            for (Type curr = t.getEnclosingType();\n+                    curr != Type.noType;\n@@ -2549,11 +2614,0 @@\n-                enclosing = enclosing.prepend((ClassType) curr);\n-            }\n-            for (ClassType te : enclosing) {\n-                if (te.typarams_field != null) {\n-                    int i = 0;\n-                    for (Type typaram : te.typarams_field) {\n-                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(\n-                                TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n-                    }\n-                }\n-                visitType(te, path);\n@@ -2562,1 +2616,6 @@\n-            return null;\n+            List<Type> typarams = t.getTypeArguments();\n+            List<Type> typarams1 = rewriteTypeParams(path, typarams);\n+            if (outer1 != outer || typarams != typarams1) {\n+                t = new ClassType(outer1, typarams1, t.tsym, t.getMetadata());\n+            }\n+            return reannotate(t, path);\n@@ -2565,5 +2624,6 @@\n-        @Override\n-        public Void visitWildcardType(\n-                WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n-            return super.visitWildcardType(t, path);\n+        private List<Type> rewriteTypeParams(\n+                List<TypeAnnotationPosition.TypePathEntry> path, List<Type> typarams) {\n+            var i = IntStream.iterate(0, x -> x + 1).iterator();\n+            return typarams.map(typaram -> visit(typaram,\n+                    path.append(new TypeAnnotationPosition.TypePathEntry(\n+                            TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i.nextInt()))));\n@@ -2573,3 +2633,10 @@\n-        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n-            return super.visitArrayType(t, path);\n+        public Type visitWildcardType(\n+                WildcardType wt, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            Type t = wt.type;\n+            if (t != null) {\n+                t = visit(t, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            }\n+            if (t != wt.type) {\n+                wt = new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.getMetadata());\n+            }\n+            return reannotate(wt, path);\n@@ -2579,4 +2646,6 @@\n-        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n-            if (attributes != null) {\n-                attributesByType.put(t, attributes.toList());\n+        public Type visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            Type elemtype = t.elemtype;\n+            Type elemtype1 =\n+                    visit(elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            if (elemtype1 != elemtype)  {\n+                t = new ArrayType(elemtype1, t.tsym, t.getMetadata());\n@@ -2584,1 +2653,1 @@\n-            return null;\n+            return reannotate(t, path);\n@@ -2586,9 +2655,3 @@\n-    }\n-\n-    \/** A type mapping that rewrites the type to include type annotations. *\/\n-    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n-        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n-\n-        private TypeAnnotationTypeMapping(\n-                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n-            this.attributesByType = attributesByType;\n+        @Override\n+        public Type visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            return reannotate(t, path);\n@@ -2598,8 +2661,4 @@\n-        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n-            \/\/ We're relying on object identify of Type instances to record where the annotations\n-            \/\/ need to be added, so we have to retrieve the annotations for each type before\n-            \/\/ rewriting it, and then add them after its contained types have been rewritten.\n-            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n-            Type mapped = f.apply(t, null);\n-            if (attributes == null) {\n-                return mapped;\n+        Type reannotate(Type type, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            List<Attribute.TypeCompound> attributes = attributesForPath(path);\n+            if (attributes.isEmpty()) {\n+                return type;\n@@ -2609,1 +2668,1 @@\n-            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n+            TypeMetadata.Annotations existing = type.getMetadata(TypeMetadata.Annotations.class);\n@@ -2612,1 +2671,1 @@\n-                return mapped;\n+                return type;\n@@ -2614,6 +2673,1 @@\n-            return mapped.annotatedType(attributes);\n-        }\n-\n-        @Override\n-        public Type visitClassType(ClassType t, Void unused) {\n-            return reannotate(t, super::visitClassType);\n+            return type.annotatedType(attributes);\n@@ -2622,13 +2676,4 @@\n-        @Override\n-        public Type visitWildcardType(WildcardType t, Void unused) {\n-            return reannotate(t, super::visitWildcardType);\n-        }\n-\n-        @Override\n-        public Type visitArrayType(ArrayType t, Void unused) {\n-            return reannotate(t, super::visitArrayType);\n-        }\n-\n-        @Override\n-        public Type visitType(Type t, Void unused) {\n-            return reannotate(t, (x, u) -> x);\n+        List<Attribute.TypeCompound> attributesForPath(\n+                List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            return attributes != null ? attributes.toList() : List.nil();\n@@ -2663,1 +2708,2 @@\n-        Type type = poolReader.getType(nextChar());\n+        Type descriptorType = poolReader.getType(nextChar());\n+        Type type = descriptorType;\n@@ -2691,0 +2737,1 @@\n+        boolean forceLocal = false;\n@@ -2698,1 +2745,2 @@\n-            boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n+            boolean local = forceLocal =\n+                    !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n@@ -2719,0 +2767,1 @@\n+        adjustParameterAnnotations(m, descriptorType, forceLocal);\n@@ -2846,3 +2895,2 @@\n-        if (parameterAnnotations != null && parameterAnnotations.length != annotationIndex) {\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", sym);\n-        }\n+        Assert.check(parameterAnnotations == null ||\n+                     parameterAnnotations.length == annotationIndex);\n@@ -2854,0 +2902,1 @@\n+        allParameterAccessFlags = null;\n@@ -2857,0 +2906,124 @@\n+    void adjustParameterAnnotations(MethodSymbol sym, Type methodDescriptor,\n+                                    boolean forceLocal) {\n+        if (parameterAnnotations == null) {\n+            return ;\n+        }\n+\n+        \/\/the specification for Runtime(In)VisibleParameterAnnotations does not\n+        \/\/enforce any mapping between the method parameters and the recorded\n+        \/\/parameter annotation. Attempt a number of heuristics to adjust the\n+        \/\/adjust parameterAnnotations to the percieved number of parameters:\n+\n+        int methodParameterCount = sym.type.getParameterTypes().size();\n+\n+        if (methodParameterCount == parameterAnnotations.length) {\n+            \/\/we've got exactly as many parameter annotations as are parameters\n+            \/\/of the method (after considering a possible Signature attribute),\n+            \/\/no need to do anything. the parameter creation code will use\n+            \/\/the 1-1 mapping to restore the annotations:\n+            return ;\n+        }\n+\n+        if (allParameterAccessFlags != null) {\n+            \/\/MethodParameters attribute present, use it:\n+\n+            \/\/count the number of non-synthetic and non-mandatory parameters:\n+            int realParameters = 0;\n+\n+            for (int i = 0; i < allParameterAccessFlags.length; i++) {\n+                if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                    realParameters++;\n+                }\n+            }\n+\n+            int methodDescriptorParameterCount = methodDescriptor.getParameterTypes().size();\n+\n+            if (realParameters == parameterAnnotations.length &&\n+                allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if we have parameter annotations for each non-synthetic\/mandatory parameter,\n+                \/\/and if Signature was not present, expand the parameterAnnotations to cover\n+                \/\/all the method descriptor's parameters:\n+                if (sym.type == methodDescriptor) {\n+                    ParameterAnnotations[] newParameterAnnotations =\n+                            new ParameterAnnotations[methodParameterCount];\n+                    int srcIndex = 0;\n+\n+                    for (int i = 0; i < methodParameterCount; i++) {\n+                        if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                            newParameterAnnotations[i] = parameterAnnotations[srcIndex++];\n+                        }\n+                    }\n+\n+                    parameterAnnotations = newParameterAnnotations;\n+                } else {\n+                    dropParameterAnnotations();\n+                }\n+            } else if (realParameters == methodParameterCount &&\n+                       methodDescriptorParameterCount == parameterAnnotations.length &&\n+                       allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if there are as many parameter annotations as parameters in\n+                \/\/the method descriptor, and as many real parameters as parameters\n+                \/\/in the method's type (after accounting for Signature), shrink\n+                \/\/the parameterAnnotations to only cover the parameters from\n+                \/\/the method's type:\n+                ParameterAnnotations[] newParameterAnnotations =\n+                        new ParameterAnnotations[methodParameterCount];\n+                int targetIndex = 0;\n+\n+                for (int i = 0; i < parameterAnnotations.length; i++) {\n+                    if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                        newParameterAnnotations[targetIndex++] = parameterAnnotations[i];\n+                    }\n+                }\n+\n+                parameterAnnotations = newParameterAnnotations;\n+            } else {\n+                dropParameterAnnotations();\n+            }\n+            return ;\n+        }\n+\n+        if (!sym.isConstructor()) {\n+            \/\/if the number of parameter annotations and the number of parameters\n+            \/\/don't match, we don't have any heuristics to map one to the other\n+            \/\/unless the method is a constructor:\n+            dropParameterAnnotations();\n+            return ;\n+        }\n+\n+        if (sym.owner.isEnum()) {\n+            if (methodParameterCount == parameterAnnotations.length + 2 &&\n+                sym.type == methodDescriptor) {\n+                \/\/handle constructors of enum types without the Signature attribute -\n+                \/\/there are the two synthetic parameters (name and ordinal) in the\n+                \/\/constructor, but there may be only parameter annotations for the\n+                \/\/real non-synthetic parameters:\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[parameterAnnotations.length + 2];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 2, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        } else if (sym.owner.isDirectlyOrIndirectlyLocal() || forceLocal) {\n+            \/\/local class may capture the enclosing instance (as the first parameter),\n+            \/\/and local variables (as trailing parameters)\n+            \/\/if there are less parameter annotations than parameters, put the existing\n+            \/\/ones starting with offset:\n+            if (methodParameterCount > parameterAnnotations.length &&\n+                sym.type == methodDescriptor) {\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[methodParameterCount];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 1, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        }\n+\n+        \/\/no heuristics worked, drop the annotations:\n+        dropParameterAnnotations();\n+    }\n+\n+    private void dropParameterAnnotations() {\n+        parameterAnnotations = null;\n+        if (lintClassfile) {\n+            log.warning(LintCategory.CLASSFILE, Warnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":270,"deletions":97,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-            (c.owner.type == null \/\/ local to init block\n+            ((c.owner.flags() & BLOCK) != 0 \/\/ local to init block\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.code.Flags.Flag;\n@@ -43,0 +44,1 @@\n+import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -64,0 +66,2 @@\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -478,1 +482,5 @@\n-    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+    protected JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey) {\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -481,1 +489,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -508,0 +516,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -510,1 +522,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -2661,2 +2673,2 @@\n-        final JCModifiers mods = modifiersOpt();\n-        List<JCAnnotation> newAnnotations = mods.annotations;\n+        List<JCAnnotation> newAnnotations = typeAnnotationsOpt();\n+\n@@ -2666,3 +2678,0 @@\n-            if (mods.flags != 0) {\n-                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n-            }\n@@ -2750,5 +2759,1 @@\n-            JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);\n-            if ((newClass.def == null) && (mods.flags != 0)) {\n-                log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n-            }\n-            return newClass;\n+            return classCreatorRest(newpos, null, typeArgs, t);\n@@ -2779,1 +2784,1 @@\n-        return classCreatorRest(newpos, encl, typeArgs, t, 0);\n+        return classCreatorRest(newpos, encl, typeArgs, t);\n@@ -2881,2 +2886,1 @@\n-                                  JCExpression t,\n-                                  long flags)\n+                                  JCExpression t)\n@@ -2890,1 +2894,1 @@\n-            JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);\n+            JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n@@ -3070,1 +3074,1 @@\n-                    case NULL: case IDENTIFIER: case TRUE: case FALSE:\n+                    case NULL: case IDENTIFIER: case UNDERSCORE: case TRUE: case FALSE:\n@@ -3606,1 +3610,9 @@\n-                case RPAREN: parenDepth--; break;\n+                case RPAREN:\n+                    parenDepth--;\n+                    if (parenDepth == 0 &&\n+                        typeDepth == 0 &&\n+                        peekToken(lookahead, TokenKind.IDENTIFIER) &&\n+                        S.token(lookahead + 1).name() == names.when) {\n+                        return PatternResult.PATTERN;\n+                    }\n+                    break;\n@@ -3650,4 +3662,1 @@\n-                pos = token.pos;\n-                JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);\n-                F.at(pos);\n-                return variableDeclarators(mods, t, stats, true).toList();\n+                return variableDeclarators(modifiersOpt(), t, stats, true).toList();\n@@ -4280,0 +4289,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4512,0 +4528,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4921,0 +4940,6 @@\n+            } else if (isDefiniteStatementStartToken()) {\n+                int startPos = token.pos;\n+                List<JCStatement> statements = blockStatement();\n+                return List.of(syntaxError(startPos,\n+                                           statements,\n+                                           Errors.StatementNotExpected));\n@@ -5088,0 +5113,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n@@ -5098,1 +5129,13 @@\n-        }\n+    }\n+\n+    \/**\n+     * {@return true if and only if the current token is definitelly a token that\n+     *  starts a statement.}\n+     *\/\n+    private boolean isDefiniteStatementStartToken() {\n+        return switch (token.kind) {\n+            case IF, WHILE, DO, SWITCH, RETURN, TRY, FOR, ASSERT, BREAK,\n+                 CONTINUE, THROW -> true;\n+            default -> false;\n+        };\n+    }\n@@ -5236,0 +5279,1 @@\n+            boolean unclosedParameterList;\n@@ -5238,0 +5282,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5243,0 +5288,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5256,0 +5303,1 @@\n+                    accept(SEMI);\n@@ -5258,0 +5306,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5259,1 +5308,0 @@\n-                accept(SEMI);\n@@ -5262,2 +5310,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5280,0 +5331,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":156,"deletions":27,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -577,1 +577,2 @@\n-    illegal fall-through to a pattern\n+    illegal fall-through to a pattern\\n\\\n+    (the previous case label is missing a break)\n@@ -580,1 +581,2 @@\n-    illegal fall-through from a pattern\n+    illegal fall-through from a pattern\\n\\\n+    (the current case label is missing a break)\n@@ -1617,0 +1619,6 @@\n+compiler.err.statement.not.expected=\\\n+    statements not expected outside of methods and initializers\n+\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n@@ -2352,0 +2360,5 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations=\\\n+    Cannot attach type annotations {0} to {1}.{2}:\\n\\\n+    {3}\n+\n@@ -2543,2 +2556,11 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=\\\n-    bad RuntimeInvisibleParameterAnnotations attribute: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=\\\n+    the length of parameters in RuntimeVisibleParameterAnnotations attribute and \\\n+    RuntimeInvisibleParameterAnnotations attribute in: {0} \\\n+    do not match, ignoring both attributes\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=\\\n+    the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations attributes \\\n+    in: {0} \\\n+    cannot be mapped to the method''s parameters\n@@ -3271,1 +3293,5 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible=\\\n+    {0} not expected here\\n\\\n+    (to annotate a qualified type, write {1}.{2})\n+\n@@ -3273,2 +3299,2 @@\n-compiler.err.cant.type.annotate.scoping.1=\\\n-    scoping construct cannot be annotated with type-use annotation: {0}\n+compiler.misc.type.annotation.1=\\\n+    type annotation {0} is\n@@ -3276,3 +3302,2 @@\n-# TODO 308: make a better error message\n-compiler.err.cant.type.annotate.scoping=\\\n-    scoping construct cannot be annotated with type-use annotations: {0}\n+compiler.misc.type.annotation=\\\n+    type annotations {0} are\n@@ -4114,1 +4139,1 @@\n-    cannot reference {0} after supertype constructor has been called\n+    cannot assign to {0} after supertype constructor has been called\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -811,0 +811,2 @@\n+        \/** The owner of this functional expression. *\/\n+        public Symbol owner;\n@@ -2020,0 +2022,1 @@\n+        public boolean wasMethodReference;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1474,1 +1474,1 @@\n-                    print(Convert.quote(String.valueOf((char)((Number)tree.value).intValue())));\n+                    print(Convert.quote((char)((Number)tree.value).intValue(), true));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -353,0 +353,1 @@\n+            result = tree;\n@@ -358,0 +359,1 @@\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,6 @@\n-import jdk.javadoc.doclet.DocletEnvironment;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n@@ -46,6 +44,10 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-import java.util.stream.Collectors;\n+\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyles;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import jdk.javadoc.internal.html.Content;\n+import jdk.javadoc.internal.html.ContentBuilder;\n+import jdk.javadoc.internal.html.Entity;\n+import jdk.javadoc.internal.html.HtmlTag;\n+import jdk.javadoc.internal.html.HtmlTree;\n+import jdk.javadoc.internal.html.Text;\n@@ -66,1 +68,1 @@\n-        var signature = HtmlTree.DIV(HtmlStyle.moduleSignature);\n+        var signature = HtmlTree.DIV(HtmlStyles.moduleSignature);\n@@ -69,1 +71,1 @@\n-            signature.add(HtmlTree.SPAN(HtmlStyle.annotations, annotations));\n+            signature.add(HtmlTree.SPAN(HtmlStyles.annotations, annotations));\n@@ -76,1 +78,1 @@\n-        var nameSpan = HtmlTree.SPAN(HtmlStyle.elementName);\n+        var nameSpan = HtmlTree.SPAN(HtmlStyles.elementName);\n@@ -86,1 +88,1 @@\n-        var signature = HtmlTree.DIV(HtmlStyle.packageSignature);\n+        var signature = HtmlTree.DIV(HtmlStyles.packageSignature);\n@@ -89,1 +91,1 @@\n-            signature.add(HtmlTree.SPAN(HtmlStyle.annotations, annotations));\n+            signature.add(HtmlTree.SPAN(HtmlStyles.annotations, annotations));\n@@ -92,1 +94,1 @@\n-        var nameSpan = HtmlTree.SPAN(HtmlStyle.elementName);\n+        var nameSpan = HtmlTree.SPAN(HtmlStyles.elementName);\n@@ -125,1 +127,1 @@\n-                content.add(HtmlTree.SPAN(HtmlStyle.annotations, annotationInfo));\n+                content.add(HtmlTree.SPAN(HtmlStyles.annotations, annotationInfo));\n@@ -127,1 +129,1 @@\n-            content.add(HtmlTree.SPAN(HtmlStyle.modifiers, modifiers));\n+            content.add(HtmlTree.SPAN(HtmlStyles.modifiers, modifiers));\n@@ -129,1 +131,1 @@\n-            var nameSpan = HtmlTree.SPAN(HtmlStyle.elementName);\n+            var nameSpan = HtmlTree.SPAN(HtmlStyles.elementName);\n@@ -134,1 +136,1 @@\n-                nameSpan.addStyle(HtmlStyle.typeNameLabel).add(className);\n+                nameSpan.addStyle(HtmlStyles.typeNameLabel).add(className);\n@@ -147,1 +149,1 @@\n-                var extendsImplements = HtmlTree.SPAN(HtmlStyle.extendsImplements);\n+                var extendsImplements = HtmlTree.SPAN(HtmlStyles.extendsImplements);\n@@ -189,1 +191,1 @@\n-                var permitsSpan = HtmlTree.SPAN(HtmlStyle.permits);\n+                var permitsSpan = HtmlTree.SPAN(HtmlStyles.permits);\n@@ -208,1 +210,1 @@\n-                    permitsSpan.add(HtmlTree.SPAN(HtmlStyle.permitsNote, c));\n+                    permitsSpan.add(HtmlTree.SPAN(HtmlStyles.permitsNote, c));\n@@ -212,1 +214,1 @@\n-            return HtmlTree.DIV(HtmlStyle.typeSignature, content);\n+            return HtmlTree.DIV(HtmlStyles.typeSignature, content);\n@@ -460,1 +462,1 @@\n-                content.add(HtmlTree.SPAN(HtmlStyle.annotations, annotations));\n+                content.add(HtmlTree.SPAN(HtmlStyles.annotations, annotations));\n@@ -474,1 +476,1 @@\n-                content.add(HtmlTree.SPAN(HtmlStyle.returnType, returnType));\n+                content.add(HtmlTree.SPAN(HtmlStyles.returnType, returnType));\n@@ -479,1 +481,1 @@\n-            var nameSpan = HtmlTree.SPAN(HtmlStyle.elementName);\n+            var nameSpan = HtmlTree.SPAN(HtmlStyles.elementName);\n@@ -493,1 +495,1 @@\n-            return HtmlTree.DIV(HtmlStyle.memberSignature, content);\n+            return HtmlTree.DIV(HtmlStyles.memberSignature, content);\n@@ -524,1 +526,1 @@\n-                target.add(HtmlTree.SPAN(HtmlStyle.modifiers, Text.of(mods)))\n+                target.add(HtmlTree.SPAN(HtmlStyles.modifiers, Text.of(mods)))\n@@ -539,0 +541,1 @@\n+            \/\/ Note return type will be null if this is a constructor.\n@@ -542,1 +545,1 @@\n-                target.add(HtmlTree.SPAN(HtmlStyle.typeParametersLong, typeParameters));\n+                target.add(HtmlTree.SPAN(HtmlStyles.typeParametersLong, typeParameters));\n@@ -544,1 +547,1 @@\n-                target.add(HtmlTree.SPAN(HtmlStyle.typeParameters, typeParameters));\n+                target.add(HtmlTree.SPAN(HtmlStyles.typeParameters, typeParameters));\n@@ -549,0 +552,1 @@\n+            int returnTypeLength = returnType != null ? returnType.charCount() : 0;\n@@ -551,1 +555,1 @@\n-            if (lineLength + returnType.charCount() > RETURN_TYPE_MAX_LINE_LENGTH) {\n+            if (lineLength + returnTypeLength > RETURN_TYPE_MAX_LINE_LENGTH) {\n@@ -575,2 +579,2 @@\n-                target.add(new HtmlTree(TagName.WBR))\n-                        .add(HtmlTree.SPAN(HtmlStyle.parameters, parameters));\n+                target.add(HtmlTree.WBR())\n+                        .add(HtmlTree.SPAN(HtmlStyles.parameters, parameters));\n@@ -585,1 +589,1 @@\n-                        .add(HtmlTree.SPAN(HtmlStyle.exceptions, exceptions));\n+                        .add(HtmlTree.SPAN(HtmlStyles.exceptions, exceptions));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":44,"deletions":40,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+compiler.err.cant.attach.type.annotations               # bad class file\n@@ -57,1 +58,2 @@\n-compiler.misc.bad.runtime.invisible.param.annotations   # bad class file\n+compiler.warn.runtime.invisible.parameter.annotations   # bad class file\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch   # bad class file\n@@ -225,0 +227,4 @@\n+# Pending removal\n+compiler.note.implicit.annotation.processing\n+compiler.warn.proc.use.proc.or.implicit\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,12 +1,12 @@\n-NullabilityInferenceTest.java:23:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:24:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:25:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:26:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String!>>, java.lang.Integer)\n-NullabilityInferenceTest.java:34:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:35:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:36:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:37:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String!>>, java.lang.Integer)\n-NullabilityInferenceTest.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String!>>, java.lang.Integer)\n-NullabilityInferenceTest.java:46:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String!>>, java.lang.Integer)\n-NullabilityInferenceTest.java:47:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String?>>, java.lang.Integer)\n-NullabilityInferenceTest.java:48:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String!>>, java.lang.Integer)\n+NullabilityInferenceTest.java:23:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:24:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:25:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:26:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:34:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:35:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:36:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:37:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:46:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:47:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:48:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityInferenceTest.out","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      8329345\n+ *      8329345 8341061 8340984\n@@ -747,1 +747,5 @@\n-        record Data(String src, boolean isRecord) {}\n+        record Data(String src, boolean isRecord) {\n+            Data(String src) {\n+                this(src, false);\n+            }\n+        }\n@@ -754,1 +758,1 @@\n-                    \"\"\", false),\n+                    \"\"\"),\n@@ -763,1 +767,1 @@\n-                    \"\"\", false),\n+                    \"\"\"),\n@@ -773,1 +777,1 @@\n-                    \"\"\", false),\n+                    \"\"\"),\n@@ -783,1 +787,1 @@\n-                    \"\"\", false),\n+                    \"\"\"),\n@@ -815,1 +819,1 @@\n-                    int j;\n+                    int j = 0;\n@@ -817,1 +821,1 @@\n-                        j = 200;\n+                        System.out.println(j);\n@@ -821,1 +825,1 @@\n-        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,aload_0,sipush,putfield,return,\";\n+        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,iconst_0,putfield,aload_0,invokespecial,getstatic,iconst_0,invokevirtual,return,\";\n@@ -832,1 +836,1 @@\n-                    Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                    Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n@@ -880,0 +884,58 @@\n+        \/*assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+                \"\"\"\n+                value class Test {\n+                    int f;\n+                    {\n+                        f = 1;\n+                    }\n+                }\n+                \"\"\"\n+        );*\/\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+                \"\"\"\n+                value class V {\n+                    int x;\n+                    int y = x + 1; \/\/ allowed\n+                    V1() {\n+                        x = 12;\n+                        \/\/ super();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.var.might.already.be.assigned\",\n+                \"\"\"\n+                value class V2 {\n+                    int x;\n+                    V2() { this(x = 3); } \/\/ error\n+                    V2(int i) { x = 4; }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                abstract value class AV1 {\n+                    AV1(int i) {}\n+                }\n+                value class V3 extends AV1 {\n+                    int x;\n+                    V3() {\n+                        super(x = 3); \/\/ ok\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+                \"\"\"\n+                value class V4 {\n+                    int x;\n+                    int y = x + 1;\n+                    V4() {\n+                        x = 12;\n+                    }\n+                    V4(int i) {\n+                        x = i;\n+                    }\n+                }\n+                \"\"\"\n+        );\n@@ -946,32 +1008,0 @@\n-    @Test\n-    void testAnonymousValue() throws Exception {\n-        assertOK(\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        Object o = new value Comparable<String>() {\n-                            @Override\n-                            public int compareTo(String o) {\n-                                return 0;\n-                            }\n-                        };\n-                    }\n-                }\n-                \"\"\"\n-        );\n-        assertOK(\n-                \"\"\"\n-                class Test {\n-                    void m() {\n-                        Object o = new value Comparable<>() {\n-                            @Override\n-                            public int compareTo(Object o) {\n-                                return 0;\n-                            }\n-                        };\n-                    }\n-                }\n-                \"\"\"\n-        );\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":72,"deletions":42,"binary":false,"changes":114,"status":"modified"}]}