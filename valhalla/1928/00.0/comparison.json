{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,1 @@\n+          --with-external-symbols-in-bundles=none\n","filename":".github\/workflows\/build-cross-compile.yml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,1 @@\n+          --with-external-symbols-in-bundles=none\n","filename":".github\/workflows\/build-linux.yml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,0 +114,1 @@\n+          --with-external-symbols-in-bundles=none\n","filename":".github\/workflows\/build-macos.yml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,1 @@\n+          --with-external-symbols-in-bundles=none\n","filename":".github\/workflows\/build-windows.yml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":".github\/workflows\/main.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+# -XDaccessInternalAPI is a temporary workaround, see 8373909\n@@ -99,1 +100,0 @@\n-    -XDenableValueTypes \\\n@@ -101,1 +101,2 @@\n-    --override-methods=summary\n+    --override-methods=summary \\\n+    -XDaccessInternalAPI\n@@ -107,1 +108,2 @@\n-    -html5 -javafx --expand-requires transitive\n+    -html5 -javafx --expand-requires transitive \\\n+    -XDaccessInternalAPI\n","filename":"make\/Docs.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/autoconf\/hotspot.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -319,2 +319,4 @@\n-      [which type of external native debug symbol information shall be shipped in product bundles (none, public, full)\n-      (e.g. ship full\/stripped pdbs on Windows) @<:@none@:>@])])\n+      [which type of external native debug symbol information shall be shipped with bundles\/images (none, public, full).\n+      @<:@none in release builds, full otherwise. --with-native-debug-symbols=external\/zipped is a prerequisite. public is only supported on Windows@:>@])],\n+      [],\n+      [with_external_symbols_in_bundles=default])\n@@ -325,5 +327,7 @@\n-    if test \"x$OPENJDK_TARGET_OS\" != xwindows ; then\n-      AC_MSG_ERROR([--with-external-symbols-in-bundles currently only works on windows!])\n-    elif test \"x$COPY_DEBUG_SYMBOLS\" != xtrue ; then\n-      AC_MSG_ERROR([--with-external-symbols-in-bundles only works when --with-native-debug-symbols=external is used!])\n-    elif test \"x$with_external_symbols_in_bundles\" = xfull ; then\n+    if test \"x$COPY_DEBUG_SYMBOLS\" != xtrue ; then\n+      AC_MSG_ERROR([--with-external-symbols-in-bundles only works when --with-native-debug-symbols=external\/zipped is used!])\n+    elif test \"x$with_external_symbols_in_bundles\" = xpublic && test \"x$OPENJDK_TARGET_OS\" != xwindows ; then\n+      AC_MSG_ERROR([--with-external-symbols-in-bundles=public is only supported on Windows!])\n+    fi\n+\n+    if test \"x$with_external_symbols_in_bundles\" = xfull ; then\n@@ -336,0 +340,9 @@\n+  elif test \"x$with_external_symbols_in_bundles\" = xdefault ; then\n+    if test \"x$DEBUG_LEVEL\" = xrelease ; then\n+      AC_MSG_RESULT([no (default)])\n+    elif test \"x$COPY_DEBUG_SYMBOLS\" = xtrue ; then\n+      AC_MSG_RESULT([full (default)])\n+      SHIP_DEBUG_SYMBOLS=full\n+    else\n+      AC_MSG_RESULT([no (default, native debug symbols are not external\/zipped)])\n+    fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2571,0 +2571,1 @@\n+\n@@ -2577,1 +2578,1 @@\n-  if (lo != min_jint && hi != max_jint) {\n+  if (lo != min_jint) {\n@@ -2580,0 +2581,2 @@\n+  }\n+  if (hi != max_jint) {\n@@ -2581,9 +2584,1 @@\n-    br(Assembler::LE, L_success);\n-  } else if (lo != min_jint) {\n-    subsw(rtmp, rval, lo);\n-    br(Assembler::GE, L_success);\n-  } else if (hi != max_jint) {\n-    subsw(rtmp, rval, hi);\n-    br(Assembler::LE, L_success);\n-  } else {\n-    ShouldNotReachHere();\n+    br(Assembler::GT, L_failure);\n@@ -2591,0 +2586,1 @@\n+  b(L_success);\n@@ -2614,0 +2610,1 @@\n+\n@@ -2620,1 +2617,1 @@\n-  if (lo != min_jlong && hi != max_jlong) {\n+  if (lo != min_jlong) {\n@@ -2623,0 +2620,2 @@\n+  }\n+  if (hi != max_jlong) {\n@@ -2624,9 +2623,1 @@\n-    br(Assembler::LE, L_success);\n-  } else if (lo != min_jlong) {\n-    subs(rtmp, rval, lo);\n-    br(Assembler::GE, L_success);\n-  } else if (hi != max_jlong) {\n-    subs(rtmp, rval, hi);\n-    br(Assembler::LE, L_success);\n-  } else {\n-    ShouldNotReachHere();\n+    br(Assembler::GT, L_failure);\n@@ -2634,0 +2625,1 @@\n+  b(L_success);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1315,23 +1315,3 @@\n-                                        Register recv, Label* update_done) {\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    \/\/ See if the receiver is receiver[n].\n-    __ cmpptr(recv, Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));\n-    __ jccb(Assembler::notEqual, next_test);\n-    Address data_addr(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));\n-    __ addptr(data_addr, DataLayout::counter_increment);\n-    __ jmp(*update_done);\n-    __ bind(next_test);\n-  }\n-\n-  \/\/ Didn't find receiver; find next empty slot and fill it in\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    Address recv_addr(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));\n-    __ cmpptr(recv_addr, NULL_WORD);\n-    __ jccb(Assembler::notEqual, next_test);\n-    __ movptr(recv_addr, recv);\n-    __ movptr(Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);\n-    __ jmp(*update_done);\n-    __ bind(next_test);\n-  }\n+                                        Register recv) {\n+  int mdp_offset = md->byte_offset_of_slot(data, in_ByteSize(0));\n+  __ profile_receiver_type(recv, mdo, mdp_offset);\n@@ -1396,9 +1376,3 @@\n-      Label update_done;\n-      Register recv = k_RInfo;\n-      __ load_klass(recv, obj, tmp_load_klass);\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-\n-      Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n-\n-      __ bind(update_done);\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj, tmp_load_klass);\n+    type_profile_helper(mdo, md, data, recv);\n@@ -1525,1 +1499,0 @@\n-      Label update_done;\n@@ -1528,5 +1501,1 @@\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-      __ bind(update_done);\n+      type_profile_helper(mdo, md, data, recv);\n@@ -3003,4 +2972,1 @@\n-      \/\/ dynamic tests on the receiver type\n-\n-      \/\/ NOTE: we should probably put a lock around this search to\n-      \/\/ avoid collisions by concurrent compilations\n+      \/\/ dynamic tests on the receiver type.\n@@ -3008,2 +2974,1 @@\n-      uint i;\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n+      for (uint i = 0; i < VirtualCallData::row_limit(); i++) {\n@@ -3017,16 +2982,3 @@\n-\n-      \/\/ Receiver type not found in profile data; select an empty slot\n-\n-      \/\/ Note that this is less efficient than it should be because it\n-      \/\/ always does a write to the receiver part of the\n-      \/\/ VirtualCallData rather than just the first time\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n-        ciKlass* receiver = vc_data->receiver(i);\n-        if (receiver == nullptr) {\n-          Address recv_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));\n-          __ mov_metadata(recv_addr, known_klass->constant_encoding(), rscratch1);\n-          Address data_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));\n-          __ addptr(data_addr, DataLayout::counter_increment);\n-          return;\n-        }\n-      }\n+      \/\/ Receiver type is not found in profile data.\n+      \/\/ Fall back to runtime helper to handle the rest at runtime.\n+      __ mov_metadata(recv, known_klass->constant_encoding());\n@@ -3035,7 +2987,1 @@\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-      \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-      \/\/ Increment total counter to indicate polymorphic case.\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-\n-      __ bind(update_done);\n+    type_profile_helper(mdo, md, data, recv);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":13,"deletions":67,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-                           Register recv, Label* update_done);\n+                           Register recv);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -649,1 +649,2 @@\n-  if (hi == max_jint) {\n+\n+  if (lo != min_jint) {\n@@ -651,6 +652,3 @@\n-    jccb(Assembler::greaterEqual, succeed);\n-  } else {\n-    if (lo != min_jint) {\n-      cmpl(val, lo);\n-      jccb(Assembler::less, fail);\n-    }\n+    jccb(Assembler::less, fail);\n+  }\n+  if (hi != max_jint) {\n@@ -658,1 +656,1 @@\n-    jccb(Assembler::lessEqual, succeed);\n+    jccb(Assembler::greater, fail);\n@@ -660,0 +658,1 @@\n+  jmpb(succeed);\n@@ -698,1 +697,1 @@\n-  if (hi == max_jlong) {\n+  if (lo != min_jlong) {\n@@ -700,6 +699,3 @@\n-    jccb(Assembler::greaterEqual, succeed);\n-  } else {\n-    if (lo != min_jlong) {\n-      cmp_val(lo);\n-      jccb(Assembler::less, fail);\n-    }\n+    jccb(Assembler::less, fail);\n+  }\n+  if (hi != max_jlong) {\n@@ -707,1 +703,1 @@\n-    jccb(Assembler::lessEqual, succeed);\n+    jccb(Assembler::greater, fail);\n@@ -709,0 +705,1 @@\n+  jmpb(succeed);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -585,1 +585,1 @@\n-\/\/      rcx, rdi\n+\/\/      rcx\n@@ -593,1 +593,0 @@\n-  assert(Rsub_klass != rdi, \"rdi holds 2ndary super array scan ptr\");\n@@ -597,1 +596,1 @@\n-    profile_typecheck(rcx, Rsub_klass, rdi); \/\/ blows rcx, reloads rdi\n+    profile_typecheck(rcx, Rsub_klass); \/\/ blows rcx\n@@ -599,1 +598,0 @@\n-\n@@ -1541,1 +1539,0 @@\n-                                                     Register reg2,\n@@ -1561,1 +1558,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2);\n+    profile_receiver_type(receiver, mdp, 0);\n@@ -1570,126 +1567,0 @@\n-\/\/ This routine creates a state machine for updating the multi-row\n-\/\/ type profile at a virtual call site (or other type-sensitive bytecode).\n-\/\/ The machine visits each row (of receiver\/count) until the receiver type\n-\/\/ is found, or until it runs out of rows.  At the same time, it remembers\n-\/\/ the location of the first empty row.  (An empty row records null for its\n-\/\/ receiver, and can be allocated for a newly-observed receiver type.)\n-\/\/ Because there are two degrees of freedom in the state, a simple linear\n-\/\/ search will not work; it must be a decision tree.  Hence this helper\n-\/\/ function is recursive, to generate the required tree structured code.\n-\/\/ It's the interpreter, so we are trading off code space for speed.\n-\/\/ See below for example code.\n-void InterpreterMacroAssembler::record_klass_in_profile_helper(Register receiver, Register mdp,\n-                                                               Register reg2, int start_row,\n-                                                               Label& done) {\n-  if (TypeProfileWidth == 0) {\n-    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-  } else {\n-    record_item_in_profile_helper(receiver, mdp, reg2, 0, done, TypeProfileWidth,\n-                                  &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n-  }\n-}\n-\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n-                                                              Label& done, int total_rows,\n-                                                              OffsetFunction item_offset_fn,\n-                                                              OffsetFunction item_count_offset_fn) {\n-  int last_row = total_rows - 1;\n-  assert(start_row <= last_row, \"must be work left to do\");\n-  \/\/ Test this row for both the item and for null.\n-  \/\/ Take any of three different outcomes:\n-  \/\/   1. found item => increment count and goto done\n-  \/\/   2. found null => keep looking for case 1, maybe allocate this cell\n-  \/\/   3. found something else => keep looking for cases 1 and 2\n-  \/\/ Case 3 is handled by a recursive call.\n-  for (int row = start_row; row <= last_row; row++) {\n-    Label next_test;\n-    bool test_for_null_also = (row == start_row);\n-\n-    \/\/ See if the item is item[n].\n-    int item_offset = in_bytes(item_offset_fn(row));\n-    test_mdp_data_at(mdp, item_offset, item,\n-                     (test_for_null_also ? reg2 : noreg),\n-                     next_test);\n-    \/\/ (Reg2 now contains the item from the CallData.)\n-\n-    \/\/ The item is item[n].  Increment count[n].\n-    int count_offset = in_bytes(item_count_offset_fn(row));\n-    increment_mdp_data_at(mdp, count_offset);\n-    jmp(done);\n-    bind(next_test);\n-\n-    if (test_for_null_also) {\n-      \/\/ Failed the equality check on item[n]...  Test for null.\n-      testptr(reg2, reg2);\n-      if (start_row == last_row) {\n-        \/\/ The only thing left to do is handle the null case.\n-        Label found_null;\n-        jccb(Assembler::zero, found_null);\n-        \/\/ Item did not match any saved item and there is no empty row for it.\n-        \/\/ Increment total counter to indicate polymorphic case.\n-        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-        jmp(done);\n-        bind(found_null);\n-        break;\n-      }\n-      Label found_null;\n-      \/\/ Since null is rare, make it be the branch-taken case.\n-      jcc(Assembler::zero, found_null);\n-\n-      \/\/ Put all the \"Case 3\" tests here.\n-      record_item_in_profile_helper(item, mdp, reg2, start_row + 1, done, total_rows,\n-                                    item_offset_fn, item_count_offset_fn);\n-\n-      \/\/ Found a null.  Keep searching for a matching item,\n-      \/\/ but remember that this is an empty (unused) slot.\n-      bind(found_null);\n-    }\n-  }\n-\n-  \/\/ In the fall-through case, we found no matching item, but we\n-  \/\/ observed the item[start_row] is null.\n-\n-  \/\/ Fill in the item field and increment the count.\n-  int item_offset = in_bytes(item_offset_fn(start_row));\n-  set_mdp_data_at(mdp, item_offset, item);\n-  int count_offset = in_bytes(item_count_offset_fn(start_row));\n-  movl(reg2, DataLayout::counter_increment);\n-  set_mdp_data_at(mdp, count_offset, reg2);\n-  if (start_row > 0) {\n-    jmp(done);\n-  }\n-}\n-\n-\/\/ Example state machine code for three profile rows:\n-\/\/   \/\/ main copy of decision tree, rooted at row[1]\n-\/\/   if (row[0].rec == rec) { row[0].incr(); goto done; }\n-\/\/   if (row[0].rec != nullptr) {\n-\/\/     \/\/ inner copy of decision tree, rooted at row[1]\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[1].rec != nullptr) {\n-\/\/       \/\/ degenerate decision tree, rooted at row[2]\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n-\/\/       row[2].init(rec); goto done;\n-\/\/     } else {\n-\/\/       \/\/ remember row[1] is empty\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       row[1].init(rec); goto done;\n-\/\/     }\n-\/\/   } else {\n-\/\/     \/\/ remember row[0] is empty\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/     row[0].init(rec); goto done;\n-\/\/   }\n-\/\/   done:\n-\n-void InterpreterMacroAssembler::record_klass_in_profile(Register receiver, Register mdp, Register reg2) {\n-  assert(ProfileInterpreter, \"must be profiling\");\n-  Label done;\n-\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n-\n-  bind (done);\n-}\n-\n@@ -1755,1 +1626,1 @@\n-void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass, Register reg2) {\n+void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass) {\n@@ -1768,1 +1639,1 @@\n-      record_klass_in_profile(klass, mdp, reg2);\n+      profile_receiver_type(klass, mdp, 0);\n@@ -1883,1 +1754,1 @@\n-    record_klass_in_profile(tmp, mdp, tmp2);\n+    profile_receiver_type(tmp, mdp, 0);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":6,"deletions":135,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -254,7 +254,0 @@\n-  void record_klass_in_profile(Register receiver, Register mdp, Register reg2);\n-  void record_klass_in_profile_helper(Register receiver, Register mdp, Register reg2, int start_row, Label &done);\n-  void record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n-                                     Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn,\n-                                     OffsetFunction item_count_offset_fn);\n-\n@@ -271,1 +264,0 @@\n-                            Register scratch2,\n@@ -275,1 +267,1 @@\n-  void profile_typecheck(Register mdp, Register klass, Register scratch);\n+  void profile_typecheck(Register mdp, Register klass);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5020,0 +5020,197 @@\n+\/\/ Handle the receiver type profile update given the \"recv\" klass.\n+\/\/\n+\/\/ Normally updates the ReceiverData (RD) that starts at \"mdp\" + \"mdp_offset\".\n+\/\/ If there are no matching or claimable receiver entries in RD, updates\n+\/\/ the polymorphic counter.\n+\/\/\n+\/\/ This code expected to run by either the interpreter or JIT-ed code, without\n+\/\/ extra synchronization. For safety, receiver cells are claimed atomically, which\n+\/\/ avoids grossly misrepresenting the profiles under concurrent updates. For speed,\n+\/\/ counter updates are not atomic.\n+\/\/\n+void MacroAssembler::profile_receiver_type(Register recv, Register mdp, int mdp_offset) {\n+  int base_receiver_offset   = in_bytes(ReceiverTypeData::receiver_offset(0));\n+  int end_receiver_offset    = in_bytes(ReceiverTypeData::receiver_offset(ReceiverTypeData::row_limit()));\n+  int poly_count_offset      = in_bytes(CounterData::count_offset());\n+  int receiver_step          = in_bytes(ReceiverTypeData::receiver_offset(1)) - base_receiver_offset;\n+  int receiver_to_count_step = in_bytes(ReceiverTypeData::receiver_count_offset(0)) - base_receiver_offset;\n+\n+  \/\/ Adjust for MDP offsets. Slots are pointer-sized, so is the global offset.\n+  assert(is_aligned(mdp_offset, BytesPerWord), \"sanity\");\n+  base_receiver_offset += mdp_offset;\n+  end_receiver_offset  += mdp_offset;\n+  poly_count_offset    += mdp_offset;\n+\n+  \/\/ Scale down to optimize encoding. Slots are pointer-sized.\n+  assert(is_aligned(base_receiver_offset,   BytesPerWord), \"sanity\");\n+  assert(is_aligned(end_receiver_offset,    BytesPerWord), \"sanity\");\n+  assert(is_aligned(poly_count_offset,      BytesPerWord), \"sanity\");\n+  assert(is_aligned(receiver_step,          BytesPerWord), \"sanity\");\n+  assert(is_aligned(receiver_to_count_step, BytesPerWord), \"sanity\");\n+  base_receiver_offset   >>= LogBytesPerWord;\n+  end_receiver_offset    >>= LogBytesPerWord;\n+  poly_count_offset      >>= LogBytesPerWord;\n+  receiver_step          >>= LogBytesPerWord;\n+  receiver_to_count_step >>= LogBytesPerWord;\n+\n+#ifdef ASSERT\n+  \/\/ We are about to walk the MDO slots without asking for offsets.\n+  \/\/ Check that our math hits all the right spots.\n+  for (uint c = 0; c < ReceiverTypeData::row_limit(); c++) {\n+    int real_recv_offset  = mdp_offset + in_bytes(ReceiverTypeData::receiver_offset(c));\n+    int real_count_offset = mdp_offset + in_bytes(ReceiverTypeData::receiver_count_offset(c));\n+    int offset = base_receiver_offset + receiver_step*c;\n+    int count_offset = offset + receiver_to_count_step;\n+    assert((offset << LogBytesPerWord) == real_recv_offset, \"receiver slot math\");\n+    assert((count_offset << LogBytesPerWord) == real_count_offset, \"receiver count math\");\n+  }\n+  int real_poly_count_offset = mdp_offset + in_bytes(CounterData::count_offset());\n+  assert(poly_count_offset << LogBytesPerWord == real_poly_count_offset, \"poly counter math\");\n+#endif\n+\n+  \/\/ Corner case: no profile table. Increment poly counter and exit.\n+  if (ReceiverTypeData::row_limit() == 0) {\n+    addptr(Address(mdp, poly_count_offset, Address::times_ptr), DataLayout::counter_increment);\n+    return;\n+  }\n+\n+  Register offset = rscratch1;\n+\n+  Label L_loop_search_receiver, L_loop_search_empty;\n+  Label L_restart, L_found_recv, L_found_empty, L_polymorphic, L_count_update;\n+\n+  \/\/ The code here recognizes three major cases:\n+  \/\/   A. Fastest: receiver found in the table\n+  \/\/   B. Fast: no receiver in the table, and the table is full\n+  \/\/   C. Slow: no receiver in the table, free slots in the table\n+  \/\/\n+  \/\/ The case A performance is most important, as perfectly-behaved code would end up\n+  \/\/ there, especially with larger TypeProfileWidth. The case B performance is\n+  \/\/ important as well, this is where bulk of code would land for normally megamorphic\n+  \/\/ cases. The case C performance is not essential, its job is to deal with installation\n+  \/\/ races, we optimize for code density instead. Case C needs to make sure that receiver\n+  \/\/ rows are only claimed once. This makes sure we never overwrite a row for another\n+  \/\/ receiver and never duplicate the receivers in the list, making profile type-accurate.\n+  \/\/\n+  \/\/ It is very tempting to handle these cases in a single loop, and claim the first slot\n+  \/\/ without checking the rest of the table. But, profiling code should tolerate free slots\n+  \/\/ in the table, as class unloading can clear them. After such cleanup, the receiver\n+  \/\/ we need might be _after_ the free slot. Therefore, we need to let at least full scan\n+  \/\/ to complete, before trying to install new slots. Splitting the code in several tight\n+  \/\/ loops also helpfully optimizes for cases A and B.\n+  \/\/\n+  \/\/ This code is effectively:\n+  \/\/\n+  \/\/ restart:\n+  \/\/   \/\/ Fastest: receiver is already installed\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == recv) goto found_recv(i);\n+  \/\/   }\n+  \/\/\n+  \/\/   \/\/ Fast: no receiver, but profile is full\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == null) goto found_null(i);\n+  \/\/   }\n+  \/\/   goto polymorphic\n+  \/\/\n+  \/\/   \/\/ Slow: try to install receiver\n+  \/\/ found_null(i):\n+  \/\/   CAS(&receiver(i), null, recv);\n+  \/\/   goto restart\n+  \/\/\n+  \/\/ polymorphic:\n+  \/\/   count++;\n+  \/\/   return\n+  \/\/\n+  \/\/ found_recv(i):\n+  \/\/   *receiver_count(i)++\n+  \/\/\n+\n+  bind(L_restart);\n+\n+  \/\/ Fastest: receiver is already installed\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop_search_receiver);\n+    cmpptr(recv, Address(mdp, offset, Address::times_ptr));\n+    jccb(Assembler::equal, L_found_recv);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop_search_receiver);\n+\n+  \/\/ Fast: no receiver, but profile is full\n+  movptr(offset, base_receiver_offset);\n+  bind(L_loop_search_empty);\n+    cmpptr(Address(mdp, offset, Address::times_ptr), NULL_WORD);\n+    jccb(Assembler::equal, L_found_empty);\n+  addptr(offset, receiver_step);\n+  cmpptr(offset, end_receiver_offset);\n+  jccb(Assembler::notEqual, L_loop_search_empty);\n+  jmpb(L_polymorphic);\n+\n+  \/\/ Slow: try to install receiver\n+  bind(L_found_empty);\n+\n+  \/\/ Atomically swing receiver slot: null -> recv.\n+  \/\/\n+  \/\/ The update code uses CAS, which wants RAX register specifically, *and* it needs\n+  \/\/ other important registers untouched, as they form the address. Therefore, we need\n+  \/\/ to shift any important registers from RAX into some other spare register. If we\n+  \/\/ have a spare register, we are forced to save it on stack here.\n+\n+  Register spare_reg = noreg;\n+  Register shifted_mdp = mdp;\n+  Register shifted_recv = recv;\n+  if (recv == rax || mdp == rax) {\n+    spare_reg = (recv != rbx && mdp != rbx) ? rbx :\n+                (recv != rcx && mdp != rcx) ? rcx :\n+                rdx;\n+    assert_different_registers(mdp, recv, offset, spare_reg);\n+\n+    push(spare_reg);\n+    if (recv == rax) {\n+      movptr(spare_reg, recv);\n+      shifted_recv = spare_reg;\n+    } else {\n+      assert(mdp == rax, \"Remaining case\");\n+      movptr(spare_reg, mdp);\n+      shifted_mdp = spare_reg;\n+    }\n+  } else {\n+    push(rax);\n+  }\n+\n+  \/\/ None of the important registers are in RAX after this shuffle.\n+  assert_different_registers(rax, shifted_mdp, shifted_recv, offset);\n+\n+  xorptr(rax, rax);\n+  cmpxchgptr(shifted_recv, Address(shifted_mdp, offset, Address::times_ptr));\n+\n+  \/\/ Unshift registers.\n+  if (recv == rax || mdp == rax) {\n+    movptr(rax, spare_reg);\n+    pop(spare_reg);\n+  } else {\n+    pop(rax);\n+  }\n+\n+  \/\/ CAS success means the slot now has the receiver we want. CAS failure means\n+  \/\/ something had claimed the slot concurrently: it can be the same receiver we want,\n+  \/\/ or something else. Since this is a slow path, we can optimize for code density,\n+  \/\/ and just restart the search from the beginning.\n+  jmpb(L_restart);\n+\n+  \/\/ Counter updates:\n+\n+  \/\/ Increment polymorphic counter instead of receiver slot.\n+  bind(L_polymorphic);\n+  movptr(offset, poly_count_offset);\n+  jmpb(L_count_update);\n+\n+  \/\/ Found a receiver, convert its slot offset to corresponding count offset.\n+  bind(L_found_recv);\n+  addptr(offset, receiver_to_count_step);\n+\n+  bind(L_count_update);\n+  addptr(Address(mdp, offset, Address::times_ptr), DataLayout::counter_increment);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":197,"deletions":0,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -724,0 +724,2 @@\n+  void profile_receiver_type(Register recv, Register mdp, int mdp_offset);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3471,1 +3471,1 @@\n-  __ profile_virtual_call(rax, rlocals, rdx);\n+  __ profile_virtual_call(rax, rlocals);\n@@ -3612,1 +3612,1 @@\n-  __ profile_virtual_call(rdx, rbcp, rlocals);\n+  __ profile_virtual_call(rdx, rbcp);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-    return (address)0;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-                                              size_t length) {\n+                                               size_t length) {\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,1 +1221,1 @@\n-C2V_VMENTRY_0(jobject, getInvalidationReasonDescription, (JNIEnv *env, jobject, jint invalidation_reason))\n+C2V_VMENTRY_NULL(jobject, getInvalidationReasonDescription, (JNIEnv *env, jobject, jint invalidation_reason))\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,8 +65,0 @@\n-\/\/    [0 ............ 0| 00]  inflating          inflation in progress (stack-locking in use)\n-\/\/\n-\/\/    We assume that stack\/thread pointers have the lowest two bits cleared.\n-\/\/\n-\/\/\n-\/\/  - INFLATING() is a distinguished markword value of all zeros that is\n-\/\/    used when inflating an existing stack-lock into an ObjectMonitor.\n-\/\/    See below for is_being_inflated() and INFLATING().\n@@ -233,13 +225,0 @@\n-  \/\/ Special temporary state of the markWord while being inflated.\n-  \/\/ Code that looks at mark outside a lock need to take this into account.\n-  bool is_being_inflated() const { return (value() == 0); }\n-\n-  \/\/ Distinguished markword value - used when inflating over\n-  \/\/ an existing stack-lock.  0 indicates the markword is \"BUSY\".\n-  \/\/ Lockword mutators that use a LD...CAS idiom should always\n-  \/\/ check for and avoid overwriting a 0 value installed by some\n-  \/\/ other thread.  (They should spin or block instead.  The 0 value\n-  \/\/ is transient and *should* be short-lived).\n-  \/\/ Fast-locking does not use INFLATING.\n-  static markWord INFLATING() { return zero(); }    \/\/ inflate-in-progress\n-\n@@ -270,0 +249,3 @@\n+  markWord set_has_monitor() const {\n+    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  }\n@@ -276,21 +258,1 @@\n-  bool has_displaced_mark_helper() const {\n-    intptr_t lockbits = value() & lock_mask_in_place;\n-    return !UseObjectMonitorTable && lockbits == monitor_value;\n-  }\n-  markWord displaced_mark_helper() const;\n-  void set_displaced_mark_helper(markWord m) const;\n-  markWord copy_set_hash(intptr_t hash) const {\n-    uintptr_t tmp = value() & (~hash_mask_in_place);\n-    tmp |= ((hash & hash_mask) << hash_shift);\n-    return markWord(tmp);\n-  }\n-  \/\/ it is only used to be stored into BasicLock as the\n-  \/\/ indicator that the lock is using heavyweight monitor\n-  static markWord unused_mark() {\n-    return markWord(marked_value);\n-  }\n-  \/\/ the following two functions create the markWord to be\n-  \/\/ stored into object header, it encodes monitor info\n-  static markWord encode(BasicLock* lock) {\n-    return from_pointer(lock);\n-  }\n+\n@@ -303,2 +265,3 @@\n-  markWord set_has_monitor() const {\n-    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  bool has_displaced_mark_helper() const {\n+    intptr_t lockbits = value() & lock_mask_in_place;\n+    return !UseObjectMonitorTable && lockbits == monitor_value;\n@@ -306,0 +269,2 @@\n+  markWord displaced_mark_helper() const;\n+  void set_displaced_mark_helper(markWord m) const;\n@@ -358,0 +323,6 @@\n+  markWord copy_set_hash(intptr_t hash) const {\n+    uintptr_t tmp = value() & (~hash_mask_in_place);\n+    tmp |= ((hash & hash_mask) << hash_shift);\n+    return markWord(tmp);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":15,"deletions":44,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1174,0 +1174,2 @@\n+\/\/ Updated by platform-specific code, for example MacroAssembler::profile_receiver_type.\n+\/\/\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1343,0 +1343,4 @@\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n@@ -1540,0 +1544,2 @@\n+          \/\/ The graph could be dying (i.e. x is top) in which case type(x) is not a long.\n+          const TypeLong* x_long = phase->type(x)->isa_long();\n@@ -1541,1 +1547,1 @@\n-          if (can_overflow(phase->type(x)->is_long(), con1->get_long() + con2->get_long())) {\n+          if (x_long == nullptr || can_overflow(x_long, con1->get_long() + con2->get_long())) {\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1566,12 +1566,3 @@\n-      if (u->is_Phi() && u->as_Phi()->type() == Type::MEMORY &&\n-          u->adr_type() == TypePtr::BOTTOM && u->in(0) == phi_reg &&\n-          u->req() == phi_len) {\n-        for (uint j = 1; j < phi_len; j++) {\n-          if (in(j) != u->in(j)) {\n-            u = nullptr;\n-            break;\n-          }\n-        }\n-        if (u != nullptr) {\n-          return u;\n-        }\n+      assert(!u->is_Phi() || u->in(0) == phi_reg, \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->req() == phi_len && can_be_replaced_by(u->as_Phi())) {\n+        return u;\n@@ -2767,1 +2758,1 @@\n-              phi->set_req(i, mms.memory2());\n+              phi->set_req_X(i, mms.memory2(), phase);\n@@ -2776,1 +2767,3 @@\n-              if (phi->in(i) == this)  phi->set_req(i, phi);\n+              if (phi->in(i) == this) {\n+                phi->set_req_X(i, phi, phase);\n+              }\n@@ -2911,0 +2904,19 @@\n+  \/\/ PhiNode::Identity replaces a non-bottom memory phi with a bottom memory phi with the same inputs, if it exists.\n+  \/\/ If the bottom memory phi's inputs are changed (so it can now replace the non-bottom memory phi) or if it's created\n+  \/\/ only after the non-bottom memory phi is processed by igvn, PhiNode::Identity doesn't run and the transformation\n+  \/\/ doesn't happen.\n+  \/\/ Look for non-bottom Phis that should be transformed and enqueue them for igvn so that PhiNode::Identity executes for\n+  \/\/ them.\n+  if (can_reshape && type() == Type::MEMORY && adr_type() == TypePtr::BOTTOM) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    uint phi_len = req();\n+    Node* phi_reg = region();\n+    for (DUIterator_Fast imax, i = phi_reg->fast_outs(imax); i < imax; i++) {\n+      Node* u = phi_reg->fast_out(i);\n+      assert(!u->is_Phi() || (u->in(0) == phi_reg && u->req() == phi_len), \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->as_Phi()->can_be_replaced_by(this)) {\n+        igvn->_worklist.push(u);\n+      }\n+    }\n+  }\n+\n@@ -3055,0 +3067,5 @@\n+bool PhiNode::can_be_replaced_by(const PhiNode* other) const {\n+  return type() == Type::MEMORY && other->type() == Type::MEMORY && adr_type() != TypePtr::BOTTOM &&\n+    other->adr_type() == TypePtr::BOTTOM && has_same_inputs_as(other);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+  bool can_be_replaced_by(const PhiNode* other) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -3954,0 +3954,1 @@\n+  record_for_igvn(membar);\n@@ -3983,0 +3984,1 @@\n+  record_for_igvn(membar);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1883,0 +1883,1 @@\n+      n->Opcode() != Op_CreateEx &&\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1226,1 +1226,1 @@\n-  } else if ((this->is_Load() || this->is_DecodeN() || this->is_Phi()) && n->Opcode() == Op_MemBarAcquire) {\n+  } else if ((this->is_Load() || this->is_DecodeN() || this->is_Phi() || this->is_Con()) && n->Opcode() == Op_MemBarAcquire) {\n@@ -2892,10 +2892,3 @@\n-            use->req() == req()) {\n-          uint j;\n-          for (j = 0; j < use->req(); j++) {\n-            if (use->in(j) != in(j)) {\n-              break;\n-            }\n-          }\n-          if (j == use->req()) {\n-            return use;\n-          }\n+            use->req() == req() &&\n+            has_same_inputs_as(use)) {\n+          return use;\n@@ -2909,0 +2902,10 @@\n+bool Node::has_same_inputs_as(const Node* other) const {\n+  assert(req() == other->req(), \"should have same number of inputs\");\n+  for (uint j = 0; j < other->req(); j++) {\n+    if (in(j) != other->in(j)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1202,0 +1202,1 @@\n+  bool has_same_inputs_as(const Node* other) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+WB_ENTRY(jlong, WB_GetMinimumJavaStackSize(JNIEnv* env, jobject o))\n+  return os::get_minimum_java_stack_size();\n+WB_END\n+\n@@ -3249,1 +3253,2 @@\n-  {CC\"lockAndStuckInSafepoint\", CC\"()V\", (void*)&WB_TakeLockAndHangInSafepoint},\n+  {CC\"lockAndStuckInSafepoint\", CC\"()V\",              (void*)&WB_TakeLockAndHangInSafepoint},\n+  {CC\"getMinimumJavaStackSize\", CC\"()J\",              (void*)&WB_GetMinimumJavaStackSize},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1762,2 +1762,2 @@\n-      assert(bcp != 0 || m->is_native(), \"\");\n-      at_sync_method = m->is_synchronized() && (bcp == 0 || bcp == m->code_base());\n+      assert(bcp != nullptr || m->is_native(), \"\");\n+      at_sync_method = m->is_synchronized() && (bcp == nullptr || bcp == m->code_base());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,0 +812,1 @@\n+          range(0, 1024)                                                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1056,1 +1056,5 @@\n-  if (is_obj_deopt_suspend()) {\n+  \/\/ We mustn't block for object deopt if the thread is\n+  \/\/ currently executing in a JNI critical region, as that\n+  \/\/ can cause deadlock because allocation may be locked out\n+  \/\/ and the object deopt suspender may try to allocate.\n+  if (is_obj_deopt_suspend() && !in_critical()) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/jfieldIDWorkaround.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,6 +277,6 @@\n-  if (a->is_objArray()) {\n-    if (value_type == T_OBJECT) {\n-      oop obj = cast_to_oop(value->l);\n-      if (a->is_null_free_array() && obj == nullptr) {\n-         THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"null-restricted array\");\n-      }\n+  if (value_type == T_OBJECT) {\n+    assert(a->is_objArray(), \"just checking\");\n+    oop obj = cast_to_oop(value->l);\n+    if (a->is_null_free_array() && obj == nullptr) {\n+      THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"null-restricted array\");\n+    }\n@@ -284,5 +284,4 @@\n-      if (obj != nullptr) {\n-        Klass* element_klass = ObjArrayKlass::cast(a->klass())->element_klass();\n-        if (!obj->is_a(element_klass)) {\n-          THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"array element type mismatch\");\n-        }\n+    if (obj != nullptr) {\n+      Klass* element_klass = ObjArrayKlass::cast(a->klass())->element_klass();\n+      if (!obj->is_a(element_klass)) {\n+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"array element type mismatch\");\n@@ -290,1 +289,1 @@\n-      objArrayOop(a)->obj_at_put(index, obj);\n+    objArrayOop(a)->obj_at_put(index, obj);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3861,1 +3861,1 @@\n-    current->push_cont_fastpath(sender.sp());\n+    current->push_cont_fastpath(sender.unextended_sp());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,5 +94,2 @@\n-void DCmd::register_dcmds(){\n-  \/\/ Registration of the diagnostic commands\n-  \/\/ First argument specifies which interfaces will export the command\n-  \/\/ Second argument specifies if the command is enabled\n-  \/\/ Third  argument specifies if the command is hidden\n+void DCmd::register_dcmds() {\n+  \/\/ Argument specifies on which interfaces a command is made available:\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,8 +227,0 @@\n-    public static void releaseByteBuffer(ByteBuffer buffer) {\n-        Objects.requireNonNull(buffer);\n-\n-        if (!MAP_ALL) {\n-            ImageBufferCache.releaseBuffer(buffer);\n-        }\n-    }\n-\n@@ -419,0 +411,1 @@\n+        int checkedOffset = (int) offset;\n@@ -421,1 +414,1 @@\n-            throw new IndexOutOfBoundsException(\"Bad size: \" + size);\n+            throw new IllegalArgumentException(\"Bad size: \" + size);\n@@ -423,0 +416,1 @@\n+        int checkedSize = (int) size;\n@@ -425,1 +419,1 @@\n-            ByteBuffer buffer = slice(memoryMap, (int)offset, (int)size);\n+            ByteBuffer buffer = slice(memoryMap, checkedOffset, checkedSize);\n@@ -433,2 +427,1 @@\n-\n-            ByteBuffer buffer = ImageBufferCache.getBuffer(size);\n+            ByteBuffer buffer = ByteBuffer.allocate(checkedSize);\n@@ -437,1 +430,1 @@\n-                read = channel.read(buffer, offset);\n+                read = channel.read(buffer, checkedOffset);\n@@ -440,1 +433,0 @@\n-                ImageBufferCache.releaseBuffer(buffer);\n@@ -444,2 +436,1 @@\n-            if (read != size) {\n-                ImageBufferCache.releaseBuffer(buffer);\n+            if (read != checkedSize) {\n@@ -447,1 +438,1 @@\n-                                           \" instead of \" + size + \" bytes\");\n+                        \" instead of \" + checkedSize + \" bytes\");\n@@ -463,9 +454,1 @@\n-\n-        if (buffer != null) {\n-            byte[] bytes = getBufferBytes(buffer);\n-            ImageBufferCache.releaseBuffer(buffer);\n-\n-            return bytes;\n-        }\n-\n-        return null;\n+        return buffer != null ? getBufferBytes(buffer) : null;\n@@ -474,0 +457,3 @@\n+    \/**\n+     * Returns the content of jimage location in a newly allocated byte buffer.\n+     *\/\n@@ -494,1 +480,0 @@\n-\n@@ -497,1 +482,0 @@\n-                ImageBufferCache.releaseBuffer(buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,14 +210,1 @@\n-     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n-     * {@link #getResourceBuffer(Node)}.\n-     *\n-     * <p>Note that no testing is performed to check whether the buffer about\n-     * to be released actually came from a call to {@code getResourceBuffer()}.\n-     *\/\n-    public static void releaseByteBuffer(ByteBuffer buffer) {\n-        BasicImageReader.releaseByteBuffer(buffer);\n-    }\n-\n-    \/**\n-     * Returns the content of a resource node in a possibly cached byte buffer.\n-     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n-     * when they are finished with it.\n+     * Returns the content of a resource node in a newly allocated byte buffer.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,6 +468,0 @@\n-        }\n-\n-        @Override\n-        public void release(ByteBuffer bb) {\n-            Objects.requireNonNull(bb);\n-            ImageReader.releaseByteBuffer(bb);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  EXPECT_FALSE(mark.is_being_inflated());\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,7 +143,0 @@\n-serviceability_ttf_virtual = \\\n-  serviceability\/ \\\n-  -serviceability\/jvmti\/vthread \\\n-  -serviceability\/jvmti\/thread  \\\n-  -serviceability\/jvmti\/events  \\\n-  -serviceability\/jvmti\/negative\n-\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/BMITestRunner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/UncaughtNativeExceptionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,3 +42,4 @@\n-# The test uses \"--add-modules jdk.internal.le\" during production.\n-# So the test is incompatible with AOT_JDK testing because because all runs must have consistent module options on the command line.\n-java\/lang\/IO\/IO.java                                           0000000 generic-all\n+# This test checks for a warning message that's already printed by\n+# sun.util.locale.BaseLocale.<clinit> during the training run. Because BaseLocale is aot-initialized,\n+# this message will not be printed in the production run.\n+java\/util\/Locale\/UseOldISOCodesTest.java                       0000000 generic-all\n","filename":"test\/jdk\/ProblemList-AotJdk.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -797,1 +797,0 @@\n-tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java 8372801 generic-all\n@@ -815,0 +814,2 @@\n+\n+tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java 8375574 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+        map.put(\"jdk.explodedImage\", this::explodedImage);\n@@ -755,0 +756,14 @@\n+    private String explodedImage() {\n+        try {\n+            Path jmodFile = Path.of(System.getProperty(\"java.home\"), \"jmods\", \"java.base.jmod\");\n+            if (Files.exists(jmodFile)) {\n+                return Boolean.FALSE.toString();\n+            } else {\n+                return Boolean.TRUE.toString();\n+            }\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            return errorWithMessage(\"Error in explodedImage \" + t);\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  public native long getMinimumJavaStackSize();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}