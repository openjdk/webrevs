{"files":[{"patch":"@@ -5329,5 +5329,0 @@\n-            if (c.type.isValueClass()) {\n-                final Env<AttrContext> env = typeEnvs.get(c);\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n-                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2435,39 +2435,0 @@\n-    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n-    void checkNonCyclicMembership(JCClassDecl tree) {\n-        if (allowValueClasses) {\n-            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-            try {\n-                tree.sym.flags_field |= LOCKED;\n-                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (l.head.hasTag(VARDEF)) {\n-                        JCVariableDecl field = (JCVariableDecl) l.head;\n-                        if (cyclePossible(field.sym)) {\n-                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n-                        }\n-                    }\n-                }\n-            } finally {\n-                tree.sym.flags_field &= ~LOCKED;\n-            }\n-        }\n-    }\n-    \/\/ where\n-    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n-        if ((c.flags_field & LOCKED) != 0) {\n-            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n-            return;\n-        }\n-        try {\n-            c.flags_field |= LOCKED;\n-            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n-                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n-            }\n-        } finally {\n-            c.flags_field &= ~LOCKED;\n-        }\n-    }\n-        \/\/ where\n-        private boolean cyclePossible(VarSymbol symbol) {\n-            return false; \/\/ (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2825,2 +2825,0 @@\n-        \/\/ we need to do some checks now that the class has been loaded\n-        checkNonCyclicMembership(c);\n@@ -3096,51 +3094,0 @@\n-\n-    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n-    void checkNonCyclicMembership(ClassSymbol csym) {\n-        if (!allowValueClasses) {\n-            \/\/ nothing to see here\n-            return;\n-        }\n-        Assert.check((csym.flags_field & LOCKED) == 0);\n-        try {\n-            ListBuffer<Symbol> fields = new ListBuffer<>();\n-            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n-            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n-                fields.add(field);\n-            }\n-            csym.flags_field |= LOCKED;\n-            for (Symbol field : fields) {\n-                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n-            }\n-        } finally {\n-            csym.flags_field &= ~LOCKED;\n-        }\n-    }\n-    \/\/ where\n-    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n-        if ((c.flags_field & LOCKED) != 0) {\n-            JavaFileObject prevSource = log.useSource(currentClassFile);\n-            try {\n-                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n-                return;\n-            } finally {\n-                log.useSource(prevSource);\n-            }\n-        }\n-        try {\n-            ListBuffer<Symbol> fields = new ListBuffer<>();\n-            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n-            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n-                fields.add(fld);\n-            }\n-            c.flags_field |= LOCKED;\n-            for (Symbol field : fields) {\n-                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n-            }\n-        } finally {\n-            c.flags_field &= ~LOCKED;\n-        }\n-    }\n-    \/\/ where\n-    private boolean cyclePossible(VarSymbol symbol) {\n-        return false; \/\/(symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -4056,4 +4056,0 @@\n-# 0: symbol\n-compiler.err.cyclic.primitive.class.membership=\\\n-    cyclic value class membership involving {0}\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}