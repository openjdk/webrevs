{"files":[{"patch":"@@ -594,2 +594,1 @@\n-      SafePointNode* map = _caller->map();\n-      Node* receiver_in_caller = map->argument(_caller, 0)->as_InlineType();\n+      Node* receiver_in_caller = _caller->map()->argument(_caller, 0);\n@@ -688,1 +687,0 @@\n-  Node* receiver_in_caller = local(0);\n@@ -815,1 +813,0 @@\n-  }\n@@ -817,8 +814,9 @@\n-  \/\/ Did we inline a value class constructor from another value class constructor?\n-  if (cg->is_inline() && cg->method()->is_object_constructor() && cg->method()->holder()->is_inlinetype() &&\n-      _method->is_object_constructor() && cg->method()->holder()->is_inlinetype() && receiver_in_caller == receiver) {\n-    \/\/ Update the receiver in the exit map because the constructor call updated it.\n-    \/\/ MethodLiveness::BasicBlock::compute_gen_kill_single ensures that the receiver in local(0) is live.\n-    assert(local(0)->is_InlineType(), \"Unexpected receiver\");\n-    assert(receiver->bottom_type()->inline_klass() == local(0)->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n-    _exits.map()->replace_edge(receiver, local(0), &_gvn);\n+    \/\/ Did we inline a value class constructor from another value class constructor?\n+    if (_caller->has_method() && cg->is_inline() && cg->method()->is_object_constructor() && cg->method()->holder()->is_inlinetype() &&\n+        _method->is_object_constructor() && _method->holder()->is_inlinetype() && receiver == _caller->map()->argument(_caller, 0)) {\n+      \/\/ Update the receiver in the exit map because the constructor call updated it.\n+      \/\/ MethodLiveness::BasicBlock::compute_gen_kill_single ensures that the receiver in local(0) is still live.\n+      assert(local(0)->is_InlineType(), \"Unexpected receiver\");\n+      assert(receiver->bottom_type()->inline_klass() == local(0)->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n+      _exits.map()->replace_edge(receiver, local(0), &_gvn);\n+    }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -963,0 +963,2 @@\n+\n+  JVMState* callee_jvms = nullptr;\n@@ -989,8 +991,5 @@\n-        call->set_req(p++, in_map->in(k+j));\n-        Node* local = in_map->in(k+j);\n-        \/\/ TODO 8325106\n-        \/*\n-        if (false && local->is_InlineType() && local->isa_InlineType()->is_larval()) {\n-          tty->print_cr(\"LARVAL FOUND in LOCAL\");\n-          in_map->dump(0);\n-          local->dump(0);\n+        Node* val = in_map->in(k + j);\n+        \/\/ Check if there's a larval that has been written in the callee state (constructor) and update it in the caller state\n+        if (val->is_InlineType() && val->isa_InlineType()->is_larval() && callee_jvms != nullptr &&\n+            callee_jvms->method()->is_object_constructor() && callee_jvms->method()->holder()->is_inlinetype() && val == in_map->argument(in_jvms, 0)) {\n+          val = callee_jvms->map()->local(callee_jvms, 0); \/\/ Receiver\n@@ -998,1 +997,1 @@\n-        *\/\n+        call->set_req(p++, val);\n@@ -1010,11 +1009,5 @@\n-        call->set_req(p++, in_map->in(k+j));\n-        Node* local = in_map->in(k+j);\n-        \/\/ TODO 8325106 check if there's a larval on stack in the caller state that has been written in the callee state and update it accordingly\n-        \/*\n-        if (false && local->is_InlineType() && local->isa_InlineType()->is_larval()) {\n-          tty->print_cr(\"LARVAL FOUND on STACK\");\n-          in_map->dump(0);\n-          local->dump(0);\n-          map()->replaced_nodes().dump(tty);\n-          map()->replaced_nodes().apply(call, 0);\n-          tty->print_cr(\"\");\n+        Node* val = in_map->in(k + j);\n+        \/\/ Check if there's a larval that has been written in the callee state (constructor) and update it in the caller state\n+        if (val->is_InlineType() && val->isa_InlineType()->is_larval() && callee_jvms != nullptr &&\n+            callee_jvms->method()->is_object_constructor() && callee_jvms->method()->holder()->is_inlinetype() && val == in_map->argument(in_jvms, 0)) {\n+          val = callee_jvms->map()->local(callee_jvms, 0); \/\/ Receiver\n@@ -1022,1 +1015,1 @@\n-        *\/\n+        call->set_req(p++, val);\n@@ -1062,0 +1055,1 @@\n+    callee_jvms = out_jvms;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -259,0 +259,7 @@\n+  \/\/ Don't scalarize larvals in their own constructor call because the constructor will update them\n+  if (is_larval() && sfpt->is_CallJava() && sfpt->as_CallJava()->method() != nullptr && sfpt->as_CallJava()->method()->is_object_constructor() &&\n+      sfpt->as_CallJava()->method()->holder()->is_inlinetype() && sfpt->in(TypeFunc::Parms) == this) {\n+    assert(is_allocated(igvn), \"receiver must be allocated\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -252,2 +252,1 @@\n-      int nargs = 1 + field->type()->size();\n-      inc_sp(nargs);\n+      inc_sp(1);\n@@ -267,2 +266,1 @@\n-      int nargs = 1 + field->type()->size();\n-      inc_sp(nargs);\n+      inc_sp(1);\n@@ -278,2 +276,1 @@\n-      int nargs = 1 + field->type()->size();\n-      inc_sp(nargs);\n+      inc_sp(1);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    if (TraceDeoptimization) {\n+    if (TraceDeoptimization && objects != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,2 +242,0 @@\n-        \/\/ TODO 8325106 Fix and re-enable\n-        \/*\n@@ -285,1 +283,0 @@\n-        *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.util.Random;\n+\n@@ -27,0 +29,2 @@\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n@@ -31,1 +35,2 @@\n- * @library \/testlibrary \/test\/lib \/\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n@@ -33,1 +38,7 @@\n- * @run main\/othervm -XX:+EnableValhalla -Xbatch\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -35,1 +46,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -37,0 +48,1 @@\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -38,1 +50,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -40,0 +52,5 @@\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -41,1 +58,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n@@ -43,0 +60,1 @@\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -44,1 +62,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -46,0 +64,1 @@\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -47,2 +66,3 @@\n- *\n- * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -50,1 +70,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -53,1 +75,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -56,1 +80,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -59,1 +85,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n@@ -64,3 +92,0 @@\n-\/\/ TODO 8325106 Add -XX:+DeoptimizeALot\n-\/\/ TODO 8325106 Convert this to an IR Framework test but make sure that test coverage doesn't suffer\n-\n@@ -68,0 +93,19 @@\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    static boolean VERBOSE = false;\n+    static boolean deopt[] = new boolean[13];\n+\n+    static void reportDeopt(int deoptNum) {\n+        System.out.println(\"Deopt \" + deoptNum + \" triggered\");\n+        if (VERBOSE) {\n+            new Exception().printStackTrace(System.out);\n+        }\n+    }\n+\n+    \/\/ Trigger deopts at various places\n+    static void checkDeopt(int deoptNum) {\n+        if (deopt[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n@@ -77,0 +121,1 @@\n+            checkDeopt(0);\n@@ -78,0 +123,15 @@\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n@@ -87,0 +147,1 @@\n+            checkDeopt(0);\n@@ -88,0 +149,7 @@\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n@@ -93,1 +161,1 @@\n-\n+            checkDeopt(0);\n@@ -101,0 +169,1 @@\n+            checkDeopt(1);\n@@ -102,2 +171,3 @@\n-            helper1(this, x); \/\/ 'this' escapes through argument\n-            helper2(x); \/\/ 'this' escapes through receiver\n+            helper1(this, x, 2); \/\/ 'this' escapes through argument\n+            helper2(x, 3); \/\/ 'this' escapes through receiver\n+            checkDeopt(4);\n@@ -107,1 +177,1 @@\n-            this.x = helper3(x);\n+            this.x = helper3(x, 5);\n@@ -109,2 +179,3 @@\n-            helper1(this, x); \/\/ 'this' escapes through argument\n-            helper2(x); \/\/ 'this' escapes through receiver\n+            helper1(this, x, 6); \/\/ 'this' escapes through argument\n+            helper2(x, 7); \/\/ 'this' escapes through receiver\n+            checkDeopt(8);\n@@ -113,1 +184,2 @@\n-        public static void helper1(MyValue3 obj, int x) {\n+        public static void helper1(MyValue3 obj, int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n@@ -117,1 +189,2 @@\n-        public void helper2(int x) {\n+        public void helper2(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n@@ -121,1 +194,2 @@\n-        public static int helper3(int x) {\n+        public static int helper3(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n@@ -124,0 +198,4 @@\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n@@ -130,0 +208,1 @@\n+            checkDeopt(0);\n@@ -131,0 +210,7 @@\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n@@ -138,0 +224,1 @@\n+            checkDeopt(0);\n@@ -139,0 +226,1 @@\n+                checkDeopt(1);\n@@ -140,0 +228,1 @@\n+                checkDeopt(2);\n@@ -141,0 +230,1 @@\n+                checkDeopt(3);\n@@ -142,0 +232,1 @@\n+                checkDeopt(4);\n@@ -143,0 +234,7 @@\n+            checkDeopt(5);\n+            super();\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n@@ -148,1 +246,2 @@\n-        MyValue1 val;\n+        MyValue1 val1;\n+        MyValue1 val2;\n@@ -151,0 +250,1 @@\n+            checkDeopt(0);\n@@ -152,1 +252,5 @@\n-            this.val = new MyValue1(x);\n+            checkDeopt(1);\n+            this.val1 = new MyValue1(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1(x + 1, 6, 7, 8);\n+            checkDeopt(9);\n@@ -154,0 +258,5 @@\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n@@ -162,0 +271,1 @@\n+            checkDeopt(0);\n@@ -163,1 +273,5 @@\n-            new MyValue1(42);\n+            checkDeopt(1);\n+            new MyValue1(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1(43, 6, 7, 8);\n+            checkDeopt(9);\n@@ -165,0 +279,5 @@\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n@@ -173,0 +292,1 @@\n+            checkDeopt(0);\n@@ -174,0 +294,1 @@\n+            checkDeopt(1);\n@@ -177,0 +298,1 @@\n+            checkDeopt(2);\n@@ -178,0 +300,1 @@\n+                checkDeopt(3);\n@@ -179,0 +302,1 @@\n+                checkDeopt(4);\n@@ -180,0 +304,1 @@\n+                checkDeopt(5);\n@@ -181,0 +306,1 @@\n+                checkDeopt(6);\n@@ -182,0 +308,3 @@\n+            checkDeopt(7);\n+            super();\n+            checkDeopt(8);\n@@ -185,0 +314,1 @@\n+            checkDeopt(3);\n@@ -186,0 +316,1 @@\n+            checkDeopt(4);\n@@ -189,0 +320,1 @@\n+            checkDeopt(0);\n@@ -190,0 +322,1 @@\n+                checkDeopt(1);\n@@ -192,0 +325,1 @@\n+                checkDeopt(2);\n@@ -195,0 +329,4 @@\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n@@ -202,0 +340,1 @@\n+            checkDeopt(9);\n@@ -203,0 +342,1 @@\n+            checkDeopt(10);\n@@ -206,0 +346,1 @@\n+            checkDeopt(11);\n@@ -207,0 +348,1 @@\n+            checkDeopt(12);\n@@ -210,0 +352,1 @@\n+            checkDeopt(5);\n@@ -211,0 +354,1 @@\n+            checkDeopt(6);\n@@ -214,0 +358,1 @@\n+            checkDeopt(7);\n@@ -215,0 +360,5 @@\n+            checkDeopt(8);\n+        }\n+\n+        public String toString() {\n+            return \"val: [\" + val + \"]\";\n@@ -224,0 +374,1 @@\n+            checkDeopt(0);\n@@ -225,0 +376,1 @@\n+            checkDeopt(1);\n@@ -227,0 +379,1 @@\n+                checkDeopt(2);\n@@ -228,0 +381,1 @@\n+                checkDeopt(3);\n@@ -229,0 +383,1 @@\n+            checkDeopt(4);\n@@ -230,0 +385,38 @@\n+            checkDeopt(5);\n+            super();\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", y: \" + y;\n+        }\n+    }\n+\n+    \/\/ Value class with recursive field definitions\n+    static value class MyValue11 {\n+        int x;\n+        MyValue11 val1;\n+        MyValue11 val2;\n+\n+        public MyValue11(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue11(x + 1, 2, 3, 4, 5);\n+            checkDeopt(6);\n+            this.val2 = new MyValue11(x + 2, 7, 8, 9, 10);\n+            checkDeopt(11);\n+        }\n+\n+        public MyValue11(int x, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            this.val1 = null;\n+            checkDeopt(deoptNum3);\n+            this.val2 = null;\n+            checkDeopt(deoptNum4);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + (val1 != this ? val1 : \"this\") + \"], val2: [\" + (val2 != this ? val2 : \"this\") + \"]\";\n@@ -235,0 +428,1 @@\n+        checkDeopt(3);\n@@ -250,0 +444,1 @@\n+            checkDeopt(3);\n@@ -256,0 +451,1 @@\n+        checkDeopt(3);\n@@ -262,0 +458,1 @@\n+        checkDeopt(3);\n@@ -277,0 +474,1 @@\n+            checkDeopt(3);\n@@ -283,0 +481,1 @@\n+        checkDeopt(3);\n@@ -289,0 +488,1 @@\n+        checkDeopt(9);\n@@ -303,0 +503,1 @@\n+            checkDeopt(9);\n@@ -310,0 +511,1 @@\n+        checkDeopt(9);\n@@ -362,2 +564,31 @@\n-    public static void main(String[] args) {\n-        for (int x = 0; x < 50_000; ++x) {\n+    public static MyValue11 test25(int x) {\n+        return new MyValue11(x);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Random rand = Utils.getRandomInstance();\n+\n+        \/\/ Randomly exclude some constructors from inlining via the WhiteBox API because CompileCommands don't match on different signatures.\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue3.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue3.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue11.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue11.class.getConstructor(int.class, int.class, int.class, int.class, int.class), rand.nextBoolean());\n+\n+        Integer deoptNum = Integer.getInteger(\"deoptNum\");\n+        if (deoptNum == null) {\n+            deoptNum = rand.nextInt(deopt.length);\n+        }\n+        for (int x = 0; x <= 50_000; ++x) {\n+            if (x == 50_000) {\n+                \/\/ Last iteration, trigger deoptimization\n+                deopt[deoptNum] = true;\n+            }\n@@ -388,0 +619,1 @@\n+            Asserts.assertEQ(test25(x), new MyValue11(x));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":261,"deletions":29,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n- *                   -XX:CompileCommand=dontinline,TestWithSpeculativeTypes::*\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestWithSpeculativeTypes::*\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithSpeculativeTypes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}