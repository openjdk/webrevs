{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import compiler.valhalla.inlinetypes.InlineTypeIRNode;\n@@ -155,0 +156,6 @@\n+    \/\/ Valhalla: Make sure that all Valhalla specific IR nodes are also properly initialized. Doing it here also\n+    \/\/           ensures that the Flag VM is able to pick up the correct compile phases.\n+    static {\n+        InlineTypeIRNode.forceStaticInitialization();\n+    }\n+\n@@ -1706,1 +1713,1 @@\n-        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+        macroNodes(SUBTYPE_CHECK, \"SubTypeCheck\");\n@@ -2488,0 +2495,13 @@\n+    \/**\n+     * Apply a regex that matches a macro node IR node name {@code macroNodeName} exactly on all machine independent\n+     * ideal graph phases up to and including {@link CompilePhase#BEFORE_MACRO_EXPANSION}. By default, we match on\n+     * {@link CompilePhase#BEFORE_MACRO_EXPANSION} when no {@link CompilePhase} is chosen.\n+     *\/\n+    private static void macroNodes(String irNodePlaceholder, String macroNodeName) {\n+        String macroNodeRegex = START + macroNodeName + \"\\\\b\" + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.BEFORE_MACRO_EXPANSION,\n+                                                                          macroNodeRegex,\n+                                                                          CompilePhase.BEFORE_STRINGOPTS,\n+                                                                          CompilePhase.BEFORE_MACRO_EXPANSION));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -190,5 +190,0 @@\n-    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n-    static {\n-        IRNode.optoOnly(CHECKCAST_ARRAY, InlineTypeRegexes.CHECKCAST_ARRAY);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R(.*(decode|mov|nop).*\\\\R)*.*(cmp|CMP|CLR))\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-        InlineTypeIRNode.forceStaticInitialization();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2347,1 +2347,1 @@\n-    @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2375,1 +2375,1 @@\n-    @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2404,1 +2404,1 @@\n-    \/\/FIX:8343423 @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(applyIf = {\"MonomorphicArrayCheck\", \"true\"}, failOn = IRNode.SUBTYPE_CHECK)\n@@ -2406,0 +2406,1 @@\n+        \/\/ When calling this with array = MyValue1[], we will already throw an ArrayStoreException here.\n@@ -2407,2 +2408,2 @@\n-        \/\/ Always throws a ClassCastException because we just successfully stored\n-        \/\/ a non-value type value and therefore the array can't be a value class array.\n+        \/\/ Always returns false because we just successfully stored a non-value object and therefore the array can't\n+        \/\/ be a value class array.\n@@ -2413,1 +2414,1 @@\n-    public void test97_verifier() {\n+    public void test97_verifier(RunInfo runInfo) {\n@@ -2416,5 +2417,23 @@\n-        try {\n-            test97(array1);\n-            throw new RuntimeException(\"Should throw ArrayStoreException\");\n-        } catch (ArrayStoreException e) {\n-            \/\/ Expected\n+        \/\/ When emitting the array store check \"NonValueClass <: Object[]\" for \"array[0] = new NonValueClass(42)\" in\n+        \/\/ test97(), we speculatively assume that Object[] is exact and emit such a check with an uncommon trap before\n+        \/\/ the array store check at the same bci. We propagate that information with an additional CheckCastPP node\n+        \/\/ feeding into the array store sub type check.\n+        \/\/ At runtime, we will hit the ArrayStoreException in the first execution when array is a MyValue1[].\n+        \/\/ With the default IR framework warm-up, we will profile the ArrayStoreException in the interpreter and\n+        \/\/ pass it in the MDO to the C2 compiler which treats these exceptions as traps being hit (see\n+        \/\/ InterpreterRuntime::create_klass_exception). As a result, C2 is not able to speculatively cast the array of\n+        \/\/ type Object[] to an exact type before the first sub type check because we've seen too many traps being taken\n+        \/\/ at that bci due to the ArrayStoreException that was hit at the very same bci (see Compile::too_many_traps()\n+        \/\/ which checks that zero traps have been taken so far). Thus, neither the first sub type check for the array\n+        \/\/ check cast nor the second sub type check for the instanceof can be removed.\n+        \/\/ By not executing test97() with MyValue1[] during warm-up, which would trigger the ArrayStoreException,\n+        \/\/ we will not observe an ArrayStoreException before C2 compilation. Note that C2 also requires\n+        \/\/ MonomorphicArrayCheck in order to emit the speculative exactness check.\n+        \/\/ The same is required for test98-100().\n+        if (!runInfo.isWarmUp()) {\n+            try {\n+                test97(array1);\n+                throw new RuntimeException(\"Should throw ArrayStoreException\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n@@ -2428,2 +2447,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2431,0 +2450,1 @@\n+        \/\/ When calling this with array = MyValue1[], we will already throw an ArrayStoreException here.\n@@ -2438,1 +2458,1 @@\n-    public void test98_verifier() {\n+    public void test98_verifier(RunInfo runInfo) {\n@@ -2441,5 +2461,7 @@\n-        try {\n-            test98(array1);\n-            throw new RuntimeException(\"Should throw ArrayStoreException\");\n-        } catch (ArrayStoreException e) {\n-            \/\/ Expected\n+        if (!runInfo.isWarmUp()) { \/\/ See test97() for the reason why we need this.\n+            try {\n+                test98(array1);\n+                throw new RuntimeException(\"Should throw ArrayStoreException\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n@@ -2457,2 +2479,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2460,0 +2482,1 @@\n+        \/\/ When calling this with array = MyValue1[], we will already throw an ArrayStoreException here.\n@@ -2468,1 +2491,1 @@\n-    public void test99_verifier() {\n+    public void test99_verifier(RunInfo runInfo) {\n@@ -2471,5 +2494,7 @@\n-        try {\n-            test99(array1);\n-            throw new RuntimeException(\"Should throw ArrayStoreException\");\n-        } catch (ArrayStoreException e) {\n-            \/\/ Expected\n+        if (!runInfo.isWarmUp()) { \/\/ See test97() for the reason why we need this.\n+            try {\n+                test99(array1);\n+                throw new RuntimeException(\"Should throw ArrayStoreException\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n@@ -2487,2 +2512,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2490,0 +2515,1 @@\n+        \/\/ When calling this with array = MyValue1[], we will already throw an ArrayStoreException here.\n@@ -2497,1 +2523,1 @@\n-    public void test100_verifier() {\n+    public void test100_verifier(RunInfo runInfo) {\n@@ -2500,5 +2526,7 @@\n-        try {\n-            test100(array1);\n-            throw new RuntimeException(\"Should throw ArrayStoreException\");\n-        } catch (ArrayStoreException e) {\n-            \/\/ Expected\n+        if (!runInfo.isWarmUp()) { \/\/ See test97() for the reason why we need this.\n+            try {\n+                test100(array1);\n+                throw new RuntimeException(\"Should throw ArrayStoreException\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n@@ -2510,1 +2538,1 @@\n-    \/\/ Test that CHECKCAST_ARRAY matching works as expected\n+    \/\/ Test that SUBTYPE_CHECK matching works as expected\n@@ -2512,1 +2540,1 @@\n-    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    @IR(counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n@@ -2527,1 +2555,1 @@\n-    \/\/ Test that CHECKCAST_ARRAY matching works as expected with null-free arrays\n+    \/\/ Test that SUBTYPE_CHECK matching works as expected with null-free arrays\n@@ -2529,1 +2557,1 @@\n-    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    @IR(counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":67,"deletions":39,"binary":false,"changes":106,"status":"modified"}]}