{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import compiler.valhalla.inlinetypes.InlineTypeIRNode;\n@@ -155,0 +156,6 @@\n+    \/\/ Valhalla: Make sure that all Valhalla specific IR nodes are also properly initialized. Doing it here also\n+    \/\/           ensures that the Flag VM is able to pick up the correct compile phases.\n+    static {\n+        InlineTypeIRNode.forceStaticInitialization();\n+    }\n+\n@@ -1706,1 +1713,1 @@\n-        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+        macroNodes(SUBTYPE_CHECK, \"SubTypeCheck\");\n@@ -2488,0 +2495,13 @@\n+    \/**\n+     * Apply a regex that matches a macro node IR node name {@code macroNodeName} exactly on all machine independent\n+     * ideal graph phases up to and including {@link CompilePhase#BEFORE_MACRO_EXPANSION}. By default, we match on\n+     * {@link CompilePhase#BEFORE_MACRO_EXPANSION} when no {@link CompilePhase} is chosen.\n+     *\/\n+    private static void macroNodes(String irNodePlaceholder, String macroNodeName) {\n+        String macroNodeRegex = START + macroNodeName + \"\\\\b\" + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.BEFORE_MACRO_EXPANSION,\n+                                                                          macroNodeRegex,\n+                                                                          CompilePhase.BEFORE_STRINGOPTS,\n+                                                                          CompilePhase.BEFORE_MACRO_EXPANSION));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -190,5 +190,0 @@\n-    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n-    static {\n-        IRNode.optoOnly(CHECKCAST_ARRAY, InlineTypeRegexes.CHECKCAST_ARRAY);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*\" + MYVALUE_ARRAY_KLASS + \".*:|.*(?i:mov|or).*\" + MYVALUE_ARRAY_KLASS + \".*:.*\\\\R(.*(decode|mov|nop).*\\\\R)*.*(cmp|CMP|CLR))\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-        InlineTypeIRNode.forceStaticInitialization();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2347,1 +2347,1 @@\n-    @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2375,1 +2375,1 @@\n-    @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2404,1 +2404,1 @@\n-    \/\/FIX:8343423 @IR(failOn = CHECKCAST_ARRAY)\n+    @IR(applyIf = {\"MonomorphicArrayCheck\", \"true\"}, failOn = IRNode.SUBTYPE_CHECK)\n@@ -2413,0 +2413,8 @@\n+    \/\/ With the default warm-up, we will profile the ArrayStoreException already in the interpreter and pass it in the\n+    \/\/ MDO to the C2 compiler (see InterpreterRuntime::create_klass_exception). As a result, C2 is not able to propagate\n+    \/\/ the improved type in the CheckCastPP after the subtype check because we've seen too many traps being taken at\n+    \/\/ that bci (see Compile::too_many_traps() which checks that zero traps have been taken so far). Thus, the subtype\n+    \/\/ check for the value class cannot be removed either. Set a warm-up value of zero to avoid that the trap is\n+    \/\/ observed in the interpreter. Note that C2 also required MonomorphicArrayCheck to be set in order to propagate\n+    \/\/ the type. Same for test98-100().\n+    @Warmup(0)\n@@ -2428,2 +2436,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2438,0 +2446,1 @@\n+    @Warmup(0) \/\/ See test97() for details.\n@@ -2457,2 +2466,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2468,0 +2477,1 @@\n+    @Warmup(0) \/\/ See test97() for details.\n@@ -2487,2 +2497,2 @@\n-    \/\/FIX:8343423 @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n-    \/\/    failOn = CHECKCAST_ARRAY)\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"MonomorphicArrayCheck\", \"true\"},\n+        failOn = IRNode.SUBTYPE_CHECK)\n@@ -2497,0 +2507,1 @@\n+    @Warmup(0) \/\/ See test97() for details.\n@@ -2510,1 +2521,1 @@\n-    \/\/ Test that CHECKCAST_ARRAY matching works as expected\n+    \/\/ Test that SUBTYPE_CHECK matching works as expected\n@@ -2512,1 +2523,1 @@\n-    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    @IR(counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n@@ -2527,1 +2538,1 @@\n-    \/\/ Test that CHECKCAST_ARRAY matching works as expected with null-free arrays\n+    \/\/ Test that SUBTYPE_CHECK matching works as expected with null-free arrays\n@@ -2529,1 +2540,1 @@\n-    @IR(counts = { CHECKCAST_ARRAY, \"= 1\" })\n+    @IR(counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"}]}