{"files":[{"patch":"@@ -1141,1 +1141,2 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                \/\/ invoking sym.flags() below can provoke symbol completion\n+                if (sym.name.isEmpty() && (sym.flags_field & COMPOUND) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -31,1 +30,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -36,0 +34,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -176,0 +175,21 @@\n+    JCExpression generateNullCheckIfNeeded(JCExpression tree) {\n+        if (expectedNullness == NullMarker.NOT_NULL && !types.isNonNullable(tree.type)) {\n+            return attr.makeNullCheck(tree);\n+        }\n+        return tree;\n+    }\n+\n+    \/** Translate method argument list, casting each argument\n+     *  to its corresponding type in a list of target types.\n+     *  @param _args               The method argument list.\n+     *  @param parameters          The list of target types.\n+     *  @param varargsElement      The erasure of the varargs element type,\n+     *                             or null if translating a non-varargs invocation\n+     *\/\n+    <T extends JCTree> List<T> translateArgs(List<T> _args,\n+                                             List<Type> parameters,\n+                                             Type varargsElement) {\n+        return translateArgs(_args, parameters, parameters.map(t -> NullMarker.UNSPECIFIED),\n+                varargsElement, NullMarker.UNSPECIFIED);\n+    }\n+\n@@ -178,4 +198,6 @@\n-     *  @param _args            The method argument list.\n-     *  @param parameters       The list of target types.\n-     *  @param varargsElement   The erasure of the varargs element type,\n-     *  or null if translating a non-varargs invocation\n+     *  @param _args                      The method argument list.\n+     *  @param parameters                 The list of target types (after erasure).\n+     *  @param paramsNullMarkers          The list of null markers of the target types\n+     *  @param varargsElement             The erasure of the varargs element type,\n+     *                                    or null if translating a non-varargs invocation\n+     *  @param varargsElementNullMarker   The null marker of the varargs element type\n@@ -185,1 +207,3 @@\n-                                           Type varargsElement) {\n+                                           List<NullMarker> paramsNullMarkers,\n+                                           Type varargsElement,\n+                                           NullMarker varargsElementNullMarker) {\n@@ -189,1 +213,1 @@\n-            args.head = translate(args.head, parameters.head);\n+            args.head = translate(args.head, parameters.head, paramsNullMarkers.head);\n@@ -192,0 +216,3 @@\n+            if (!paramsNullMarkers.isEmpty()) {\n+                paramsNullMarkers = paramsNullMarkers.tail;\n+            }\n@@ -197,1 +224,1 @@\n-                args.head = translate(args.head, varargsElement);\n+                args.head = translate(args.head, varargsElement, varargsElementNullMarker);\n@@ -201,1 +228,1 @@\n-            args.head = translate(args.head, parameter);\n+            args.head = translate(args.head, parameter, paramsNullMarkers.head);\n@@ -437,0 +464,2 @@\n+    private NullMarker expectedNullness = NullMarker.UNSPECIFIED;\n+\n@@ -440,0 +469,4 @@\n+        return translate(tree, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> T translate(T tree, Type pt, NullMarker expectedNullness) {\n@@ -441,0 +474,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -443,0 +477,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -446,0 +481,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -452,0 +488,4 @@\n+        return translate(trees, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> List<T> translate(List<T> trees, Type pt, NullMarker expectedNullness) {\n@@ -453,0 +493,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -456,0 +497,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -459,0 +501,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -488,1 +531,1 @@\n-        tree.init = translate(tree.init, tree.sym.erasure(types));\n+        tree.init = translate(tree.init, tree.sym.erasure(types), tree.type.getNullMarker());\n@@ -590,0 +633,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -620,0 +664,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -650,0 +695,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -669,0 +715,2 @@\n+        List<NullMarker> paramsNullMarkers = meth.type.getParameterTypes().map(t->t.getNullMarker());\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -673,1 +721,3 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym) {\n+            \/\/ this is special case code only for j.l.Enum constructor and will effectively\n+            \/\/ set the argtypes to an empty list making the invocation to translateArgs a no-op\n@@ -675,0 +725,1 @@\n+        }\n@@ -682,1 +733,1 @@\n-        tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);\n+        tree.args = translateArgs(tree.args, argtypes, paramsNullMarkers, tree.varargsElement, varargsElementNullMarker);\n@@ -687,0 +738,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -708,0 +760,1 @@\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -711,1 +764,1 @@\n-            tree.args, argtypes, tree.varargsElement);\n+            tree.args, argtypes, tree.constructor.type.getParameterTypes().map(t->t.getNullMarker()), tree.varargsElement, varargsElementNullMarker);\n@@ -733,1 +786,1 @@\n-        tree.expr = translate(tree.expr, pt);\n+        tree.expr = translate(tree.expr, pt, expectedNullness);\n@@ -739,0 +792,3 @@\n+        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs);\n+        }\n@@ -743,0 +799,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -775,0 +832,3 @@\n+        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n+            tree.expr = attr.makeNullCheck(tree.expr);\n+        }\n@@ -797,0 +857,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -811,0 +872,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -833,0 +895,1 @@\n+            result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -855,1 +918,2 @@\n-            result = retype(tree, tree.sym.erasure(types), pt);\n+            result = generateNullCheckIfNeeded(tree);\n+            result = retype((JCExpression) result, tree.sym.erasure(types), pt);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":80,"deletions":16,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -940,4 +940,0 @@\n-            if (types.isNonNullable(pts.head) && !types.isNullable(l.head.type)) {\n-                code.emitop0(dup);\n-                genNullCheck(l.head);\n-            }\n@@ -1125,4 +1121,0 @@\n-                if (types.isNonNullable(tree.type) && !types.isNonNullable(tree.init.type)) {\n-                    code.emitop0(dup);\n-                    genNullCheck(tree.init);\n-                }\n@@ -2163,4 +2155,0 @@\n-        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n-            code.emitop0(dup);\n-            genNullCheck(tree.rhs);\n-        }\n@@ -2372,4 +2360,0 @@\n-        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n-            code.emitop0(dup);\n-            genNullCheck(tree.expr);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2902,1 +2902,1 @@\n-        public void setNullMarker(NullMarker nullMarker) {\n+        public JCNullableTypeExpression setNullMarker(NullMarker nullMarker) {\n@@ -2904,0 +2904,1 @@\n+            return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -895,1 +895,5 @@\n-        return tp.setType(t);\n+        tp.setType(t);\n+        TypeMetadata.NullMarker nm = t.getMetadata(TypeMetadata.NullMarker.class);\n+        return (nm != null && nm.nullMarker() != NullMarker.UNSPECIFIED && tp instanceof JCNullableTypeExpression) ?\n+            ((JCNullableTypeExpression)tp).setNullMarker(t.getMetadata(TypeMetadata.NullMarker.class).nullMarker()) :\n+            tp;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -35,1 +36,0 @@\n- * @ignore\n@@ -79,0 +79,1 @@\n+        int i = 0;\n@@ -81,1 +82,0 @@\n-                value class Point { public implicit Point(); }\n@@ -84,2 +84,2 @@\n-                        Point s = null;\n-                        Point! o = s; \/\/ NPE at runtime, variable initialization\n+                        String s = null;\n+                        String! o = s; \/\/ NPE at runtime, variable initialization\n@@ -90,1 +90,0 @@\n-                value class Point { public implicit Point(); }\n@@ -93,2 +92,2 @@\n-                        Point s = null;\n-                        Point! o;\n+                        String s = null;\n+                        String! o;\n@@ -100,2 +99,1 @@\n-                value class Point { public implicit Point(); }\n-                class Test {\n+                class Test {\/\/\n@@ -103,2 +101,2 @@\n-                        Point s = null;\n-                        Point![] sr = new Point![10];\n+                        String s = null;\n+                        String![] sr = new String![10];\n@@ -110,1 +108,0 @@\n-                value class Point { public implicit Point(); }\n@@ -112,1 +109,1 @@\n-                    static Point id(Point! arg) { return arg; }\n+                    static String id(String! arg) { return arg; }\n@@ -114,1 +111,1 @@\n-                        Point s = null;\n+                        String s = null;\n@@ -120,1 +117,0 @@\n-                value class Point { public implicit Point(); }\n@@ -122,0 +118,69 @@\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = null;\n+                        String s2 = \"\";\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = \"\";\n+                        String s2 = null;\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object! o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object? o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n@@ -123,2 +188,44 @@\n-                        Point s = null;\n-                        Object o = (Point!) s; \/\/ NPE, cast\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o, o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", new Object(), o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n@@ -129,0 +236,1 @@\n+            System.err.println(\"executing test \" + i++);\n@@ -131,0 +239,94 @@\n+\n+        \/\/ enums are a bit special as the NPE happens inside a static initializer and ExceptionInInitializerError is thrown\n+        testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    static Object s = null;\n+                    enum E {\n+                        A(s);\n+                        E(Object! o) {}\n+                    }\n+                    public static void main(String... args) {\n+                        Test.E a = E.A;\n+                    }\n+                }\n+                \"\"\", true, ExceptionInInitializerError.class);\n+\n+        \/\/ similar test cases as above but without null markers, should trivially pass\n+        i = 0;\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o;\n+                        o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String[] sr = new String[10];\n+                        sr[0] = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String) s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, false, null);\n+        }\n@@ -133,0 +335,3 @@\n+    private static String[] PREVIEW_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+\n@@ -144,0 +349,1 @@\n+                .options(PREVIEW_OPTIONS)\n@@ -152,0 +358,1 @@\n+                    .vmOptions(\"--enable-preview\")\n@@ -161,0 +368,1 @@\n+                    .vmOptions(\"--enable-preview\")\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":225,"deletions":17,"binary":false,"changes":242,"status":"modified"}]}