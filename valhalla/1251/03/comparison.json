{"files":[{"patch":"@@ -1141,1 +1141,2 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                \/\/ invoking sym.flags() below can provoke symbol completion\n+                if (sym.name.isEmpty() && (sym.flags_field & COMPOUND) != 0) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,0 +176,7 @@\n+    JCExpression generateNullCheckIfNeeded(JCExpression tree) {\n+        if (expectedNullness == JCNullableTypeExpression.NullMarker.NOT_NULL && !types.isNonNullable(tree.type)) {\n+            return attr.makeNullCheck(tree);\n+        }\n+        return tree;\n+    }\n+\n@@ -178,4 +185,4 @@\n-     *  @param _args            The method argument list.\n-     *  @param parameters       The list of target types.\n-     *  @param varargsElement   The erasure of the varargs element type,\n-     *  or null if translating a non-varargs invocation\n+     *  @param _args               The method argument list.\n+     *  @param parameters          The list of target types.\n+     *  @param varargsElement      The erasure of the varargs element type,\n+     *                             or null if translating a non-varargs invocation\n@@ -184,3 +191,20 @@\n-                                           List<Type> parameters,\n-                                           Type varargsElement) {\n-        if (parameters.isEmpty()) return _args;\n+                                             List<Type> parameters,\n+                                             Type varargsElement) {\n+        return translateArgs(_args, parameters, List.nil(), varargsElement, varargsElement);\n+    }\n+\n+    \/** Translate method argument list, casting each argument\n+     *  to its corresponding type in a list of target types.\n+     *  @param _args                      The method argument list.\n+     *  @param erasedParameterTypes       The list of target types (after erasure).\n+     *  @param unerasedParamTypes         The list of target original parameter types.\n+     *  @param varargsElement             The erasure of the varargs element type,\n+     *                                    or null if translating a non-varargs invocation\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    <T extends JCTree> List<T> translateArgs(List<T> _args,\n+                                           List<Type> erasedParameterTypes,\n+                                           List<Type> unerasedParamTypes,\n+                                           Type varargsElement,\n+                                           Type originalVarargsElement) {\n+        if (erasedParameterTypes.isEmpty()) return _args;\n@@ -188,2 +212,6 @@\n-        while (parameters.tail.nonEmpty()) {\n-            args.head = translate(args.head, parameters.head);\n+        while (erasedParameterTypes.tail.nonEmpty()) {\n+            args.head = translate(args.head, erasedParameterTypes.head,\n+                    (!unerasedParamTypes.isEmpty() && unerasedParamTypes.head != null) ?\n+                        unerasedParamTypes.head.getNullMarker() :\n+                        JCNullableTypeExpression.NullMarker.UNSPECIFIED\n+                    );\n@@ -191,1 +219,4 @@\n-            parameters = parameters.tail;\n+            erasedParameterTypes = erasedParameterTypes.tail;\n+            if (!unerasedParamTypes.isEmpty()) {\n+                unerasedParamTypes = unerasedParamTypes.tail;\n+            }\n@@ -193,1 +224,1 @@\n-        Type parameter = parameters.head;\n+        Type parameter = erasedParameterTypes.head;\n@@ -197,1 +228,1 @@\n-                args.head = translate(args.head, varargsElement);\n+                args.head = translate(args.head, varargsElement, originalVarargsElement.getNullMarker());\n@@ -201,1 +232,5 @@\n-            args.head = translate(args.head, parameter);\n+            args.head = translate(args.head, parameter,\n+                    (!unerasedParamTypes.isEmpty() && unerasedParamTypes.head != null) ?\n+                            unerasedParamTypes.head.getNullMarker() :\n+                            JCNullableTypeExpression.NullMarker.UNSPECIFIED\n+            );\n@@ -437,0 +472,2 @@\n+    private JCNullableTypeExpression.NullMarker expectedNullness = JCNullableTypeExpression.NullMarker.UNSPECIFIED;\n+\n@@ -440,0 +477,4 @@\n+        return translate(tree, pt, JCNullableTypeExpression.NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> T translate(T tree, Type pt, JCNullableTypeExpression.NullMarker expectedNullness) {\n@@ -441,0 +482,1 @@\n+        JCNullableTypeExpression.NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -443,0 +485,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -446,0 +489,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -452,0 +496,4 @@\n+        return translate(trees, pt, JCNullableTypeExpression.NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> List<T> translate(List<T> trees, Type pt, JCNullableTypeExpression.NullMarker expectedNullness) {\n@@ -453,0 +501,1 @@\n+        JCNullableTypeExpression.NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -456,0 +505,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -459,0 +509,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -488,1 +539,1 @@\n-        tree.init = translate(tree.init, tree.sym.erasure(types));\n+        tree.init = translate(tree.init, tree.sym.erasure(types), tree.type.getNullMarker());\n@@ -590,0 +641,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -620,0 +672,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -650,0 +703,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -669,0 +723,2 @@\n+        List<Type> unerasedParamTypes = meth.type.getParameterTypes();\n+        Type originalVarargsElement = tree.varargsElement;\n@@ -673,1 +729,3 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym) {\n+            \/\/ this is special case code only for j.l.Enum constructor and will effectively\n+            \/\/ set the argtypes to an empty list making the invocation to translateArgs a no-op\n@@ -675,0 +733,2 @@\n+            unerasedParamTypes = unerasedParamTypes.tail.tail;\n+        }\n@@ -682,1 +742,1 @@\n-        tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);\n+        tree.args = translateArgs(tree.args, argtypes, unerasedParamTypes, tree.varargsElement, originalVarargsElement);\n@@ -687,0 +747,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -708,0 +769,1 @@\n+        Type originalVarargsElement = tree.varargsElement;\n@@ -711,1 +773,1 @@\n-            tree.args, argtypes, tree.varargsElement);\n+            tree.args, argtypes, tree.constructor.type.getParameterTypes(), tree.varargsElement, originalVarargsElement);\n@@ -733,1 +795,1 @@\n-        tree.expr = translate(tree.expr, pt);\n+        tree.expr = translate(tree.expr, pt, expectedNullness);\n@@ -739,0 +801,3 @@\n+        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs);\n+        }\n@@ -743,0 +808,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -775,0 +841,3 @@\n+        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n+            tree.expr = attr.makeNullCheck(tree.expr);\n+        }\n@@ -797,0 +866,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -811,0 +881,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -833,0 +904,1 @@\n+            result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -855,1 +927,2 @@\n-            result = retype(tree, tree.sym.erasure(types), pt);\n+            result = generateNullCheckIfNeeded(tree);\n+            result = retype((JCExpression) result, tree.sym.erasure(types), pt);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":92,"deletions":19,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -940,4 +940,0 @@\n-            if (types.isNonNullable(pts.head) && !types.isNullable(l.head.type)) {\n-                code.emitop0(dup);\n-                genNullCheck(l.head);\n-            }\n@@ -1125,4 +1121,0 @@\n-                if (types.isNonNullable(tree.type) && !types.isNonNullable(tree.init.type)) {\n-                    code.emitop0(dup);\n-                    genNullCheck(tree.init);\n-                }\n@@ -2163,4 +2155,0 @@\n-        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n-            code.emitop0(dup);\n-            genNullCheck(tree.rhs);\n-        }\n@@ -2372,4 +2360,0 @@\n-        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n-            code.emitop0(dup);\n-            genNullCheck(tree.expr);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2902,1 +2902,1 @@\n-        public void setNullMarker(NullMarker nullMarker) {\n+        public JCNullableTypeExpression setNullMarker(NullMarker nullMarker) {\n@@ -2904,0 +2904,1 @@\n+            return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -895,1 +895,5 @@\n-        return tp.setType(t);\n+        tp.setType(t);\n+        TypeMetadata.NullMarker nm = t.getMetadata(TypeMetadata.NullMarker.class);\n+        return (nm != null && nm.nullMarker() != NullMarker.UNSPECIFIED && tp instanceof JCNullableTypeExpression) ?\n+            ((JCNullableTypeExpression)tp).setNullMarker(t.getMetadata(TypeMetadata.NullMarker.class).nullMarker()) :\n+            tp;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -35,1 +36,0 @@\n- * @ignore\n@@ -79,0 +79,1 @@\n+        int i = 0;\n@@ -81,1 +82,0 @@\n-                value class Point { public implicit Point(); }\n@@ -84,2 +84,2 @@\n-                        Point s = null;\n-                        Point! o = s; \/\/ NPE at runtime, variable initialization\n+                        String s = null;\n+                        String! o = s; \/\/ NPE at runtime, variable initialization\n@@ -90,1 +90,0 @@\n-                value class Point { public implicit Point(); }\n@@ -93,2 +92,2 @@\n-                        Point s = null;\n-                        Point! o;\n+                        String s = null;\n+                        String! o;\n@@ -100,2 +99,1 @@\n-                value class Point { public implicit Point(); }\n-                class Test {\n+                class Test {\/\/\n@@ -103,2 +101,2 @@\n-                        Point s = null;\n-                        Point![] sr = new Point![10];\n+                        String s = null;\n+                        String![] sr = new String![10];\n@@ -110,1 +108,0 @@\n-                value class Point { public implicit Point(); }\n@@ -112,1 +109,1 @@\n-                    static Point id(Point! arg) { return arg; }\n+                    static String id(String! arg) { return arg; }\n@@ -114,1 +111,1 @@\n-                        Point s = null;\n+                        String s = null;\n@@ -120,1 +117,0 @@\n-                value class Point { public implicit Point(); }\n@@ -122,0 +118,69 @@\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = null;\n+                        String s2 = \"\";\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = \"\";\n+                        String s2 = null;\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object! o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object? o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n@@ -123,2 +188,44 @@\n-                        Point s = null;\n-                        Object o = (Point!) s; \/\/ NPE, cast\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o, o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", new Object(), o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n@@ -129,0 +236,1 @@\n+            System.err.println(\"executing test \" + i++);\n@@ -131,0 +239,94 @@\n+\n+        \/\/ enums are a bit special as the NPE happens inside a static initializer and ExceptionInInitializerError is thrown\n+        testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    static Object s = null;\n+                    enum E {\n+                        A(s);\n+                        E(Object! o) {}\n+                    }\n+                    public static void main(String... args) {\n+                        Test.E a = E.A;\n+                    }\n+                }\n+                \"\"\", true, ExceptionInInitializerError.class);\n+\n+        \/\/ similar test cases as above but without null markers, should trivially pass\n+        i = 0;\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o;\n+                        o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String[] sr = new String[10];\n+                        sr[0] = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String) s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, false, null);\n+        }\n@@ -133,0 +335,3 @@\n+    private static String[] PREVIEW_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+\n@@ -144,0 +349,1 @@\n+                .options(PREVIEW_OPTIONS)\n@@ -152,0 +358,1 @@\n+                    .vmOptions(\"--enable-preview\")\n@@ -161,0 +368,1 @@\n+                    .vmOptions(\"--enable-preview\")\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":225,"deletions":17,"binary":false,"changes":242,"status":"modified"}]}