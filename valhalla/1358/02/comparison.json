{"files":[{"patch":"@@ -584,0 +584,17 @@\n+\n+    \/\/ For osr compilation, we have no way to know which parameter is larval and which is not. We\n+    \/\/ optimistically assume all parameters are non-larval. Then, a parameter is changed to larval\n+    \/\/ if we encounter a store into one of its fields, or if we encounter a constructor invocation\n+    \/\/ with it being the first argument\n+    if (receiver_node->is_InlineType() && orig_callee->is_object_constructor()) {\n+      InlineTypeNode* vt = receiver_node->as_InlineType();\n+      if (!vt->is_larval()) {\n+        assert(is_osr_parse(), \"can only encounter in an osr compilation\");\n+        InlineTypeNode* new_vt = vt->clone()->as_InlineType();\n+        new_vt->set_is_larval(true);\n+        new_vt = _gvn.transform(new_vt)->as_InlineType();\n+        vt->replace_by(new_vt);\n+        receiver_node = new_vt;\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1144,8 +1144,1 @@\n-    \/\/ TODO 8335256 Re-enable assert and fix OSR code\n-    \/\/ Issue triggers with TestValueConstruction.java and -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0 -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 -Xbatch -XX:-TieredCompilation\n-    \/\/ assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n-    if (is_larval && !oop->as_InlineType()->is_larval()) {\n-      vt = oop->clone()->as_InlineType();\n-      vt->set_is_larval(true);\n-      return gvn.transform(vt)->as_InlineType();\n-    }\n+    assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -626,1 +626,5 @@\n-      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_java_lang_Object();\n+      \/\/ For osr compilation, we have no way to know which parameter is larval and which is not. We\n+      \/\/ optimistically assume all parameters are non-larval. Then, a parameter is changed to\n+      \/\/ larval if we encounter a store into one of its fields, or if we encounter a constructor\n+      \/\/ invocation with it being the first argument\n+      bool is_larval = !is_osr_parse() && i == 0 && method()->is_object_constructor() && !method()->holder()->is_java_lang_Object();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,21 @@\n-  if (is_get && is_field && field_holder->is_inlinetype() && peek()->is_InlineType()) {\n+  \/\/ For osr compilation, we have no way to know which parameter is larval and which is not. We\n+  \/\/ optimistically assume all parameters are non-larval. Then, a parameter is changed to larval if\n+  \/\/ we encounter a store into one of its fields, or if we encounter a constructor invocation with\n+  \/\/ it being the first argument\n+  if (is_field) {\n+    int obj_depth = is_get ? 0 : field->type()->size();\n+    if (peek(obj_depth)->is_InlineType()) {\n+      InlineTypeNode* vt = peek(obj_depth)->as_InlineType();\n+      if (is_get) {\n+        assert(!vt->is_larval(), \"can only read from a non-larval object\");\n+      } else if (!vt->is_larval()) {\n+        assert(is_osr_parse() && method()->is_object_constructor() && method()->holder() == field_holder, \"can only encounter in an osr compilation\");\n+        InlineTypeNode* new_vt = vt->clone()->as_InlineType();\n+        new_vt->set_is_larval(true);\n+        new_vt = _gvn.transform(new_vt)->as_InlineType();\n+        vt->replace_by(new_vt);\n+      }\n+    }\n+  }\n+\n+  if (is_get && is_field && field_holder->is_inlinetype()) {\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,14 @@\n+\/*\n+ * @test id=StressOSRCompilation\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0\n+ *                   -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}