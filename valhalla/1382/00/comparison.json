{"files":[{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -7132,6 +7133,12 @@\n-    mov(rscratch1, (intptr_t)markWord::inline_type_prototype().value());\n-    str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n-    store_klass_gap(buffer_obj, zr);\n-    if (vk == nullptr) {\n-      \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n-      mov(tmp1, klass);\n+    if (UseCompactObjectHeaders) {\n+      ldr(rscratch1, Address(klass, Klass::prototype_header_offset()));\n+      str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      mov(rscratch1, (intptr_t)markWord::inline_type_prototype().value());\n+      str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+      store_klass_gap(buffer_obj, zr);\n+      if (vk == nullptr) {\n+        \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n+        mov(tmp1, klass);\n+      }\n+      store_klass(buffer_obj, klass);\n@@ -7139,1 +7146,0 @@\n-    store_klass(buffer_obj, klass);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -6951,6 +6951,13 @@\n-    movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n-    xorl(r13, r13);\n-    store_klass_gap(buffer_obj, r13);\n-    if (vk == nullptr) {\n-      \/\/ store_klass corrupts rbx(klass), so save it in r13 for later use (interpreter case only).\n-      mov(r13, rbx);\n+    if (UseCompactObjectHeaders) {\n+      Register mark_word = r13;\n+      movptr(mark_word, Address(rbx, Klass::prototype_header_offset()));\n+      movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+    } else {\n+      movptr(Address(buffer_obj, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n+      xorl(r13, r13);\n+      store_klass_gap(buffer_obj, r13);\n+      if (vk == nullptr) {\n+        \/\/ store_klass corrupts rbx(klass), so save it in r13 for later use (interpreter case only).\n+        mov(r13, rbx);\n+      }\n+      store_klass(buffer_obj, rbx, rscratch1);\n@@ -6958,1 +6965,0 @@\n-    store_klass(buffer_obj, rbx, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      arrayOopDesc::set_mark(mem, Klass::default_prototype_header(_klass).set_marked());\n+      arrayOopDesc::set_mark(mem, _klass->prototype_header().set_marked());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind) :\n-  Klass(kind),\n+ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind, markWord prototype_header) :\n+Klass(kind, prototype_header),\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  ArrayKlass(Symbol* name, KlassKind kind);\n+  ArrayKlass(Symbol* name, KlassKind kind, markWord prototype_header = markWord::prototype());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk) : ArrayKlass(name, Kind) {\n+FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk) : ArrayKlass(name, Kind, markWord::flat_array_prototype(lk)) {\n@@ -69,7 +69,0 @@\n-#ifdef _LP64\n-  set_prototype_header(markWord::flat_array_prototype(lk));\n-#else\n-  fatal(\"Not supported yet\");\n-  set_prototype_header(markWord::inline_type_prototype());\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-    : InstanceKlass(parser, InlineKlass::Kind) {\n-  set_prototype_header(markWord::inline_type_prototype());\n+    : InstanceKlass(parser, InlineKlass::Kind, markWord::inline_type_prototype()) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -589,2 +590,2 @@\n-InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, ReferenceType reference_type) :\n-  Klass(kind),\n+InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, markWord prototype_header, ReferenceType reference_type) :\n+  Klass(kind, prototype_header),\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  InstanceKlass(const ClassFileParser& parser, KlassKind kind = Kind, ReferenceType reference_type = REF_NONE);\n+  InstanceKlass(const ClassFileParser& parser, KlassKind kind = Kind, markWord prototype = markWord::prototype(), ReferenceType reference_type = REF_NONE);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  : InstanceKlass(parser, Kind, determine_reference_type(parser)) {}\n+  : InstanceKlass(parser, Kind, markWord::prototype(), determine_reference_type(parser)) {}\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,17 +277,0 @@\n-static markWord make_prototype(const Klass* kls) {\n-  markWord prototype = markWord::prototype();\n-#ifdef _LP64\n-  if (UseCompactObjectHeaders) {\n-    \/\/ With compact object headers, the narrow Klass ID is part of the mark word.\n-    \/\/ We therfore seed the mark word with the narrow Klass ID.\n-    \/\/ Note that only those Klass that can be instantiated have a narrow Klass ID.\n-    \/\/ For those who don't, we leave the klass bits empty and assert if someone\n-    \/\/ tries to use those.\n-    const narrowKlass nk = CompressedKlassPointers::is_encodable(kls) ?\n-        CompressedKlassPointers::encode(const_cast<Klass*>(kls)) : 0;\n-    prototype = prototype.set_narrow_klass(nk);\n-  }\n-#endif\n-  return prototype;\n-}\n-\n@@ -302,2 +285,1 @@\n-Klass::Klass(KlassKind kind) : _kind(kind),\n-                               _prototype_header(make_prototype(this)),\n+Klass::Klass(KlassKind kind, markWord prototype_header) : _kind(kind),\n@@ -305,0 +287,1 @@\n+  set_prototype_header(make_prototype_header(this, prototype_header));\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  Klass(KlassKind kind);\n+  Klass(KlassKind kind, markWord prototype_header = markWord::prototype());\n@@ -748,0 +748,1 @@\n+  static inline markWord make_prototype_header(const Klass* kls, markWord prototype = markWord::prototype());\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,17 +62,10 @@\n-inline void Klass::set_prototype_header(markWord header) {\n-#ifdef ASSERT\n-  if (EnableValhalla && !UseCompactObjectHeaders) {\n-    assert(!is_inline_klass() || header.is_inline_type(), \"Unexpected prototype\");\n-    assert(_prototype_header.value() == 0 || _prototype_header == markWord::prototype(),\n-           \"Prototype already set\");\n-#ifdef _LP64\n-    assert(header == markWord::prototype() ||\n-           header.is_inline_type() ||\n-           header.is_flat_array() ||\n-           header.is_null_free_array(),\n-           \"unknown prototype header\");\n-#else\n-    assert(header == markWord::prototype() ||\n-           header.is_inline_type(),\n-           \"unknown prototype header\");\n-#endif\n+inline markWord Klass::make_prototype_header(const Klass* kls, markWord prototype) {\n+  if (UseCompactObjectHeaders) {\n+    \/\/ With compact object headers, the narrow Klass ID is part of the mark word.\n+    \/\/ We therfore seed the mark word with the narrow Klass ID.\n+    \/\/ Note that only those Klass that can be instantiated have a narrow Klass ID.\n+    \/\/ For those who don't, we leave the klass bits empty and assert if someone\n+    \/\/ tries to use those.\n+    const narrowKlass nk = CompressedKlassPointers::is_encodable(kls) ?\n+        CompressedKlassPointers::encode(const_cast<Klass*>(kls)) : 0;\n+    prototype = prototype.set_narrow_klass(nk);\n@@ -80,1 +73,4 @@\n-#endif \/\/ ASSERT\n+  return prototype;\n+}\n+\n+inline void Klass::set_prototype_header(markWord header) {\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -112,1 +113,2 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) : ArrayKlass(name, Kind) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) :\n+ArrayKlass(name, Kind, null_free ? markWord::null_free_array_prototype() : markWord::prototype()) {\n@@ -137,1 +139,0 @@\n-    set_prototype_header(markWord::null_free_array_prototype());\n@@ -139,2 +140,0 @@\n-#else\n-    set_prototype_header(markWord::inline_type_prototype());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}