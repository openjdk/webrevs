{"files":[{"patch":"@@ -101,1 +101,1 @@\n-    -encoding ISO-8859-1 -docencoding UTF-8 -breakiterator \\\n+    -serialwarn -encoding ISO-8859-1 -docencoding UTF-8 -breakiterator \\\n@@ -110,1 +110,1 @@\n-    -encoding ISO-8859-1 -breakiterator -splitIndex --system none \\\n+    -serialwarn -encoding ISO-8859-1 -breakiterator -splitIndex --system none \\\n@@ -678,1 +678,1 @@\n-          $(call FindModuleManDirs, $m))))) \\\n+          $(call FindModuleManDirsForDocs, $m))))) \\\n","filename":"make\/Docs.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,1 +94,4 @@\n-MAN_SUBDIRS += share\/man windows\/man\n+MAN_SUBDIRS += share\/man $(TARGET_OS)\/man\n+\n+# The docs should include the sum of all man pages for all platforms\n+MAN_DOCS_SUBDIRS += share\/man windows\/man\n@@ -166,0 +169,4 @@\n+FindModuleManDirsForDocs = \\\n+    $(strip $(wildcard \\\n+        $(foreach sub, $(MAN_DOCS_SUBDIRS), $(addsuffix \/$(strip $1)\/$(sub), $(TOP_SRC_DIRS)))))\n+\n","filename":"make\/common\/Modules.gmk","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,0 +125,11 @@\n+# Copy dependency files for inclusion in the benchmark JARs\n+$(eval $(call SetupCopyFiles, COPY_JAXP_TEST_XML, \\\n+    SRC := $(TOPDIR)\/test\/jaxp\/javax\/xml\/jaxp\/unittest, \\\n+    DEST := $(MICROBENCHMARK_CLASSES)\/org\/openjdk\/bench\/javax\/xml, \\\n+    FILES := \\\n+        stream\/XMLStreamWriterTest\/message_12.xml \\\n+        validation\/tck\/reZ003vExc23082309.xml \\\n+        transform\/msgAttach.xml, \\\n+    FLATTEN := true, \\\n+))\n+\n@@ -127,1 +138,1 @@\n-    DEPENDENCIES := $(BUILD_JDK_MICROBENCHMARK) $(JMH_UNPACKED_JARS_DONE), \\\n+    DEPENDENCIES := $(BUILD_JDK_MICROBENCHMARK) $(JMH_UNPACKED_JARS_DONE) $(COPY_JAXP_TEST_XML), \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-#if COMPILER2_OR_JVMCI\n+#if defined(COMPILER1) || COMPILER2_OR_JVMCI\n@@ -517,1 +517,1 @@\n-#endif \/\/ COMPILER2_OR_JVMCI\n+#endif \/\/ defined(COMPILER1) || COMPILER1_OR_COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2842,1 +2842,1 @@\n-  \/\/ Stubs: Called via rt_call, but dest is a stub address (no function descriptor).\n+  \/\/ Stubs: Called via rt_call, but dest is a stub address (no FunctionDescriptor).\n@@ -2844,1 +2844,3 @@\n-      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   )) {\n+      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   ) ||\n+      dest == Runtime1::entry_for(C1StubId::is_instance_of_id    )) {\n+    assert(CodeCache::contains(dest), \"simplified call is only for special C1 stubs\");\n@@ -2849,3 +2851,4 @@\n-    assert(info != nullptr, \"sanity\");\n-    add_call_info_here(info);\n-    __ post_call_nop();\n+    if (info != nullptr) {\n+      add_call_info_here(info);\n+      __ post_call_nop();\n+    }\n@@ -2856,0 +2859,1 @@\n+  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n@@ -2858,0 +2862,1 @@\n+    __ post_call_nop();\n@@ -2859,2 +2864,0 @@\n-  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n-  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -931,1 +931,2 @@\n-    (_model == 0x97 || _model == 0xAA || _model == 0xAC || _model == 0xAF)) {\n+    (_model == 0x97 || _model == 0xAA || _model == 0xAC || _model == 0xAF ||\n+      _model == 0xCC || _model == 0xDD)) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -539,11 +539,0 @@\n-  case vmIntrinsics::_isPrimitive        : {\n-    assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-    \/\/ Class.isPrimitive is known on constant classes:\n-    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n-    if (c != nullptr && !c->value()->is_null_object()) {\n-      ciType* t = c->value()->java_mirror_type();\n-      set_constant(t->is_primitive_type());\n-    }\n-    break;\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1301,19 +1301,0 @@\n-\/\/ java.lang.Class::isPrimitive()\n-void LIRGenerator::do_isPrimitive(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-  LIRItem rcvr(x->argument_at(0), this);\n-  rcvr.load_item();\n-  LIR_Opr temp = new_register(T_METADATA);\n-  LIR_Opr result = rlock_result(x);\n-\n-  CodeEmitInfo* info = nullptr;\n-  if (x->needs_null_check()) {\n-    info = state_for(x);\n-  }\n-\n-  __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset(), T_ADDRESS), temp, info);\n-  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(nullptr));\n-  __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);\n-}\n-\n@@ -3478,1 +3459,0 @@\n-  case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -260,1 +260,0 @@\n-  void do_isPrimitive(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/filemap.hpp\"\n@@ -43,0 +44,2 @@\n+bool CDSConfig::_is_dumping_preimage_static_archive = false;\n+bool CDSConfig::_is_dumping_final_static_archive = false;\n@@ -50,0 +53,1 @@\n+bool CDSConfig::_new_aot_flags_used = false;\n@@ -75,1 +79,1 @@\n-  if (is_dumping_static_archive()) {\n+  if (is_dumping_static_archive() && !is_dumping_final_static_archive()) {\n@@ -224,0 +228,1 @@\n+            log_error(cds)(\"Not a valid %s (%s)\", new_aot_flags_used() ? \"AOT cache\" : \"archive\", SharedArchiveFile);\n@@ -351,1 +356,5 @@\n-      log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n+      if (new_aot_flags_used()) {\n+        log_warning(cds)(\"AOT cache is disabled when the %s option is specified.\", option);\n+      } else {\n+        log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n+      }\n@@ -371,1 +380,1 @@\n-  if (_old_cds_flags_used && !alias_is_default) {\n+  if (old_cds_flags_used() && !alias_is_default) {\n@@ -379,1 +388,1 @@\n-void CDSConfig::check_flag_aliases() {\n+void CDSConfig::check_aot_flags() {\n@@ -391,1 +400,1 @@\n-    \/\/ Aliases not used.\n+    \/\/ AOTCache\/AOTConfiguration\/AOTMode not used.\n@@ -393,0 +402,2 @@\n+  } else {\n+    _new_aot_flags_used = true;\n@@ -396,16 +407,1 @@\n-    if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n-      vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n-    }\n-\n-    if (!FLAG_IS_DEFAULT(AOTCache)) {\n-      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n-    }\n-\n-    UseSharedSpaces = true;\n-    if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n-      RequireSharedSpaces = false;\n-    } else {\n-      assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n-      RequireSharedSpaces = true;\n-    }\n+    check_aotmode_auto_or_on();\n@@ -413,2 +409,1 @@\n-    UseSharedSpaces = false;\n-    RequireSharedSpaces = false;\n+    check_aotmode_off();\n@@ -422,8 +417,1 @@\n-      if (!FLAG_IS_DEFAULT(AOTCache)) {\n-        vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n-      }\n-\n-      assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n-      FLAG_SET_ERGO(DumpLoadedClassList, AOTConfiguration);\n-      UseSharedSpaces = false;\n-      RequireSharedSpaces = false;\n+      check_aotmode_record();\n@@ -432,3 +420,4 @@\n-      if (FLAG_IS_DEFAULT(AOTCache)) {\n-        vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n-      }\n+      check_aotmode_create();\n+    }\n+  }\n+}\n@@ -436,4 +425,4 @@\n-      assert(FLAG_IS_DEFAULT(SharedClassListFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedClassListFile, AOTConfiguration);\n-      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+void CDSConfig::check_aotmode_off() {\n+  UseSharedSpaces = false;\n+  RequireSharedSpaces = false;\n+}\n@@ -441,2 +430,16 @@\n-      CDSConfig::enable_dumping_static_archive();\n-    }\n+void CDSConfig::check_aotmode_auto_or_on() {\n+  if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n+    vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+  }\n+\n+  if (!FLAG_IS_DEFAULT(AOTCache)) {\n+    assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+    FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+  }\n+\n+  UseSharedSpaces = true;\n+  if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n+    RequireSharedSpaces = false;\n+  } else {\n+    assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n+    RequireSharedSpaces = true;\n@@ -446,0 +449,38 @@\n+void CDSConfig::check_aotmode_record() {\n+  if (!FLAG_IS_DEFAULT(AOTCache)) {\n+    vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n+  }\n+\n+  assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n+  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n+  FLAG_SET_ERGO(DumpLoadedClassList, nullptr);\n+  UseSharedSpaces = false;\n+  RequireSharedSpaces = false;\n+  _is_dumping_static_archive = true;\n+  _is_dumping_preimage_static_archive = true;\n+\n+  \/\/ At VM exit, the module graph may be contaminated with program states.\n+  \/\/ We will rebuild the module graph when dumping the CDS final image.\n+  disable_heap_dumping();\n+}\n+\n+void CDSConfig::check_aotmode_create() {\n+  if (FLAG_IS_DEFAULT(AOTCache)) {\n+    vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+  }\n+\n+  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+\n+  _is_dumping_final_static_archive = true;\n+  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n+  UseSharedSpaces = true;\n+  RequireSharedSpaces = true;\n+\n+  if (!FileMapInfo::is_preimage_static_archive(AOTConfiguration)) {\n+    vm_exit_during_initialization(\"Must be a valid AOT configuration generated by the current JVM\", AOTConfiguration);\n+  }\n+\n+  CDSConfig::enable_dumping_static_archive();\n+}\n+\n@@ -447,1 +488,1 @@\n-  check_flag_aliases();\n+  check_aot_flags();\n@@ -463,1 +504,3 @@\n-    if (!mode_flag_cmd_line) {\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode\n+    } else if (!mode_flag_cmd_line) {\n@@ -527,0 +570,14 @@\n+bool CDSConfig::is_dumping_classic_static_archive() {\n+  return _is_dumping_static_archive &&\n+    !is_dumping_preimage_static_archive() &&\n+    !is_dumping_final_static_archive();\n+}\n+\n+bool CDSConfig::is_dumping_preimage_static_archive() {\n+  return _is_dumping_preimage_static_archive;\n+}\n+\n+bool CDSConfig::is_dumping_final_static_archive() {\n+  return _is_dumping_final_static_archive;\n+}\n+\n@@ -562,0 +619,20 @@\n+const char* CDSConfig::type_of_archive_being_loaded() {\n+  if (is_dumping_final_static_archive()) {\n+    return \"AOT configuration file\";\n+  } else if (new_aot_flags_used()) {\n+    return \"AOT cache\";\n+  } else {\n+    return \"shared archive file\";\n+  }\n+}\n+\n+const char* CDSConfig::type_of_archive_being_written() {\n+  if (is_dumping_preimage_static_archive()) {\n+    return \"AOT configuration file\";\n+  } else if (new_aot_flags_used()) {\n+    return \"AOT cache\";\n+  } else {\n+    return \"shared archive file\";\n+  }\n+}\n+\n@@ -606,1 +683,1 @@\n-  if (!is_dumping_static_archive() \/\/ heap dump is not supported in dynamic dump\n+  if (!(is_dumping_classic_static_archive() || is_dumping_final_static_archive())\n@@ -611,1 +688,0 @@\n-\n@@ -659,1 +735,3 @@\n-  if (is_dumping_dynamic_archive()) {\n+  if (is_dumping_preimage_static_archive()) {\n+    return false;\n+  } else if (is_dumping_dynamic_archive()) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":123,"deletions":45,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  static bool _is_dumping_preimage_static_archive;\n+  static bool _is_dumping_final_static_archive;\n@@ -52,0 +54,1 @@\n+  static bool  _new_aot_flags_used;\n@@ -63,1 +66,5 @@\n-  static void check_flag_aliases();\n+  static void check_aot_flags();\n+  static void check_aotmode_off();\n+  static void check_aotmode_auto_or_on();\n+  static void check_aotmode_record();\n+  static void check_aotmode_create();\n@@ -77,0 +84,1 @@\n+  static bool new_aot_flags_used()                           { return CDS_ONLY(_new_aot_flags_used) NOT_CDS(false); }\n@@ -87,0 +95,2 @@\n+  static const char* type_of_archive_being_loaded();\n+  static const char* type_of_archive_being_written();\n@@ -99,0 +109,24 @@\n+  \/\/ A static CDS archive can be dumped in three modes:\n+  \/\/\n+  \/\/ \"classic\"   - This is the traditional CDS workflow of\n+  \/\/               \"java -Xshare:dump -XX:SharedClassListFile=file.txt\".\n+  \/\/\n+  \/\/ \"preimage\"  - This happens when we execute the JEP 483 training run, e.g:\n+  \/\/               \"java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconfig -cp app.jar App\"\n+  \/\/               The above command writes app.aotconfig as a \"CDS preimage\". This\n+  \/\/               is a binary file that contains all the classes loaded during the\n+  \/\/               training run, plus profiling data (e.g., the resolved constant pool entries).\n+  \/\/\n+  \/\/ \"final\"     - This happens when we execute the JEP 483 assembly phase, e.g:\n+  \/\/               \"java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconfig -XX:AOTCache=app.aot -cp app.jar\"\n+  \/\/               The above command loads all classes from app.aotconfig, perform additional linking,\n+  \/\/               and writes app.aot as a \"CDS final image\" file.\n+  \/\/\n+  \/\/ The main structural difference between \"preimage\" and \"final\" is that the preimage\n+  \/\/ - has a different magic number (0xcafea07c)\n+  \/\/ - does not have any archived Java heap objects\n+  \/\/ - does not have aot-linked classes\n+  static bool is_dumping_classic_static_archive()            NOT_CDS_RETURN_(false);\n+  static bool is_dumping_preimage_static_archive()           NOT_CDS_RETURN_(false);\n+  static bool is_dumping_final_static_archive()              NOT_CDS_RETURN_(false);\n+\n@@ -148,2 +182,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -853,0 +853,8 @@\n+  if (SystemDictionaryShared::should_be_excluded(ik)) {\n+    if (log_is_enabled(Warning, cds, resolve)) {\n+      ResourceMark rm;\n+      log_warning(cds, resolve)(\"Cannot aot-resolve constants for %s because it is excluded\", ik->external_name());\n+    }\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -198,1 +198,4 @@\n-\/\/ This is a map of all the original vtptrs. E.g., for\n+\/\/ _orig_cpp_vtptrs and _archived_cpp_vtptrs are used for type checking in\n+\/\/ CppVtables::get_archived_vtable().\n+\/\/\n+\/\/ _orig_cpp_vtptrs is a map of all the original vtptrs. E.g., for\n@@ -201,2 +204,7 @@\n-\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n-static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] == ((intptr_t**)cp)[0]\n+\/\/\n+\/\/ _archived_cpp_vtptrs is a map of all the vptprs used by classes in a preimage. E.g., for\n+\/\/    InstanceKlass* k = a class loaded from the preimage;\n+\/\/    ConstantPool* cp = k->constants();\n+\/\/ the following holds true:\n+\/\/     _archived_cpp_vtptrs[ConstantPool_Kind] == ((intptr_t**)cp)[0]\n@@ -204,0 +212,2 @@\n+static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+static intptr_t* _archived_cpp_vtptrs[_num_cloned_vtable_kinds];\n@@ -221,4 +231,4 @@\n-\/\/ Vtables are all fixed offsets from ArchiveBuilder::current()->mapped_base()\n-\/\/ E.g. ConstantPool is at offset 0x58. We can archive these offsets in the\n-\/\/ RO region and use them to alculate their location at runtime without storing\n-\/\/ the pointers in the RW region\n+\/\/ This marks the location in the archive where _index[0] is stored. This location\n+\/\/ will be stored as FileMapHeader::_cloned_vtables_offset into the archive header.\n+\/\/ Serviceability Agent uses this information to determine the vtables of\n+\/\/ archived Metadata objects.\n@@ -230,0 +240,12 @@\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    \/\/ When dumping final archive, _index[kind] at this point is in the preimage.\n+    \/\/ Remember these vtable pointers in _archived_cpp_vtptrs, as _index[kind] will now be rewritten\n+    \/\/ to point to the runtime vtable data.\n+    for (int i = 0; i < _num_cloned_vtable_kinds; i++) {\n+      assert(_index[i] != nullptr, \"must have been restored by CppVtables::serialize()\");\n+      _archived_cpp_vtptrs[i] = _index[i]->cloned_vtable();\n+    }\n+  } else {\n+    memset(_archived_cpp_vtptrs, 0, sizeof(_archived_cpp_vtptrs));\n+  }\n+\n@@ -267,1 +289,0 @@\n-  case MetaspaceObj::SharedClassPathEntryType:\n@@ -277,1 +298,2 @@\n-      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n+      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind] ||\n+          vtable_of((Metadata*)obj) == _archived_cpp_vtptrs[kind]) {\n@@ -305,1 +327,2 @@\n-  return vtable_of(m) == _index[Method_Kind]->cloned_vtable();\n+  return vtable_of(m) == _index[Method_Kind]->cloned_vtable() ||\n+         vtable_of(m) == _archived_cpp_vtptrs[Method_Kind];\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -218,0 +219,7 @@\n+void FileMapInfo::free_current_info() {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"only supported in this mode\");\n+  assert(_current_info != nullptr, \"sanity\");\n+  delete _current_info;\n+  assert(_current_info == nullptr, \"sanity\"); \/\/ Side effect expected from the above \"delete\" operator.\n+}\n+\n@@ -224,1 +232,0 @@\n-  size_t longest_common_prefix_size = 0;\n@@ -241,4 +248,0 @@\n-  ResourceMark rm;\n-  GrowableArray<const char*>* app_cp_array = create_dumptime_app_classpath_array();\n-  int len = app_cp_array->length();\n-  longest_common_prefix_size = longest_common_app_classpath_prefix_len(len, app_cp_array);\n@@ -251,2 +254,1 @@\n-                    base_archive_name_offset,\n-                    longest_common_prefix_size);\n+                    base_archive_name_offset);\n@@ -257,1 +259,1 @@\n-                             size_t base_archive_name_offset, size_t common_app_classpath_prefix_size) {\n+                             size_t base_archive_name_offset) {\n@@ -264,2 +266,7 @@\n-  set_common_app_classpath_prefix_size((unsigned int)common_app_classpath_prefix_size);\n-  set_magic(CDSConfig::is_dumping_dynamic_archive() ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    set_magic(CDS_DYNAMIC_ARCHIVE_MAGIC);\n+  } else if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    set_magic(CDS_PREIMAGE_ARCHIVE_MAGIC);\n+  } else {\n+    set_magic(CDS_ARCHIVE_MAGIC);\n+  }\n@@ -305,5 +312,0 @@\n-  _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();\n-  _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();\n-  _max_used_path_index = ClassLoaderExt::max_used_path_index();\n-  _num_module_paths = ClassLoader::num_module_path_entries();\n-\n@@ -312,2 +314,1 @@\n-  _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();\n-  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n+  _has_platform_or_app_classes = AOTClassLocationConfig::dumptime()->has_platform_or_app_classes();\n@@ -318,4 +319,0 @@\n-\n-  if (!CDSConfig::is_dumping_dynamic_archive()) {\n-    set_shared_path_table(info->_shared_path_table);\n-  }\n@@ -338,1 +335,0 @@\n-  st->print_cr(\"- common_app_classpath_size:      \" UINT32_FORMAT, common_app_classpath_prefix_size());\n@@ -364,5 +360,1 @@\n-  st->print_cr(\"- shared_path_table_offset:       0x%zx\", _shared_path_table_offset);\n-  st->print_cr(\"- app_class_paths_start_index:    %d\", _app_class_paths_start_index);\n-  st->print_cr(\"- app_module_paths_start_index:   %d\", _app_module_paths_start_index);\n-  st->print_cr(\"- num_module_paths:               %d\", _num_module_paths);\n-  st->print_cr(\"- max_used_path_index:            %d\", _max_used_path_index);\n+  st->print_cr(\"- class_location_config_offset:   0x%zx\", _class_location_config_offset);\n@@ -372,1 +364,0 @@\n-  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -393,84 +384,1 @@\n-void SharedClassPathEntry::init_as_non_existent(const char* path, TRAPS) {\n-  _type = non_existent_entry;\n-  set_name(path, CHECK);\n-}\n-\n-void SharedClassPathEntry::init(bool is_modules_image,\n-                                bool is_module_path,\n-                                ClassPathEntry* cpe, TRAPS) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  _timestamp = 0;\n-  _filesize  = 0;\n-  _from_class_path_attr = false;\n-\n-  struct stat st;\n-  if (os::stat(cpe->name(), &st) == 0) {\n-    if ((st.st_mode & S_IFMT) == S_IFDIR) {\n-      _type = dir_entry;\n-    } else {\n-      \/\/ The timestamp of the modules_image is not checked at runtime.\n-      if (is_modules_image) {\n-        _type = modules_image_entry;\n-      } else {\n-        _type = jar_entry;\n-        _timestamp = st.st_mtime;\n-        _from_class_path_attr = cpe->from_class_path_attr();\n-        _is_multi_release = cpe->is_multi_release_jar();\n-      }\n-      _filesize = st.st_size;\n-      _is_module_path = is_module_path;\n-    }\n-  } else {\n-    \/\/ The file\/dir must exist, or it would not have been added\n-    \/\/ into ClassLoader::classpath_entry().\n-    \/\/\n-    \/\/ If we can't access a jar file in the boot path, then we can't\n-    \/\/ make assumptions about where classes get loaded from.\n-    log_error(cds)(\"Unable to open file %s.\", cpe->name());\n-    MetaspaceShared::unrecoverable_loading_error();\n-  }\n-\n-  \/\/ No need to save the name of the module file, as it will be computed at run time\n-  \/\/ to allow relocation of the JDK directory.\n-  const char* name = is_modules_image  ? \"\" : cpe->name();\n-  set_name(name, CHECK);\n-}\n-\n-void SharedClassPathEntry::set_name(const char* name, TRAPS) {\n-  size_t len = strlen(name) + 1;\n-  _name = MetadataFactory::new_array<char>(ClassLoaderData::the_null_class_loader_data(), (int)len, CHECK);\n-  strcpy(_name->data(), name);\n-}\n-\n-void SharedClassPathEntry::copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS) {\n-  assert(ent != nullptr, \"sanity\");\n-  _type = ent->_type;\n-  _is_module_path = ent->_is_module_path;\n-  _timestamp = ent->_timestamp;\n-  _filesize = ent->_filesize;\n-  _from_class_path_attr = ent->_from_class_path_attr;\n-  set_name(ent->name(), CHECK);\n-\n-  if (ent->is_jar() && ent->manifest() != nullptr) {\n-    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                    ent->manifest_size(),\n-                                                    CHECK);\n-    char* p = (char*)(buf->data());\n-    memcpy(p, ent->manifest(), ent->manifest_size());\n-    set_manifest(buf);\n-  }\n-}\n-\n-const char* SharedClassPathEntry::name() const {\n-  if (CDSConfig::is_using_archive() && is_modules_image()) {\n-    \/\/ In order to validate the runtime modules image file size against the archived\n-    \/\/ size information, we need to obtain the runtime modules image path. The recorded\n-    \/\/ dump time modules image path in the archive may be different from the runtime path\n-    \/\/ if the JDK image has beed moved after generating the archive.\n-    return ClassLoader::get_jrt_entry()->name();\n-  } else {\n-    return _name->data();\n-  }\n-}\n-\n-bool SharedClassPathEntry::validate(bool is_class_path) const {\n+bool FileMapInfo::validate_class_location() {\n@@ -479,333 +387,6 @@\n-  struct stat st;\n-  const char* name = this->name();\n-\n-  bool ok = true;\n-  log_info(class, path)(\"checking shared classpath entry: %s\", name);\n-  if (os::stat(name, &st) != 0 && is_class_path) {\n-    \/\/ If the archived module path entry does not exist at runtime, it is not fatal\n-    \/\/ (no need to invalid the shared archive) because the shared runtime visibility check\n-    \/\/ filters out any archived module classes that do not have a matching runtime\n-    \/\/ module path location.\n-    log_warning(cds)(\"Required classpath entry does not exist: %s\", name);\n-    ok = false;\n-  } else if (is_dir()) {\n-    if (!os::dir_is_empty(name)) {\n-      log_warning(cds)(\"directory is not empty: %s\", name);\n-      ok = false;\n-    }\n-  } else {\n-    bool size_differs = _filesize != st.st_size;\n-    bool time_differs = has_timestamp() && _timestamp != st.st_mtime;\n-    if (time_differs || size_differs) {\n-      ok = false;\n-      if (PrintSharedArchiveAndExit) {\n-        log_warning(cds)(time_differs ? \"Timestamp mismatch\" : \"File size mismatch\");\n-      } else {\n-        const char* bad_file_msg = \"This file is not the one used while building the shared archive file:\";\n-        log_warning(cds)(\"%s %s\", bad_file_msg, name);\n-        if (!log_is_enabled(Info, cds)) {\n-          log_warning(cds)(\"%s %s\", bad_file_msg, name);\n-        }\n-        if (time_differs) {\n-          log_warning(cds)(\"%s timestamp has changed.\", name);\n-        }\n-        if (size_differs) {\n-          log_warning(cds)(\"%s size has changed.\", name);\n-        }\n-      }\n-    }\n-  }\n-\n-  if (PrintSharedArchiveAndExit && !ok) {\n-    \/\/ If PrintSharedArchiveAndExit is enabled, don't report failure to the\n-    \/\/ caller. Please see above comments for more details.\n-    ok = true;\n-    MetaspaceShared::set_archive_loading_failed();\n-  }\n-  return ok;\n-}\n-\n-bool SharedClassPathEntry::check_non_existent() const {\n-  assert(_type == non_existent_entry, \"must be\");\n-  log_info(class, path)(\"should be non-existent: %s\", name());\n-  struct stat st;\n-  if (os::stat(name(), &st) != 0) {\n-    log_info(class, path)(\"ok\");\n-    return true; \/\/ file doesn't exist\n-  } else {\n-    return false;\n-  }\n-}\n-\n-void SharedClassPathEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_name);\n-  it->push(&_manifest);\n-}\n-\n-void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_entries);\n-}\n-\n-void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, TRAPS) {\n-  const int num_entries =\n-    ClassLoader::num_boot_classpath_entries() +\n-    ClassLoader::num_app_classpath_entries() +\n-    ClassLoader::num_module_path_entries() +\n-    FileMapInfo::num_non_existent_class_paths();\n-  _entries = MetadataFactory::new_array<SharedClassPathEntry*>(loader_data, num_entries, CHECK);\n-  for (int i = 0; i < num_entries; i++) {\n-    SharedClassPathEntry* ent =\n-      new (loader_data, SharedClassPathEntry::size(), MetaspaceObj::SharedClassPathEntryType, THREAD) SharedClassPathEntry;\n-    _entries->at_put(i, ent);\n-  }\n-}\n-\n-void FileMapInfo::allocate_shared_path_table(TRAPS) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  ClassPathEntry* jrt = ClassLoader::get_jrt_entry();\n-\n-  assert(jrt != nullptr,\n-         \"No modular java runtime image present when allocating the CDS classpath entry table\");\n-\n-  _shared_path_table.dumptime_init(loader_data, CHECK);\n-\n-  \/\/ 1. boot class path\n-  int i = 0;\n-  i = add_shared_classpaths(i, \"boot\",   jrt, CHECK);\n-  i = add_shared_classpaths(i, \"app\",    ClassLoader::app_classpath_entries(), CHECK);\n-  i = add_shared_classpaths(i, \"module\", ClassLoader::module_path_entries(), CHECK);\n-\n-  for (int x = 0; x < num_non_existent_class_paths(); x++, i++) {\n-    const char* path = _non_existent_class_paths->at(x);\n-    shared_path(i)->init_as_non_existent(path, CHECK);\n-  }\n-\n-  assert(i == _shared_path_table.size(), \"number of shared path entry mismatch\");\n-}\n-\n-int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {\n-  while (cpe != nullptr) {\n-    bool is_jrt = (cpe == ClassLoader::get_jrt_entry());\n-    bool is_module_path = i >= ClassLoaderExt::app_module_paths_start_index();\n-    const char* type = (is_jrt ? \"jrt\" : (cpe->is_jar_file() ? \"jar\" : \"dir\"));\n-    log_info(class, path)(\"add %s shared path (%s) %s\", which, type, cpe->name());\n-    SharedClassPathEntry* ent = shared_path(i);\n-    ent->init(is_jrt, is_module_path, cpe, CHECK_0);\n-    if (cpe->is_jar_file()) {\n-      update_jar_manifest(cpe, ent, CHECK_0);\n-    }\n-    if (is_jrt) {\n-      cpe = ClassLoader::get_next_boot_classpath_entry(cpe);\n-    } else {\n-      cpe = cpe->next();\n-    }\n-    i++;\n-  }\n-\n-  return i;\n-}\n-\n-void FileMapInfo::check_nonempty_dir_in_shared_path_table() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  bool has_nonempty_dir = false;\n-\n-  int last = _shared_path_table.size() - 1;\n-  if (last > ClassLoaderExt::max_used_path_index()) {\n-     \/\/ no need to check any path beyond max_used_path_index\n-     last = ClassLoaderExt::max_used_path_index();\n-  }\n-\n-  for (int i = 0; i <= last; i++) {\n-    SharedClassPathEntry *e = shared_path(i);\n-    if (e->is_dir()) {\n-      const char* path = e->name();\n-      if (!os::dir_is_empty(path)) {\n-        log_error(cds)(\"Error: non-empty directory '%s'\", path);\n-        has_nonempty_dir = true;\n-      }\n-    }\n-  }\n-\n-  if (has_nonempty_dir) {\n-    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", nullptr);\n-  }\n-}\n-\n-void FileMapInfo::record_non_existent_class_path_entry(const char* path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  log_info(class, path)(\"non-existent Class-Path entry %s\", path);\n-  if (_non_existent_class_paths == nullptr) {\n-    _non_existent_class_paths = new (mtClass) GrowableArray<const char*>(10, mtClass);\n-  }\n-  _non_existent_class_paths->append(os::strdup(path));\n-}\n-\n-int FileMapInfo::num_non_existent_class_paths() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  if (_non_existent_class_paths != nullptr) {\n-    return _non_existent_class_paths->length();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-int FileMapInfo::get_module_shared_path_index(Symbol* location) {\n-  if (location->starts_with(\"jrt:\", 4) && get_number_of_shared_paths() > 0) {\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-    return 0;\n-  }\n-\n-  if (ClassLoaderExt::app_module_paths_start_index() >= get_number_of_shared_paths()) {\n-    \/\/ The archive(s) were created without --module-path option\n-    return -1;\n-  }\n-\n-  if (!location->starts_with(\"file:\", 5)) {\n-    return -1;\n-  }\n-\n-  \/\/ skip_uri_protocol was also called during dump time -- see ClassLoaderExt::process_module_table()\n-  ResourceMark rm;\n-  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n-  for (int i = ClassLoaderExt::app_module_paths_start_index(); i < get_number_of_shared_paths(); i++) {\n-    SharedClassPathEntry* ent = shared_path(i);\n-    if (!ent->is_non_existent()) {\n-      assert(ent->in_named_module(), \"must be\");\n-      bool cond = strcmp(file, ent->name()) == 0;\n-      log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n-                             location->as_C_string(), ent->name(), cond ? \"same\" : \"different\");\n-      if (cond) {\n-        return i;\n-      }\n-    }\n-  }\n-\n-  return -1;\n-}\n-\n-class ManifestStream: public ResourceObj {\n-  private:\n-  u1*   _buffer_start; \/\/ Buffer bottom\n-  u1*   _buffer_end;   \/\/ Buffer top (one past last element)\n-  u1*   _current;      \/\/ Current buffer position\n-\n- public:\n-  \/\/ Constructor\n-  ManifestStream(u1* buffer, int length) : _buffer_start(buffer),\n-                                           _current(buffer) {\n-    _buffer_end = buffer + length;\n-  }\n-\n-  static bool is_attr(u1* attr, const char* name) {\n-    return strncmp((const char*)attr, name, strlen(name)) == 0;\n-  }\n-\n-  static char* copy_attr(u1* value, size_t len) {\n-    char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n-    strncpy(buf, (char*)value, len);\n-    buf[len] = 0;\n-    return buf;\n-  }\n-};\n-\n-void FileMapInfo::update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  ResourceMark rm(THREAD);\n-  jint manifest_size;\n-\n-  assert(cpe->is_jar_file() && ent->is_jar(), \"the shared class path entry is not a JAR file\");\n-  char* manifest = ClassLoaderExt::read_manifest(THREAD, cpe, &manifest_size);\n-  if (manifest != nullptr) {\n-    ManifestStream* stream = new ManifestStream((u1*)manifest,\n-                                                manifest_size);\n-    \/\/ Copy the manifest into the shared archive\n-    manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n-    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                    manifest_size,\n-                                                    CHECK);\n-    char* p = (char*)(buf->data());\n-    memcpy(p, manifest, manifest_size);\n-    ent->set_manifest(buf);\n-  }\n-}\n-\n-char* FileMapInfo::skip_first_path_entry(const char* path) {\n-  size_t path_sep_len = strlen(os::path_separator());\n-  char* p = strstr((char*)path, os::path_separator());\n-  if (p != nullptr) {\n-    debug_only( {\n-      size_t image_name_len = strlen(MODULES_IMAGE_NAME);\n-      assert(strncmp(p - image_name_len, MODULES_IMAGE_NAME, image_name_len) == 0,\n-             \"first entry must be the modules image\");\n-    } );\n-    p += path_sep_len;\n-  } else {\n-    debug_only( {\n-      assert(ClassLoader::string_ends_with(path, MODULES_IMAGE_NAME),\n-             \"first entry must be the modules image\");\n-    } );\n-  }\n-  return p;\n-}\n-\n-int FileMapInfo::num_paths(const char* path) {\n-  if (path == nullptr) {\n-    return 0;\n-  }\n-  int npaths = 1;\n-  char* p = (char*)path;\n-  while (p != nullptr) {\n-    char* prev = p;\n-    p = strstr((char*)p, os::path_separator());\n-    if (p != nullptr) {\n-      p++;\n-      \/\/ don't count empty path\n-      if ((p - prev) > 1) {\n-       npaths++;\n-      }\n-    }\n-  }\n-  return npaths;\n-}\n-\n-\/\/ Returns true if a path within the paths exists and has non-zero size.\n-bool FileMapInfo::check_paths_existence(const char* paths) {\n-  ClasspathStream cp_stream(paths);\n-  bool exist = false;\n-  struct stat st;\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    if (os::stat(path, &st) == 0 && st.st_size > 0) {\n-      exist = true;\n-      break;\n-    }\n-  }\n-  return exist;\n-}\n-\n-GrowableArray<const char*>* FileMapInfo::create_dumptime_app_classpath_array() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n-  ClassPathEntry* cpe = ClassLoader::app_classpath_entries();\n-  while (cpe != nullptr) {\n-    path_array->append(cpe->name());\n-    cpe = cpe->next();\n-  }\n-  return path_array;\n-}\n-\n-GrowableArray<const char*>* FileMapInfo::create_path_array(const char* paths) {\n-  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n-  JavaThread* current = JavaThread::current();\n-  ClasspathStream cp_stream(paths);\n-  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    if (!non_jar_in_cp) {\n-      struct stat st;\n-      if (os::stat(path, &st) == 0) {\n-        path_array->append(path);\n-      }\n+  AOTClassLocationConfig* config = header()->class_location_config();\n+  bool has_extra_module_paths = false;\n+  if (!config->validate(header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n+    if (PrintSharedArchiveAndExit) {\n+      MetaspaceShared::set_archive_loading_failed();\n+      return true;\n@@ -813,59 +394,0 @@\n-      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n-      if (canonical_path != nullptr) {\n-        char* error_msg = nullptr;\n-        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n-        if (zip != nullptr && error_msg == nullptr) {\n-          path_array->append(path);\n-        }\n-      }\n-    }\n-  }\n-  return path_array;\n-}\n-\n-bool FileMapInfo::classpath_failure(const char* msg, const char* name) {\n-  ClassLoader::trace_class_path(msg, name);\n-  if (PrintSharedArchiveAndExit) {\n-    MetaspaceShared::set_archive_loading_failed();\n-  }\n-  return false;\n-}\n-\n-unsigned int FileMapInfo::longest_common_app_classpath_prefix_len(int num_paths,\n-                                                                  GrowableArray<const char*>* rp_array) {\n-  if (num_paths == 0) {\n-    return 0;\n-  }\n-  unsigned int pos;\n-  for (pos = 0; ; pos++) {\n-    for (int i = 0; i < num_paths; i++) {\n-      if (rp_array->at(i)[pos] != '\\0' && rp_array->at(i)[pos] == rp_array->at(0)[pos]) {\n-        continue;\n-      }\n-      \/\/ search backward for the pos before the file separator char\n-      while (pos > 0) {\n-        if (rp_array->at(0)[--pos] == *os::file_separator()) {\n-          return pos + 1;\n-        }\n-      }\n-      return 0;\n-    }\n-  }\n-  return 0;\n-}\n-\n-bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array,\n-                              unsigned int dumptime_prefix_len, unsigned int runtime_prefix_len) {\n-  int i = 0;\n-  int j = shared_path_start_idx;\n-  while (i < num_paths) {\n-    while (shared_path(j)->from_class_path_attr()) {\n-      \/\/ shared_path(j) was expanded from the JAR file attribute \"Class-Path:\"\n-      \/\/ during dump time. It's not included in the -classpath VM argument.\n-      j++;\n-    }\n-    assert(strlen(shared_path(j)->name()) > (size_t)dumptime_prefix_len, \"sanity\");\n-    const char* dumptime_path = shared_path(j)->name() + dumptime_prefix_len;\n-    assert(strlen(rp_array->at(i)) > (size_t)runtime_prefix_len, \"sanity\");\n-    const char* runtime_path = rp_array->at(i)  + runtime_prefix_len;\n-    if (!os::same_files(dumptime_path, runtime_path)) {\n@@ -874,64 +396,0 @@\n-    i++;\n-    j++;\n-  }\n-  return true;\n-}\n-\n-bool FileMapInfo::validate_boot_class_paths() {\n-  \/\/\n-  \/\/ - Archive contains boot classes only - relaxed boot path check:\n-  \/\/   Extra path elements appended to the boot path at runtime are allowed.\n-  \/\/\n-  \/\/ - Archive contains application or platform classes - strict boot path check:\n-  \/\/   Validate the entire runtime boot path, which must be compatible\n-  \/\/   with the dump time boot path. Appending boot path at runtime is not\n-  \/\/   allowed.\n-  \/\/\n-\n-  \/\/ The first entry in boot path is the modules_image (guaranteed by\n-  \/\/ ClassLoader::setup_boot_search_path()). Skip the first entry. The\n-  \/\/ path of the runtime modules_image may be different from the dump\n-  \/\/ time path (e.g. the JDK image is copied to a different location\n-  \/\/ after generating the shared archive), which is acceptable. For most\n-  \/\/ common cases, the dump time boot path might contain modules_image only.\n-  char* runtime_boot_path = Arguments::get_boot_class_path();\n-  char* rp = skip_first_path_entry(runtime_boot_path);\n-  assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-  int dp_len = header()->app_class_paths_start_index() - 1; \/\/ ignore the first path to the module image\n-  bool match = true;\n-\n-  bool relaxed_check = !header()->has_platform_or_app_classes();\n-  if (dp_len == 0 && rp == nullptr) {\n-    return true;   \/\/ ok, both runtime and dump time boot paths have modules_images only\n-  } else if (dp_len == 0 && rp != nullptr) {\n-    if (relaxed_check) {\n-      return true;   \/\/ ok, relaxed check, runtime has extra boot append path entries\n-    } else {\n-      ResourceMark rm;\n-      if (check_paths_existence(rp)) {\n-        \/\/ If a path exists in the runtime boot paths, it is considered a mismatch\n-        \/\/ since there's no boot path specified during dump time.\n-        match = false;\n-      }\n-    }\n-  } else if (dp_len > 0 && rp != nullptr) {\n-    int num;\n-    ResourceMark rm;\n-    GrowableArray<const char*>* rp_array = create_path_array(rp);\n-    int rp_len = rp_array->length();\n-    if (rp_len >= dp_len) {\n-      if (relaxed_check) {\n-        \/\/ only check the leading entries in the runtime boot path, up to\n-        \/\/ the length of the dump time boot path\n-        num = dp_len;\n-      } else {\n-        \/\/ check the full runtime boot path, must match with dump time\n-        num = rp_len;\n-      }\n-      match = check_paths(1, num, rp_array, 0, 0);\n-    } else {\n-      \/\/ create_path_array() ignores non-existing paths. Although the dump time and runtime boot classpath lengths\n-      \/\/ are the same initially, after the call to create_path_array(), the runtime boot classpath length could become\n-      \/\/ shorter. We consider boot classpath mismatch in this case.\n-      match = false;\n-    }\n@@ -940,121 +398,1 @@\n-  if (!match) {\n-    \/\/ The paths are different\n-    return classpath_failure(\"[BOOT classpath mismatch, actual =\", runtime_boot_path);\n-  }\n-  return true;\n-}\n-\n-bool FileMapInfo::validate_app_class_paths(int shared_app_paths_len) {\n-  const char *appcp = Arguments::get_appclasspath();\n-  assert(appcp != nullptr, \"null app classpath\");\n-  int rp_len = num_paths(appcp);\n-  bool match = false;\n-  if (rp_len < shared_app_paths_len) {\n-    return classpath_failure(\"Run time APP classpath is shorter than the one at dump time: \", appcp);\n-  }\n-  if (shared_app_paths_len != 0 && rp_len != 0) {\n-    \/\/ Prefix is OK: E.g., dump with -cp foo.jar, but run with -cp foo.jar:bar.jar.\n-    ResourceMark rm;\n-    GrowableArray<const char*>* rp_array = create_path_array(appcp);\n-    if (rp_array->length() == 0) {\n-      \/\/ None of the jar file specified in the runtime -cp exists.\n-      return classpath_failure(\"None of the jar file specified in the runtime -cp exists: -Djava.class.path=\", appcp);\n-    }\n-    if (rp_array->length() < shared_app_paths_len) {\n-      \/\/ create_path_array() ignores non-existing paths. Although the dump time and runtime app classpath lengths\n-      \/\/ are the same initially, after the call to create_path_array(), the runtime app classpath length could become\n-      \/\/ shorter. We consider app classpath mismatch in this case.\n-      return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n-    }\n-\n-    \/\/ Handling of non-existent entries in the classpath: we eliminate all the non-existent\n-    \/\/ entries from both the dump time classpath (ClassLoader::update_class_path_entry_list)\n-    \/\/ and the runtime classpath (FileMapInfo::create_path_array), and check the remaining\n-    \/\/ entries. E.g.:\n-    \/\/\n-    \/\/ dump : -cp a.jar:NE1:NE2:b.jar  -> a.jar:b.jar -> recorded in archive.\n-    \/\/ run 1: -cp NE3:a.jar:NE4:b.jar  -> a.jar:b.jar -> matched\n-    \/\/ run 2: -cp x.jar:NE4:b.jar      -> x.jar:b.jar -> mismatched\n-\n-    int j = header()->app_class_paths_start_index();\n-    match = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n-    if (!match) {\n-      \/\/ To facilitate app deployment, we allow the JAR files to be moved *together* to\n-      \/\/ a different location, as long as they are still stored under the same directory\n-      \/\/ structure. E.g., the following is OK.\n-      \/\/     java -Xshare:dump -cp \/a\/Foo.jar:\/a\/b\/Bar.jar  ...\n-      \/\/     java -Xshare:auto -cp \/x\/y\/Foo.jar:\/x\/y\/b\/Bar.jar  ...\n-      unsigned int dumptime_prefix_len = header()->common_app_classpath_prefix_size();\n-      unsigned int runtime_prefix_len = longest_common_app_classpath_prefix_len(shared_app_paths_len, rp_array);\n-      if (dumptime_prefix_len != 0 || runtime_prefix_len != 0) {\n-        log_info(class, path)(\"LCP length for app classpath (dumptime: %u, runtime: %u)\",\n-                              dumptime_prefix_len, runtime_prefix_len);\n-        match = check_paths(j, shared_app_paths_len, rp_array,\n-                               dumptime_prefix_len, runtime_prefix_len);\n-      }\n-      if (!match) {\n-        return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-void FileMapInfo::log_paths(const char* msg, int start_idx, int end_idx) {\n-  LogTarget(Info, class, path) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"%s\", msg);\n-    const char* prefix = \"\";\n-    for (int i = start_idx; i < end_idx; i++) {\n-      ls.print(\"%s%s\", prefix, shared_path(i)->name());\n-      prefix = os::path_separator();\n-    }\n-    ls.cr();\n-  }\n-}\n-\n-void FileMapInfo::extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths) {\n-  GrowableArray<const char*>* path_array = create_path_array(runtime_path);\n-  int num_paths = path_array->length();\n-  for (int i = 0; i < num_paths; i++) {\n-    const char* name = path_array->at(i);\n-    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n-  }\n-  \/\/ module paths are stored in sorted order in the CDS archive.\n-  module_paths->sort(ClassLoaderExt::compare_module_names);\n-}\n-\n-bool FileMapInfo::check_module_paths() {\n-  const char* runtime_path = Arguments::get_property(\"jdk.module.path\");\n-  int archived_num_module_paths = header()->num_module_paths();\n-  if (runtime_path == nullptr && archived_num_module_paths == 0) {\n-    return true;\n-  }\n-  if ((runtime_path == nullptr && archived_num_module_paths > 0) ||\n-      (runtime_path != nullptr && archived_num_module_paths == 0)) {\n-    return false;\n-  }\n-  ResourceMark rm;\n-  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(3);\n-  extract_module_paths(runtime_path, module_paths);\n-  int num_paths = module_paths->length();\n-  if (num_paths != archived_num_module_paths) {\n-    return false;\n-  }\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, module_paths, 0, 0);\n-}\n-\n-bool FileMapInfo::validate_shared_path_table() {\n-  assert(CDSConfig::is_using_archive(), \"runtime only\");\n-\n-  _validating_shared_path_table = true;\n-\n-  \/\/ Load the shared path table info from the archive header\n-  _shared_path_table = header()->shared_path_table();\n-\n-  bool matched_module_paths = true;\n-  if (CDSConfig::is_dumping_dynamic_archive() || header()->has_full_module_graph()) {\n-    matched_module_paths = check_module_paths();\n-  }\n-  if (header()->has_full_module_graph() && !matched_module_paths) {\n+  if (header()->has_full_module_graph() && has_extra_module_paths) {\n@@ -1062,1 +400,1 @@\n-    log_info(cds)(\"optimized module handling: disabled because of mismatched module paths\");\n+    log_info(cds)(\"optimized module handling: disabled because extra module path(s) are specified\");\n@@ -1070,5 +408,1 @@\n-    \/\/\n-    \/\/ When dynamic archiving is enabled, the _shared_path_table is overwritten\n-    \/\/ to include the application path and stored in the top layer archive.\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-    if (header()->app_class_paths_start_index() > 1) {\n+    if (config->num_boot_classpaths() > 0) {\n@@ -1079,2 +413,2 @@\n-    if (header()->num_module_paths() > 0) {\n-      if (!matched_module_paths) {\n+    if (config->num_module_paths() > 0) {\n+      if (has_extra_module_paths) {\n@@ -1088,57 +422,0 @@\n-  log_paths(\"Expecting BOOT path=\", 0, header()->app_class_paths_start_index());\n-  log_paths(\"Expecting -Djava.class.path=\", header()->app_class_paths_start_index(), header()->app_module_paths_start_index());\n-\n-  int module_paths_start_index = header()->app_module_paths_start_index();\n-  int shared_app_paths_len = 0;\n-\n-  \/\/ validate the path entries up to the _max_used_path_index\n-  for (int i=0; i < header()->max_used_path_index() + 1; i++) {\n-    if (i < module_paths_start_index) {\n-      if (shared_path(i)->validate()) {\n-        \/\/ Only count the app class paths not from the \"Class-path\" attribute of a jar manifest.\n-        if (!shared_path(i)->from_class_path_attr() && i >= header()->app_class_paths_start_index()) {\n-          shared_app_paths_len++;\n-        }\n-        log_info(class, path)(\"ok\");\n-      } else {\n-        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n-          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n-        }\n-        return false;\n-      }\n-    } else if (i >= module_paths_start_index) {\n-      if (shared_path(i)->validate(false \/* not a class path entry *\/)) {\n-        log_info(class, path)(\"ok\");\n-      } else {\n-        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n-          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n-        }\n-        return false;\n-      }\n-    }\n-  }\n-\n-  if (header()->max_used_path_index() == 0) {\n-    \/\/ default archive only contains the module image in the bootclasspath\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-  } else {\n-    if (!validate_boot_class_paths() || !validate_app_class_paths(shared_app_paths_len)) {\n-      const char* mismatch_msg = \"shared class paths mismatch\";\n-      const char* hint_msg = log_is_enabled(Info, class, path) ?\n-          \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n-      if (RequireSharedSpaces) {\n-        log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-        MetaspaceShared::unrecoverable_loading_error();\n-      } else {\n-        log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-      }\n-      return false;\n-    }\n-  }\n-\n-  if (!validate_non_existent_class_paths()) {\n-    return false;\n-  }\n-\n-  _validating_shared_path_table = false;\n-\n@@ -1149,1 +426,1 @@\n-  size_t sz = sizeof(ClassPathEntry*) * get_number_of_shared_paths();\n+  size_t sz = sizeof(ClassPathEntry*) * AOTClassLocationConfig::runtime()->length();\n@@ -1157,28 +434,0 @@\n-bool FileMapInfo::validate_non_existent_class_paths() {\n-  \/\/ All of the recorded non-existent paths came from the Class-Path: attribute from the JAR\n-  \/\/ files on the app classpath. If any of these are found to exist during runtime,\n-  \/\/ it will change how classes are loading for the app loader. For safety, disable\n-  \/\/ loading of archived platform\/app classes (currently there's no way to disable just the\n-  \/\/ app classes).\n-\n-  assert(CDSConfig::is_using_archive(), \"runtime only\");\n-  for (int i = header()->app_module_paths_start_index() + header()->num_module_paths();\n-       i < get_number_of_shared_paths();\n-       i++) {\n-    SharedClassPathEntry* ent = shared_path(i);\n-    if (!ent->check_non_existent()) {\n-      if (header()->has_aot_linked_classes()) {\n-        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n-                       \"file %s exists\", ent->name());\n-        return false;\n-      } else {\n-        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-                         \"file %s exists\", ent->name());\n-        header()->set_has_platform_or_app_classes(false);\n-      }\n-    }\n-  }\n-\n-  return true;\n-}\n-\n@@ -1222,1 +471,1 @@\n-      log_info(cds)(\"Specified shared archive not found (%s)\", _archive_name);\n+      log_info(cds)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -1233,0 +482,1 @@\n+    const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -1238,1 +488,1 @@\n-      log_warning(cds)(\"Unable to read generic CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read generic CDS file map header from %s\", file_type);\n@@ -1243,2 +493,3 @@\n-        gen_header._magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      log_warning(cds)(\"The shared archive file has a bad magic number: %#x\", gen_header._magic);\n+        gen_header._magic != CDS_DYNAMIC_ARCHIVE_MAGIC &&\n+        gen_header._magic != CDS_PREIMAGE_ARCHIVE_MAGIC) {\n+      log_warning(cds)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n@@ -1249,2 +500,2 @@\n-      log_warning(cds)(\"Cannot handle shared archive file version 0x%x. Must be at least 0x%x.\",\n-                                 gen_header._version, CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION);\n+      log_warning(cds)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n+                       file_type, gen_header._version, CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION);\n@@ -1255,2 +506,2 @@\n-      log_warning(cds)(\"The shared archive file version 0x%x does not match the required version 0x%x.\",\n-                                 gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+      log_warning(cds)(\"The %s version 0x%x does not match the required version 0x%x.\",\n+                       file_type, gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n@@ -1271,1 +522,1 @@\n-      log_warning(cds)(\"Unable to read actual CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read file map header from %s\", file_type);\n@@ -1298,0 +549,12 @@\n+  bool is_static_archive() const {\n+    return _header->_magic == CDS_ARCHIVE_MAGIC;\n+  }\n+\n+  bool is_dynamic_archive() const {\n+    return _header->_magic == CDS_DYNAMIC_ARCHIVE_MAGIC;\n+  }\n+\n+  bool is_preimage_static_archive() const {\n+    return _header->_magic == CDS_PREIMAGE_ARCHIVE_MAGIC;\n+  }\n+\n@@ -1323,1 +586,2 @@\n-    if (_header->_magic == CDS_ARCHIVE_MAGIC) {\n+\n+    if (is_static_archive() || is_preimage_static_archive()) {\n@@ -1333,1 +597,1 @@\n-      assert(_header->_magic == CDS_DYNAMIC_ARCHIVE_MAGIC, \"must be\");\n+      assert(is_dynamic_archive(), \"must be\");\n@@ -1381,1 +645,6 @@\n-  if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+  switch (header->_magic) {\n+  case CDS_PREIMAGE_ARCHIVE_MAGIC:\n+    return false; \/\/ This is a binary config file, not a proper archive\n+  case CDS_DYNAMIC_ARCHIVE_MAGIC:\n+    break;\n+  default:\n@@ -1399,0 +668,8 @@\n+bool FileMapInfo::is_preimage_static_archive(const char* file) {\n+  FileHeaderHelper file_helper(file, false);\n+  if (!file_helper.initialize()) {\n+    return false;\n+  }\n+  return file_helper.is_preimage_static_archive();\n+}\n+\n@@ -1409,0 +686,1 @@\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -1410,2 +688,9 @@\n-    if (gen_header->_magic != CDS_ARCHIVE_MAGIC) {\n-      log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+    if ((gen_header->_magic == CDS_ARCHIVE_MAGIC) ||\n+        (gen_header->_magic == CDS_PREIMAGE_ARCHIVE_MAGIC && CDSConfig::is_dumping_final_static_archive())) {\n+      \/\/ Good\n+    } else {\n+      if (CDSConfig::new_aot_flags_used()) {\n+        log_warning(cds)(\"Not a valid %s %s\", file_type, _full_path);\n+      } else {\n+        log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+      }\n@@ -1433,1 +718,1 @@\n-    log_warning(cds)(\"The shared archive file has the wrong version.\");\n+    log_warning(cds)(\"The %s has the wrong version.\", file_type);\n@@ -1437,6 +722,0 @@\n-  int common_path_size = header()->common_app_classpath_prefix_size();\n-  if (common_path_size < 0) {\n-      log_warning(cds)(\"common app classpath prefix len < 0\");\n-      return false;\n-  }\n-\n@@ -1449,1 +728,0 @@\n-      log_info(cds)(\"common_app_classpath_size: \" UINT32_FORMAT, header()->common_app_classpath_prefix_size());\n@@ -1452,1 +730,1 @@\n-      log_warning(cds)(\"The shared archive file has an incorrect header size.\");\n+      log_warning(cds)(\"The %s has an incorrect header size.\", file_type);\n@@ -1469,2 +747,2 @@\n-    log_warning(cds)(\"The shared archive file was created by a different\"\n-                  \" version or build of HotSpot\");\n+    log_warning(cds)(\"The %s was created by a different\"\n+                  \" version or build of HotSpot\", file_type);\n@@ -1481,1 +759,1 @@\n-      log_warning(cds)(\"The shared archive file has been truncated.\");\n+      log_warning(cds)(\"The %s has been truncated.\", file_type);\n@@ -1505,1 +783,4 @@\n-  log_info(cds)(\"trying to map %s\", _full_path);\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n+  const char* info = CDSConfig::is_dumping_final_static_archive() ?\n+    \"AOTConfiguration file \" : \"\";\n+  log_info(cds)(\"trying to map %s%s\", info, _full_path);\n@@ -1509,1 +790,1 @@\n-      log_info(cds)(\"Specified shared archive not found (%s)\", _full_path);\n+      log_info(cds)(\"Specified %s not found (%s)\", file_type, _full_path);\n@@ -1511,1 +792,1 @@\n-      log_warning(cds)(\"Failed to open shared archive file (%s)\",\n+      log_warning(cds)(\"Failed to open %s (%s)\", file_type,\n@@ -1516,1 +797,1 @@\n-    log_info(cds)(\"Opened archive %s.\", _full_path);\n+    log_info(cds)(\"Opened %s %s.\", file_type, _full_path);\n@@ -1529,1 +810,5 @@\n-    msg.info(\"Dumping shared data to file: \");\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      msg.info(\"Writing binary AOTConfiguration file: \");\n+    } else {\n+      msg.info(\"Dumping shared data to file: \");\n+    }\n@@ -1534,1 +819,1 @@\n-    chmod(_full_path, _S_IREAD | _S_IWRITE);\n+  chmod(_full_path, _S_IREAD | _S_IWRITE);\n@@ -1540,1 +825,2 @@\n-  int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0444);\n+  int mode = CDSConfig::is_dumping_preimage_static_archive() ? 0666 : 0444;\n+  int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, mode);\n@@ -1542,1 +828,1 @@\n-    log_error(cds)(\"Unable to create shared archive file %s: (%s).\", _full_path,\n+    log_error(cds)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n@@ -1798,1 +1084,8 @@\n-    MetaspaceShared::writing_error(\"Unable to write to shared archive file.\");\n+\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      MetaspaceShared::writing_error(\"Unable to write to AOT configuration file.\");\n+    } else if (CDSConfig::new_aot_flags_used()) {\n+      MetaspaceShared::writing_error(\"Unable to write to AOT cache.\");\n+    } else {\n+      MetaspaceShared::writing_error(\"Unable to write to shared archive.\");\n+    }\n@@ -2533,3 +1826,0 @@\n-SharedPathTable FileMapInfo::_shared_path_table;\n-bool FileMapInfo::_validating_shared_path_table = false;\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n@@ -2545,1 +1835,1 @@\n-\/\/ [2] validate_shared_path_table - this is done later, because the table is in the RW\n+\/\/ [2] validate_shared_path_table - this is done later, because the table is in the RO\n@@ -2643,0 +1933,1 @@\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -2644,1 +1935,1 @@\n-    log_info(cds)(\"The shared archive file's ObjectAlignmentInBytes of %d\"\n+    log_info(cds)(\"The %s's ObjectAlignmentInBytes of %d\"\n@@ -2646,1 +1937,1 @@\n-                  _obj_alignment, ObjectAlignmentInBytes);\n+                  file_type, _obj_alignment, ObjectAlignmentInBytes);\n@@ -2650,2 +1941,2 @@\n-    log_info(cds)(\"The shared archive file's CompactStrings setting (%s)\"\n-                  \" does not equal the current CompactStrings setting (%s).\",\n+    log_info(cds)(\"The %s's CompactStrings setting (%s)\"\n+                  \" does not equal the current CompactStrings setting (%s).\", file_type,\n@@ -2675,2 +1966,2 @@\n-    log_info(cds)(\"The shared archive file's BytecodeVerificationLocal setting (%s)\"\n-                               \" does not equal the current BytecodeVerificationLocal setting (%s).\",\n+    log_info(cds)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+                               \" does not equal the current BytecodeVerificationLocal setting (%s).\", file_type,\n@@ -2687,2 +1978,2 @@\n-    log_info(cds)(\"The shared archive file was created with less restrictive \"\n-                               \"verification setting than the current setting.\");\n+    log_info(cds)(\"The %s was created with less restrictive \"\n+                               \"verification setting than the current setting.\", file_type);\n@@ -2700,1 +1991,1 @@\n-                               \"from the setting in the shared archive.\");\n+                               \"from the setting in the %s.\", file_type);\n@@ -2705,2 +1996,2 @@\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n+    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\", file_type);\n@@ -2709,2 +2000,2 @@\n-  log_info(cds)(\"Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n-                          compressed_oops(), compressed_class_pointers(), compact_headers());\n+  log_info(cds)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n+                          file_type, compressed_oops(), compressed_class_pointers(), compact_headers());\n@@ -2712,2 +2003,2 @@\n-    log_warning(cds)(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n-                               \"different from runtime, CDS will be disabled.\");\n+    log_warning(cds)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+                               \"different from runtime, CDS will be disabled.\", file_type);\n@@ -2736,2 +2027,2 @@\n-    log_warning(cds)(\"Unable to use shared archive.\\nThe shared archive file's UseCompactObjectHeaders setting (%s)\"\n-                     \" does not equal the current UseCompactObjectHeaders setting (%s).\",\n+    log_warning(cds)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n+                     \" does not equal the current UseCompactObjectHeaders setting (%s).\", file_type, file_type,\n@@ -2743,1 +2034,1 @@\n-  if (!_use_optimized_module_handling) {\n+  if (!_use_optimized_module_handling && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -2784,4 +2075,2 @@\n-    SharedClassPathEntry* scpe = shared_path(i);\n-    assert(scpe->is_jar(), \"must be\"); \/\/ other types of scpe will not produce archived classes\n-\n-    const char* path = scpe->name();\n+    const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(i);\n+    const char* path = cl->path();\n@@ -2794,1 +2083,1 @@\n-      ent = ClassLoader::create_class_path_entry(THREAD, path, &st, false, false, scpe->is_multi_release());\n+      ent = ClassLoader::create_class_path_entry(THREAD, path, &st);\n@@ -2818,1 +2107,1 @@\n-  assert(path_index < (int)get_number_of_shared_paths(), \"sanity\");\n+  assert(path_index < AOTClassLocationConfig::runtime()->length(), \"sanity\");\n@@ -2828,0 +2117,1 @@\n+  const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(path_index);\n@@ -2829,1 +2119,4 @@\n-  if (class_loader() != nullptr && !cpe->is_modules_image() && cpe->is_multi_release_jar()) {\n+  if (class_loader() != nullptr && cl->is_multi_release_jar()) {\n+    \/\/ This class was loaded from a multi-release JAR file during dump time. The\n+    \/\/ process for finding its classfile is complex. Let's defer to the Java code\n+    \/\/ in java.lang.ClassLoader.\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":140,"deletions":847,"binary":false,"changes":987,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class AOTClassLocationConfig;\n@@ -55,83 +56,0 @@\n-class SharedClassPathEntry : public MetaspaceObj {\n-  enum {\n-    modules_image_entry,\n-    jar_entry,\n-    dir_entry,\n-    non_existent_entry,\n-    unknown_entry\n-  };\n-\n-  void set_name(const char* name, TRAPS);\n-\n-  u1     _type;\n-  bool   _is_module_path;\n-  bool   _from_class_path_attr;\n-  bool   _is_multi_release;\n-  time_t _timestamp;          \/\/ jar timestamp,  0 if is directory, modules image or other\n-  int64_t      _filesize;     \/\/ jar\/jimage file size, -1 if is directory, -2 if other\n-  Array<char>* _name;\n-  Array<u1>*   _manifest;\n-\n-public:\n-  SharedClassPathEntry() : _type(0), _is_module_path(false),\n-                           _from_class_path_attr(false), _is_multi_release(false), _timestamp(0),\n-                           _filesize(0), _name(nullptr), _manifest(nullptr) {}\n-  static int size() {\n-    static_assert(is_aligned(sizeof(SharedClassPathEntry), wordSize), \"must be\");\n-    return (int)(sizeof(SharedClassPathEntry) \/ wordSize);\n-  }\n-  void init(bool is_modules_image, bool is_module_path, ClassPathEntry* cpe, TRAPS);\n-  void init_as_non_existent(const char* path, TRAPS);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-  MetaspaceObj::Type type() const { return SharedClassPathEntryType; }\n-  bool validate(bool is_class_path = true) const;\n-\n-  \/\/ The _timestamp only gets set for jar files.\n-  bool has_timestamp() const {\n-    return _timestamp != 0;\n-  }\n-  bool is_dir()           const { return _type == dir_entry; }\n-  bool is_modules_image() const { return _type == modules_image_entry; }\n-  bool is_jar()           const { return _type == jar_entry; }\n-  bool is_non_existent()  const { return _type == non_existent_entry; }\n-  bool from_class_path_attr() { return _from_class_path_attr; }\n-  bool is_multi_release()     { return _is_multi_release; }\n-  time_t timestamp() const { return _timestamp; }\n-  const char* name() const;\n-  const char* manifest() const {\n-    return (_manifest == nullptr) ? nullptr : (const char*)_manifest->data();\n-  }\n-  int manifest_size() const {\n-    return (_manifest == nullptr) ? 0 : _manifest->length();\n-  }\n-  void set_manifest(Array<u1>* manifest) {\n-    _manifest = manifest;\n-  }\n-  bool check_non_existent() const;\n-  void copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS);\n-  bool in_named_module() {\n-    return is_modules_image() || \/\/ modules image doesn't contain unnamed modules\n-           _is_module_path;      \/\/ module path doesn't contain unnamed modules\n-  }\n-};\n-\n-class SharedPathTable {\n-  Array<SharedClassPathEntry*>* _entries;\n-public:\n-  SharedPathTable() : _entries(nullptr) {}\n-  SharedPathTable(Array<SharedClassPathEntry*>* entries) : _entries(entries) {}\n-\n-  void dumptime_init(ClassLoaderData* loader_data, TRAPS);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-\n-  int size() {\n-    return _entries == nullptr ? 0 : _entries->length();\n-  }\n-  SharedClassPathEntry* path_at(int index) {\n-    return _entries->at(index);\n-  }\n-  Array<SharedClassPathEntry*>* table() {return _entries;}\n-  void set_table(Array<SharedClassPathEntry*>* table) {_entries = table;}\n-};\n-\n-\n@@ -236,3 +154,0 @@\n-  bool _has_non_jar_in_classpath;                 \/\/ non-jar file entry exists in classpath\n-  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n-                                                  \/\/    0 if no common prefix exists\n@@ -245,12 +160,2 @@\n-  \/\/ The following is a table of all the boot\/app\/module path entries that were used\n-  \/\/ during dumping. At run time, we validate these entries according to their\n-  \/\/ SharedClassPathEntry::_type. See:\n-  \/\/      check_nonempty_dir_in_shared_path_table()\n-  \/\/      validate_shared_path_table()\n-  \/\/      validate_non_existent_class_paths()\n-  size_t _shared_path_table_offset;\n-\n-  jshort _app_class_paths_start_index;  \/\/ Index of first app classpath entry\n-  jshort _app_module_paths_start_index; \/\/ Index of first module path entry\n-  jshort _max_used_path_index;          \/\/ max path index referenced during CDS dump\n-  int    _num_module_paths;             \/\/ number of module path entries\n+  size_t _class_location_config_offset;\n+\n@@ -259,1 +164,1 @@\n-  bool   _has_platform_or_app_classes;  \/\/ Archive contains app classes\n+  bool   _has_platform_or_app_classes;  \/\/ Archive contains app or platform classes\n@@ -276,2 +181,2 @@\n-  char* from_mapped_offset(size_t offset) const {\n-    return mapped_base_address() + offset;\n+  template <typename T> T from_mapped_offset(size_t offset) const {\n+    return (T)(mapped_base_address() + offset);\n@@ -280,0 +185,4 @@\n+  template <typename T> void set_as_offset(T p, size_t *offset) {\n+    set_as_offset((char*)p, offset);\n+  }\n+\n@@ -288,1 +197,0 @@\n-  unsigned int common_app_classpath_prefix_size() const { return _common_app_classpath_prefix_size;         }\n@@ -296,1 +204,0 @@\n-  void set_common_app_classpath_prefix_size(unsigned int s) { _common_app_classpath_prefix_size = s;         }\n@@ -307,3 +214,3 @@\n-  char* cloned_vtables()                   const { return from_mapped_offset(_cloned_vtables_offset); }\n-  char* early_serialized_data()            const { return from_mapped_offset(_early_serialized_data_offset); }\n-  char* serialized_data()                  const { return from_mapped_offset(_serialized_data_offset); }\n+  char* cloned_vtables()                   const { return from_mapped_offset<char*>(_cloned_vtables_offset); }\n+  char* early_serialized_data()            const { return from_mapped_offset<char*>(_early_serialized_data_offset); }\n+  char* serialized_data()                  const { return from_mapped_offset<char*>(_serialized_data_offset); }\n@@ -314,1 +221,0 @@\n-  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n@@ -326,5 +232,0 @@\n-  \/\/ FIXME: These should really return int\n-  jshort max_used_path_index()             const { return _max_used_path_index; }\n-  jshort app_module_paths_start_index()    const { return _app_module_paths_start_index; }\n-  jshort app_class_paths_start_index()     const { return _app_class_paths_start_index; }\n-  int    num_module_paths()                const { return _num_module_paths; }\n@@ -344,2 +245,6 @@\n-  void set_shared_path_table(SharedPathTable table) {\n-    set_as_offset((char*)table.table(), &_shared_path_table_offset);\n+  void set_class_location_config(AOTClassLocationConfig* table) {\n+    set_as_offset(table, &_class_location_config_offset);\n+  }\n+\n+  AOTClassLocationConfig* class_location_config() {\n+    return from_mapped_offset<AOTClassLocationConfig*>(_class_location_config_offset);\n@@ -353,5 +258,0 @@\n-  SharedPathTable shared_path_table() const {\n-    return SharedPathTable((Array<SharedClassPathEntry*>*)\n-                           from_mapped_offset(_shared_path_table_offset));\n-  }\n-\n@@ -367,2 +267,1 @@\n-                size_t base_archive_name_size, size_t base_archive_name_offset,\n-                size_t common_app_classpath_size);\n+                size_t base_archive_name_size, size_t base_archive_name_offset);\n@@ -397,3 +296,0 @@\n-  static SharedPathTable       _shared_path_table;\n-  static bool                  _validating_shared_path_table;\n-\n@@ -408,1 +304,0 @@\n-  static GrowableArray<const char*>* _non_existent_class_paths;\n@@ -414,3 +309,1 @@\n-  static SharedPathTable shared_path_table() {\n-    return _shared_path_table;\n-  }\n+  static bool is_preimage_static_archive(const char* file);\n@@ -419,3 +312,0 @@\n-  static void metaspace_pointers_do(MetaspaceClosure* it) {\n-    _shared_path_table.metaspace_pointers_do(it);\n-  }\n@@ -427,0 +317,1 @@\n+  static void free_current_info();\n@@ -447,2 +338,0 @@\n-  jshort app_module_paths_start_index()       const { return header()->app_module_paths_start_index(); }\n-  jshort app_class_paths_start_index()        const { return header()->app_class_paths_start_index(); }\n@@ -533,6 +422,1 @@\n-  static void allocate_shared_path_table(TRAPS);\n-  static int add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS);\n-  static void check_nonempty_dir_in_shared_path_table();\n-  bool check_module_paths();\n-  bool validate_shared_path_table();\n-  bool validate_non_existent_class_paths();\n+  bool validate_class_location();\n@@ -540,6 +424,0 @@\n-  static void set_shared_path_table(FileMapInfo* info) {\n-    _shared_path_table = info->header()->shared_path_table();\n-  }\n-  static void update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);\n-  static int num_non_existent_class_paths();\n-  static void record_non_existent_class_path_entry(const char* path);\n@@ -556,15 +434,0 @@\n-  static SharedClassPathEntry* shared_path(int index) {\n-    return _shared_path_table.path_at(index);\n-  }\n-\n-  static const char* shared_path_name(int index) {\n-    assert(index >= 0, \"Sanity\");\n-    return shared_path(index)->name();\n-  }\n-\n-  static int get_number_of_shared_paths() {\n-    return _shared_path_table.size();\n-  }\n-\n-  static int get_module_shared_path_index(Symbol* location) NOT_CDS_RETURN_(-1);\n-\n@@ -603,16 +466,0 @@\n-  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(nullptr);\n-  int   num_paths(const char* path) NOT_CDS_RETURN_(0);\n-  bool  check_paths_existence(const char* paths) NOT_CDS_RETURN_(false);\n-  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(nullptr);\n-  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(nullptr);\n-  bool  classpath_failure(const char* msg, const char* name) NOT_CDS_RETURN_(false);\n-  unsigned int longest_common_app_classpath_prefix_len(int num_paths,\n-                                                       GrowableArray<const char*>* rp_array)\n-                                                       NOT_CDS_RETURN_(0);\n-  bool  check_paths(int shared_path_start_idx, int num_paths,\n-                    GrowableArray<const char*>* rp_array,\n-                    unsigned int dumptime_prefix_len,\n-                    unsigned int runtime_prefix_len) NOT_CDS_RETURN_(false);\n-  void  extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths);\n-  bool  validate_boot_class_paths() NOT_CDS_RETURN_(false);\n-  bool  validate_app_class_paths(int shared_app_paths_len) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":23,"deletions":176,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -403,0 +404,5 @@\n+void HeapShared::init_dumping() {\n+  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+}\n+\n@@ -411,2 +417,0 @@\n-  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n-  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n@@ -1174,1 +1178,1 @@\n-      ClassLoaderExt::num_module_paths() > 0) {\n+      AOTClassLocationConfig::runtime()->num_module_paths() > 0) {\n@@ -1178,1 +1182,2 @@\n-                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()),\n+                        AOTClassLocationConfig::runtime()->num_module_paths());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"cds\/finalImageRecipes.hpp\"\n@@ -335,1 +337,1 @@\n-    int size = FileMapInfo::get_number_of_shared_paths();\n+    int size = AOTClassLocationConfig::runtime()->length();\n@@ -338,11 +340,0 @@\n-      if (!CDSConfig::is_dumping_dynamic_archive()) {\n-        FileMapInfo* info;\n-        if (FileMapInfo::dynamic_info() == nullptr) {\n-          info = FileMapInfo::current_info();\n-        } else {\n-          info = FileMapInfo::dynamic_info();\n-        }\n-        ClassLoaderExt::init_paths_start_index(info->app_class_paths_start_index());\n-        ClassLoaderExt::init_app_module_paths_start_index(info->app_module_paths_start_index());\n-        ClassLoaderExt::init_num_module_paths(info->header()->num_module_paths());\n-      }\n@@ -504,0 +495,1 @@\n+  FinalImageRecipes::serialize(soc);\n@@ -563,1 +555,1 @@\n-  char* dump_read_only_tables();\n+  char* dump_read_only_tables(AOTClassLocationConfig*& cl_config);\n@@ -584,1 +576,0 @@\n-    FileMapInfo::metaspace_pointers_do(it);\n@@ -619,1 +610,1 @@\n-char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {\n+char* VM_PopulateDumpSharedSpace::dump_read_only_tables(AOTClassLocationConfig*& cl_config) {\n@@ -623,0 +614,1 @@\n+  cl_config = AOTClassLocationConfig::dumptime()->write_to_archive();\n@@ -624,0 +616,3 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    FinalImageRecipes::record_recipes();\n+  }\n@@ -639,1 +634,3 @@\n-  guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+  if (!CDSConfig::is_dumping_final_static_archive()) {\n+    guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+  }\n@@ -650,1 +647,1 @@\n-  FileMapInfo::check_nonempty_dir_in_shared_path_table();\n+  AOTClassLocationConfig::dumptime_check_nonempty_dirs();\n@@ -684,1 +681,2 @@\n-  char* serialized_data = dump_read_only_tables();\n+  AOTClassLocationConfig* cl_config;\n+  char* serialized_data = dump_read_only_tables(cl_config);\n@@ -693,1 +691,7 @@\n-  const char* static_archive = CDSConfig::static_archive_path();\n+  const char* static_archive;\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    static_archive = AOTCache;\n+    FileMapInfo::free_current_info();\n+  } else {\n+    static_archive = CDSConfig::static_archive_path();\n+  }\n@@ -700,0 +704,1 @@\n+  _map_info->header()->set_class_location_config(cl_config);\n@@ -756,1 +761,1 @@\n-  if (!jcmd_request) {\n+  if (!jcmd_request && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -791,0 +796,4 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    FinalImageRecipes::apply_recipes(CHECK);\n+  }\n@@ -796,1 +805,0 @@\n-  ClassLoader::initialize_shared_path(JavaThread::current());\n@@ -818,7 +826,12 @@\n-  if (!CDSConfig::old_cds_flags_used()) {\n-    \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n-    \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n-    \/\/ to the JLI launcher, as the launcher will fail when trying to\n-    \/\/ run the main class, which is not what we want.\n-    tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n-    vm_exit(0);\n+  if (CDSConfig::new_aot_flags_used()) {\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      tty->print_cr(\"AOTConfiguration recorded: %s\", AOTConfiguration);\n+      vm_exit(0);\n+    } else {\n+      \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n+      \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n+      \/\/ to the JLI launcher, as the launcher will fail when trying to\n+      \/\/ run the main class, which is not what we want.\n+      tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n+      vm_exit(0);\n+    }\n@@ -924,1 +937,10 @@\n-  loadable_descriptors(CHECK);\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ We are running with -Xshare:dump\n+    loadable_descriptors(CHECK);\n+\n+    if (SharedArchiveConfigFile) {\n+      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+      read_extra_data(THREAD, SharedArchiveConfigFile);\n+      log_info(cds)(\"Reading extra data: done.\");\n+    }\n+  }\n@@ -926,4 +948,17 @@\n-  if (SharedArchiveConfigFile) {\n-    log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n-    read_extra_data(THREAD, SharedArchiveConfigFile);\n-    log_info(cds)(\"Reading extra data: done.\");\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    log_info(cds)(\"Reading lambda form invokers from JDK default classlist ...\");\n+    char default_classlist[JVM_MAXPATHLEN];\n+    get_default_classlist(default_classlist, sizeof(default_classlist));\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      ClassListParser::parse_classlist(default_classlist,\n+                                       ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n+  }\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    if (ExtraSharedClassListFile) {\n+      log_info(cds)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n+      ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                       ClassListParser::_parse_all, CHECK);\n+    }\n@@ -951,0 +986,1 @@\n+      ClassLoaderDataShared::ensure_module_entry_tables_exist();\n@@ -1006,2 +1042,2 @@\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n+    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\", CDSConfig::type_of_archive_being_loaded());\n@@ -1017,1 +1053,7 @@\n-  if (!ik->is_shared() && ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n+\n+  if (ik->is_shared() && !CDSConfig::is_dumping_final_static_archive()) {\n+    assert(CDSConfig::is_dumping_dynamic_archive(), \"must be\");\n+    return false;\n+  }\n+\n+  if (ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n@@ -1090,1 +1132,1 @@\n-  log_error(cds)(\"An error has occurred while processing the shared archive file.\");\n+  log_error(cds)(\"An error has occurred while processing the %s.\", CDSConfig::type_of_archive_being_loaded());\n@@ -1094,1 +1136,8 @@\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    vm_exit_during_initialization(\"Must be a valid AOT configuration generated by the current JVM\", AOTConfiguration);\n+  } else if (CDSConfig::new_aot_flags_used()) {\n+    vm_exit_during_initialization(\"Unable to use AOT cache.\", nullptr);\n+  } else {\n+    vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+  }\n@@ -1144,1 +1193,0 @@\n-      FileMapInfo::set_shared_path_table(dynamic_mapinfo);\n@@ -1147,2 +1195,0 @@\n-    } else {\n-      FileMapInfo::set_shared_path_table(static_mapinfo);\n@@ -1651,1 +1697,1 @@\n-  if (!mapinfo->validate_shared_path_table()) {\n+  if (!mapinfo->validate_class_location()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":88,"deletions":42,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"cds\/filemap.hpp\"\n@@ -161,6 +161,0 @@\n-#if INCLUDE_CDS\n-ClassPathEntry* ClassLoader::_app_classpath_entries = nullptr;\n-ClassPathEntry* ClassLoader::_last_app_classpath_entry = nullptr;\n-ClassPathEntry* ClassLoader::_module_path_entries = nullptr;\n-ClassPathEntry* ClassLoader::_last_module_path_entry = nullptr;\n-#endif\n@@ -304,2 +298,1 @@\n-ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,\n-                                     bool is_boot_append, bool from_class_path_attr, bool multi_release) : ClassPathEntry() {\n+ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name) : ClassPathEntry() {\n@@ -308,2 +301,0 @@\n-  _from_class_path_attr = from_class_path_attr;\n-  _multi_release = multi_release;\n@@ -466,8 +457,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::exit_with_path_failure(const char* error, const char* message) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  tty->print_cr(\"Hint: enable -Xlog:class+path=info to diagnose the failure\");\n-  vm_exit_during_cds_dumping(error, message);\n-}\n-#endif\n-\n@@ -536,51 +519,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::setup_app_search_path(JavaThread* current, const char *class_path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  ResourceMark rm(current);\n-  ClasspathStream cp_stream(class_path);\n-\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    update_class_path_entry_list(current, path, \/* check_for_duplicates *\/ true,\n-                                 \/* is_boot_append *\/ false, \/* from_class_path_attr *\/ false);\n-  }\n-}\n-\n-void ClassLoader::add_to_module_path_entries(const char* path,\n-                                             ClassPathEntry* entry) {\n-  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  \/\/ The entry does not exist, add to the list\n-  if (_module_path_entries == nullptr) {\n-    assert(_last_module_path_entry == nullptr, \"Sanity\");\n-    _module_path_entries = _last_module_path_entry = entry;\n-  } else {\n-    _last_module_path_entry->set_next(entry);\n-    _last_module_path_entry = entry;\n-  }\n-}\n-\n-\/\/ Add a module path to the _module_path_entries list.\n-void ClassLoader::setup_module_search_path(JavaThread* current, const char* path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  struct stat st;\n-  if (os::stat(path, &st) != 0) {\n-    tty->print_cr(\"os::stat error %d (%s). CDS dump aborted (path was \\\"%s\\\").\",\n-      errno, os::errno_name(errno), path);\n-    vm_exit_during_initialization();\n-  }\n-  \/\/ File or directory found\n-  ClassPathEntry* new_entry = nullptr;\n-  new_entry = create_class_path_entry(current, path, &st,\n-                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/);\n-  if (new_entry != nullptr) {\n-    \/\/ ClassLoaderExt::process_module_table() filters out non-jar entries before calling this function.\n-    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n-    add_to_module_path_entries(path, new_entry);\n-  }\n-}\n-\n-#endif \/\/ INCLUDE_CDS\n-\n@@ -619,1 +551,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n+        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st);\n@@ -693,2 +625,1 @@\n-      update_class_path_entry_list(current, path, \/* check_for_duplicates *\/ false,\n-                                    \/* is_boot_append *\/ true, \/* from_class_path_attr *\/ false);\n+      update_class_path_entry_list(current, path);\n@@ -725,1 +656,1 @@\n-    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n+    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st);\n@@ -751,4 +682,1 @@\n-                                                     const char *path, const struct stat* st,\n-                                                     bool is_boot_append,\n-                                                     bool from_class_path_attr,\n-                                                     bool is_multi_release) {\n+                                                     const char *path, const struct stat* st) {\n@@ -767,1 +695,1 @@\n-      new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr, is_multi_release);\n+      new_entry = new ClassPathZipEntry(zip, path);\n@@ -769,3 +697,0 @@\n-#if INCLUDE_CDS\n-      ClassLoaderExt::set_has_non_jar_in_classpath();\n-#endif\n@@ -787,1 +712,1 @@\n-ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {\n+ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path) {\n@@ -800,1 +725,1 @@\n-          return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false, false);\n+          return new ClassPathZipEntry(zip, canonical_path);\n@@ -823,44 +748,1 @@\n-\/\/ Record the path entries specified in -cp during dump time. The recorded\n-\/\/ information will be used at runtime for loading the archived app classes.\n-\/\/\n-\/\/ Note that at dump time, ClassLoader::_app_classpath_entries are NOT used for\n-\/\/ loading app classes. Instead, the app class are loaded by the\n-\/\/ jdk\/internal\/loader\/ClassLoaders$AppClassLoader instance.\n-bool ClassLoader::add_to_app_classpath_entries(JavaThread* current,\n-                                               ClassPathEntry* entry,\n-                                               bool check_for_duplicates) {\n-#if INCLUDE_CDS\n-  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n-  ClassPathEntry* e = _app_classpath_entries;\n-  if (check_for_duplicates) {\n-    while (e != nullptr) {\n-      if (strcmp(e->name(), entry->name()) == 0 &&\n-          e->from_class_path_attr() == entry->from_class_path_attr()) {\n-        \/\/ entry already exists\n-        return false;\n-      }\n-      e = e->next();\n-    }\n-  }\n-\n-  \/\/ The entry does not exist, add to the list\n-  if (_app_classpath_entries == nullptr) {\n-    assert(_last_app_classpath_entry == nullptr, \"Sanity\");\n-    _app_classpath_entries = _last_app_classpath_entry = entry;\n-  } else {\n-    _last_app_classpath_entry->set_next(entry);\n-    _last_app_classpath_entry = entry;\n-  }\n-\n-  if (entry->is_jar_file()) {\n-    ClassLoaderExt::process_jar_manifest(current, entry);\n-  }\n-#endif\n-  return true;\n-}\n-\n-bool ClassLoader::update_class_path_entry_list(JavaThread* current,\n-                                               const char *path,\n-                                               bool check_for_duplicates,\n-                                               bool is_boot_append,\n-                                               bool from_class_path_attr) {\n+bool ClassLoader::update_class_path_entry_list(JavaThread* current, const char *path) {\n@@ -872,1 +754,1 @@\n-    new_entry = create_class_path_entry(current, path, &st, is_boot_append, from_class_path_attr);\n+    new_entry = create_class_path_entry(current, path, &st);\n@@ -879,8 +761,1 @@\n-    if (is_boot_append) {\n-      add_to_boot_append_entries(new_entry);\n-    } else {\n-      if (!add_to_app_classpath_entries(current, new_entry, check_for_duplicates)) {\n-        \/\/ new_entry is not saved, free it now\n-        delete new_entry;\n-      }\n-    }\n+    add_to_boot_append_entries(new_entry);\n@@ -1344,1 +1219,7 @@\n-  if (FileMapInfo::get_number_of_shared_paths() > 0) {\n+  if (!AOTClassLocationConfig::dumptime_is_ready()) {\n+    \/\/ The shared path table is set up after module system initialization.\n+    \/\/ The path table contains no entry before that. Any classes loaded prior\n+    \/\/ to the setup of the shared path table must be from the modules image.\n+    assert(stream->from_boot_loader_modules_image(), \"stream must be loaded by boot loader from modules image\");\n+    classpath_index = 0;\n+  } else {\n@@ -1350,11 +1231,13 @@\n-    for (int i = 0; i < FileMapInfo::get_number_of_shared_paths(); i++) {\n-      SharedClassPathEntry* ent = FileMapInfo::shared_path(i);\n-      \/\/ A shared path has been validated during its creation in ClassLoader::create_class_path_entry(),\n-      \/\/ it must be valid here.\n-      assert(ent->name() != nullptr, \"sanity\");\n-      \/\/ If the path (from the class stream source) is the same as the shared\n-      \/\/ class or module path, then we have a match.\n-      \/\/ src may come from the App\/Platform class loaders, which would canonicalize\n-      \/\/ the file name. We cannot use strcmp to check for equality against ent->name().\n-      \/\/ We must use os::same_files (which is faster than canonicalizing ent->name()).\n-      if (os::same_files(ent->name(), path)) {\n+    AOTClassLocationConfig::dumptime_iterate([&] (AOTClassLocation* cl) {\n+      int i = cl->index();\n+      \/\/ for index 0 and the stream->source() is the modules image or has the jrt: protocol.\n+      \/\/ The class must be from the runtime modules image.\n+      if (cl->is_modules_image() && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n+        classpath_index = i;\n+      } else if (os::same_files(cl->path(), path)) {\n+        \/\/ If the path (from the class stream source) is the same as the shared\n+        \/\/ class or module path, then we have a match.\n+        \/\/ src may come from the App\/Platform class loaders, which would canonicalize\n+        \/\/ the file name. We cannot use strcmp to check for equality against cs->path().\n+        \/\/ We must use os::same_files (which is faster than canonicalizing cs->path()).\n+\n@@ -1367,3 +1250,1 @@\n-          if (SystemDictionary::is_system_class_loader(loader) &&\n-              (i >= ClassLoaderExt::app_class_paths_start_index()) &&\n-              (i < ClassLoaderExt::app_module_paths_start_index())) {\n+          if (SystemDictionary::is_system_class_loader(loader) && cl->from_app_classpath()) {\n@@ -1371,3 +1252,1 @@\n-            break;\n-            if ((i >= 1) &&\n-                (i < ClassLoaderExt::app_class_paths_start_index())) {\n+            if (cl->from_boot_classpath()) {\n@@ -1379,1 +1258,0 @@\n-              break;\n@@ -1385,6 +1263,2 @@\n-          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n-            if (i >= ClassLoaderExt::app_module_paths_start_index() &&\n-                i < FileMapInfo::get_number_of_shared_paths()) {\n-              classpath_index = i;\n-              break;\n-            }\n+          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && cl->from_module_path()) {\n+            classpath_index = i;\n@@ -1394,5 +1268,4 @@\n-      \/\/ for index 0 and the stream->source() is the modules image or has the jrt: protocol.\n-      \/\/ The class must be from the runtime modules image.\n-      if (i == 0 && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n-        classpath_index = i;\n-        break;\n+      if (classpath_index >= 0) {\n+        return false; \/\/ quit iterating\n+      } else {\n+        return true; \/\/ Keep iterating\n@@ -1400,1 +1273,1 @@\n-    }\n+    });\n@@ -1410,9 +1283,0 @@\n-  } else {\n-    \/\/ The shared path table is set up after module system initialization.\n-    \/\/ The path table contains no entry before that. Any classes loaded prior\n-    \/\/ to the setup of the shared path table must be from the modules image.\n-    if (!CDSConfig::is_valhalla_preview()) {\n-      assert(stream->from_boot_loader_modules_image(), \"stream must be loaded by boot loader from modules image\");\n-    }\n-    assert(FileMapInfo::get_number_of_shared_paths() == 0, \"shared path table must not have been setup\");\n-    classpath_index = 0;\n@@ -1459,1 +1323,1 @@\n-      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+      ik->set_shared_classpath_index(AOTClassLocationConfig::dumptime()->app_cp_start_index());\n@@ -1568,28 +1432,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::initialize_shared_path(JavaThread* current) {\n-  if (CDSConfig::is_dumping_archive()) {\n-    ClassLoaderExt::setup_search_paths(current);\n-  }\n-}\n-\n-void ClassLoader::initialize_module_path(TRAPS) {\n-  if (CDSConfig::is_dumping_archive()) {\n-    ClassLoaderExt::setup_module_paths(THREAD);\n-    FileMapInfo::allocate_shared_path_table(CHECK);\n-  }\n-}\n-\n-\/\/ Helper function used by CDS code to get the number of module path\n-\/\/ entries during shared classpath setup time.\n-int ClassLoader::num_module_path_entries() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  int num_entries = 0;\n-  ClassPathEntry* e= ClassLoader::_module_path_entries;\n-  while (e != nullptr) {\n-    num_entries ++;\n-    e = e->next();\n-  }\n-  return num_entries;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":42,"deletions":206,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -873,0 +873,1 @@\n+int java_lang_Class::_is_primitive_offset;\n@@ -1067,1 +1068,1 @@\n-  int computed_modifiers = k->compute_modifier_flags();\n+  u2 computed_modifiers = k->compute_modifier_flags();\n@@ -1287,2 +1288,5 @@\n-    java_class->obj_field_put(_component_mirror_offset, comp_mirror);\n-  }\n+  assert(java_lang_Class::as_Klass(java_class) != nullptr &&\n+         java_lang_Class::as_Klass(java_class)->is_array_klass(), \"must be\");\n+  java_class->obj_field_put(_component_mirror_offset, comp_mirror);\n+}\n+\n@@ -1362,0 +1366,6 @@\n+void java_lang_Class::set_is_primitive(oop java_class) {\n+  assert(_is_primitive_offset != 0, \"must be set\");\n+  java_class->bool_field_put(_is_primitive_offset, true);\n+}\n+\n+\n@@ -1363,2 +1373,1 @@\n-  \/\/ This should be improved by adding a field at the Java level or by\n-  \/\/ introducing a new VM klass (see comment in ClassFileParser)\n+  \/\/ Mirrors for basic types have a null klass field, which makes them special.\n@@ -1376,0 +1385,1 @@\n+  set_is_primitive(java_class);\n@@ -1521,2 +1531,3 @@\n-  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), int_signature,    false); \\\n-  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false);\n+  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), char_signature,    false); \\\n+  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false); \\\n+  macro(_is_primitive_offset,        k, \"primitive\",           bool_signature,         false);\n@@ -1558,1 +1569,1 @@\n-  return the_class_mirror->int_field(_modifiers_offset);\n+  return the_class_mirror->char_field(_modifiers_offset);\n@@ -1561,1 +1572,1 @@\n-void java_lang_Class::set_modifiers(oop the_class_mirror, int value) {\n+void java_lang_Class::set_modifiers(oop the_class_mirror, u2 value) {\n@@ -1563,1 +1574,1 @@\n-  the_class_mirror->int_field_put(_modifiers_offset, value);\n+  the_class_mirror->char_field_put(_modifiers_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  static int _is_primitive_offset;\n@@ -307,0 +308,1 @@\n+  static void set_is_primitive(oop java_class);\n@@ -344,1 +346,1 @@\n-  static void set_modifiers(oop java_class, int value);\n+  static void set_modifiers(oop java_class, u2 value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,0 +235,3 @@\n+    if (frame->verifier()->has_error()) {\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -967,1 +968,1 @@\n-  SharedClassPathEntry* scp_entry = FileMapInfo::shared_path(scp_index);\n+  const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(scp_index);\n@@ -969,1 +970,1 @@\n-    assert(scp_entry != nullptr, \"must be\");\n+    assert(cl != nullptr, \"must be\");\n@@ -972,1 +973,1 @@\n-    \/\/ [1] scp_entry->is_modules_image(): classes in java.base, or,\n+    \/\/ [1] cs->is_modules_image(): classes in java.base, or,\n@@ -974,1 +975,1 @@\n-    assert(scp_entry->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n+    assert(cl->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n@@ -991,1 +992,1 @@\n-  bool was_archived_from_named_module = scp_entry->in_named_module();\n+  bool was_archived_from_named_module = !cl->has_unnamed_module();\n@@ -1214,0 +1215,4 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    SystemDictionaryShared::init_dumptime_info_from_preimage(ik);\n+  }\n@@ -1625,0 +1630,3 @@\n+  if (CDSConfig::is_dumping_archive()) {\n+    AOTClassLocationConfig::dumptime_init(THREAD);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -63,0 +62,3 @@\n+#if INCLUDE_CDS\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#endif\n@@ -238,0 +240,1 @@\n+#if INCLUDE_CDS\n@@ -243,0 +246,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,3 +259,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,6 +307,0 @@\n-  do_intrinsic(_isInterface,              java_lang_Class,        isInterface_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isInterface_name,                                \"isInterface\")                                         \\\n-  do_intrinsic(_isArray,                  java_lang_Class,        isArray_name, void_boolean_signature,          F_RN)  \\\n-   do_name(     isArray_name,                                    \"isArray\")                                             \\\n-  do_intrinsic(_isPrimitive,              java_lang_Class,        isPrimitive_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isPrimitive_name,                                \"isPrimitive\")                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -997,4 +997,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -552,9 +552,0 @@\n-JNIEXPORT jobject JNICALL\n-JVM_GetProtectionDomain(JNIEnv *env, jclass cls);\n-\n-JNIEXPORT jboolean JNICALL\n-JVM_IsArrayClass(JNIEnv *env, jclass cls);\n-\n-JNIEXPORT jboolean JNICALL\n-JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);\n-\n@@ -570,3 +561,0 @@\n-JNIEXPORT jint JNICALL\n-JVM_GetClassModifiers(JNIEnv *env, jclass cls);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  DEBUG_ONLY(LOG_TAG(deathtest2)) \/* Log Internal death test tag *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,3 +317,2 @@\n-  f(SharedClassPathEntry) \\\n-  f(RecordComponent) \\\n-  f(InlineLayoutInfo)\n+  f(InlineLayoutInfo) \\\n+  f(RecordComponent)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -458,0 +458,5 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive() && resolved_references() != nullptr) {\n+    objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), resolved_references()->length(), CHECK);\n+    HeapShared::add_scratch_resolved_references(this, scratch_references);\n+  }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2963,0 +2963,1 @@\n+  DEBUG_ONLY(_shared_class_load_count = 0);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,3 +171,3 @@\n-  \/\/ This is an index into FileMapHeader::_shared_path_table[], to\n-  \/\/ associate this class with the JAR file where it's loaded from during\n-  \/\/ dump time. If a class is not loaded from the shared archive, this field is\n+  \/\/ This is an index into AOTClassLocationConfig::class_locations(), to\n+  \/\/ indicate the AOTClassLocation where this class is loaded from during\n+  \/\/ dump time. If a class is not loaded from the AOT cache, this field is\n@@ -779,1 +779,1 @@\n-  virtual u2 compute_modifier_flags() const = 0;\n+  \/\/ Get modifier flags from Java mirror cache.\n@@ -782,0 +782,5 @@\n+  \/\/ Compute modifier flags from the original data. This also allows\n+  \/\/ accessing flags when Java mirror is already dead, e.g. during class\n+  \/\/ unloading.\n+  virtual u2 compute_modifier_flags() const = 0;\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -765,3 +765,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -526,3 +526,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n@@ -4090,11 +4087,0 @@\n-  case vmIntrinsics::_isInterface:\n-    prim_return_value = intcon(0);\n-    break;\n-  case vmIntrinsics::_isArray:\n-    prim_return_value = intcon(0);\n-    expect_prim = true;  \/\/ cf. ObjectStreamClass.getClassSignature\n-    break;\n-  case vmIntrinsics::_isPrimitive:\n-    prim_return_value = intcon(1);\n-    expect_prim = true;  \/\/ obviously\n-    break;\n@@ -4169,22 +4155,0 @@\n-  case vmIntrinsics::_isInterface:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsInterface.)\n-    if (generate_interface_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an interface.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isArray:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsArrayClass.)\n-    if (generate_array_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an array.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isPrimitive:\n-    query_value = intcon(0); \/\/ \"normal\" path produces false\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1366,3 +1366,3 @@\n-  IfTrueNode* create_new_if_for_predicate(\n-    ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n-    bool rewire_uncommon_proj_phi_inputs = false);\n+  IfTrueNode* create_new_if_for_predicate(const ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+                                          Deoptimization::DeoptReason reason, int opcode,\n+                                          bool rewire_uncommon_proj_phi_inputs = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1294,14 +1294,0 @@\n-JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    return JNI_FALSE;\n-  }\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  jboolean result = k->is_interface();\n-  assert(!result || k->is_instance_klass(),\n-         \"all interfaces are instance types\");\n-  \/\/ The compiler intrinsic for isInterface tests the\n-  \/\/ Klass::_access_flags bits in the same way.\n-  return result;\n-JVM_END\n-\n@@ -1385,12 +1371,0 @@\n-JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n-  return (k != nullptr) && k->is_array_klass() ? true : false;\n-JVM_END\n-\n-\n-JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  return (jboolean) java_lang_Class::is_primitive(mirror);\n-JVM_END\n-\n-\n@@ -2468,1 +2442,17 @@\n-\/\/ Please, refer to the description in the jvmtiThreadSate.hpp.\n+\/\/ Please, refer to the description in the jvmtiThreadState.hpp.\n+\n+JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  \/\/ This isn't necessary since answer is the same since redefinition\n+  \/\/ has already checked this matches for the scratch class.\n+  \/\/ k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);\n+  jboolean result = k->is_interface();\n+  assert(!result || k->is_instance_klass(),\n+         \"all interfaces are instance types\");\n+  return result;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, true);\n+    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment);\n@@ -712,1 +712,1 @@\n-    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);\n+    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n+#include \"jvm.h\"\n@@ -1812,0 +1812,4 @@\n+WB_ENTRY(jboolean, WB_IsStaticallyLinked(JNIEnv* env, jobject wb))\n+  return JVM_IsStaticallyLinked();\n+WB_END\n+\n@@ -2755,8 +2759,0 @@\n-WB_ENTRY(void, WB_LockCritical(JNIEnv* env, jobject wb))\n-  GCLocker::lock_critical(thread);\n-WB_END\n-\n-WB_ENTRY(void, WB_UnlockCritical(JNIEnv* env, jobject wb))\n-  GCLocker::unlock_critical(thread);\n-WB_END\n-\n@@ -3109,2 +3105,0 @@\n-  {CC\"lockCritical\",    CC\"()V\",                      (void*)&WB_LockCritical},\n-  {CC\"unlockCritical\",  CC\"()V\",                      (void*)&WB_UnlockCritical},\n@@ -3120,1 +3114,2 @@\n-  {CC\"rootChunkWordSize\", CC\"()J\",                    (void*)&WB_RootChunkWordSize}\n+  {CC\"rootChunkWordSize\", CC\"()J\",                    (void*)&WB_RootChunkWordSize},\n+  {CC\"isStatic\", CC\"()Z\",                             (void*)&WB_IsStaticallyLinked}\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"cds\/filemap.hpp\"\n@@ -538,0 +537,1 @@\n+  { \"ZMarkStackSpaceLimit\",         JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n@@ -1369,3 +1369,7 @@\n-    jio_fprintf(defaultStream::error_stream(),\n-      \"Class data sharing is inconsistent with other specified options.\\n\");\n-    vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    log_error(cds)(\"%s is incompatible with other specified options.\",\n+                   CDSConfig::new_aot_flags_used() ? \"AOT cache\" : \"CDS\");\n+    if (CDSConfig::new_aot_flags_used()) {\n+      vm_exit_during_initialization(\"Unable to use AOT cache\", message);\n+    } else {\n+      vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    }\n@@ -1373,1 +1377,5 @@\n-    log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    if (CDSConfig::new_aot_flags_used()) {\n+      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+    } else {\n+      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    }\n@@ -2665,3 +2673,3 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n-        ret = true;\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n+        const char* async_tail = tail + strlen(\":async\");\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -484,0 +484,4 @@\n+  develop(bool, TestingAsyncLoggingDeathTest, false,                        \\\n+          \"Recursive logging death test\")                                   \\\n+  develop(bool, TestingAsyncLoggingDeathTestNoCrash, false,                 \\\n+          \"Recursive logging death test (no crash)\")                        \\\n@@ -1628,1 +1632,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1632,1 +1636,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1636,1 +1640,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1640,1 +1644,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1644,1 +1648,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1648,1 +1652,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1652,1 +1656,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1656,1 +1660,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1660,1 +1664,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1664,1 +1668,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1668,1 +1672,1 @@\n-          range(-1, 127)                                                    \\\n+          range(min_jint, max_jint)                                         \\\n@@ -1894,1 +1898,1 @@\n-          range(100*K, 50*M)                                                \\\n+          range(DEBUG_ONLY(192) NOT_DEBUG(100*K), 50*M)                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -943,0 +943,3 @@\n+  \/\/ Atomic version; invoked by a thread other than the owning thread.\n+  bool in_critical_atomic() { return Atomic::load(&_jni_active_critical) > 0; }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -412,3 +412,0 @@\n-  \/\/ Update the count of active JNI critical regions\n-  GCLocker::set_jni_lock_count(_current_jni_active_count);\n-\n@@ -475,0 +472,2 @@\n+  SafepointTracing::leave();\n+\n@@ -889,0 +888,1 @@\n+jlong SafepointTracing::_last_safepoint_leave_time_ns = 0;\n@@ -990,0 +990,4 @@\n+void SafepointTracing::leave() {\n+  _last_safepoint_leave_time_ns = os::javaTimeNanos();\n+}\n+\n@@ -1008,0 +1012,1 @@\n+     \"Leaving safepoint: \" JLONG_FORMAT \" ns, \"\n@@ -1011,3 +1016,4 @@\n-      _last_safepoint_sync_time_ns    - _last_safepoint_begin_time_ns,\n-      _last_safepoint_end_time_ns     - _last_safepoint_sync_time_ns,\n-      _last_safepoint_end_time_ns     - _last_safepoint_begin_time_ns\n+      _last_safepoint_sync_time_ns  - _last_safepoint_begin_time_ns,\n+      _last_safepoint_leave_time_ns - _last_safepoint_sync_time_ns,\n+      _last_safepoint_end_time_ns   - _last_safepoint_leave_time_ns,\n+      _last_safepoint_end_time_ns   - _last_safepoint_begin_time_ns\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -565,0 +565,2 @@\n+  do_stub(initial, atomic_add)                                          \\\n+  do_entry(initial, atomic_add, atomic_add_entry, atomic_add_entry)     \\\n@@ -651,2 +653,0 @@\n-  do_stub(compiler, atomic_add)                                         \\\n-  do_entry(compiler, atomic_add, atomic_add_entry, atomic_add_entry)    \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -803,9 +803,0 @@\n-#if INCLUDE_CDS\n-  \/\/ capture the module path info from the ModuleEntryTable\n-  ClassLoader::initialize_module_path(THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n-    vm_exit_during_initialization(\"ClassLoader::initialize_module_path() failed unexpectedly\");\n-  }\n-#endif\n-\n@@ -866,1 +857,5 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ Classic -Xshare:dump, aka \"old workflow\"\n+    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+  } else if (CDSConfig::is_dumping_final_static_archive()) {\n+    tty->print_cr(\"Reading AOTConfiguration %s and writing AOTCache %s\", AOTConfiguration, AOTCache);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType, int mods, ProtectionDomain pd) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim) {\n@@ -245,0 +245,1 @@\n+        \/\/ The following assignments are done directly by the VM without calling this constructor.\n@@ -249,0 +250,1 @@\n+        primitive = isPrim;\n@@ -834,2 +836,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isInterface();\n+    public boolean isInterface() {\n+        return Modifier.isInterface(modifiers);\n+    }\n@@ -845,2 +848,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isArray();\n+    public boolean isArray() {\n+        return componentType != null;\n+    }\n@@ -887,2 +891,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isPrimitive();\n+    public boolean isPrimitive() {\n+        return primitive;\n+    }\n@@ -1046,1 +1051,2 @@\n-    private final transient int modifiers;  \/\/ Set by the VM\n+    private final transient char modifiers;  \/\/ Set by the VM\n+    private final transient boolean primitive;  \/\/ Set by the VM if the Class is a primitive type.\n@@ -1328,6 +1334,1 @@\n-        \/\/ Only return for array types. Storage may be reused for Class for instance types.\n-        if (isArray()) {\n-            return componentType;\n-        } else {\n-            return null;\n-        }\n+        return componentType;\n@@ -1336,1 +1337,3 @@\n-    private final Class<?> componentType;\n+    \/\/ The componentType field's null value is the sole indication that the class\n+    \/\/ is an array - see isArray().\n+    private transient final Class<?> componentType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n- * ClassTransform ct = ClassTransform.transformingMethodBodiess(fooToBar);\n+ * ClassTransform ct = ClassTransform.transformingMethodBodies(fooToBar);\n@@ -377,1 +377,1 @@\n- * byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n+ * byte[] newBytes = cc.transformClass(cc.parse(bytes), ct);\n@@ -396,1 +396,1 @@\n- * byte[] newBytes = cc.transform(cc.parse(bytes),\n+ * byte[] newBytes = cc.transformClass(cc.parse(bytes),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-    {\"isInterface\",      \"()Z\",             (void *)&JVM_IsInterface},\n-    {\"isArray\",          \"()Z\",             (void *)&JVM_IsArrayClass},\n@@ -62,1 +60,0 @@\n-    {\"isPrimitive\",      \"()Z\",             (void *)&JVM_IsPrimitiveClass},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2466,1 +2466,6 @@\n-                noteCyclic(pos, (ClassSymbol)c);\n+                log.error(pos, Errors.CyclicInheritance(c));\n+                seenClasses.stream()\n+                  .filter(s -> !s.type.isErroneous())\n+                  .filter(ClassSymbol.class::isInstance)\n+                  .map(ClassSymbol.class::cast)\n+                  .forEach(Check.this::handleCyclic);\n@@ -2543,1 +2548,2 @@\n-            noteCyclic(pos, (ClassSymbol)c);\n+            log.error(pos, Errors.CyclicInheritance(c));\n+            handleCyclic((ClassSymbol)c);\n@@ -2570,3 +2576,4 @@\n-    \/** Note that we found an inheritance cycle. *\/\n-    private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {\n-        log.error(pos, Errors.CyclicInheritance(c));\n+    \/** Handle finding an inheritance cycle on a class by setting\n+     *  the class' and its supertypes' types to the error type.\n+     **\/\n+    private void handleCyclic(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-gc\/stress\/gclocker\/TestExcessGCLockerCollections.java 8229120 generic-all\n@@ -248,2 +247,0 @@\n-vmTestbase\/gc\/lock\/jni\/jnilock002\/TestDescription.java 8192647 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,13 +163,0 @@\n-hotspot_not_fast_compiler = \\\n-  :hotspot_compiler \\\n-  -:tier1_compiler \\\n-  -:hotspot_slow_compiler\n-\n-hotspot_slow_compiler = \\\n-  compiler\/codecache\/stress \\\n-  compiler\/codegen\/aes \\\n-  compiler\/gcbarriers\/PreserveFPRegistersTest.java \\\n-  compiler\/memoryinitialization\/ZeroTLABTest.java \\\n-  compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java \\\n-  :hotspot_compiler_arraycopy\n-\n@@ -181,0 +168,1 @@\n+  -compiler\/arraycopy\/stress \\\n@@ -190,2 +178,1 @@\n-  -compiler\/c2\/Test6912517.java \\\n-  -:hotspot_slow_compiler\n+  -compiler\/c2\/Test6912517.java\n@@ -208,1 +195,4 @@\n-  -:hotspot_slow_compiler\n+  -compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java \\\n+  -compiler\/codecache\/stress \\\n+  -compiler\/codegen\/aes \\\n+  -compiler\/gcbarriers\/PreserveFPRegistersTest.java\n@@ -233,0 +223,1 @@\n+  -compiler\/memoryinitialization\/ZeroTLABTest.java \\\n@@ -242,1 +233,0 @@\n-  compiler\/codegen\/ \\\n@@ -260,2 +250,1 @@\n-  -:tier1_compiler \\\n-  -:hotspot_slow_compiler\n+  -:tier1_compiler\n@@ -439,0 +428,1 @@\n+ -runtime\/cds\/appcds\/aotClassLinking \\\n@@ -457,1 +447,0 @@\n- -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -935,4 +935,6 @@\n-            return f.getName().equals(\"classLoader\") ||\n-                   f.getName().equals(\"classData\") ||\n-                   f.getName().equals(\"modifiers\") ||\n-                   f.getName().equals(\"protectionDomain\");\n+            String name = f.getName();\n+            return name.equals(\"classLoader\") ||\n+                   name.equals(\"classData\") ||\n+                   name.equals(\"modifiers\") ||\n+                   name.equals(\"protectionDomain\") ||\n+                   name.equals(\"primitive\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -641,3 +641,0 @@\n-com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java                     8039280 generic-all\n-com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java            8039280 generic-all\n-com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java              8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -642,3 +642,0 @@\n-    com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -132,0 +133,1 @@\n+        map.put(\"java.enablePreview\", this::isPreviewEnabled);\n@@ -143,0 +145,1 @@\n+        map.put(\"jdk.static\", this::isStatic);\n@@ -589,0 +592,3 @@\n+    protected String isPreviewEnabled() {\n+        return \"\" + PreviewFeatures.isEnabled();\n+    }\n@@ -824,0 +830,4 @@\n+    private String isStatic() {\n+        return Boolean.toString(WB.isStatic());\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -803,4 +803,0 @@\n-  public native void lockCritical();\n-\n-  public native void unlockCritical();\n-\n@@ -815,0 +811,2 @@\n+\n+  public native boolean isStatic();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}