{"files":[{"patch":"@@ -235,1 +235,1 @@\n-class CastI2NNode : public Node {\n+class CastI2NNode : public TypeNode {\n@@ -237,1 +237,4 @@\n-  CastI2NNode(Node* ctrl, Node* n) : Node(ctrl, n) { }\n+  CastI2NNode(Node* ctrl, Node* n, const Type* t) : TypeNode(t, 2) {\n+    init_req(0, ctrl);\n+    init_req(1, n);\n+  }\n@@ -240,1 +243,0 @@\n-  virtual const Type* bottom_type() const { return TypeNarrowOop::BOTTOM; }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-        value = gvn->transform(new CastI2NNode(kit->control(), value));\n+        value = gvn->transform(new CastI2NNode(kit->control(), value, val_type->make_narrowoop()));\n@@ -541,1 +541,0 @@\n-        value = gvn->transform(new CastPPNode(kit->control(), value, val_type, ConstraintCastNode::UnconditionalDependency));\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,4 +300,0 @@\n-        \/\/ It is not safe to step over MemBarCPUOrders because they guard mismatched accesses\n-        if (is_strict_final_load && proj_in->Opcode() == Op_MemBarCPUOrder) {\n-          break;\n-        }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}