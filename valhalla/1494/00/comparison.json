{"files":[{"patch":"@@ -300,0 +300,4 @@\n+        \/\/ It is not safe to step over MemBarCPUOrders because they guard mismatched accesses\n+        if (is_strict_final_load && proj_in->Opcode() == Op_MemBarCPUOrder) {\n+          break;\n+        }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,2 @@\n+runtime\/cds\/appcds\/RewriteBytecodesInlineTest.java 8361082 generic-all\n+compiler\/gcbarriers\/TestG1BarrierGeneration.java 8361166 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8354981 8359345\n+ * @summary Test that membars are emitted around flat, atomic loads and stores.\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -Xbatch TestMemBars\n+ *\/\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestMemBars {\n+    static long VAL = 42; \/\/ Prevent constant folding\n+\n+    static value class MyValue1 {\n+        @Strict\n+        @NullRestricted\n+        MyValue3 val = new MyValue3(); \/\/ Too large to be flattened\n+\n+        int unused = 42; \/\/ Make sure it's not naturally atomic\n+    }\n+\n+    static value class MyValue2 {\n+        @Strict\n+        MyValue3 val = new MyValue3(); \/\/ Too large to be flattened\n+\n+        int unused = 42; \/\/ Make sure it's not naturally atomic\n+    }\n+\n+    static value class MyValue3 {\n+        long l0 = VAL;\n+        long l1 = VAL;\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue1 field1 = new MyValue1();\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue2 field2 = new MyValue2();\n+\n+    static MyValue1[] array1 = new MyValue1[1];\n+    static MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, new MyValue1());\n+    static MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 1, new MyValue1());\n+    static MyValue1[] array4 = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, 1);\n+    static {\n+        array1[0] = new MyValue1();\n+        array4[0] = new MyValue1();\n+    }\n+\n+    static MyValue2[] array5 = new MyValue2[1];\n+    static MyValue2[] array6 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, new MyValue2());\n+    static MyValue2[] array7 = (MyValue2[])ValueClass.newNullRestrictedAtomicArray(MyValue2.class, 1, new MyValue2());\n+    static MyValue2[] array8 = (MyValue2[])ValueClass.newNullableAtomicArray(MyValue2.class, 1);\n+    static {\n+        array5[0] = new MyValue2();\n+        array8[0] = new MyValue2();\n+    }\n+\n+    public long testFieldLoad1() {\n+        return field1.val.l0;\n+    }\n+\n+    public void testFieldStore1(MyValue1 val) {\n+        field1 = val;\n+    }\n+\n+    public long testFieldLoad2() {\n+        return field2.val.l0;\n+    }\n+\n+    public void testFieldStore2(MyValue2 val) {\n+        field2 = val;\n+    }\n+\n+    public long testArrayLoad1() {\n+        return array1[0].val.l0;\n+    }\n+\n+    public void testArrayStore1(MyValue1 val) {\n+        array1[0] = val;\n+    }\n+\n+    public long testArrayLoad2() {\n+        return array2[0].val.l0;\n+    }\n+\n+    public void testArrayStore2(MyValue1 val) {\n+        array2[0] = val;\n+    }\n+\n+    public long testArrayLoad3() {\n+        return array3[0].val.l0;\n+    }\n+\n+    public void testArrayStore3(MyValue1 val) {\n+        array3[0] = val;\n+    }\n+\n+    public long testArrayLoad4() {\n+        return array4[0].val.l0;\n+    }\n+\n+    public void testArrayStore4(MyValue1 val) {\n+        array4[0] = val;\n+    }\n+\n+    public long testArrayLoad5() {\n+        return array5[0].val.l0;\n+    }\n+\n+    public void testArrayStore5(MyValue2 val) {\n+        array5[0] = val;\n+    }\n+\n+    public long testArrayLoad6() {\n+        return array6[0].val.l0;\n+    }\n+\n+    public void testArrayStore6(MyValue2 val) {\n+        array6[0] = val;\n+    }\n+\n+    public long testArrayLoad7() {\n+        return array7[0].val.l0;\n+    }\n+\n+    public void testArrayStore7(MyValue2 val) {\n+        array7[0] = val;\n+    }\n+\n+    public long testArrayLoad8() {\n+        return array8[0].val.l0;\n+    }\n+\n+    public void testArrayStore8(MyValue2 val) {\n+        array8[0] = val;\n+    }\n+\n+    public long testFieldLoadStore1(MyValue1 val) {\n+        long res = field1.val.l0;\n+        field1 = val;\n+        return res;\n+    }\n+\n+    public long testFieldLoadStore1Independent(MyValue1 val) {\n+        long res = field2.val.l0;\n+        field1 = val;\n+        return res;\n+    }\n+\n+    public long testFieldStoreLoad1(MyValue1 val) {\n+        field1 = val;\n+        return field1.val.l0;\n+    }\n+\n+    public long testFieldStoreLoad1Independent(MyValue1 val) {\n+        field1 = val;\n+        return field2.val.l0;\n+    }\n+\n+    public long testArrayLoadStore1(MyValue1 val) {\n+        long res = array3[0].val.l0;\n+        array3[0] = val;\n+        return res;\n+    }\n+\n+    public long testArrayLoadStore1Independent(MyValue1 val) {\n+        long res = array7[0].val.l0;\n+        array3[0] = val;\n+        return res;\n+    }\n+\n+    public long testArrayStoreLoad1(MyValue1 val) {\n+        array3[0] = val;\n+        return array3[0].val.l0;\n+    }\n+\n+    public long testArrayStoreLoad1Independent(MyValue1 val) {\n+        array3[0] = val;\n+        return array7[0].val.l0;\n+    }\n+\n+    public static void main(String[] args) {\n+        TestMemBars t = new TestMemBars();\n+        for (int i = 0; i < 50_000; ++i) {\n+            VAL++;\n+            MyValue1 val1 = new MyValue1();\n+            MyValue2 val2 = new MyValue2();\n+\n+            t.testFieldStore1(val1);\n+            Asserts.assertEQ(t.testFieldLoad1(), VAL);\n+            t.testFieldStore2(val2);\n+            Asserts.assertEQ(t.testFieldLoad2(), VAL);\n+            t.testArrayStore1(val1);\n+            Asserts.assertEQ(t.testArrayLoad1(), VAL);\n+            t.testArrayStore2(val1);\n+            Asserts.assertEQ(t.testArrayLoad2(), VAL);\n+            t.testArrayStore3(val1);\n+            Asserts.assertEQ(t.testArrayLoad3(), VAL);\n+            t.testArrayStore4(val1);\n+            Asserts.assertEQ(t.testArrayLoad4(), VAL);\n+            t.testArrayStore5(val2);\n+            Asserts.assertEQ(t.testArrayLoad5(), VAL);\n+            t.testArrayStore6(val2);\n+            Asserts.assertEQ(t.testArrayLoad6(), VAL);\n+            t.testArrayStore7(val2);\n+            Asserts.assertEQ(t.testArrayLoad7(), VAL);\n+            t.testArrayStore8(val2);\n+            Asserts.assertEQ(t.testArrayLoad8(), VAL);\n+\n+            VAL++;\n+            val1 = new MyValue1();\n+            val2 = new MyValue2();\n+\n+            Asserts.assertEQ(t.testFieldLoadStore1(val1), VAL-1);\n+            Asserts.assertEQ(t.field1, val1);\n+            Asserts.assertEQ(t.testFieldLoadStore1Independent(val1), VAL-1);\n+            Asserts.assertEQ(t.field1, val1);\n+\n+            VAL++;\n+            val1 = new MyValue1();\n+            val2 = new MyValue2();\n+\n+            Asserts.assertEQ(t.testFieldStoreLoad1(val1), VAL);\n+            Asserts.assertEQ(t.field1, val1);\n+            Asserts.assertEQ(t.testFieldStoreLoad1Independent(val1), VAL-2);\n+            Asserts.assertEQ(t.field1, val1);\n+\n+            VAL++;\n+            val1 = new MyValue1();\n+            val2 = new MyValue2();\n+\n+            Asserts.assertEQ(t.testArrayLoadStore1(val1), VAL-3);\n+            Asserts.assertEQ(t.array3[0], val1);\n+            Asserts.assertEQ(t.testArrayLoadStore1Independent(val1), VAL-3);\n+            Asserts.assertEQ(t.array3[0], val1);\n+\n+            VAL++;\n+            val1 = new MyValue1();\n+            val2 = new MyValue2();\n+\n+            Asserts.assertEQ(t.testArrayStoreLoad1(val1), VAL);\n+            Asserts.assertEQ(t.array3[0], val1);\n+            Asserts.assertEQ(t.testArrayStoreLoad1Independent(val1), VAL-4);\n+            Asserts.assertEQ(t.array3[0], val1);\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMemBars.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"}]}