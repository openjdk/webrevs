{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -224,1 +225,2 @@\n-                              Constable {\n+                              Constable,\n+                              RuntimeType<T> {\n@@ -4197,1 +4199,1 @@\n-        if (obj != null && !isInstance(obj))\n+        if (!canCast(obj))\n@@ -4206,0 +4208,14 @@\n+    \/**\n+     * Tests whether a cast to this class or interface will succeed.\n+     *\/\n+    public boolean canCast(Object obj) {\n+        return obj == null || isInstance(obj);\n+    }\n+\n+    \/**\n+     * Returns this {@code Class}.\n+     *\/\n+    public Class<T> baseClass() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -118,0 +119,13 @@\n+    \/**\n+     * Returns a {@link RuntimeType} for the null-restricted type of {@code cls}.\n+     *\n+     * @param lookup unused\n+     * @param name unused\n+     * @param type the required result type (must be {@code RuntimeType.class})\n+     * @param cls the class, interface, or array type to be null-restricted\n+     * @return the null-restricted {@code RuntimeType}\n+     *\/\n+    public static RuntimeType<?> nullRestrictedClass(MethodHandles.Lookup lookup, String name, Class<?> type, Class<?> cls) {\n+        return RuntimeType.nullRestricted(cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -498,0 +498,10 @@\n+    \/**\n+     * Get the {@code RuntimeType} enforced on components of an array.\n+     *\n+     * @param array the array\n+     * @return the {@code RuntimeType} of the components of {@code array}\n+     *\/\n+    public static RuntimeType<?> componentType(Object array) {\n+        return array.getClass().getComponentType();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -272,0 +272,15 @@\n+    \/**\n+     * Get a {@code RuntimeType} representing the type that is\n+     * dynamically enforced by this field. If the field does\n+     * not perform dynamic checks, this is the type that is\n+     * enforced by bytecode verification (the same as\n+     * {@link #getType} in most cases, but {@code Object} in\n+     * the case of an interface type).\n+     *\n+     * @return a {@code RuntimeType} representing the type that\n+     *         is dynamically enforced by this field\n+     *\/\n+    public RuntimeType<?> getRuntimeType() {\n+        return !type.isInterface() ? type : Object.class;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.lang.constant.*;\n+import java.util.Optional;\n+import java.util.Objects;\n+\n+\/**\n+ * A {@code NullRestrictedClass} represents the null-restricted type of a class,\n+ * interface, or array type.\n+ *\/\n+final class NullRestrictedClass<T> implements RuntimeType<T> {\n+\n+    private final Class<T> c;\n+\n+    \/**\n+     * Assumes {@code c} is a class, interface, or array type, not a primitive.\n+     *\/\n+    NullRestrictedClass(Class<T> c) {\n+        this.c = c;\n+    }\n+\n+    \/**\n+     * Ensure an object is non-null and an instance of the class.\n+     * @throws NullPointerException if {@code arg} is {@code null}\n+     * @throws ClassCastException if {@code arg} is an instance of an incompatible class\n+     *\/\n+    public T cast(Object arg) {\n+        if (arg == null) throw new NullPointerException();\n+        return c.cast(arg);\n+    }\n+\n+    \/**\n+     * Tests whether {@code arg} is a non-null instance of the class.\n+     *\/\n+    public boolean canCast(Object arg) {\n+        return c.isInstance(arg);\n+    }\n+\n+    public Class<T> baseClass() {\n+        return c;\n+    }\n+\n+    public String toString() {\n+        \/\/ note that array types use descriptors\n+        return c.getName() + \"!\";\n+    }\n+\n+    public boolean equals(Object o) {\n+        return o instanceof NullRestrictedClass<?> that &&\n+               this.c.equals(that.c);\n+    }\n+\n+    public int hashCode() {\n+        return Objects.hash(NullRestrictedClass.class, c);\n+    }\n+\n+    public Optional<DynamicConstantDesc<NullRestrictedClass<T>>> describeConstable() {\n+        return c.describeConstable().map(classDesc ->\n+            DynamicConstantDesc.of(BSM_NULL_RESTRICTED_CLASS, classDesc));\n+    }\n+\n+    private static final DirectMethodHandleDesc BSM_NULL_RESTRICTED_CLASS =\n+        ConstantDescs.ofConstantBootstrap(\n+            ConstantDescs.CD_ConstantBootstraps,\n+            \"nullRestrictedClass\",\n+            RuntimeType.class.describeConstable().get(),\n+            ConstantDescs.CD_Class);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/NullRestrictedClass.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.lang.constant.Constable;\n+\n+\/**\n+ * A {@code RuntimeType} represents a stable property of an object reference\n+ * that can be dynamically checked at run time. These checks may be applied\n+ * to a {@link Field} or an {@link Array} component.\n+ *\n+ * A {@code RuntimeType} might be a class, interface, or array type,\n+ * represented with a {@link java.lang.Class} object. It might also be a\n+ * null-restricted class, interface, or array type, which excludes the\n+ * {@code null} reference. Other kinds of {@code RuntimeType}s may be\n+ * supported in a future release.\n+ *\n+ * @param <T> the compile-time type enforced by this {@code RuntimeType}\n+ *\/\n+public sealed interface RuntimeType<T> extends Constable\n+                                       permits Class, NullRestrictedClass {\n+\n+    \/**\n+     * Ensure an object has this type. If not, throw a {@link RuntimeException}.\n+     *\n+     * @param ref the object reference to check\n+     * @return the reference after casting\n+     *\/\n+    T cast(Object ref);\n+\n+    \/**\n+     * Tests whether a cast to this type will succeed.\n+     *\n+     * @param ref the object reference to check\n+     * @return {@code true} iff the {@link #cast} operation will succeed\n+     *\/\n+    boolean canCast(Object ref);\n+\n+    \/**\n+     * The most-specific {@code Class} that includes all values of this\n+     * {@code RuntimeType}.\n+     *\n+     * @return a {@code Class}\n+     *\/\n+    Class<?> baseClass();\n+\n+    \/**\n+     * Create a null-restricted class, interface, or array type.\n+     *\n+     * @param <T> the compile-time type of the {@code Class} object\n+     * @param c   the class to which instances of the {@code RuntimeType}\n+     *            should belong\n+     * @return    a null-restricted {@code RuntimeType}\n+     *\n+     * @throws IllegalArgumentException if {@code c} represents a primitive type\n+     *\/\n+    public static <T> RuntimeType<T> nullRestricted(Class<T> c) {\n+        if (c.isPrimitive()) throw new IllegalArgumentException();\n+        return new NullRestrictedClass<T>(c);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RuntimeType.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,485 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.RuntimeType;\n+import java.util.Arrays;\n+import java.util.function.IntFunction;\n+import java.util.stream.IntStream;\n+import java.lang.invoke.*;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+\n+\/**\n+ * Bootstrap methods for strictly-initialized array creation.\n+ *\/\n+public class ArrayCreation {\n+\n+    private ArrayCreation() {}\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MAKE_LARVAL_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n+    private static final MethodType MAKE_DEFAULT_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n+    private static final MethodType MAKE_FILLED_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class);\n+    private static final MethodType MAKE_COMPUTED_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, IntFunction.class);\n+    private static final MethodType MAKE_COPY_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class, int.class);\n+\n+    private static boolean isDefault(RuntimeType<?> componentType, Object value) {\n+        Class<?> c = componentType.baseClass();\n+        if (c.isPrimitive()) {\n+            return Wrapper.forPrimitiveType(c).zero().equals(value);\n+        } else {\n+            return value == null && componentType.canCast(null);\n+        }\n+    }\n+\n+    \/\/ makeLarval\n+\n+    private static Object makeLarval(RuntimeType<?> componentType, int flags, int length) {\n+        return Array.newInstance(componentType.baseClass(), length);\n+    }\n+\n+    \/\/ makeDefault\n+\n+    private static Object makeDefault(RuntimeType<?> componentType, int flags, int length) {\n+        if (!componentType.baseClass().isPrimitive() && !componentType.canCast(null)) {\n+            throw new AssertionError(\"unsupported component type: \" + componentType);\n+        }\n+        return Array.newInstance(componentType.baseClass(), length);\n+    }\n+\n+    \/\/ makeFilled\n+\n+    private static Object makeFilled(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n+        Arrays.fill(result, init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_byte(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        byte[] result = new byte[length];\n+        Arrays.fill(result, (byte) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_short(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        short[] result = new short[length];\n+        Arrays.fill(result, (short) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_int(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        int[] result = new int[length];\n+        Arrays.fill(result, (int) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_long(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        long[] result = new long[length];\n+        Arrays.fill(result, (long) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_float(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        float[] result = new float[length];\n+        Arrays.fill(result, (float) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_double(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        double[] result = new double[length];\n+        Arrays.fill(result, (double) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_boolean(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        boolean[] result = new boolean[length];\n+        Arrays.fill(result, (boolean) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_char(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        char[] result = new char[length];\n+        Arrays.fill(result, (char) init);\n+        return result;\n+    }\n+\n+    \/\/ makeComputed\n+\n+    private static Object makeComputed(RuntimeType<?> componentType, int flags,\n+                                         int length, IntFunction<?> func) {\n+        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n+        Arrays.setAll(result, func);\n+        return result;\n+    }\n+\n+    private static Object makeComputed_byte(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        byte[] result = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (byte) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_short(RuntimeType<?> componentType, int flags,\n+                                              int length, IntFunction<?> func) {\n+        short[] result = new short[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (short) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_int(RuntimeType<?> componentType, int flags,\n+                                          int length, IntFunction<?> func) {\n+        int[] result = new int[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (int) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_long(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        long[] result = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (long) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_float(RuntimeType<?> componentType, int flags,\n+                                              int length, IntFunction<?> func) {\n+        float[] result = new float[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (float) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_double(RuntimeType<?> componentType, int flags,\n+                                                int length, IntFunction<?> func) {\n+        double[] result = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (double) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_boolean(RuntimeType<?> componentType, int flags,\n+                                                  int length, IntFunction<?> func) {\n+        boolean[] result = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (boolean) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_char(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        char[] result = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (char) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ makeCopy\n+\n+    private static Object makeCopy(RuntimeType<?> componentType, int flags,\n+                                   int length, Object source, int start) {\n+        Object result = Array.newInstance(componentType.baseClass(), length);\n+        System.arraycopy(source, start, result, 0, length);\n+        return result;\n+    }\n+\n+    \/\/ bootstraps\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a given constant initial value.\n+     * Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @param init          Initial value\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantFilled(Lookup lookup, String methodName,\n+                                          MethodType type, RuntimeType<?> componentType,\n+                                          int flags, int length, Object init) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory;\n+        if (isDefault(componentType, init)) {\n+            factory = LOOKUP.findStatic(ArrayCreation.class, \"makeDefault\", MAKE_DEFAULT_TYPE);\n+            if (length < 0) {\n+                factory = insertArguments(factory, 0, componentType, flags);\n+            } else {\n+                factory = insertArguments(factory, 0, componentType, flags, length);\n+            }\n+        } else {\n+            String mname = \"makeFilled\";\n+            if (componentType.baseClass().isPrimitive()) {\n+                mname += \"_\" + componentType;\n+            }\n+            factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n+            if (length < 0) {\n+                factory = insertArguments(factory, 0, componentType, flags);\n+                factory = insertArguments(factory, 1, init);\n+            } else {\n+                factory = insertArguments(factory, 0, componentType, flags, length, init);\n+            }\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a dynamically-evaluated\n+     * initial value. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an appropriately-typed initial value,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicFilled(Lookup lookup, String methodName,\n+                                         MethodType type, RuntimeType<?> componentType,\n+                                         int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        String mname = \"makeFilled\";\n+        if (componentType.baseClass().isPrimitive()) {\n+            mname += \"_\" + componentType;\n+        }\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n+        if (length  < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with lazily-computed initial\n+     * values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an IntFunction producing initial values,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite computed(Lookup lookup, String methodName,\n+                                    MethodType type, RuntimeType<?> componentType,\n+                                    int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        String mname = \"makeComputed\";\n+        if (componentType.baseClass().isPrimitive()) {\n+            mname += \"_\" + componentType;\n+        }\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_COMPUTED_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from another\n+     * array. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and a source array of initial values,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite copied(Lookup lookup, String methodName,\n+                                  MethodType type, RuntimeType<?> componentType,\n+                                  int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+            factory = insertArguments(factory, 2, 0);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+            factory = insertArguments(factory, 1, 0);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from another\n+     * array, starting at an offset. Intended for use with {@code invokedynamic}\n+     * call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, a source array of initial values, and\n+     *                      a start offset into the array, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite offsetCopied(Lookup lookup, String methodName,\n+                                        MethodType type, RuntimeType<?> componentType,\n+                                        int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * constant values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: no parameters, with\n+     *                      an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param values        Initial values\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantEnumerated(Lookup lookup, String methodName,\n+                                              MethodType type, RuntimeType<?> componentType,\n+                                              int flags, Object... values) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        factory = insertArguments(factory, 0, componentType, flags, values.length, values, 0);\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * dynamically-evaluated values. Intended for use with {@code invokedynamic}\n+     * call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: a parameter for each\n+     *                      array component, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicEnumerated(Lookup lookup, String methodName,\n+                                             MethodType type, RuntimeType<?> componentType,\n+                                             int flags) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        Class<?> ccls = componentType.baseClass();\n+        Class<?> acls = ccls.arrayType();\n+        int arity = type.parameterCount();\n+        MethodHandle binaryId = dropArguments(identity(acls), 1, ccls);\n+        \/\/ binaryId type: (acls, ccls)->acls\n+        MethodHandle alloc = LOOKUP.findStatic(ArrayCreation.class, \"makeLarval\", MAKE_LARVAL_TYPE);\n+        alloc = insertArguments(alloc, 0, componentType, flags, arity);\n+        MethodHandle result = alloc.asType(MethodType.methodType(acls));\n+        \/\/ result type: ()->acls\n+        for (int i = 0; i < arity; i++) {\n+            MethodHandle setter = arrayElementSetter(acls);\n+            setter = insertArguments(setter, 1, i);\n+            setter = foldArguments(binaryId, setter);\n+            \/\/ setter type: (acls, ccls)->acls\n+            result = collectArguments(setter, 0, result);\n+            \/\/ result type: (..., ccls)->acls\n+        }\n+        return new ConstantCallSite(result.asType(type));\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ArrayCreation.java","additions":485,"deletions":0,"binary":false,"changes":485,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ArrayCreationInvoker version 67:0 {\n+\n+   public static Method constantFilled3:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled0:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilledN:\"(I)[Ljava\/lang\/String;\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledN:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computed3:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed0:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computedN:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copied3:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied0:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copiedN:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedN:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, String \"c1\", String \"c2\", String \"c3\";\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3\n+            :\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+            stack 3 {\n+        aload_0;\n+        aload_1;\n+        aload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+ }\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationInvoker.jasm","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @summary invokedynamic usage of java.lang.runtime.ArrayCreation bootstraps\n+ * @compile ArrayCreationInvoker.jasm\n+ * @run main ArrayCreationTest\n+ *\/\n+public class ArrayCreationTest {\n+\n+    public static void main(String... args) {\n+\n+        checkArray(ArrayCreationInvoker.constantFilled3(),\n+                   new String[]{ \"c\", \"c\", \"c\" });\n+        checkArray(ArrayCreationInvoker.constantFilled0(),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.constantFilledN(5),\n+                   new String[]{ \"c\", \"c\", \"c\", \"c\", \"c\" });\n+\n+        checkArray(ArrayCreationInvoker.dynamicFilled3(\"hi\"),\n+                   new String[]{ \"hi\", \"hi\", \"hi\" });\n+        checkArray(ArrayCreationInvoker.dynamicFilled0(\"hi\"),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.dynamicFilledN(2, \"hi\"),\n+                   new String[]{ \"hi\", \"hi\" });\n+        checkArray(ArrayCreationInvoker.dynamicFilledN(0, \"hi\"),\n+                   new String[]{ });\n+\n+        checkArray(ArrayCreationInvoker.computed3(i -> \"x\"+i),\n+                   new String[]{ \"x0\", \"x1\", \"x2\" });\n+        checkArray(ArrayCreationInvoker.computed0(i -> \"y\"+i),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.computedN(5, i -> \"z\"+i),\n+                   new String[]{ \"z0\", \"z1\", \"z2\", \"z3\", \"z4\" });\n+        checkArray(ArrayCreationInvoker.computedN(0, i -> \"w\"+i),\n+                   new String[]{ });\n+\n+        Object[] src = new Object[]{ \"a\", \"b\", \"c\", \"d\", \"e\" };\n+\n+        checkArray(ArrayCreationInvoker.copied3(src),\n+                   new String[]{ \"a\", \"b\", \"c\" });\n+        checkArray(ArrayCreationInvoker.copied0(src),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.copiedN(4, src),\n+                   new String[]{ \"a\", \"b\", \"c\", \"d\" });\n+        checkArray(ArrayCreationInvoker.copiedN(0, src),\n+                   new String[]{ });\n+\n+        checkArray(ArrayCreationInvoker.offsetCopied3(src, 0),\n+                   new String[]{ \"a\", \"b\", \"c\" });\n+        checkArray(ArrayCreationInvoker.offsetCopied3(src, 2),\n+                   new String[]{ \"c\", \"d\", \"e\" });\n+        checkArray(ArrayCreationInvoker.offsetCopied0(src, 0),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopied0(src, 2),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopiedN(4, src, 1),\n+                   new String[]{ \"b\", \"c\", \"d\", \"e\" });\n+        checkArray(ArrayCreationInvoker.offsetCopiedN(0, src, 4),\n+                   new String[]{ });\n+\n+        checkArray(ArrayCreationInvoker.constantEnumerated3(),\n+                   new String[]{ \"c1\", \"c2\", \"c3\" });\n+        checkArray(ArrayCreationInvoker.constantEnumerated0(),\n+                   new String[]{ });\n+\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated3(\"x\", \"y\", \"z\"),\n+                   new String[]{ \"x\", \"y\", \"z\" });\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated0(),\n+                   new String[]{ });\n+    }\n+\n+    private static void checkArray(Object[] arr, Object[] expected) {\n+        if (!Arrays.equals(arr, expected)) {\n+            throw new AssertionError(\"Unexpected result: %s, expected %s\".formatted(\n+                                     Arrays.toString(arr), Arrays.toString(expected)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}