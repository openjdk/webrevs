{"files":[{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8368799\n+ * @summary Verify heapwalking API does not report array classes several times.\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.value\n+ * @enablePreview\n+ * @run main\/othervm\/native -agentlib:HeapwalkDupClasses HeapwalkDupClasses\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+public class HeapwalkDupClasses {\n+\n+    static native int tagWithFollowReferences(long tag);\n+    static native int tagWithIterateOverReachableObjects(long tag);\n+    static native Object[] getObjectsWithTags(long tag);\n+\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"HeapwalkDupClasses\");\n+\n+        Integer instance = new Integer(0);\n+        Object[] testObjects = new Object[] {\n+            new Integer[5],\n+            ValueClass.newNullableAtomicArray(Integer.class, 5),\n+            ValueClass.newNullRestrictedNonAtomicArray(Integer.class, 5, instance)\n+        };\n+\n+        for (long tag = 1; tag <= 2; tag++) {\n+            int taggedClasses;\n+            if (tag == 1) {\n+                System.out.println(\"FollowReferences\");\n+                taggedClasses = tagWithFollowReferences(tag);\n+            } else {\n+                System.out.println(\"IterateOverReachableObjects\");\n+                taggedClasses = tagWithIterateOverReachableObjects(tag);\n+            }\n+            System.out.println(\"Tagged \" + taggedClasses + \" classes\");\n+\n+            Object[] taggedObjects = getObjectsWithTags(tag);\n+            System.out.println(\"Tagged objects (total \" + taggedObjects.length + \"):\");\n+\n+            int duplicates = 0;\n+            boolean foundTestObjectClass[] = new boolean[testObjects.length];\n+\n+            for (int i = 0; i < taggedObjects.length; i++) {\n+                System.out.println(\"[\" + i + \"] \" + taggedObjects[i]);\n+                for (int j = 0; j < i; j++) {\n+                    if (taggedObjects[i].equals(taggedObjects[j])) {\n+                        duplicates++;\n+                        System.out.println(\"  ERROR: duplicate (\" + j + \")\");\n+                    }\n+                }\n+                for (int j = 0; j < testObjects.length; j++) {\n+                    if (taggedObjects[i].equals(testObjects[j].getClass())) {\n+                        foundTestObjectClass[j] = true;\n+                        System.out.println(\"  FOUND expected array class\");\n+                    }\n+                }\n+            }\n+            if (duplicates != 0) {\n+            throw new RuntimeException(\"Found \" + duplicates + \" duplicate classes\");\n+            }\n+            for (int i = 0; i < foundTestObjectClass.length; i++) {\n+                if (!foundTestObjectClass[i]) {\n+                    throw new RuntimeException(\"Expected class not found: \" + testObjects[i].getClass());\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/HeapwalkDupClasses\/HeapwalkDupClasses.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include \"jvmti_common.hpp\"\n+\n+static jvmtiEnv *jvmti = nullptr;\n+struct CallbackData {\n+  jlong tag;\n+  jint counter;\n+\n+  CallbackData(jlong tag): tag(tag), counter(0) {}\n+};\n+\n+static jint JNICALL\n+heap_reference_callback(jvmtiHeapReferenceKind reference_kind,\n+                        const jvmtiHeapReferenceInfo* reference_info,\n+                        jlong class_tag,\n+                        jlong referrer_class_tag,\n+                        jlong size,\n+                        jlong* tag_ptr,\n+                        jlong* referrer_tag_ptr,\n+                        jint length,\n+                        void* user_data) {\n+  if (reference_kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {\n+    CallbackData* data = (CallbackData*)user_data;\n+    data->counter++;\n+    *tag_ptr = data->tag;\n+  }\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_HeapwalkDupClasses_tagWithFollowReferences(JNIEnv* jni, jclass clazz, jlong tag) {\n+  jvmtiHeapCallbacks callbacks = {};\n+  callbacks.heap_reference_callback = heap_reference_callback;\n+\n+  CallbackData data(tag);\n+\n+  jvmtiError err = jvmti->FollowReferences(0 \/* filter nothing *\/,\n+                                           nullptr \/* no class filter *\/,\n+                                           nullptr \/* no initial object, follow roots *\/,\n+                                           &callbacks,\n+                                           &data);\n+  check_jvmti_error(err, \"FollowReferences failed\");\n+\n+  return data.counter;\n+}\n+\n+static jvmtiIterationControl JNICALL\n+heap_root_callback(jvmtiHeapRootKind root_kind,\n+                   jlong class_tag,\n+                   jlong size,\n+                   jlong* tag_ptr,\n+                   void* user_data) {\n+  if (root_kind == JVMTI_HEAP_ROOT_SYSTEM_CLASS) {\n+    CallbackData* data = (CallbackData*)user_data;\n+    data->counter++;\n+    *tag_ptr = data->tag;\n+  }\n+  return JVMTI_ITERATION_CONTINUE;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_HeapwalkDupClasses_tagWithIterateOverReachableObjects(JNIEnv* jni, jclass clazz, jlong tag) {\n+  CallbackData data(tag);\n+  jvmtiError err = jvmti->IterateOverReachableObjects(heap_root_callback,\n+                                                      nullptr,\n+                                                      nullptr,\n+                                                      &data);\n+  check_jvmti_error(err, \"IterateOverReachableObjects failed\");\n+\n+  return data.counter;\n+}\n+\n+extern \"C\" JNIEXPORT jobjectArray JNICALL\n+Java_HeapwalkDupClasses_getObjectsWithTags(JNIEnv* jni, jclass clazz, jlong tag) {\n+  jlong tags[1] = {tag};\n+\n+  jint count = 0;\n+  jobject* objects = nullptr;\n+\n+  jvmtiError err = jvmti->GetObjectsWithTags(1, tags,\n+                                  &count, &objects, nullptr);\n+  check_jvmti_error(err, \"GetObjectsWithTags failed\");\n+\n+  jclass object_klass = jni->FindClass(\"java\/lang\/Object\");\n+  jobjectArray array = jni->NewObjectArray(count, object_klass, nullptr);\n+\n+  for (jint i = 0; i < count; i++) {\n+    jni->SetObjectArrayElement(array, i, objects[i]);\n+  }\n+\n+  deallocate(jvmti, jni, objects);\n+\n+  return array;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv(reinterpret_cast<void**>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    abort();\n+  }\n+  jvmtiCapabilities capabilities;\n+  memset(&capabilities, 0, sizeof(capabilities));\n+  capabilities.can_tag_objects = 1;\n+  check_jvmti_error(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+  return JVMTI_ERROR_NONE;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/HeapwalkDupClasses\/libHeapwalkDupClasses.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}