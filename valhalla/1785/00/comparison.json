{"files":[{"patch":"@@ -1477,0 +1477,1 @@\n+\n@@ -1478,1 +1479,15 @@\n-          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          const bool full_header_in_current_region = cur_addr + oopDesc::header_size() <= end;\n+\n+          if (EnableValhalla && !full_header_in_current_region) {\n+            \/\/ When using Valhalla, it might be necessary to preserve the Valhalla-\n+            \/\/ specific bits in the markWord. If the entire object header is\n+            \/\/ copied, the correct markWord (with the appropriate Valhalla bits)\n+            \/\/ can be retrieved from the Klass. However, if the full header is\n+            \/\/ not copied, we cannot access the Klass to obtain this information.\n+            \/\/ In such cases, we always preserve the markWord to ensure that all\n+            \/\/ relevant bits, including Valhalla-specific ones, are retained.\n+            cm->preserved_marks()->push_always(obj, obj->mark());\n+          } else {\n+            cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          }\n+\n@@ -2374,1 +2389,11 @@\n-    cast_to_oop(copy_destination())->reinit_mark();\n+\n+    const bool full_header_in_current_region = words >= (size_t)oopDesc::header_size();\n+    oop copy_dest_oop = cast_to_oop(copy_destination());\n+\n+    if (UseCompactObjectHeaders || (EnableValhalla && full_header_in_current_region)) {\n+      \/\/ It is only safe to read the klass iff we have copied the entire\n+      \/\/ object header.\n+      copy_dest_oop->set_mark(copy_dest_oop->klass()->prototype_header());\n+    } else {\n+      copy_dest_oop->set_mark(markWord::prototype());\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -249,2 +249,1 @@\n-    return (!is_unlocked() || !has_no_hash() ||\n-      (EnableValhalla && (is_larval_state() || is_inline_type() || is_flat_array() || is_null_free_array())));\n+    return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-  inline void reinit_mark(); \/\/ special for parallelGC\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,13 +97,0 @@\n-\/\/ This is specifically for Parallel GC. The other collectors need klass()->prototype_header()\n-\/\/ even without using Compact Object Headers. The issue is that this operation is unsafe\n-\/\/ using Parallel, as there are multiple concurrent GC workers that could access it.\n-\/\/ In practice, this has lead to relatively frequent crashes.\n-\/\/ More work needs to be done in the future to consolidate reinit_mark with init_mark.\n-void oopDesc::reinit_mark() {\n-  if (UseCompactObjectHeaders) {\n-    set_mark(klass()->prototype_header());\n-  } else {\n-    set_mark(markWord::prototype());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"}]}