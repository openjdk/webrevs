{"files":[{"patch":"@@ -1452,0 +1452,12 @@\n+static bool safe_to_read_header(size_t words) {\n+  precond(words > 0);\n+\n+  const bool safe = words >= (size_t)oopDesc::header_size();\n+\n+  \/\/ If using Compact Object Headers, the full header is inside the markWord,\n+  \/\/ so will always be safe to read\n+  assert(!UseCompactObjectHeaders || safe, \"Compact Object Headers should always be safe\");\n+\n+  return safe;\n+}\n+\n@@ -1477,0 +1489,1 @@\n+\n@@ -1478,1 +1491,15 @@\n-          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          size_t remaining_words = pointer_delta(end, cur_addr);\n+\n+          if (EnableValhalla && !safe_to_read_header(remaining_words)) {\n+            \/\/ When using Valhalla, it might be necessary to preserve the Valhalla-\n+            \/\/ specific bits in the markWord. If the entire object header is\n+            \/\/ copied, the correct markWord (with the appropriate Valhalla bits)\n+            \/\/ can be safely read from the Klass. However, if the full header is\n+            \/\/ not copied, we cannot safely read the Klass to obtain this information.\n+            \/\/ In such cases, we always preserve the markWord to ensure that all\n+            \/\/ relevant bits, including Valhalla-specific ones, are retained.\n+            cm->preserved_marks()->push_always(obj, obj->mark());\n+          } else {\n+            cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          }\n+\n@@ -2120,0 +2147,13 @@\n+static markWord safe_mark_prototype(HeapWord* addr, size_t words) {\n+  \/\/ If the original markWord contains bits that cannot be reconstructed because\n+  \/\/ the header cannot be safely read, a placeholder is used. In this case,\n+  \/\/ the correct markWord is preserved before compaction and restored after\n+  \/\/ compaction completes.\n+\n+  if (UseCompactObjectHeaders || (EnableValhalla && safe_to_read_header(words))) {\n+    return cast_to_oop(addr)->klass()->prototype_header();\n+  } else {\n+    return markWord::prototype();\n+  }\n+}\n+\n@@ -2235,1 +2275,6 @@\n-      closure.do_addr(cur_addr, obj_size);\n+\n+      size_t remaining_words = pointer_delta(end_addr, cur_addr);\n+      markWord mark = safe_mark_prototype(cur_addr, remaining_words);\n+\n+      closure.do_addr(cur_addr, obj_size, mark);\n+\n@@ -2355,1 +2400,1 @@\n-void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n+void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words, markWord mark) {\n@@ -2374,1 +2419,1 @@\n-    cast_to_oop(copy_destination())->reinit_mark();\n+    cast_to_oop(copy_destination())->set_mark(mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-  void do_addr(HeapWord* addr, size_t words);\n+  void do_addr(HeapWord* addr, size_t words, markWord mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,2 +249,1 @@\n-    return (!is_unlocked() || !has_no_hash() ||\n-      (EnableValhalla && (is_larval_state() || is_inline_type() || is_flat_array() || is_null_free_array())));\n+    return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-  inline void reinit_mark(); \/\/ special for parallelGC\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,13 +97,0 @@\n-\/\/ This is specifically for Parallel GC. The other collectors need klass()->prototype_header()\n-\/\/ even without using Compact Object Headers. The issue is that this operation is unsafe\n-\/\/ using Parallel, as there are multiple concurrent GC workers that could access it.\n-\/\/ In practice, this has lead to relatively frequent crashes.\n-\/\/ More work needs to be done in the future to consolidate reinit_mark with init_mark.\n-void oopDesc::reinit_mark() {\n-  if (UseCompactObjectHeaders) {\n-    set_mark(klass()->prototype_header());\n-  } else {\n-    set_mark(markWord::prototype());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"}]}