{"files":[{"patch":"@@ -1452,0 +1452,13 @@\n+static bool safe_to_read_header(size_t words) {\n+  assert(words > 0, \"precondition\");\n+\n+  \/\/ If using Compact Object Headers, the full header is inside the markWord,\n+  \/\/ so will always be safe to read\n+  if (UseCompactObjectHeaders) {\n+    return true;\n+  }\n+\n+  \/\/ Otherwise, it is only safe to read the full header if we've copied all of it\n+  return words >= (size_t)oopDesc::header_size();\n+}\n+\n@@ -1479,1 +1492,1 @@\n-          const bool full_header_in_current_region = cur_addr + oopDesc::header_size() <= end;\n+          size_t remaining_words = pointer_delta(end, cur_addr);\n@@ -1481,1 +1494,1 @@\n-          if (EnableValhalla && !full_header_in_current_region) {\n+          if (EnableValhalla && !safe_to_read_header(remaining_words)) {\n@@ -1485,2 +1498,2 @@\n-            \/\/ can be retrieved from the Klass. However, if the full header is\n-            \/\/ not copied, we cannot access the Klass to obtain this information.\n+            \/\/ can be safely read from the Klass. However, if the full header is\n+            \/\/ not copied, we cannot safely read the Klass to obtain this information.\n@@ -1490,0 +1503,1 @@\n+            log_info(gc)(\"Preserving markWord for %p\", cur_addr);\n@@ -2135,0 +2149,13 @@\n+static markWord safe_mark_prototype(HeapWord* addr, size_t words) {\n+  \/\/ If the original markWord contains bits that cannot be reconstructed because\n+  \/\/ the header cannot be safely read, a placeholder is used. In this case,\n+  \/\/ the correct markWord is preserved before compaction and restored after\n+  \/\/ compaction completes.\n+\n+  if (UseCompactObjectHeaders || (EnableValhalla && safe_to_read_header(words))) {\n+    return cast_to_oop(addr)->klass()->prototype_header();\n+  } else {\n+    return markWord::prototype();\n+  }\n+}\n+\n@@ -2250,1 +2277,6 @@\n-      closure.do_addr(cur_addr, obj_size);\n+\n+      size_t remaining_words = pointer_delta(end_addr, cur_addr);\n+      markWord mark = safe_mark_prototype(cur_addr, remaining_words);\n+\n+      closure.do_addr(cur_addr, obj_size, mark);\n+\n@@ -2370,1 +2402,1 @@\n-void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n+void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words, markWord mark) {\n@@ -2389,11 +2421,1 @@\n-\n-    const bool full_header_in_current_region = words >= (size_t)oopDesc::header_size();\n-    oop copy_dest_oop = cast_to_oop(copy_destination());\n-\n-    if (UseCompactObjectHeaders || (EnableValhalla && full_header_in_current_region)) {\n-      \/\/ It is only safe to read the klass iff we have copied the entire\n-      \/\/ object header.\n-      copy_dest_oop->set_mark(copy_dest_oop->klass()->prototype_header());\n-    } else {\n-      copy_dest_oop->set_mark(markWord::prototype());\n-    }\n+    cast_to_oop(copy_destination())->set_mark(mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-  void do_addr(HeapWord* addr, size_t words);\n+  void do_addr(HeapWord* addr, size_t words, markWord mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}