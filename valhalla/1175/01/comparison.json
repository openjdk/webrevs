{"files":[{"patch":"@@ -2318,1 +2318,6 @@\n-      \/\/ Half-precision floating point add scalar operation requires FEAT_FP16\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MinHF:\n+    case Op_MaxHF:\n+      \/\/ Half-precision floating point scalar operations require FEAT_FP16\n@@ -14146,0 +14151,15 @@\n+instruct subHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (SubHF src1 src2));\n+\n+  ins_cost(INSN_COST * 5);\n+  format %{ \"fsubh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fsubh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -14176,0 +14196,15 @@\n+instruct mulHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MulHF src1 src2));\n+\n+  ins_cost(INSN_COST * 6);\n+  format %{ \"fmulh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fmulh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -14347,0 +14382,23 @@\n+\/\/ Math.max(HF)\n+instruct maxHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"fmaxh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmaxh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Math.min(HF)\n+instruct minHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"fminh   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fminh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n@@ -14404,0 +14462,14 @@\n+instruct divHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (DivHF src1  src2));\n+\n+  ins_cost(INSN_COST * 18);\n+  format %{ \"fdivh   $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fdivh(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_div_s);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -231,0 +231,5 @@\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n@@ -835,0 +840,16 @@\n+instruct vsubHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vsubHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -909,0 +930,10 @@\n+instruct vsubHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1032,0 +1063,16 @@\n+instruct vmulHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"vmulHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1106,0 +1153,10 @@\n+instruct vmulHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1130,0 +1187,22 @@\n+instruct vdivHF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"vdivHF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivHF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVHF dst_src1 src2));\n+  format %{ \"vdivHF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1176,0 +1255,10 @@\n+instruct vdivHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2002,0 +2091,25 @@\n+instruct vhfmin_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"vhfmin_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmin($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmin_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinVHF dst_src1 src2));\n+  format %{ \"vhfmin_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2022,0 +2136,12 @@\n+instruct vhfmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MinVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmin_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2089,0 +2215,25 @@\n+instruct vhfmax_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vhfmax_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ fmax($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vhfmax_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxVHF dst_src1 src2));\n+  format %{ \"vhfmax_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2109,0 +2260,12 @@\n+instruct vhfmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MaxVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vhfmax_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":163,"deletions":0,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -221,0 +221,5 @@\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n@@ -536,6 +541,7 @@\n-BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n-BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n-BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n-BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n-BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n-BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+BINARY_OP(vsubB,  SubVB,  subv, sve_sub,  B)\n+BINARY_OP(vsubS,  SubVS,  subv, sve_sub,  H)\n+BINARY_OP(vsubI,  SubVI,  subv, sve_sub,  S)\n+BINARY_OP(vsubL,  SubVL,  subv, sve_sub,  D)\n+BINARY_OP(vsubHF, SubVHF, fsub, sve_fsub, H)\n+BINARY_OP(vsubF,  SubVF,  fsub, sve_fsub, S)\n+BINARY_OP(vsubD,  SubVD,  fsub, sve_fsub, D)\n@@ -544,6 +550,7 @@\n-BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n-BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n-BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n-BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n-BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n-BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+BINARY_OP_PREDICATE(vsubB,  SubVB,  sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS,  SubVS,  sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI,  SubVI,  sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL,  SubVL,  sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubHF, SubVHF, sve_fsub, H)\n+BINARY_OP_PREDICATE(vsubF,  SubVF,  sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD,  SubVD,  sve_fsub, D)\n@@ -616,2 +623,3 @@\n-BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n-BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+BINARY_OP(vmulHF, MulVHF, fmul, sve_fmul, H)\n+BINARY_OP(vmulF,  MulVF,  fmul, sve_fmul, S)\n+BINARY_OP(vmulD,  MulVD,  fmul, sve_fmul, D)\n@@ -620,6 +628,7 @@\n-BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n-BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n-BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n-BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n-BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n-BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+BINARY_OP_PREDICATE(vmulB,  MulVB,  sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS,  MulVS,  sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI,  MulVI,  sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL,  MulVL,  sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulHF, MulVHF, sve_fmul, H)\n+BINARY_OP_PREDICATE(vmulF,  MulVF,  sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD,  MulVD,  sve_fmul, D)\n@@ -630,2 +639,3 @@\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivHF, DivVHF, fdiv, sve_fdiv, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF,  DivVF,  fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD,  DivVD,  fdiv, sve_fdiv, D)\n@@ -634,2 +644,3 @@\n-BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n-BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)\n+BINARY_OP_PREDICATE(vdivF,  DivVF,  sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD,  DivVD,  sve_fdiv, D)\n@@ -1019,0 +1030,15 @@\n+dnl VHFMINMAX_NEON($1,   $2,      $3     )\n+dnl VHFMINMAX_NEON(type, op_name, insn_fp)\n+define(`VHFMINMAX_NEON', `\n+instruct vhf$1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"vhf$1_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1042,0 +1068,16 @@\n+dnl VHFMINMAX_SVE($1,   $2,      $3     )\n+dnl VHFMINMAX_SVE(type, op_name, insn_fp)\n+define(`VHFMINMAX_SVE', `\n+instruct vhf$1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"vhf$1_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1063,0 +1105,15 @@\n+dnl VHFMINMAX_PREDICATE($1,   $2,      $3     )\n+dnl VHFMINMAX_PREDICATE(type, op_name, insn_fp)\n+define(`VHFMINMAX_PREDICATE', `\n+instruct vhf$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"vhf$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1072,0 +1129,2 @@\n+VHFMINMAX_NEON(min, MinVHF, fmin)\n+VHFMINMAX_SVE(min, MinVHF, sve_fmin)\n@@ -1075,0 +1134,1 @@\n+VHFMINMAX_PREDICATE(min, MinVHF, sve_fmin)\n@@ -1085,0 +1145,2 @@\n+VHFMINMAX_NEON(max, MaxVHF, fmax)\n+VHFMINMAX_SVE(max, MaxVHF, sve_fmax)\n@@ -1088,0 +1150,1 @@\n+VHFMINMAX_PREDICATE(max, MaxVHF, sve_fmax)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":87,"deletions":24,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -3379,1 +3379,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3857,1 +3857,1 @@\n-    \"AddI\",\"AddL\",\"AddF\",\"AddD\",\n+    \"AddI\",\"AddL\",\"AddHF\",\"AddF\",\"AddD\",\n@@ -3859,2 +3859,2 @@\n-    \"MaxI\",\"MinI\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n-    \"MulI\",\"MulL\",\"MulF\",\"MulD\",\n+    \"MaxI\",\"MinI\",\"MaxHF\",\"MinHF\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n+    \"MulI\",\"MulL\",\"MulHF\",\"MulF\",\"MulD\",\n@@ -3866,2 +3866,2 @@\n-    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVF\", \"AddVD\",\n-    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVF\", \"MulVD\",\n+    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVHF\", \"AddVF\", \"AddVD\",\n+    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVHF\", \"MulVF\", \"MulVD\",\n@@ -3869,1 +3869,1 @@\n-    \"MaxV\", \"MinV\"\n+    \"MaxVHF\", \"MinVHF\", \"MaxV\", \"MinV\"\n@@ -4096,0 +4096,1 @@\n+        strcmp(opType,\"DivHF\")==0 ||\n@@ -4236,3 +4237,3 @@\n-    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\",\"SubVF\",\"SubVD\",\n-    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVF\",\"MulVD\",\n-    \"DivVF\",\"DivVD\",\n+    \"SubVB\",\"SubVS\",\"SubVI\",\"SubVL\", \"SubVHF\", \"SubVF\",\"SubVD\",\n+    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\", \"MulVHF\", \"MulVF\",\"MulVD\",\n+    \"DivVHF\",\"DivVF\",\"DivVD\",\n@@ -4243,1 +4244,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"MinVHF\", \"MaxVHF\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -200,4 +200,14 @@\n-  do_intrinsic(_sum_float16,              java_lang_Float16,      sum_name,           floa16_float16_signature,  F_S)   \\\n-   do_name(sum_name, \"sum\")                                                                                             \\\n-   do_signature(floa16_float16_signature, \"(Ljava\/lang\/Float16;Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\")                \\\n-                                                                                                                        \\\n+  \/* All names for Float16 binary operations *\/                                                                         \\\n+  do_name(add_name, \"add\")                                                                                              \\\n+  do_name(subtract_name, \"subtract\")                                                                                    \\\n+  do_name(multiply_name, \"multiply\")                                                                                    \\\n+  do_name(divide_name, \"divide\")                                                                                        \\\n+  \/* Float16 signature for binary operations *\/                                                                         \\\n+  do_signature(floa16_float16_signature, \"(Ljava\/lang\/Float16;Ljava\/lang\/Float16;)Ljava\/lang\/Float16;\")                 \\\n+  \/* Float16 intrinsics for binary operations *\/                                                                        \\\n+  do_intrinsic(_add_float16,              java_lang_Float16,      add_name,           floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_subtract_float16,         java_lang_Float16,      subtract_name,      floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_multiply_float16,         java_lang_Float16,      multiply_name,      floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_divide_float16,           java_lang_Float16,      divide_name,        floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_max_float16,              java_lang_Float16,      max_name,           floa16_float16_signature,  F_S)   \\\n+  do_intrinsic(_min_float16,              java_lang_Float16,      min_name,           floa16_float16_signature,  F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -406,0 +406,20 @@\n+\/\/------------------------------MaxHFNode--------------------------------------\n+\/\/ Maximum of 2 half floats.\n+class MaxHFNode : public MaxFNode {\n+public:\n+  MaxHFNode(Node* in1, Node* in2) : MaxFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n+\/\/------------------------------MinHFNode---------------------------------------\n+\/\/ Minimum of 2 half floats.\n+class MinHFNode : public MinFNode {\n+public:\n+  MinHFNode(Node* in1, Node* in2) : MinFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-  case vmIntrinsics::_sum_float16:\n+  case vmIntrinsics::_add_float16:\n@@ -608,0 +608,15 @@\n+  case vmIntrinsics::_subtract_float16:\n+    if (!Matcher::match_rule_supported(Op_SubHF)) return false;\n+    break;\n+  case vmIntrinsics::_multiply_float16:\n+    if (!Matcher::match_rule_supported(Op_MulHF)) return false;\n+    break;\n+  case vmIntrinsics::_divide_float16:\n+    if (!Matcher::match_rule_supported(Op_DivHF)) return false;\n+    break;\n+    case vmIntrinsics::_max_float16:\n+    if (!Matcher::match_rule_supported(Op_MaxHF)) return false;\n+    break;\n+  case vmIntrinsics::_min_float16:\n+    if (!Matcher::match_rule_supported(Op_MinHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+macro(DivHF)\n@@ -226,0 +227,1 @@\n+macro(MaxHF)\n@@ -241,0 +243,1 @@\n+macro(MinHF)\n@@ -257,0 +260,1 @@\n+macro(MulHF)\n@@ -360,0 +364,1 @@\n+macro(SubHF)\n@@ -378,1 +383,0 @@\n-macro(AddVHF)\n@@ -384,0 +388,1 @@\n+macro(AddVHF)\n@@ -392,0 +397,1 @@\n+macro(SubVHF)\n@@ -400,0 +406,1 @@\n+macro(MulVHF)\n@@ -407,0 +414,1 @@\n+macro(DivVHF)\n@@ -441,0 +449,2 @@\n+macro(MinVHF)\n+macro(MaxVHF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3681,0 +3681,6 @@\n+  case Op_AddHF:\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MaxHF:\n+  case Op_MinHF:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,8 @@\n+\/\/------------------------------DivHFNode--------------------------------------\n+\/\/ Half float division\n+class DivHFNode : public DivFNode {\n+public:\n+  DivHFNode(Node* c, Node* dividend, Node* divisor) : DivFNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -548,1 +548,6 @@\n-  case vmIntrinsics::_sum_float16:              return inline_fp16_operations(intrinsic_id());\n+  case vmIntrinsics::_add_float16:\n+  case vmIntrinsics::_subtract_float16:\n+  case vmIntrinsics::_multiply_float16:\n+  case vmIntrinsics::_divide_float16:\n+  case vmIntrinsics::_max_float16:\n+  case vmIntrinsics::_min_float16:              return inline_fp16_operations(intrinsic_id());\n@@ -5076,1 +5081,6 @@\n-  case vmIntrinsics::_sum_float16:   result = _gvn.transform(new AddHFNode(fld1, fld2)); break;\n+  case vmIntrinsics::_add_float16:       result = _gvn.transform(new AddHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_subtract_float16:  result = _gvn.transform(new SubHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_multiply_float16:  result = _gvn.transform(new MulHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_divide_float16:    result = _gvn.transform(new DivHFNode(0, fld1, fld2)); break;\n+  case vmIntrinsics::_max_float16:       result = _gvn.transform(new MaxHFNode(fld1, fld2));    break;\n+  case vmIntrinsics::_min_float16:       result = _gvn.transform(new MinHFNode(fld1, fld2));    break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -6299,0 +6299,1 @@\n+    case Op_DivHF:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-                  (op == Op_MulF) || (op == Op_MulD);\n+                  (op == Op_MulF) || (op == Op_MulD) ||\n+                  (op == Op_MulHF);\n@@ -124,2 +125,3 @@\n-      op != Op_MulF &&          \/\/ Float & double cannot reassociate\n-      op != Op_MulD ) {\n+      op != Op_MulF &&          \/\/ Float, half-precision float and double cannot reassociate\n+      op != Op_MulD &&\n+      op != Op_MulHF) {\n@@ -551,0 +553,8 @@\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Ideal------------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeF* t2 = phase->type(in(2))->isa_float_constant();\n@@ -552,0 +562,5 @@\n+  \/\/ x * 2 -> x + x\n+  if (t2 != nullptr && t2->getf() == 2) {\n+    Node* base = in(1);\n+    return new AddHFNode(base, base);\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,13 @@\n+\/\/------------------------------MulHFNode---------------------------------------\n+\/\/ Multiply 2 half floats\n+class MulHFNode : public MulFNode {\n+public:\n+  MulHFNode(Node* in1, Node* in2) : MulFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  int add_opcode() const { return Op_AddHF; }\n+  int mul_opcode() const { return Op_MulHF; }\n+  int max_opcode() const { return Op_MaxHF; }\n+  int min_opcode() const { return Op_MinHF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-\/\/ Subtract 2 doubles\n+\/\/ Subtract 2 floats\n@@ -119,0 +119,8 @@\n+\/\/------------------------------SubHFNode--------------------------------------\n+\/\/ Subtract 2 half floats\n+class SubHFNode : public SubFNode {\n+public:\n+  SubHFNode(Node* in1, Node* in2) : SubFNode(in1, in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  case Op_SubHF: return (bt == T_SHORT ? Op_SubVHF : 0);\n@@ -77,0 +78,2 @@\n+  case Op_MulHF:\n+    return (bt == T_SHORT ? Op_MulVHF : 0);\n@@ -91,0 +94,2 @@\n+  case Op_DivHF:\n+    return (bt == T_SHORT ? Op_DivVHF : 0);\n@@ -117,0 +122,2 @@\n+  case Op_MinHF:\n+    return (bt == T_SHORT ? Op_MinVHF : 0);\n@@ -132,0 +139,2 @@\n+  case Op_MaxHF:\n+    return (bt == T_SHORT ? Op_MaxVHF : 0);\n@@ -386,0 +395,4 @@\n+    case Op_MinVHF:\n+      return Op_MinHF;\n+    case Op_MaxVHF:\n+      return Op_MaxHF;\n@@ -593,0 +606,5 @@\n+  case Op_SubHF:\n+  case Op_MulHF:\n+  case Op_DivHF:\n+  case Op_MinHF:\n+  case Op_MaxHF:\n@@ -655,3 +673,3 @@\n-  case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:\n-  case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:\n-  case Op_DivF: case Op_DivD:\n+  case Op_SubI: case Op_SubL: case Op_SubHF: case Op_SubF: case Op_SubD:\n+  case Op_MulI: case Op_MulL: case Op_MulHF: case Op_MulF: case Op_MulD:\n+  case Op_DivHF: case Op_DivF: case Op_DivD:\n@@ -711,1 +729,1 @@\n-  case Op_AddVB: return new AddVBNode(n1, n2, vt);\n+  case Op_AddVB:  return new AddVBNode(n1, n2, vt);\n@@ -713,22 +731,25 @@\n-  case Op_AddVS: return new AddVSNode(n1, n2, vt);\n-  case Op_AddVI: return new AddVINode(n1, n2, vt);\n-  case Op_AddVL: return new AddVLNode(n1, n2, vt);\n-  case Op_AddVF: return new AddVFNode(n1, n2, vt);\n-  case Op_AddVD: return new AddVDNode(n1, n2, vt);\n-\n-  case Op_SubVB: return new SubVBNode(n1, n2, vt);\n-  case Op_SubVS: return new SubVSNode(n1, n2, vt);\n-  case Op_SubVI: return new SubVINode(n1, n2, vt);\n-  case Op_SubVL: return new SubVLNode(n1, n2, vt);\n-  case Op_SubVF: return new SubVFNode(n1, n2, vt);\n-  case Op_SubVD: return new SubVDNode(n1, n2, vt);\n-\n-  case Op_MulVB: return new MulVBNode(n1, n2, vt);\n-  case Op_MulVS: return new MulVSNode(n1, n2, vt);\n-  case Op_MulVI: return new MulVINode(n1, n2, vt);\n-  case Op_MulVL: return new MulVLNode(n1, n2, vt);\n-  case Op_MulVF: return new MulVFNode(n1, n2, vt);\n-  case Op_MulVD: return new MulVDNode(n1, n2, vt);\n-\n-  case Op_DivVF: return new DivVFNode(n1, n2, vt);\n-  case Op_DivVD: return new DivVDNode(n1, n2, vt);\n+  case Op_AddVS:  return new AddVSNode(n1, n2, vt);\n+  case Op_AddVI:  return new AddVINode(n1, n2, vt);\n+  case Op_AddVL:  return new AddVLNode(n1, n2, vt);\n+  case Op_AddVF:  return new AddVFNode(n1, n2, vt);\n+  case Op_AddVD:  return new AddVDNode(n1, n2, vt);\n+\n+  case Op_SubVB:  return new SubVBNode(n1, n2, vt);\n+  case Op_SubVS:  return new SubVSNode(n1, n2, vt);\n+  case Op_SubVI:  return new SubVINode(n1, n2, vt);\n+  case Op_SubVL:  return new SubVLNode(n1, n2, vt);\n+  case Op_SubVHF: return new SubVHFNode(n1, n2, vt);\n+  case Op_SubVF:  return new SubVFNode(n1, n2, vt);\n+  case Op_SubVD:  return new SubVDNode(n1, n2, vt);\n+\n+  case Op_MulVB:  return new MulVBNode(n1, n2, vt);\n+  case Op_MulVS:  return new MulVSNode(n1, n2, vt);\n+  case Op_MulVI:  return new MulVINode(n1, n2, vt);\n+  case Op_MulVL:  return new MulVLNode(n1, n2, vt);\n+  case Op_MulVHF: return new MulVHFNode(n1, n2, vt);\n+  case Op_MulVF:  return new MulVFNode(n1, n2, vt);\n+  case Op_MulVD:  return new MulVDNode(n1, n2, vt);\n+\n+  case Op_DivVHF: return new DivVHFNode(n1, n2, vt);\n+  case Op_DivVF:  return new DivVFNode(n1, n2, vt);\n+  case Op_DivVD:  return new DivVDNode(n1, n2, vt);\n@@ -739,0 +760,3 @@\n+  case Op_MinVHF: return new MinVHFNode(n1, n2, vt);\n+  case Op_MaxVHF: return new MaxVHFNode(n1, n2, vt);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":50,"deletions":26,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -315,0 +315,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector subtract half float\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -318,1 +326,1 @@\n- public:\n+public:\n@@ -326,1 +334,1 @@\n- public:\n+public:\n@@ -363,0 +371,8 @@\n+\/\/------------------------------MulVFNode--------------------------------------\n+\/\/ Vector multiply half float\n+class MulVHFNode : public VectorNode {\n+public:\n+  MulVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -445,0 +461,8 @@\n+\/\/------------------------------DivVHFNode-------------------------------------\n+\/\/ Vector divide half float\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -448,1 +472,1 @@\n- public:\n+public:\n@@ -456,1 +480,1 @@\n- public:\n+public:\n@@ -488,1 +512,1 @@\n- public:\n+public:\n@@ -493,0 +517,16 @@\n+\/\/------------------------------MinVHFNode------------------------------------\n+\/\/ Vector Min for half floats\n+class MinVHFNode : public VectorNode {\n+public:\n+  MinVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------MaxVHFNode------------------------------------\n+\/\/ Vector Max for half floats\n+class MaxVHFNode : public VectorNode {\n+public:\n+  MaxVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1433,0 +1433,2 @@\n+  declare_c2_type(MaxHFNode, MaxFNode)                                    \\\n+  declare_c2_type(MinHFNode, MinFNode)                                    \\\n@@ -1536,0 +1538,1 @@\n+  declare_c2_type(DivHFNode, DivFNode)                                    \\\n@@ -1632,0 +1635,1 @@\n+  declare_c2_type(MulHFNode, MulFNode)                                    \\\n@@ -1653,0 +1657,1 @@\n+  declare_c2_type(SubHFNode, SubFNode)                                    \\\n@@ -1706,0 +1711,1 @@\n+  declare_c2_type(SubVHFNode, VectorNode)                                 \\\n@@ -1714,0 +1720,1 @@\n+  declare_c2_type(MulVHFNode, VectorNode)                                 \\\n@@ -1730,0 +1737,1 @@\n+  declare_c2_type(DivVHFNode, VectorNode)                                 \\\n@@ -1756,0 +1764,2 @@\n+  declare_c2_type(MaxVHFNode, VectorNode)                                 \\\n+  declare_c2_type(MinVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -544,16 +544,0 @@\n-    \/**\n-     * Adds two {@code Float16} values together as per the {@code +}\n-     * operator semantics.\n-     *\n-     * @implSpec\n-     * This method is operationally equivalent to {@link #add(Float16, Float16)}.\n-     *\n-     * @param a the first operand\n-     * @param b the second operand\n-     * @return the sum of {@code a} and {@code b}\n-     *\/\n-    @IntrinsicCandidate\n-    public static Float16 sum(Float16 a, Float16 b) {\n-        return add(a, b);\n-    }\n-\n@@ -661,0 +645,1 @@\n+    @IntrinsicCandidate\n@@ -680,0 +665,1 @@\n+    @IntrinsicCandidate\n@@ -735,1 +721,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -758,1 +744,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -781,1 +767,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -804,1 +790,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import static java.lang.Float16.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8336406\n+ * @summary Test that Ideal transformations of MulHFNode are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.MulHFNodeIdealizationTests\n+ *\/\n+public class MulHFNodeIdealizationTests {\n+\n+    private Float16 src;\n+    private Float16 dst;\n+    private Random rng;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--enable-preview\");\n+    }\n+\n+    public MulHFNodeIdealizationTests() {\n+        rng = new Random(25);\n+        src = Float16.valueOf(rng.nextFloat());\n+        dst = Float16.valueOf(rng.nextFloat());\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"},\n+        failOn = {IRNode.MUL_HF})\n+    public void test1() {\n+        dst = Float16.multiply(src, Float16.valueOf(2));\n+    }\n+\n+    @Check(test=\"test1\")\n+    public void checkTest1() {\n+        Float16 expected = Float16.valueOf(src.floatValue() * (float) 2);\n+        if (float16ToRawShortBits(expected) != float16ToRawShortBits(dst)) {\n+            throw new RuntimeException(\"Invalid result: dst = \" + float16ToRawShortBits(dst) + \" != \" + float16ToRawShortBits(expected));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @bug 8308363\n-* @summary Validate compiler IR for FP16 scalar operations.\n-* @requires vm.compiler2.enabled\n-* @library \/test\/lib \/\n-* @run driver TestFP16ScalarAdd\n-*\/\n-\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import static java.lang.Float16.*;\n-\n-public class TestFP16ScalarAdd {\n-    private static final int count = 1024;\n-\n-    private short[] src;\n-    private short[] dst;\n-    private short res;\n-\n-    public static void main(String args[]) {\n-        TestFramework.runWithFlags(\"--enable-preview\");\n-    }\n-\n-    public TestFP16ScalarAdd() {\n-        src = new short[count];\n-        dst = new short[count];\n-        for (int i = 0; i < count; i++) {\n-            src[i] = Float.floatToFloat16(i);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = {\"avx512_fp16\", \"true\"}, counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"})\n-    @IR(applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"}, counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"})\n-    public void test1() {\n-        Float16 res = shortBitsToFloat16((short)0);\n-        for (int i = 0; i < count; i++) {\n-            res = Float16.sum(res, shortBitsToFloat16(src[i]));\n-            dst[i] = float16ToRawShortBits(res);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeature = {\"avx512_fp16\", \"true\"}, failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S})\n-    @IR(applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"}, failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S})\n-    public void test2() {\n-        Float16 hf0 = shortBitsToFloat16((short)0);\n-        Float16 hf1 = shortBitsToFloat16((short)15360);\n-        Float16 hf2 = shortBitsToFloat16((short)16384);\n-        Float16 hf3 = shortBitsToFloat16((short)16896);\n-        Float16 hf4 = shortBitsToFloat16((short)17408);\n-        res = float16ToRawShortBits(Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4));\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarAdd.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Validate compiler IR for FP16 scalar operations.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver TestFP16ScalarOps\n+*\/\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFP16ScalarOps {\n+    private static final int count = 1024;\n+\n+    private short[] src;\n+    private short[] dst;\n+    private short res;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\");\n+    }\n+\n+    public TestFP16ScalarOps() {\n+        src = new short[count];\n+        dst = new short[count];\n+        for (int i = 0; i < count; i++) {\n+            src[i] = Float.floatToFloat16(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd1() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.add(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testAdd2() {\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        res = float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testSub() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.subtract(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMul() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.multiply(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testDiv() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.divide(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMax() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.max(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testMin() {\n+        Float16 res = shortBitsToFloat16((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.min(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarOps.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -890,0 +890,5 @@\n+    public static final String MAX_VHF = PREFIX + \"MAX_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_VHF, \"MaxVHF\");\n+    }\n+\n@@ -935,0 +940,10 @@\n+    public static final String MIN_HF = PREFIX + \"MIN_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_HF, \"MinHF\");\n+    }\n+\n+    public static final String MAX_HF = PREFIX + \"MAX_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_HF, \"MaxHF\");\n+    }\n+\n@@ -950,0 +965,5 @@\n+    public static final String MIN_VHF = PREFIX + \"MIN_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_VHF, \"MinVHF\");\n+    }\n+\n@@ -981,0 +1001,5 @@\n+    public static final String MUL_HF = PREFIX + \"MUL_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HF, \"MulHF\");\n+    }\n+\n@@ -1006,0 +1031,5 @@\n+    public static final String MUL_VHF = PREFIX + \"MUL_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VHF, \"MulVHF\");\n+    }\n+\n@@ -1477,0 +1507,5 @@\n+    public static final String SUB_HF = PREFIX + \"SUB_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_HF, \"SubHF\");\n+    }\n+\n@@ -1512,0 +1547,5 @@\n+    public static final String SUB_VHF = PREFIX + \"SUB_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_VHF, \"SubVHF\");\n+    }\n+\n@@ -1527,0 +1567,10 @@\n+    public static final String DIV_HF = PREFIX + \"DIV_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_HF, \"DivHF\");\n+    }\n+\n+    public static final String DIV_VHF = PREFIX + \"DIV_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_VHF, \"DivVHF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8308363 8336406\n+* @summary Test vectorization of Float16 binary operations\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @compile TestFloat16VectorOps.java\n+* @run driver compiler.vectorization.TestFloat16VectorOps\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import static java.lang.Float16.*;\n+\n+public class TestFloat16VectorOps {\n+    private Float16[] input;\n+    private Float16[] output;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-TieredCompilation\", \"-Xbatch\");\n+    }\n+\n+    public TestFloat16VectorOps() {\n+        input  = new Float16[LEN];\n+        output = new Float16[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorAddFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.add(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddFloat16\")\n+    public void checkResultAdd() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.add(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorSubFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.subtract(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubFloat16\")\n+    public void checkResultSub() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.subtract(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMulFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.multiply(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulFloat16\")\n+    public void checkResultMul() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.multiply(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorDivFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.divide(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivFloat16\")\n+    public void checkResultDiv() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.divide(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMinFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.min(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinFloat16\")\n+    public void checkResultMin() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.min(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorMaxFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.max(input[i], input[i]);\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxFloat16\")\n+    public void checkResultMax() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.max(input[i], input[i]);\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + float16ToRawShortBits(output[i]) + \" != \" + float16ToRawShortBits(expected));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOps.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+* @bug 8330021\n@@ -70,1 +71,1 @@\n-            flout[i] = Float16.sum(fin[i], fin[i]).floatValue();\n+            flout[i] = Float16.add(fin[i], fin[i]).floatValue();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorReinterpretConv.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @summary Test vectorization of Float16.sum operation.\n-* @requires vm.compiler2.enabled\n-* @library \/test\/lib \/\n-* @compile  TestFloat16VectorSum.java\n-* @run driver compiler.vectorization.TestFloat16VectorSum\n-*\/\n-\n-package compiler.vectorization;\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import static java.lang.Float16.*;\n-\n-public class TestFloat16VectorSum {\n-    private Float16[] input;\n-    private Float16[] output;\n-    private static final int LEN = 2048;\n-    private Random rng;\n-\n-    public static void main(String args[]) {\n-        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-TieredCompilation\", \"-Xbatch\");\n-    }\n-\n-    public TestFloat16VectorSum() {\n-        input  = new Float16[LEN];\n-        output = new Float16[LEN];\n-        rng = new Random(42);\n-        for (int i = 0; i < LEN; ++i) {\n-            input[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n-        }\n-    }\n-\n-    @Test\n-    @Warmup(10000)\n-    @IR(counts = {IRNode.ADD_VHF, \" >= 1\"},\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.ADD_VHF, \" >= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n-    public void vectorSumFloat16() {\n-        for (int i = 0; i < LEN; ++i) {\n-            output[i] = Float16.sum(input[i], input[i]);\n-        }\n-    }\n-\n-    @Check(test=\"vectorSumFloat16\")\n-    public void checkResult() {\n-        for (int i = 0; i < LEN; ++i) {\n-            Float16 expected = Float16.sum(input[i], input[i]);\n-            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" +\n-                                           float16ToRawShortBits(output[i]) + \" != \" +\n-                                           float16ToRawShortBits(expected));\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorSum.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-        return float16ToRawShortBits(Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4));\n+        return float16ToRawShortBits(Float16.add(Float16.add(Float16.add(Float16.add(hf0, hf1), hf2), hf3), hf4));\n@@ -84,1 +84,1 @@\n-            res = Float16.sum(res, shortBitsToFloat16(arr[i]));\n+            res = Float16.add(res, shortBitsToFloat16(arr[i]));\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ReductionOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n@@ -26,2 +27,2 @@\n- * @bug 8308363\n- * @summary Initial compiler support for Float16.add operation.\n+ * @bug 8308363 8336406\n+ * @summary Verify binary FP16 scalar operations\n@@ -40,1 +41,1 @@\n-    public static short actual_value(char oper, short val1, short val2) {\n+    public static short actual_value(String oper, short val1, short val2) {\n@@ -43,3 +44,8 @@\n-        switch ((int)oper) {\n-            case '+' : return float16ToRawShortBits(Float16.sum(obj1, obj2));\n-            default  : throw new AssertionError(\"Unsupported Operation!\");\n+        switch (oper) {\n+            case \"+\"   : return float16ToRawShortBits(Float16.add(obj1, obj2));\n+            case \"-\"   : return float16ToRawShortBits(Float16.subtract(obj1, obj2));\n+            case \"*\"   : return float16ToRawShortBits(Float16.multiply(obj1, obj2));\n+            case \"\/\"   : return float16ToRawShortBits(Float16.divide(obj1, obj2));\n+            case \"min\" : return float16ToRawShortBits(Float16.min(obj1, obj2));\n+            case \"max\" : return float16ToRawShortBits(Float16.max(obj1, obj2));\n+            default    : throw new AssertionError(\"Unsupported Operation!\");\n@@ -49,1 +55,1 @@\n-    public static void test_add(short [] arr1, short arr2[]) {\n+    public static void test_operations(short [] arr1, short arr2[]) {\n@@ -51,1 +57,6 @@\n-            validate('+', arr1[i], arr2[i]);\n+            validate(\"+\", arr1[i], arr2[i]);\n+            validate(\"-\", arr1[i], arr2[i]);\n+            validate(\"*\", arr1[i], arr2[i]);\n+            validate(\"\/\", arr1[i], arr2[i]);\n+            validate(\"min\", arr1[i], arr2[i]);\n+            validate(\"max\", arr1[i], arr2[i]);\n@@ -55,4 +66,9 @@\n-    public static short expected_value(char oper, short input1, short input2) {\n-        switch((int)oper) {\n-            case '+' : return Float.floatToFloat16(Float.float16ToFloat(input1) + Float.float16ToFloat(input2));\n-            default  : throw new AssertionError(\"Unsupported Operation!\");\n+    public static short expected_value(String oper, short input1, short input2) {\n+        switch(oper) {\n+            case \"+\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) + Float.float16ToFloat(input2));\n+            case \"-\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) - Float.float16ToFloat(input2));\n+            case \"*\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) * Float.float16ToFloat(input2));\n+            case \"\/\"   : return Float.floatToFloat16(Float.float16ToFloat(input1) \/ Float.float16ToFloat(input2));\n+            case \"min\" : return Float.floatToFloat16(Float.min(Float.float16ToFloat(input1), Float.float16ToFloat(input2)));\n+            case \"max\" : return Float.floatToFloat16(Float.max(Float.float16ToFloat(input1), Float.float16ToFloat(input2)));\n+            default    : throw new AssertionError(\"Unsupported Operation!\");\n@@ -66,1 +82,1 @@\n-    public static void validate(char oper, short input1, short input2) {\n+    public static void validate(String oper, short input1, short input2) {\n@@ -94,2 +110,2 @@\n-            test_add(input1, input2);\n-            test_add(special_values, special_values);\n+            test_operations(input1, input2);\n+            test_operations(special_values, special_values);\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"}]}