{"files":[{"patch":"@@ -2356,9 +2356,25 @@\n-  int max_size = max_vector_size(bt);\n-  \/\/ Limit the min vector size to 8 bytes.\n-  int size = 8 \/ type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    \/\/ To support vector api shuffle\/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    \/\/ To support vector api load\/store mask.\n-    size = 2;\n+  \/\/ Usually, the shortest vector length supported by AArch64 ISA and\n+  \/\/ Vector API species is 64 bits. However, we allow 32-bit or 16-bit\n+  \/\/ vectors in a few special cases.\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      \/\/ Load\/store a vector mask with only 2 elements for vector types\n+      \/\/ such as \"2I\/2F\/2L\/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      \/\/ Generate a \"4B\" vector, to support vector cast between \"8B\/16B\"\n+      \/\/ and \"4S\/4I\/4L\/4F\/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      \/\/ Generate a \"2S\" vector, to support vector cast between \"4S\/8S\"\n+      \/\/ and \"2I\/2L\/2F\/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      \/\/ Limit the min vector length to 64-bit.\n+      size = 8 \/ type2aelembytes(bt);\n+      \/\/ The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n@@ -2366,1 +2382,2 @@\n-  if (size < 2) size = 2;\n+\n+  int max_size = max_vector_size(bt);\n@@ -3444,4 +3461,0 @@\n-  enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{\n-    __ load_byte_map_base($dst$$Register);\n-  %}\n-\n@@ -4579,14 +4592,0 @@\n-\/\/ Card Table Byte Map Base\n-operand immByteMapBase()\n-%{\n-  \/\/ Get base of card map\n-  predicate(BarrierSet::barrier_set()->is_a(BarrierSet::CardTableBarrierSet) &&\n-            SHENANDOAHGC_ONLY(!BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&)\n-            (CardTable::CardValue*)n->get_ptr() == ((CardTableBarrierSet*)(BarrierSet::barrier_set()))->card_table()->byte_map_base());\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -6879,14 +6878,0 @@\n-\/\/ Load Byte Map Base Constant\n-\n-instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)\n-%{\n-  match(Set dst con);\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"adr  $dst, $con\\t# Byte Map Base\" %}\n-\n-  ins_encode(aarch64_enc_mov_byte_map_base(dst, con));\n-\n-  ins_pipe(ialu_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":27,"deletions":42,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1807,7 +1807,5 @@\n-    if (dst_bt == T_SHORT) {\n-      \/\/ 4B\/8B to 4S\/8S\n-      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n-    } else {\n-      \/\/ 4B to 4I\n-      assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n-      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+    \/\/ 4B to 4S\/4I, 8B to 8S\n+    assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_SHORT || dst_bt == T_INT, \"unsupported\");\n+    _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+    if (dst_bt == T_INT) {\n@@ -1817,2 +1815,3 @@\n-    \/\/ 4S to 4I\n-    assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+    \/\/ 2S to 2I\/2L, 4S to 4I\n+    assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_INT || dst_bt == T_LONG, \"unsupported\");\n@@ -1820,0 +1819,3 @@\n+    if (dst_bt == T_LONG) {\n+      _xshll(is_unsigned, dst, T2D, dst, T2S, 0);\n+    }\n@@ -1839,2 +1841,2 @@\n-    \/\/ 4I to 4B\/4S\n-    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    \/\/ 2I to 2S, 4I to 4B\/4S\n+    assert(src_vlen_in_bytes == 8 || src_vlen_in_bytes == 16, \"unsupported\");\n@@ -1847,1 +1849,1 @@\n-    \/\/ 2L to 2I\n+    \/\/ 2L to 2S\/2I\n@@ -1849,1 +1851,1 @@\n-    assert(dst_bt == T_INT, \"unsupported\");\n+    assert(dst_bt == T_INT || dst_bt == T_SHORT, \"unsupported\");\n@@ -1851,0 +1853,3 @@\n+    if (dst_bt == T_SHORT) {\n+      xtn(dst, T4H, dst, T4S);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-          \"Options: none, nop, isb, yield, sb.\")                        \\\n+          \"Valid values are: none, nop, isb, yield, sb.\")               \\\n+          constraint(OnSpinWaitInstNameConstraintFunc, AtParse)         \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7611,0 +7611,1 @@\n+        assert(VM_Version::supports_sb(), \"current CPU does not support SB instruction\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    __ push(tmp);\n+    __ push_ppx(tmp);\n@@ -401,1 +401,1 @@\n-    __ pop(tmp); \/\/ pop it right away, no matter which path we take\n+    __ pop_ppx(tmp); \/\/ pop it right away, no matter which path we take\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1441,2 +1441,2 @@\n-        __ push(klass_RInfo);\n-        __ push(k_RInfo);\n+        __ push_ppx(klass_RInfo);\n+        __ push_ppx(k_RInfo);\n@@ -1444,2 +1444,2 @@\n-        __ pop(klass_RInfo);\n-        __ pop(klass_RInfo);\n+        __ pop_ppx(klass_RInfo);\n+        __ pop_ppx(klass_RInfo);\n@@ -1455,2 +1455,2 @@\n-      __ push(klass_RInfo);\n-      __ push(k_RInfo);\n+      __ push_ppx(klass_RInfo);\n+      __ push_ppx(k_RInfo);\n@@ -1458,2 +1458,2 @@\n-      __ pop(klass_RInfo);\n-      __ pop(k_RInfo);\n+      __ pop_ppx(klass_RInfo);\n+      __ pop_ppx(k_RInfo);\n@@ -1534,2 +1534,2 @@\n-    __ push(klass_RInfo);\n-    __ push(k_RInfo);\n+    __ push_ppx(klass_RInfo);\n+    __ push_ppx(k_RInfo);\n@@ -1537,2 +1537,2 @@\n-    __ pop(klass_RInfo);\n-    __ pop(k_RInfo);\n+    __ pop_ppx(klass_RInfo);\n+    __ pop_ppx(k_RInfo);\n@@ -2739,2 +2739,2 @@\n-      __ push(src);\n-      __ push(dst);\n+      __ push_ppx(src);\n+      __ push_ppx(dst);\n@@ -2747,2 +2747,2 @@\n-      __ push(src);\n-      __ push(dst);\n+      __ push_ppx(src);\n+      __ push_ppx(dst);\n@@ -2750,2 +2750,2 @@\n-      __ pop(dst);\n-      __ pop(src);\n+      __ pop_ppx(dst);\n+      __ pop_ppx(src);\n@@ -2757,2 +2757,2 @@\n-      __ pop(dst);\n-      __ pop(src);\n+      __ pop_ppx(dst);\n+      __ pop_ppx(src);\n@@ -3108,1 +3108,1 @@\n-      __ push(tmp);\n+      __ push_ppx(tmp);\n@@ -3114,1 +3114,1 @@\n-      __ pop(tmp);\n+      __ pop_ppx(tmp);\n@@ -3179,1 +3179,1 @@\n-          __ push(tmp);\n+          __ push_ppx(tmp);\n@@ -3190,1 +3190,1 @@\n-          __ pop(tmp);\n+          __ pop_ppx(tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -722,1 +722,1 @@\n-  __ push(rax);\n+  __ push_ppx(rax);\n@@ -730,1 +730,1 @@\n-  __ pop(rax);\n+  __ pop_ppx(rax);\n@@ -1185,4 +1185,4 @@\n-        __ push(rdi);\n-        __ push(rsi);\n-        __ push(rcx);\n-        __ push(rax);\n+        __ push_ppx(rdi);\n+        __ push_ppx(rsi);\n+        __ push_ppx(rcx);\n+        __ push_ppx(rax);\n@@ -1199,4 +1199,4 @@\n-        __ pop(rax);\n-        __ pop(rcx);\n-        __ pop(rsi);\n-        __ pop(rdi);\n+        __ pop_ppx(rax);\n+        __ pop_ppx(rcx);\n+        __ pop_ppx(rsi);\n+        __ pop_ppx(rdi);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -556,2 +556,2 @@\n-  __ push(rax);\n-  __ push(rdx);\n+  __ push_ppx(rax);\n+  __ push_ppx(rdx);\n@@ -605,2 +605,2 @@\n-  __ pop(rdx);\n-  __ pop(rax);\n+  __ pop_ppx(rdx);\n+  __ pop_ppx(rax);\n@@ -629,2 +629,2 @@\n-  __ push(rax);\n-  __ push(rcx);\n+  __ push_ppx(rax);\n+  __ push_ppx(rcx);\n@@ -655,1 +655,1 @@\n-  __ push(rdx);\n+  __ push_ppx(rdx);\n@@ -674,1 +674,1 @@\n-  __ pop(rdx);\n+  __ pop_ppx(rdx);\n@@ -677,2 +677,2 @@\n-  __ pop(rcx);\n-  __ pop(rax);\n+  __ pop_ppx(rcx);\n+  __ pop_ppx(rax);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -805,0 +805,16 @@\n+void MacroAssembler::push_ppx(Register src) {\n+  if (VM_Version::supports_apx_f()) {\n+    pushp(src);\n+  } else {\n+    Assembler::push(src);\n+  }\n+}\n+\n+void MacroAssembler::pop_ppx(Register dst) {\n+  if (VM_Version::supports_apx_f()) {\n+    popp(dst);\n+  } else {\n+    Assembler::pop(dst);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1046,0 +1046,3 @@\n+  void push_ppx(Register src);\n+  void pop_ppx(Register dst);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    __ push(method_holder); \/\/ keep holder around for diagnostic purposes\n+    __ push_ppx(method_holder); \/\/ keep holder around for diagnostic purposes\n@@ -168,1 +168,1 @@\n-    __ pop(method_holder); \/\/ restore stack layout\n+    __ pop_ppx(method_holder); \/\/ restore stack layout\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -593,1 +593,1 @@\n-    __ push(rax);\n+    __ push_ppx(rax);\n@@ -604,1 +604,1 @@\n-    __ pop(rax);\n+    __ pop_ppx(rax);\n@@ -621,4 +621,4 @@\n-  __ push(rax);\n-  __ push(c_rarg3);\n-  __ push(c_rarg2);\n-  __ push(c_rarg1);\n+  __ push_ppx(rax);\n+  __ push_ppx(c_rarg3);\n+  __ push_ppx(c_rarg2);\n+  __ push_ppx(c_rarg1);\n@@ -641,4 +641,4 @@\n-  __ pop(c_rarg1);\n-  __ pop(c_rarg2);\n-  __ pop(c_rarg3);\n-  __ pop(rax);\n+  __ pop_ppx(c_rarg1);\n+  __ pop_ppx(c_rarg2);\n+  __ pop_ppx(c_rarg3);\n+  __ pop_ppx(rax);\n@@ -659,4 +659,4 @@\n-  __ push(rax);\n-  __ push(c_rarg3);\n-  __ push(c_rarg2);\n-  __ push(c_rarg1);\n+  __ push_ppx(rax);\n+  __ push_ppx(c_rarg3);\n+  __ push_ppx(c_rarg2);\n+  __ push_ppx(c_rarg1);\n@@ -679,4 +679,4 @@\n-  __ pop(c_rarg1);\n-  __ pop(c_rarg2);\n-  __ pop(c_rarg3);\n-  __ pop(rax);\n+  __ pop_ppx(c_rarg1);\n+  __ pop_ppx(c_rarg2);\n+  __ pop_ppx(c_rarg3);\n+  __ pop_ppx(rax);\n@@ -698,5 +698,5 @@\n-  __ push(rax);\n-  __ push(c_rarg3);\n-  __ push(c_rarg2);\n-  __ push(c_rarg1);\n-  __ push(c_rarg0);\n+  __ push_ppx(rax);\n+  __ push_ppx(c_rarg3);\n+  __ push_ppx(c_rarg2);\n+  __ push_ppx(c_rarg1);\n+  __ push_ppx(c_rarg0);\n@@ -726,5 +726,5 @@\n-  __ pop(c_rarg0);\n-  __ pop(c_rarg1);\n-  __ pop(c_rarg2);\n-  __ pop(c_rarg3);\n-  __ pop(rax);\n+  __ pop_ppx(c_rarg0);\n+  __ pop_ppx(c_rarg1);\n+  __ pop_ppx(c_rarg2);\n+  __ pop_ppx(c_rarg3);\n+  __ pop_ppx(rax);\n@@ -746,5 +746,5 @@\n-  __ push(rax);\n-  __ push(c_rarg3);\n-  __ push(c_rarg2);\n-  __ push(c_rarg1);\n-  __ push(c_rarg0);\n+  __ push_ppx(rax);\n+  __ push_ppx(c_rarg3);\n+  __ push_ppx(c_rarg2);\n+  __ push_ppx(c_rarg1);\n+  __ push_ppx(c_rarg0);\n@@ -774,5 +774,5 @@\n-  __ pop(c_rarg0);\n-  __ pop(c_rarg1);\n-  __ pop(c_rarg2);\n-  __ pop(c_rarg3);\n-  __ pop(rax);\n+  __ pop_ppx(c_rarg0);\n+  __ pop_ppx(c_rarg1);\n+  __ pop_ppx(c_rarg2);\n+  __ pop_ppx(c_rarg3);\n+  __ pop_ppx(rax);\n@@ -1199,1 +1199,1 @@\n-  __ push(r12);\n+  __ push_ppx(r12);\n@@ -1202,2 +1202,2 @@\n-  __ push(c_rarg2);\n-  __ push(c_rarg3);\n+  __ push_ppx(c_rarg2);\n+  __ push_ppx(c_rarg3);\n@@ -1230,3 +1230,3 @@\n-  __ pop(c_rarg3);                             \/\/ restore c_rarg3\n-  __ pop(c_rarg2);                             \/\/ restore c_rarg2\n-  __ pop(r12);                                 \/\/ restore r12\n+  __ pop_ppx(c_rarg3);           \/\/ restore c_rarg3\n+  __ pop_ppx(c_rarg2);           \/\/ restore c_rarg2\n+  __ pop_ppx(r12);               \/\/ restore r12\n@@ -1240,3 +1240,3 @@\n-  __ pop(c_rarg3);                             \/\/ get saved c_rarg3 back\n-  __ pop(c_rarg2);                             \/\/ get saved c_rarg2 back\n-  __ pop(r12);                                 \/\/ get saved r12 back\n+  __ pop_ppx(c_rarg3);           \/\/ get saved c_rarg3 back\n+  __ pop_ppx(c_rarg2);           \/\/ get saved c_rarg2 back\n+  __ pop_ppx(r12);               \/\/ get saved r12 back\n@@ -1450,4 +1450,4 @@\n-  __ push(rbx);\n-  __ push(rdi);\n-  __ push(rsi);\n-  __ push(r15);\n+  __ push_ppx(rbx);\n+  __ push_ppx(rdi);\n+  __ push_ppx(rsi);\n+  __ push_ppx(r15);\n@@ -1465,4 +1465,4 @@\n-  __ pop(r15);\n-  __ pop(rsi);\n-  __ pop(rdi);\n-  __ pop(rbx);\n+  __ pop_ppx(r15);\n+  __ pop_ppx(rsi);\n+  __ pop_ppx(rdi);\n+  __ pop_ppx(rbx);\n@@ -1809,4 +1809,4 @@\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n+  __ push_ppx(r12);\n+  __ push_ppx(r13);\n+  __ push_ppx(r14);\n+  __ push_ppx(r15);\n@@ -2172,4 +2172,4 @@\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n+  __ pop_ppx(r15);\n+  __ pop_ppx(r14);\n+  __ pop_ppx(r13);\n+  __ pop_ppx(r12);\n@@ -2509,5 +2509,5 @@\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n-  __ push(rbx);\n+  __ push_ppx(r12);\n+  __ push_ppx(r13);\n+  __ push_ppx(r14);\n+  __ push_ppx(r15);\n+  __ push_ppx(rbx);\n@@ -2581,1 +2581,1 @@\n-  __ push(dest);          \/\/ Save for return value calc\n+  __ push_ppx(dest);          \/\/ Save for return value calc\n@@ -2812,1 +2812,1 @@\n-    __ pop(rax);             \/\/ Get original dest value\n+    __ pop_ppx(rax);             \/\/ Get original dest value\n@@ -2815,5 +2815,5 @@\n-    __ pop(rbx);\n-    __ pop(r15);\n-    __ pop(r14);\n-    __ pop(r13);\n-    __ pop(r12);\n+    __ pop_ppx(rbx);\n+    __ pop_ppx(r15);\n+    __ pop_ppx(r14);\n+    __ pop_ppx(r13);\n+    __ pop_ppx(r12);\n@@ -3006,2 +3006,2 @@\n-  __ pop(rax);             \/\/ Get original dest value\n-  __ subptr(dest, rax);      \/\/ Number of bytes converted\n+  __ pop_ppx(rax);             \/\/ Get original dest value\n+  __ subptr(dest, rax);                      \/\/ Number of bytes converted\n@@ -3009,5 +3009,5 @@\n-  __ pop(rbx);\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n+  __ pop_ppx(rbx);\n+  __ pop_ppx(r15);\n+  __ pop_ppx(r14);\n+  __ pop_ppx(r13);\n+  __ pop_ppx(r12);\n@@ -3136,2 +3136,2 @@\n-  __ push(y);\n-  __ push(z);\n+  __ push_ppx(y);\n+  __ push_ppx(z);\n@@ -3145,2 +3145,2 @@\n-  __ pop(z);\n-  __ pop(y);\n+  __ pop_ppx(z);\n+  __ pop_ppx(y);\n@@ -3332,1 +3332,1 @@\n-  __ push(c_rarg0);\n+  __ push_ppx(c_rarg0);\n@@ -3369,1 +3369,1 @@\n-  __ pop(c_rarg0);\n+  __ pop_ppx(c_rarg0);\n@@ -3380,1 +3380,1 @@\n-  __ pop(c_rarg0);\n+  __ pop_ppx(c_rarg0);\n@@ -3484,2 +3484,2 @@\n-  __ push(tmp3);\n-  __ push(tmp4);\n+  __ push_ppx(tmp3);\n+  __ push_ppx(tmp4);\n@@ -3487,1 +3487,1 @@\n-  __ push(tmp5);\n+  __ push_ppx(tmp5);\n@@ -3560,1 +3560,1 @@\n-  __ pop(tmp5);\n+  __ pop_ppx(tmp5);\n@@ -3562,2 +3562,2 @@\n-  __ pop(tmp4);\n-  __ pop(tmp3);\n+  __ pop_ppx(tmp4);\n+  __ pop_ppx(tmp3);\n@@ -3617,2 +3617,2 @@\n-  __ push(tmp3);\n-  __ push(tmp4);\n+  __ push_ppx(tmp3);\n+  __ push_ppx(tmp4);\n@@ -3620,1 +3620,1 @@\n-  __ push(tmp5);\n+  __ push_ppx(tmp5);\n@@ -3685,1 +3685,1 @@\n-  __ pop(tmp5);\n+  __ pop_ppx(tmp5);\n@@ -3687,2 +3687,2 @@\n-  __ pop(tmp4);\n-  __ pop(tmp3);\n+  __ pop_ppx(tmp4);\n+  __ pop_ppx(tmp3);\n@@ -3782,1 +3782,1 @@\n-  masm->push(rax);\n+  masm->push_ppx(rax);\n@@ -3839,1 +3839,1 @@\n-  masm->pop(rax);\n+  masm->pop_ppx(rax);\n@@ -3958,1 +3958,1 @@\n-    __ push(rax);\n+    __ push_ppx(rax);\n@@ -3967,1 +3967,1 @@\n-    __ pop(rax);\n+    __ pop_ppx(rax);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2946,1 +2946,1 @@\n-  __ push(rklass_tmp); \/\/ rdi is callee-save on Windows\n+  __ push_ppx(rklass_tmp); \/\/ rdi is callee-save on Windows\n@@ -3092,1 +3092,1 @@\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ pop_ppx(rklass_tmp); \/\/ Restore callee-save rdi\n@@ -3164,1 +3164,1 @@\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ pop_ppx(rklass_tmp); \/\/ Restore callee-save rdi\n@@ -3218,1 +3218,1 @@\n-    __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+    __ pop_ppx(rklass_tmp); \/\/ Restore callee-save rdi\n@@ -3231,1 +3231,1 @@\n-  __ pop(rklass_tmp); \/\/ Restore callee-save rdi\n+  __ pop_ppx(rklass_tmp); \/\/ Restore callee-save rdi\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-#undef DECLARE_CPU_FEATURE_FLAG\n+#undef DECLARE_CPU_FEATURE_NAME\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -651,0 +651,1 @@\n+  csize_t copy_relocations_to(address buf, csize_t buf_limit) const;\n@@ -801,2 +802,0 @@\n-  csize_t copy_relocations_to(address buf, csize_t buf_limit, bool only_inst) const;\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  bool should_install_code()                     { return _install_code && InstallMethods; }\n+  bool should_install_code()                     { return _install_code; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,1 +388,2 @@\n-  if (expected_type != nullptr && flags == 0) {\n+  if (expected_type != nullptr &&\n+      ((flags & ~LIR_OpArrayCopy::get_initial_copy_flags()) == 0)) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1309,0 +1309,2 @@\n+  static int get_initial_copy_flags()            { return LIR_OpArrayCopy::unaligned |\n+                                                          LIR_OpArrayCopy::overlapping; }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,3 +268,0 @@\n-  develop(bool, InstallMethods, true,                                       \\\n-          \"Install methods at the end of successful compilations\")          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -622,0 +622,1 @@\n+  log_info(aot)(\"Disabled all JVMTI agents during -XX:AOTMode=create\");\n@@ -726,0 +727,7 @@\n+  if (is_dumping_classic_static_archive() && AOTClassLinking) {\n+    if (JvmtiAgentList::disable_agent_list()) {\n+      FLAG_SET_ERGO(AllowArchivingWithJavaAgent, false);\n+      log_warning(cds)(\"Disabled all JVMTI agents with -Xshare:dump -XX:+AOTClassLinking\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2468,1 +2468,1 @@\n-void nmethod::oops_do(OopClosure* f, bool allow_dead) {\n+void nmethod::oops_do(OopClosure* f) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -940,2 +940,1 @@\n-  void oops_do(OopClosure* f) { oops_do(f, false); }\n-  void oops_do(OopClosure* f, bool allow_dead);\n+  void oops_do(OopClosure* f);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  CompileTask* next = _first;\n+  CompileTask* current = _first;\n@@ -373,18 +373,3 @@\n-  while (next != nullptr) {\n-    CompileTask* current = next;\n-    next = current->next();\n-    bool found_waiter = false;\n-    {\n-      MutexLocker ct_lock(CompileTaskWait_lock);\n-      assert(current->waiting_for_completion_count() <= 1, \"more than one thread are waiting for task\");\n-      if (current->waiting_for_completion_count() > 0) {\n-        \/\/ If another thread waits for this task, we must wake them up\n-        \/\/ so they will stop waiting and free the task.\n-        CompileTaskWait_lock->notify_all();\n-        found_waiter = true;\n-      }\n-    }\n-    if (!found_waiter) {\n-      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n-      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+  while (current != nullptr) {\n+    if (!current->is_blocking()) {\n+      \/\/ Non-blocking task. No one is waiting for it, delete it now.\n@@ -392,0 +377,4 @@\n+    } else {\n+      \/\/ Blocking task. By convention, it is the waiters responsibility\n+      \/\/ to delete the task. We cannot delete it here, because we do not\n+      \/\/ coordinate with waiters. We will notify the waiters later.\n@@ -393,0 +382,1 @@\n+    current = current->next();\n@@ -397,0 +387,8 @@\n+  \/\/ Wake up all blocking task waiters to deal with remaining blocking\n+  \/\/ tasks. This is not a performance sensitive path, so we do this\n+  \/\/ unconditionally to simplify coding\/testing.\n+  {\n+    MonitorLocker ml(Thread::current(), CompileTaskWait_lock);\n+    ml.notify_all();\n+  }\n+\n@@ -1723,2 +1721,2 @@\n-    MonitorLocker ml(thread, CompileTaskWait_lock);\n-    task->inc_waiting_for_completion();\n+    \/\/ Wait until the task is complete or compilation is shut down.\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1729,1 +1727,0 @@\n-    task->dec_waiting_for_completion();\n@@ -1732,5 +1729,10 @@\n-  if (free_task) {\n-    if (is_compilation_disabled_forever()) {\n-      delete task;\n-      return;\n-    }\n+  \/\/ It is harmless to check this status without the lock, because\n+  \/\/ completion is a stable property.\n+  if (!task->is_complete() && is_compilation_disabled_forever()) {\n+    \/\/ Task is not complete, and we are exiting for compilation shutdown.\n+    \/\/ The task can still be executed by some compiler thread, therefore\n+    \/\/ we cannot delete it. This will leave task allocated, which leaks it.\n+    \/\/ At this (degraded) point, it is less risky to abandon the task,\n+    \/\/ rather than attempting a more complicated deletion protocol.\n+    free_task = false;\n+  }\n@@ -1738,2 +1740,1 @@\n-    \/\/ It is harmless to check this status without the lock, because\n-    \/\/ completion is a stable property (until the task object is deleted).\n+  if (free_task) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -736,10 +736,0 @@\n-  {\n-    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n-    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n-    DEBUG_ONLY(MetaspaceUtils::verify();)\n-  }\n-\n-  \/\/ Need to clear claim bits for the next mark.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n-\n@@ -1048,4 +1038,0 @@\n-    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n-                              false \/* unregister_nmethods_during_purge *\/,\n-                              false \/* lock_nmethod_free_separately *\/);\n-\n@@ -1341,1 +1327,3 @@\n-    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* unregister_nmethods_during_purge *\/,\n+                              false \/* lock_nmethod_free_separately *\/);\n@@ -1357,1 +1345,1 @@\n-      ctx->purge_nmethods();\n+      ctx.purge_nmethods();\n@@ -1365,1 +1353,1 @@\n-      ctx->free_nmethods();\n+      ctx.free_nmethods();\n@@ -1373,0 +1361,9 @@\n+    {\n+      \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+      ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+      DEBUG_ONLY(MetaspaceUtils::verify();)\n+    }\n+\n+    \/\/ Need to clear claim bits for the next mark.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2280,1 +2280,1 @@\n-  JVMCIObjectArray array = JVMCIENV->new_FieldInfo_array(fields->length(), JVMCIENV);\n+  JVMCIObjectArray array = JVMCIENV->new_FieldInfo_array(fields->length(), JVMCI_CHECK_NULL);\n@@ -2988,0 +2988,1 @@\n+\/\/ Checks that `index` denotes a non-injected field in `klass`\n@@ -2994,1 +2995,8 @@\n-  if (index < 0 || index > iklass->total_fields_count()) {\n+  if (index < 0 || index >= iklass->java_fields_count()) {\n+    if (index >= 0 && index < iklass->total_fields_count()) {\n+      fieldDescriptor fd(iklass, index);\n+      if (fd.is_injected()) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+            err_msg(\"Cannot get Field for injected %s.%s\", klass->external_name(), fd.name()->as_C_string()));\n+      }\n+    }\n@@ -3004,1 +3012,1 @@\n-  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCI_CHECK_NULL);\n@@ -3012,1 +3020,1 @@\n-                                              JavaThread* THREAD, JVMCIEnv* JVMCIENV) {\n+                                              JavaThread* THREAD, JVMCI_TRAPS) {\n@@ -3090,1 +3098,1 @@\n-  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCIENV);\n+  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCI_CHECK_NULL);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -769,0 +769,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n@@ -1158,1 +1159,0 @@\n-#undef DECLARE_CPU_FEATURE_FLAG\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  LOG_TAG(package) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -903,2 +904,0 @@\n-  ClassLoaderData::init_null_class_loader_data();\n-\n@@ -911,0 +910,8 @@\n+#endif\n+\n+  ClassLoaderData::init_null_class_loader_data();\n+\n+#if INCLUDE_CDS\n+  if (CDSConfig::is_using_full_module_graph()) {\n+    ClassLoaderDataShared::restore_archived_entries_for_null_class_loader_data();\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -54,2 +55,0 @@\n-#include \"oops\/flatArrayKlass.hpp\"\n-\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"memory\/memRegion.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+\n@@ -29,0 +30,1 @@\n+#include \"memory\/memRegion.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"oops\/flatArrayKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"flatArrayOop.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"flatArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/flatArrayOop.hpp\"\n+\n@@ -30,1 +32,0 @@\n-#include \"oops\/flatArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"memory\/metaspaceClosure.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -44,1 +44,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -46,0 +45,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"oops\/inlineKlass.hpp\"\n+\n@@ -29,1 +31,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"logging\/log.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -64,1 +64,2 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -76,2 +77,0 @@\n-#include \"oops\/symbol.hpp\"\n-#include \"oops\/inlineKlass.hpp\"\n@@ -79,0 +78,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -84,1 +84,1 @@\n-#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"runtime\/java.hpp\"\n+#include \"runtime\/java.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -54,1 +54,2 @@\n-#include \"oops\/constMethod.hpp\"\n+#include \"oops\/constMethod.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -64,1 +65,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -68,1 +68,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/methodFlags.hpp\"\n+#include \"oops\/methodFlags.hpp\"\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/compressedKlass.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n@@ -38,0 +38,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"memory\/universe.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -37,1 +37,1 @@\n-#include \"oops\/objLayout.inline.hpp\"\n+#include \"oops\/objLayout.inline.hpp\"\n@@ -44,1 +44,1 @@\n-#include \"utilities\/macros.hpp\"\n+#include \"utilities\/macros.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/refArrayOop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/refArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/refArrayKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/refArrayOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/refArrayOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/archiveBuilder.hpp\"\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -881,0 +881,9 @@\n+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop\/long range checks: don't create loop nest if \" \\\n+          \"loop runs for small enough number of iterations. Long loop is \"  \\\n+          \"converted to a single int loop.\")                                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds \" \\\n+          \"are unknown even if profile data doesn't say so.\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -952,1 +952,1 @@\n-CallProjections* CallNode::extract_projections(bool separate_io_proj, bool do_asserts) {\n+CallProjections* CallNode::extract_projections(bool separate_io_proj, bool do_asserts) const {\n@@ -1488,0 +1488,51 @@\n+bool CallLeafPureNode::is_unused() const {\n+  return proj_out_or_null(TypeFunc::Parms) == nullptr;\n+}\n+\n+bool CallLeafPureNode::is_dead() const {\n+  return proj_out_or_null(TypeFunc::Control) == nullptr;\n+}\n+\n+\/* We make a tuple of the global input state + TOP for the output values.\n+ * We use this to delete a pure function that is not used: by replacing the call with\n+ * such a tuple, we let output Proj's idealization pick the corresponding input of the\n+ * pure call, so jumping over it, and effectively, removing the call from the graph.\n+ * This avoids doing the graph surgery manually, but leaves that to IGVN\n+ * that is specialized for doing that right. We need also tuple components for output\n+ * values of the function to respect the return arity, and in case there is a projection\n+ * that would pick an output (which shouldn't happen at the moment).\n+ *\/\n+TupleNode* CallLeafPureNode::make_tuple_of_input_state_and_top_return_values(const Compile* C) const {\n+  \/\/ Transparently propagate input state but parameters\n+  TupleNode* tuple = TupleNode::make(\n+      tf()->range_cc(),\n+      in(TypeFunc::Control),\n+      in(TypeFunc::I_O),\n+      in(TypeFunc::Memory),\n+      in(TypeFunc::FramePtr),\n+      in(TypeFunc::ReturnAdr));\n+\n+  \/\/ And add TOPs for the return values\n+  for (uint i = TypeFunc::Parms; i < tf()->range_cc()->cnt(); i++) {\n+    tuple->set_req(i, C->top());\n+  }\n+\n+  return tuple;\n+}\n+\n+Node* CallLeafPureNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (is_dead()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We need to wait until IGVN because during parsing, usages might still be missing\n+  \/\/ and we would remove the call immediately.\n+  if (can_reshape && is_unused()) {\n+    \/\/ The result is not used. We remove the call by replacing it with a tuple, that\n+    \/\/ is later disintegrated by the projections.\n+    return make_tuple_of_input_state_and_top_return_values(phase->C);\n+  }\n+\n+  return CallRuntimeNode::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-  CallProjections* extract_projections(bool separate_io_proj, bool do_asserts = true);\n+  CallProjections* extract_projections(bool separate_io_proj, bool do_asserts = true) const;\n@@ -950,0 +950,27 @@\n+\/* A pure function call, they are assumed not to be safepoints, not to read or write memory,\n+ * have no exception... They just take parameters, return a value without side effect. It is\n+ * always correct to create some, or remove them, if the result is not used.\n+ *\n+ * They still have control input to allow easy lowering into other kind of calls that require\n+ * a control, but this is more a technical than a moral constraint.\n+ *\n+ * Pure calls must have only control and data input and output: I\/O, Memory and so on must be top.\n+ * Nevertheless, pure calls can typically be expensive math operations so care must be taken\n+ * when letting the node float.\n+ *\/\n+class CallLeafPureNode : public CallLeafNode {\n+protected:\n+  bool is_unused() const;\n+  bool is_dead() const;\n+  TupleNode* make_tuple_of_input_state_and_top_return_values(const Compile* C) const;\n+\n+public:\n+  CallLeafPureNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type)\n+      : CallLeafNode(tf, addr, name, adr_type) {\n+    init_class_id(Class_CallLeafPure);\n+  }\n+  int Opcode() const override;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/cfgnode.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/loopnode.hpp\"\n@@ -344,0 +346,61 @@\n+bool CastLLNode::is_inner_loop_backedge(ProjNode* proj) {\n+  if (proj != nullptr) {\n+    Node* ctrl_use = proj->unique_ctrl_out_or_null();\n+    if (ctrl_use != nullptr && ctrl_use->Opcode() == Op_Loop &&\n+        ctrl_use->in(2) == proj &&\n+        ctrl_use->as_Loop()->is_loop_nest_inner_loop()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CastLLNode::cmp_used_at_inner_loop_exit_test(CmpNode* cmp) {\n+  for (DUIterator_Fast imax, i = cmp->fast_outs(imax); i < imax; i++) {\n+    Node* bol = cmp->fast_out(i);\n+    if (bol->Opcode() == Op_Bool) {\n+      for (DUIterator_Fast jmax, j = bol->fast_outs(jmax); j < jmax; j++) {\n+        Node* iff = bol->fast_out(j);\n+        if (iff->Opcode() == Op_If) {\n+          ProjNode* true_proj = iff->as_If()->proj_out_or_null(true);\n+          ProjNode* false_proj = iff->as_If()->proj_out_or_null(false);\n+          if (is_inner_loop_backedge(true_proj) || is_inner_loop_backedge(false_proj)) {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Find if this is a cast node added by PhaseIdealLoop::create_loop_nest() to narrow the number of iterations of the\n+\/\/ inner loop\n+bool CastLLNode::used_at_inner_loop_exit_test() const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* convl2i = fast_out(i);\n+    if (convl2i->Opcode() == Op_ConvL2I) {\n+      for (DUIterator_Fast jmax, j = convl2i->fast_outs(jmax); j < jmax; j++) {\n+        Node* cmp_or_sub = convl2i->fast_out(j);\n+        if (cmp_or_sub->Opcode() == Op_CmpI) {\n+          if (cmp_used_at_inner_loop_exit_test(cmp_or_sub->as_Cmp())) {\n+            \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (ConvL2I (CastLL )))))))\n+            return true;\n+          }\n+        } else if (cmp_or_sub->Opcode() == Op_SubI && cmp_or_sub->in(1)->find_int_con(-1) == 0) {\n+          for (DUIterator_Fast kmax, k = cmp_or_sub->fast_outs(kmax); k < kmax; k++) {\n+            Node* cmp = cmp_or_sub->fast_out(k);\n+            if (cmp->Opcode() == Op_CmpI) {\n+              if (cmp_used_at_inner_loop_exit_test(cmp->as_Cmp())) {\n+                \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (SubI 0 (ConvL2I (CastLL ))))))))\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -373,1 +436,6 @@\n-  return optimize_integer_cast(phase, T_LONG);\n+  \/\/ If it's a cast created by PhaseIdealLoop::short_running_loop(), don't transform it until the counted loop is created\n+  \/\/ in next loop opts pass\n+  if (!can_reshape || !used_at_inner_loop_exit_test()) {\n+    return optimize_integer_cast(phase, T_LONG);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -141,0 +141,6 @@\n+\n+  static bool is_inner_loop_backedge(ProjNode* proj);\n+\n+  static bool cmp_used_at_inner_loop_exit_test(CmpNode* cmp);\n+  bool used_at_inner_loop_exit_test() const;\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+macro(CallLeafPure)\n@@ -378,0 +379,1 @@\n+macro(Tuple)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3816,0 +3816,19 @@\n+  case Op_CallLeafPure: {\n+    \/\/ If the pure call is not supported, then lower to a CallLeaf.\n+    if (!Matcher::match_rule_supported(Op_CallLeafPure)) {\n+      CallNode* call = n->as_Call();\n+      CallNode* new_call = new CallLeafNode(call->tf(), call->entry_point(),\n+                                            call->_name, TypeRawPtr::BOTTOM);\n+      new_call->init_req(TypeFunc::Control, call->in(TypeFunc::Control));\n+      new_call->init_req(TypeFunc::I_O, C->top());\n+      new_call->init_req(TypeFunc::Memory, C->top());\n+      new_call->init_req(TypeFunc::ReturnAdr, C->top());\n+      new_call->init_req(TypeFunc::FramePtr, C->top());\n+      for (unsigned int i = TypeFunc::Parms; i < call->tf()->domain_sig()->cnt(); i++) {\n+        new_call->init_req(i, call->in(i));\n+      }\n+      n->subsume_by(new_call, this);\n+    }\n+    frc.inc_call_count();\n+    break;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, const char* name) : CallLeafNode(tf, nullptr, name, TypeRawPtr::BOTTOM) {\n+ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name) : CallLeafPureNode(tf, addr, name, TypeRawPtr::BOTTOM) {\n@@ -50,1 +50,1 @@\n-ModDNode::ModDNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::Math_DD_D_Type(), \"drem\") {\n+ModDNode::ModDNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::Math_DD_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::drem), \"drem\") {\n@@ -57,1 +57,1 @@\n-ModFNode::ModFNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::modf_Type(), \"frem\") {\n+ModFNode::ModFNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::modf_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::frem), \"frem\") {\n@@ -1514,19 +1514,1 @@\n-Node* ModFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n-  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n-  if (result_is_unused && not_dead) {\n-    return replace_with_con(igvn, TypeF::make(0.));\n-  }\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return phase->C->top();\n-  }\n-\n+const Type* ModFNode::get_result_if_constant(const Type* dividend, const Type* divisor) const {\n@@ -1534,1 +1516,1 @@\n-  if ((t1->base() != Type::FloatCon) || (t2->base() != Type::FloatCon)) {\n+  if ((dividend->base() != Type::FloatCon) || (divisor->base() != Type::FloatCon)) {\n@@ -1538,4 +1520,4 @@\n-  float f1 = t1->getf();\n-  float f2 = t2->getf();\n-  jint x1 = jint_cast(f1); \/\/ note:  *(int*)&f1, not just (int)f1\n-  jint x2 = jint_cast(f2);\n+  float dividend_f = dividend->getf();\n+  float divisor_f = divisor->getf();\n+  jint dividend_i = jint_cast(dividend_f); \/\/ note:  *(int*)&f1, not just (int)f1\n+  jint divisor_i = jint_cast(divisor_f);\n@@ -1544,2 +1526,2 @@\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n+  if (g_isnan(dividend_f)) {\n+    return dividend;\n@@ -1547,2 +1529,2 @@\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n+  if (g_isnan(divisor_f)) {\n+    return divisor;\n@@ -1552,1 +1534,1 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint) {\n+  if (!g_isfinite(dividend_f) || !g_isfinite(divisor_f) || divisor_i == 0 || divisor_i == min_jint) {\n@@ -1558,2 +1540,2 @@\n-  jint xr = jint_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n+  jint xr = jint_cast(fmod(dividend_f, divisor_f));\n+  if ((dividend_i ^ xr) < 0) {\n@@ -1563,1 +1545,1 @@\n-  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n+  return TypeF::make(jfloat_cast(xr));\n@@ -1566,19 +1548,1 @@\n-Node* ModDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  if (!can_reshape) {\n-    return nullptr;\n-  }\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n-  bool not_dead = proj_out_or_null(TypeFunc::Control) != nullptr;\n-  if (result_is_unused && not_dead) {\n-    return replace_with_con(igvn, TypeD::make(0.));\n-  }\n-\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type* t1 = phase->type(dividend());\n-  const Type* t2 = phase->type(divisor());\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return nullptr;\n-  }\n-\n+const Type* ModDNode::get_result_if_constant(const Type* dividend, const Type* divisor) const {\n@@ -1586,1 +1550,1 @@\n-  if ((t1->base() != Type::DoubleCon) || (t2->base() != Type::DoubleCon)) {\n+  if ((dividend->base() != Type::DoubleCon) || (divisor->base() != Type::DoubleCon)) {\n@@ -1590,4 +1554,4 @@\n-  double f1 = t1->getd();\n-  double f2 = t2->getd();\n-  jlong x1 = jlong_cast(f1); \/\/ note:  *(long*)&f1, not just (long)f1\n-  jlong x2 = jlong_cast(f2);\n+  double dividend_d = dividend->getd();\n+  double divisor_d = divisor->getd();\n+  jlong dividend_l = jlong_cast(dividend_d); \/\/ note:  *(long*)&f1, not just (long)f1\n+  jlong divisor_l = jlong_cast(divisor_d);\n@@ -1596,2 +1560,2 @@\n-  if (g_isnan(f1)) {\n-    return replace_with_con(igvn, t1);\n+  if (g_isnan(dividend_d)) {\n+    return dividend;\n@@ -1599,2 +1563,2 @@\n-  if (g_isnan(f2)) {\n-    return replace_with_con(igvn, t2);\n+  if (g_isnan(divisor_d)) {\n+    return divisor;\n@@ -1604,1 +1568,1 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong) {\n+  if (!g_isfinite(dividend_d) || !g_isfinite(divisor_d) || divisor_l == 0 || divisor_l == min_jlong) {\n@@ -1610,2 +1574,2 @@\n-  jlong xr = jlong_cast(fmod(f1, f2));\n-  if ((x1 ^ xr) < 0) {\n+  jlong xr = jlong_cast(fmod(dividend_d, divisor_d));\n+  if ((dividend_l ^ xr) < 0) {\n@@ -1615,1 +1579,1 @@\n-  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n+  return TypeD::make(jdouble_cast(xr));\n@@ -1618,21 +1582,14 @@\n-Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n-  Compile* C = phase->C;\n-  Node* con_node = phase->makecon(con);\n-  CallProjections* projs = extract_projections(false, false);\n-  phase->replace_node(projs->fallthrough_proj, in(TypeFunc::Control));\n-  if (projs->fallthrough_catchproj != nullptr) {\n-    phase->replace_node(projs->fallthrough_catchproj, in(TypeFunc::Control));\n-  }\n-  if (projs->fallthrough_memproj != nullptr) {\n-    phase->replace_node(projs->fallthrough_memproj, in(TypeFunc::Memory));\n-  }\n-  if (projs->catchall_memproj != nullptr) {\n-    phase->replace_node(projs->catchall_memproj, C->top());\n-  }\n-  if (projs->fallthrough_ioproj != nullptr) {\n-    phase->replace_node(projs->fallthrough_ioproj, in(TypeFunc::I_O));\n-  }\n-  assert(projs->catchall_ioproj == nullptr, \"no exceptions from floating mod\");\n-  assert(projs->catchall_catchproj == nullptr, \"no exceptions from floating mod\");\n-  if (projs->resproj[0] != nullptr) {\n-    phase->replace_node(projs->resproj[0], con_node);\n+Node* ModFloatingNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+    \/\/ Either input is TOP ==> the result is TOP\n+    const Type* dividend_type = phase->type(dividend());\n+    const Type* divisor_type = phase->type(divisor());\n+    if (dividend_type == Type::TOP || divisor_type == Type::TOP) {\n+      return phase->C->top();\n+    }\n+    const Type* constant_result = get_result_if_constant(dividend_type, divisor_type);\n+    if (constant_result != nullptr) {\n+      return make_tuple_of_input_state_and_constant_result(igvn, constant_result);\n+    }\n@@ -1640,4 +1597,20 @@\n-  phase->replace_node(this, C->top());\n-  C->remove_macro_node(this);\n-  disconnect_inputs(C);\n-  return nullptr;\n+\n+  return CallLeafPureNode::Ideal(phase, can_reshape);\n+}\n+\n+\/* Give a tuple node for ::Ideal to return, made of the input state (control to return addr)\n+ * and the given constant result. Idealization of projections will make sure to transparently\n+ * propagate the input state and replace the result by the said constant.\n+ *\/\n+TupleNode* ModFloatingNode::make_tuple_of_input_state_and_constant_result(PhaseIterGVN* phase, const Type* con) const {\n+  Node* con_node = phase->makecon(con);\n+  TupleNode* tuple = TupleNode::make(\n+      tf()->range_cc(),\n+      in(TypeFunc::Control),\n+      in(TypeFunc::I_O),\n+      in(TypeFunc::Memory),\n+      in(TypeFunc::FramePtr),\n+      in(TypeFunc::ReturnAdr),\n+      con_node);\n+\n+  return tuple;\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":65,"deletions":92,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -159,1 +159,3 @@\n-class ModFloatingNode : public CallLeafNode {\n+class ModFloatingNode : public CallLeafPureNode {\n+  TupleNode* make_tuple_of_input_state_and_constant_result(PhaseIterGVN* phase, const Type* con) const;\n+\n@@ -161,1 +163,3 @@\n-  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n+  virtual Node* dividend() const = 0;\n+  virtual Node* divisor() const = 0;\n+  virtual const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const = 0;\n@@ -164,1 +168,2 @@\n-  ModFloatingNode(Compile* C, const TypeFunc* tf, const char *name);\n+  ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name);\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n@@ -170,2 +175,3 @@\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 1); }\n+  Node* dividend() const override { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const override { return in(TypeFunc::Parms + 1); }\n+  const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const override;\n@@ -175,4 +181,3 @@\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegF; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  int Opcode() const override;\n+  uint ideal_reg() const override { return Op_RegF; }\n+  uint size_of() const override { return sizeof(*this); }\n@@ -184,2 +189,3 @@\n-  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n-  Node* divisor() const { return in(TypeFunc::Parms + 2); }\n+  Node* dividend() const override { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const override { return in(TypeFunc::Parms + 2); }\n+  const Type* get_result_if_constant(const Type* dividend, const Type* divisor) const override;\n@@ -189,4 +195,3 @@\n-  virtual int Opcode() const;\n-  virtual uint ideal_reg() const { return Op_RegD; }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  int Opcode() const override;\n+  uint ideal_reg() const override { return Op_RegD; }\n+  uint size_of() const override { return sizeof(*this); }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2097,8 +2097,14 @@\n-  Node* memory = reset_memory();\n-  Node* m = narrow_mem == nullptr ? memory : narrow_mem;\n-  call->init_req( TypeFunc::Control,   control()  );\n-  call->init_req( TypeFunc::I_O,       top()      ); \/\/ does no i\/o\n-  call->init_req( TypeFunc::Memory,    m          ); \/\/ may gc ptrs\n-  call->init_req( TypeFunc::FramePtr,  frameptr() );\n-  call->init_req( TypeFunc::ReturnAdr, top()      );\n-  return memory;\n+  call->init_req(TypeFunc::Control, control());\n+  call->init_req(TypeFunc::I_O, top()); \/\/ does no i\/o\n+  call->init_req(TypeFunc::ReturnAdr, top());\n+  if (call->is_CallLeafPure()) {\n+    call->init_req(TypeFunc::Memory, top());\n+    call->init_req(TypeFunc::FramePtr, top());\n+    return nullptr;\n+  } else {\n+    Node* memory = reset_memory();\n+    Node* m = narrow_mem == nullptr ? memory : narrow_mem;\n+    call->init_req(TypeFunc::Memory, m); \/\/ may gc ptrs\n+    call->init_req(TypeFunc::FramePtr, frameptr());\n+    return memory;\n+  }\n@@ -2122,0 +2128,5 @@\n+  if (call->is_CallLeafPure()) {\n+    \/\/ Pure function have only control (for now) and data output, in particular\n+    \/\/ they don't touch the memory, so we don't want a memory proj that is set after.\n+    return;\n+  }\n@@ -2722,0 +2733,2 @@\n+  } else if (flags & RC_PURE) {\n+    call = new CallLeafPureNode(call_type, call_addr, call_name, adr_type);\n@@ -4619,0 +4632,5 @@\n+  if (ShortRunningLongLoop) {\n+    \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n+    \/\/ walking up from the loop.\n+    add_parse_predicate(Deoptimization::Reason_short_running_long_loop, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -809,0 +809,1 @@\n+    RC_PURE = 128,              \/\/ CallLeaf is pure\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2198,0 +2198,1 @@\n+    case Deoptimization::Reason_short_running_long_loop:\n@@ -2246,0 +2247,3 @@\n+    case Deoptimization::DeoptReason::Reason_short_running_long_loop:\n+      st->print(\"Short_Running_Long_Loop \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1824,1 +1824,1 @@\n-  Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,\n+  Node* trig = make_runtime_call(RC_LEAF | RC_PURE, call_type, funcAddr, funcName,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,12 @@\n+\n+  virtual void set_trip_count(julong tc) = 0;\n+  virtual julong trip_count() const = 0;\n+\n+  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n+  void set_exact_trip_count(julong tc) {\n+    set_trip_count(tc);\n+    _loop_flags |= HasExactTripCount;\n+  }\n+  void set_nonexact_trip_count() {\n+    _loop_flags &= ~HasExactTripCount;\n+  }\n@@ -304,0 +316,5 @@\n+  void set_trip_count(julong tc) {\n+    assert(tc < max_juint, \"Cannot set trip count to max_juint\");\n+    _trip_count = checked_cast<uint>(tc);\n+  }\n+  julong trip_count() const      { return _trip_count; }\n@@ -310,14 +327,0 @@\n-  \/\/ We use max_juint for the default value of _trip_count to signal it wasn't set.\n-  \/\/ We shouldn't set _trip_count to max_juint explicitly.\n-  void set_trip_count(uint tc) { assert(tc < max_juint, \"Cannot set trip count to max_juint\"); _trip_count = tc; }\n-  uint trip_count()            { return _trip_count; }\n-\n-  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n-  void set_exact_trip_count(uint tc) {\n-    assert(tc < max_juint, \"Cannot set trip count to max_juint\");\n-    _trip_count = tc;\n-    _loop_flags |= HasExactTripCount;\n-  }\n-  void set_nonexact_trip_count() {\n-    _loop_flags &= ~HasExactTripCount;\n-  }\n@@ -386,0 +389,6 @@\n+private:\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  \/\/ Known trip count calculated by compute_exact_trip_count()\n+  julong _trip_count;\n+\n@@ -388,1 +397,1 @@\n-    : BaseCountedLoopNode(entry, backedge) {\n+    : BaseCountedLoopNode(entry, backedge), _trip_count(max_julong) {\n@@ -398,0 +407,6 @@\n+  void set_trip_count(julong tc) {\n+    assert(tc < max_julong, \"Cannot set trip count to max_julong\");\n+    _trip_count = tc;\n+  }\n+  julong trip_count() const      { return _trip_count; }\n+\n@@ -785,1 +800,1 @@\n-  void compute_trip_count(PhaseIdealLoop* phase);\n+  void compute_trip_count(PhaseIdealLoop* phase, BasicType bt);\n@@ -1842,0 +1857,2 @@\n+  bool try_make_short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List& range_checks, const uint iters_limit);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3242,5 +3242,2 @@\n-        bool is_drem = n->Opcode() == Op_ModD;\n-        CallNode* call = new CallLeafNode(mod_macro->tf(),\n-                                          is_drem ? CAST_FROM_FN_PTR(address, SharedRuntime::drem)\n-                                                  : CAST_FROM_FN_PTR(address, SharedRuntime::frem),\n-                                          is_drem ? \"drem\" : \"frem\", TypeRawPtr::BOTTOM);\n+        CallNode* call = new CallLeafPureNode(mod_macro->tf(), mod_macro->entry_point(),\n+                                              mod_macro->_name, TypeRawPtr::BOTTOM);\n@@ -3249,4 +3246,4 @@\n-        call->init_req(TypeFunc::I_O, mod_macro->in(TypeFunc::I_O));\n-        call->init_req(TypeFunc::Memory, mod_macro->in(TypeFunc::Memory));\n-        call->init_req(TypeFunc::ReturnAdr, mod_macro->in(TypeFunc::ReturnAdr));\n-        call->init_req(TypeFunc::FramePtr, mod_macro->in(TypeFunc::FramePtr));\n+        call->init_req(TypeFunc::I_O, C->top());\n+        call->init_req(TypeFunc::Memory, C->top());\n+        call->init_req(TypeFunc::ReturnAdr, C->top());\n+        call->init_req(TypeFunc::FramePtr, C->top());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -123,0 +123,4 @@\n+    if (ctrl->Opcode() == Op_Tuple) {\n+      \/\/ Jumping over Tuples: the i-th projection of a Tuple is the i-th input of the Tuple.\n+      ctrl = ctrl->in(_con);\n+    }\n@@ -166,0 +170,9 @@\n+\/\/------------------------------Identity---------------------------------------\n+Node* ProjNode::Identity(PhaseGVN* phase) {\n+  if (in(0) != nullptr && in(0)->Opcode() == Op_Tuple) {\n+    \/\/ Jumping over Tuples: the i-th projection of a Tuple is the i-th input of the Tuple.\n+    return in(0)->in(_con);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -108,0 +109,45 @@\n+\/* Tuples are used to avoid manual graph surgery. When a node with Proj outputs (such as a call)\n+ * must be removed and its ouputs replaced by its input, or some other value, we can make its\n+ * ::Ideal return a tuple of what we want for each output: the ::Identity of output Proj will\n+ * take care to jump over the Tuple and directly pick up the right input of the Tuple.\n+ *\n+ * For instance, if a function call is proven to have no side effect and return the constant 0,\n+ * we can replace it with the 6-tuple:\n+ * (control input, IO input, memory input, frame ptr input, return addr input, Con:0)\n+ * all the output projections will pick up the input of the now gone call, except for the result\n+ * projection that is replaced by 0.\n+ *\n+ * Using TupleNode avoid manual graph surgery and leave that to our expert surgeon: IGVN.\n+ * Since the user of a Tuple are expected to be Proj, when creating a tuple during idealization,\n+ * the output Proj should be enqueued for IGVN immediately after, and the tuple should not survive\n+ * after the current IGVN.\n+ *\/\n+class TupleNode : public MultiNode {\n+  const TypeTuple* _tf;\n+\n+  template <typename... NN>\n+  static void make_helper(TupleNode* tn, uint i, Node* node, NN... nn) {\n+    tn->set_req(i, node);\n+    make_helper(tn, i + 1, nn...);\n+  }\n+\n+  static void make_helper(TupleNode*, uint) {}\n+\n+public:\n+  TupleNode(const TypeTuple* tf) : MultiNode(tf->cnt()), _tf(tf) {}\n+\n+  int Opcode() const override;\n+  const Type* bottom_type() const override { return _tf; }\n+\n+  \/* Give as many `Node*` as you want in the `nn` pack:\n+   * TupleNode::make(tf, input1)\n+   * TupleNode::make(tf, input1, input2, input3, input4)\n+   *\/\n+  template <typename... NN>\n+  static TupleNode* make(const TypeTuple* tf, NN... nn) {\n+    TupleNode* tn = new TupleNode(tf);\n+    make_helper(tn, 0, nn...);\n+    return tn;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2956,10 +2956,0 @@\n-bool Node::is_pure_function() const {\n-  switch (Opcode()) {\n-  case Op_ModD:\n-  case Op_ModF:\n-    return true;\n-  default:\n-    return false;\n-  }\n-}\n-\n@@ -2972,1 +2962,1 @@\n-  return Opcode() == Op_Proj && as_Proj()->_con == TypeFunc::Parms && maybe_pure_function->is_pure_function();\n+  return Opcode() == Op_Proj && as_Proj()->_con == TypeFunc::Parms && maybe_pure_function->is_CallLeafPure();\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class CallLeafPureNode;\n@@ -680,0 +681,1 @@\n+              DEFINE_CLASS_ID(CallLeafPure,     CallLeaf, 1)\n@@ -920,0 +922,1 @@\n+  DEFINE_CLASS_QUERY(CallLeafPure)\n@@ -1306,2 +1309,0 @@\n-  bool is_pure_function() const;\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1474,1 +1474,1 @@\n-  CallNode* mod = type == BasicType::T_DOUBLE ? static_cast<CallNode*>(new ModDNode(C, a, b)) : new ModFNode(C, a, b);\n+  CallLeafPureNode* mod = type == BasicType::T_DOUBLE ? static_cast<CallLeafPureNode*>(new ModDNode(C, a, b)) : new ModFNode(C, a, b);\n@@ -1476,3 +1476,3 @@\n-  Node* prev_mem = set_predefined_input_for_runtime_call(mod);\n-  mod = _gvn.transform(mod)->as_Call();\n-  set_predefined_output_for_runtime_call(mod, prev_mem, TypeRawPtr::BOTTOM);\n+  set_predefined_input_for_runtime_call(mod);\n+  mod = _gvn.transform(mod)->as_CallLeafPure();\n+  set_predefined_output_for_runtime_call(mod);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2584,0 +2584,9 @@\n+  \/\/ If changed AndI\/AndL inputs, check RShift users for \"(x & mask) >> shift\" optimization opportunity\n+  if (use_op == Op_AndI || use_op == Op_AndL) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2890,0 +2890,1 @@\n+  \"short_running_loop\" JVMCI_ONLY(\"_or_aliasing\"),\n@@ -2891,1 +2892,0 @@\n-  \"aliasing\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    Reason_short_running_long_loop,    \/\/ profile reports loop runs for small number of iterations\n@@ -121,1 +122,1 @@\n-    Reason_aliasing,              \/\/ optimistic assumption about aliasing failed\n+    Reason_aliasing = Reason_short_running_long_loop, \/\/ optimistic assumption about aliasing failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  bool is_injected()              const    { return field_flags().is_injected(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1574,0 +1574,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n@@ -1581,1 +1582,0 @@\n-  NOT_ZERO(JVMCI_ONLY(declare_constant(Deoptimization::Reason_aliasing)))                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+#ifndef JULONG_FORMAT_W\n+#define JULONG_FORMAT_W(width)   UINT64_FORMAT_W(width)\n+#endif\n@@ -785,0 +788,8 @@\n+inline julong max_unsigned_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_juint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_julong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4312,3 +4312,4 @@\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n+     * <li>read write access modes for all {@code T}.  Access modes {@code get}\n+     *     and {@code set} for {@code long} and {@code double} are supported but\n+     *     have no atomicity guarantee, as described in Section {@jls 17.7} of\n+     *     <cite>The Java Language Specification<\/cite>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-        log.mandatoryWarning(pos,\n+        log.warning(pos,\n@@ -188,2 +188,1 @@\n-            log.mandatoryWarning(null,\n-                    LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n+            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-            log.mandatoryWarning(pos, warningKey);\n+            log.warning(pos, warningKey);\n@@ -264,1 +264,1 @@\n-            log.mandatoryWarning(pos, warnKey);\n+            log.warning(pos, warnKey);\n@@ -281,1 +281,1 @@\n-            log.mandatoryWarning(pos, warnKey);\n+            log.warning(pos, warnKey);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1855,1 +1855,1 @@\n-            log.mandatoryNote(null, Notes.CompressedDiags);\n+            log.note(Notes.CompressedDiags);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1679,0 +1679,1 @@\n+# flags: mandatory\n@@ -1926,1 +1927,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -1932,1 +1933,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -1938,1 +1939,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -1949,1 +1950,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -1961,1 +1962,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -1967,1 +1968,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2375,1 +2376,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2381,1 +2382,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2391,1 +2392,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2399,1 +2400,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2405,1 +2406,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -2804,1 +2805,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -3204,1 +3205,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -3211,1 +3212,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -3315,1 +3316,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -3321,1 +3322,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n@@ -3327,0 +3328,1 @@\n+# flags: mandatory\n@@ -4309,1 +4311,1 @@\n-# flags: aggregate\n+# flags: aggregate, mandatory\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-compiler\/debug\/TestStressBailout.java 8361752 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -565,0 +565,1 @@\n+ -runtime\/cds\/appcds\/javaldr\/ExceptionDuringDumpAtObjectsInitPhase.java \\\n@@ -582,0 +583,1 @@\n+ -runtime\/cds\/appcds\/LambdaWithJavaAgent.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n@@ -107,0 +108,1 @@\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n@@ -113,0 +115,1 @@\n+    private static final HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();\n@@ -117,0 +120,7 @@\n+    @Test\n+    public void getMirrorTest() {\n+        for (ResolvedJavaType type : javaTypes) {\n+            assertEquals(type.toClassName(), runtime.getMirror(type).getName());\n+        }\n+    }\n+\n@@ -941,0 +951,3 @@\n+    \/**\n+     * Replicates the semantics of jdk.internal.reflect.Reflection#fieldFilterMap.\n+     *\/\n@@ -977,1 +990,7 @@\n-                    if (field.isInternal() || isHiddenFromReflection(field)) {\n+                    var mirror = runtime.getMirror(field);\n+                    if (field.isInternal()) {\n+                        assertNull(field.toString(), mirror);\n+                        continue;\n+                    }\n+                    assertNotNull(field.toString(), mirror);\n+                    if (isHiddenFromReflection(field)) {\n@@ -1008,0 +1027,2 @@\n+                var mirror = runtime.getMirror(rf);\n+                assertNotNull(rf.toString(), mirror);\n@@ -1031,0 +1052,22 @@\n+            for (ResolvedJavaMethod method : actual) {\n+                assertNotNull(method.toString(), runtime.getMirror(method));\n+            }\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void getDeclaredConstructorsTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Constructor<?>[] raw = c.getDeclaredConstructors();\n+            Set<ResolvedJavaMethod> expected = new HashSet<>();\n+            for (Constructor<?> m : raw) {\n+                ResolvedJavaMethod resolvedMethod = metaAccess.lookupJavaMethod(m);\n+                assertNotNull(resolvedMethod);\n+                expected.add(resolvedMethod);\n+            }\n+            Set<ResolvedJavaMethod> actual = new HashSet<>(Arrays.asList(type.getDeclaredConstructors()));\n+            for (ResolvedJavaMethod method : actual) {\n+                assertNotNull(runtime.getMirror(method));\n+            }\n@@ -1073,0 +1116,1 @@\n+            assertNull(runtime.getMirror(clinit));\n@@ -1244,1 +1288,0 @@\n-        \"getDeclaredConstructors\",\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1720,0 +1720,5 @@\n+    public static final String SHORT_RUNNING_LOOP_TRAP = PREFIX + \"SHORT_RUNNING_LOOP_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(SHORT_RUNNING_LOOP_TRAP, \"short_running_loop\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}