{"files":[{"patch":"@@ -1805,0 +1805,4 @@\n+        \"<b>IsSameObject is a preview API of the Java platform.<\/b> \"\n+        \"<em>Preview features may be removed in a future release, or upgraded to \"\n+        \"permanent features of the Java platform.<\/em>\"\n+        \"<p>\"\n@@ -1806,0 +1810,1 @@\n+        \"<p>Since JDWP version 27.\"\n@@ -1819,0 +1824,4 @@\n+        \"<b>ObjectHashCode is a preview API of the Java platform.<\/b> \"\n+        \"<em>Preview features may be removed in a future release, or upgraded to \"\n+        \"permanent features of the Java platform.<\/em>\"\n+        \"<p>\"\n@@ -1820,0 +1829,1 @@\n+        \"<p>Since JDWP version 27.\"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+        if (!vm.supportsValueClasses()) {\n+            return false;\n+        }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ClassTypeImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            if (isValueObject() && vm.canUseIsSameObject()) {\n+            if (isValueObject()) {\n@@ -177,1 +177,1 @@\n-        if (isValueObject() && vm.canUseIsSameObject()) {\n+        if (isValueObject()) {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ObjectReferenceImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -838,1 +838,1 @@\n-    public boolean canUseIsSameObject() {\n+    public boolean supportsValueClasses() {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,16 +70,16 @@\n-The test reproduces scenarios when ObjectReference for value object is fetched during the object construction\n-and the object content is changed later. When \"this\" ObjectReference for value object is requested,\n-JDI returns existing reference if there are other references to the equal value object or create a new one otherwise.\n-The test debugs \"new Value(3,6)\" statement by setting breakpoints in Value class constructor at locations\n-when the object being constructed is (0,0), (3,0) and (3,6).\n-\n-Test scenarios are defined by test arguments; TestScaffold passes them creating debuggee process (TargetApp class).\n-Debugsee initializes static fields with value objects (0,0), (3,0), (3,6) depending on the passed arguments.\n-Debugger gets ObjectReferences for the fields before testing.\n-\n-Tested scenarios:\n-- no existing references;\n-- all 3 references exists;\n-- there are references for 1 and 3 breakpoints.\n-\n-*\/\n+ * The test reproduces scenarios when ObjectReference for value object is fetched during the object construction\n+ * and the object content is changed later. When \"this\" ObjectReference for value object is requested,\n+ * JDI returns existing reference if there are other references to the equal value object or create a new one otherwise.\n+ * The test debugs \"new Value(3,6)\" statement by setting breakpoints in Value class constructor at locations\n+ * when the object being constructed is (0,0), (3,0) and (3,6).\n+ *\n+ * Test scenarios are defined by test arguments; TestScaffold passes them creating debuggee process (TargetApp class).\n+ * Debugsee initializes static fields with value objects (0,0), (3,0), (3,6) depending on the passed arguments.\n+ * Debugger gets ObjectReferences for the fields before testing.\n+ *\n+ * Tested scenarios:\n+ * - no existing references;\n+ * - all 3 references exists;\n+ * - there are references for 1 and 3 breakpoints.\n+ *\n+ *\/\n@@ -188,1 +188,1 @@\n-        boolean isValueClass = !isIdentity && !isInterface && !isAbstract;\n+        boolean isValueClass = !isIdentity;\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/CtorDebuggingTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"}]}