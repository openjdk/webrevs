{"files":[{"patch":"@@ -1804,0 +1804,37 @@\n+    (Command IsSameObject=11\n+        \"<b>IsSameObject is a preview API of the Java platform.<\/b> \"\n+        \"<em>Preview features may be removed in a future release, or upgraded to \"\n+        \"permanent features of the Java platform.<\/em>\"\n+        \"<p>\"\n+        \"Determines whether two objects refer to the same Java object.\"\n+        \"<p>Since JDWP version 27.\"\n+        (Out\n+            (object object1 \"The object ID\")\n+            (object object2 \"The object ID\")\n+        )\n+        (Reply\n+            (boolean isSameObject \"true if the objects refer to the same Java object; false otherwise\")\n+        )\n+        (ErrorSet\n+            (Error INVALID_OBJECT)\n+            (Error VM_DEAD)\n+        )\n+    )\n+    (Command ObjectHashCode=12\n+        \"<b>ObjectHashCode is a preview API of the Java platform.<\/b> \"\n+        \"<em>Preview features may be removed in a future release, or upgraded to \"\n+        \"permanent features of the Java platform.<\/em>\"\n+        \"<p>\"\n+        \"Returns hash code for an object.\"\n+        \"<p>Since JDWP version 27.\"\n+        (Out\n+            (object object \"The object ID\")\n+        )\n+        (Reply\n+            (int hashCode \"hash code value for the object\")\n+        )\n+        (ErrorSet\n+            (Error INVALID_OBJECT)\n+            (Error VM_DEAD)\n+        )\n+    )\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -134,0 +134,10 @@\n+    public boolean isValueClass() {\n+        if (!vm.supportsValueClasses()) {\n+            return false;\n+        }\n+        if (modifiers == -1) {\n+            getModifiers();\n+        }\n+        return (modifiers & VMModifiers.IDENTITY) == 0;\n+    }\n+\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ClassTypeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -148,0 +148,7 @@\n+    boolean isValueObject() {\n+        if (referenceType() instanceof ClassTypeImpl classType) {\n+            return classType.isValueClass();\n+        }\n+        return false;\n+    }\n+\n@@ -150,4 +157,14 @@\n-            return (ref() == other.ref()) &&\n-                    super.equals(obj);\n-        } else {\n-            return false;\n+            if (!super.equals(obj)) { \/\/ checks if the references belong to the same VM\n+                return false;\n+            }\n+            if (ref() == other.ref()) {\n+                return true;\n+            }\n+            \/\/ We can get equal value objects with different IDs.\n+            if (isValueObject()) {\n+                try {\n+                    return JDWP.ObjectReference.IsSameObject.process(vm, this, other).isSameObject;\n+                } catch (JDWPException exc) {\n+                    throw exc.toJDIException();\n+                }\n+            }\n@@ -155,0 +172,1 @@\n+        return false;\n@@ -159,0 +177,7 @@\n+        if (isValueObject()) {\n+            try {\n+                return JDWP.ObjectReference.ObjectHashCode.process(vm, this).hashCode;\n+            } catch (JDWPException exc) {\n+                throw exc.toJDIException();\n+            }\n+        }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ObjectReferenceImpl.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+    int IDENTITY = 0x0020;          \/* identity (not value) class *\/\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VMModifiers.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -838,0 +838,4 @@\n+    public boolean supportsValueClasses() {\n+        return versionInfo().jdwpMajor >= 27;\n+    }\n+\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,0 +360,57 @@\n+static jboolean\n+isSameObjectImpl(PacketInputStream *in, PacketOutputStream *out)\n+{\n+    jlong id1;\n+    jlong id2;\n+    jobject ref1;\n+    jobject ref2;\n+    JNIEnv *env;\n+\n+    env = getEnv();\n+    id1 = inStream_readObjectID(in);\n+    id2 = inStream_readObjectID(in);\n+    if (inStream_error(in)) {\n+        return JNI_TRUE;\n+    }\n+\n+    if (id1 == NULL_OBJECT_ID || id2 == NULL_OBJECT_ID) {\n+        outStream_setError(out, JDWP_ERROR(INVALID_OBJECT));\n+        return JNI_TRUE;\n+    }\n+\n+    ref1 = commonRef_idToRef(env, id1);\n+    ref2 = commonRef_idToRef(env, id2);\n+    (void)outStream_writeBoolean(out, isSameObject(env, ref1, ref2));\n+\n+    commonRef_idToRef_delete(env, ref1);\n+    commonRef_idToRef_delete(env, ref2);\n+\n+    return JNI_TRUE;\n+}\n+\n+static jboolean\n+objectHashCodeImpl(PacketInputStream *in, PacketOutputStream *out)\n+{\n+    jlong id;\n+    jobject ref;\n+    JNIEnv *env;\n+\n+    env = getEnv();\n+    id = inStream_readObjectID(in);\n+    if (inStream_error(in)) {\n+        return JNI_TRUE;\n+    }\n+\n+    if (id == NULL_OBJECT_ID) {\n+        outStream_setError(out, JDWP_ERROR(INVALID_OBJECT));\n+        return JNI_TRUE;\n+    }\n+\n+    ref = commonRef_idToRef(env, id);\n+    (void)outStream_writeInt(out, objectHashCode(ref));\n+\n+    commonRef_idToRef_delete(env, ref);\n+\n+    return JNI_TRUE;\n+}\n+\n@@ -370,1 +427,3 @@\n-    {referringObjects, \"ReferringObjects\"}\n+    {referringObjects, \"ReferringObjects\"},\n+    {isSameObjectImpl, \"IsSameObject\"},\n+    {objectHashCodeImpl, \"ObjectHashCode\"}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ObjectReferenceImpl.c","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,439 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test value class constructor debugging\n+ * @library ..\n+ * @enablePreview\n+ *\n+ * @comment No other references\n+ * @run main CtorDebuggingTest\n+ *\n+ * @comment All references exist\n+ * @run main CtorDebuggingTest 1 2 3\n+ *\n+ * @comment No reference at step 2\n+ * @run main CtorDebuggingTest 1 3\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import com.sun.jdi.ClassType;\n+import com.sun.jdi.Field;\n+import com.sun.jdi.IncompatibleThreadStateException;\n+import com.sun.jdi.IntegerValue;\n+import com.sun.jdi.Location;\n+import com.sun.jdi.ObjectReference;\n+import com.sun.jdi.ReferenceType;\n+import com.sun.jdi.StackFrame;\n+import com.sun.jdi.ThreadReference;\n+import com.sun.jdi.event.BreakpointEvent;\n+import com.sun.jdi.event.ClassPrepareEvent;\n+import com.sun.jdi.event.Event;\n+import com.sun.jdi.event.EventSet;\n+import com.sun.jdi.event.VMDisconnectEvent;\n+import com.sun.jdi.request.BreakpointRequest;\n+import com.sun.jdi.request.EventRequest;\n+import com.sun.jdi.request.EventRequestManager;\n+\n+\/*\n+ * The test reproduces scenarios when ObjectReference for value object is fetched during the object construction\n+ * and the object content is changed later. When \"this\" ObjectReference for value object is requested,\n+ * JDI returns existing reference if there are other references to the equal value object or create a new one otherwise.\n+ * The test debugs \"new Value(3,6)\" statement by setting breakpoints in Value class constructor at locations\n+ * when the object being constructed is (0,0), (3,0) and (3,6).\n+ *\n+ * Test scenarios are defined by test arguments; TestScaffold passes them creating debuggee process (TargetApp class).\n+ * Debugsee initializes static fields with value objects (0,0), (3,0), (3,6) depending on the passed arguments.\n+ * Debugger gets ObjectReferences for the fields before testing.\n+ *\n+ * Tested scenarios:\n+ * - no existing references;\n+ * - all 3 references exists;\n+ * - there are references for 1 and 3 breakpoints.\n+ *\n+ *\/\n+public class CtorDebuggingTest extends TestScaffold {\n+\n+    static value class Value {\n+        int x;\n+        int y;\n+        Value(int x, int y) {\n+            this.x = x;                 \/\/ @1 breakpoint\n+            this.y = y;                 \/\/ @2 breakpoint\n+            System.out.println(\".\");    \/\/ @3 breakpoint\n+        }\n+    }\n+\n+    static class TargetApp {\n+        public static Value v1;\n+        public static Value v2;\n+        public static Value v3;\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ ensure the class is loaded\n+            Class.forName(Value.class.getName());\n+            List<String> argList = Arrays.asList(args);\n+            if (argList.contains(\"1\")) {\n+                v1 = new Value(0, 0);\n+            }\n+            if (argList.contains(\"2\")) {\n+                v2 = new Value(3, 0);\n+            }\n+            if (argList.contains(\"3\")) {\n+                v3 = new Value(3, 6);\n+            }\n+            System.out.println(\">>main\"); \/\/ @prepared breakpoint\n+            Value v = new Value(3, 6);\n+            System.out.println(\"<<main\"); \/\/ @done breakpoint\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        new CtorDebuggingTest(args).startTests();\n+    }\n+\n+    Field xField;\n+    Field yField;\n+\n+    CtorDebuggingTest(String args[]) {\n+        super(args);\n+    }\n+\n+    ObjectReference getStaticFieldObject(ReferenceType cls, String fieldName) throws Exception {\n+        Field field = cls.fieldByName(fieldName);\n+        ObjectReference result = (ObjectReference)cls.getValue(field);\n+        System.out.println(fieldName + \" static field: \" + valueString(result));\n+        return result;\n+    }\n+\n+    ObjectReference getThisObject(BreakpointEvent bkptEvent) {\n+        try {\n+            return bkptEvent.thread().frame(0).thisObject();\n+        } catch (IncompatibleThreadStateException ex) {\n+            throw new RuntimeException(\"Cannot get 'this' object\", ex);\n+        }\n+    }\n+\n+    String valueString(ObjectReference obj) {\n+        if (obj == null) {\n+            return \"null\";\n+        }\n+        IntegerValue ix = (IntegerValue)obj.getValue(xField);\n+        IntegerValue iy = (IntegerValue)obj.getValue(yField);\n+        return obj + \" (\" + \"x: \" + ix + \", y: \" + iy + \")\";\n+    }\n+\n+    void assertEquals(Object obj1, Object obj2) {\n+        if (!Objects.equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Must be equal: \" + obj1 + \" and \" + obj2);\n+        }\n+        \/\/ Sanity check that equal objects has equal hashCode.\n+        if (obj1 != null) {\n+            if (obj1.hashCode() != obj2.hashCode()) {\n+                throw new RuntimeException(\"Equal objects have different hashCode: \"\n+                                           + obj1.hashCode() + \" and \" + obj2.hashCode());\n+            }\n+        }\n+    }\n+\n+    void assertNotEquals(Object obj1, Object obj2) {\n+        if (Objects.equals(obj1, obj2)) {\n+            throw new RuntimeException(\"Must be different: \" + obj1 + \" and \" + obj2);\n+        }\n+    }\n+\n+    \/\/ Sanity testing for value object detection logic.\n+    void verifyClassIsValueClass(ClassType theClass, boolean expected) {\n+        \/\/ VM constants\n+        final int IDENTITY = 0x0020;\n+        final int INTERFACE = 0x00000200;\n+        final int ABSTRACT = 0x00000400;\n+\n+        int modifiers = theClass.modifiers();\n+        boolean isIdentity = (modifiers & IDENTITY) != 0;\n+        boolean isInterface = (modifiers & INTERFACE) != 0;\n+        boolean isAbstract = (modifiers & ABSTRACT) != 0;\n+        boolean isValueClass = !isIdentity;\n+        System.out.println(\"Class \" + theClass + \" is value class: \" + (isValueClass ? \"YES\" : \"NO\"));\n+        if (isValueClass != expected) {\n+            throw new RuntimeException(\"IsValueClass verification failed: \"\n+                                     + \" \" + isValueClass + \", expected: \" + expected\n+                                     + \" (isIdentity: \" + isIdentity\n+                                     + \" (isInterface: \" + isInterface\n+                                     + \" (isAbstract: \" + isAbstract + \")\");\n+        }\n+    }\n+\n+    \/\/ Parses the specified source file for \"@{id} breakpoint\" tags and returns <id, line_number> map.\n+    \/\/ Example:\n+    \/\/   System.out.println(\"BP is here\");  \/\/ @my_breakpoint breakpoint\n+    public static Map<String, Integer> parseBreakpoints(String filePath) {\n+        return parseTags(\"breakpoint\", filePath);\n+    }\n+\n+    public static Map<String, Integer> parseTags(String tag, String filePath) {\n+        final String regexp = \"\\\\@(.*?) \" + tag;\n+        Pattern pattern = Pattern.compile(regexp);\n+        int lineNum = 1;\n+        Map<String, Integer> result = new HashMap<>();\n+        try {\n+            for (String line: Files.readAllLines(Paths.get(filePath))) {\n+                Matcher matcher = pattern.matcher(line);\n+                if (matcher.find()) {\n+                    result.put(matcher.group(1), lineNum);\n+                }\n+                lineNum++;\n+            }\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"failed to parse \" + filePath, ex);\n+        }\n+        return result;\n+    }\n+\n+    public static String getTestSourcePath(String fileName) {\n+        return Paths.get(System.getProperty(\"test.src\")).resolve(fileName).toString();\n+    }\n+\n+    public static String getThisTestFile() {\n+        return System.getProperty(\"test.file\");\n+    }\n+\n+    \/\/ TestScaffold is not very good in handling multiple breakpoints.\n+    \/\/ This helper class is a listener which resumes debuggee after breakpoints.\n+    class MultiBreakpointHandler extends TargetAdapter {\n+        boolean needToResume = false;\n+        \/\/ the map stores \"this\" in all breakpoints\n+        Map<BreakpointRequest, ObjectReference> thisObjects = new HashMap<>();\n+\n+        @Override\n+        public void eventSetComplete(EventSet set) {\n+            if (needToResume) {\n+                set.resume();\n+                needToResume = false;\n+            }\n+        }\n+\n+        BreakpointRequest addBreakpoint(Location loc, ObjectReference filterObject) {\n+            final BreakpointRequest request = eventRequestManager().createBreakpointRequest(loc);\n+            if (filterObject != null) {\n+                request.addInstanceFilter(filterObject);\n+            }\n+            request.enable();\n+\n+            TargetAdapter adapter = new TargetAdapter() {\n+                @Override\n+                public void breakpointReached(BreakpointEvent event) {\n+                    if (request.equals(event.request())) {\n+                        ObjectReference thisObject = getThisObject(event);\n+                        System.out.println(\"BreakpointEvent: \" + event\n+                                           + \" (instanceFilter: \" + valueString(filterObject) + \")\"\n+                                           + \", this = \" + valueString(thisObject));\n+                        thisObjects.put((BreakpointRequest)event.request(), thisObject);\n+                        needToResume = true;\n+                        removeThisListener();\n+                    }\n+                }\n+            };\n+\n+            addListener(adapter);\n+\n+            System.out.println(\"Breakpoint added: \" + loc\n+                               + \" (instanceFilter: \" + valueString(filterObject) + \")\");\n+\n+            return request;\n+        }\n+\n+        \/\/ Resumes the debuggee and goes through all breackpoints until the location specified is reached.\n+        void resumeTo(Location loc) {\n+            final BreakpointRequest request = eventRequestManager().createBreakpointRequest(loc);\n+            request.enable();\n+\n+            class EventNotification {\n+                boolean completed = false;\n+                boolean disconnected = false;\n+            }\n+            final EventNotification en = new EventNotification();\n+\n+            TargetAdapter adapter = new TargetAdapter() {\n+                public void eventReceived(Event event) {\n+                    if (request.equals(event.request())) {\n+                        synchronized (en) {\n+                            en.completed = true;\n+                            en.notifyAll();\n+                        }\n+                        removeThisListener();\n+                    } else if (event instanceof VMDisconnectEvent) {\n+                        synchronized (en) {\n+                            en.disconnected = true;\n+                            en.notifyAll();\n+                        }\n+                        removeThisListener();\n+                    }\n+                }\n+            };\n+\n+            addListener(adapter);\n+            \/\/ this must be the last listener (as it resumes the debuggee)\n+            addListener(this);\n+\n+            try {\n+                synchronized (en) {\n+                    vm().resume();\n+                    while (!en.completed && !en.disconnected) {\n+                        en.wait();\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+\n+            removeListener(this);\n+\n+            if (en.disconnected) {\n+                throw new RuntimeException(\"VM Disconnected before requested event occurred\");\n+            }\n+        }\n+\n+        \/\/ check if the breakpoint was hit.\n+        boolean breakpointHit(BreakpointRequest bkpt) {\n+            return thisObjects.containsKey(bkpt);\n+        }\n+\n+        ObjectReference thisAtBreakpoint(BreakpointRequest bkpt) {\n+            return thisObjects.get(bkpt);\n+        }\n+    }\n+\n+    @Override\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startToMain(TargetApp.class.getName());\n+        ClassType targetClass = (ClassType)bpe.location().declaringType();\n+\n+        Map<String, Integer> breakpoints = parseBreakpoints(getThisTestFile());\n+        System.out.println(\"breakpoints:\");\n+        for (var entry : breakpoints.entrySet()) {\n+            System.out.println(\"  tag \" + entry.getKey() + \", line \" + entry.getValue());\n+        }\n+\n+        Location locPrepared = findLocation(targetClass, breakpoints.get(\"prepared\"));\n+        Location locDone = findLocation(targetClass, breakpoints.get(\"done\"));\n+\n+        resumeTo(locPrepared);\n+        System.out.println(\"PREPARED\");\n+\n+        ClassType valueClass = (ClassType)findReferenceType(Value.class.getName());\n+        System.out.println(Value.class.getName() + \": \" + valueClass);\n+        xField = valueClass.fieldByName(\"x\");\n+        yField = valueClass.fieldByName(\"y\");\n+\n+        verifyClassIsValueClass(valueClass, true);\n+        verifyClassIsValueClass(targetClass, false);\n+\n+        \/\/ Get references for pre-created objects created by debuggee.\n+        ObjectReference v1 = getStaticFieldObject(targetClass, \"v1\");\n+        ObjectReference v2 = getStaticFieldObject(targetClass, \"v2\");\n+        ObjectReference v3 = getStaticFieldObject(targetClass, \"v3\");\n+\n+        MultiBreakpointHandler breakpointHandler = new MultiBreakpointHandler();\n+\n+        \/\/ Breakpoints for location when \"this\" is (0,0).\n+        Location loc1 = findLocation(valueClass, breakpoints.get(\"1\"));\n+        BreakpointRequest bkpt1 = breakpointHandler.addBreakpoint(loc1, null);\n+        BreakpointRequest bkpt1_v1 = v1 == null ? null : breakpointHandler.addBreakpoint(loc1, v1);\n+        BreakpointRequest bkpt1_v2 = v2 == null ? null : breakpointHandler.addBreakpoint(loc1, v2);\n+        BreakpointRequest bkpt1_v3 = v3 == null ? null : breakpointHandler.addBreakpoint(loc1, v3);\n+\n+        \/\/ Breakpoints for location when \"this\" is (3,0).\n+        Location loc2 = findLocation(valueClass, breakpoints.get(\"2\"));\n+        BreakpointRequest bkpt2 = breakpointHandler.addBreakpoint(loc2, null);\n+        BreakpointRequest bkpt2_v1 = v1 == null ? null : breakpointHandler.addBreakpoint(loc2, v1);\n+        BreakpointRequest bkpt2_v2 = v2 == null ? null : breakpointHandler.addBreakpoint(loc2, v2);\n+        BreakpointRequest bkpt2_v3 = v3 == null ? null : breakpointHandler.addBreakpoint(loc2, v3);\n+\n+        \/\/ Breakpoints for location when \"this\" is (3,6).\n+        Location loc3 = findLocation(valueClass, breakpoints.get(\"3\"));\n+        BreakpointRequest bkpt3 = breakpointHandler.addBreakpoint(loc3, null);\n+        BreakpointRequest bkpt3_v1 = v1 == null ? null : breakpointHandler.addBreakpoint(loc3, v1);\n+        BreakpointRequest bkpt3_v2 = v2 == null ? null : breakpointHandler.addBreakpoint(loc3, v2);\n+        BreakpointRequest bkpt3_v3 = v3 == null ? null : breakpointHandler.addBreakpoint(loc3, v3);\n+\n+        \/\/ Go through all breakpoints.\n+        breakpointHandler.resumeTo(locDone);\n+\n+        System.out.println(\"DONE\");\n+\n+        \/\/ Analyze gathered data depending on the testcase.\n+        if (v1 == null && v2 == null && v3 == null) {\n+            \/\/ No other references.\n+            \/\/ ObjectID is generated at the 1st breakpoint (reference to heap object being constructed),\n+            \/\/ and later we get the same oop (although it's content is changing).\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1), breakpointHandler.thisAtBreakpoint(bkpt2));\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt2), breakpointHandler.thisAtBreakpoint(bkpt3));\n+            \/\/ There is no breakpoints with instance filter.\n+        } else if (v1 != null && v2 != null && v3 != null) {\n+            \/\/ Existing references to value objects with the same content as the object being constructed.\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1), v1);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1_v1), v1);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1_v2), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1_v3), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt2), v2);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt2_v1), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt2_v2), v2);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt2_v3), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3), v3);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3_v1), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3_v2), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3_v3), v3);\n+        } else if (v1 != null && v2 == null && v3 != null) {\n+            \/\/ At 2nd breakpoint new ObjectID is generated.\n+            ObjectReference thisAt2 = breakpointHandler.thisAtBreakpoint(bkpt2);\n+            assertNotEquals(thisAt2, null);\n+            assertNotEquals(thisAt2, v1);\n+            \/\/ Now thisAt2 has the same content as v3.\n+            assertEquals(thisAt2, v3);\n+            \/\/ At breakpoint 1 this == v1.\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1), v1);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1_v1), v1);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt1_v3), null);\n+            \/\/ At breakpoint 3 this == v3.\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3), v3);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3_v1), null);\n+            assertEquals(breakpointHandler.thisAtBreakpoint(bkpt3_v3), v3);\n+        } else {\n+            throw new RuntimeException(\"Unknown test case\");\n+        }\n+\n+        resumeToVMDisconnect();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/CtorDebuggingTest.java","additions":439,"deletions":0,"binary":false,"changes":439,"status":"added"}]}