{"files":[{"patch":"@@ -245,0 +245,1 @@\n+    \/\/ TODO 8284443 Use different heuristic to decide what should be scalarized in the calling convention\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1107,0 +1107,3 @@\n+private:\n+  bool _null_free;\n+\n@@ -1119,0 +1122,1 @@\n+    _null_free = false;\n@@ -1120,0 +1124,1 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -1138,0 +1143,3 @@\n+\n+  void set_null_free() { _null_free = true; }\n+  bool is_null_free() const { return _null_free; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -705,1 +705,1 @@\n-  Node* null_check_receiver_before_call(ciMethod* callee, bool replace_value = true) {\n+  Node* null_check_receiver_before_call(ciMethod* callee) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    \/\/ of the same type but with different scalarization depth during IGVN. To avoid inconsistencies\n+    \/\/ of the same type but with different scalarization depth during GVN. To avoid inconsistencies\n@@ -76,1 +76,1 @@\n-    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flat(i);\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || field_is_flat(i);\n@@ -388,3 +388,3 @@\n-\/\/ We limit scalarization for inline types with circular fields and can therefore observe\n-\/\/ nodes of same type but with different scalarization depth during GVN. This method adjusts\n-\/\/ the scalarization depth to avoid inconsistencies during merging.\n+\/\/ We limit scalarization for inline types with circular fields and can therefore observe nodes\n+\/\/ of the same type but with different scalarization depth during GVN. This method adjusts the\n+\/\/ scalarization depth to avoid inconsistencies during merging.\n@@ -1156,0 +1156,3 @@\n+          \/\/ We limit scalarization for inline types with circular fields and can therefore observe nodes\n+          \/\/ of the same type but with different scalarization depth during GVN. To avoid inconsistencies\n+          \/\/ during merging, make sure that we only create Phis for fields that are guaranteed to be scalarized.\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4425,2 +4425,0 @@\n-  \/\/ TODO 8325106\n-  \/\/ Improve this and add required runtime checks\n@@ -4441,0 +4439,2 @@\n+          AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj);\n+          alloc->set_null_free();\n@@ -5580,6 +5580,0 @@\n-        \/\/ TODO 8325106\n-        \/\/ TestArrays::test94 hits an assert because we create a wrong JVMState for before the newNullRestrictedArray intrinsic because above code does not account for the class argument on stack in addition to the size\n-        \/\/ See https:\/\/github.com\/openjdk\/jdk\/commit\/5a478ef7759e64da6d17426673700ff0d9c66b33\n-        \/\/ Check why this isn't optimized for Array.newInstance(MyValue.class, 10);\n-        \/\/ Re-enable IR matching in TestArrays::test29 and TestNullableArrays::test29 and deopt checks in TestArrayCopyNoInitDeopt\n-        return nullptr;\n@@ -5611,0 +5605,11 @@\n+  int adjustment = 1;\n+  if (alloc->is_null_free()) {\n+    \/\/ A null-free, tightly coupled array allocation can only come from LibraryCallKit::inline_newNullRestrictedArray\n+    \/\/ which requires both the component type and the array length on stack for re-execution. Re-create and push\n+    \/\/ the component type.\n+    ciArrayKlass* klass = alloc->in(AllocateNode::KlassNode)->bottom_type()->is_aryklassptr()->exact_klass()->as_array_klass();\n+    ciInstance* instance = klass->component_mirror_instance();\n+    const TypeInstPtr* t_instance = TypeInstPtr::make(instance);\n+    sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), makecon(t_instance));\n+    adjustment++;\n+  }\n@@ -5612,5 +5617,5 @@\n-  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n-  old_jvms->set_sp(old_jvms->sp()+1);\n-  old_jvms->set_monoff(old_jvms->monoff()+1);\n-  old_jvms->set_scloff(old_jvms->scloff()+1);\n-  old_jvms->set_endoff(old_jvms->endoff()+1);\n+  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp() + adjustment - 1, alloc->in(AllocateNode::ALength));\n+  old_jvms->set_sp(old_jvms->sp() + adjustment);\n+  old_jvms->set_monoff(old_jvms->monoff() + adjustment);\n+  old_jvms->set_scloff(old_jvms->scloff() + adjustment);\n+  old_jvms->set_endoff(old_jvms->endoff() + adjustment);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1217,1 +1217,1 @@\n-    kit.null_check_receiver_before_call(method(), false);\n+    kit.null_check_receiver_before_call(method());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,2 +114,1 @@\n-                \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n-                \/\/ throw new RuntimeException(\"m1 not deoptimized\");\n+                throw new RuntimeException(\"m1 not deoptimized\");\n@@ -145,2 +144,1 @@\n-                    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n-                    \/\/ throw new RuntimeException(\"m2 not deoptimized\");\n+                    throw new RuntimeException(\"m2 not deoptimized\");\n@@ -157,2 +155,1 @@\n-                    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n-                    \/\/ throw new RuntimeException(\"m2 not deoptimized\");\n+                    throw new RuntimeException(\"m2 not deoptimized\");\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInitDeopt.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -767,2 +767,0 @@\n-    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n-    \/*\n@@ -773,1 +771,0 @@\n-    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1650,0 +1650,24 @@\n+\n+    \/\/ Test that LibraryCallKit::arraycopy_move_allocation_here works as expected\n+    @Test\n+    public MyValue1 test83(Object[] src) {\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            Asserts.assertEQ(test83(src), src[0]);\n+        } else {\n+            \/\/ Trigger deoptimization to verify that re-execution works\n+            try {\n+                test83(new Integer[10]);\n+                throw new RuntimeException(\"No NullPointerException thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -904,2 +904,1 @@\n-    \/\/ TODO 8325106 Currently disabled in LibraryCallKit::arraycopy_restore_alloc_state\n-    \/\/@IR(failOn = {ALLOCA, LOOP, TRAP})\n+    @IR(failOn = {ALLOCA, LOOP, TRAP})\n@@ -2822,1 +2821,1 @@\n-    \/\/ TODO 8325106 Fails with \"matching stack sizes\" in Scenario 5 with -XX:TypeProfileLevel=222\n+    \/\/ TODO 8325632 Fails with \"matching stack sizes\" in Scenario 5 with -XX:TypeProfileLevel=222\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2809,2 +2809,0 @@\n-    \/\/ TODO 8325106 fix assert in InlineTypeNode::merge_with\n-\/*\n@@ -2824,1 +2822,1 @@\n-*\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}