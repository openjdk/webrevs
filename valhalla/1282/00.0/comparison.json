{"files":[{"patch":"@@ -80,6 +80,6 @@\n-       $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n-         $(subst \/share\/classes,, \\\n-            $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n-         ) \\\n-       ), \\\n-       .properties \\\n+        $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n+            $(subst \/share\/classes,, \\\n+                $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n+            ) \\\n+        ), \\\n+        .properties \\\n","filename":"make\/CompileJavaModules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  ifneq ($$($1_GROUPS),)\n+  ifneq ($$($1_GROUPS), )\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,2 +138,2 @@\n-  $1_$2_$3_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,) $(if $(filter _valhalla, $3),--enable-preview,)\n-  $1_$2_$3_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)$(if $(filter _valhalla, $3),-VALHALLA,)\n+  $1_$2_$3_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2), -XX:-UseCompressedOops,) $(if $(filter _valhalla, $3), --enable-preview,)\n+  $1_$2_$3_DUMP_TYPE      := $(if $(filter _nocoops, $2), -NOCOOPS,)$(if $(filter _valhalla, $3), -VALHALLA,)\n@@ -142,1 +142,1 @@\n-  $1_$2_$3_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)),-XX:+UseG1GC)\n+  $1_$2_$3_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)), -XX:+UseG1GC)\n@@ -241,1 +241,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_GCOV_GCNO, \\\n+  $(eval $(call SetupCopyFiles, COPY_GCOV_GCNO, \\\n","filename":"make\/Images.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -1417,1 +1417,1 @@\n-\t$(if $(filter $(CONF_NAME),$(notdir $(OUTPUTDIR))), \\\n+\t$(if $(filter $(CONF_NAME), $(notdir $(OUTPUTDIR))), \\\n","filename":"make\/Main.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-###############################################################################\n+################################################################################\n@@ -44,1 +44,1 @@\n-###############################################################################\n+################################################################################\n@@ -108,1 +108,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/hotspot.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,2 +196,2 @@\n-\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -210,2 +210,2 @@\n-\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -240,1 +240,1 @@\n-                 $(call FindDepsForModule, $n))))\n+                $(call FindDepsForModule, $n))))\n@@ -259,1 +259,1 @@\n-                 $(call FindIndirectExportsForModule, $n))))\n+                $(call FindIndirectExportsForModule, $n))))\n","filename":"make\/common\/Modules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,1 +72,2 @@\n-    # Override the default -g with a more liberal strip policy for the minimal JVM\n+    # Override the default -g with a more liberal strip policy for the\n+    # minimal JVM\n@@ -83,5 +84,8 @@\n-  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp jvmtiExtensions.cpp \\\n-      jvmtiImpl.cpp jvmtiManageCapabilities.cpp jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp \\\n-      jvmtiCodeBlobEvents.cpp jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp jvmtiEnvThreadState.cpp \\\n-      jvmtiTagMap.cpp jvmtiEventController.cpp evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n+  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp \\\n+      jvmtiExtensions.cpp jvmtiImpl.cpp jvmtiManageCapabilities.cpp \\\n+      jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp jvmtiCodeBlobEvents.cpp \\\n+      jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp \\\n+      jvmtiEnvThreadState.cpp jvmtiTagMap.cpp jvmtiEventController.cpp \\\n+      evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp \\\n+      jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n@@ -169,2 +173,4 @@\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto -fuse-linker-plugin -fno-strict-aliasing\n+    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n+        -fno-fat-lto-objects\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n+        -fuse-linker-plugin -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    EXCLUDE_FILES:= _the.BUILD_JDK_MICROBENCHMARK_batch \\\n+    EXCLUDE_FILES := _the.BUILD_JDK_MICROBENCHMARK_batch \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -66,1 +67,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -69,1 +71,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n+    #\n@@ -73,1 +76,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi \\\n+    #\n@@ -77,1 +81,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -82,1 +87,2 @@\n-    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\n+    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti \\\n+    #\n@@ -86,1 +92,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks \\\n+    #\n@@ -93,1 +100,2 @@\n-    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share\n+    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share \\\n+    #\n@@ -97,1 +105,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -102,1 +111,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -107,1 +117,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -111,1 +122,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -114,1 +126,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni \\\n+    #\n@@ -120,1 +133,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common \\\n+    #\n@@ -127,1 +141,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod \\\n+    #\n@@ -132,1 +147,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -143,1 +159,1 @@\n-JVMTI_COMMON_INCLUDES=-I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+JVMTI_COMMON_INCLUDES = -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n@@ -766,1 +782,1 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 :=$(NSK_JVMTI_AGENT_INCLUDES)\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1564,1 +1580,1 @@\n-$(eval $(call SetupCopyFiles,COPY_HOTSPOT_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_HOTSPOT_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2329,1 +2329,1 @@\n-  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n+  int size = MIN2((UseSVE > 0) ? (int)FloatRegister::sve_vl_max : (int)FloatRegister::neon_vl, (int)MaxVectorSize);\n@@ -2368,1 +2368,1 @@\n-  if (UseSVE > 0 && 16 < len && len <= 256) {\n+  if (UseSVE > 0 && FloatRegister::neon_vl < len && len <= FloatRegister::sve_vl_max) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-    ldrw(hdr, Address(hdr, Klass::access_flags_offset()));\n-    tstw(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n+    tst(hdr, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -894,2 +894,2 @@\n-        __ ldrw(t, Address(t, Klass::access_flags_offset()));\n-        __ tbnz(t, exact_log2(JVM_ACC_HAS_FINALIZER), register_finalizer);\n+        __ ldrb(t, Address(t, Klass::misc_flags_offset()));\n+        __ tbnz(t, exact_log2(KlassFlags::_misc_has_finalizer), register_finalizer);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+    tst(tmp, KlassFlags::_misc_is_value_based_class);\n@@ -274,2 +274,2 @@\n-    ldrw(t1, Address(t1, Klass::access_flags_offset()));\n-    tstw(t1, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(t1, Address(t1, Klass::misc_flags_offset()));\n+    tst(t1, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -793,2 +793,2 @@\n-      ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+      tst(tmp, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7229,0 +7229,3 @@\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n@@ -7230,1 +7233,0 @@\n-  if (!UseSVE) return;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2323,1 +2323,1 @@\n-    __ ldrw(r3, Address(r3, Klass::access_flags_offset()));\n+    __ ldrb(r3, Address(r3, Klass::misc_flags_offset()));\n@@ -2325,1 +2325,1 @@\n-    __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);\n+    __ tbz(r3, exact_log2(KlassFlags::_misc_has_finalizer), skip_register_finalizer);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -973,2 +973,2 @@\n-      lwz(tmp, in_bytes(Klass::access_flags_offset()), tmp);\n-      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+      lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n+      testbitdi(CCR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-    movl(hdr, Address(hdr, Klass::access_flags_offset()));\n-    testl(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(hdr, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,2 +1269,1 @@\n-        __ movl(t, Address(t, Klass::access_flags_offset()));\n-        __ testl(t, JVM_ACC_HAS_FINALIZER);\n+        __ testb(Address(t, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -305,2 +305,1 @@\n-    movl(tmpReg, Address(tmpReg, Klass::access_flags_offset()));\n-    testl(tmpReg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(tmpReg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -629,2 +628,1 @@\n-    movl(rax_reg, Address(rax_reg, Klass::access_flags_offset()));\n-    testl(rax_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(rax_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1327,2 +1327,1 @@\n-      movl(tmp_reg, Address(tmp_reg, Klass::access_flags_offset()));\n-      testl(tmp_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      testb(Address(tmp_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2703,2 +2703,1 @@\n-    __ movl(rdi, Address(rdi, Klass::access_flags_offset()));\n-    __ testl(rdi, JVM_ACC_HAS_FINALIZER);\n+    __ testb(Address(rdi, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6429,1 +6429,1 @@\n-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)\n@@ -6467,1 +6467,1 @@\n-instruct cmovL_imm_01U(rRegL dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+instruct cmovL_imm_01U(rRegL dst, immL1 src, rFlagsRegU cr, cmpOpU cop)\n@@ -6493,1 +6493,1 @@\n-instruct cmovL_imm_01UCF(rRegL dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+instruct cmovL_imm_01UCF(rRegL dst, immL1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1493,0 +1493,5 @@\n+  if (next_bci() >= method()->code_size()) {\n+    \/\/ This can happen if the subroutine does not terminate with a ret,\n+    \/\/ effectively turning the jsr into a goto.\n+    BAILOUT(\"too-complicated jsr\/ret structure\");\n+  }\n@@ -4012,0 +4017,3 @@\n+  if (next_bci() >= method()->code_size()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, len, \/*version_leq_47*\/false)) {\n@@ -856,1 +856,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-  st->print_cr(\"- narrow_oop_base:                \" INTPTR_FORMAT, p2i(_narrow_oop_base));\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1654,24 +1654,0 @@\n-#ifndef PRODUCT\n-ResourceBitMap HeapShared::calculate_oopmap(MemRegion region) {\n-  size_t num_bits = region.byte_size() \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n-  ResourceBitMap oopmap(num_bits);\n-\n-  HeapWord* p   = region.start();\n-  HeapWord* end = region.end();\n-  FindEmbeddedNonNullPointers finder((void*)p, &oopmap);\n-\n-  int num_objs = 0;\n-  while (p < end) {\n-    oop o = cast_to_oop(p);\n-    o->oop_iterate(&finder);\n-    p += o->size();\n-    ++ num_objs;\n-  }\n-\n-  log_info(cds, heap)(\"calculate_oopmap: objects = %6d, oop fields = %7d (nulls = %7d)\",\n-                      num_objs, finder.num_total_oops(), finder.num_null_oops());\n-  return oopmap;\n-}\n-\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  _has_finalizer = access_flags.has_finalizer();\n+  _has_finalizer = ik->has_finalizer();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,0 +238,9 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::misc_flags\n+klass_flags_t ciKlass::misc_flags() {\n+  assert(is_loaded(), \"not loaded\");\n+  GUARDED_VM_ENTRY(\n+    return get_Klass()->misc_flags();\n+  )\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,3 @@\n+  \/\/ Fetch Klass::misc_flags.\n+  klass_flags_t          misc_flags();\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4830,1 +4830,2 @@\n-  if (!UTF8::is_legal_utf8(buffer, length, _major_version <= 47)) {\n+  \/\/ Note: 0 <= length < 64K, as it comes from a u2 entry in the CP.\n+  if (!UTF8::is_legal_utf8(buffer, static_cast<size_t>(length), _major_version <= 47)) {\n@@ -5483,3 +5484,1 @@\n-  if (_is_hidden) {\n-    ik->set_is_hidden();\n-  }\n+  assert(!_is_hidden || ik->is_hidden(), \"must be set already\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -309,1 +309,2 @@\n-    char* expected = UNICODE::as_utf8(unicode, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    char* expected = UNICODE::as_utf8(unicode, utf8_len);\n@@ -351,1 +352,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n@@ -559,1 +560,1 @@\n-  int result_length;\n+  size_t result_length;\n@@ -571,2 +572,2 @@\n-  assert(result_length >= length + 1, \"must not be shorter\");\n-  assert(result_length == (int)strlen(result) + 1, \"must match\");\n+  assert(result_length >= (size_t)length + 1, \"must not be shorter\");\n+  assert(result_length == strlen(result) + 1, \"must match\");\n@@ -587,2 +588,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    Symbol* sym = SymbolTable::new_symbol(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    Symbol* sym = SymbolTable::new_symbol(base, checked_cast<int>(utf8_len));\n@@ -603,2 +605,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    return SymbolTable::probe(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    return SymbolTable::probe(base, checked_cast<int>(utf8_len));\n@@ -608,1 +611,1 @@\n-int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n+size_t java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n@@ -622,1 +625,1 @@\n-int java_lang_String::utf8_length(oop java_string) {\n+size_t java_lang_String::utf8_length(oop java_string) {\n@@ -627,0 +630,19 @@\n+int java_lang_String::utf8_length_as_int(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  return utf8_length_as_int(java_string, value);\n+}\n+\n+int java_lang_String::utf8_length_as_int(oop java_string, typeArrayOop value) {\n+  assert(value_equals(value, java_lang_String::value(java_string)),\n+         \"value must be same as java_lang_String::value(java_string)\");\n+  int length = java_lang_String::length(java_string, value);\n+  if (length == 0) {\n+    return 0;\n+  }\n+  if (!java_lang_String::is_latin1(java_string)) {\n+    return UNICODE::utf8_length_as_int(value->char_at_addr(0), length);\n+  } else {\n+    return UNICODE::utf8_length_as_int(value->byte_at_addr(0), length);\n+  }\n+}\n+\n@@ -628,1 +650,1 @@\n-  int length;\n+  size_t length;\n@@ -632,1 +654,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+char* java_lang_String::as_utf8_string(oop java_string, size_t& length) {\n@@ -634,0 +656,2 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n@@ -647,1 +671,1 @@\n-char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& utf8_len) {\n@@ -668,1 +692,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen) {\n@@ -682,1 +706,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, char* buf, size_t buflen) {\n@@ -688,0 +712,3 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n+  size_t  length = static_cast<size_t>(len);\n@@ -693,1 +720,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -696,1 +723,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -700,1 +727,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -134,2 +134,5 @@\n-  static int utf8_length(oop java_string);\n-  static int utf8_length(oop java_string, typeArrayOop string_value);\n+  static size_t utf8_length(oop java_string);\n+  static size_t utf8_length(oop java_string, typeArrayOop string_value);\n+  \/\/ Legacy variants that truncate the length if needed\n+  static int    utf8_length_as_int(oop java_string);\n+  static int    utf8_length_as_int(oop java_string, typeArrayOop string_value);\n@@ -139,3 +142,4 @@\n-  static char*  as_utf8_string(oop java_string, int& length);\n-  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n-  static char*  as_utf8_string(oop java_string, char* buf, int buflen);\n+  \/\/ `length` is set to the length of the utf8 sequence.\n+  static char*  as_utf8_string(oop java_string, size_t& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& length);\n+  static char*  as_utf8_string(oop java_string, char* buf, size_t buflen);\n@@ -143,2 +147,2 @@\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -291,2 +291,1 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n-                             static_cast<int>(name_len), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, name_len, false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-  _type       = (DepType)(end_marker-1);  \/\/ defeat \"already at end\" assert\n+  _type       = undefined_dependency;  \/\/ defeat \"already at end\" assert\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n@@ -235,0 +238,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -46,0 +48,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -52,0 +55,1 @@\n+PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n@@ -66,0 +70,4 @@\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator\n+    = new PartialArrayStateAllocator(ParallelGCThreads);\n+\n@@ -71,0 +79,1 @@\n+    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -128,0 +137,4 @@\n+  \/\/ All PartialArrayStates have been returned to the allocator, since the\n+  \/\/ claimed_stack_depths are all empty.  Leave them there for use by future\n+  \/\/ collections.\n+\n@@ -176,1 +189,4 @@\n-PSPromotionManager::PSPromotionManager() {\n+\/\/ Most members are initialized either by initialize() or reset().\n+PSPromotionManager::PSPromotionManager()\n+  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+{\n@@ -186,1 +202,3 @@\n-  _array_chunk_size = ParGCArrayScanChunk;\n+  \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n@@ -188,1 +206,1 @@\n-  _min_array_size_for_chunking = 3 * _array_chunk_size \/ 2;\n+  _min_array_size_for_chunking = (3 * ParGCArrayScanChunk \/ 2);\n@@ -281,7 +299,1 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n-  assert(PSChunkLargeArrays, \"invariant\");\n-\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n@@ -290,11 +302,15 @@\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  if (UseCompressedOops) {\n+    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n@@ -302,4 +318,1 @@\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n+    process_array_chunk_work<oop>(state->destination(), start, end);\n@@ -307,0 +320,3 @@\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n@@ -308,0 +324,22 @@\n+void PSPromotionManager::push_objArray(oop old_obj, oop new_obj) {\n+  assert(old_obj->is_objArray(), \"precondition\");\n+  assert(old_obj->is_forwarded(), \"precondition\");\n+  assert(old_obj->forwardee() == new_obj, \"precondition\");\n+  assert(new_obj->is_objArray(), \"precondition\");\n+\n+  size_t array_length = objArrayOop(new_obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                               old_obj, new_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n@@ -309,1 +347,1 @@\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n@@ -311,1 +349,1 @@\n-    process_array_chunk_work<oop>(obj, start, end);\n+    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -186,0 +186,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsStaticallyLinked(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+  nonstatic_field(Klass,                       _misc_flags._flags,                            u1)                                    \\\n@@ -485,4 +486,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n-  declare_constant(JVM_ACC_IS_HIDDEN_CLASS)                               \\\n-  declare_constant(JVM_ACC_IS_VALUE_BASED_CLASS)                          \\\n@@ -739,0 +736,4 @@\n+  declare_constant(KlassFlags::_misc_is_hidden_class)                     \\\n+  declare_constant(KlassFlags::_misc_is_value_based_class)                \\\n+  declare_constant(KlassFlags::_misc_has_finalizer)                       \\\n+  declare_constant(KlassFlags::_misc_is_cloneable_fast)                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2902,2 +2902,2 @@\n-  \/\/ Initialize @ValueBased class annotation\n-  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation()) {\n+  \/\/ Initialize @ValueBased class annotation if not already set in the archived klass.\n+  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation() && !is_value_based()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  return _access_flags.is_cloneable_fast() ||\n+  return _misc_flags.is_cloneable_fast() ||\n@@ -79,1 +79,1 @@\n-    _access_flags.set_is_cloneable_fast();\n+    _misc_flags.set_is_cloneable_fast(true);\n@@ -981,0 +981,1 @@\n+  st->print(BULLET\"flags: \"); _misc_flags.print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klassFlags.hpp\"\n@@ -170,0 +171,2 @@\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -200,0 +203,2 @@\n+  KlassFlags  _misc_flags;\n+\n@@ -434,0 +439,1 @@\n+  static ByteSize misc_flags_offset()            { return byte_offset_of(Klass, _misc_flags._flags); }\n@@ -721,6 +727,8 @@\n-  bool has_finalizer() const            { return _access_flags.has_finalizer(); }\n-  void set_has_finalizer()              { _access_flags.set_has_finalizer(); }\n-  bool is_hidden() const                { return access_flags().is_hidden_class(); }\n-  void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }\n-  bool is_value_based()                 { return _access_flags.is_value_based_class(); }\n-  void set_is_value_based()             { _access_flags.set_is_value_based_class(); }\n+  bool has_finalizer() const            { return _misc_flags.has_finalizer(); }\n+  void set_has_finalizer()              { _misc_flags.set_has_finalizer(true); }\n+  bool is_hidden() const                { return _misc_flags.is_hidden_class(); }\n+  void set_is_hidden()                  { _misc_flags.set_is_hidden_class(true); }\n+  bool is_value_based() const           { return _misc_flags.is_value_based_class(); }\n+  void set_is_value_based()             { _misc_flags.set_is_value_based_class(true); }\n+\n+  klass_flags_t misc_flags() const      { return _misc_flags.value(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-  return access_flags().is_hidden_class() &&\n-         class_loader_data()->has_class_mirror_holder();\n+  return is_hidden() && class_loader_data()->has_class_mirror_holder();\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-  int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n+  size_t quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,3 @@\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ CompilationPolicy::min_invocations());\n+      \/\/ avoid division by 0, set divisor to at least 1\n+      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1760,0 +1760,2 @@\n+      if (flat->offset() == in_bytes(Klass::misc_flags_offset()))\n+        alias_type(idx)->set_rewritable(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4057,1 +4057,1 @@\n-\/\/ Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.\n+\/\/ Use this for JVM_ACC_INTERFACE.\n@@ -4059,1 +4059,2 @@\n-Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+Node* LibraryCallKit::generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                                 ByteSize offset, const Type* type, BasicType bt) {\n@@ -4062,2 +4063,2 @@\n-  Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* modp = basic_plus_adr(kls, in_bytes(offset));\n+  Node* mods = make_load(nullptr, modp, type, bt, MemNode::unordered);\n@@ -4073,1 +4074,2 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);\n+  return generate_klass_flags_guard(kls, JVM_ACC_INTERFACE, 0, region,\n+                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n@@ -4075,0 +4077,7 @@\n+\n+\/\/ Use this for testing if Klass is_hidden, has_finalizer, and is_cloneable_fast.\n+Node* LibraryCallKit::generate_misc_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+  return generate_klass_flags_guard(kls, modifier_mask, modifier_bits, region,\n+                                    Klass::misc_flags_offset(), TypeInt::UBYTE, T_BOOLEAN);\n+}\n+\n@@ -4076,1 +4085,1 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);\n+  return generate_misc_flags_guard(kls, KlassFlags::_misc_is_hidden_class, 0, region);\n@@ -5676,6 +5685,6 @@\n-      generate_access_flags_guard(obj_klass,\n-                                  \/\/ Test both conditions:\n-                                  JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,\n-                                  \/\/ Must be cloneable but not finalizer:\n-                                  JVM_ACC_IS_CLONEABLE_FAST,\n-                                  slow_region);\n+      generate_misc_flags_guard(obj_klass,\n+                                \/\/ Test both conditions:\n+                                KlassFlags::_misc_is_cloneable_fast | KlassFlags::_misc_has_finalizer,\n+                                \/\/ Must be cloneable but not finalizer:\n+                                KlassFlags::_misc_is_cloneable_fast,\n+                                slow_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -167,3 +167,5 @@\n-  Node* generate_access_flags_guard(Node* kls,\n-                                    int modifier_mask, int modifier_bits,\n-                                    RegionNode* region);\n+  Node* generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                   ByteSize offset, const Type* type, BasicType bt);\n+  Node* generate_misc_flags_guard(Node* kls,\n+                                  int modifier_mask, int modifier_bits,\n+                                  RegionNode* region);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -946,2 +946,0 @@\n-  Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);\n-\n@@ -968,1 +966,1 @@\n-  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init,\n+  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n@@ -1544,0 +1542,2 @@\n+  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1151,0 +1151,19 @@\n+\/\/ Split some nodes that take a counted loop phi as input at a counted\n+\/\/ loop can cause vectorization of some expressions to fail\n+bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n+  if (!n_blk->is_CountedLoop()) {\n+    return false;\n+  }\n+\n+  int opcode = n->Opcode();\n+\n+  if (opcode != Op_AndI &&\n+      opcode != Op_MulI &&\n+      opcode != Op_RotateRight &&\n+      opcode != Op_RShiftI) {\n+    return false;\n+  }\n+\n+  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n+}\n+\n@@ -1243,0 +1262,4 @@\n+  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n+    return n;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2011,0 +2011,6 @@\n+  if (tkls->offset() == in_bytes(Klass::misc_flags_offset())) {\n+    \/\/ The field is Klass::_misc_flags.  Return its (constant) value.\n+    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n+    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    return TypeInt::make(klass->misc_flags());\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2281,2 +2281,2 @@\n-  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::access_flags_offset()));\n-  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::misc_flags_offset()));\n+  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -2284,1 +2284,1 @@\n-  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(JVM_ACC_HAS_FINALIZER)));\n+  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(KlassFlags::_misc_has_finalizer)));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-static jint CurrentVersion = JNI_VERSION_21;\n+static jint CurrentVersion = JNI_VERSION_24;\n@@ -2280,1 +2280,1 @@\n- HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n@@ -2282,1 +2282,1 @@\n-  jsize ret = java_lang_String::utf8_length(java_string);\n+  jsize ret = java_lang_String::utf8_length_as_int(java_string);\n@@ -2287,0 +2287,8 @@\n+JNI_ENTRY(jlong, jni_GetStringUTFLengthAsLong(JNIEnv *env, jstring string))\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY(env, string);\n+  oop java_string = JNIHandles::resolve_non_null(string);\n+  size_t ret = java_lang_String::utf8_length(java_string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN(ret);\n+return checked_cast<jlong>(ret);\n+JNI_END\n+\n@@ -2295,1 +2303,2 @@\n-    \/* JNI Specification states return null on OOM *\/\n+    \/\/ JNI Specification states return null on OOM.\n+    \/\/ The resulting sequence doesn't have to be NUL-terminated but we do.\n@@ -2298,1 +2307,1 @@\n-      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);\n+      java_lang_String::as_utf8_string(java_string, s_value, result, length + 1);\n@@ -3494,1 +3503,5 @@\n-    jni_IsVirtualThread\n+    jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    jni_GetStringUTFLengthAsLong\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  if (!UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false)) {\n+  if (!UTF8::is_legal_utf8((const unsigned char*)name, strlen(name), false)) {\n@@ -1514,0 +1514,21 @@\n+    jlong full_length =  UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n+    if (full_length > result) {\n+      ResourceMark rm(thr);\n+      stringStream ss;\n+      ss.print(\"WARNING: large String with modified UTF-8 length \" JLONG_FORMAT\n+                \" is reporting a reduced length of %d - use GetStringUTFLengthAsLong instead\",\n+                full_length, result);\n+      NativeReportJNIWarning(thr, ss.as_string());\n+    }\n+    functionExit(thr);\n+    return result;\n+JNI_END\n+\n+JNI_ENTRY_CHECKED(jlong,\n+  checked_jni_GetStringUTFLengthAsLong(JNIEnv *env,\n+                                       jstring str))\n+    functionEnter(thr);\n+    IN_VM(\n+      checkString(thr, str);\n+    )\n+    jlong result = UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n@@ -2286,1 +2307,6 @@\n-    checked_jni_IsVirtualThread\n+    checked_jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    checked_jni_GetStringUTFLengthAsLong\n+\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), \"illegal UTF name\");\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, strlen(name), false), \"illegal UTF name\");\n@@ -3567,0 +3567,4 @@\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsStaticallyLinked(void))\n+  return is_vm_statically_linked() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-      int utf8_length = 0;\n+      size_t utf8_length = 0;\n@@ -2537,0 +2537,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2549,0 +2550,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2561,0 +2563,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2573,0 +2576,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -988,0 +988,1 @@\n+  if (version == JNI_VERSION_24) return JNI_TRUE;\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2023,2 +2023,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,7 +43,0 @@\n-  \/\/ HotSpot-specific access flags\n-  \/\/ These Klass flags should be migrated, to a field such as InstanceKlass::_misc_flags,\n-  \/\/ or to a similar flags field in Klass itself.\n-  JVM_ACC_HAS_FINALIZER           = 0x40000000,     \/\/ True if klass has a non-empty finalize() method\n-  JVM_ACC_IS_CLONEABLE_FAST       = (int)0x80000000,\/\/ True if klass implements the Cloneable interface and can be optimized in generated code\n-  JVM_ACC_IS_HIDDEN_CLASS         = 0x04000000,     \/\/ True if klass is hidden\n-  JVM_ACC_IS_VALUE_BASED_CLASS    = 0x08000000,     \/\/ True if klass is marked as a ValueBased class\n@@ -81,6 +74,0 @@\n-  \/\/ Klass* flags\n-  bool has_finalizer           () const { return (_flags & JVM_ACC_HAS_FINALIZER          ) != 0; }\n-  bool is_cloneable_fast       () const { return (_flags & JVM_ACC_IS_CLONEABLE_FAST      ) != 0; }\n-  bool is_hidden_class         () const { return (_flags & JVM_ACC_IS_HIDDEN_CLASS        ) != 0; }\n-  bool is_value_based_class    () const { return (_flags & JVM_ACC_IS_VALUE_BASED_CLASS   ) != 0; }\n-\n@@ -106,7 +93,0 @@\n-  \/\/ Klass* flags\n-  \/\/ These are set at classfile parsing time so do not require atomic access.\n-  void set_has_finalizer()             { _flags |= JVM_ACC_HAS_FINALIZER; }\n-  void set_is_cloneable_fast()         { _flags |= JVM_ACC_IS_CLONEABLE_FAST; }\n-  void set_is_hidden_class()           { _flags |= JVM_ACC_IS_HIDDEN_CLASS; }\n-  void set_is_value_based_class()      { _flags |= JVM_ACC_IS_VALUE_BASED_CLASS; }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4700,1 +4700,1 @@\n-            return \"[\" + componentType.descriptorString();\n+            return \"[\".concat(componentType.descriptorString());\n@@ -4713,5 +4713,1 @@\n-            return new StringBuilder(name.length() + 2)\n-                    .append('L')\n-                    .append(name)\n-                    .append(';')\n-                    .toString();\n+            return StringConcatHelper.concat(\"L\", name, \";\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2654,0 +2654,4 @@\n+            public String concat(String prefix, Object value, String suffix) {\n+                return StringConcatHelper.concat(prefix, value, suffix);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n-        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.INT),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LONG),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FLOAT),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ not valid in all contexts\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -461,0 +461,5 @@\n+    \/**\n+     * Concatenation of prefix and suffix characters to a String for early bootstrap\n+     *\/\n+    String concat(String prefix, Object value, String suffix);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-                                \"descriptor\", newa.typeKind().typeName()));\n+                                \"descriptor\", newa.typeKind().upperBound().displayName()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-                    cob.loadConstant(ldc.opcode(),\n-                            mapConstantValue(ldc.constantValue()));\n+                    cob.ldc(mapConstantValue(ldc.constantValue()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -233,6 +233,6 @@\n-                    case BooleanType, ByteType, CharType, IntType, ShortType -> cve instanceof IntegerEntry;\n-                    case DoubleType -> cve instanceof DoubleEntry;\n-                    case FloatType -> cve instanceof FloatEntry;\n-                    case LongType -> cve instanceof LongEntry;\n-                    case ReferenceType -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n-                    case VoidType -> false;\n+                    case BOOLEAN, BYTE, CHAR, INT, SHORT -> cve instanceof IntegerEntry;\n+                    case DOUBLE -> cve instanceof DoubleEntry;\n+                    case FLOAT -> cve instanceof FloatEntry;\n+                    case LONG -> cve instanceof LongEntry;\n+                    case REFERENCE -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n+                    case VOID -> false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -472,0 +472,4 @@\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -474,1 +478,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -501,0 +505,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -503,1 +511,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -4125,0 +4133,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4357,0 +4372,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4939,0 +4957,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1622,0 +1622,3 @@\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    final int klassMiscFlagsOffset = getFieldOffset(\"Klass::_misc_flags._flags\", Integer.class, \"u1\");\n@@ -116,1 +117,1 @@\n-    final int jvmAccHasFinalizer = getConstant(\"JVM_ACC_HAS_FINALIZER\", Integer.class);\n+    final int jvmAccHasFinalizer = getConstant(\"KlassFlags::_misc_has_finalizer\", Integer.class);\n@@ -119,1 +120,1 @@\n-    final int jvmAccIsCloneableFast = getConstant(\"JVM_ACC_IS_CLONEABLE_FAST\", Integer.class);\n+    final int jvmAccIsCloneableFast = getConstant(\"KlassFlags::_misc_is_cloneable_fast\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -76,2 +77,0 @@\n-compiler\/startup\/StartupOutput.java 8326615 generic-x64\n-\n@@ -131,1 +130,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2241,0 +2241,15 @@\n+    public static final String X86_CMOVEL_IMM01 = PREFIX + \"X86_CMOVEL_IMM01\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01, \"cmovL_imm_01\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01U = PREFIX + \"X86_CMOVEL_IMM01U\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01U, \"cmovL_imm_01U\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01UCF = PREFIX + \"X86_CMOVEL_IMM01UCF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01UCF, \"cmovL_imm_01UCF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-                    .return_(TypeKind.BooleanType)\n+                    .return_(TypeKind.BOOLEAN)\n@@ -338,1 +338,1 @@\n-                    .return_(TypeKind.BooleanType);\n+                    .return_(TypeKind.BOOLEAN);\n@@ -411,1 +411,1 @@\n-                    .return_(TypeKind.BooleanType)\n+                    .return_(TypeKind.BOOLEAN)\n@@ -414,1 +414,1 @@\n-                    .return_(TypeKind.BooleanType);\n+                    .return_(TypeKind.BOOLEAN);\n@@ -494,1 +494,1 @@\n-                    .return_(TypeKind.BooleanType)\n+                    .return_(TypeKind.BOOLEAN)\n@@ -497,1 +497,1 @@\n-                    .return_(TypeKind.BooleanType);\n+                    .return_(TypeKind.BOOLEAN);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.hpp\"\n@@ -39,0 +40,3 @@\n+\/\/ JVMTI_ERROR_WRONG_PHASE guard\n+static jrawMonitorID event_mon = nullptr;\n+static bool is_vm_dead = false;\n@@ -257,1 +261,1 @@\n-\/* Process a CLASS_LOAD or aClassPrepare event. *\/\n+\/* Process a CLASS_LOAD or a ClassPrepare event. *\/\n@@ -264,0 +268,5 @@\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+  if (is_vm_dead) {\n+    return;\n+  }\n+\n@@ -266,1 +275,1 @@\n-  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad event: Error in JVMTI GetClassSignature\");\n+  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad\/ClassPrepare event: Error in JVMTI GetClassSignature\");\n@@ -311,0 +320,8 @@\n+static void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+\n+  LOG0(\"VMDeath\\n\");\n+  is_vm_dead = true;\n+}\n+\n@@ -323,0 +340,7 @@\n+  err = jvmti->CreateRawMonitor(\"Event Monitor\", &event_mon);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG1(\"Agent_OnLoad: CreateRawMonitor failed: %d\\n\", err);\n+    failed = true;\n+    return JNI_ERR;\n+  }\n+\n@@ -328,0 +352,1 @@\n+  callbacks.VMDeath = &VMDeath;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -473,3 +473,0 @@\n-# This test fails on macOS 14\n-java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java 8324782 macosx-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,8 +223,8 @@\n-                        case ByteType -> cob.baload();\n-                        case ShortType -> cob.saload();\n-                        case IntType -> cob.iaload();\n-                        case FloatType -> cob.faload();\n-                        case LongType -> cob.laload();\n-                        case DoubleType -> cob.daload();\n-                        case ReferenceType -> cob.aaload();\n-                        case CharType -> cob.caload();\n+                        case BYTE -> cob.baload();\n+                        case SHORT -> cob.saload();\n+                        case INT -> cob.iaload();\n+                        case FLOAT -> cob.faload();\n+                        case LONG -> cob.laload();\n+                        case DOUBLE -> cob.daload();\n+                        case REFERENCE -> cob.aaload();\n+                        case CHAR -> cob.caload();\n@@ -236,8 +236,8 @@\n-                        case ByteType -> cob.bastore();\n-                        case ShortType -> cob.sastore();\n-                        case IntType -> cob.iastore();\n-                        case FloatType -> cob.fastore();\n-                        case LongType -> cob.lastore();\n-                        case DoubleType -> cob.dastore();\n-                        case ReferenceType -> cob.aastore();\n-                        case CharType -> cob.castore();\n+                        case BYTE -> cob.bastore();\n+                        case SHORT -> cob.sastore();\n+                        case INT -> cob.iastore();\n+                        case FLOAT -> cob.fastore();\n+                        case LONG -> cob.lastore();\n+                        case DOUBLE -> cob.dastore();\n+                        case REFERENCE -> cob.aastore();\n+                        case CHAR -> cob.castore();\n@@ -308,1 +308,1 @@\n-                        case DoubleType -> {\n+                        case DOUBLE -> {\n@@ -310,3 +310,3 @@\n-                                case FloatType -> cob.d2f();\n-                                case IntType -> cob.d2i();\n-                                case LongType -> cob.d2l();\n+                                case FLOAT -> cob.d2f();\n+                                case INT -> cob.d2i();\n+                                case LONG -> cob.d2l();\n@@ -316,1 +316,1 @@\n-                        case FloatType -> {\n+                        case FLOAT -> {\n@@ -318,3 +318,3 @@\n-                                case DoubleType -> cob.f2d();\n-                                case IntType -> cob.f2i();\n-                                case LongType -> cob.f2l();\n+                                case DOUBLE -> cob.f2d();\n+                                case INT -> cob.f2i();\n+                                case LONG -> cob.f2l();\n@@ -324,1 +324,1 @@\n-                        case IntType -> {\n+                        case INT -> {\n@@ -326,6 +326,6 @@\n-                                case ByteType -> cob.i2b();\n-                                case CharType -> cob.i2c();\n-                                case DoubleType -> cob.i2d();\n-                                case FloatType -> cob.i2f();\n-                                case LongType -> cob.i2l();\n-                                case ShortType -> cob.i2s();\n+                                case BYTE -> cob.i2b();\n+                                case CHAR -> cob.i2c();\n+                                case DOUBLE -> cob.i2d();\n+                                case FLOAT -> cob.i2f();\n+                                case LONG -> cob.i2l();\n+                                case SHORT -> cob.i2s();\n@@ -335,1 +335,1 @@\n-                        case LongType -> {\n+                        case LONG -> {\n@@ -337,3 +337,3 @@\n-                                case DoubleType -> cob.l2d();\n-                                case FloatType -> cob.l2f();\n-                                case IntType -> cob.l2i();\n+                                case DOUBLE -> cob.l2d();\n+                                case FLOAT -> cob.l2f();\n+                                case INT -> cob.l2i();\n@@ -414,5 +414,5 @@\n-                        case IntType -> cob.iload(i.slot());\n-                        case FloatType -> cob.fload(i.slot());\n-                        case LongType -> cob.lload(i.slot());\n-                        case DoubleType -> cob.dload(i.slot());\n-                        case ReferenceType -> cob.aload(i.slot());\n+                        case INT -> cob.iload(i.slot());\n+                        case FLOAT -> cob.fload(i.slot());\n+                        case LONG -> cob.lload(i.slot());\n+                        case DOUBLE -> cob.dload(i.slot());\n+                        case REFERENCE -> cob.aload(i.slot());\n@@ -424,5 +424,5 @@\n-                        case IntType -> cob.istore(i.slot());\n-                        case FloatType -> cob.fstore(i.slot());\n-                        case LongType -> cob.lstore(i.slot());\n-                        case DoubleType -> cob.dstore(i.slot());\n-                        case ReferenceType -> cob.astore(i.slot());\n+                        case INT -> cob.istore(i.slot());\n+                        case FLOAT -> cob.fstore(i.slot());\n+                        case LONG -> cob.lstore(i.slot());\n+                        case DOUBLE -> cob.dstore(i.slot());\n+                        case REFERENCE -> cob.astore(i.slot());\n@@ -519,6 +519,6 @@\n-                        case IntType -> cob.ireturn();\n-                        case FloatType -> cob.freturn();\n-                        case LongType -> cob.lreturn();\n-                        case DoubleType -> cob.dreturn();\n-                        case ReferenceType -> cob.areturn();\n-                        case VoidType -> cob.return_();\n+                        case INT -> cob.ireturn();\n+                        case FLOAT -> cob.freturn();\n+                        case LONG -> cob.lreturn();\n+                        case DOUBLE -> cob.dreturn();\n+                        case REFERENCE -> cob.areturn();\n+                        case VOID -> cob.return_();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"}]}