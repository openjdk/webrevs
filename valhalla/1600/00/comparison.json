{"files":[{"patch":"@@ -140,0 +140,39 @@\n+    \/**\n+     * Returns a resource node in the given module, or null if no resource of\n+     * that name exists.\n+     *\n+     * <p>This is equivalent to:\n+     * <pre>{@code\n+     * findNode(\"\/modules\/\" + moduleName + \"\/\" + resourcePath)\n+     * }<\/pre>\n+     * but more performant, and returns {@code null} for directories.\n+     *\n+     * @param moduleName The module name of the requested resource.\n+     * @param resourcePath Trailing module-relative resource path, not starting\n+     *     with {@code '\/'}.\n+     *\/\n+    public Node findResourceNode(String moduleName, String resourcePath)\n+            throws IOException {\n+        ensureOpen();\n+        return reader.findResourceNode(moduleName, resourcePath);\n+    }\n+\n+    \/**\n+     * Returns whether a resource exists in the given module.\n+     *\n+     * <p>This is equivalent to:\n+     * <pre>{@code\n+     * findResourceNode(moduleName, resourcePath) != null\n+     * }<\/pre>\n+     * but more performant, and will not create or cache new nodes.\n+     *\n+     * @param moduleName The module name of the resource being tested for.\n+     * @param resourcePath Trailing module-relative resource path, not starting\n+     *     with {@code '\/'}.\n+     *\/\n+    public boolean containsResource(String moduleName, String resourcePath)\n+            throws IOException {\n+        ensureOpen();\n+        return reader.containsResource(moduleName, resourcePath);\n+    }\n+\n@@ -279,4 +318,1 @@\n-         * <p>This is the only public API by which anything outside this class can access\n-         * {@code Node} instances either directly, or by resolving symbolic links.\n-         *\n-         * <p>Note also that there is no reentrant calling back to this method from within\n+         * <p>Note that there is no reentrant calling back to this method from within\n@@ -294,0 +330,3 @@\n+                    \/\/ This may perform two lookups, one for a directory (in\n+                    \/\/ \"\/modules\/...\") and one for a non-prefixed resource\n+                    \/\/ (with \"\/modules\" removed).\n@@ -310,0 +349,49 @@\n+        \/**\n+         * Returns a resource node in the given module, or null if no resource of\n+         * that name exists.\n+         *\n+         * <p>Note that there is no reentrant calling back to this method from within\n+         * the node handling code.\n+         *\/\n+        Node findResourceNode(String moduleName, String resourcePath) {\n+            \/\/ Unlike findNode(), this method makes only one lookup in the\n+            \/\/ underlying jimage, but can only reliably return resource nodes.\n+            if (moduleName.indexOf('\/') >= 0) {\n+                throw new IllegalArgumentException(\"invalid module name: \" + moduleName);\n+            }\n+            String nodeName = MODULES_ROOT + \"\/\" + moduleName + \"\/\" + resourcePath;\n+            \/\/ Synchronize as tightly as possible to reduce locking contention.\n+            synchronized (this) {\n+                Node node = nodes.get(nodeName);\n+                if (node == null) {\n+                    ImageLocation loc = findLocation(moduleName, resourcePath);\n+                    if (loc != null && isResource(loc)) {\n+                        node = newResource(nodeName, loc);\n+                        nodes.put(node.getName(), node);\n+                    }\n+                    return node;\n+                } else {\n+                    return node.isResource() ? node : null;\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Returns whether a resource exists in the given module.\n+         *\n+         * <p>This method is expected to be called frequently for resources\n+         * which do not exist in the given module (e.g. as part of classpath\n+         * search). As such, it skips checking the nodes cache and only checks\n+         * for an entry in the jimage file, as this is faster if the resource\n+         * is not present. This also means it doesn't need synchronization.\n+         *\/\n+        boolean containsResource(String moduleName, String resourcePath) {\n+            if (moduleName.indexOf('\/') >= 0) {\n+                throw new IllegalArgumentException(\"invalid module name: \" + moduleName);\n+            }\n+            \/\/ If the given module name is 'modules', then 'isResource()'\n+            \/\/ returns false to prevent false positives.\n+            ImageLocation loc = findLocation(moduleName, resourcePath);\n+            return loc != null && isResource(loc);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.FileSystem;\n@@ -32,1 +31,0 @@\n-import java.nio.file.FileSystems;\n@@ -37,1 +35,0 @@\n-import java.util.Collections;\n@@ -41,0 +38,1 @@\n+import java.util.Objects;\n@@ -59,1 +57,0 @@\n-    private static final int PACKAGES_LEN = PACKAGES.length();\n@@ -61,1 +58,1 @@\n-    private final FileSystem defaultFS;\n+    private final Path modulesDir;\n@@ -63,1 +60,1 @@\n-    private final Map<String, PathNode> nodes = Collections.synchronizedMap(new HashMap<>());\n+    private final Map<String, PathNode> nodes = new HashMap<>();\n@@ -67,2 +64,2 @@\n-        defaultFS = FileSystems.getDefault();\n-        String str = defaultFS.getSeparator();\n+        this.modulesDir = modulesDir;\n+        String str = modulesDir.getFileSystem().getSeparator();\n@@ -82,1 +79,1 @@\n-        PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n+        private PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n@@ -87,1 +84,1 @@\n-        PathNode(String name, Node link) {              \/\/ link\n+        private PathNode(String name, Node link) {              \/\/ link\n@@ -92,1 +89,1 @@\n-        PathNode(String name, List<Node> children) {    \/\/ dir\n+        private PathNode(String name, List<Node> children) {    \/\/ dir\n@@ -97,0 +94,5 @@\n+        @Override\n+        public boolean isResource() {\n+            return link == null && !getFileAttributes().isDirectory();\n+        }\n+\n@@ -115,1 +117,1 @@\n-        byte[] getContent() throws IOException {\n+        private byte[] getContent() throws IOException {\n@@ -129,1 +131,1 @@\n-                        p = explodedModulesDir.relativize(p);\n+                        p = modulesDir.relativize(p);\n@@ -155,1 +157,1 @@\n-    public void close() throws IOException {\n+    public synchronized void close() throws IOException {\n@@ -164,1 +166,0 @@\n-    \/\/ find Node for the given Path\n@@ -166,2 +167,2 @@\n-    public synchronized Node findNode(String str) {\n-        Node node = findModulesNode(str);\n+    public synchronized Node findNode(String name) {\n+        PathNode node = nodes.get(name);\n@@ -171,22 +172,6 @@\n-        \/\/ lazily created for paths like \/packages\/<package>\/<module>\/xyz\n-        \/\/ For example \/packages\/java.lang\/java.base\/java\/lang\/\n-        if (str.startsWith(PACKAGES)) {\n-            \/\/ pkgEndIdx marks end of <package> part\n-            int pkgEndIdx = str.indexOf('\/', PACKAGES_LEN);\n-            if (pkgEndIdx != -1) {\n-                \/\/ modEndIdx marks end of <module> part\n-                int modEndIdx = str.indexOf('\/', pkgEndIdx + 1);\n-                if (modEndIdx != -1) {\n-                    \/\/ make sure we have such module link!\n-                    \/\/ ie., \/packages\/<package>\/<module> is valid\n-                    Node linkNode = nodes.get(str.substring(0, modEndIdx));\n-                    if (linkNode == null || !linkNode.isLink()) {\n-                        return null;\n-                    }\n-                    \/\/ map to \"\/modules\/zyz\" path and return that node\n-                    \/\/ For example, \"\/modules\/java.base\/java\/lang\" for\n-                    \/\/ \"\/packages\/java.lang\/java.base\/java\/lang\".\n-                    String mod = MODULES + str.substring(pkgEndIdx + 1);\n-                    return findModulesNode(mod);\n-                }\n-            }\n+        \/\/ If null, this was not the name of \"\/modules\/...\" node, and since all\n+        \/\/ \"\/packages\/...\" nodes were created and cached in advance, the name\n+        \/\/ cannot reference a valid node.\n+        Path path = underlyingModulesPath(name);\n+        if (path == null) {\n+            return null;\n@@ -194,1 +179,2 @@\n-        return null;\n+        \/\/ This can still return null for hidden files.\n+        return createModulesNode(name, path);\n@@ -197,16 +183,23 @@\n-    \/\/ find a Node for a path that starts like \"\/modules\/...\"\n-    Node findModulesNode(String str) {\n-        PathNode node = nodes.get(str);\n-        if (node != null) {\n-            return node;\n-        }\n-        \/\/ lazily created \"\/modules\/xyz\/abc\/\" Node\n-        \/\/ This is mapped to default file system path \"<JDK_MODULES_DIR>\/xyz\/abc\"\n-        Path p = underlyingPath(str);\n-        if (p != null) {\n-            try {\n-                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);\n-                if (attrs.isRegularFile()) {\n-                    Path f = p.getFileName();\n-                    if (f.toString().startsWith(\"_the.\"))\n-                        return null;\n+    \/**\n+     * Lazily creates and caches a {@code Node} for the given \"\/modules\/...\" name\n+     * and corresponding path to a file or directory.\n+     *\n+     * @param name a resource or directory node name, of the form \"\/modules\/...\".\n+     * @param path the path of a file for a resource or directory.\n+     * @return the newly created and cached node, or {@code null} if the given\n+     *     path references a file which must be hidden in the node hierarchy.\n+     *\/\n+    private Node createModulesNode(String name, Path path) {\n+        assert !nodes.containsKey(name) : \"Node must not already exist: \" + name;\n+        assert isNonEmptyModulesPath(name) : \"Invalid modules name: \" + name;\n+\n+        try {\n+            \/\/ We only know if we're creating a resource of directory when we\n+            \/\/ look up file attributes, and we only do that once. Thus, we can\n+            \/\/ only reject \"marker files\" here, rather than by inspecting the\n+            \/\/ given name string, since it doesn't apply to directories.\n+            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n+            if (attrs.isRegularFile()) {\n+                Path f = path.getFileName();\n+                if (f.toString().startsWith(\"_the.\")) {\n+                    return null;\n@@ -214,5 +207,2 @@\n-                node = new PathNode(str, p, attrs);\n-                nodes.put(str, node);\n-                return node;\n-            } catch (IOException x) {\n-                \/\/ does not exists or unable to determine\n+            } else if (!attrs.isDirectory()) {\n+                return null;\n@@ -220,0 +210,6 @@\n+            PathNode node = new PathNode(name, path, attrs);\n+            nodes.put(name, node);\n+            return node;\n+        } catch (IOException x) {\n+            \/\/ Since the path reference a file, any errors should not be ignored.\n+            throw new UncheckedIOException(x);\n@@ -221,1 +217,0 @@\n-        return null;\n@@ -224,4 +219,9 @@\n-    Path underlyingPath(String str) {\n-        if (str.startsWith(MODULES)) {\n-            str = frontSlashToNativeSlash(str.substring(\"\/modules\".length()));\n-            return defaultFS.getPath(explodedModulesDir.toString(), str);\n+    \/**\n+     * Returns the expected file path for name in the \"\/modules\/...\" namespace,\n+     * or {@code null} if the name is not in the \"\/modules\/...\" namespace or the\n+     * path does not reference a file.\n+     *\/\n+    private Path underlyingModulesPath(String name) {\n+        if (isNonEmptyModulesPath(name)) {\n+            Path path = modulesDir.resolve(frontSlashToNativeSlash(name.substring(MODULES.length())));\n+            return Files.exists(path) ? path : null;\n@@ -232,0 +232,6 @@\n+    private static boolean isNonEmptyModulesPath(String name) {\n+        \/\/ Don't just check the prefix, there must be something after it too\n+        \/\/ (otherwise you end up with an empty string after trimming).\n+        return name.startsWith(MODULES) && name.length() > MODULES.length();\n+    }\n+\n@@ -252,1 +258,1 @@\n-        try (DirectoryStream<Path> stream = Files.newDirectoryStream(explodedModulesDir)) {\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modulesDir)) {\n@@ -257,1 +263,1 @@\n-                    findModulesNode(MODULES + moduleName);\n+                    Objects.requireNonNull(createModulesNode(MODULES + moduleName, module));\n@@ -264,6 +270,3 @@\n-                                List<String> moduleNames = packageToModules.get(pkgName);\n-                                if (moduleNames == null) {\n-                                    moduleNames = new ArrayList<>();\n-                                    packageToModules.put(pkgName, moduleNames);\n-                                }\n-                                moduleNames.add(moduleName);\n+                                packageToModules\n+                                        .computeIfAbsent(pkgName, k -> new ArrayList<>())\n+                                        .add(moduleName);\n@@ -278,2 +281,2 @@\n-        PathNode modulesDir = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n-        nodes.put(modulesDir.getName(), modulesDir);\n+        PathNode modulesRootNode = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n+        nodes.put(modulesRootNode.getName(), modulesRootNode);\n@@ -288,1 +291,1 @@\n-                Node moduleNode = findModulesNode(MODULES + moduleName);\n+                Node moduleNode = Objects.requireNonNull(nodes.get(MODULES + moduleName));\n@@ -298,2 +301,2 @@\n-        PathNode packagesDir = new PathNode(\"\/packages\", packagesChildren);\n-        nodes.put(packagesDir.getName(), packagesDir);\n+        PathNode packagesRootNode = new PathNode(\"\/packages\", packagesChildren);\n+        nodes.put(packagesRootNode.getName(), packagesRootNode);\n@@ -303,2 +306,2 @@\n-        rootChildren.add(packagesDir);\n-        rootChildren.add(modulesDir);\n+        rootChildren.add(packagesRootNode);\n+        rootChildren.add(modulesRootNode);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":84,"deletions":81,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    static final String RUNTIME_HOME;\n+    private static final String RUNTIME_HOME;\n@@ -83,1 +83,1 @@\n-    static final Path moduleImageFile;\n+    private static final Path moduleImageFile;\n@@ -85,1 +85,1 @@\n-    static final boolean modulesImageExists;\n+    private static final boolean modulesImageExists;\n@@ -87,1 +87,1 @@\n-    static final Path explodedModulesDir;\n+    private static final Path explodedModulesDir;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -417,2 +417,2 @@\n-        private boolean containsResource(String resourcePath) throws IOException {\n-            Objects.requireNonNull(resourcePath);\n+        private boolean containsResource(String module, String name) throws IOException {\n+            Objects.requireNonNull(name);\n@@ -422,7 +422,1 @@\n-            if (imageReader != null) {\n-                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n-                return node != null && node.isResource();\n-            } else {\n-                \/\/ not an images build\n-                return false;\n-            }\n+            return imageReader != null && imageReader.containsResource(module, name);\n@@ -433,3 +427,2 @@\n-            String resourcePath = \"\/\" + module + \"\/\" + name;\n-            if (containsResource(resourcePath)) {\n-                URI u = JNUA.create(\"jrt\", resourcePath);\n+            if (containsResource(module, name)) {\n+                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n@@ -467,3 +460,1 @@\n-            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n-            ImageReader.Node node = reader.findNode(nodeName);\n-            return (node != null && node.isResource()) ? node : null;\n+            return reader.findResourceNode(module, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-            Node node = READER.findNode(\"\/modules\/\" + module + \"\/\" + path);\n-            if (node == null || !node.isResource()) {\n+            Node node = READER.findResourceNode(module, path);\n+            if (node == null) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jrt\/JavaRuntimeURLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import org.junit.jupiter.api.Assumptions;\n@@ -31,0 +33,1 @@\n+import org.junit.jupiter.params.provider.CsvSource;\n@@ -32,1 +35,0 @@\n-import org.opentest4j.TestSkippedException;\n@@ -45,0 +47,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -48,0 +51,1 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -57,0 +61,1 @@\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n@@ -123,0 +128,59 @@\n+    @ParameterizedTest\n+    @CsvSource(delimiter = ':', value = {\n+            \"modfoo:com\/foo\/Alpha.class\",\n+            \"modbar:com\/bar\/One.class\",\n+    })\n+    public void testResource_present(String modName, String resPath) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNotNull(reader.findResourceNode(modName, resPath));\n+            assertTrue(reader.containsResource(modName, resPath));\n+\n+            String canonicalNodeName = \"\/modules\/\" + modName + \"\/\" + resPath;\n+            Node node = reader.findNode(canonicalNodeName);\n+            assertTrue(node != null && node.isResource());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = ':', value = {\n+            \/\/ Absolute resource names are not allowed.\n+            \"modfoo:\/com\/bar\/One.class\",\n+            \/\/ Resource in wrong module.\n+            \"modfoo:com\/bar\/One.class\",\n+            \"modbar:com\/foo\/Alpha.class\",\n+            \/\/ Directories are not returned.\n+            \"modfoo:com\/foo\",\n+            \"modbar:com\/bar\",\n+            \/\/ JImage entries exist for these, but they are not resources.\n+            \"modules:modfoo\/com\/foo\/Alpha.class\",\n+            \"packages:com.foo\/modfoo\",\n+            \/\/ Empty module names\/paths do not find resources.\n+            \"'':modfoo\/com\/foo\/Alpha.class\",\n+            \"modfoo:''\"})\n+    public void testResource_absent(String modName, String resPath) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNull(reader.findResourceNode(modName, resPath));\n+            assertFalse(reader.containsResource(modName, resPath));\n+\n+            \/\/ Non-existent resources names should either not be found,\n+            \/\/ or (in the case of directory nodes) not be resources.\n+            String canonicalNodeName = \"\/modules\/\" + modName + \"\/\" + resPath;\n+            Node node = reader.findNode(canonicalNodeName);\n+            assertTrue(node == null || !node.isResource());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = ':', value = {\n+            \/\/ Don't permit module names to contain paths.\n+            \"modfoo\/com\/bar:One.class\",\n+            \"modfoo\/com:bar\/One.class\",\n+            \"modules\/modfoo\/com:foo\/Alpha.class\",\n+    })\n+    public void testResource_invalid(String modName, String resPath) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertThrows(IllegalArgumentException.class, () -> reader.containsResource(modName, resPath));\n+            assertThrows(IllegalArgumentException.class, () -> reader.findResourceNode(modName, resPath));\n+        }\n+    }\n+\n@@ -217,0 +281,1 @@\n+        Helper helper;\n@@ -218,5 +283,2 @@\n-            Helper helper = Helper.newHelper();\n-            if (helper == null) {\n-                throw new TestSkippedException(\"Cannot create test helper (exploded image?)\");\n-            }\n-            return helper;\n+            boolean isLinkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+            helper = Helper.newHelper(isLinkableRuntime);\n@@ -226,0 +288,2 @@\n+        Assumptions.assumeTrue(helper != null, \"Cannot create test helper, skipping test!\");\n+        return helper;\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Whitebox tests for ExplodedImage to ensure compatibility with ImageReader.\n+ * @modules java.base\/jdk.internal.jrtfs java.base\/jdk.internal.jimage\n+ * @run junit\/othervm java.base\/jdk.internal.jrtfs.ExplodedImageTest\n+ *\/\n+public class ExplodedImageTestDriver {}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/ExplodedImageTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+modules = \\\n+    java.base\/jdk.internal.jimage \\\n+    java.base\/jdk.internal.jrtfs\n+bootclasspath.dirs=.\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/TEST.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jrtfs;\n+\n+import jdk.internal.jimage.ImageReader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Tests an {@link ExplodedImage} view of a class-file hierarchy.\n+ *\n+ * <p>For simplicity and performance, only a subset of the JRT files are copied\n+ * to disk for testing.\n+ *\/\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class ExplodedImageTest {\n+\n+    private Path modulesRoot;\n+    private SystemImage explodedImage;\n+    private String pathSeparator;\n+\n+    @BeforeAll\n+    public void createTestDirectory(@TempDir Path modulesRoot) throws IOException {\n+        this.modulesRoot = modulesRoot;\n+        this.pathSeparator = modulesRoot.getFileSystem().getSeparator();\n+        \/\/ Copy only a useful subset of files for testing. Use at least two\n+        \/\/ modules with \"overlapping\" packages to test \/package links better.\n+        unpackModulesDirectoriesFromJrtFileSystem(modulesRoot,\n+                \"java.base\/java\/util\",\n+                \"java.base\/java\/util\/zip\",\n+                \"java.logging\/java\/util\/logging\");\n+        this.explodedImage = new ExplodedImage(modulesRoot);\n+    }\n+\n+    \/** Unpacks a list of \"\/modules\/...\" directories non-recursively into the specified root directory. *\/\n+    private static void unpackModulesDirectoriesFromJrtFileSystem(Path modulesRoot, String... dirNames)\n+            throws IOException {\n+        FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        List<Path> srcDirs = Arrays.stream(dirNames).map(s -> \"\/modules\/\" + s).map(jrtfs::getPath).toList();\n+        for (Path srcDir : srcDirs) {\n+            \/\/ Skip-1 to remove \"modules\" segment (not part of the file system path).\n+            Path dstDir = StreamSupport.stream(srcDir.spliterator(), false)\n+                    .skip(1)\n+                    .reduce(modulesRoot, (path, segment) -> path.resolve(segment.toString()));\n+            Files.createDirectories(dstDir);\n+            try (DirectoryStream<Path> files = Files.newDirectoryStream(srcDir)) {\n+                for (Path srcFile : files) {\n+                    Files.copy(srcFile, dstDir.resolve(srcFile.getFileName().toString()));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void topLevelNodes() throws IOException {\n+        ImageReader.Node root = explodedImage.findNode(\"\/\");\n+        ImageReader.Node modules = explodedImage.findNode(\"\/modules\");\n+        ImageReader.Node packages = explodedImage.findNode(\"\/packages\");\n+        assertEquals(\n+                Set.of(modules.getName(), packages.getName()),\n+                root.getChildNames().collect(Collectors.toSet()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\/java\/util\/List.class\",\n+            \"\/modules\/java.base\/java\/util\/zip\/ZipEntry.class\",\n+            \"\/modules\/java.logging\/java\/util\/logging\/Logger.class\"})\n+    public void basicLookupResource(String expectedResourceName) throws IOException {\n+        ImageReader.Node node = assertResourceNode(expectedResourceName);\n+\n+        Path fsRelPath = getRelativePath(expectedResourceName);\n+        assertArrayEquals(\n+                Files.readAllBytes(modulesRoot.resolve(fsRelPath)),\n+                explodedImage.getResource(node));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\",\n+            \"\/modules\/java.logging\",\n+            \"\/modules\/java.base\/java\",\n+            \"\/modules\/java.base\/java\/util\",\n+            \"\/modules\/java.logging\/java\/util\",\n+    })\n+    public void basicLookupDirectory(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+\n+        Path fsRelPath = getRelativePath(expectedDirectoryName);\n+        List<String> fsChildBaseNames;\n+        try (DirectoryStream<Path> paths = Files.newDirectoryStream(modulesRoot.resolve(fsRelPath))) {\n+            fsChildBaseNames = StreamSupport.stream(paths.spliterator(), false)\n+                    .map(Path::getFileName)\n+                    .map(Path::toString)\n+                    .toList();\n+        }\n+        List<String> nodeChildBaseNames = node.getChildNames()\n+                .map(s -> s.substring(node.getName().length() + 1))\n+                .toList();\n+        assertEquals(fsChildBaseNames, nodeChildBaseNames, \"expected same child names\");\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\/java.base\",\n+            \"\/packages\/java\/java.logging\",\n+            \"\/packages\/java.util\/java.base\",\n+            \"\/packages\/java.util\/java.logging\",\n+            \"\/packages\/java.util.zip\/java.base\"})\n+    public void basicLookupPackageLinks(String expectedLinkName) throws IOException {\n+        ImageReader.Node node = assertLinkNode(expectedLinkName);\n+        ImageReader.Node resolved = node.resolveLink();\n+        assertSame(explodedImage.findNode(resolved.getName()), resolved);\n+        String moduleName = expectedLinkName.substring(expectedLinkName.lastIndexOf('\/') + 1);\n+        assertEquals(\"\/modules\/\" + moduleName, resolved.getName());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\",\n+            \"\/packages\/java.util\",\n+            \"\/packages\/java.util.zip\"})\n+    public void packageDirectories(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+        assertTrue(node.getChildNames().findFirst().isPresent(),\n+                \"Package directories should not be empty: \" + node);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \".\",\n+            \"\/.\",\n+            \"modules\",\n+            \"packages\",\n+            \"\/modules\/\",\n+            \"\/modules\/xxxx\",\n+            \"\/modules\/java.base\/java\/lang\/Xxxx.class\",\n+            \"\/packages\/\",\n+            \"\/packages\/xxxx\",\n+            \"\/packages\/java.xxxx\",\n+            \"\/packages\/java.util.\",\n+            \/\/ Mismatched module.\n+            \"\/packages\/java.util.logging\/java.base\",\n+            \"\/packages\/java.util.zip\/java.logging\",\n+            \/\/ Links are not resolved as they are fetched (old\/broken behaviour).\n+            \"\/packages\/java.util\/java.base\/java\/util\/Vector.class\",\n+    })\n+    public void invalidNames(String invalidName) throws IOException {\n+        assertNull(explodedImage.findNode(invalidName), \"No node expected for: \" + invalidName);\n+    }\n+\n+    private ImageReader.Node assertResourceNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isResource(), \"expected a resource: \" + node);\n+        assertFalse(node.isDirectory(), \"resources are not directories: \" + node);\n+        assertFalse(node.isLink(), \"resources are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertDirectoryNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isDirectory(), \"expected a directory: \" + node);\n+        assertFalse(node.isResource(), \"directories are not resources: \" + node);\n+        assertFalse(node.isLink(), \"directories are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertLinkNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isLink(), \"expected a link: \" + node);\n+        assertFalse(node.isResource(), \"links are not resources: \" + node);\n+        assertFalse(node.isDirectory(), \"links are not directories: \" + node);\n+        return node;\n+    }\n+\n+    private Path getRelativePath(String name) {\n+        return Path.of(name.substring(\"\/modules\/\".length()).replace(\"\/\", pathSeparator));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/java.base\/jdk\/internal\/jrtfs\/ExplodedImageTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}