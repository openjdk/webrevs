{"files":[{"patch":"@@ -60,0 +60,1 @@\n+JVM_ExpandStackFrameInfo\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -867,1 +867,0 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_COPY_DEBUG_SYMBOLS_libnativeStack := true\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1349,3 +1349,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1369,0 +1368,2 @@\n+      Register mdo  = klass_RInfo;\n+      __ mov_metadata(mdo, md->constant_encoding());\n@@ -1372,2 +1373,0 @@\n-      Register mdo  = klass_RInfo;\n-      __ mov_metadata(mdo, md->constant_encoding());\n@@ -1383,0 +1382,9 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, obj);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+\n+      __ bind(update_done);\n@@ -1440,20 +1448,0 @@\n-  if (should_profile) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj);\n-    Label update_done;\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ b(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr\n-      = __ form_address(rscratch2, mdo,\n-                        md->byte_offset_of_slot(data, CounterData::count_offset()),\n-                        0);\n-    __ ldr(rscratch1, counter_addr);\n-    __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-    __ str(rscratch1, counter_addr);\n-    __ b(*failure);\n-  }\n@@ -1491,3 +1479,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = should_profile ? &profile_cast_success : &done;\n-    Label *failure_target = should_profile ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1497,2 +1485,0 @@\n-      __ cbnz(value, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1501,0 +1487,2 @@\n+      __ cbnz(value, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1510,0 +1498,8 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1530,19 +1526,0 @@\n-    if (should_profile) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value);\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ b(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ lea(rscratch2, counter_addr);\n-      __ ldr(rscratch1, Address(rscratch2));\n-      __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-      __ str(rscratch1, Address(rscratch2));\n-      __ b(*stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":26,"deletions":49,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -398,5 +398,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  if (profile) {\n-    profile_typecheck_failed(r2); \/\/ blows r2\n-  }\n@@ -1332,1 +1327,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    record_klass_in_profile(receiver, mdp, reg2);\n@@ -1355,1 +1350,1 @@\n-                                        Label& done, bool is_virtual_call) {\n+                                        Label& done) {\n@@ -1357,8 +1352,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1366,11 +1354,1 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1383,2 +1361,1 @@\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn) {\n@@ -1415,10 +1392,6 @@\n-        if (non_profiled_offset >= 0) {\n-          cbz(reg2, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          b(done);\n-          bind(found_null);\n-        } else {\n-          cbnz(reg2, done);\n-        }\n+        cbz(reg2, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        b(done);\n+        bind(found_null);\n@@ -1432,1 +1405,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+        item_offset_fn, item_count_offset_fn);\n@@ -1479,2 +1452,1 @@\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n+                                                        Register mdp, Register reg2) {\n@@ -1484,1 +1456,1 @@\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done, is_virtual_call);\n+  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n@@ -1546,18 +1518,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1577,1 +1531,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      record_klass_in_profile(klass, mdp, reg2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":15,"deletions":61,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-                               Register reg2, bool is_virtual_call);\n+                               Register reg2);\n@@ -294,1 +294,1 @@\n-                                      Label& done, bool is_virtual_call);\n+                                      Label& done);\n@@ -297,2 +297,1 @@\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1238,0 +1238,104 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  int vtable_start_offset = in_bytes(Klass::vtable_start_offset());\n+  int itable_offset_entry_size = itableOffsetEntry::size() * wordSize;\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add(recv_klass, recv_klass, vtable_start_offset + ioffset);\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset() + sizeof(vtableEntry) * recv_klass->_vtable_len;\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  int vtblEntrySize = vtableEntry::size_in_bytes();\n+  assert(vtblEntrySize == wordSize, \"ldr lsl shift amount must be 3\");\n+  ldr(temp_itbl_klass, Address(recv_klass, scan_temp, Address::lsl(exact_log2(vtblEntrySize))));\n+  mov(holder_offset, zr);\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(exact_log2(vtblEntrySize))));\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  cmp(resolved_klass, holder_klass);\n+  br(Assembler::NE, L_loop_search_resolved_entry);\n+  cmp(holder_klass, temp_itbl_klass);\n+  br(Assembler::EQ, L_holder_found);\n+  cbz(temp_itbl_klass, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += itable_offset_entry_size);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_search_holder;\n+  bind(L_search_holder);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, itable_offset_entry_size)));\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_holder_found);\n+    cbnz(temp_itbl_klass, L_search_holder);\n+\n+  b(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     temp_itbl_klass = *(scan_temp += itable_offset_entry_size);\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  Label L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, itable_offset_entry_size)));\n+  bind(L_loop_search_resolved_entry);\n+    cbz(temp_itbl_klass, L_no_such_interface);\n+    cmp(resolved_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_resolved_found);\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::NE, L_loop_search_resolved);\n+    mov(holder_offset, scan_temp);\n+    b(L_loop_search_resolved);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  cbz(holder_offset, L_search_holder);\n+  mov(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  ldrw(method_result, Address(scan_temp, ooffset - ioffset));\n+  add(recv_klass, recv_klass, itable_index * wordSize + in_bytes(itableMethodEntry::method_offset())\n+    - vtable_start_offset - ioffset); \/\/ substract offsets to restore the original value of recv_klass\n+  ldr(method_result, Address(recv_klass, method_result, Address::uxtw(0)));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1007,0 +1007,9 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp_reg,\n+                                    Register temp_reg2,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-#include \"oops\/methodData.hpp\"\n+#include \"oops\/methodCounters.hpp\"\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"oops\/method.hpp\"\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-  const Register resolved_klass_reg = rmethod; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r17; \/\/ resolved interface klass (REFC)\n@@ -204,17 +204,2 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             temp_reg2, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             rmethod, temp_reg,\n-                             L_no_such_interface);\n-\n-  const ptrdiff_t lookupSize = __ pc() - start_pc;\n+  __ lookup_interface_method_stub(recv_klass_reg, holder_klass_reg, resolved_klass_reg, rmethod,\n+                                  temp_reg, temp_reg2, itable_index, L_no_such_interface);\n@@ -225,1 +210,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize;\n+  const ptrdiff_t codesize = __ pc() - start_pc;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1735,3 +1735,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = op->should_profile() ? &profile_cast_success : success;\n-  Label *failure_target = op->should_profile() ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1754,1 +1753,1 @@\n-    __ cmpptr(obj, NULL_WORD);\n+    __ testptr(obj, obj);\n@@ -1757,2 +1756,0 @@\n-      __ jccb(Assembler::notEqual, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1761,0 +1758,2 @@\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1766,0 +1765,10 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, obj, tmp_load_klass);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+      Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n+\n+      __ bind(update_done);\n@@ -1834,1 +1843,1 @@\n-        __ cmpl(klass_RInfo, 0);\n+        __ testl(klass_RInfo, klass_RInfo);\n@@ -1848,1 +1857,1 @@\n-      __ cmpl(k_RInfo, 0);\n+      __ testl(k_RInfo, k_RInfo);\n@@ -1853,14 +1862,0 @@\n-  if (op->should_profile()) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj, tmp_load_klass);\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ jmp(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ subptr(counter_addr, DataLayout::counter_increment);\n-    __ jmp(*failure);\n-  }\n@@ -1897,3 +1892,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = op->should_profile() ? &profile_cast_success : &done;\n-    Label *failure_target = op->should_profile() ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1901,1 +1896,1 @@\n-    __ cmpptr(value, NULL_WORD);\n+    __ testptr(value, value);\n@@ -1904,2 +1899,0 @@\n-      __ jccb(Assembler::notEqual, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1908,0 +1901,2 @@\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1913,0 +1908,9 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value, tmp_load_klass);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1932,1 +1936,1 @@\n-    __ cmpl(k_RInfo, 0);\n+    __ testl(k_RInfo, k_RInfo);\n@@ -1936,15 +1940,0 @@\n-    if (op->should_profile()) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value, tmp_load_klass);\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ jmpb(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ subptr(counter_addr, DataLayout::counter_increment);\n-      __ jmp(*stub->entry());\n-    }\n-\n@@ -2845,1 +2834,6 @@\n-        __ cmpl(reg1, c->as_jint());\n+        jint i = c->as_jint();\n+        if (i == 0) {\n+          __ testl(reg1, reg1);\n+        } else {\n+          __ cmpl(reg1, i);\n+        }\n@@ -2851,1 +2845,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -2859,1 +2853,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -3359,1 +3353,1 @@\n-    __ cmpl(rax, 0);\n+    __ testl(rax, rax);\n@@ -3509,1 +3503,1 @@\n-      __ cmpl(src, 0);\n+      __ testl(src, src);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":43,"deletions":49,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -577,5 +577,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  if (profile) {\n-    profile_typecheck_failed(rcx); \/\/ blows rcx\n-  }\n@@ -1876,8 +1871,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1885,11 +1873,1 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n-\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+                                  &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1900,4 +1878,4 @@\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp,\n-                                        Register reg2, int start_row, Label& done, int total_rows,\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                                              Label& done, int total_rows,\n+                                                              OffsetFunction item_offset_fn,\n+                                                              OffsetFunction item_count_offset_fn) {\n@@ -1934,11 +1912,7 @@\n-        if (non_profiled_offset >= 0) {\n-          Label found_null;\n-          jccb(Assembler::zero, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          jmp(done);\n-          bind(found_null);\n-        } else {\n-          jcc(Assembler::notZero, done);\n-        }\n+        Label found_null;\n+        jccb(Assembler::zero, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        jmp(done);\n+        bind(found_null);\n@@ -1953,1 +1927,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+                                    item_offset_fn, item_count_offset_fn);\n@@ -2069,19 +2043,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":59,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"interpreter\/invocationCounter.hpp\"\n@@ -283,4 +282,4 @@\n-  void record_item_in_profile_helper(Register item, Register mdp,\n-                                     Register reg2, int start_row, Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+  void record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                     Label& done, int total_rows,\n+                                     OffsetFunction item_offset_fn,\n+                                     OffsetFunction item_count_offset_fn);\n@@ -303,1 +302,1 @@\n-  void profile_typecheck_failed(Register mdp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -334,0 +334,10 @@\n+#ifdef ASSERT\n+  \/\/ make sure the type is INT\n+  {\n+    Label L;\n+    __ cmpl(rbx, T_INT);\n+    __ jcc(Assembler::equal, L);\n+    __ stop(\"StubRoutines::call_stub: unexpected result type\");\n+    __ bind(L);\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4836,1 +4836,1 @@\n-  CompileTask::print_inlining_ul(callee, scope()->level(), bci(), msg);\n+  CompileTask::print_inlining_ul(callee, scope()->level(), bci(), inlining_result_of(success), msg);\n@@ -4841,1 +4841,1 @@\n-  CompileTask::print_inlining_tty(callee, scope()->level(), bci(), msg);\n+  CompileTask::print_inlining_tty(callee, scope()->level(), bci(), inlining_result_of(success), msg);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -445,0 +445,3 @@\n+      if (VM_Version::profile_all_receivers_at_type_check()) {\n+        return (c < 0 ? max_jint : c); \/\/ always non-negative\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -941,1 +941,1 @@\n-  MutexLocker locker(Zip_lock, Monitor::_no_safepoint_check_flag);\n+  ConditionalMutexLocker locker(Zip_lock, Zip_lock != nullptr, Monitor::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -572,3 +572,0 @@\n-  \/\/ Adjust global class iterator.\n-  ClassLoaderDataGraph::adjust_saved_class(scratch_class);\n-\n@@ -636,3 +633,0 @@\n-\n-  \/\/ Clean up global class iterator for compiler\n-  ClassLoaderDataGraph::adjust_saved_class(this);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3038,0 +3038,61 @@\n+\/\/ java_lang_ClassFrameInfo\n+\n+int java_lang_ClassFrameInfo::_classOrMemberName_offset;\n+int java_lang_ClassFrameInfo::_flags_offset;\n+\n+#define CLASSFRAMEINFO_FIELDS_DO(macro) \\\n+  macro(_classOrMemberName_offset, k, \"classOrMemberName\", object_signature,  false); \\\n+  macro(_flags_offset,             k, vmSymbols::flags_name(), int_signature, false)\n+\n+void java_lang_ClassFrameInfo::compute_offsets() {\n+  InstanceKlass* k = vmClasses::ClassFrameInfo_klass();\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_ClassFrameInfo::serialize_offsets(SerializeClosure* f) {\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+static int get_flags(const methodHandle& m) {\n+  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  if (m->is_object_constructor()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR;\n+  } else {\n+    flags |= java_lang_invoke_MemberName::MN_IS_METHOD;\n+  }\n+  if (m->caller_sensitive()) {\n+    flags |= java_lang_invoke_MemberName::MN_CALLER_SENSITIVE;\n+  }\n+  if (m->is_hidden()) {\n+    flags |= java_lang_invoke_MemberName::MN_HIDDEN_MEMBER;\n+  }\n+  assert((flags & 0xFF000000) == 0, \"unexpected flags\");\n+  return flags;\n+}\n+\n+oop java_lang_ClassFrameInfo::classOrMemberName(oop obj) {\n+  return obj->obj_field(_classOrMemberName_offset);\n+}\n+\n+int java_lang_ClassFrameInfo::flags(oop obj) {\n+  return obj->int_field(_flags_offset);\n+}\n+\n+void java_lang_ClassFrameInfo::init_class(Handle stackFrame, const methodHandle& m) {\n+  stackFrame->obj_field_put(_classOrMemberName_offset, m->method_holder()->java_mirror());\n+  \/\/ flags is initialized when ClassFrameInfo object is constructed and retain the value\n+  int flags = java_lang_ClassFrameInfo::flags(stackFrame()) | get_flags(m);\n+  stackFrame->int_field_put(_flags_offset, flags);\n+}\n+\n+void java_lang_ClassFrameInfo::init_method(Handle stackFrame, const methodHandle& m, TRAPS) {\n+  oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);\n+  stackFrame->obj_field_put(_classOrMemberName_offset, rmethod_name);\n+  \/\/ flags is initialized when ClassFrameInfo object is constructed and retain the value\n+  int flags = java_lang_ClassFrameInfo::flags(stackFrame()) | get_flags(m);\n+  stackFrame->int_field_put(_flags_offset, flags);\n+}\n+\n+\n@@ -3040,1 +3101,2 @@\n-int java_lang_StackFrameInfo::_memberName_offset;\n+int java_lang_StackFrameInfo::_type_offset;\n+int java_lang_StackFrameInfo::_name_offset;\n@@ -3046,1 +3108,2 @@\n-  macro(_memberName_offset, k, \"memberName\", object_signature,            false); \\\n+  macro(_type_offset,       k, \"type\",       object_signature,            false); \\\n+  macro(_name_offset,       k, \"name\",       string_signature,            false); \\\n@@ -3063,6 +3126,3 @@\n-Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {\n-  HandleMark hm(THREAD);\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());\n-  \/\/ we should expand MemberName::name when Throwable uses StackTrace\n-  \/\/ MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);\n+Method* java_lang_StackFrameInfo::get_method(oop obj) {\n+  oop m = java_lang_ClassFrameInfo::classOrMemberName(obj);\n+  Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(m);\n@@ -3075,5 +3135,3 @@\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Handle cont_h (THREAD, cont);\n-  InstanceKlass* ik = method->method_holder();\n-  CallInfo info(method(), ik, CHECK);\n-  MethodHandles::init_method_MemberName(mname, info);\n+  Handle cont_h(THREAD, cont);\n+  java_lang_ClassFrameInfo::init_method(stackFrame, method, CHECK);\n+\n@@ -3094,4 +3152,2 @@\n-  Handle mname(THREAD, stackFrame->obj_field(java_lang_StackFrameInfo::_memberName_offset));\n-  Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));\n-  InstanceKlass* holder = InstanceKlass::cast(clazz);\n-  Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);\n+  Method* method = java_lang_StackFrameInfo::get_method(stackFrame());\n+  InstanceKlass* holder = method->method_holder();\n@@ -3105,2 +3161,2 @@\n-void java_lang_StackFrameInfo::set_version(oop element, short value) {\n-  element->short_field_put(_version_offset, value);\n+oop java_lang_StackFrameInfo::type(oop obj) {\n+  return obj->obj_field(_type_offset);\n@@ -3109,1 +3165,17 @@\n-void java_lang_StackFrameInfo::set_bci(oop element, int value) {\n+void java_lang_StackFrameInfo::set_type(oop obj, oop value) {\n+  obj->obj_field_put(_type_offset, value);\n+}\n+\n+oop java_lang_StackFrameInfo::name(oop obj) {\n+  return obj->obj_field(_name_offset);\n+}\n+\n+void java_lang_StackFrameInfo::set_name(oop obj, oop value) {\n+  obj->obj_field_put(_name_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_version(oop obj, short value) {\n+  obj->short_field_put(_version_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_bci(oop obj, int value) {\n@@ -3111,1 +3183,1 @@\n-  element->int_field_put(_bci_offset, value);\n+  obj->int_field_put(_bci_offset, value);\n@@ -3114,2 +3186,2 @@\n-void java_lang_StackFrameInfo::set_contScope(oop element, oop value) {\n-  element->obj_field_put(_contScope_offset, value);\n+void java_lang_StackFrameInfo::set_contScope(oop obj, oop value) {\n+  obj->obj_field_put(_contScope_offset, value);\n@@ -3140,2 +3212,2 @@\n-void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {\n-  element->obj_field_put(_monitors_offset, value);\n+void java_lang_LiveStackFrameInfo::set_monitors(oop obj, oop value) {\n+  obj->obj_field_put(_monitors_offset, value);\n@@ -3144,2 +3216,2 @@\n-void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {\n-  element->obj_field_put(_locals_offset, value);\n+void java_lang_LiveStackFrameInfo::set_locals(oop obj, oop value) {\n+  obj->obj_field_put(_locals_offset, value);\n@@ -3148,2 +3220,2 @@\n-void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {\n-  element->obj_field_put(_operands_offset, value);\n+void java_lang_LiveStackFrameInfo::set_operands(oop obj, oop value) {\n+  obj->obj_field_put(_operands_offset, value);\n@@ -3152,2 +3224,2 @@\n-void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {\n-  element->int_field_put(_mode_offset, value);\n+void java_lang_LiveStackFrameInfo::set_mode(oop obj, int value) {\n+  obj->int_field_put(_mode_offset, value);\n@@ -4029,0 +4101,3 @@\n+#define RESOLVEDMETHOD_FIELDS_DO(macro) \\\n+  macro(_vmholder_offset, k, \"vmholder\", class_signature, false)\n+\n@@ -4032,0 +4107,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n@@ -4037,0 +4113,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n@@ -5299,0 +5376,1 @@\n+  f(java_lang_ClassFrameInfo) \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":109,"deletions":31,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  static inline void set_value_raw(oop string, typeArrayOop buffer);\n@@ -1215,1 +1214,0 @@\n-  macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \\\n@@ -1304,1 +1302,2 @@\n-    MN_FLAT_FIELD            = 0x00400000, \/\/ flat field\n+    MN_HIDDEN_MEMBER         = 0x00400000, \/\/ @Hidden annotation detected\n+    MN_FLAT_FIELD            = 0x00800000, \/\/ flat field\n@@ -1608,0 +1607,20 @@\n+class java_lang_ClassFrameInfo: AllStatic {\n+private:\n+  static int _classOrMemberName_offset;\n+  static int _flags_offset;\n+\n+public:\n+  static oop  classOrMemberName(oop info);\n+  static int  flags(oop info);\n+\n+  \/\/ Setters\n+  static void init_class(Handle stackFrame, const methodHandle& m);\n+  static void init_method(Handle stackFrame, const methodHandle& m, TRAPS);\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Debugging\n+  friend class JavaClasses;\n+};\n+\n@@ -1615,1 +1634,2 @@\n-  static int _memberName_offset;\n+  static int _type_offset;\n+  static int _name_offset;\n@@ -1620,2 +1640,5 @@\n-  static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);\n-\n+  \/\/ Getters\n+  static oop name(oop info);\n+  static oop type(oop info);\n+  static Method* get_method(oop info);\n+\n@@ -1625,0 +1648,2 @@\n+  static void set_name(oop info, oop value);\n+  static void set_type(oop info, oop value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -42,4 +42,0 @@\n-void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {\n-  string->obj_field_put_raw(_value_offset, buffer);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1625,1 +1625,1 @@\n-      MutexLocker ml2(is_concurrent ? Module_lock : nullptr);\n+      ConditionalMutexLocker ml2(Module_lock, is_concurrent);\n@@ -1628,1 +1628,1 @@\n-      MutexLocker ml1(is_concurrent ? SystemDictionary_lock : nullptr);\n+      ConditionalMutexLocker ml1(SystemDictionary_lock, is_concurrent);\n@@ -1651,1 +1651,1 @@\n-    MutexLocker ml(is_concurrent ? ClassInitError_lock : nullptr);\n+    ConditionalMutexLocker ml(ClassInitError_lock, is_concurrent);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  do_klass(ClassFrameInfo_klass,                        java_lang_ClassFrameInfo                              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+  template(java_lang_ClassFrameInfo,                  \"java\/lang\/ClassFrameInfo\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1351,1 +1351,1 @@\n-    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1232,0 +1232,1 @@\n+      \/\/ In libjvmci, JVMCI initialization should not deadlock with other threads\n@@ -1243,5 +1244,5 @@\n-      }\n-      \/\/ Don't allow blocking compilation requests to JVMCI\n-      \/\/ if JVMCI itself is not yet initialized\n-      if (!JVMCI::is_compiler_initialized() && compiler(comp_level)->is_jvmci()) {\n-        blocking = false;\n+        \/\/ Don't allow blocking compilation requests to JVMCI\n+        \/\/ if JVMCI itself is not yet initialized\n+        if (!JVMCI::is_compiler_initialized() && compiler(comp_level)->is_jvmci()) {\n+          blocking = false;\n+        }\n@@ -1323,0 +1324,7 @@\n+#if INCLUDE_JVMCI\n+  if (comp->is_jvmci() && !JVMCI::can_initialize_JVMCI()) {\n+    \/\/ JVMCI compilation is not yet initializable.\n+    return nullptr;\n+  }\n+#endif\n+\n@@ -1351,6 +1359,0 @@\n-#if INCLUDE_JVMCI\n-  if (comp->is_jvmci() && !JVMCI::can_initialize_JVMCI()) {\n-    return nullptr;\n-  }\n-#endif\n-\n@@ -2816,4 +2818,7 @@\n-  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : nullptr) : nullptr;\n-  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : nullptr) : nullptr;\n-  Mutex*   function_lock_1 = allFun ? nullptr : (should_take_Compile_lock   ? Compile_lock    : nullptr);\n-  Monitor* function_lock_2 = allFun ? nullptr : (should_take_CodeCache_lock ? CodeCache_lock  : nullptr);\n+  bool take_global_lock_1   =  allFun && should_take_Compile_lock;\n+  bool take_global_lock_2   =  allFun && should_take_CodeCache_lock;\n+  bool take_function_lock_1 = !allFun && should_take_Compile_lock;\n+  bool take_function_lock_2 = !allFun && should_take_CodeCache_lock;\n+  bool take_global_locks    = take_global_lock_1 || take_global_lock_2;\n+  bool take_function_locks  = take_function_lock_1 || take_function_lock_2;\n+\n@@ -2821,3 +2826,4 @@\n-  MutexLocker mu1(global_lock_1, Mutex::_safepoint_check_flag);\n-  MutexLocker mu2(global_lock_2, Mutex::_no_safepoint_check_flag);\n-  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n+\n+  ConditionalMutexLocker mu1(Compile_lock, take_global_lock_1, Mutex::_safepoint_check_flag);\n+  ConditionalMutexLocker mu2(CodeCache_lock, take_global_lock_2, Mutex::_no_safepoint_check_flag);\n+  if (take_global_locks) {\n@@ -2830,3 +2836,3 @@\n-    MutexLocker mu11(function_lock_1, Mutex::_safepoint_check_flag);\n-    MutexLocker mu22(function_lock_2, Mutex::_no_safepoint_check_flag);\n-    if ((function_lock_1 != nullptr) || (function_lock_2 != nullptr)) {\n+    ConditionalMutexLocker mu11(Compile_lock, take_function_lock_1,  Mutex::_safepoint_check_flag);\n+    ConditionalMutexLocker mu22(CodeCache_lock, take_function_lock_2, Mutex::_no_safepoint_check_flag);\n+    if (take_function_locks) {\n@@ -2838,1 +2844,1 @@\n-    if ((function_lock_1 != nullptr) || (function_lock_2 != nullptr)) {\n+    if (take_function_locks) {\n@@ -2859,1 +2865,1 @@\n-  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n+  if (take_global_locks) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -187,2 +187,1 @@\n-    \/\/ don't let the target stack size to be more than 1\/4 of the entries\n-    _target_stack_size = MIN2(GCDrainStackTargetSize, (queue_size \/ 4));\n+    _target_stack_size = GCDrainStackTargetSize;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,2 +250,1 @@\n-  JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,\n-  JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,\n+  JVM_STACKWALK_CLASS_INFO_ONLY            = 0x2,\n@@ -256,0 +255,3 @@\n+JNIEXPORT void JNICALL\n+JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj);\n+\n@@ -257,1 +259,1 @@\n-JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -262,1 +264,1 @@\n-JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n+JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"oops\/method.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/methodCounters.hpp\"\n@@ -731,1 +732,0 @@\n-  declare_constant(ReceiverTypeData::nonprofiled_count_off_set)           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2677,1 +2677,1 @@\n-      MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? nullptr : mdo->extra_data_lock());\n+      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n@@ -3632,2 +3632,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock\n-                 , Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -3674,2 +3673,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -3690,2 +3688,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1194,1 +1194,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1205,1 +1205,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"interpreter\/invocationCounter.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"oops\/methodCounters.hpp\"\n@@ -223,20 +221,3 @@\n-  u2   number_of_breakpoints() const {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs == nullptr) {\n-      return 0;\n-    } else {\n-      return mcs->number_of_breakpoints();\n-    }\n-  }\n-  void incr_number_of_breakpoints(Thread* current) {\n-    MethodCounters* mcs = get_method_counters(current);\n-    if (mcs != nullptr) {\n-      mcs->incr_number_of_breakpoints();\n-    }\n-  }\n-  void decr_number_of_breakpoints(Thread* current) {\n-    MethodCounters* mcs = get_method_counters(current);\n-    if (mcs != nullptr) {\n-      mcs->decr_number_of_breakpoints();\n-    }\n-  }\n+  inline u2 number_of_breakpoints() const;\n+  inline void incr_number_of_breakpoints(Thread* current);\n+  inline void decr_number_of_breakpoints(Thread* current);\n@@ -244,6 +225,1 @@\n-  void clear_number_of_breakpoints() {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs != nullptr) {\n-      mcs->clear_number_of_breakpoints();\n-    }\n-  }\n+  inline void clear_number_of_breakpoints();\n@@ -287,6 +263,1 @@\n-  void interpreter_throwout_increment(Thread* current) {\n-    MethodCounters* mcs = get_method_counters(current);\n-    if (mcs != nullptr) {\n-      mcs->interpreter_throwout_increment();\n-    }\n-  }\n+  inline void interpreter_throwout_increment(Thread* current);\n@@ -295,8 +266,1 @@\n-  int  interpreter_throwout_count() const        {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs == nullptr) {\n-      return 0;\n-    } else {\n-      return mcs->interpreter_throwout_count();\n-    }\n-  }\n+  inline int interpreter_throwout_count() const;\n@@ -363,30 +327,6 @@\n-  int prev_event_count() const {\n-    MethodCounters* mcs = method_counters();\n-    return mcs == nullptr ? 0 : mcs->prev_event_count();\n-  }\n-  void set_prev_event_count(int count) {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs != nullptr) {\n-      mcs->set_prev_event_count(count);\n-    }\n-  }\n-  jlong prev_time() const {\n-    MethodCounters* mcs = method_counters();\n-    return mcs == nullptr ? 0 : mcs->prev_time();\n-  }\n-  void set_prev_time(jlong time) {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs != nullptr) {\n-      mcs->set_prev_time(time);\n-    }\n-  }\n-  float rate() const {\n-    MethodCounters* mcs = method_counters();\n-    return mcs == nullptr ? 0 : mcs->rate();\n-  }\n-  void set_rate(float rate) {\n-    MethodCounters* mcs = method_counters();\n-    if (mcs != nullptr) {\n-      mcs->set_rate(rate);\n-    }\n-  }\n+  inline int prev_event_count() const;\n+  inline void set_prev_event_count(int count);\n+  inline jlong prev_time() const;\n+  inline void set_prev_time(jlong time);\n+  inline float rate() const;\n+  inline void set_rate(float rate);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":12,"deletions":72,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/methodCounters.hpp\"\n@@ -118,0 +119,87 @@\n+#if INCLUDE_JVMTI\n+inline u2 Method::number_of_breakpoints() const {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs == nullptr) {\n+    return 0;\n+  } else {\n+    return mcs->number_of_breakpoints();\n+  }\n+}\n+\n+inline void Method::incr_number_of_breakpoints(Thread* current) {\n+  MethodCounters* mcs = get_method_counters(current);\n+  if (mcs != nullptr) {\n+    mcs->incr_number_of_breakpoints();\n+  }\n+}\n+\n+inline void Method::decr_number_of_breakpoints(Thread* current) {\n+  MethodCounters* mcs = get_method_counters(current);\n+  if (mcs != nullptr) {\n+    mcs->decr_number_of_breakpoints();\n+  }\n+}\n+\n+\/\/ Initialization only\n+inline void Method::clear_number_of_breakpoints() {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs != nullptr) {\n+    mcs->clear_number_of_breakpoints();\n+  }\n+}\n+#endif \/\/ INCLUDE_JVMTI\n+\n+#if COMPILER2_OR_JVMCI\n+inline void Method::interpreter_throwout_increment(Thread* current) {\n+  MethodCounters* mcs = get_method_counters(current);\n+  if (mcs != nullptr) {\n+    mcs->interpreter_throwout_increment();\n+  }\n+}\n+#endif\n+\n+inline int Method::interpreter_throwout_count() const        {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs == nullptr) {\n+    return 0;\n+  } else {\n+    return mcs->interpreter_throwout_count();\n+  }\n+}\n+\n+inline int Method::prev_event_count() const {\n+  MethodCounters* mcs = method_counters();\n+  return mcs == nullptr ? 0 : mcs->prev_event_count();\n+}\n+\n+inline void Method::set_prev_event_count(int count) {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs != nullptr) {\n+    mcs->set_prev_event_count(count);\n+  }\n+}\n+\n+inline jlong Method::prev_time() const {\n+  MethodCounters* mcs = method_counters();\n+  return mcs == nullptr ? 0 : mcs->prev_time();\n+}\n+\n+inline void Method::set_prev_time(jlong time) {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs != nullptr) {\n+    mcs->set_prev_time(time);\n+  }\n+}\n+\n+inline float Method::rate() const {\n+  MethodCounters* mcs = method_counters();\n+  return mcs == nullptr ? 0 : mcs->rate();\n+}\n+\n+inline void Method::set_rate(float rate) {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs != nullptr) {\n+    mcs->set_rate(rate);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -422,4 +422,0 @@\n-#if INCLUDE_JVMCI\n-  st->print_cr(\"count(%u) nonprofiled_count(%u) entries(%u)\", count(), nonprofiled_count(), entries);\n-#else\n-#endif\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"interpreter\/invocationCounter.hpp\"\n@@ -1098,3 +1099,6 @@\n-\/\/ dynamic type check.  It consists of a counter which counts the total times\n-\/\/ that the check is reached, and a series of (Klass*, count) pairs\n-\/\/ which are used to store a type profile for the receiver of the check.\n+\/\/ dynamic type check.  It consists of a series of (Klass*, count)\n+\/\/ pairs which are used to store a type profile for the receiver of\n+\/\/ the check, the associated count is incremented every time the type\n+\/\/ is seen. A per ReceiverTypeData counter is incremented on type\n+\/\/ overflow (when there's no more room for a not yet profiled Klass*).\n+\/\/\n@@ -1106,14 +1110,0 @@\n-#if INCLUDE_JVMCI\n-    \/\/ Description of the different counters\n-    \/\/ ReceiverTypeData for instanceof\/checkcast\/aastore:\n-    \/\/   count is decremented for failed type checks\n-    \/\/   JVMCI only: nonprofiled_count is incremented on type overflow\n-    \/\/ VirtualCallData for invokevirtual\/invokeinterface:\n-    \/\/   count is incremented on type overflow\n-    \/\/   JVMCI only: nonprofiled_count is incremented on method overflow\n-\n-    \/\/ JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile\n-    nonprofiled_count_off_set = counter_cell_count,\n-    receiver0_offset,\n-#else\n-#endif\n@@ -1135,1 +1125,1 @@\n-    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);\n+    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count;\n@@ -1197,7 +1187,0 @@\n-#if INCLUDE_JVMCI\n-    if (!this->is_VirtualCallData()) {\n-      \/\/ if this is a ReceiverTypeData for JVMCI, the nonprofiled_count\n-      \/\/ must also be reset (see \"Description of the different counters\" above)\n-      set_nonprofiled_count(0);\n-    }\n-#endif\n@@ -1213,11 +1196,0 @@\n-#if INCLUDE_JVMCI\n-  static ByteSize nonprofiled_receiver_count_offset() {\n-    return cell_offset(nonprofiled_count_off_set);\n-  }\n-  uint nonprofiled_count() const {\n-    return uint_at(nonprofiled_count_off_set);\n-  }\n-  void set_nonprofiled_count(uint count) {\n-    set_uint_at(nonprofiled_count_off_set, count);\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":8,"deletions":36,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-                                               caller_bci, inline_msg);\n+                                 caller_bci, inlining_result_of(success), inline_msg);\n@@ -550,1 +550,1 @@\n-    C->print_inlining(callee_method, inline_level(), caller_bci, inline_msg);\n+    C->print_inlining(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -783,0 +783,6 @@\n+                                                                            \\\n+  product(intx, TypeProfileSubTypeCheckCommonThreshold, 50,                 \\\n+          \"Use profile data at type check if profiled types account for\"    \\\n+          \"more than this threshold\")                                       \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  virtual void print_inlining_late(const char* msg) {\n+  virtual void print_inlining_late(InliningResult result, const char* msg) {\n@@ -375,1 +375,1 @@\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), msg);\n+    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n@@ -525,1 +525,1 @@\n-  virtual void print_inlining_late(const char* msg) {\n+  virtual void print_inlining_late(InliningResult result, const char* msg) {\n@@ -529,1 +529,1 @@\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), msg);\n+    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n@@ -558,1 +558,1 @@\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n@@ -568,1 +568,1 @@\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  virtual void print_inlining_late(const char* msg) { ShouldNotReachHere(); }\n+  virtual void print_inlining_late(InliningResult result, const char* msg) { ShouldNotReachHere(); }\n@@ -178,3 +178,1 @@\n-    if (C->print_inlining()) {\n-      C->print_inlining(callee, inline_level, bci, msg);\n-    }\n+    print_inlining_impl(C, callee, inline_level, bci, InliningResult::SUCCESS, msg);\n@@ -184,1 +182,1 @@\n-    print_inlining(C, callee, inline_level, bci, msg);\n+    print_inlining_impl(C, callee, inline_level, bci, InliningResult::FAILURE, msg);\n@@ -191,0 +189,8 @@\n+\n+private:\n+  static void print_inlining_impl(Compile* C, ciMethod* callee, int inline_level, int bci,\n+                                  InliningResult result, const char* msg) {\n+    if (C->print_inlining()) {\n+      C->print_inlining(callee, inline_level, bci, result, msg);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-  Node* search_identical(int dist);\n+  Node* search_identical(int dist, PhaseIterGVN* igvn);\n@@ -445,0 +445,2 @@\n+\n+  bool same_condition(const Node* dom, PhaseIterGVN* igvn) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2586,1 +2586,1 @@\n-              cg->print_inlining_late(msg);\n+              cg->print_inlining_late(InliningResult::FAILURE, msg);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -522,1 +522,1 @@\n-  void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = nullptr) {\n+  void print_inlining(ciMethod* method, int inline_level, int bci, InliningResult result, const char* msg = nullptr) {\n@@ -524,1 +524,1 @@\n-    CompileTask::print_inlining_inner(&ss, method, inline_level, bci, msg);\n+    CompileTask::print_inlining_inner(&ss, method, inline_level, bci, result, msg);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      CompileTask::print_inlining_tty(prof_method, depth, bci);\n+      CompileTask::print_inlining_tty(prof_method, depth, bci, InliningResult::SUCCESS);\n@@ -377,1 +377,1 @@\n-      print_inlining(callee, jvms->depth() - 1, jvms->bci(), msg);\n+      print_inlining(callee, jvms->depth() - 1, jvms->bci(), InliningResult::FAILURE, msg);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2812,1 +2812,2 @@\n-Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn) {\n+Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn,\n+                               ciMethod* method, int bci) {\n@@ -2869,1 +2870,3 @@\n-  bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+  const TypeInt* chk_off_t = chk_off->Value(&gvn)->isa_int();\n+  int chk_off_con = (chk_off_t != nullptr && chk_off_t->is_con()) ? chk_off_t->get_con() : cacheoff_con;\n+  bool might_be_cache = (chk_off_con == cacheoff_con);\n@@ -2897,1 +2900,1 @@\n-  if( superklass == nkls )\n+  if (superklass == nkls) {\n@@ -2899,0 +2902,41 @@\n+  }\n+\n+  \/\/ Gather the various success & failures here\n+  RegionNode* r_not_subtype = new RegionNode(3);\n+  gvn.record_for_igvn(r_not_subtype);\n+  RegionNode* r_ok_subtype = new RegionNode(4);\n+  gvn.record_for_igvn(r_ok_subtype);\n+\n+  \/\/ If we might perform an expensive check, first try to take advantage of profile data that was attached to the\n+  \/\/ SubTypeCheck node\n+  if (might_be_cache && method != nullptr && VM_Version::profile_all_receivers_at_type_check()) {\n+    ciCallProfile profile = method->call_profile_at_bci(bci);\n+    float total_prob = 0;\n+    for (int i = 0; profile.has_receiver(i); ++i) {\n+      float prob = profile.receiver_prob(i);\n+      total_prob += prob;\n+    }\n+    if (total_prob * 100. >= TypeProfileSubTypeCheckCommonThreshold) {\n+      const TypeKlassPtr* superk = gvn.type(superklass)->is_klassptr();\n+      for (int i = 0; profile.has_receiver(i); ++i) {\n+        ciKlass* klass = profile.receiver(i);\n+        const TypeKlassPtr* klass_t = TypeKlassPtr::make(klass);\n+        Compile::SubTypeCheckResult result = C->static_subtype_check(superk, klass_t);\n+        if (result != Compile::SSC_always_true && result != Compile::SSC_always_false) {\n+          continue;\n+        }\n+        float prob = profile.receiver_prob(i);\n+        ConNode* klass_node = gvn.makecon(klass_t);\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, klass_node, BoolTest::eq, prob, gvn, T_ADDRESS);\n+        Node* iftrue = gvn.transform(new IfTrueNode(iff));\n+\n+        if (result == Compile::SSC_always_true) {\n+          r_ok_subtype->add_req(iftrue);\n+        } else {\n+          assert(result == Compile::SSC_always_false, \"\");\n+          r_not_subtype->add_req(iftrue);\n+        }\n+        *ctrl = gvn.transform(new IfFalseNode(iff));\n+      }\n+    }\n+  }\n@@ -2914,0 +2958,5 @@\n+    PhaseIterGVN* igvn = gvn.is_IterGVN();\n+    if (igvn != nullptr) {\n+      igvn->remove_globally_dead_node(r_ok_subtype);\n+      igvn->remove_globally_dead_node(r_not_subtype);\n+    }\n@@ -2917,6 +2966,0 @@\n-  \/\/ Gather the various success & failures here\n-  RegionNode *r_ok_subtype = new RegionNode(4);\n-  gvn.record_for_igvn(r_ok_subtype);\n-  RegionNode *r_not_subtype = new RegionNode(3);\n-  gvn.record_for_igvn(r_not_subtype);\n-\n@@ -2990,1 +3033,2 @@\n-    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn);\n+\n+    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn, method(), bci());\n@@ -2995,1 +3039,1 @@\n-  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));\n+  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass, method(), bci()));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/subtypenode.hpp\"\n@@ -1501,1 +1502,1 @@\n-  Node* prev_dom = search_identical(dist);\n+  Node* prev_dom = search_identical(dist, igvn);\n@@ -1576,1 +1577,1 @@\n-Node* IfNode::search_identical(int dist) {\n+Node* IfNode::search_identical(int dist, PhaseIterGVN* igvn) {\n@@ -1582,2 +1583,2 @@\n-  while (dom->Opcode() != op    ||  \/\/ Not same opcode?\n-         dom->in(1)    != in(1) ||  \/\/ Not same input 1?\n+  while (dom->Opcode() != op ||  \/\/ Not same opcode?\n+         !same_condition(dom, igvn) ||  \/\/ Not same input 1?\n@@ -1607,0 +1608,30 @@\n+bool IfNode::same_condition(const Node* dom, PhaseIterGVN* igvn) const {\n+  Node* dom_bool = dom->in(1);\n+  Node* this_bool = in(1);\n+  if (dom_bool == this_bool) {\n+    return true;\n+  }\n+\n+  if (dom_bool == nullptr || !dom_bool->is_Bool() ||\n+      this_bool == nullptr || !this_bool->is_Bool()) {\n+    return false;\n+  }\n+  Node* dom_cmp = dom_bool->in(1);\n+  Node* this_cmp = this_bool->in(1);\n+\n+  \/\/ If the comparison is a subtype check, then SubTypeCheck nodes may have profile data attached to them and may be\n+  \/\/ different nodes even-though they perform the same subtype check\n+  if (dom_cmp == nullptr || !dom_cmp->is_SubTypeCheck() ||\n+      this_cmp == nullptr || !this_cmp->is_SubTypeCheck()) {\n+    return false;\n+  }\n+\n+  if (dom_cmp->in(1) != this_cmp->in(1) ||\n+      dom_cmp->in(2) != this_cmp->in(2) ||\n+      dom_bool->as_Bool()->_test._test != this_bool->as_Bool()->_test._test) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1984,1 +2015,1 @@\n-    prev_dom = search_identical(4);\n+    prev_dom = search_identical(4, igvn);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -124,1 +124,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -150,1 +150,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -152,1 +152,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -193,1 +193,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -195,1 +195,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -211,1 +211,1 @@\n-    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -213,1 +213,1 @@\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, msg);\n+      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1747,0 +1747,3 @@\n+\n+  Node* similar_subtype_check(const Node* x, Node* r_in);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -148,0 +148,3 @@\n+        if (y == nullptr) {\n+          y = similar_subtype_check(x, region->in(i));\n+        }\n@@ -225,0 +228,24 @@\n+\/\/ Subtype checks that carry profile data don't common so look for a replacement by following edges\n+Node* PhaseIdealLoop::similar_subtype_check(const Node* x, Node* r_in) {\n+  if (x->is_SubTypeCheck()) {\n+    Node* in1 = x->in(1);\n+    for (DUIterator_Fast imax, i = in1->fast_outs(imax); i < imax; i++) {\n+      Node* u = in1->fast_out(i);\n+      if (u != x && u->is_SubTypeCheck() && u->in(1) == x->in(1) && u->in(2) == x->in(2)) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* bol = u->fast_out(j);\n+          for (DUIterator_Fast kmax, k = bol->fast_outs(kmax); k < kmax; k++) {\n+            Node* iff = bol->fast_out(k);\n+            \/\/ Only dominating subtype checks are interesting: otherwise we risk replacing a subtype check by another with\n+            \/\/ unrelated profile\n+            if (iff->is_If() && is_dominator(iff, r_in)) {\n+              return u;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1297,1 +1324,1 @@\n-  if (!dom->is_If() || dom->in(1) != n->in(1)) {\n+  if (!dom->is_If() ||  !n->as_If()->same_condition(dom, &_igvn)) {\n@@ -1586,1 +1613,1 @@\n-    if (max > 1 && bol->is_Bool()) {\n+    if (bol->is_Bool() && (max > 1 || bol->in(1)->is_SubTypeCheck())) {\n@@ -1588,1 +1615,2 @@\n-      Node *cutoff = get_ctrl(bol);\n+      Node* cmp = bol->in(1);\n+      Node *cutoff = cmp->is_SubTypeCheck() ? dom_lca(get_ctrl(cmp->in(1)), get_ctrl(cmp->in(2))) : get_ctrl(bol);\n@@ -1594,1 +1622,1 @@\n-        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom &&\n+        if (dom->req() > 1 && n->as_If()->same_condition(dom, &_igvn) && prevdom->in(0) == dom &&\n@@ -1655,0 +1683,6 @@\n+    if (n->in(1) != dom_if->in(1)) {\n+      assert(n->in(1)->in(1)->is_SubTypeCheck() &&\n+             (n->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr ||\n+              dom_if->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr), \"only for subtype checks with profile data attached\");\n+      _igvn.replace_input_of(n, 1, dom_if->in(1));\n+    }\n@@ -4423,0 +4457,6 @@\n+      }\n+\n+      assert(current->vect_type() != nullptr, \"must have vector type\");\n+      if (current->vect_type() != last_ur->vect_type()) {\n+        \/\/ Reductions do not have the same vector type (length and element type).\n+        break; \/\/ Chain traversal fails.\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2728,1 +2728,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, check->method(), check->bci());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn);\n+      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn, nullptr, -1);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,1 +250,18 @@\n-\n+\n+uint SubTypeCheckNode::size_of() const {\n+  return sizeof(*this);\n+}\n+\n+uint SubTypeCheckNode::hash() const {\n+  return NO_HASH;\n+}\n+\n+#ifndef PRODUCT\n+void SubTypeCheckNode::dump_spec(outputStream* st) const {\n+  if (_method != nullptr) {\n+    st->print(\" profiled at: \");\n+    _method->print_short_name(st);\n+    st->print(\":%d\", _bci);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);\n+  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, CHECK);\n@@ -551,0 +551,15 @@\n+JVM_ENTRY(void, JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj))\n+  Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(obj));\n+\n+  bool have_name = (java_lang_StackFrameInfo::name(stack_frame_info()) != nullptr);\n+  bool have_type = (java_lang_StackFrameInfo::type(stack_frame_info()) != nullptr);\n+  Method* method = java_lang_StackFrameInfo::get_method(stack_frame_info());\n+  if (!have_name) {\n+    oop name = StringTable::intern(method->name(), CHECK);\n+    java_lang_StackFrameInfo::set_name(stack_frame_info(), name);\n+  }\n+  if (!have_type) {\n+    Handle type = java_lang_String::create_from_symbol(method->signature(), CHECK);\n+    java_lang_StackFrameInfo::set_type(stack_frame_info(), type());\n+  }\n+JVM_END\n@@ -552,2 +567,1 @@\n-\n-JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -563,1 +577,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n@@ -580,1 +594,1 @@\n-JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n+JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n@@ -583,1 +597,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -420,0 +420,9 @@\n+JvmtiThreadState*\n+JvmtiExport::get_jvmti_thread_state(JavaThread *thread) {\n+  assert(thread == JavaThread::current(), \"must be current thread\");\n+  if (thread->is_vthread_mounted() && thread->jvmti_thread_state() == nullptr) {\n+    JvmtiEventController::thread_started(thread);\n+  }\n+  return thread->jvmti_thread_state();\n+}\n+\n@@ -923,1 +932,1 @@\n-    _state = _thread->jvmti_thread_state();\n+    _state = JvmtiExport::get_jvmti_thread_state(_thread);\n@@ -1215,1 +1224,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1313,1 +1322,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1332,1 +1341,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1340,1 +1349,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1355,1 +1364,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1393,1 +1402,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1522,1 +1531,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1570,1 +1579,1 @@\n-  JvmtiThreadState *state = cur_thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n@@ -1604,1 +1613,1 @@\n-  JvmtiThreadState *state = cur_thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n@@ -1639,1 +1648,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1674,1 +1683,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1707,1 +1716,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1801,1 +1810,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1841,1 +1850,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1962,1 +1971,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2004,1 +2013,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2092,1 +2101,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2208,1 +2217,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2364,1 +2373,1 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2606,1 +2615,1 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2725,1 +2734,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2733,3 +2745,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2758,1 +2767,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2766,3 +2778,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2792,1 +2801,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2800,3 +2812,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2826,1 +2835,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2834,3 +2846,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n-\n@@ -2889,1 +2898,4 @@\n-  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  HandleMark hm(thread);\n+  Handle h(thread, object);\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -2899,2 +2911,0 @@\n-  HandleMark hm(thread);\n-  Handle h(thread, object);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  HIDDEN_MEMBER        = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n@@ -1010,0 +1011,1 @@\n+    template(java_lang_invoke_MemberName,MN_HIDDEN_MEMBER) \\\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -591,2 +591,2 @@\n-    int num_node_ids = (int)numa->num_active_nodes();\n-    const int* node_ids = numa->node_ids();\n+    int num_node_ids = checked_cast<int>(numa->num_active_nodes());\n+    const uint* node_ids = numa->node_ids();\n@@ -596,1 +596,1 @@\n-      result->int_at_put(i, (jint)node_ids[i]);\n+      result->int_at_put(i, checked_cast<jint>(node_ids[i]));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,2 +123,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -145,2 +144,2 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+\n@@ -176,2 +175,2 @@\n-      MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n+      ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+\n@@ -204,2 +203,2 @@\n-        MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                       Mutex::_no_safepoint_check_flag);\n+        ConditionalMutexLocker ml(CompiledMethod_lock, !CompiledMethod_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-    BasicType result_type,\n+    int       result_type, \/* BasicType on 4 bytes *\/\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,14 @@\n+            if (CDS.isSharingEnabled()) {\n+                \/\/ load from CDS archive if present\n+                Class<?> innerClass = LambdaProxyClassArchive.find(targetClass,\n+                                                                   interfaceMethodName,\n+                                                                   factoryType,\n+                                                                   interfaceMethodType,\n+                                                                   implementation,\n+                                                                   dynamicMethodType,\n+                                                                   isSerializable,\n+                                                                   altInterfaces,\n+                                                                   altMethods);\n+                if (innerClass != null) return innerClass;\n+            }\n+\n@@ -276,11 +290,0 @@\n-            \/\/ load from CDS archive if present\n-            Class<?> innerClass = LambdaProxyClassArchive.find(targetClass,\n-                                                               interfaceMethodName,\n-                                                               factoryType,\n-                                                               interfaceMethodType,\n-                                                               implementation,\n-                                                               dynamicMethodType,\n-                                                               isSerializable,\n-                                                               altInterfaces,\n-                                                               altMethods);\n-            if (innerClass != null) return innerClass;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -69,5 +69,0 @@\n-\/*non-public*\/\n-final class ResolvedMethodName {\n-    \/\/@Injected JVM_Method* vmtarget;\n-    \/\/@Injected Class<?>    vmholder;\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,1 +119,2 @@\n-            MN_FLATTENED             = 0x00400000, \/\/ flattened field\n+            MN_HIDDEN_MEMBER         = 0x00400000, \/\/ members defined in a hidden class or with @Hidden\n+            MN_FLATTENED             = 0x00800000, \/\/ flattened field\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1072,0 +1072,1 @@\n+    int ACC_VALUE    = 0x0040;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4969,1 +4969,1 @@\n-                                   TreeInfo.unguardedCase(testCase)) {\n+                                   (testCase.equals(c) || TreeInfo.unguardedCase(testCase))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1341,2 +1341,3 @@\n-            boolean[] hasTry = new boolean[1];\n-            new TreeScanner() {\n+            class HasTryScanner extends TreeScanner {\n+                private boolean hasTry;\n+\n@@ -1345,1 +1346,6 @@\n-                    hasTry[0] = true;\n+                    hasTry = true;\n+                }\n+\n+                @Override\n+                public void visitSynchronized(JCSynchronized tree) {\n+                    hasTry = true;\n@@ -1355,2 +1361,6 @@\n-            }.scan(tree);\n-            return hasTry[0];\n+            };\n+\n+            HasTryScanner hasTryScanner = new HasTryScanner();\n+\n+            hasTryScanner.scan(tree);\n+            return hasTryScanner.hasTry;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-        final int nonprofiledCountOffset = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);\n@@ -70,2 +69,2 @@\n-        final int typeCheckDataSize = cellIndexToOffset(2) + typeDataRowSize * config.typeProfileWidth;\n-        final int virtualCallDataSize = cellIndexToOffset(2) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);\n+        final int typeCheckDataSize = cellIndexToOffset(1) + typeDataRowSize * config.typeProfileWidth;\n+        final int virtualCallDataSize = cellIndexToOffset(1) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);\n@@ -507,1 +506,1 @@\n-            totalCount += getTypesNotRecordedExecutionCount(data, position);\n+            totalCount += getCounterValue(data, position);\n@@ -511,6 +510,0 @@\n-        protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);\n-\n-        public int getNonprofiledCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -551,2 +544,2 @@\n-            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n-                            getNonprofiledCount(data, pos), profile.entries));\n+            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n+                            profile.entries));\n@@ -575,5 +568,0 @@\n-\n-        @Override\n-        protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return getNonprofiledCount(data, position);\n-        }\n@@ -605,9 +593,0 @@\n-        @Override\n-        protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return getCounterValue(data, position);\n-        }\n-\n-        private long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -639,2 +618,0 @@\n-            totalCount += getMethodsNotRecordedExecutionCount(data, position);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -381,1 +381,0 @@\n-    final int receiverTypeDataNonprofiledCountOffset = getConstant(\"ReceiverTypeData::nonprofiled_count_off_set\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1101,0 +1101,2 @@\n+     *\n+     * @deprecated Use {@link java.util.concurrent.locks.LockSupport#unpark(Thread)} instead.\n@@ -1102,0 +1104,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n@@ -1117,0 +1120,3 @@\n+     *\n+     * @deprecated Use {@link java.util.concurrent.locks.LockSupport#parkNanos(long)} or\n+     * {@link java.util.concurrent.locks.LockSupport#parkUntil(long)} instead.\n@@ -1118,0 +1124,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n@@ -1137,0 +1144,3 @@\n+     *\n+     * @deprecated Use {@link java.lang.management.OperatingSystemMXBean#getSystemLoadAverage()}\n+     * instead.\n@@ -1138,0 +1148,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n@@ -1226,1 +1237,0 @@\n-\n@@ -1237,0 +1247,2 @@\n+     *\n+     * @deprecated Use {@link java.lang.invoke.VarHandle#acquireFence()} instead.\n@@ -1239,0 +1251,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n@@ -1254,0 +1267,2 @@\n+     *\n+     * @deprecated Use {@link java.lang.invoke.VarHandle#releaseFence()} instead.\n@@ -1256,0 +1271,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n@@ -1268,0 +1284,2 @@\n+     *\n+     * @deprecated Use {@link java.lang.invoke.VarHandle#fullFence()} instead.\n@@ -1270,0 +1288,1 @@\n+    @Deprecated(since=\"22\", forRemoval=true)\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java 8315969 generic-all\n+\n@@ -128,1 +130,1 @@\n-serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64\n+serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64,aix-ppc64\n@@ -194,1 +196,1 @@\n-vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-x64\n+vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -214,3 +214,3 @@\n-            output.shouldNotMatch(\"TestNull::testArg .* inline\");\n-            output.shouldNotMatch(\"TestNull::testRet .* inline\");\n-            output.shouldNotMatch(\"TestNull::test .* inline\");\n+            output.shouldMatch(\"TestNull::testArg .* failed to inline\");\n+            output.shouldMatch(\"TestNull::testRet .* failed to inline\");\n+            output.shouldMatch(\"TestNull::test .* failed to inline\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/unloaded\/TestInlineUnloaded.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -435,0 +435,5 @@\n+    public static final String CMP_P = PREFIX + \"CMP_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_P, \"CmpP\");\n+    }\n+\n@@ -632,0 +637,10 @@\n+    public static final String LOAD_NKLASS = PREFIX + \"LOAD_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_NKLASS, \"LoadNKlass\");\n+    }\n+\n+    public static final String LOAD_KLASS_OR_NKLASS = PREFIX + \"LOAD_KLASS_OR_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_KLASS_OR_NKLASS, \"LoadN?Klass\");\n+    }\n+\n@@ -1056,0 +1071,5 @@\n+    public static final String PARTIAL_SUBTYPE_CHECK = PREFIX + \"PARTIAL_SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PARTIAL_SUBTYPE_CHECK, \"PartialSubtypeCheck\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64\n@@ -133,0 +134,1 @@\n+java\/awt\/Focus\/NonFocusableWindowTest\/NonfocusableOwnerTest.java 8280392 windows-x64\n@@ -140,0 +142,1 @@\n+java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8294264 windows-x64\n@@ -440,1 +443,1 @@\n-java\/awt\/PopupMenu\/PopupMenuLocation.java 8238720 windows-all\n+java\/awt\/PopupMenu\/PopupMenuLocation.java 8238720,8315878 windows-all,macosx-aarch64\n@@ -463,0 +466,4 @@\n+# Several tests which fail on some hidpi systems\/macosx12-aarch64 system\n+java\/awt\/Window\/8159168\/SetShapeTest.java 8274106 macosx-aarch64\n+java\/awt\/image\/multiresolution\/MultiResolutionJOptionPaneIconTest.java 8274106 macosx-aarch64\n+\n@@ -657,2 +664,0 @@\n-java\/awt\/Window\/8159168\/SetShapeTest.java 8274106 macosx-aarch64\n-java\/awt\/image\/multiresolution\/MultiResolutionJOptionPaneIconTest.java 8274106 macosx-aarch64\n@@ -661,5 +666,0 @@\n-java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n-java\/awt\/Focus\/NonFocusableWindowTest\/NonfocusableOwnerTest.java 8280392 windows-x64\n-java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8294264 windows-x64\n-\n-java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -36,2 +41,3 @@\n-import com.sun.tools.classfile.*;\n-import static com.sun.tools.classfile.AccessFlags.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n@@ -50,1 +56,1 @@\n-        { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+        { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -55,1 +61,1 @@\n-            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+            { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -63,1 +69,1 @@\n-            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+            { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -68,1 +74,1 @@\n-        { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+        { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -73,1 +79,1 @@\n-            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+            { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -81,1 +87,1 @@\n-            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n+            { anonClasses.put(getClass().getName(), Classfile.ACC_IDENTITY); }\n@@ -92,1 +98,1 @@\n-        ClassFile outerClass = ClassFile.read(outerFile);\n+        ClassModel outerClass = Classfile.of().parse(outerFile);\n@@ -95,1 +101,1 @@\n-            ClassFile innerClass = ClassFile.read(innerFile);\n+            ClassModel innerClass = Classfile.of().parse(innerFile);\n@@ -104,3 +110,3 @@\n-    static void assertClassFlags(ClassFile classFile, String name, int expected) {\n-        int mask = ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n-                   ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM | ACC_IDENTITY;\n+    static void assertClassFlags(ClassModel classFile, String name, int expected) {\n+        int mask = Classfile.ACC_PUBLIC | Classfile.ACC_FINAL | Classfile.ACC_INTERFACE | Classfile.ACC_ABSTRACT |\n+                   Classfile.ACC_SYNTHETIC | Classfile.ACC_ANNOTATION | Classfile.ACC_ENUM | Classfile.ACC_IDENTITY;\n@@ -108,1 +114,1 @@\n-        int classActual = classFile.access_flags.flags;\n+        int classActual = classFile.flags().flagsMask();\n@@ -116,2 +122,2 @@\n-    static void assertInnerFlags(ClassFile classFile, String name, int expected) throws ConstantPoolException {\n-        int innerActual = lookupInnerFlags(classFile, name).flags;\n+    static void assertInnerFlags(ClassModel classFile, String name, int expected) {\n+        int innerActual = lookupInnerFlags(classFile, name);\n@@ -120,1 +126,1 @@\n-                                     \" in class \" + classFile.getName() +\n+                                     \" in class \" + classFile.thisClass().asInternalName() +\n@@ -125,2 +131,2 @@\n-    private static AccessFlags lookupInnerFlags(ClassFile classFile, String innerName) throws ConstantPoolException {\n-        InnerClasses_attribute inners = (InnerClasses_attribute) classFile.getAttribute(\"InnerClasses\");\n+    private static int lookupInnerFlags(ClassModel classFile, String innerName) {\n+        InnerClassesAttribute inners = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n@@ -128,1 +134,1 @@\n-            throw new AssertionError(\"InnerClasses attribute missing in class \" + classFile.getName());\n+            throw new AssertionError(\"InnerClasses attribute missing in class \" + classFile.thisClass().asInternalName());\n@@ -130,2 +136,2 @@\n-        for (InnerClasses_attribute.Info info : inners.classes) {\n-            String entryName = info.getInnerClassInfo(classFile.constant_pool).getName();\n+        for (InnerClassInfo info: inners.classes()) {\n+            String entryName = info.innerClass().asInternalName();\n@@ -133,1 +139,1 @@\n-                return info.inner_class_access_flags;\n+                return info.flagsMask();\n@@ -136,1 +142,1 @@\n-        throw new AssertionError(\"No InnerClasses entry in class \" + classFile.getName() + \" for class \" + innerName);\n+        throw new AssertionError(\"No InnerClasses entry in class \" + classFile.thisClass().asInternalName() + \" for class \" + innerName);\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n- *  @modules jdk.jdeps\/com.sun.tools.classfile\n+ *  @modules java.base\/jdk.internal.classfile\n+ *           java.base\/jdk.internal.classfile.attribute\n+ *           java.base\/jdk.internal.classfile.constantpool\n+ *           java.base\/jdk.internal.classfile.instruction\n+ *           java.base\/jdk.internal.classfile.components\n+ *           java.base\/jdk.internal.classfile.impl\n@@ -35,1 +40,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -39,1 +45,1 @@\n-    public static void main(String[] args) throws IOException, ConstantPoolException {\n+    public static void main(String[] args) throws IOException {\n@@ -43,1 +49,1 @@\n-    private void run() throws IOException, ConstantPoolException {\n+    private void run() throws IOException {\n@@ -45,5 +51,5 @@\n-        for (File classFile : testClasses.listFiles(f -> f.getName().endsWith(\".class\"))) {\n-            ClassFile cf = ClassFile.read(classFile);\n-            if ((cf.access_flags.flags & (AccessFlags.ACC_SYNTHETIC | AccessFlags.ACC_VALUE | AccessFlags.ACC_ABSTRACT)) == AccessFlags.ACC_SYNTHETIC) {\n-                if ((cf.access_flags.flags & AccessFlags.ACC_IDENTITY) == 0) {\n-                    throw new IllegalStateException(\"Missing ACC_IDENTITY on synthetic concrete identity class: \" + cf.getName());\n+        for (File classFile : Objects.requireNonNull(testClasses.listFiles(f -> f.getName().endsWith(\".class\")))) {\n+            ClassModel cf = Classfile.of().parse(classFile.toPath());\n+            if ((cf.flags().flagsMask() & (Classfile.ACC_SYNTHETIC | Classfile.ACC_VALUE | Classfile.ACC_ABSTRACT)) == Classfile.ACC_SYNTHETIC) {\n+                if ((cf.flags().flagsMask() & Classfile.ACC_IDENTITY) == 0) {\n+                    throw new IllegalStateException(\"Missing ACC_IDENTITY on synthetic concrete identity class: \" + cf.thisClass().asInternalName());\n@@ -52,3 +58,2 @@\n-            if (cf.getName().matches(\".*\\\\$[0-9]+\")) {\n-                EnclosingMethod_attribute encl =\n-                        (EnclosingMethod_attribute) cf.getAttribute(Attribute.EnclosingMethod);\n+            if (cf.thisClass().asInternalName().matches(\".*\\\\$[0-9]+\")) {\n+                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.ENCLOSING_METHOD).orElse(null);\n@@ -56,3 +61,3 @@\n-                    if (encl.method_index != 0)\n-                        throw new IllegalStateException(\"Invalid EnclosingMethod.method_index: \" +\n-                                                        encl.method_index + \".\");\n+                    if (encl.enclosingMethodName().isPresent())\n+                        throw new IllegalStateException(\"Invalid EnclosingMethod.method: \" +\n+                                                        encl.enclosingMethodName().get().stringValue() + \".\");\n@@ -61,2 +66,1 @@\n-            InnerClasses_attribute attr =\n-                    (InnerClasses_attribute) cf.getAttribute(Attribute.InnerClasses);\n+            InnerClassesAttribute attr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n@@ -64,2 +68,2 @@\n-                for (InnerClasses_attribute.Info info : attr.classes) {\n-                    if (cf.major_version < 51)\n+                for (InnerClassInfo info : attr.classes()) {\n+                    if (cf.majorVersion() < 51)\n@@ -67,5 +71,4 @@\n-                    if (info.inner_name_index == 0 && info.outer_class_info_index != 0)\n-                        throw new IllegalStateException(\"Invalid outer_class_info_index=\" +\n-                                                        info.outer_class_info_index +\n-                                                        \"; inner_name_index=\" +\n-                                                        info.inner_name_index + \".\");\n+                    if (info.innerName().isEmpty() && info.outerClass().isPresent() )\n+                        throw new IllegalStateException(\"Invalid outer_class_info: \" +\n+                                                        info.outerClass().get().asInternalName() +\n+                                                        \"; inner_name is empty\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/InnerClasses\/SyntheticClasses.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -30,1 +30,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -37,1 +42,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -493,4 +499,4 @@\n-            ClassFile cf = ClassFile.read(in);\n-            for (ConstantPool.CPInfo cpinfo: cf.constant_pool.entries()) {\n-                if (cpinfo.getTag() == ConstantPool.CONSTANT_Utf8) {\n-                    String v = ((ConstantPool.CONSTANT_Utf8_info) cpinfo).value;\n+            ClassModel cm = Classfile.of().parse(in.readAllBytes());\n+            for (int i = 1; i < cm.constantPool().entryCount(); ++i) {\n+                if (cm.constantPool().entryByIndex(i) instanceof Utf8Entry entry) {\n+                    String v = entry.stringValue();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,6 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n+ *      java.base\/jdk.internal.classfile.impl\n@@ -44,7 +49,1 @@\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -73,20 +72,5 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n-import com.sun.tools.classfile.RuntimeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.TypeAnnotation;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n@@ -1292,1 +1276,1 @@\n-            for (final File fileEntry : dir.listFiles()) {\n+            for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1294,3 +1278,3 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (CPInfo cpInfo : classFile.constant_pool.entries()) {\n-                        if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {\n+                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    for (int i = 1; i < classFile.constantPool().entryCount(); ++i) {\n+                        if (classFile.constantPool().entryByIndex(i) instanceof FieldRefEntry fieldRefEntry) {\n@@ -1298,4 +1282,3 @@\n-                            ConstantPool.CONSTANT_NameAndType_info nameAndType =\n-                                    (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool\n-                                            .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);\n-                            Assert.check(nameAndType.getName().equals(\"recordComponent\"));\n+                            NameAndTypeEntry nameAndType = (NameAndTypeEntry) classFile.constantPool()\n+                                            .entryByIndex(fieldRefEntry.nameAndType().index());\n+                            Assert.check(nameAndType.name().equalsString(\"recordComponent\"));\n@@ -1313,2 +1296,2 @@\n-        int putField1 = -1;\n-        int putField2 = -1;\n+        FieldInstruction putField1 = null;\n+        FieldInstruction putField2 = null;\n@@ -1316,1 +1299,1 @@\n-        for (final File fileEntry : dir.listFiles()) {\n+        for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1318,7 +1301,7 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                        Code_attribute code_attribute = (Code_attribute) method.attributes.get(\"Code\");\n-                        for (Instruction instruction : code_attribute.getInstructions()) {\n-                            if (instruction.getMnemonic().equals(\"putfield\")) {\n-                                if (putField1 != -1 && putField2 != -1) {\n+                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                for (MethodModel method : classFile.methods()) {\n+                    if (method.methodName().equalsString(\"<init>\")) {\n+                        CodeAttribute code_attribute = method.findAttribute(Attributes.CODE).orElseThrow();\n+                        for (CodeElement ce : code_attribute.elementList()) {\n+                            if (ce instanceof Instruction instruction && instruction.opcode() == Opcode.PUTFIELD) {\n+                                if (putField1 != null && putField2 != null) {\n@@ -1327,4 +1310,4 @@\n-                                if (putField1 == -1) {\n-                                    putField1 = instruction.getShort(1);\n-                                } else if (putField2 == -1) {\n-                                    putField2 = instruction.getShort(1);\n+                                if (putField1 == null) {\n+                                    putField1 = (FieldInstruction) instruction;\n+                                } else {\n+                                    putField2 = (FieldInstruction) instruction;\n@@ -1335,2 +1318,3 @@\n-                        CONSTANT_Fieldref_info fieldref_info1 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField1);\n-                        if (!fieldref_info1.getNameAndTypeInfo().getName().equals(\"i\")) {\n+                        assert putField1 != null;\n+                        FieldRefEntry fieldref_info1 = putField1.field();\n+                        if (!fieldref_info1.name().equalsString(\"i\")) {\n@@ -1339,3 +1323,3 @@\n-\n-                        CONSTANT_Fieldref_info fieldref_info2 = (CONSTANT_Fieldref_info)classFile.constant_pool.get(putField2);\n-                        if (!fieldref_info2.getNameAndTypeInfo().getName().equals(\"s\")) {\n+                        assert putField2 != null;\n+                        FieldRefEntry fieldref_info2 = putField2.field();\n+                        if (!fieldref_info2.name().equalsString(\"s\")) {\n@@ -1462,1 +1446,1 @@\n-                ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+                ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1465,2 +1449,2 @@\n-                Assert.check(classFile.fields.length == 1);\n-                Field field = classFile.fields[0];\n+                Assert.check(classFile.fields().size() == 1);\n+                FieldModel field = classFile.fields().get(0);\n@@ -1470,4 +1454,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    field.attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1476,1 +1457,1 @@\n-                    assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(field.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1481,5 +1462,2 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n-                            \"FIELD\",\n-                            \"Anno\");\n+                    checkTypeAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n+                            \"FIELD\", \"Anno\");\n@@ -1487,1 +1465,1 @@\n-                    assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1491,1 +1469,1 @@\n-                Method init = findMethodOrFail(classFile, \"<init>\");\n+                MethodModel init = findMethodOrFail(classFile, \"<init>\");\n@@ -1495,4 +1473,4 @@\n-                    checkParameterAnno(classFile,\n-                            (RuntimeVisibleParameterAnnotations_attribute) findAttributeOrFail(\n-                                    init.attributes,\n-                                    RuntimeVisibleParameterAnnotations_attribute.class),\n+                    checkParameterAnno(\n+                            (RuntimeVisibleParameterAnnotationsAttribute) findAttributeOrFail(\n+                                    init.attributes(),\n+                                    RuntimeVisibleParameterAnnotationsAttribute.class),\n@@ -1501,1 +1479,1 @@\n-                    assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(init.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1505,3 +1483,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1510,1 +1486,1 @@\n-                    assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1514,1 +1490,1 @@\n-                Method accessor = findMethodOrFail(classFile, \"s\");\n+                MethodModel accessor = findMethodOrFail(classFile, \"s\");\n@@ -1518,4 +1494,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    accessor.attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1524,1 +1497,1 @@\n-                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(accessor.attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1528,3 +1501,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1533,1 +1504,1 @@\n-                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1537,2 +1508,2 @@\n-                Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n-                Assert.check(record.component_count == 1);\n+                RecordAttribute record = (RecordAttribute) findAttributeOrFail(classFile.attributes(), RecordAttribute.class);\n+                Assert.check(record.components().size() == 1);\n@@ -1542,4 +1513,1 @@\n-                    checkAnno(classFile,\n-                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n-                                    record.component_info_arr[0].attributes,\n-                                    RuntimeVisibleAnnotations_attribute.class),\n+                    checkAnno(findAttributeOrFail(record.components().get(0).attributes(), RuntimeVisibleAnnotationsAttribute.class),\n@@ -1548,1 +1516,1 @@\n-                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);\n+                    assertAttributeNotPresent(record.components().get(0).attributes(), RuntimeVisibleAnnotationsAttribute.class);\n@@ -1552,5 +1520,1 @@\n-                    checkTypeAnno(\n-                            classFile,\n-                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n-                                    record.component_info_arr[0].attributes,\n-                                    RuntimeVisibleTypeAnnotations_attribute.class),\n+                    checkTypeAnno(findAttributeOrFail(record.components().get(0).attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1559,1 +1523,1 @@\n-                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                    assertAttributeNotPresent(record.components().get(0).attributes(), RuntimeVisibleTypeAnnotationsAttribute.class);\n@@ -1584,1 +1548,1 @@\n-        ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+        ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1587,5 +1551,3 @@\n-        Assert.check(classFile.fields.length == 1);\n-        Field field = classFile.fields[0];\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        Assert.check(classFile.fields().size() == 1);\n+        FieldModel field = classFile.fields().get(0);\n+        checkTypeAnno(findAttributeOrFail(field.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1596,4 +1558,2 @@\n-        Method init = findMethodOrFail(classFile, \"<init>\");\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        MethodModel init = findMethodOrFail(classFile, \"<init>\");\n+        checkTypeAnno(findAttributeOrFail(init.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1603,4 +1563,2 @@\n-        Method accessor = findMethodOrFail(classFile, \"s\");\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+        MethodModel accessor = findMethodOrFail(classFile, \"s\");\n+        checkTypeAnno(findAttributeOrFail(accessor.attributes(), RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1610,7 +1568,4 @@\n-        Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n-        Assert.check(record.component_count == 1);\n-        checkTypeAnno(\n-                classFile,\n-                (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n-                            record.component_info_arr[0].attributes,\n-                                RuntimeVisibleTypeAnnotations_attribute.class),\n+        RecordAttribute record = (RecordAttribute) findAttributeOrFail(classFile.attributes(), RecordAttribute.class);\n+        Assert.check(record.components().size() == 1);\n+        checkTypeAnno(findAttributeOrFail(record.components().get(0).attributes(),\n+                                RuntimeVisibleTypeAnnotationsAttribute.class),\n@@ -1620,2 +1575,1 @@\n-    private void checkTypeAnno(ClassFile classFile,\n-                               RuntimeTypeAnnotations_attribute rtAnnos,\n+    private void checkTypeAnno(Attribute<?> rtAnnos,\n@@ -1623,1 +1577,1 @@\n-                               String annoName) throws Exception {\n+                               String annoName) {\n@@ -1625,4 +1579,15 @@\n-        Assert.check(rtAnnos.annotations.length == 1);\n-        TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];\n-        Assert.check(tAnno.position.type.toString().equals(positionType));\n-        String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);\n+        TypeAnnotation tAnno;\n+        switch (rtAnnos) {\n+            case RuntimeVisibleTypeAnnotationsAttribute rtVAnnos -> {\n+                Assert.check(rtVAnnos.annotations().size() == 1);\n+                tAnno = rtVAnnos.annotations().get(0);\n+            }\n+            case RuntimeInvisibleTypeAnnotationsAttribute rtIAnnos -> {\n+                Assert.check(rtIAnnos.annotations().size() == 1);\n+                tAnno = rtIAnnos.annotations().get(0);\n+            }\n+            default -> throw new AssertionError();\n+        }\n+        assert tAnno != null;\n+        Assert.check(tAnno.targetInfo().targetType().name().equals(positionType));\n+        String annotationName = tAnno.classSymbol().displayName();\n@@ -1631,4 +1596,2 @@\n-\n-    private void checkAnno(ClassFile classFile,\n-                           RuntimeAnnotations_attribute rAnnos,\n-                           String annoName) throws Exception {\n+    private void checkAnno(Attribute<?> rAnnos,\n+                           String annoName) {\n@@ -1636,3 +1599,14 @@\n-        Assert.check(rAnnos.annotations.length == 1);\n-        Annotation anno = (Annotation)rAnnos.annotations[0];\n-        String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);\n+        Annotation anno;\n+        switch (rAnnos) {\n+            case RuntimeVisibleAnnotationsAttribute rVAnnos -> {\n+                Assert.check(rVAnnos.annotations().size() == 1);\n+                anno = rVAnnos.annotations().get(0);\n+            }\n+            case RuntimeInvisibleAnnotationsAttribute rIAnnos -> {\n+                Assert.check(rIAnnos.annotations().size() == 1);\n+                anno = rIAnnos.annotations().get(0);\n+            }\n+            default -> throw new AssertionError();\n+        }\n+        assert anno != null;\n+        String annotationName = anno.classSymbol().displayName();\n@@ -1643,3 +1617,2 @@\n-    private void checkParameterAnno(ClassFile classFile,\n-                           RuntimeVisibleParameterAnnotations_attribute rAnnos,\n-                           String annoName) throws Exception {\n+    private void checkParameterAnno(RuntimeVisibleParameterAnnotationsAttribute rAnnos,\n+                           String annoName) {\n@@ -1647,4 +1620,4 @@\n-        Assert.check(rAnnos.parameter_annotations.length == 1);\n-        Assert.check(rAnnos.parameter_annotations[0].length == 1);\n-        Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];\n-        String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);\n+        Assert.check(rAnnos.parameterAnnotations().size() == 1);\n+        Assert.check(rAnnos.parameterAnnotations().get(0).size() == 1);\n+        Annotation anno = rAnnos.parameterAnnotations().get(0).get(0);\n+        String annotationName = anno.classSymbol().displayName();\n@@ -1656,1 +1629,1 @@\n-            if (fileEntry.getName().equals(\"R.class\")) {\n+            if (fileEntry.getName().equals(name)) {\n@@ -1663,3 +1636,3 @@\n-    private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(name)) {\n+    private MethodModel findMethodOrFail(ClassModel classFile, String name) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(name)) {\n@@ -1672,3 +1645,3 @@\n-    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass) {\n-        for (Attribute attribute : attributes) {\n-            if (attribute.getClass() == attrClass) {\n+    private Attribute<?> findAttributeOrFail(List<Attribute<?>> attributes, Class<? extends Attribute<?>> attrClass) {\n+        for (Attribute<?> attribute : attributes) {\n+            if (attrClass.isAssignableFrom(attribute.getClass())) {\n@@ -1678,1 +1651,1 @@\n-        throw new AssertionError(\"attribute not found\");\n+        throw new AssertionError(\"attribute not found\" + attrClass.toString() + \"!!!!\" + attributes.getFirst().getClass().toString());\n@@ -1681,2 +1654,2 @@\n-    private void assertAttributeNotPresent(Attributes attributes, Class<? extends Attribute> attrClass) {\n-        for (Attribute attribute : attributes) {\n+    private void assertAttributeNotPresent(List<Attribute<?>> attributes, Class<? extends Attribute<?>> attrClass) {\n+        for (Attribute<?> attribute : attributes) {\n@@ -1720,1 +1693,1 @@\n-                    case FIELD:\n+                    case FIELD -> {\n@@ -1723,2 +1696,2 @@\n-                        break;\n-                    case METHOD:\n+                    }\n+                    case METHOD -> {\n@@ -1727,2 +1700,2 @@\n-                        break;\n-                    case PARAMETER:\n+                    }\n+                    case PARAMETER -> {\n@@ -1731,2 +1704,2 @@\n-                        break;\n-                    case RECORD_COMPONENT:\n+                    }\n+                    case RECORD_COMPONENT -> {\n@@ -1735,3 +1708,2 @@\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"unexpected element kind\");\n+                    }\n+                    default -> throw new AssertionError(\"unexpected element kind\");\n@@ -1789,1 +1761,1 @@\n-        for (final File fileEntry : dir.listFiles()) {\n+        for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1791,3 +1763,3 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods)\n-                    switch (method.getName(classFile.constant_pool)) {\n+                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                for (MethodModel method : classFile.methods())\n+                    switch (method.methodName().stringValue()) {\n@@ -1795,1 +1767,1 @@\n-                            Assert.check(method.access_flags.is(AccessFlags.ACC_PUBLIC) && method.access_flags.is(AccessFlags.ACC_FINAL));\n+                            Assert.check(((method.flags().flagsMask() & Classfile.ACC_PUBLIC) != 0) && ((method.flags().flagsMask() & Classfile.ACC_FINAL) != 0));\n@@ -1821,1 +1793,1 @@\n-            for (final File fileEntry : dir.listFiles()) {\n+            for (final File fileEntry : Objects.requireNonNull(dir.listFiles())) {\n@@ -1823,5 +1795,5 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (Method method : classFile.methods)\n-                        if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                            Assert.check(method.access_flags.flags == accessFlag(a),\n-                                    \"was expecting access flag \" + accessFlag(a) + \" but found \" + method.access_flags.flags);\n+                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    for (MethodModel method : classFile.methods())\n+                        if (method.methodName().equalsString(\"<init>\")) {\n+                            Assert.check(method.flags().flagsMask() == accessFlag(a),\n+                                    \"was expecting access flag \" + accessFlag(a) + \" but found \" + method.flags().flagsMask());\n@@ -1835,8 +1807,7 @@\n-        switch (access) {\n-            case \"private\": return 3;\n-            case \"protected\": return 1;\n-            case \"public\": return 0;\n-            case \"\": return 2;\n-            default:\n-                throw new AssertionError();\n-        }\n+        return switch (access) {\n+            case \"private\" -> 3;\n+            case \"protected\" -> 1;\n+            case \"public\" -> 0;\n+            case \"\" -> 2;\n+            default -> throw new AssertionError();\n+        };\n@@ -1846,8 +1817,7 @@\n-        switch (access) {\n-            case \"private\": return AccessFlags.ACC_PRIVATE;\n-            case \"protected\": return AccessFlags.ACC_PROTECTED;\n-            case \"public\": return AccessFlags.ACC_PUBLIC;\n-            case \"\": return 0;\n-            default:\n-                throw new AssertionError();\n-        }\n+        return switch (access) {\n+            case \"private\" -> Classfile.ACC_PRIVATE;\n+            case \"protected\" -> Classfile.ACC_PROTECTED;\n+            case \"public\" -> Classfile.ACC_PUBLIC;\n+            case \"\" -> 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2104,1 +2074,1 @@\n-            \/\/ dont execute this test when the default annotation processor is on as it will fail due to\n+            \/\/ don't execute this test when the default annotation processor is on as it will fail due to\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":162,"deletions":192,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaClass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}