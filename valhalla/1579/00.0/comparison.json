{"files":[{"patch":"@@ -1768,3 +1768,0 @@\n-  \/\/ insert a nop at the start of the prolog so we can patch in a\n-  \/\/ branch if we need to invalidate the method later\n-  __ nop();\n@@ -2170,4 +2167,0 @@\n-    \/\/ insert a nop at the start of the prolog so we can patch in a\n-    \/\/ branch if we need to invalidate the method later\n-    __ nop();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1125,2 +1125,1 @@\n-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n@@ -1131,1 +1130,0 @@\n-    \/\/ Otherwise, assign to mdp\n@@ -1135,15 +1133,2 @@\n-    \/\/ We inline increment_mdp_data_at to return bumped_count in a register\n-    \/\/increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    ldr(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    \/\/ Intel does this to catch overflow\n-    \/\/ addptr(bumped_count, DataLayout::counter_increment);\n-    \/\/ sbbptr(bumped_count, 0);\n-    \/\/ so we do this\n-    adds(bumped_count, bumped_count, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       \/\/ skip store if counter overflow\n-    str(bumped_count, data);\n-    bind(L);\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n+\n@@ -1164,1 +1149,1 @@\n-    \/\/ We are taking a branch.  Increment the not taken count.\n+    \/\/ We are not taking a branch.  Increment the not taken count.\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-  void profile_taken_branch(Register mdp, Register bumped_count);\n+  void profile_taken_branch(Register mdp);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1817,1 +1817,1 @@\n-  __ profile_taken_branch(r0, r1);\n+  __ profile_taken_branch(r0);\n@@ -1867,1 +1867,0 @@\n-    \/\/ w1: MDO bumped taken-count\n@@ -1878,1 +1877,0 @@\n-    __ push(r1);\n@@ -1883,1 +1881,0 @@\n-    __ pop(r1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -346,10 +346,0 @@\n-  if (breakAtEntry) {\n-    \/\/ Verified Entry first instruction should be 5 bytes long for correct\n-    \/\/ patching by patch_verified_entry().\n-    \/\/\n-    \/\/ Breakpoint has one byte first instruction.\n-    \/\/ Also first instruction will be one byte \"push(rbp)\" if stack banging\n-    \/\/ code is not generated (see build_frame() above).\n-    \/\/ For all these cases generate long instruction first.\n-    fat_nop();\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,6 +73,0 @@\n-  \/\/ WARNING: Initial instruction MUST be 5 bytes or longer so that\n-  \/\/ NativeJump::patch_verified_entry will be able to patch out the entry\n-  \/\/ code safely. The push to verify stack depth is ok at 5 bytes,\n-  \/\/ the frame allocation can be either 3 or 6 bytes. So if we don't do\n-  \/\/ stack bang then we must use the 6 byte frame allocation even if\n-  \/\/ we have no frame. :-(\n@@ -109,2 +103,1 @@\n-    \/\/ Create frame (force generation of a 4 byte immediate value)\n-    subptr_imm32(rsp, framesize);\n+    subptr(rsp, framesize);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1635,13 +1635,0 @@\n-\/\/ A 5 byte nop that is safe for patching (see patch_verified_entry)\n-void MacroAssembler::fat_nop() {\n-  if (UseAddressNop) {\n-    addr_nop_5();\n-  } else {\n-    emit_int8((uint8_t)0x26); \/\/ es:\n-    emit_int8((uint8_t)0x2e); \/\/ cs:\n-    emit_int8((uint8_t)0x64); \/\/ fs:\n-    emit_int8((uint8_t)0x65); \/\/ gs:\n-    emit_int8((uint8_t)0x90);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -237,2 +237,0 @@\n-  \/\/ A 5 byte nop that is safe for patching (see patch_verified_entry)\n-  void fat_nop();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14876,0 +14876,18 @@\n+peephole\n+%{\n+  peepmatch (leaPCompressedOopOffset);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP8Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP32Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-  code->initialize_consts_size(Compilation::desired_max_constant_size());\n+  code->initialize_consts_size(Compilation::desired_max_constant_size);\n@@ -677,1 +677,1 @@\n-    if (DeoptC1 && UseCHA && !(ik->has_subklass() || ik->is_interface())) {\n+    if (UseCHA && !(ik->has_subklass() || ik->is_interface())) {\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,6 +221,2 @@\n-  static uint desired_max_code_buffer_size() {\n-    return (uint)NMethodSizeLimit;  \/\/ default 64K\n-  }\n-  static uint desired_max_constant_size() {\n-    return desired_max_code_buffer_size() \/ 10;\n-  }\n+  const static uint desired_max_code_buffer_size = 64*K * wordSize;\n+  const static uint desired_max_constant_size = desired_max_code_buffer_size \/ 10;\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2112,1 +2112,0 @@\n-  assert(DeoptC1, \"need debug information\");\n@@ -2259,1 +2258,1 @@\n-  if (UseCHA && DeoptC1 && target->is_loaded() &&\n+  if (UseCHA && target->is_loaded() &&\n@@ -2509,1 +2508,1 @@\n-      if (DeoptC1 && UseCHA && !(ik->has_subklass() || ik->is_interface())) {\n+      if (UseCHA && !(ik->has_subklass() || ik->is_interface())) {\n@@ -3622,1 +3621,1 @@\n-  case vmIntrinsics::_Reference_get:\n+  case vmIntrinsics::_Reference_get0:\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1215,1 +1215,1 @@\n-void LIRGenerator::do_Reference_get(Intrinsic* x) {\n+void LIRGenerator::do_Reference_get0(Intrinsic* x) {\n@@ -3442,2 +3442,2 @@\n-  case vmIntrinsics::_Reference_get:\n-    do_Reference_get(x);\n+  case vmIntrinsics::_Reference_get0:\n+    do_Reference_get0(x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  void do_Reference_get(Intrinsic* x);\n+  void do_Reference_get0(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-    if (nm->make_not_entrant(nmethod::ChangeReason::C1_deoptimize)) {\n+    if (nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE)) {\n@@ -1293,1 +1293,1 @@\n-      nm->make_not_entrant(nmethod::ChangeReason::C1_codepatch);\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_CODEPATCH);\n@@ -1541,1 +1541,1 @@\n-      nm->make_not_entrant(nmethod::ChangeReason::C1_deoptimize_for_patching);\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING);\n@@ -1669,1 +1669,1 @@\n-  nm->make_not_entrant(nmethod::ChangeReason::C1_predicate_failed_trap);\n+  nm->make_not_entrant(nmethod::InvalidationReason::C1_PREDICATE_FAILED_TRAP);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,3 +247,0 @@\n-  develop(bool, DeoptC1, true,                                              \\\n-          \"Use deoptimization in C1\")                                       \\\n-                                                                            \\\n@@ -277,6 +274,0 @@\n-  \/* The compiler assumes, in many places, that methods are at most 1MB. *\/ \\\n-  \/* Therefore, we restrict this flag to at most 1MB.                    *\/ \\\n-  develop(intx, NMethodSizeLimit, (64*K)*wordSize,                          \\\n-          \"Maximum size of a compiled method.\")                             \\\n-          range(0, 1*M)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-class VM_PopulateDynamicDumpSharedSpace: public VM_GC_Sync_Operation {\n+class VM_PopulateDynamicDumpSharedSpace: public VM_Heap_Sync_Operation {\n@@ -392,1 +392,1 @@\n-  : VM_GC_Sync_Operation(), _builder(archive_name) {}\n+  : VM_Heap_Sync_Operation(), _builder(archive_name) {}\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1298,0 +1298,4 @@\n+  if (!ls.is_enabled()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -806,1 +806,1 @@\n-      nm->make_not_entrant(nmethod::ChangeReason::CI_replay);\n+      nm->make_not_entrant(nmethod::InvalidationReason::CI_REPLAY);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  if (frame_type < 64) {\n+  if (frame_type <= SAME_FRAME_END) {\n@@ -331,1 +331,1 @@\n-  if (frame_type < 128) {\n+  if (frame_type <= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {\n@@ -334,1 +334,1 @@\n-      offset = frame_type - 64;\n+      offset = frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_START;\n@@ -341,1 +341,1 @@\n-      offset = _prev_frame->offset() + frame_type - 63;\n+      offset = _prev_frame->offset() + frame_type - (SAME_LOCALS_1_STACK_ITEM_FRAME_START - 1);\n@@ -407,1 +407,1 @@\n-  if (frame_type <= SAME_EXTENDED) {\n+  if (frame_type <= SAME_FRAME_EXTENDED) {\n@@ -411,1 +411,1 @@\n-    int chops = SAME_EXTENDED - frame_type;\n+    int chops = SAME_FRAME_EXTENDED - frame_type;\n@@ -414,0 +414,1 @@\n+    assert(chops == 0 || (frame_type >= CHOP_FRAME_START && frame_type <= CHOP_FRAME_END), \"should be\");\n@@ -448,1 +449,1 @@\n-  } else if (frame_type < SAME_EXTENDED + 4) {\n+  } else if (frame_type <= APPEND_FRAME_END) {\n@@ -450,1 +451,2 @@\n-    int appends = frame_type - SAME_EXTENDED;\n+    assert(frame_type >= APPEND_FRAME_START && frame_type <= APPEND_FRAME_END, \"should be\");\n+    int appends = frame_type - APPEND_FRAME_START + 1;\n@@ -481,1 +483,1 @@\n-  if (frame_type == FULL) {\n+  if (frame_type == FULL_FRAME) {\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  friend class VM_RedefineClasses;\n@@ -154,0 +155,6 @@\n+    SAME_FRAME_START = 0,\n+    SAME_FRAME_END = 63,\n+    SAME_LOCALS_1_STACK_ITEM_FRAME_START = 64,\n+    SAME_LOCALS_1_STACK_ITEM_FRAME_END = 127,\n+    RESERVED_START = 128,\n+    RESERVED_END = 245,\n@@ -156,2 +163,6 @@\n-    SAME_EXTENDED = 251,\n-    FULL = 255\n+    CHOP_FRAME_START = 248,\n+    CHOP_FRAME_END = 250,\n+    SAME_FRAME_EXTENDED = 251,\n+    APPEND_FRAME_START = 252,\n+    APPEND_FRAME_END = 254,\n+    FULL_FRAME = 255\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  case vmIntrinsics::_Reference_get:\n+  case vmIntrinsics::_Reference_get0:\n@@ -247,1 +247,1 @@\n-    case vmIntrinsics::_Reference_get:\n+    case vmIntrinsics::_Reference_get0:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-  do_intrinsic(_Reference_get,              java_lang_ref_Reference, get_name,       void_object_signature,    F_R)     \\\n+  do_intrinsic(_Reference_get0,             java_lang_ref_Reference, get0_name,      void_object_signature,    F_RN)    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-  template(get_name,                                  \"get\")                                      \\\n+  template(get0_name,                                 \"get0\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"code\/relocInfo.hpp\"\n@@ -695,7 +694,0 @@\n-  if (!is_in_use()) {\n-    low_boundary += NativeJump::instruction_size;\n-    \/\/ %%% Note:  On SPARC we patch only a 4-byte trap, not a full NativeJump.\n-    \/\/ This means that the low_boundary is going to be a little too high.\n-    \/\/ This shouldn't matter, since oops of non-entrant methods are never used.\n-    \/\/ In fact, why are we bothering to look at oops in a non-entrant method??\n-  }\n@@ -1675,4 +1667,0 @@\n-  \/\/ Enter a critical section to prevent a race with deopts that patch code and updates the relocation info.\n-  \/\/ Unfortunately, we have to lock the NMethodState_lock before the tty lock due to the deadlock rules and\n-  \/\/ cannot lock in a more finely grained manner.\n-  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -1997,1 +1985,1 @@\n-void nmethod::log_state_change(ChangeReason change_reason) const {\n+void nmethod::log_state_change(InvalidationReason invalidation_reason) const {\n@@ -2002,1 +1990,1 @@\n-                       os::current_thread_id(), change_reason_to_string(change_reason));\n+                       os::current_thread_id(), invalidation_reason_to_string(invalidation_reason));\n@@ -2011,1 +1999,1 @@\n-  ss.print(\"made not entrant: %s\", change_reason_to_string(change_reason));\n+  ss.print(\"made not entrant: %s\", invalidation_reason_to_string(invalidation_reason));\n@@ -2026,1 +2014,1 @@\n-bool nmethod::make_not_entrant(ChangeReason change_reason) {\n+bool nmethod::make_not_entrant(InvalidationReason invalidation_reason) {\n@@ -2062,13 +2050,1 @@\n-      NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),\n-                                       SharedRuntime::get_handle_wrong_method_stub());\n-\n-      \/\/ Update the relocation info for the patched entry.\n-      \/\/ First, get the old relocation info...\n-      RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n-      if (iter.next() && iter.addr() == verified_entry_point()) {\n-        Relocation* old_reloc = iter.reloc();\n-        \/\/ ...then reset the iterator to update it.\n-        RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n-        relocInfo::change_reloc_info_for_address(&iter, verified_entry_point(), old_reloc->type(),\n-                                                 relocInfo::relocType::runtime_call_type);\n-      }\n+      BarrierSet::barrier_set()->barrier_set_nmethod()->make_not_entrant(this);\n@@ -2095,1 +2071,1 @@\n-    log_state_change(change_reason);\n+    log_state_change(invalidation_reason);\n@@ -2106,1 +2082,1 @@\n-    nmethod_data->invalidate_nmethod_mirror(this);\n+    nmethod_data->invalidate_nmethod_mirror(this, invalidation_reason);\n@@ -2144,1 +2120,3 @@\n-    nmethod_data->invalidate_nmethod_mirror(this);\n+    nmethod_data->invalidate_nmethod_mirror(this, is_cold() ?\n+            nmethod::InvalidationReason::UNLOADING_COLD :\n+            nmethod::InvalidationReason::UNLOADING);\n@@ -2964,3 +2942,0 @@\n-  \/\/ Make sure all the entry points are correctly aligned for patching.\n-  NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":35,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -479,23 +479,26 @@\n-  enum class ChangeReason : u1 {\n-    C1_codepatch,\n-    C1_deoptimize,\n-    C1_deoptimize_for_patching,\n-    C1_predicate_failed_trap,\n-    CI_replay,\n-    JVMCI_invalidate_nmethod,\n-    JVMCI_invalidate_nmethod_mirror,\n-    JVMCI_materialize_virtual_object,\n-    JVMCI_new_installation,\n-    JVMCI_register_method,\n-    JVMCI_replacing_with_new_code,\n-    JVMCI_reprofile,\n-    marked_for_deoptimization,\n-    missing_exception_handler,\n-    not_used,\n-    OSR_invalidation_back_branch,\n-    OSR_invalidation_for_compiling_with_C1,\n-    OSR_invalidation_of_lower_level,\n-    set_native_function,\n-    uncommon_trap,\n-    whitebox_deoptimization,\n-    zombie,\n+  \/\/ If you change anything in this enum please patch\n+  \/\/ vmStructs_jvmci.cpp accordingly.\n+  enum class InvalidationReason : s1 {\n+    NOT_INVALIDATED = -1,\n+    C1_CODEPATCH,\n+    C1_DEOPTIMIZE,\n+    C1_DEOPTIMIZE_FOR_PATCHING,\n+    C1_PREDICATE_FAILED_TRAP,\n+    CI_REPLAY,\n+    UNLOADING,\n+    UNLOADING_COLD,\n+    JVMCI_INVALIDATE,\n+    JVMCI_MATERIALIZE_VIRTUAL_OBJECT,\n+    JVMCI_REPLACED_WITH_NEW_CODE,\n+    JVMCI_REPROFILE,\n+    MARKED_FOR_DEOPTIMIZATION,\n+    MISSING_EXCEPTION_HANDLER,\n+    NOT_USED,\n+    OSR_INVALIDATION_BACK_BRANCH,\n+    OSR_INVALIDATION_FOR_COMPILING_WITH_C1,\n+    OSR_INVALIDATION_OF_LOWER_LEVEL,\n+    SET_NATIVE_FUNCTION,\n+    UNCOMMON_TRAP,\n+    WHITEBOX_DEOPTIMIZATION,\n+    ZOMBIE,\n+    INVALIDATION_REASONS_COUNT\n@@ -505,3 +508,3 @@\n-  static const char* change_reason_to_string(ChangeReason change_reason) {\n-    switch (change_reason) {\n-      case ChangeReason::C1_codepatch:\n+  static const char* invalidation_reason_to_string(InvalidationReason invalidation_reason) {\n+    switch (invalidation_reason) {\n+      case InvalidationReason::C1_CODEPATCH:\n@@ -509,1 +512,1 @@\n-      case ChangeReason::C1_deoptimize:\n+      case InvalidationReason::C1_DEOPTIMIZE:\n@@ -511,1 +514,1 @@\n-      case ChangeReason::C1_deoptimize_for_patching:\n+      case InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING:\n@@ -513,1 +516,1 @@\n-      case ChangeReason::C1_predicate_failed_trap:\n+      case InvalidationReason::C1_PREDICATE_FAILED_TRAP:\n@@ -515,1 +518,1 @@\n-      case ChangeReason::CI_replay:\n+      case InvalidationReason::CI_REPLAY:\n@@ -517,5 +520,3 @@\n-      case ChangeReason::JVMCI_invalidate_nmethod:\n-        return \"JVMCI invalidate nmethod\";\n-      case ChangeReason::JVMCI_invalidate_nmethod_mirror:\n-        return \"JVMCI invalidate nmethod mirror\";\n-      case ChangeReason::JVMCI_materialize_virtual_object:\n+      case InvalidationReason::JVMCI_INVALIDATE:\n+        return \"JVMCI invalidate\";\n+      case InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT:\n@@ -523,7 +524,3 @@\n-      case ChangeReason::JVMCI_new_installation:\n-        return \"JVMCI new installation\";\n-      case ChangeReason::JVMCI_register_method:\n-        return \"JVMCI register method\";\n-      case ChangeReason::JVMCI_replacing_with_new_code:\n-        return \"JVMCI replacing with new code\";\n-      case ChangeReason::JVMCI_reprofile:\n+      case InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE:\n+        return \"JVMCI replaced with new code\";\n+      case InvalidationReason::JVMCI_REPROFILE:\n@@ -531,1 +528,1 @@\n-      case ChangeReason::marked_for_deoptimization:\n+      case InvalidationReason::MARKED_FOR_DEOPTIMIZATION:\n@@ -533,1 +530,1 @@\n-      case ChangeReason::missing_exception_handler:\n+      case InvalidationReason::MISSING_EXCEPTION_HANDLER:\n@@ -535,1 +532,1 @@\n-      case ChangeReason::not_used:\n+      case InvalidationReason::NOT_USED:\n@@ -537,1 +534,1 @@\n-      case ChangeReason::OSR_invalidation_back_branch:\n+      case InvalidationReason::OSR_INVALIDATION_BACK_BRANCH:\n@@ -539,1 +536,1 @@\n-      case ChangeReason::OSR_invalidation_for_compiling_with_C1:\n+      case InvalidationReason::OSR_INVALIDATION_FOR_COMPILING_WITH_C1:\n@@ -541,1 +538,1 @@\n-      case ChangeReason::OSR_invalidation_of_lower_level:\n+      case InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL:\n@@ -543,1 +540,1 @@\n-      case ChangeReason::set_native_function:\n+      case InvalidationReason::SET_NATIVE_FUNCTION:\n@@ -545,1 +542,1 @@\n-      case ChangeReason::uncommon_trap:\n+      case InvalidationReason::UNCOMMON_TRAP:\n@@ -547,1 +544,1 @@\n-      case ChangeReason::whitebox_deoptimization:\n+      case InvalidationReason::WHITEBOX_DEOPTIMIZATION:\n@@ -549,1 +546,1 @@\n-      case ChangeReason::zombie:\n+      case InvalidationReason::ZOMBIE:\n@@ -723,2 +720,2 @@\n-  bool  make_not_entrant(ChangeReason change_reason);\n-  bool  make_not_used() { return make_not_entrant(ChangeReason::not_used); }\n+  bool  make_not_entrant(InvalidationReason invalidation_reason);\n+  bool  make_not_used() { return make_not_entrant(InvalidationReason::NOT_USED); }\n@@ -1047,1 +1044,1 @@\n-  void log_state_change(ChangeReason change_reason) const;\n+  void log_state_change(InvalidationReason invalidation_reason) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -581,0 +581,4 @@\n+\n+  virtual bool is_gc_operation() const {\n+    return true;\n+  }\n@@ -772,1 +776,1 @@\n-      _bs_nm->set_guard_value(nm, (int)untype(new_disarm_value_ptr));\n+      _bs_nm->guard_with(nm, (int)untype(new_disarm_value_ptr));\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,0 +359,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_ReferenceGet(JNIEnv *env, jobject ref);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  method_entry(java_lang_ref_reference_get)\n+  method_entry(java_lang_ref_reference_get0)\n@@ -232,0 +232,1 @@\n+  native_method_entry(java_lang_ref_reference_get0)\n@@ -469,1 +470,1 @@\n-  case Interpreter::java_lang_ref_reference_get\n+  case Interpreter::java_lang_ref_reference_get0\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, true, nmethod::ChangeReason::JVMCI_replacing_with_new_code, JVMCI_CHECK_0);\n+        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, true, nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE, JVMCI_CHECK_0);\n@@ -1221,0 +1221,8 @@\n+C2V_VMENTRY_0(jobject, getInvalidationReasonDescription, (JNIEnv *env, jobject, jint invalidation_reason))\n+  HandleMark hm(THREAD);\n+  JNIHandleMark jni_hm(thread);\n+  nmethod::InvalidationReason reason = static_cast<nmethod::InvalidationReason>(invalidation_reason);\n+  JVMCIObject desc = JVMCIENV->create_string(nmethod::invalidation_reason_to_string(reason), JVMCI_CHECK_NULL);\n+  return JVMCIENV->get_jobject(desc);\n+C2V_END\n+\n@@ -1386,1 +1394,1 @@\n-    code->make_not_entrant(nmethod::ChangeReason::JVMCI_reprofile);\n+    code->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPROFILE);\n@@ -1399,1 +1407,6 @@\n-C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod, jboolean deoptimize))\n+C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod, jboolean deoptimize, jint invalidation_reason))\n+  int first = static_cast<int>(nmethod::InvalidationReason::C1_CODEPATCH);\n+  int last = static_cast<int>(nmethod::InvalidationReason::INVALIDATION_REASONS_COUNT);\n+  if (invalidation_reason < first || invalidation_reason >= last) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"Invalid invalidation_reason: %d\", invalidation_reason));\n+  }\n@@ -1401,1 +1414,1 @@\n-  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, deoptimize, nmethod::ChangeReason::JVMCI_invalidate_nmethod, JVMCI_CHECK);\n+  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, deoptimize, static_cast<nmethod::InvalidationReason>(invalidation_reason), JVMCI_CHECK);\n@@ -1826,1 +1839,1 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant(nmethod::ChangeReason::JVMCI_materialize_virtual_object);\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(nmethod::InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT);\n@@ -3356,0 +3369,1 @@\n+  {CC \"getInvalidationReasonDescription\",             CC \"(I)\" STRING,                                                                      FN_PTR(getInvalidationReasonDescription)},\n@@ -3364,1 +3378,1 @@\n-  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \"Z)V\",                                                              FN_PTR(invalidateHotSpotNmethod)},\n+  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \"ZI)V\",                                                             FN_PTR(invalidateHotSpotNmethod)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -567,1 +567,24 @@\n-                                                                          \\\n+                                                                                          \\\n+  declare_constant(nmethod::InvalidationReason::NOT_INVALIDATED)                          \\\n+  declare_constant(nmethod::InvalidationReason::C1_CODEPATCH)                             \\\n+  declare_constant(nmethod::InvalidationReason::C1_DEOPTIMIZE)                            \\\n+  declare_constant(nmethod::InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING)               \\\n+  declare_constant(nmethod::InvalidationReason::C1_PREDICATE_FAILED_TRAP)                 \\\n+  declare_constant(nmethod::InvalidationReason::CI_REPLAY)                                \\\n+  declare_constant(nmethod::InvalidationReason::UNLOADING)                                \\\n+  declare_constant(nmethod::InvalidationReason::UNLOADING_COLD)                           \\\n+  declare_constant(nmethod::InvalidationReason::JVMCI_INVALIDATE)                         \\\n+  declare_constant(nmethod::InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT)         \\\n+  declare_constant(nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE)             \\\n+  declare_constant(nmethod::InvalidationReason::JVMCI_REPROFILE)                          \\\n+  declare_constant(nmethod::InvalidationReason::MARKED_FOR_DEOPTIMIZATION)                \\\n+  declare_constant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER)                \\\n+  declare_constant(nmethod::InvalidationReason::NOT_USED)                                 \\\n+  declare_constant(nmethod::InvalidationReason::OSR_INVALIDATION_BACK_BRANCH)             \\\n+  declare_constant(nmethod::InvalidationReason::OSR_INVALIDATION_FOR_COMPILING_WITH_C1)   \\\n+  declare_constant(nmethod::InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL)          \\\n+  declare_constant(nmethod::InvalidationReason::SET_NATIVE_FUNCTION)                      \\\n+  declare_constant(nmethod::InvalidationReason::UNCOMMON_TRAP)                            \\\n+  declare_constant(nmethod::InvalidationReason::WHITEBOX_DEOPTIMIZATION)                  \\\n+  declare_constant(nmethod::InvalidationReason::ZOMBIE)                                   \\\n+                                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1969,2 +1969,4 @@\n-  int k1 = operand_bootstrap_method_ref_index_at(idx1);\n-  int k2 = cp2->operand_bootstrap_method_ref_index_at(idx2);\n+  BSMAttributeEntry* e1 = bsm_attribute_entry(idx1);\n+  BSMAttributeEntry* e2 = cp2->bsm_attribute_entry(idx2);\n+  int k1 = e1->bootstrap_method_index();\n+  int k2 = e2->bootstrap_method_index();\n@@ -1976,2 +1978,2 @@\n-  int argc = operand_argument_count_at(idx1);\n-  if (argc == cp2->operand_argument_count_at(idx2)) {\n+  int argc = e1->argument_count();\n+  if (argc == e2->argument_count()) {\n@@ -1979,2 +1981,2 @@\n-      k1 = operand_argument_index_at(idx1, j);\n-      k2 = cp2->operand_argument_index_at(idx2, j);\n+      k1 = e1->argument_index(j);\n+      k2 = e2->argument_index(j);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,37 @@\n+class BSMAttributeEntry {\n+  friend class ConstantPool;\n+  u2 _bootstrap_method_index;\n+  u2 _argument_count;\n+\n+  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n+  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n+  \/\/ So in order to find the argument array, jump over ourselves.\n+  const u2* argument_indexes() const {\n+    return reinterpret_cast<const u2*>(this + 1);\n+  }\n+  u2* argument_indexes() {\n+    return reinterpret_cast<u2*>(this + 1);\n+  }\n+  \/\/ These are overlays on top of the operands array. Do not construct.\n+  BSMAttributeEntry() = delete;\n+\n+public:\n+  \/\/ Offsets for SA\n+  enum {\n+    _bsmi_offset = 0,\n+    _argc_offset = 1,\n+    _argv_offset = 2\n+  };\n+\n+  int bootstrap_method_index() const {\n+    return _bootstrap_method_index;\n+  }\n+  int argument_count() const {\n+    return _argument_count;\n+  }\n+  int argument_index(int n) const {\n+    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n+    return argument_indexes()[n];\n+  }\n+};\n+\n@@ -522,4 +559,0 @@\n-  int bootstrap_operand_base(int cp_index) {\n-    int bsms_attribute_index = bootstrap_methods_attribute_index(cp_index);\n-    return operand_offset_at(operands(), bsms_attribute_index);\n-  }\n@@ -563,4 +596,0 @@\n-  int bootstrap_operand_limit(int cp_index) {\n-    int bsms_attribute_index = bootstrap_methods_attribute_index(cp_index);\n-    return operand_limit_at(operands(), bsms_attribute_index);\n-  }\n@@ -569,11 +598,0 @@\n-  \/\/ Layout of InvokeDynamic and Dynamic bootstrap method specifier\n-  \/\/ data in second part of operands array.  This encodes one record in\n-  \/\/ the BootstrapMethods attribute.  The whole specifier also includes\n-  \/\/ the name and type information from the main constant pool entry.\n-  enum {\n-         _indy_bsm_offset  = 0,  \/\/ CONSTANT_MethodHandle bsm\n-         _indy_argc_offset = 1,  \/\/ u2 argc\n-         _indy_argv_offset = 2   \/\/ u2 argv[argc]\n-  };\n-\n-\n@@ -587,10 +605,2 @@\n-  u2 operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {\n-    int offset = operand_offset_at(bsms_attribute_index);\n-    return operands()->at(offset + _indy_bsm_offset);\n-  }\n-  u2 operand_argument_count_at(int bsms_attribute_index) {\n-    int offset = operand_offset_at(bsms_attribute_index);\n-    u2 argc = operands()->at(offset + _indy_argc_offset);\n-    return argc;\n-  }\n-  u2 operand_argument_index_at(int bsms_attribute_index, int j) {\n+\n+  BSMAttributeEntry* bsm_attribute_entry(int bsms_attribute_index) {\n@@ -598,1 +608,1 @@\n-    return operands()->at(offset + _indy_argv_offset + j);\n+    return reinterpret_cast<BSMAttributeEntry*>(operands()->adr_at(offset));\n@@ -600,0 +610,1 @@\n+\n@@ -601,3 +612,4 @@\n-    int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset\n-                   + operand_argument_count_at(bsms_attribute_index);\n-    return offset;\n+    BSMAttributeEntry* bsme = bsm_attribute_entry(bsms_attribute_index);\n+    u2* argv_start = bsme->argument_indexes();\n+    int offset = argv_start - operands()->data();\n+    return offset + bsme->argument_count();\n@@ -620,2 +632,2 @@\n-    int op_base = bootstrap_operand_base(cp_index);\n-    return operands()->at(op_base + _indy_bsm_offset);\n+    int bsmai = bootstrap_methods_attribute_index(cp_index);\n+    return bsm_attribute_entry(bsmai)->bootstrap_method_index();\n@@ -625,6 +637,2 @@\n-    int op_base = bootstrap_operand_base(cp_index);\n-    u2 argc = operands()->at(op_base + _indy_argc_offset);\n-    DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;\n-               int next_offset = bootstrap_operand_limit(cp_index));\n-    assert(end_offset == next_offset, \"matched ending\");\n-    return argc;\n+    int bsmai = bootstrap_methods_attribute_index(cp_index);\n+    return bsm_attribute_entry(bsmai)->argument_count();\n@@ -633,4 +641,4 @@\n-    int op_base = bootstrap_operand_base(cp_index);\n-    DEBUG_ONLY(int argc = operands()->at(op_base + _indy_argc_offset));\n-    assert((uint)j < (uint)argc, \"oob\");\n-    return operands()->at(op_base + _indy_argv_offset + j);\n+    int bsmai = bootstrap_methods_attribute_index(cp_index);\n+    BSMAttributeEntry* bsme = bsm_attribute_entry(bsmai);\n+    assert((uint)j < (uint)bsme->argument_count(), \"oob\");\n+    return bsm_attribute_entry(bsmai)->argument_index(j);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":53,"deletions":45,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -3836,1 +3836,1 @@\n-      inv->make_not_entrant(nmethod::ChangeReason::OSR_invalidation_of_lower_level);\n+      inv->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-    nm->make_not_entrant(nmethod::ChangeReason::set_native_function);\n+    nm->make_not_entrant(nmethod::InvalidationReason::SET_NATIVE_FUNCTION);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"compiler\/compilerEvent.hpp\"\n+#include \"compiler\/compilerEvent.hpp\"\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n@@ -36,1 +35,2 @@\n-#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -781,1 +781,1 @@\n-  case vmIntrinsics::_Reference_get:\n+  case vmIntrinsics::_Reference_get0:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"ci\/ciObjArray.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"ci\/ciObjArray.hpp\"\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n-#include \"compiler\/compileLog.hpp\"\n-#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"code\/vmreg.hpp\"\n+#include \"compiler\/compileLog.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"code\/vmreg.hpp\"\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"castnode.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"castnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"opto\/narrowptrnode.hpp\"\n+#include \"opto\/narrowptrnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"opto\/memnode.hpp\"\n+#include \"opto\/memnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n@@ -800,13 +800,3 @@\n-      if (method()->intrinsic_id() == vmIntrinsics::_Reference_get) {\n-        \/\/ With java.lang.ref.reference.get() we must go through the\n-        \/\/ intrinsic - even when get() is the root\n-        \/\/ method of the compile - so that, if necessary, the value in\n-        \/\/ the referent field of the reference object gets recorded by\n-        \/\/ the pre-barrier code.\n-        cg = find_intrinsic(method(), false);\n-      }\n-      if (cg == nullptr) {\n-        float past_uses = method()->interpreter_invocation_count();\n-        float expected_uses = past_uses;\n-        cg = CallGenerator::for_inline(method(), expected_uses);\n-      }\n+      float past_uses = method()->interpreter_invocation_count();\n+      float expected_uses = past_uses;\n+      cg = CallGenerator::for_inline(method(), expected_uses);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"compiler\/compiler_globals.hpp\"\n+#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -40,1 +40,2 @@\n-#include \"opto\/phasetype.hpp\"\n+#include \"opto\/phasetype.hpp\"\n+#include \"opto\/printinlining.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"opto\/printinlining.hpp\"\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"opto\/movenode.hpp\"\n+#include \"opto\/movenode.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"opto\/runtime.hpp\"\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"opto\/c2compiler.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n@@ -36,0 +36,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -40,2 +41,1 @@\n-#include \"opto\/macro.hpp\"\n-#include \"opto\/phaseX.hpp\"\n+#include \"opto\/macro.hpp\"\n@@ -45,1 +45,1 @@\n-#include \"opto\/castnode.hpp\"\n+#include \"opto\/phaseX.hpp\"\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"opto\/chaitin.hpp\"\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"asm\/register.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"ci\/ciObjArray.hpp\"\n@@ -29,2 +31,0 @@\n-#include \"ci\/ciObjArray.hpp\"\n-#include \"asm\/register.hpp\"\n@@ -56,1 +56,1 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"opto\/cfgnode.hpp\"\n+#include \"opto\/cfgnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"opto\/runtime.hpp\"\n+#include \"opto\/runtime.hpp\"\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"opto\/rootnode.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"opto\/rootnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"opto\/chaitin.hpp\"\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n@@ -51,1 +51,0 @@\n-#include \"opto\/library_call.hpp\"\n@@ -53,0 +52,1 @@\n+#include \"opto\/library_call.hpp\"\n@@ -59,1 +59,1 @@\n-#include \"opto\/runtime.hpp\"\n+#include \"opto\/runtime.hpp\"\n@@ -588,1 +588,1 @@\n-  case vmIntrinsics::_Reference_get:            return inline_reference_get();\n+  case vmIntrinsics::_Reference_get0:           return inline_reference_get0();\n@@ -1599,3 +1599,8 @@\n-    \/\/ Check if src array address is aligned to HeapWordSize (dst is always aligned)\n-    const TypeInt* toffset = gvn().type(offset)->is_int();\n-    bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    \/\/ Check if dst array address is aligned to HeapWordSize\n+    bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+    \/\/ If true, then check if src array address is aligned to HeapWordSize\n+    if (aligned) {\n+      const TypeInt* toffset = gvn().type(offset)->is_int();\n+      aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                       toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    }\n@@ -1682,2 +1687,2 @@\n-    bool aligned = tsrc->is_con() && ((tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n-                   tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    bool aligned = tsrc->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_BYTE) + tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n+                   tdst->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) + tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n@@ -7596,1 +7601,1 @@\n-\/\/----------------------------inline_reference_get----------------------------\n+\/\/----------------------------inline_reference_get0----------------------------\n@@ -7598,1 +7603,1 @@\n-bool LibraryCallKit::inline_reference_get() {\n+bool LibraryCallKit::inline_reference_get0() {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"opto\/graphKit.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"opto\/graphKit.hpp\"\n@@ -330,1 +330,1 @@\n-  bool inline_reference_get();\n+  bool inline_reference_get0();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -579,1 +579,2 @@\n-  static void fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+  void fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop) const;\n+  void handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn);\n@@ -595,0 +596,4 @@\n+  CountedLoopNode* inner_counted_loop() const { return unique_ctrl_out()->as_CountedLoop(); }\n+  CountedLoopEndNode* inner_counted_loop_end() const { return  inner_counted_loop()->loopexit(); }\n+  IfFalseNode* inner_loop_exit() const { return inner_counted_loop_end()->proj_out(false)->as_IfFalse(); }\n+\n@@ -1300,1 +1305,1 @@\n-  IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,\n+  IdealLoopTree* create_outer_strip_mined_loop(Node* init_control,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"opto\/castnode.hpp\"\n@@ -38,1 +37,1 @@\n-#include \"opto\/mulnode.hpp\"\n+#include \"opto\/mulnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"opto\/arraycopynode.hpp\"\n+#include \"opto\/arraycopynode.hpp\"\n+#include \"opto\/castnode.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"opto\/vectornode.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"opto\/castnode.hpp\"\n+#include \"opto\/vectornode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"opto\/regalloc.hpp\"\n@@ -52,0 +51,1 @@\n+#include \"opto\/regalloc.hpp\"\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -40,1 +40,1 @@\n-#include \"opto\/c2compiler.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -77,1 +77,1 @@\n-#include \"runtime\/vframeArray.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1476,3 +1476,8 @@\n-  \/\/ Check if destination address is aligned to HeapWordSize\n-  const TypeInt* tdst = __ gvn().type(start)->is_int();\n-  bool aligned = tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);\n+  \/\/ Check if src array address is aligned to HeapWordSize\n+  bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+  \/\/ If true, then check if dst array address is aligned to HeapWordSize\n+  if (aligned) {\n+    const TypeInt* tdst = __ gvn().type(start)->is_int();\n+    aligned = tdst->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_BYTE) +\n+                                  tdst->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);\n+  }\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -41,1 +41,1 @@\n-#include \"opto\/callnode.hpp\"\n+#include \"opto\/callnode.hpp\"\n@@ -49,0 +49,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3220,0 +3220,8 @@\n+JVM_ENTRY(jobject, JVM_ReferenceGet(JNIEnv* env, jobject ref))\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  \/\/ PhantomReference has its own implementation of get().\n+  assert(!java_lang_ref_Reference::is_phantom(ref_oop), \"precondition\");\n+  oop referent = java_lang_ref_Reference::weak_referent(ref_oop);\n+  return JNIHandles::make_local(THREAD, referent);\n+JVM_END\n+\n@@ -3222,1 +3230,1 @@\n-  \/\/ PhantomReference has it's own implementation of refersTo().\n+  \/\/ PhantomReference has its own implementation of refersTo().\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-    u2 num_bootstrap_arguments = cpool()->operand_argument_count_at(n);\n+    u2 num_bootstrap_arguments = cpool()->bsm_attribute_entry(n)->argument_count();\n@@ -410,3 +410,3 @@\n-    u2 bootstrap_method_ref = cpool()->operand_bootstrap_method_ref_index_at(n);\n-    u2 num_bootstrap_arguments = cpool()->operand_argument_count_at(n);\n-    write_u2(bootstrap_method_ref);\n+    BSMAttributeEntry* bsme = cpool()->bsm_attribute_entry(n);\n+    u2 num_bootstrap_arguments = bsme->argument_count();\n+    write_u2(bsme->bootstrap_method_index());\n@@ -415,1 +415,1 @@\n-      u2 bootstrap_argument = cpool()->operand_argument_index_at(n, arg);\n+      u2 bootstrap_argument = bsme->argument_index(arg);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -662,1 +662,1 @@\n-void VM_RedefineClasses::append_operand(const constantPoolHandle& scratch_cp, int old_bs_i,\n+void VM_RedefineClasses::append_operand(const constantPoolHandle& scratch_cp, const int old_bs_i,\n@@ -665,1 +665,2 @@\n-  u2 old_ref_i = scratch_cp->operand_bootstrap_method_ref_index_at(old_bs_i);\n+  BSMAttributeEntry* old_bsme = scratch_cp->bsm_attribute_entry(old_bs_i);\n+  u2 old_ref_i = old_bsme->bootstrap_method_index();\n@@ -679,1 +680,1 @@\n-  u2 argc      = scratch_cp->operand_argument_count_at(old_bs_i);\n+  u2 argc      = old_bsme->argument_count();\n@@ -686,1 +687,1 @@\n-    u2 old_arg_ref_i = scratch_cp->operand_argument_index_at(old_bs_i, i);\n+    u2 old_arg_ref_i = old_bsme->argument_index(i);\n@@ -3296,1 +3297,1 @@\n-    if (frame_type <= 63) {\n+    if (frame_type <= StackMapReader::SAME_FRAME_END) {\n@@ -3304,1 +3305,2 @@\n-    else if (frame_type >= 64 && frame_type <= 127) {\n+    else if (frame_type >= StackMapReader::SAME_LOCALS_1_STACK_ITEM_FRAME_START &&\n+             frame_type <= StackMapReader::SAME_LOCALS_1_STACK_ITEM_FRAME_END) {\n@@ -3310,1 +3312,2 @@\n-    else if (frame_type >= 128 && frame_type <= 245) {\n+    else if (frame_type >= StackMapReader::RESERVED_START &&\n+             frame_type <= StackMapReader::RESERVED_END) {\n@@ -3319,1 +3322,1 @@\n-    else if (frame_type == 247) {\n+    else if (frame_type == StackMapReader::SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n@@ -3329,1 +3332,2 @@\n-    else if (frame_type >= 248 && frame_type <= 250) {\n+    else if (frame_type >= StackMapReader::CHOP_FRAME_START &&\n+             frame_type <= StackMapReader::CHOP_FRAME_END) {\n@@ -3334,1 +3338,1 @@\n-    \/\/   u1 frame_type = SAME_FRAME_EXTENDED; \/* 251*\/\n+    \/\/   u1 frame_type = SAME_EXTENDED; \/* 251 *\/\n@@ -3337,1 +3341,1 @@\n-    else if (frame_type == 251) {\n+    else if (frame_type == StackMapReader::SAME_FRAME_EXTENDED) {\n@@ -3344,1 +3348,1 @@\n-    \/\/   verification_type_info locals[frame_type - 251];\n+    \/\/   verification_type_info locals[frame_type - SAME_EXTENDED];\n@@ -3346,1 +3350,2 @@\n-    else if (frame_type >= 252 && frame_type <= 254) {\n+    else if (frame_type >= StackMapReader::APPEND_FRAME_START &&\n+             frame_type <= StackMapReader::APPEND_FRAME_END) {\n@@ -3350,1 +3355,1 @@\n-      u1 len = frame_type - 251;\n+      u1 len = frame_type - StackMapReader::APPEND_FRAME_START + 1;\n@@ -3365,1 +3370,1 @@\n-    else if (frame_type == 255) {\n+    else if (frame_type == StackMapReader::FULL_FRAME) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -780,1 +780,1 @@\n-                nm->make_not_entrant(nmethod::ChangeReason::whitebox_deoptimization);\n+                nm->make_not_entrant(nmethod::InvalidationReason::WHITEBOX_DEOPTIMIZATION);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -548,0 +548,2 @@\n+  { \"ParallelRefProcEnabled\",       JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n+  { \"ParallelRefProcBalancingEnabled\", JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1949,1 +1949,1 @@\n-  nm->make_not_entrant(nmethod::ChangeReason::missing_exception_handler);\n+  nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n@@ -2578,1 +2578,1 @@\n-      if (!nm->make_not_entrant(nmethod::ChangeReason::uncommon_trap)) {\n+      if (!nm->make_not_entrant(nmethod::InvalidationReason::UNCOMMON_TRAP)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1124,0 +1124,3 @@\n+  \/* This value is later shifted left by up to LogBytesPerLong bits       *\/\\\n+  \/* (to convert from element count to size in bytes), so we must ensure  *\/\\\n+  \/* it does not overflow during the shift.                               *\/\\\n@@ -1127,0 +1130,1 @@\n+          range(0, (1 << (BitsPerInt - LogBytesPerLong - 1)) - 1)           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1342,1 +1342,1 @@\n-      nm->make_not_entrant(nmethod::ChangeReason::zombie);\n+      nm->make_not_entrant(nmethod::InvalidationReason::ZOMBIE);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,4 @@\n+  \/\/ VMOp_Type may belong to a category of the operation.\n+  \/\/ Override is_XX_operation() appropriately in subclasses.\n+  virtual bool is_gc_operation() const { return false; }\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1491,3 +1491,3 @@\n-  \/***********************************************\/                       \\\n-  \/* ConstantPool* layout enum for InvokeDynamic *\/                       \\\n-  \/***********************************************\/                       \\\n+  \/******************************************************\/                \\\n+  \/* BSMAttributeEntry* - layout enum for InvokeDynamic *\/                \\\n+  \/******************************************************\/                \\\n@@ -1495,3 +1495,3 @@\n-  declare_constant(ConstantPool::_indy_bsm_offset)                        \\\n-  declare_constant(ConstantPool::_indy_argc_offset)                       \\\n-  declare_constant(ConstantPool::_indy_argv_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_bsmi_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_argc_offset)                       \\\n+  declare_constant(BSMAttributeEntry::_argv_offset)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import sun.invoke.empty.Empty;\n@@ -986,1 +985,1 @@\n-    static <T extends Throwable> Empty throwException(T t) throws T { throw t; }\n+    static <T extends Throwable> Void throwException(T t) throws T { throw t; }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -370,2 +370,1 @@\n-    @IntrinsicCandidate\n-        return this.referent;\n+        return get0();\n@@ -375,0 +374,8 @@\n+    \/* Implementation of get().  This method exists to avoid making get() all\n+     * of virtual, native, and intrinsic candidate. That could have the\n+     * undesirable effect of having the native method used instead of the\n+     * intrinsic when devirtualization fails.\n+     *\/\n+    @IntrinsicCandidate\n+    private native T get0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInvalidationReasonTest.java 8360168 linux-riscv64\n@@ -88,0 +89,3 @@\n+compiler\/codegen\/TestRedundantLea.java#StringInflate  8367518 generic-all\n+compiler\/codegen\/TestRedundantLea.java#StoreNParallel 8367518 generic-all\n+compiler\/codegen\/TestRedundantLea.java#StoreNSerial   8367518 generic-all\n@@ -146,0 +150,1 @@\n+compiler\/c2\/irTests\/stringopts\/TestArrayCopySelect.java                         8348568 generic-all\n@@ -187,1 +192,0 @@\n-serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/MAAThreadStart.java 8225354 windows-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -695,0 +695,5 @@\n+    public static final String DECODE_HEAP_OOP_NOT_NULL = PREFIX + \"DECODE_HEAP_OOP_NOT_NULL\" + POSTFIX;\n+    static {\n+        machOnly(DECODE_HEAP_OOP_NOT_NULL, \"decodeHeapOop_not_null\");\n+    }\n+\n@@ -921,0 +926,6 @@\n+    \/\/ Only supported on x86.\n+    public static final String LEA_P = PREFIX + \"LEA_P\" + POSTFIX;\n+    static {\n+        machOnly(LEA_P, \"leaP(CompressedOopOffset|(8|32)Narrow)\");\n+    }\n+\n@@ -1263,0 +1274,5 @@\n+    public static final String MEM_TO_REG_SPILL_COPY = PREFIX + \"MEM_TO_REG_SPILL_COPY\" + POSTFIX;\n+    static {\n+        machOnly(MEM_TO_REG_SPILL_COPY, \"MemToRegSpillCopy\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -603,2 +603,0 @@\n-java\/net\/Socket\/asyncClose\/Race.java                            8317801 aix-ppc64\n-\n@@ -856,0 +854,1 @@\n+tools\/sincechecker\/modules\/jdk.management.jfr\/JdkManagementJfrCheckSince.java 8354921 generic-all\n@@ -875,0 +874,1 @@\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}