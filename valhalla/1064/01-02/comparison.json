{"files":[{"patch":"@@ -622,1 +622,2 @@\n-      if (instruction->method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n+      if (instruction->method()->intrinsic_id() == vmIntrinsics::_Object_init ||\n+          (instruction->method()->is_object_constructor() && instruction->method()->holder()->is_inlinetype())) {\n@@ -625,0 +626,2 @@\n+        \/\/ Value class constructors update the scalarized receiver. Keep it live so that\n+        \/\/ we can find it after (chained) constructor calls and propagate updates to the caller.\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -688,0 +688,1 @@\n+  Node* receiver_in_caller = local(0);\n@@ -816,0 +817,10 @@\n+  \/\/ Did we inline a value class constructor from another value class constructor?\n+  if (cg->is_inline() && cg->method()->is_object_constructor() && cg->method()->holder()->is_inlinetype() &&\n+      _method->is_object_constructor() && cg->method()->holder()->is_inlinetype() && receiver_in_caller == receiver) {\n+    \/\/ Update the receiver in the exit map because the constructor call updated it.\n+    \/\/ MethodLiveness::BasicBlock::compute_gen_kill_single ensures that the receiver in local(0) is live.\n+    assert(local(0)->is_InlineType(), \"Unexpected receiver\");\n+    assert(receiver->bottom_type()->inline_klass() == local(0)->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n+    _exits.map()->replace_edge(receiver, local(0), &_gvn);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -168,0 +168,65 @@\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static value class MyValue8 {\n+        int x;\n+\n+        public MyValue8(int x) {\n+            this(x, 0);\n+        }\n+\n+        public MyValue8(int x, int unused1) {\n+            if ((x % 2) == 0) {\n+                this.x = 42;\n+            } else {\n+                this.x = x;\n+            }\n+        }\n+\n+        public MyValue8(int x, int unused1, int unused2) {\n+            this.x = x;\n+        }\n+\n+        public static MyValue8 valueOf(int x) {\n+            if ((x % 2) == 0) {\n+                return new MyValue8(42, 0, 0);\n+            } else {\n+                return new MyValue8(x, 0, 0);\n+            }\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9 {\n+        MyValue8 val;\n+\n+        public MyValue9(int x) {\n+            this(x, 0);\n+        }\n+\n+        public MyValue9(int i, int unused1) {\n+            val = new MyValue8(i);\n+        }\n+\n+        public MyValue9(int x, int unused1, int unused2) {\n+            this(x, 0, 0, 0);\n+        }\n+\n+        public MyValue9(int i, int unused1, int unused2, int unused3) {\n+            val = MyValue8.valueOf(i);\n+        }\n+    }\n+\n+    \/\/ Constructor with a loop\n+    static value class MyValue10 {\n+        int x;\n+        int y;\n+\n+        public MyValue10(int x, int cnt) {\n+            this.x = x;\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                res += x;\n+            }\n+            this.y = res;\n+        }\n+    }\n+\n@@ -265,0 +330,32 @@\n+    public static MyValue8 test17(int x) {\n+        return new MyValue8(x);\n+    }\n+\n+    public static MyValue8 test18(int x) {\n+        return new MyValue8(x, 0);\n+    }\n+\n+    public static MyValue8 test19(int x) {\n+        return MyValue8.valueOf(x);\n+    }\n+\n+    public static MyValue9 test20(int x) {\n+        return new MyValue9(x);\n+    }\n+\n+    public static MyValue9 test21(int x) {\n+        return new MyValue9(x, 0);\n+    }\n+\n+    public static MyValue9 test22(int x) {\n+        return new MyValue9(x, 0, 0);\n+    }\n+\n+    public static MyValue9 test23(int x) {\n+        return new MyValue9(x, 0, 0, 0);\n+    }\n+\n+    public static MyValue10 test24(int x, int cnt) {\n+        return new MyValue10(x, cnt);\n+    }\n+\n@@ -267,1 +364,1 @@\n-            Asserts.assertEQ(test1(x),x);\n+            Asserts.assertEQ(test1(x), x);\n@@ -283,0 +380,8 @@\n+            Asserts.assertEQ(test17(x), new MyValue8(x));\n+            Asserts.assertEQ(test18(x), new MyValue8(x));\n+            Asserts.assertEQ(test19(x), new MyValue8(x));\n+            Asserts.assertEQ(test20(x), new MyValue9(x));\n+            Asserts.assertEQ(test21(x), new MyValue9(x));\n+            Asserts.assertEQ(test22(x), new MyValue9(x));\n+            Asserts.assertEQ(test23(x), new MyValue9(x));\n+            Asserts.assertEQ(test24(x, x % 10), new MyValue10(x, x % 10));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":106,"deletions":1,"binary":false,"changes":107,"status":"modified"}]}