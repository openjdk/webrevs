{"files":[{"patch":"@@ -622,1 +622,2 @@\n-      if (instruction->method()->intrinsic_id() == vmIntrinsics::_Object_init) {\n+      if (instruction->method()->intrinsic_id() == vmIntrinsics::_Object_init ||\n+          (instruction->method()->is_object_constructor() && instruction->method()->holder()->is_inlinetype())) {\n@@ -625,0 +626,2 @@\n+        \/\/ Value class constructors update the scalarized receiver. Keep it live so that\n+        \/\/ we can find it after (chained) constructor calls and propagate updates to the caller.\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    \/\/ TODO 8325106 Can we avoid cloning?\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2045,1 +2045,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass)->clone_with_phis(phase, in(0), !_type->maybe_null());\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass, \/* transform = *\/ false)->clone_with_phis(phase, in(0), nullptr, !_type->maybe_null());\n@@ -2075,0 +2075,1 @@\n+      \/\/ TODO 8325106 Can we avoid cloning?\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -582,3 +582,4 @@\n-  if (orig_callee->is_object_constructor() && (orig_callee->holder()->is_abstract() || orig_callee->holder()->is_java_lang_Object()) && peek()->is_InlineType()) {\n-    InlineTypeNode* receiver = peek()->as_InlineType();\n-    \/\/ TODO 8325106 re-enable the assert\n+  if (orig_callee->is_object_constructor() && (orig_callee->holder()->is_abstract() || orig_callee->holder()->is_java_lang_Object()) && stack(sp() - nargs)->is_InlineType()) {\n+    assert(method()->is_object_constructor() && (method()->holder()->is_inlinetype() || method()->holder()->is_abstract()), \"Unexpected caller\");\n+    InlineTypeNode* receiver = stack(sp() - nargs)->as_InlineType();\n+    \/\/ TODO 8325106 re-enable the assert and add the same check for the receiver in the caller map\n@@ -586,1 +587,1 @@\n-    InlineTypeNode* clone = receiver->clone()->as_InlineType();\n+    InlineTypeNode* clone = receiver->clone_if_required(&_gvn, _map);\n@@ -588,1 +589,10 @@\n-    replace_in_map(receiver, _gvn.transform(clone));\n+    clone = _gvn.transform(clone)->as_InlineType();\n+    replace_in_map(receiver, clone);\n+\n+    if (_caller->has_method()) {\n+      \/\/ Get receiver from the caller map and update it in the exit map now that we are done initializing it\n+      SafePointNode* map = _caller->map();\n+      Node* receiver_in_caller = map->argument(_caller, 0)->as_InlineType();\n+      assert(receiver_in_caller->bottom_type()->inline_klass() == receiver->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n+      _exits.map()->replace_edge(receiver_in_caller, clone, &_gvn);\n+    }\n@@ -678,0 +688,1 @@\n+  Node* receiver_in_caller = local(0);\n@@ -806,0 +817,10 @@\n+  \/\/ Did we inline a value class constructor from another value class constructor?\n+  if (cg->is_inline() && cg->method()->is_object_constructor() && cg->method()->holder()->is_inlinetype() &&\n+      _method->is_object_constructor() && cg->method()->holder()->is_inlinetype() && receiver_in_caller == receiver) {\n+    \/\/ Update the receiver in the exit map because the constructor call updated it.\n+    \/\/ MethodLiveness::BasicBlock::compute_gen_kill_single ensures that the receiver in local(0) is live.\n+    assert(local(0)->is_InlineType(), \"Unexpected receiver\");\n+    assert(receiver->bottom_type()->inline_klass() == local(0)->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n+    _exits.map()->replace_edge(receiver, local(0), &_gvn);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1495,0 +1495,1 @@\n+    \/\/ TODO 8325106 Can we avoid cloning?\n@@ -1895,3 +1896,0 @@\n-      if (!is_late_inline && !arg->as_InlineType()->is_larval()) {\n-        arg = arg->as_InlineType()->get_oop();\n-      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map, bool is_init) {\n+  InlineTypeNode* vt = clone_if_required(gvn, map);\n@@ -79,1 +79,1 @@\n-      value = value->as_InlineType()->clone_with_phis(gvn, region);\n+      value = value->as_InlineType()->clone_with_phis(gvn, region, map);\n@@ -423,1 +423,1 @@\n-        val = clone()->as_InlineType();\n+        val = clone_if_required(&kit->gvn(), kit->map());\n@@ -534,1 +534,1 @@\n-    InlineTypeNode* vt = clone()->as_InlineType();\n+    InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n@@ -590,1 +590,0 @@\n-      \/\/ TODO 8325106 MemBarRelease vs. MemBarStoreStore, see set_alloc_with_final\n@@ -611,1 +610,1 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n@@ -670,1 +669,1 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map());\n@@ -878,0 +877,1 @@\n+    assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n@@ -910,2 +910,1 @@\n-\n-      vt = vt->clone_with_phis(&gvn, region);\n+      vt = vt->clone_with_phis(&gvn, region, kit->map());\n@@ -1260,1 +1259,1 @@\n-InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform) {\n@@ -1263,1 +1262,1 @@\n-  return make_null_impl(gvn, vk, visited);\n+  return make_null_impl(gvn, vk, visited, transform);\n@@ -1266,1 +1265,1 @@\n-InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform) {\n@@ -1283,1 +1282,14 @@\n-  return gvn.transform(vt)->as_InlineType();\n+  return transform ? gvn.transform(vt)->as_InlineType() : vt;\n+}\n+\n+InlineTypeNode* InlineTypeNode::clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace) {\n+  if (!safe_for_replace || (map == nullptr && outcnt() != 0)) {\n+    return clone()->as_InlineType();\n+  }\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    if (fast_out(i) != map) {\n+      return clone()->as_InlineType();\n+    }\n+  }\n+  gvn->hash_delete(this);\n+  return this;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform = true);\n@@ -99,1 +99,1 @@\n-  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform = true);\n@@ -106,1 +106,1 @@\n-  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);\n+  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map = nullptr, bool is_init = false);\n@@ -167,0 +167,2 @@\n+  InlineTypeNode* clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace = true);\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-      bool is_larval = (i == 0) && method()->is_object_constructor() && method()->intrinsic_id() != vmIntrinsics::_Object_init;\n+      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_abstract() && !method()->holder()->is_java_lang_Object();\n@@ -1217,1 +1217,2 @@\n-    kit.null_check_receiver_before_call(method());\n+    Node* receiver = kit.argument(0);\n+    Node* null_free = kit.null_check_receiver_before_call(method());\n@@ -1219,0 +1220,5 @@\n+    if (receiver->is_InlineType() && receiver->as_InlineType()->is_larval()) {\n+      \/\/ Replace the larval inline type receiver in the exit map as well to make sure that\n+      \/\/ we can find and update it in Parse::do_call when we are done with the initialization.\n+      _exits.map()->replace_edge(receiver, null_free);\n+    }\n@@ -2178,0 +2184,1 @@\n+    \/\/ TODO 8325106 Why can't we pass map here?\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-    InlineTypeNode* new_vt = obj->clone()->as_InlineType();\n+    InlineTypeNode* new_vt = obj->as_InlineType()->clone_if_required(&_gvn, _map);\n@@ -283,2 +283,3 @@\n-    \/\/ TODO 8325106 needed? I think so, because although we are incrementally inlining, we might not incrementally inline this very method\n-    if ((!_caller->has_method() || C->inlining_incrementally()) && new_vt->is_allocated(&gvn())) {\n+    \/\/ TODO 8325106 Double check and explain these checks\n+    if ((!_caller->has_method() || C->inlining_incrementally() || _caller->method()->is_object_constructor()) && new_vt->is_allocated(&gvn())) {\n+      assert(new_vt->as_InlineType()->is_allocated(&gvn()), \"must be buffered\");\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,2 +103,1 @@\n-    \/\/ TODO 8325106 needed?\n-    if (replaced.improved()->_idx >= idx || replaced.improved()->is_InlineType()) {\n+    if (replaced.improved()->_idx >= idx) {\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+\/\/ TODO 8329234\n+\/\/    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-    \/\/ Test removal of the MemBarRelease following the value buffer initialization\n+    \/\/ Test detection of value object copies and removal of the MemBarRelease following the value buffer initialization\n@@ -1046,0 +1046,19 @@\n+\n+    @DontInline\n+    public void test42_helper(MyValue41 val) {\n+        Asserts.assertEQ(val, new MyValue41(rI));\n+    }\n+\n+    \/\/ Same as test41 but with call argument requiring buffering\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public void test42(MyValue41 val) {\n+        test42_helper(new MyValue41(val.x));\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier() {\n+        MyValue41 val = new MyValue41(rI);\n+        test42(val);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n@@ -50,1 +49,0 @@\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n@@ -65,0 +65,1 @@\n+\/\/ TODO 8325106 Convert this to an IR Framework test but make sure that test coverage doesn't suffer\n@@ -80,1 +81,1 @@\n-    static abstract value class MyAbstract { }\n+    static abstract value class MyAbstract1 { }\n@@ -82,1 +83,1 @@\n-    static value class MyValue2 extends MyAbstract {\n+    static value class MyValue2 extends MyAbstract1 {\n@@ -90,1 +91,7 @@\n-    static value class MyValue3 extends MyAbstract {\n+    static abstract value class MyAbstract2 {\n+        public MyAbstract2(int x) {\n+\n+        }\n+    }\n+\n+    static value class MyValue3 extends MyAbstract2 {\n@@ -94,5 +101,3 @@\n-          this.x = x;\n-          \/\/ TODO 8325106 enable\n-          \/\/  this(x, 0);\n-          \/\/  helper1(this, x, y); \/\/ 'this' escapes through argument\n-          \/\/  helper2(x, y); \/\/ 'this' escapes through receiver\n+            this(x, 0);\n+            helper1(this, x); \/\/ 'this' escapes through argument\n+            helper2(x); \/\/ 'this' escapes through receiver\n@@ -102,4 +107,4 @@\n-            this.x = x;\n-          \/\/  super();\n-          \/\/  helper1(this, x, y); \/\/ 'this' escapes through argument\n-          \/\/  helper2(x, y); \/\/ 'this' escapes through receiver\n+            this.x = helper3(x);\n+            super(x);\n+            helper1(this, x); \/\/ 'this' escapes through argument\n+            helper2(x); \/\/ 'this' escapes through receiver\n@@ -110,1 +115,1 @@\n-        };\n+        }\n@@ -114,1 +119,112 @@\n-        };\n+        }\n+\n+        public static int helper3(int x) {\n+            return x;\n+        }\n+    }\n+\n+    static value class MyValue4 {\n+        Integer x;\n+\n+        public MyValue4(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static value class MyValue5 {\n+        int x;\n+\n+        public MyValue5(int x, boolean b) {\n+            if (b) {\n+                this.x = 42;\n+            } else {\n+                this.x = x;\n+            }\n+        }\n+    }\n+\n+    static value class MyValue6 {\n+        int x;\n+        MyValue1 val;\n+\n+        public MyValue6(int x) {\n+            this.x = x;\n+            this.val = new MyValue1(x);\n+            super();\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7 {\n+        int x;\n+\n+        public MyValue7(int x) {\n+            this.x = x;\n+            new MyValue1(42);\n+            super();\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static value class MyValue8 {\n+        int x;\n+\n+        public MyValue8(int x) {\n+            this(x, 0);\n+        }\n+\n+        public MyValue8(int x, int unused1) {\n+            if ((x % 2) == 0) {\n+                this.x = 42;\n+            } else {\n+                this.x = x;\n+            }\n+        }\n+\n+        public MyValue8(int x, int unused1, int unused2) {\n+            this.x = x;\n+        }\n+\n+        public static MyValue8 valueOf(int x) {\n+            if ((x % 2) == 0) {\n+                return new MyValue8(42, 0, 0);\n+            } else {\n+                return new MyValue8(x, 0, 0);\n+            }\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9 {\n+        MyValue8 val;\n+\n+        public MyValue9(int x) {\n+            this(x, 0);\n+        }\n+\n+        public MyValue9(int i, int unused1) {\n+            val = new MyValue8(i);\n+        }\n+\n+        public MyValue9(int x, int unused1, int unused2) {\n+            this(x, 0, 0, 0);\n+        }\n+\n+        public MyValue9(int i, int unused1, int unused2, int unused3) {\n+            val = MyValue8.valueOf(i);\n+        }\n+    }\n+\n+    \/\/ Constructor with a loop\n+    static value class MyValue10 {\n+        int x;\n+        int y;\n+\n+        public MyValue10(int x, int cnt) {\n+            this.x = x;\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                res += x;\n+            }\n+            this.y = res;\n+        }\n@@ -198,0 +314,48 @@\n+    public static MyValue4 test13(int x) {\n+        return new MyValue4(x);\n+    }\n+\n+    public static MyValue5 test14(int x, boolean b) {\n+        return new MyValue5(x, b);\n+    }\n+\n+    public static Object test15(int x) {\n+        return new MyValue6(x);\n+    }\n+\n+    public static Object test16(int x) {\n+        return new MyValue7(x);\n+    }\n+\n+    public static MyValue8 test17(int x) {\n+        return new MyValue8(x);\n+    }\n+\n+    public static MyValue8 test18(int x) {\n+        return new MyValue8(x, 0);\n+    }\n+\n+    public static MyValue8 test19(int x) {\n+        return MyValue8.valueOf(x);\n+    }\n+\n+    public static MyValue9 test20(int x) {\n+        return new MyValue9(x);\n+    }\n+\n+    public static MyValue9 test21(int x) {\n+        return new MyValue9(x, 0);\n+    }\n+\n+    public static MyValue9 test22(int x) {\n+        return new MyValue9(x, 0, 0);\n+    }\n+\n+    public static MyValue9 test23(int x) {\n+        return new MyValue9(x, 0, 0, 0);\n+    }\n+\n+    public static MyValue10 test24(int x, int cnt) {\n+        return new MyValue10(x, cnt);\n+    }\n+\n@@ -200,1 +364,1 @@\n-            Asserts.assertEQ(test1(x),x);\n+            Asserts.assertEQ(test1(x), x);\n@@ -212,0 +376,12 @@\n+            Asserts.assertEQ(test13(x), new MyValue4(x));\n+            Asserts.assertEQ(test14(x, (x % 2) == 0), new MyValue5(x, (x % 2) == 0));\n+            Asserts.assertEQ(test15(x), new MyValue6(x));\n+            Asserts.assertEQ(test16(x), new MyValue7(x));\n+            Asserts.assertEQ(test17(x), new MyValue8(x));\n+            Asserts.assertEQ(test18(x), new MyValue8(x));\n+            Asserts.assertEQ(test19(x), new MyValue8(x));\n+            Asserts.assertEQ(test20(x), new MyValue9(x));\n+            Asserts.assertEQ(test21(x), new MyValue9(x));\n+            Asserts.assertEQ(test22(x), new MyValue9(x));\n+            Asserts.assertEQ(test23(x), new MyValue9(x));\n+            Asserts.assertEQ(test24(x, x % 10), new MyValue10(x, x % 10));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":193,"deletions":17,"binary":false,"changes":210,"status":"modified"}]}