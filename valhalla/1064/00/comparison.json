{"files":[{"patch":"@@ -111,0 +111,1 @@\n+    \/\/ TODO 8325106 Can we avoid cloning?\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2045,1 +2045,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass)->clone_with_phis(phase, in(0), !_type->maybe_null());\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, inline_klass, \/* transform = *\/ false)->clone_with_phis(phase, in(0), nullptr, !_type->maybe_null());\n@@ -2075,0 +2075,1 @@\n+      \/\/ TODO 8325106 Can we avoid cloning?\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -583,0 +583,1 @@\n+    assert(method()->is_object_constructor() && (method()->holder()->is_inlinetype() || method()->holder()->is_abstract()), \"Unexpected caller\");\n@@ -584,1 +585,1 @@\n-    \/\/ TODO 8325106 re-enable the assert\n+    \/\/ TODO 8325106 re-enable the assert and add the same check for the receiver in the caller map\n@@ -586,1 +587,1 @@\n-    InlineTypeNode* clone = receiver->clone()->as_InlineType();\n+    InlineTypeNode* clone = receiver->clone_if_required(&_gvn, _map);\n@@ -588,1 +589,10 @@\n-    replace_in_map(receiver, _gvn.transform(clone));\n+    clone = _gvn.transform(clone)->as_InlineType();\n+    replace_in_map(receiver, clone);\n+\n+    if (_caller->has_method()) {\n+      \/\/ Get receiver from the caller map and update it in the exit map now that we are done initializing it\n+      SafePointNode* map = _caller->map();\n+      receiver = map->argument(_caller, 0)->as_InlineType();\n+      assert(peek()->bottom_type()->inline_klass() == receiver->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n+      _exits.map()->replace_edge(receiver, clone, &_gvn);\n+    }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1495,0 +1495,1 @@\n+    \/\/ TODO 8325106 Can we avoid cloning?\n@@ -1895,3 +1896,0 @@\n-      if (!is_late_inline && !arg->as_InlineType()->is_larval()) {\n-        arg = arg->as_InlineType()->get_oop();\n-      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map, bool is_init) {\n+  InlineTypeNode* vt = clone_if_required(gvn, map);\n@@ -79,1 +79,1 @@\n-      value = value->as_InlineType()->clone_with_phis(gvn, region);\n+      value = value->as_InlineType()->clone_with_phis(gvn, region, map);\n@@ -423,1 +423,1 @@\n-        val = clone()->as_InlineType();\n+        val = clone_if_required(&kit->gvn(), kit->map());\n@@ -534,1 +534,1 @@\n-    InlineTypeNode* vt = clone()->as_InlineType();\n+    InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n@@ -590,1 +590,0 @@\n-      \/\/ TODO 8325106 MemBarRelease vs. MemBarStoreStore, see set_alloc_with_final\n@@ -611,1 +610,1 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map(), safe_for_replace);\n@@ -670,1 +669,1 @@\n-  InlineTypeNode* vt = clone()->as_InlineType();\n+  InlineTypeNode* vt = clone_if_required(&kit->gvn(), kit->map());\n@@ -878,0 +877,1 @@\n+    assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n@@ -910,2 +910,1 @@\n-\n-      vt = vt->clone_with_phis(&gvn, region);\n+      vt = vt->clone_with_phis(&gvn, region, kit->map());\n@@ -1260,1 +1259,1 @@\n-InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform) {\n@@ -1263,1 +1262,1 @@\n-  return make_null_impl(gvn, vk, visited);\n+  return make_null_impl(gvn, vk, visited, transform);\n@@ -1266,1 +1265,1 @@\n-InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform) {\n@@ -1283,1 +1282,14 @@\n-  return gvn.transform(vt)->as_InlineType();\n+  return transform ? gvn.transform(vt)->as_InlineType() : vt;\n+}\n+\n+InlineTypeNode* InlineTypeNode::clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace) {\n+  if (!safe_for_replace || (map == nullptr && outcnt() != 0)) {\n+    return clone()->as_InlineType();\n+  }\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    if (fast_out(i) != map) {\n+      return clone()->as_InlineType();\n+    }\n+  }\n+  gvn->hash_delete(this);\n+  return this;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_null_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool transform = true);\n@@ -99,1 +99,1 @@\n-  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk, bool transform = true);\n@@ -106,1 +106,1 @@\n-  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);\n+  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, SafePointNode* map = nullptr, bool is_init = false);\n@@ -167,0 +167,2 @@\n+  InlineTypeNode* clone_if_required(PhaseGVN* gvn, SafePointNode* map, bool safe_for_replace = true);\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-      bool is_larval = (i == 0) && method()->is_object_constructor() && method()->intrinsic_id() != vmIntrinsics::_Object_init;\n+      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_abstract() && !method()->holder()->is_java_lang_Object();\n@@ -1217,1 +1217,2 @@\n-    kit.null_check_receiver_before_call(method());\n+    Node* receiver = kit.argument(0);\n+    Node* null_free = kit.null_check_receiver_before_call(method());\n@@ -1219,0 +1220,5 @@\n+    if (receiver->is_InlineType() && receiver->as_InlineType()->is_larval()) {\n+      \/\/ Replace the larval inline type receiver in the exit map as well to make sure that\n+      \/\/ we can find and update it in Parse::do_call when we are done with the initialization.\n+      _exits.map()->replace_edge(receiver, null_free);\n+    }\n@@ -2178,0 +2184,1 @@\n+    \/\/ TODO 8325106 Why can't we pass map here?\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-    InlineTypeNode* new_vt = obj->clone()->as_InlineType();\n+    InlineTypeNode* new_vt = obj->as_InlineType()->clone_if_required(&_gvn, _map);\n@@ -283,2 +283,3 @@\n-    \/\/ TODO 8325106 needed? I think so, because although we are incrementally inlining, we might not incrementally inline this very method\n-    if ((!_caller->has_method() || C->inlining_incrementally()) && new_vt->is_allocated(&gvn())) {\n+    \/\/ TODO 8325106 Double check and explain these checks\n+    if ((!_caller->has_method() || C->inlining_incrementally() || _caller->method()->is_object_constructor()) && new_vt->is_allocated(&gvn())) {\n+      assert(new_vt->as_InlineType()->is_allocated(&gvn()), \"must be buffered\");\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,2 +103,1 @@\n-    \/\/ TODO 8325106 needed?\n-    if (replaced.improved()->_idx >= idx || replaced.improved()->is_InlineType()) {\n+    if (replaced.improved()->_idx >= idx) {\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+\/\/ TODO 8329234\n+\/\/    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-    \/\/ Test removal of the MemBarRelease following the value buffer initialization\n+    \/\/ Test detection of value object copies and removal of the MemBarRelease following the value buffer initialization\n@@ -1046,0 +1046,19 @@\n+\n+    @DontInline\n+    public void test42_helper(MyValue41 val) {\n+        Asserts.assertEQ(val, new MyValue41(rI));\n+    }\n+\n+    \/\/ Same as test41 but with call argument requiring buffering\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public void test42(MyValue41 val) {\n+        test42_helper(new MyValue41(val.x));\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier() {\n+        MyValue41 val = new MyValue41(rI);\n+        test42(val);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n@@ -50,1 +49,0 @@\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main\/othervm -XX:+EnableValhalla\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ * @run main\/othervm -XX:+EnableValhalla -Xbatch -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n@@ -65,0 +65,1 @@\n+\/\/ TODO 8325106 Convert this to an IR Framework test but make sure that test coverage doesn't suffer\n@@ -94,5 +95,3 @@\n-          this.x = x;\n-          \/\/ TODO 8325106 enable\n-          \/\/  this(x, 0);\n-          \/\/  helper1(this, x, y); \/\/ 'this' escapes through argument\n-          \/\/  helper2(x, y); \/\/ 'this' escapes through receiver\n+            this(x, 0);\n+            helper1(this, x); \/\/ 'this' escapes through argument\n+            helper2(x); \/\/ 'this' escapes through receiver\n@@ -102,4 +101,4 @@\n-            this.x = x;\n-          \/\/  super();\n-          \/\/  helper1(this, x, y); \/\/ 'this' escapes through argument\n-          \/\/  helper2(x, y); \/\/ 'this' escapes through receiver\n+            this.x = helper3(x);\n+            super();\n+            helper1(this, x); \/\/ 'this' escapes through argument\n+            helper2(x); \/\/ 'this' escapes through receiver\n@@ -110,1 +109,1 @@\n-        };\n+        }\n@@ -114,1 +113,47 @@\n-        };\n+        }\n+\n+        public static int helper3(int x) {\n+            return x;\n+        }\n+    }\n+\n+    static value class MyValue4 {\n+        Integer x;\n+\n+        public MyValue4(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static value class MyValue5 {\n+        int x;\n+\n+        public MyValue5(int x, boolean b) {\n+            if (b) {\n+                this.x = 42;\n+            } else {\n+                this.x = x;\n+            }\n+        }\n+    }\n+\n+    static value class MyValue6 {\n+        int x;\n+        MyValue1 val;\n+\n+        public MyValue6(int x) {\n+            this.x = x;\n+            this.val = new MyValue1(x);\n+            super();\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7 {\n+        int x;\n+\n+        public MyValue7(int x) {\n+            this.x = x;\n+            new MyValue1(42);\n+            super();\n+        }\n@@ -198,0 +243,16 @@\n+    public static MyValue4 test13(int x) {\n+        return new MyValue4(x);\n+    }\n+\n+    public static MyValue5 test14(int x, boolean b) {\n+        return new MyValue5(x, b);\n+    }\n+\n+    public static Object test15(int x) {\n+        return new MyValue6(x);\n+    }\n+\n+    public static Object test16(int x) {\n+        return new MyValue7(x);\n+    }\n+\n@@ -212,0 +273,4 @@\n+            Asserts.assertEQ(test13(x), new MyValue4(x));\n+            Asserts.assertEQ(test14(x, (x % 2) == 0), new MyValue5(x, (x % 2) == 0));\n+            Asserts.assertEQ(test15(x), new MyValue6(x));\n+            Asserts.assertEQ(test16(x), new MyValue7(x));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":78,"deletions":13,"binary":false,"changes":91,"status":"modified"}]}