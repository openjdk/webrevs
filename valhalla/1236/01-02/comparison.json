{"files":[{"patch":"@@ -624,0 +624,2 @@\n+      const bool abstract_klass = holder->is_abstract();\n+      const bool concrete_value_klass = !abstract_klass && holder->is_inlinetype();\n@@ -625,3 +627,1 @@\n-          (method->is_object_constructor() &&\n-           ((!holder->is_abstract() && holder->is_inlinetype()) ||\n-            holder->is_abstract()))) {\n+          (method->is_object_constructor() && (concrete_value_klass || abstract_klass)) {\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -253,0 +253,3 @@\n+  bool index() const {\n+    return _current_stream.index();\n+  }\n@@ -294,2 +297,2 @@\n-  const FieldStreamType& current() const {\n-    return _current_stream;\n+  bool is_flat() const {\n+    return _current_stream.is_flat();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-    if (fs.current().is_flat()) {\n+    if (fs.is_flat()) {\n@@ -258,1 +258,1 @@\n-      Klass* vk = get_inline_type_field_klass(fs.current().index());\n+      Klass* vk = get_inline_type_field_klass(fs.index());\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1898,1 +1898,0 @@\n-      const ciMethod* caller_method = _method;\n@@ -1902,12 +1901,16 @@\n-      bool must_init_buffer = false;\n-      \/\/ Do we have a larval receiver for an abstract constructor or the Object constructor (that is not going to be\n-      \/\/ inlined)?\n-      if (is_receiver && inline_type->is_larval() && method->is_object_constructor() &&\n-          (holder->is_abstract() || holder->is_java_lang_Object())) {\n-        \/\/ We normally do not want to initialize the buffer of a larval because we are going to update it anyway which\n-        \/\/ requires us to create a new buffer. But at this point, we are going to call the super constructor of this\n-        \/\/ concrete or abstract inline type without inlining it. After that, the larval is completely initialized and\n-        \/\/ thus not a larval anymore. We therefore need to force an initialization of the buffer to not lose all the\n-        \/\/ field writes so far in case the buffer needs to be used (e.g. to read from when deoptimizing at runtime) or\n-        \/\/ further updated in abstract super value class constructors which could have more fields to be initialized.\n-        must_init_buffer = true;\n+      const bool is_abstract_or_object_klass_constructor = method->is_object_constructor() &&\n+                                                           (holder->is_abstract() || holder->is_java_lang_Object());\n+      const bool is_larval_receiver_on_super_constructor = is_receiver && is_abstract_or_object_klass_constructor;\n+      bool must_init_buffer = true;\n+      \/\/ We always need to buffer inline types when they are escaping. However, we can skip the actual initialization\n+      \/\/ of the buffer if the inline type is a larval because we are going to update the buffer anyway which requires\n+      \/\/ us to create a one. But there is one special case where we are still required to initialize the buffer: When\n+      \/\/ we have a larval receiver invoked on an abstract (value class) constructor or the Object constructor (that is\n+      \/\/ not going to be inlined). After this call, the larval is completely initialized and thus not a larval anymore.\n+      \/\/ We therefore need to force an initialization of the buffer to not lose all the field writes so far in case the\n+      \/\/ buffer needs to be used (e.g. to read from when deoptimizing at runtime) or further updated in abstract super\n+      \/\/ value class constructors which could have more fields to be initialized. Note that we do not need to\n+      \/\/ initialize the buffer when invoking another constructor in the same class on a larval receiver because we\n+      \/\/ have not initialized any fields, yet (this is done completely by the other constructor call).\n+      if (inline_type->is_larval() && !is_larval_receiver_on_super_constructor) {\n+        must_init_buffer = false;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -262,3 +262,3 @@\n-  \/\/ updated. If we scalarize and update the fields in the constructor, the updates won't be visible in the caller after deoptimization\n-  \/\/ because the scalarized field values are local to the caller. We need to use a buffer to make the updates visible to\n-  \/\/ the outside.\n+  \/\/ updated. If we scalarize and update the fields in the constructor, the updates won't be visible in the caller after\n+  \/\/ deoptimization because the scalarized field values are local to the caller. We need to use a buffer to make the\n+  \/\/ updates visible to the outside.\n@@ -593,8 +593,4 @@\n-      \/\/ Larval?\n-      \/\/ - must_init set: We are about to call an abstract value class constructor or the Object constructor which is\n-      \/\/                  not inlined. It is therefore escaping and we must initialize the buffer because we have not\n-      \/\/                  done this, yet, for larvals (see second case).\n-      \/\/ - Other larvals: We do not need to initialize the buffer because a larval could still be updated which will\n-      \/\/                  create a new buffer. Once the larval escapes, we will initialize the buffer (must_init set).\n-      assert(!must_init || is_larval(), \"must_init should only be set for larval\");\n-      if (!is_larval() || must_init) {\n+      if (must_init) {\n+        \/\/ Either not a larval or a larval receiver on which we are about to invoke an abstract value class constructor\n+        \/\/ or the Object constructor which is not inlined. It is therefore escaping, and we must initialize the buffer\n+        \/\/ because we have not done this, yet, for larvals (see else case).\n@@ -608,0 +604,4 @@\n+      } else {\n+        \/\/ We do not need to initialize the buffer because a larval could still be updated which will create a new buffer.\n+        \/\/ Once the larval escapes, we will initialize the buffer (must_init set).\n+        assert(is_larval(), \"only larvals can possibly skip the initialization of their buffer\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  InlineTypeNode* buffer(GraphKit* kit, bool safe_for_replace = true, bool must_init = false);\n+  InlineTypeNode* buffer(GraphKit* kit, bool safe_for_replace = true, bool must_init = true);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}