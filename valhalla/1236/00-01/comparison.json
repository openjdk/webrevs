{"files":[{"patch":"@@ -38,1 +38,1 @@\n-    int super_flen   = super_klass->nof_nonstatic_fields();\n+    int super_flen = super_klass->nof_nonstatic_fields();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-        \/\/ Returning from Object.<init> implicitly registers a finalizer for the receiver if needed, so keep it alive.\n+        \/\/ Returning from Object.<init> implicitly registers a finalizer for the receiver if needed, to keep it alive.\n@@ -631,1 +631,1 @@\n-        \/\/ we do not know if the constructor was called from a value class or not. We therefore keep the receiver of all\n+        \/\/ we do not know if the constructor was called on a value class or not. We therefore keep the receiver of all\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-\/\/ Inline types could also have fields in abstract super value classes.\n+\/\/ Value classes could also have fields in abstract super value classes.\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-           \"must have valid receiver after calling another inline type constructor\");\n+           \"must have valid receiver after calling another constructor\");\n@@ -811,2 +811,2 @@\n-        \/\/ AND:\n-        \/\/ 1) ...has the same receiver? Then it's another constructor of the same class doing the initialization.\n+         \/\/ AND:\n+         \/\/ 1) ... invoked on the same receiver? Then it's another constructor on the same object doing the initialization.\n@@ -814,1 +814,1 @@\n-         \/\/ 2) ...is abstract? Then it's the call to the super constructor which eventually calls Object.<init> to\n+         \/\/ 2) ... abstract? Then it's the call to the super constructor which eventually calls Object.<init> to\n@@ -817,2 +817,2 @@\n-         \/\/ 3) ...Object.<init>? Then we know it's the final call to finish the larval initialization. Other\n-         \/\/       Object.<init> calls would have a non-inline-type receiver which we already excluded in the check above.\n+         \/\/ 3) ... Object.<init>? Then we know it's the final call to finish the larval initialization. Other\n+         \/\/        Object.<init> calls would have a non-inline-type receiver which we already excluded in the check above.\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1901,1 +1901,1 @@\n-      const bool is_receiver = i == TypeFunc::Parms;\n+      const bool is_receiver = (i == TypeFunc::Parms);\n@@ -1995,3 +1995,2 @@\n-    Node* receiver = call->in(TypeFunc::Parms);\n-    if (receiver->bottom_type()->is_inlinetypeptr()) {\n-      InlineTypeNode* inline_type_receiver = receiver->as_InlineType();\n+    InlineTypeNode* inline_type_receiver = call->in(TypeFunc::Parms)->isa_InlineType();\n+    if (receiver != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -261,4 +261,4 @@\n-  \/\/ We should not scalarize larvals in their own inline type constructor methods because their fields could still be\n-  \/\/ updated. If we scalarize now and update the fields, we cannot propagate the update out of the constructor call\n-  \/\/ because the scalarized fields are local to this method. We need to use the buffer to make the update visible to\n-  \/\/ the outside (see also CompiledEntrySignature::compute_calling_conventions()).\n+  \/\/ We should not scalarize larvals in debug info of their constructor calls because their fields could still be\n+  \/\/ updated. If we scalarize and update the fields in the constructor, the updates won't be visible in the caller after deoptimization\n+  \/\/ because the scalarized field values are local to the caller. We need to use a buffer to make the updates visible to\n+  \/\/ the outside.\n@@ -268,2 +268,1 @@\n-    \/\/ Receiver of larval is always buffered in its constructor call because it was initially created outside the\n-    \/\/ constructor.\n+    \/\/ Receiver is always buffered because it's passed as oop, see special case in CompiledEntrySignature::compute_calling_conventions().\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"}]}