{"files":[{"patch":"@@ -33,1 +33,9 @@\n-  assert(super() == nullptr || !super()->has_nonstatic_fields(), \"an inline type must not inherit fields from its superclass\");\n+\n+  \/\/ Abstract value classes can also have declared fields.\n+  ciInstanceKlass* super_klass = super();\n+  GrowableArray<ciField*>* super_klass_fields = nullptr;\n+  if (super_klass != nullptr && super_klass->has_nonstatic_fields()) {\n+    int super_flen = super_klass->nof_nonstatic_fields();\n+    super_klass_fields = super_klass->_nonstatic_fields;\n+    assert(super_flen == 0 || super_klass_fields != nullptr, \"first get nof_fields\");\n+  }\n@@ -37,1 +45,1 @@\n-  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(nullptr, false \/* no flattening *\/);)\n+  GUARDED_VM_ENTRY(fields = compute_nonstatic_fields_impl(super_klass_fields, false \/* no flattening *\/);)\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+ public:\n@@ -72,1 +73,1 @@\n-\n+ private:\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -621,7 +621,12 @@\n-    case Bytecodes::_return:\n-      if (instruction->method()->intrinsic_id() == vmIntrinsics::_Object_init ||\n-          (instruction->method()->is_object_constructor() && instruction->method()->holder()->is_inlinetype())) {\n-        \/\/ return from Object.init implicitly registers a finalizer\n-        \/\/ for the receiver if needed, so keep it alive.\n-        \/\/ Value class constructors update the scalarized receiver. Keep it live so that\n-        \/\/ we can find it after (chained) constructor calls and propagate updates to the caller.\n+    case Bytecodes::_return: {\n+      ciMethod* method = instruction->method();\n+      ciInstanceKlass* holder = method->holder();\n+      const bool abstract_klass = holder->is_abstract();\n+      const bool concrete_value_klass = !abstract_klass && holder->is_inlinetype();\n+      if (method->intrinsic_id() == vmIntrinsics::_Object_init ||\n+          (method->is_object_constructor() && (concrete_value_klass || abstract_klass))) {\n+        \/\/ Returning from Object.<init> implicitly registers a finalizer for the receiver if needed, to keep it alive.\n+        \/\/ Value class constructors update the scalarized receiver. We need to keep it live so that we can find it after\n+        \/\/ (chained) constructor calls and propagate updates to the caller. If the holder of the constructor is abstract,\n+        \/\/ we do not know if the constructor was called on a value class or not. We therefore keep the receiver of all\n+        \/\/ abstract constructors live.\n@@ -631,2 +636,1 @@\n-\n-\n+    }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  bool is_flat() {\n+  bool is_flat() const {\n@@ -253,0 +253,3 @@\n+  int index() const {\n+    return _current_stream.index();\n+  }\n@@ -294,0 +297,3 @@\n+  bool is_flat() const {\n+    return _current_stream.is_flat();\n+  }\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -246,0 +246,3 @@\n+\/\/\n+\/\/ Value classes could also have fields in abstract super value classes.\n+\/\/ Use a HierarchicalFieldStream to get them as well.\n@@ -249,1 +252,1 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fs(this); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -581,17 +581,0 @@\n-  \/\/ Detect the call to the object or abstract class constructor at the end of a value constructor to know when we are done initializing the larval\n-  if (orig_callee->is_object_constructor() && (orig_callee->holder()->is_abstract() || orig_callee->holder()->is_java_lang_Object()) && stack(sp() - nargs)->is_InlineType()) {\n-    assert(method()->is_object_constructor() && (method()->holder()->is_inlinetype() || method()->holder()->is_abstract()), \"Unexpected caller\");\n-    InlineTypeNode* receiver = stack(sp() - nargs)->as_InlineType();\n-    InlineTypeNode* clone = receiver->clone_if_required(&_gvn, _map);\n-    clone->set_is_larval(false);\n-    clone = _gvn.transform(clone)->as_InlineType();\n-    replace_in_map(receiver, clone);\n-\n-    if (_caller->has_method()) {\n-      \/\/ Get receiver from the caller map and update it in the exit map now that we are done initializing it\n-      Node* receiver_in_caller = _caller->map()->argument(_caller, 0);\n-      assert(receiver_in_caller->bottom_type()->inline_klass() == receiver->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n-      _exits.map()->replace_edge(receiver_in_caller, clone, &_gvn);\n-    }\n-  }\n-\n@@ -812,8 +795,46 @@\n-    \/\/ Did we inline a value class constructor from another value class constructor?\n-    if (_caller->has_method() && cg->is_inline() && cg->method()->is_object_constructor() && cg->method()->holder()->is_inlinetype() &&\n-        _method->is_object_constructor() && _method->holder()->is_inlinetype() && receiver == _caller->map()->argument(_caller, 0)) {\n-      \/\/ Update the receiver in the exit map because the constructor call updated it.\n-      \/\/ MethodLiveness::BasicBlock::compute_gen_kill_single ensures that the receiver in local(0) is still live.\n-      assert(local(0)->is_InlineType(), \"Unexpected receiver\");\n-      assert(receiver->bottom_type()->inline_klass() == local(0)->bottom_type()->inline_klass(), \"Receiver type mismatch\");\n-      _exits.map()->replace_edge(receiver, local(0), &_gvn);\n+    \/\/ Note that:\n+    \/\/ - The caller map is the state just before the call of the currently parsed method with all arguments\n+    \/\/   on the stack. Therefore, we have caller_map->arg(0) == this.\n+    \/\/ - local(0) contains the updated receiver after calling an inline type constructor.\n+    \/\/ - Abstract value classes are not ciInlineKlass instances and thus abstract_value_klass->is_inlinetype() is false.\n+    \/\/   We use the bottom type of the receiver node to determine if we have a value class or not.\n+    const bool is_current_method_inline_type_constructor =\n+        \/\/ Is current method a constructor (i.e <init>)?\n+        _method->is_object_constructor() &&\n+        \/\/ Is the holder of the current constructor method an inline type?\n+        _caller->map()->argument(_caller, 0)->bottom_type()->is_inlinetypeptr();\n+    assert(!is_current_method_inline_type_constructor || !cg->method()->is_object_constructor() || receiver != nullptr,\n+           \"must have valid receiver after calling another constructor\");\n+    if (is_current_method_inline_type_constructor &&\n+        \/\/ Is the just called method an inline type constructor?\n+        cg->method()->is_object_constructor() && receiver->bottom_type()->is_inlinetypeptr() &&\n+         \/\/ AND:\n+         \/\/ 1) ... invoked on the same receiver? Then it's another constructor on the same object doing the initialization.\n+        (receiver == _caller->map()->argument(_caller, 0) ||\n+         \/\/ 2) ... abstract? Then it's the call to the super constructor which eventually calls Object.<init> to\n+         \/\/                    finish the initialization of this larval.\n+         cg->method()->holder()->is_abstract() ||\n+         \/\/ 3) ... Object.<init>? Then we know it's the final call to finish the larval initialization. Other\n+         \/\/        Object.<init> calls would have a non-inline-type receiver which we already excluded in the check above.\n+         cg->method()->holder()->is_java_lang_Object())\n+        ) {\n+      assert(local(0)->is_InlineType() && receiver->bottom_type()->is_inlinetypeptr() && receiver->is_InlineType() &&\n+             _caller->map()->argument(_caller, 0)->bottom_type()->inline_klass() == receiver->bottom_type()->inline_klass(),\n+             \"Unexpected receiver\");\n+      InlineTypeNode* updated_receiver = local(0)->as_InlineType();\n+      InlineTypeNode* cloned_updated_receiver = updated_receiver->clone_if_required(&_gvn, _map);\n+      cloned_updated_receiver->set_is_larval(false);\n+      cloned_updated_receiver = _gvn.transform(cloned_updated_receiver)->as_InlineType();\n+      \/\/ Receiver updated by the just called constructor. We need to update the map to make the effect visible. After\n+      \/\/ the super() call, only the updated receiver in local(0) will be used from now on. Therefore, we do not need\n+      \/\/ to update the original receiver 'receiver' but only the 'updated_receiver'.\n+      replace_in_map(updated_receiver, cloned_updated_receiver);\n+\n+      if (_caller->has_method()) {\n+        \/\/ If the current method is inlined, we also need to update the exit map to propagate the updated receiver\n+        \/\/ to the caller map.\n+        Node* receiver_in_caller = _caller->map()->argument(_caller, 0);\n+        assert(receiver_in_caller->bottom_type()->inline_klass() == receiver->bottom_type()->inline_klass(),\n+               \"Receiver type mismatch\");\n+        _exits.map()->replace_edge(receiver_in_caller, cloned_updated_receiver, &_gvn);\n+      }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -993,2 +993,3 @@\n-        if (val->is_InlineType() && val->isa_InlineType()->is_larval() && callee_jvms != nullptr &&\n-            callee_jvms->method()->is_object_constructor() && callee_jvms->method()->holder()->is_inlinetype() && val == in_map->argument(in_jvms, 0)) {\n+        if (callee_jvms != nullptr && val->is_InlineType() && val->as_InlineType()->is_larval() &&\n+            callee_jvms->method()->is_object_constructor() && val == in_map->argument(in_jvms, 0) &&\n+            val->bottom_type()->is_inlinetypeptr()) {\n@@ -1011,2 +1012,3 @@\n-        if (val->is_InlineType() && val->isa_InlineType()->is_larval() && callee_jvms != nullptr &&\n-            callee_jvms->method()->is_object_constructor() && callee_jvms->method()->holder()->is_inlinetype() && val == in_map->argument(in_jvms, 0)) {\n+        if (callee_jvms != nullptr && val->is_InlineType() && val->as_InlineType()->is_larval() &&\n+            callee_jvms->method()->is_object_constructor() && val == in_map->argument(in_jvms, 0) &&\n+            val->bottom_type()->is_inlinetypeptr()) {\n@@ -1895,1 +1897,22 @@\n-      arg = arg->as_InlineType()->buffer(this);\n+      InlineTypeNode* inline_type = arg->as_InlineType();\n+      const ciMethod* method = call->method();\n+      ciInstanceKlass* holder = method->holder();\n+      const bool is_receiver = (i == TypeFunc::Parms);\n+      const bool is_abstract_or_object_klass_constructor = method->is_object_constructor() &&\n+                                                           (holder->is_abstract() || holder->is_java_lang_Object());\n+      const bool is_larval_receiver_on_super_constructor = is_receiver && is_abstract_or_object_klass_constructor;\n+      bool must_init_buffer = true;\n+      \/\/ We always need to buffer inline types when they are escaping. However, we can skip the actual initialization\n+      \/\/ of the buffer if the inline type is a larval because we are going to update the buffer anyway which requires\n+      \/\/ us to create a new one. But there is one special case where we are still required to initialize the buffer:\n+      \/\/ When we have a larval receiver invoked on an abstract (value class) constructor or the Object constructor (that\n+      \/\/ is not going to be inlined). After this call, the larval is completely initialized and thus not a larval anymore.\n+      \/\/ We therefore need to force an initialization of the buffer to not lose all the field writes so far in case the\n+      \/\/ buffer needs to be used (e.g. to read from when deoptimizing at runtime) or further updated in abstract super\n+      \/\/ value class constructors which could have more fields to be initialized. Note that we do not need to\n+      \/\/ initialize the buffer when invoking another constructor in the same class on a larval receiver because we\n+      \/\/ have not initialized any fields, yet (this is done completely by the other constructor call).\n+      if (inline_type->is_larval() && !is_larval_receiver_on_super_constructor) {\n+        must_init_buffer = false;\n+      }\n+      arg = inline_type->buffer(this, true, must_init_buffer);\n@@ -1973,7 +1996,11 @@\n-  if (call->method()->is_object_constructor() && call->method()->holder()->is_inlinetype()) {\n-    InlineTypeNode* receiver = call->in(TypeFunc::Parms)->as_InlineType();\n-    assert(receiver->is_larval(), \"must be larval\");\n-    assert(receiver->is_allocated(&gvn()), \"larval must be buffered\");\n-    InlineTypeNode* reloaded = InlineTypeNode::make_from_oop(this, receiver->get_oop(), receiver->bottom_type()->inline_klass(), true);\n-    assert(!reloaded->is_larval(), \"should not be larval anymore\");\n-    replace_in_map(receiver, reloaded);\n+  ciMethod* method = call->method();\n+  if (method->is_object_constructor() && !method->holder()->is_java_lang_Object()) {\n+    InlineTypeNode* inline_type_receiver = call->in(TypeFunc::Parms)->isa_InlineType();\n+    if (inline_type_receiver != nullptr) {\n+      assert(inline_type_receiver->is_larval(), \"must be larval\");\n+      assert(inline_type_receiver->is_allocated(&gvn()), \"larval must be buffered\");\n+      InlineTypeNode* reloaded = InlineTypeNode::make_from_oop(this, inline_type_receiver->get_oop(),\n+                                                               inline_type_receiver->bottom_type()->inline_klass(), true);\n+      assert(!reloaded->is_larval(), \"should not be larval anymore\");\n+      replace_in_map(inline_type_receiver, reloaded);\n+    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -261,3 +261,8 @@\n-  \/\/ Don't scalarize larvals in their own constructor call because the constructor will update them\n-  if (is_larval() && sfpt->is_CallJava() && sfpt->as_CallJava()->method() != nullptr && sfpt->as_CallJava()->method()->is_object_constructor() &&\n-      sfpt->as_CallJava()->method()->holder()->is_inlinetype() && sfpt->in(TypeFunc::Parms) == this) {\n+  \/\/ We should not scalarize larvals in debug info of their constructor calls because their fields could still be\n+  \/\/ updated. If we scalarize and update the fields in the constructor, the updates won't be visible in the caller after\n+  \/\/ deoptimization because the scalarized field values are local to the caller. We need to use a buffer to make the\n+  \/\/ updates visible to the outside.\n+  if (is_larval() && sfpt->is_CallJava() && sfpt->as_CallJava()->method() != nullptr &&\n+      sfpt->as_CallJava()->method()->is_object_constructor() && bottom_type()->is_inlinetypeptr() &&\n+      sfpt->in(TypeFunc::Parms) == this) {\n+    \/\/ Receiver is always buffered because it's passed as oop, see special case in CompiledEntrySignature::compute_calling_conventions().\n@@ -532,1 +537,1 @@\n-InlineTypeNode* InlineTypeNode::buffer(GraphKit* kit, bool safe_for_replace) {\n+InlineTypeNode* InlineTypeNode::buffer(GraphKit* kit, bool safe_for_replace, bool must_init) {\n@@ -587,3 +592,5 @@\n-      \/\/ No need to initialize a larval buffer, we make sure that the oop can not escape\n-      if (!is_larval()) {\n-        \/\/ Larval will be initialized later\n+\n+      if (must_init) {\n+        \/\/ Either not a larval or a larval receiver on which we are about to invoke an abstract value class constructor\n+        \/\/ or the Object constructor which is not inlined. It is therefore escaping, and we must initialize the buffer\n+        \/\/ because we have not done this, yet, for larvals (see else case).\n@@ -597,0 +604,4 @@\n+      } else {\n+        \/\/ We do not need to initialize the buffer because a larval could still be updated which will create a new buffer.\n+        \/\/ Once the larval escapes, we will initialize the buffer (must_init set).\n+        assert(is_larval(), \"only larvals can possibly skip the initialization of their buffer\");\n@@ -1330,0 +1341,8 @@\n+\n+#ifndef PRODUCT\n+void InlineTypeNode::dump_spec(outputStream* st) const {\n+  if (_is_larval) {\n+    st->print(\" #larval\");\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  InlineTypeNode* buffer(GraphKit* kit, bool safe_for_replace = true);\n+  InlineTypeNode* buffer(GraphKit* kit, bool safe_for_replace = true, bool must_init = true);\n@@ -175,0 +175,2 @@\n+\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const;)\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -626,1 +626,1 @@\n-      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_abstract() && !method()->holder()->is_java_lang_Object();\n+      bool is_larval = (i == 0) && method()->is_object_constructor() && !method()->holder()->is_java_lang_Object();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2210,0 +2210,2 @@\n+\/\/ TODO 8325632 Fails with -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n+\/*\n@@ -2239,3 +2241,0 @@\n-\/\/ TODO 8325632 Fails with -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n-\/*\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @test TestValueConstruction\n+ * @test id=Xbatch\n@@ -43,0 +43,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=DeoptimizeALot\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -46,0 +55,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=CompileonlyTest\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +68,23 @@\n+ *\/\n+\n+\/**\n+ * @test id=DontInlineHelper\n+ * @summary Test construction of value objects.\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:CompileCommand=dontinline,compiler*::helper*\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineMyValueInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -54,0 +95,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineObjectInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -58,2 +108,11 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n- *                   -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineObjectInitDeoptimizeALot\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+DeoptimizeALot -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n@@ -62,0 +121,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineMyAbstractInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -66,0 +134,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInlining\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -70,0 +147,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningCompileOnlyTest\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -75,0 +161,8 @@\n+ *\/\n+\n+\/* @test id=StressIncrementalInliningDontInlineMyValueInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -80,0 +174,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningDontInlineObjectInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -85,0 +188,9 @@\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningDontInlineMyAbstractInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -96,1 +208,5 @@\n-    static boolean deopt[] = new boolean[13];\n+    static boolean[] deopt = new boolean[14];\n+    static boolean[] deoptBig = new boolean[24];\n+    static boolean[] deoptHuge = new boolean[37];\n+\n+    static Object o = new Object();\n@@ -113,0 +229,16 @@\n+    \/\/ Trigger deopts at various places\n+    static void checkDeoptBig(int deoptNum) {\n+        if (deoptBig[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n+\n+    \/\/ Trigger deopts at various places\n+    static void checkDeoptHuge(int deoptNum) {\n+        if (deoptHuge[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n+\n@@ -141,0 +273,73 @@\n+    static value class MyValue1a extends MyAbstract1 implements MyInterface {\n+        int x;\n+\n+        public MyValue1a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1a(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static abstract value class AMyValue1 implements MyInterface {\n+        int x;\n+\n+        public AMyValue1(int x) {\n+            checkDeopt(3);\n+            this.x = x;\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+\n+        public AMyValue1(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue1b extends AMyValue1 implements MyInterface {\n+        int x;\n+\n+        public MyValue1b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super(x);\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1b(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super(x, deoptNum1 + 3, deoptNum2 + 3, deoptNum3 + 3);\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+\n@@ -204,0 +409,60 @@\n+    static abstract value class AMyValue3a {\n+        int x;\n+\n+        public AMyValue3a(int x) {\n+            this.x = helper3(x, 5);\n+            super();\n+            helper1(this, x, 6); \/\/ 'this' escapes through argument\n+            helper2(x, 7); \/\/ 'this' escapes through receiver\n+            checkDeopt(8);\n+        }\n+\n+        public static void helper1(AMyValue3a obj, int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(obj.x, x);\n+        }\n+\n+        public void helper2(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(this.x, x);\n+        }\n+\n+        public static int helper3(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            return x;\n+        }\n+    }\n+\n+    static value class MyValue3a extends AMyValue3a {\n+        int y;\n+\n+        public MyValue3a(int y) {\n+            checkDeopt(1);\n+            this.y = helper3(y, 5);\n+            super(y);\n+            helper1(this, y, 2); \/\/ 'this' escapes through argument\n+            helper2(y, 3); \/\/ 'this' escapes through receiver\n+            checkDeopt(4);\n+        }\n+\n+\n+        public static void helper1(MyValue3a obj, int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(obj.y, y);\n+        }\n+\n+        public void helper2(int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(this.y, y);\n+        }\n+\n+        public static int helper3(int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            return y;\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + y;\n+        }\n+    }\n+\n@@ -220,1 +485,33 @@\n-    static value class MyValue5 {\n+    abstract static value class AMyValue4a {\n+        Integer y;\n+\n+        public AMyValue4a(int y) {\n+            checkDeopt(3);\n+            this.y = y;\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    static value class MyValue4a extends AMyValue4a {\n+        Integer x;\n+\n+        public MyValue4a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super(x);\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue5 extends MyAbstract1 {\n@@ -244,0 +541,48 @@\n+    static abstract value class AMyValue5a {\n+        int y;\n+\n+        public AMyValue5a(int y, boolean b) {\n+            checkDeopt(7);\n+            if (b) {\n+                checkDeopt(8);\n+                this.y = 42;\n+                checkDeopt(9);\n+            } else {\n+                checkDeopt(10);\n+                this.y = y;\n+                checkDeopt(11);\n+            }\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    static value class MyValue5a extends AMyValue5a {\n+        int x;\n+\n+        public MyValue5a(int x, boolean b) {\n+            checkDeopt(0);\n+            if (b) {\n+                checkDeopt(1);\n+                this.x = 42;\n+                checkDeopt(2);\n+            } else {\n+                checkDeopt(3);\n+                this.x = x;\n+                checkDeopt(4);\n+            }\n+            checkDeopt(5);\n+            super(x, b);\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n@@ -266,0 +611,44 @@\n+    static value class MyValue6a {\n+        int x;\n+        MyValue1a val1;\n+        MyValue1a val2;\n+\n+        public MyValue6a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue1a(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1a(x + 1, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    static value class MyValue6b {\n+        int x;\n+        MyValue1b val1;\n+        MyValue1b val2;\n+\n+        public MyValue6b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue1b(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1b(x + 1, 6, 7, 8);\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n+        }\n+    }\n+\n@@ -287,0 +676,42 @@\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7a {\n+        int x;\n+\n+        public MyValue7a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            new MyValue1a(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1a(43, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7b {\n+        int x;\n+\n+        public MyValue7b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            new MyValue1b(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1b(43, 6, 7, 8);\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n@@ -331,1 +762,200 @@\n-            return \"x: \" + x;\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static abstract value class AMyValue8a {\n+        int y;\n+\n+        public AMyValue8a(int y) {\n+            checkDeoptBig(9);\n+            this(y, 0);\n+            checkDeoptBig(10);\n+        }\n+\n+        public AMyValue8a(int y, int unused1) {\n+            checkDeoptBig(11);\n+            if ((y % 2) == 0) {\n+                checkDeoptBig(12);\n+                this.y = 42;\n+                checkDeoptBig(13);\n+            } else {\n+                checkDeoptBig(14);\n+                this.y = y;\n+                checkDeoptBig(15);\n+            }\n+            checkDeoptBig(16);\n+            super();\n+            checkDeoptBig(17);\n+        }\n+\n+        public AMyValue8a(int y, int unused1, int unused2) {\n+            checkDeoptBig(12);\n+            this.y = y;\n+            checkDeoptBig(13);\n+        }\n+\n+        public static AMyValue8a valueOf(int y) {\n+            checkDeoptBig(0);\n+            if ((y % 2) == 0) {\n+                checkDeoptBig(1);\n+                return new MyValue8a(42, 0, 0);\n+            } else {\n+                checkDeoptBig(2);\n+                return new MyValue8a(y, 0, 0);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static value class MyValue8a extends AMyValue8a {\n+        int x;\n+\n+        public MyValue8a(int x) {\n+            checkDeoptBig(0);\n+            this(x, 0);\n+            checkDeoptBig(1);\n+        }\n+\n+        public MyValue8a(int x, int unused1) {\n+            checkDeoptBig(2);\n+            if ((x % 2) == 0) {\n+                checkDeoptBig(3);\n+                this.x = 42;\n+                checkDeoptBig(4);\n+            } else {\n+                checkDeoptBig(5);\n+                this.x = x;\n+                checkDeoptBig(6);\n+            }\n+            checkDeoptBig(7);\n+            super(unused1);\n+            checkDeoptBig(8);\n+        }\n+\n+        public MyValue8a(int x, int unused1, int unused2) {\n+            checkDeoptBig(3);\n+            this.x = x;\n+            checkDeoptBig(4);\n+            super(x, unused1, unused2);\n+        }\n+\n+        public static MyValue8a valueOf(int x) {\n+            checkDeoptBig(0);\n+            if ((x % 2) == 0) {\n+                checkDeoptBig(1);\n+                return new MyValue8a(42, 0, 0);\n+            } else {\n+                checkDeoptBig(2);\n+                return new MyValue8a(x, 0, 0);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9 {\n+        MyValue8 val;\n+\n+        public MyValue9(int x) {\n+            checkDeopt(9);\n+            this(x, 0);\n+            checkDeopt(10);\n+        }\n+\n+        public MyValue9(int i, int unused1) {\n+            checkDeopt(11);\n+            val = new MyValue8(i);\n+            checkDeopt(12);\n+        }\n+\n+        public MyValue9(int x, int unused1, int unused2) {\n+            checkDeopt(5);\n+            this(x, 0, 0, 0);\n+            checkDeopt(6);\n+        }\n+\n+        public MyValue9(int i, int unused1, int unused2, int unused3) {\n+            checkDeopt(7);\n+            val = MyValue8.valueOf(i);\n+            checkDeopt(8);\n+        }\n+\n+        public String toString() {\n+            return \"val: [\" + val + \"]\";\n+        }\n+    }\n+\n+    abstract static value class AMyValue9a {\n+        AMyValue8a valA;\n+\n+        public AMyValue9a(int x) {\n+            checkDeoptHuge(22);\n+            this(x, 0);\n+            checkDeoptHuge(23);\n+        }\n+\n+        public AMyValue9a(int i, int unused1) {\n+            checkDeoptHuge(24);\n+            valA = new MyValue8a(i);\n+            checkDeoptHuge(25);\n+        }\n+\n+        public AMyValue9a(int x, int unused1, int unused2) {\n+            checkDeoptHuge(18);\n+            this(x, 0, 0, 0);\n+            checkDeoptHuge(19);\n+        }\n+\n+        public AMyValue9a(int i, int unused1, int unused2, int unused3) {\n+            checkDeoptHuge(20);\n+            valA = MyValue8a.valueOf(i);\n+            checkDeoptHuge(21);\n+        }\n+\n+        public String toString() {\n+            return \"valA: [\" + valA + \"]\";\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9a extends AMyValue9a {\n+        MyValue8a val;\n+\n+        public MyValue9a(int x) {\n+            checkDeoptHuge(18);\n+            this(x, 0);\n+            checkDeoptHuge(19);\n+        }\n+\n+        public MyValue9a(int i, int unused1) {\n+            checkDeoptHuge(20);\n+            val = new MyValue8a(i);\n+            checkDeoptHuge(21);\n+            super(i, unused1);\n+            checkDeoptHuge(26);\n+        }\n+\n+        public MyValue9a(int x, int unused1, int unused2) {\n+            checkDeoptHuge(14);\n+            this(x, 0, 0, 0);\n+            checkDeoptHuge(15);\n+        }\n+\n+        public MyValue9a(int i, int unused1, int unused2, int unused3) {\n+            checkDeoptHuge(16);\n+            val = MyValue8a.valueOf(i);\n+            checkDeoptHuge(17);\n+            super(i, unused1, unused2, unused3);\n+            checkDeoptHuge(27);\n+        }\n+\n+        public String toString() {\n+            return \"val: [\" + val + \"]\";\n@@ -335,3 +965,4 @@\n-    \/\/ Constructor calling another constructor of a different value class\n-    static value class MyValue9 {\n-        MyValue8 val;\n+    \/\/ Constructor with a loop\n+    static value class MyValue10 {\n+        int x;\n+        int y;\n@@ -339,4 +970,15 @@\n-        public MyValue9(int x) {\n-            checkDeopt(9);\n-            this(x, 0);\n-            checkDeopt(10);\n+        public MyValue10(int x, int cnt) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                checkDeopt(2);\n+                res += x;\n+                checkDeopt(3);\n+            }\n+            checkDeopt(4);\n+            this.y = res;\n+            checkDeopt(5);\n+            super();\n+            checkDeopt(6);\n@@ -345,4 +987,2 @@\n-        public MyValue9(int i, int unused1) {\n-            checkDeopt(11);\n-            val = new MyValue8(i);\n-            checkDeopt(12);\n+        public String toString() {\n+            return \"x: \" + x + \", y: \" + y;\n@@ -350,0 +990,1 @@\n+    }\n@@ -351,5 +992,4 @@\n-        public MyValue9(int x, int unused1, int unused2) {\n-            checkDeopt(5);\n-            this(x, 0, 0, 0);\n-            checkDeopt(6);\n-        }\n+    \/\/ Constructor with a loop\n+    static abstract value class AMyValue10a {\n+        int a;\n+        int b;\n@@ -357,1 +997,1 @@\n-        public MyValue9(int i, int unused1, int unused2, int unused3) {\n+        public AMyValue10a(int a, int cnt) {\n@@ -359,1 +999,1 @@\n-            val = MyValue8.valueOf(i);\n+            this.a = a;\n@@ -361,0 +1001,11 @@\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                checkDeopt(9);\n+                res += a;\n+                checkDeopt(10);\n+            }\n+            checkDeopt(11);\n+            this.b = res;\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n@@ -364,1 +1015,1 @@\n-            return \"val: [\" + val + \"]\";\n+            return \"x: \" + a + \", y: \" + b;\n@@ -369,1 +1020,1 @@\n-    static value class MyValue10 {\n+    static value class MyValue10a extends AMyValue10a {\n@@ -373,1 +1024,1 @@\n-        public MyValue10(int x, int cnt) {\n+        public MyValue10a(int x, int cnt) {\n@@ -386,1 +1037,1 @@\n-            super();\n+            super(x, cnt);\n@@ -426,0 +1077,250 @@\n+    \/\/ Value class with recursive field definitions\n+    static abstract value class AMyValue11a {\n+        int y;\n+        AMyValue11a valA1;\n+        AMyValue11a valA2;\n+\n+        public AMyValue11a(int y) {\n+            checkDeoptHuge(19);\n+            this.y = y;\n+            checkDeoptHuge(20);\n+            this.valA1 = new MyValue11a(y + 1, 21, 22, 23, 24, 25);\n+            checkDeoptHuge(26);\n+            this.valA2 = new MyValue11a(y + 2, 27, 28, 29, 30, 31);\n+            checkDeoptHuge(36);\n+        }\n+\n+        public AMyValue11a(int y, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4) {\n+            checkDeoptHuge(deoptNum1);\n+            this.y = y;\n+            checkDeoptHuge(deoptNum2);\n+            this.valA1 = null;\n+            checkDeoptHuge(deoptNum3);\n+            this.valA2 = null;\n+            checkDeoptHuge(deoptNum4);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + y + \", val1: [\" + (valA1 != this ? valA1 : \"this\") + \"], val2: [\" + (valA2 != this ? valA2 : \"this\") + \"]\";\n+        }\n+    }\n+\n+    \/\/ Value class with recursive field definitions\n+    static value class MyValue11a extends AMyValue11a {\n+        int x;\n+        MyValue11a val1;\n+        MyValue11a val2;\n+\n+        public MyValue11a(int x) {\n+            checkDeoptHuge(0);\n+            this.x = x;\n+            checkDeoptHuge(1);\n+            this.val1 = new MyValue11a(x + 1, 2, 3, 4, 5, 6);\n+            checkDeoptHuge(7);\n+            this.val2 = new MyValue11a(x + 2, 8, 9, 10, 11, 12);\n+            checkDeoptHuge(17);\n+            super(x);\n+            checkDeoptHuge(18);\n+        }\n+\n+        public MyValue11a(int x, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4, int deoptNum5) {\n+            checkDeoptHuge(deoptNum1);\n+            this.x = x;\n+            checkDeoptHuge(deoptNum2);\n+            this.val1 = null;\n+            checkDeoptHuge(deoptNum3);\n+            this.val2 = null;\n+            checkDeoptHuge(deoptNum4);\n+            super(x, deoptNum5 + 1, deoptNum5 + 2, deoptNum5 + 3, deoptNum5 + 4);\n+            checkDeoptHuge(deoptNum5);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + (val1 != this ? val1 : \"this\") + \"], val2: [\" + (val2 != this ? val2 : \"this\") + \"]\";\n+        }\n+    }\n+\n+    static value class MyValue12 {\n+        Object o;\n+\n+        public MyValue12() {\n+            checkDeopt(0);\n+            this.o = new Object();\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+    }\n+\n+    static abstract value class MyAbsract13b {\n+        MyAbsract13b() {\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+    }\n+\n+    static abstract value class MyAbsract13a extends MyAbsract13b {\n+        MyAbsract13a() {\n+            checkDeopt(2);\n+            super();\n+            checkDeopt(3);\n+        }\n+    }\n+\n+    static value class MyValue13 extends MyAbsract13a {\n+        public MyValue13() {\n+            checkDeopt(0);\n+            super();\n+            checkDeopt(1);\n+        }\n+    }\n+\n+    static value class MyValue14 {\n+        private Object o;\n+\n+        public MyValue14(Object o) {\n+            this.o = o;\n+        }\n+\n+        public static MyValue14 get(Object o) {\n+            return new MyValue14(getO(o));\n+        }\n+\n+        public static Object getO(Object obj) {\n+            return obj;\n+        }\n+    }\n+\n+    static abstract value class MyAbstract15 {\n+        int i;\n+\n+        public MyAbstract15(int i) {\n+            checkDeoptBig(2);\n+            this.i = 34;\n+            checkDeoptBig(3);\n+            super();\n+            checkDeoptBig(4);\n+            MyValue15 v = new MyValue15();\n+            checkDeoptBig(11);\n+            foo(v);\n+            checkDeoptBig(13);\n+        }\n+\n+        MyValue15 foo(MyValue15 v) {\n+            checkDeoptBig(12);\n+            return v;\n+        }\n+\n+        public MyAbstract15() {\n+            checkDeoptBig(17);\n+            this.i = 4;\n+            checkDeoptBig(18);\n+            super();\n+            checkDeoptBig(19);\n+        }\n+    }\n+\n+    static value class MyValue15 extends MyAbstract15 {\n+        int i;\n+\n+        public MyValue15(int i) {\n+            checkDeoptBig(0);\n+            this.i = 3;\n+            checkDeoptBig(1);\n+            super(i);\n+            checkDeoptBig(14);\n+            MyValue15 v = new MyValue15();\n+            checkDeoptBig(21);\n+            getO(v);\n+            checkDeoptBig(23);\n+        }\n+\n+\n+        public MyValue15() {\n+            checkDeoptBig( 15);\n+            this.i = 43;\n+            checkDeoptBig(16);\n+            super();\n+            checkDeoptBig(20);\n+        }\n+\n+        static Object getO(Object o) {\n+            checkDeoptBig(22);\n+            return o;\n+        }\n+    }\n+\n+    static abstract value class MyAbstract16 {\n+        int i;\n+        public MyAbstract16() {\n+            checkDeoptBig(8);\n+            this.i = 4;\n+            checkDeoptBig(9);\n+            super();\n+            checkDeoptBig(10);\n+        }\n+\n+        public MyAbstract16(int i) {\n+            checkDeoptBig(2);\n+            this.i = 34;\n+            checkDeoptBig(3);\n+            super();\n+            checkDeoptBig(4);\n+            getV();\n+            checkDeoptBig(13);\n+        }\n+\n+        public MyAbstract16(boolean ignore) {\n+            checkDeoptBig(17);\n+            this.i = 4;\n+            checkDeoptBig(18);\n+            super();\n+            checkDeoptBig(19);\n+        }\n+\n+        public static MyValue16 getV() {\n+            checkDeoptBig(5);\n+            MyValue16 v = new MyValue16();\n+            checkDeoptBig(12);\n+            return v;\n+        }\n+    }\n+\n+    static value class MyValue16 extends MyAbstract16 {\n+        int i;\n+\n+        public MyValue16(int i) {\n+            checkDeoptBig(0);\n+            this.i = 3;\n+            checkDeoptBig(1);\n+            super(i);\n+            checkDeoptBig(14);\n+            MyValue16 v = new MyValue16(true);\n+            checkDeoptBig(21);\n+            getO(v);\n+            checkDeoptBig(23);\n+        }\n+\n+        public MyValue16() {\n+            checkDeoptBig( 6);\n+            this.i = 34;\n+            checkDeoptBig(7);\n+            super();\n+            checkDeoptBig(11);\n+        }\n+\n+        public MyValue16(boolean ignore) {\n+            checkDeoptBig( 15);\n+            this.i = 43;\n+            checkDeoptBig(16);\n+            super(true);\n+            checkDeoptBig(20);\n+        }\n+\n+        static Object getO(Object o) {\n+            checkDeoptBig(22);\n+            return o;\n+        }\n+    }\n+\n@@ -432,0 +1333,12 @@\n+    public static int test1a(int x) {\n+        MyValue1a val = new MyValue1a(x);\n+        checkDeopt(3);\n+        return val.x;\n+    }\n+\n+    public static int test1b(int x) {\n+        MyValue1b val = new MyValue1b(x);\n+        checkDeopt(6);\n+        return val.x;\n+    }\n+\n@@ -436,0 +1349,8 @@\n+    public static MyValue1a helper1a(int x) {\n+        return new MyValue1a(x);\n+    }\n+\n+    public static MyValue1b helper1b(int x) {\n+        return new MyValue1b(x);\n+    }\n+\n@@ -439,0 +1360,6 @@\n+    public static Object test2a(int x) {\n+        return helper1a(x);\n+    }\n+    public static Object test2b(int x) {\n+        return helper1b(x);\n+    }\n@@ -449,0 +1376,18 @@\n+    public static Object test3a(int limit) {\n+        MyValue1a res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue1a(i);\n+            checkDeopt(3);\n+        }\n+        return res;\n+    }\n+\n+    public static Object test3b(int limit) {\n+        MyValue1b res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue1b(i);\n+            checkDeopt(6);\n+        }\n+        return res;\n+    }\n+\n@@ -456,0 +1401,14 @@\n+    public static MyValue1a test4a(int x) {\n+        MyValue1a v = new MyValue1a(x);\n+        checkDeopt(3);\n+        v = new MyValue1a(x);\n+        return v;\n+    }\n+\n+    public static MyValue1b test4b(int x) {\n+        MyValue1b v = new MyValue1b(x);\n+        checkDeopt(6);\n+        v = new MyValue1b(x);\n+        return v;\n+    }\n+\n@@ -492,0 +1451,6 @@\n+    public static int test9a(int x) {\n+        MyValue3a val = new MyValue3a(x);\n+        checkDeopt(9);\n+        return val.x + val.y;\n+    }\n+\n@@ -500,0 +1465,8 @@\n+    public static MyValue3a helper3a(int x) {\n+        return new MyValue3a(x);\n+    }\n+\n+    public static Object test10a(int x) {\n+        return helper3a(x);\n+    }\n+\n@@ -509,0 +1482,9 @@\n+    public static Object test11a(int limit) {\n+        MyValue3a res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            checkDeopt(9);\n+            res = new MyValue3a(i);\n+        }\n+        return res;\n+    }\n+\n@@ -516,0 +1498,7 @@\n+    public static MyValue3a test12a(int x) {\n+        MyValue3a v = new MyValue3a(x);\n+        checkDeopt(9);\n+        v = new MyValue3a(x);\n+        return v;\n+    }\n+\n@@ -520,0 +1509,4 @@\n+    public static MyValue4a test13a(int x) {\n+        return new MyValue4a(x);\n+    }\n+\n@@ -524,0 +1517,4 @@\n+    public static MyValue5a test14a(int x, boolean b) {\n+        return new MyValue5a(x, b);\n+    }\n+\n@@ -528,0 +1525,8 @@\n+    public static Object test15a(int x) {\n+        return new MyValue6a(x);\n+    }\n+\n+    public static Object test15b(int x) {\n+        return new MyValue6b(x);\n+    }\n+\n@@ -532,0 +1537,8 @@\n+    public static Object test16a(int x) {\n+        return new MyValue7a(x);\n+    }\n+\n+    public static Object test16b(int x) {\n+        return new MyValue7b(x);\n+    }\n+\n@@ -536,0 +1549,4 @@\n+    public static MyValue8a test17a(int x) {\n+        return new MyValue8a(x);\n+    }\n+\n@@ -540,0 +1557,4 @@\n+    public static MyValue8a test18a(int x) {\n+        return new MyValue8a(x, 0);\n+    }\n+\n@@ -544,0 +1565,8 @@\n+    public static MyValue8a test19a(int x) {\n+        return MyValue8a.valueOf(x);\n+    }\n+\n+    public static AMyValue8a test19b(int x) {\n+        return AMyValue8a.valueOf(x);\n+    }\n+\n@@ -548,0 +1577,4 @@\n+    public static MyValue9a test20a(int x) {\n+        return new MyValue9a(x);\n+    }\n+\n@@ -552,0 +1585,4 @@\n+    public static MyValue9a test21a(int x) {\n+        return new MyValue9a(x, 0);\n+    }\n+\n@@ -556,0 +1593,4 @@\n+    public static MyValue9a test22a(int x) {\n+        return new MyValue9a(x, 0, 0);\n+    }\n+\n@@ -560,0 +1601,4 @@\n+    public static MyValue9a test23a(int x) {\n+        return new MyValue9a(x, 0, 0, 0);\n+    }\n+\n@@ -564,0 +1609,4 @@\n+    public static MyValue10a test24a(int x, int cnt) {\n+        return new MyValue10a(x, cnt);\n+    }\n+\n@@ -568,0 +1617,24 @@\n+    public static MyValue11a test25a(int x) {\n+        return new MyValue11a(x);\n+    }\n+\n+    public static MyValue12 testObjectCallInsideConstructor() {\n+        return new MyValue12();\n+    }\n+\n+    public static MyValue13 testMultipleAbstract() {\n+        return new MyValue13();\n+    }\n+\n+    public static MyValue14 testCallAsConstructorArgument() {\n+        return MyValue14.get(o);\n+    }\n+\n+    public static MyValue15 testBackAndForthAbstract(int x) {\n+        return new MyValue15(x);\n+    }\n+\n+    public static MyValue16 testBackAndForthAbstract2(int x) {\n+        return new MyValue16(x);\n+    }\n+\n@@ -573,0 +1646,2 @@\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1a.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1b.class.getConstructor(int.class), rand.nextBoolean());\n@@ -574,0 +1649,2 @@\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1a.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1b.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n@@ -585,0 +1662,14 @@\n+        int randValue = rand.nextInt(0, 4);\n+        if (randValue > 0) {\n+            \/\/ Some variation\n+            WHITE_BOX.testSetDontInlineMethod(MyValue15.class.getConstructor(), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue15.class.getConstructor(int.class), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue16.class.getConstructor(), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue16.class.getConstructor(int.class), rand.nextBoolean());\n+            if (randValue > 1) {\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract15.class.getConstructor(), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract15.class.getConstructor(int.class), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract16.class.getConstructor(), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract16.class.getConstructor(int.class), rand.nextBoolean());\n+            }\n+        }\n@@ -587,0 +1678,2 @@\n+        Integer deoptNumBig = Integer.getInteger(\"deoptNumBig\");\n+        Integer deoptNumHuge = Integer.getInteger(\"deoptNumHuge\");\n@@ -589,0 +1682,1 @@\n+            System.out.println(\"deoptNum = \" + deoptNum);\n@@ -590,1 +1684,10 @@\n-        for (int x = 0; x <= 50_000; ++x) {\n+        if (deoptNumBig == null) {\n+            deoptNumBig = rand.nextInt(deoptBig.length);\n+            System.out.println(\"deoptNumBig = \" + deoptNumBig);\n+        }\n+        if (deoptNumHuge == null) {\n+            deoptNumHuge = rand.nextInt(deoptHuge.length);\n+            System.out.println(\"deoptNumHuge = \" + deoptNumHuge);\n+        }\n+        run(0, true);\n+        for (int x = 1; x <= 50_000; ++x) {\n@@ -593,0 +1696,1 @@\n+                run(x, true);\n@@ -594,0 +1698,5 @@\n+                deoptBig[deoptNumBig] = true;\n+                deoptHuge[deoptNumHuge] = true;\n+                run(x, true);\n+            } else {\n+                run(x, false);\n@@ -595,25 +1704,69 @@\n-            Asserts.assertEQ(test1(x), x);\n-            Asserts.assertEQ(test2(x), new MyValue1(x));\n-            Asserts.assertEQ(test3(10), new MyValue1(10));\n-            Asserts.assertEQ(test4(x), new MyValue1(x));\n-            Asserts.assertEQ(test5(x), x);\n-            Asserts.assertEQ(test6(x), new MyValue2(x));\n-            Asserts.assertEQ(test7(10), new MyValue2(10));\n-            Asserts.assertEQ(test8(x), new MyValue2(x));\n-            Asserts.assertEQ(test9(x), x);\n-            Asserts.assertEQ(test10(x), new MyValue3(x));\n-            Asserts.assertEQ(test11(10), new MyValue3(10));\n-            Asserts.assertEQ(test12(x), new MyValue3(x));\n-            Asserts.assertEQ(test13(x), new MyValue4(x));\n-            Asserts.assertEQ(test14(x, (x % 2) == 0), new MyValue5(x, (x % 2) == 0));\n-            Asserts.assertEQ(test15(x), new MyValue6(x));\n-            Asserts.assertEQ(test16(x), new MyValue7(x));\n-            Asserts.assertEQ(test17(x), new MyValue8(x));\n-            Asserts.assertEQ(test18(x), new MyValue8(x));\n-            Asserts.assertEQ(test19(x), new MyValue8(x));\n-            Asserts.assertEQ(test20(x), new MyValue9(x));\n-            Asserts.assertEQ(test21(x), new MyValue9(x));\n-            Asserts.assertEQ(test22(x), new MyValue9(x));\n-            Asserts.assertEQ(test23(x), new MyValue9(x));\n-            Asserts.assertEQ(test24(x, x % 10), new MyValue10(x, x % 10));\n-            Asserts.assertEQ(test25(x), new MyValue11(x));\n+        }\n+    }\n+\n+    private static void run(int x, boolean doCheck) {\n+        check(test1(x), x, doCheck);\n+        check(test1a(x), x, doCheck);\n+        check(test1b(x), x, doCheck);\n+        check(test2(x), new MyValue1(x), doCheck);\n+        check(test2a(x), new MyValue1a(x), doCheck);\n+        check(test2b(x), new MyValue1b(x), doCheck);\n+        check(test3(10), new MyValue1(10), doCheck);\n+        check(test3a(10), new MyValue1a(10), doCheck);\n+        check(test3b(10), new MyValue1b(10), doCheck);\n+        check(test4(x), new MyValue1(x), doCheck);\n+        check(test4a(x), new MyValue1a(x), doCheck);\n+        check(test4b(x), new MyValue1b(x), doCheck);\n+        check(test5(x), x, doCheck);\n+        check(test5(x), x, doCheck);\n+        check(test6(x), new MyValue2(x), doCheck);\n+        check(test6(x), new MyValue2(x), doCheck);\n+        check(test7(10), new MyValue2(10), doCheck);\n+        check(test8(x), new MyValue2(x), doCheck);\n+        check(test9(x), x, doCheck);\n+        check(test9a(x), x + x, doCheck);\n+        check(test10(x), new MyValue3(x), doCheck);\n+        check(test10a(x), new MyValue3a(x), doCheck);\n+        check(test11(10), new MyValue3(10), doCheck);\n+        check(test11a(10), new MyValue3a(10), doCheck);\n+        check(test12(x), new MyValue3(x), doCheck);\n+        check(test12a(x), new MyValue3a(x), doCheck);\n+        check(test13(x), new MyValue4(x), doCheck);\n+        check(test13a(x), new MyValue4a(x), doCheck);\n+        check(test14(x, (x % 2) == 0), new MyValue5(x, (x % 2) == 0), doCheck);\n+        check(test14a(x, (x % 2) == 0), new MyValue5a(x, (x % 2) == 0), doCheck);\n+        check(test15(x), new MyValue6(x), doCheck);\n+        check(test15a(x), new MyValue6a(x), doCheck);\n+        check(test15b(x), new MyValue6b(x), doCheck);\n+        check(test16(x), new MyValue7(x), doCheck);\n+        check(test16a(x), new MyValue7a(x), doCheck);\n+        check(test16b(x), new MyValue7b(x), doCheck);\n+        check(test17(x), new MyValue8(x), doCheck);\n+        check(test17a(x), new MyValue8a(x), doCheck);\n+        check(test18(x), new MyValue8(x), doCheck);\n+        check(test18a(x), new MyValue8a(x), doCheck);\n+        check(test19(x), new MyValue8(x), doCheck);\n+        check(test19a(x), new MyValue8a(x), doCheck);\n+        check(test19b(x), new MyValue8a(x), doCheck);\n+        check(test20(x), new MyValue9(x), doCheck);\n+        check(test20a(x), new MyValue9a(x), doCheck);\n+        check(test21(x), new MyValue9(x), doCheck);\n+        check(test21a(x), new MyValue9a(x), doCheck);\n+        check(test22(x), new MyValue9(x), doCheck);\n+        check(test22a(x), new MyValue9a(x), doCheck);\n+        check(test23(x), new MyValue9(x), doCheck);\n+        check(test23a(x), new MyValue9a(x), doCheck);\n+        check(test24(x, x % 10), new MyValue10(x, x % 10), doCheck);\n+        check(test24a(x, x % 10), new MyValue10a(x, x % 10), doCheck);\n+        check(test25(x), new MyValue11(x), doCheck);\n+        check(test25a(x), new MyValue11a(x), doCheck);\n+        testObjectCallInsideConstructor(); \/\/ Creates a new Object each time - cannot compare on equality.\n+        check(testMultipleAbstract(), new MyValue13(), doCheck);\n+        check(testCallAsConstructorArgument(), new MyValue14(o), doCheck);\n+        check(testBackAndForthAbstract(x), new MyValue15(x), doCheck);\n+        check(testBackAndForthAbstract2(x), new MyValue16(x), doCheck);\n+    }\n+\n+    private static void check(Object testResult, Object expectedResult, boolean check) {\n+        if (check) {\n+            Asserts.assertEQ(testResult, expectedResult);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":1207,"deletions":54,"binary":false,"changes":1261,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xint ValueFieldInheritanceTest 0\n+ * @run main\/othervm ValueFieldInheritanceTest 0\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xint ValueFieldInheritanceTest 1\n+ * @run main\/othervm ValueFieldInheritanceTest 1\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xint ValueFieldInheritanceTest 2\n+ * @run main\/othervm ValueFieldInheritanceTest 2\n@@ -61,1 +61,1 @@\n- * @run main\/othervm -Xint ValueFieldInheritanceTest 3\n+ * @run main\/othervm ValueFieldInheritanceTest 3\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueFieldInheritanceTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}