{"files":[{"patch":"@@ -1944,1 +1944,2 @@\n-    Node* arg = argument(i-TypeFunc::Parms);\n+    uint arg_idx = i - TypeFunc::Parms;\n+    Node* arg = argument(arg_idx);\n@@ -1950,2 +1951,13 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n-        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass());\n+        \/\/ There are 2 cases in which the argument has not been scalarized\n+        if (_gvn.type(arg)->is_zero_type()) {\n+          arg = InlineTypeNode::make_null(_gvn, t->inline_klass());\n+        } else {\n+          \/\/ During parsing, a method is called with an abstract (or j.l.Object) receiver, the\n+          \/\/ receiver is a non-scalarized oop. Later on, IGVN reveals that the receiver must be a\n+          \/\/ value object. The method is devirtualized, and replaced with a direct call with a\n+          \/\/ scalarized receiver instead.\n+          assert(arg_idx == 0 && !call->method()->is_static(), \"must be the receiver\");\n+          assert(C->inlining_incrementally() || C->strength_reduction(), \"must be during devirtualization of calls\");\n+          assert(!is_Parse(), \"must be during devirtualization of calls\");\n+          arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass());\n+        }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-java\/util\/NavigableMap\/LockStep.java                               8372824 generic-all\n-java\/util\/Collections\/CheckedSetBash.java                          8372824 generic-all\n","filename":"test\/jdk\/ProblemList-enable-preview.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}