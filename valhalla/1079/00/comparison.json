{"files":[{"patch":"@@ -3449,2 +3449,3 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n-  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr* klass_ptr_type = _gvn.type(superklass)->is_klassptr();\n+  const TypeKlassPtr* improved_klass_ptr_type = klass_ptr_type->try_improve();\n+  const TypeOopPtr* toop = improved_klass_ptr_type->cast_to_exactness(false)->as_instance_type();\n@@ -3460,1 +3461,1 @@\n-  if (tk->singleton()) {\n+  if (improved_klass_ptr_type->singleton()) {\n@@ -3470,1 +3471,1 @@\n-      switch (C->static_subtype_check(tk, kptr)) {\n+      switch (C->static_subtype_check(improved_klass_ptr_type, kptr)) {\n@@ -3564,1 +3565,1 @@\n-  if (tk->klass_is_exact()) {\n+  if (improved_klass_ptr_type->klass_is_exact()) {\n@@ -3574,1 +3575,1 @@\n-      cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk, spec_obj_type, safe_for_replace);\n+      cast_obj = maybe_cast_profiled_receiver(not_null_obj, improved_klass_ptr_type, spec_obj_type, safe_for_replace);\n@@ -3586,2 +3587,8 @@\n-    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);\n-\n+    Node* improved_superklass = superklass;\n+    if (improved_klass_ptr_type != klass_ptr_type && improved_klass_ptr_type->singleton()) {\n+      \/\/ Only improve the super class for constants which allows subsequent sub type checks to possibly be commoned up.\n+      \/\/ The other non-constant cases cannot be improved with a cast node here since they could be folded to top.\n+      \/\/ Additionally, the benefit would only be minor in non-constant cases.\n+      improved_superklass = makecon(improved_klass_ptr_type);\n+    }\n+    Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, improved_superklass);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -995,0 +995,3 @@\n+\n+  \/\/ Verify that:\n+  \/\/      this meet t == t meet this\n@@ -1011,0 +1014,6 @@\n+  \/\/ Verify that:\n+  \/\/      !(t meet this)  meet !t ==\n+  \/\/      (!t join !this) meet !t == !t\n+  \/\/ and\n+  \/\/      !(t meet this)  meet !this ==\n+  \/\/      (!t join !this) meet !this == !this\n@@ -4524,4 +4533,5 @@\n-  bool this_flat_in_array = this_type->flat_in_array();\n-  bool other_flat_in_array = other_type->flat_in_array();\n-  bool this_flat_in_array_orig = this_flat_in_array;\n-  bool other_flat_in_array_orig = other_flat_in_array;\n+  const bool this_flat_in_array = this_type->flat_in_array();\n+  const bool other_flat_in_array = other_type->flat_in_array();\n+  const bool this_not_flat_in_array = this_type->not_flat_in_array();\n+  const bool other_not_flat_in_array = other_type->not_flat_in_array();\n+\n@@ -4575,0 +4585,9 @@\n+  \/\/ Flat in array matrix, yes = y, no = n, maybe = m, top\/empty = T:\n+  \/\/        yes maybe no   -> Super Klass\n+  \/\/   yes   y    y    y\n+  \/\/ maybe   y    m    m\n+  \/\/    no   T    n    n\n+  \/\/    |\n+  \/\/    v\n+  \/\/ Sub Klass\n+\n@@ -4577,1 +4596,1 @@\n-  bool flat_array = false;\n+  bool flat_in_array = false;\n@@ -4581,2 +4600,2 @@\n-    flat_array = below_centerline(ptr) ? (this_flat_in_array && other_flat_in_array) : (this_flat_in_array || other_flat_in_array);\n-  } else if (!other_xk && this_type->is_meet_subtype_of(other_type) && (!other_flat_in_array || this_flat_in_array)) {\n+    flat_in_array = below_centerline(ptr) ? (this_flat_in_array && other_flat_in_array) : (this_flat_in_array || other_flat_in_array);\n+  } else if (!other_xk && is_meet_subtype_of(this_type, other_type)) {\n@@ -4585,2 +4604,3 @@\n-    flat_array = this_flat_in_array;\n-  } else if (!this_xk && other_type->is_meet_subtype_of(this_type) && (!this_flat_in_array || other_flat_in_array)) {\n+    bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n+    flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n+  } else if (!this_xk && is_meet_subtype_of(other_type, this_type)) {\n@@ -4589,1 +4609,2 @@\n-    flat_array = other_flat_in_array;\n+    bool this_flat_other_maybe_flat = this_flat_in_array && (!other_flat_in_array && !other_not_flat_in_array);\n+    flat_in_array = other_flat_in_array || this_flat_other_maybe_flat;\n@@ -4593,1 +4614,2 @@\n-    if (above_centerline(ptr)) { \/\/ both are up?\n+    if (above_centerline(ptr)) {\n+      \/\/ Both types are empty.\n@@ -4596,1 +4618,0 @@\n-      this_flat_in_array = other_flat_in_array = flat_array;\n@@ -4598,1 +4619,2 @@\n-      this_type = other_type; \/\/ tinst is down; keep down man\n+      \/\/ this_type is empty while other_type is not. Take other_type.\n+      this_type = other_type;\n@@ -4600,1 +4622,1 @@\n-      this_flat_in_array = other_flat_in_array;\n+      flat_in_array = other_flat_in_array;\n@@ -4602,0 +4624,1 @@\n+      \/\/ other_type is empty while this_type is not. Take this_type.\n@@ -4603,2 +4626,1 @@\n-      other_xk = this_xk;\n-      other_flat_in_array = this_flat_in_array;\n+      flat_in_array = this_flat_in_array;\n@@ -4606,0 +4628,1 @@\n+      \/\/ this_type and other_type are both non-empty.\n@@ -4607,1 +4630,0 @@\n-      this_flat_in_array = flat_array;\n@@ -4618,1 +4640,1 @@\n-    res_flat_in_array = this_flat_in_array;\n+    res_flat_in_array = subtype ? flat_in_array : this_flat_in_array;\n@@ -4635,1 +4657,1 @@\n-  res_flat_in_array = this_flat_in_array_orig && other_flat_in_array_orig;\n+  res_flat_in_array = this_flat_in_array && other_flat_in_array;\n@@ -4640,0 +4662,4 @@\n+template<class T> bool TypePtr::is_meet_subtype_of(const T* sub_type, const T* super_type) {\n+  return sub_type->is_meet_subtype_of(super_type) && !(super_type->flat_in_array() && sub_type->not_flat_in_array());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":45,"deletions":19,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1026,0 +1026,3 @@\n+ private:\n+  template<class T> static bool is_meet_subtype_of(const T* sub_type, const T* super_type);\n+ protected:\n@@ -1096,1 +1099,1 @@\n-  virtual bool not_flat_in_array()  const { return false; }\n+  virtual bool not_flat_in_array()  const { return true; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-applications\/ctw\/modules\/jdk_jshell.java 8321734 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=serialgc\n+ * @bug 8321734\n+ * @requires vm.gc.Serial\n+ * @summary Test that CmpPNode::sub and SubTypeCheckNode::sub correctly identify unrelated classes based on the flat\n+ *          in array property of the types. Additionally check that the type system properly handles the case of a\n+ *         super class being flat in array while the sub klass could be flat in array.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestFlatInArraysFolding serial\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8321734\n+ * @summary Test that CmpPNode::sub and SubTypeCheckNode::sub correctly identify unrelated classes based on the flat\n+ *          in array property of the types. Additionally check that the type system properly handles the case of a\n+ *         super class being flat in array while the sub klass could be flat in array.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestFlatInArraysFolding\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+public class TestFlatInArraysFolding {\n+    static Object[] oArrArr = new Object[100][100];\n+    static Object[] oArr = new Object[100];\n+    static Object o = new Object();\n+\n+    \/\/ Make sure these are loaded such that A has a flat in array and a not flat in array sub class.\n+    static FlatInArray flat = new FlatInArray(34);\n+    static NotFlatInArray notFlat = new NotFlatInArray(34);\n+\n+    \/\/ Make sure PUnique is the unique concrete sub class loaded from AUnique.\n+    static PUnique pUnique = new PUnique(34);\n+\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        Scenario flatArrayElementMaxSize1Scenario = new Scenario(1, \"-XX:FlatArrayElementMaxSize=1\");\n+        Scenario flatArrayElementMaxSize4Scenario = new Scenario(2, \"-XX:FlatArrayElementMaxSize=4\");\n+        Scenario noFlagsScenario = new Scenario(3);\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(0)\n+                .addFlags(\"--enable-preview\",\n+                          \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                          \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\")\n+                .addScenarios(flatArrayElementMaxSize1Scenario,\n+                              flatArrayElementMaxSize4Scenario, noFlagsScenario);\n+\n+        if (args.length > 0) {\n+            \/\/ Disable Loop Unrolling for IR matching in testCmpP().\n+            \/\/ Use IgnoreUnrecognizedVMOptions since LoopMaxUnroll is a C2 flag.\n+            \/\/ testSubTypeCheck() only triggers with SerialGC.\n+            Scenario serialGCScenario = new Scenario(4, \"-XX:+UseSerialGC\", \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                                     \"-XX:LoopMaxUnroll=0\");\n+            testFramework.addScenarios(serialGCScenario);\n+        }\n+        testFramework.start();\n+    }\n+\n+    \/\/ SubTypeCheck is not folded while CheckCastPPNode is replaced by top which results in a bad graph (data dies while\n+    \/\/ control does not).\n+    @Test\n+    static void testSubTypeCheck() {\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = oArrArr[i];\n+            oArr = (Object[])arrayElement;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\", \/\/ Loop Unswitching done?\n+                  IRNode.STORE_I, \"1\"}, \/\/ CmpP folded in unswitched loop version with flat in array?\n+        applyIf = {\"LoopMaxUnroll\", \"0\"})\n+    static void testCmpP() {\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = oArrArr[i];\n+            if (arrayElement == oArr) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ Type system does not correctly handle the case that a super klass is flat in array while the sub klass is\n+    \/\/ maybe flat in array. This leads to a bad graph.\n+    @Test\n+    static void testUnswitchingAbstractClass() {\n+        Object[] arr = oArr;\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = arr[i];\n+            if (arrayElement instanceof A) {\n+                A a = (A)arrayElement;\n+                if (a == o) {\n+                    a.foo();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testUnswitchingAbstractClass() but with interfaces. This worked before because I has type Object(I)\n+    \/\/ from which Object is a sub type of.\n+    @Test\n+    static void testUnswitchingInterface() {\n+        Object[] arr = oArr;\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = arr[i];\n+            if (arrayElement instanceof I) {\n+                I iVar = (I)arrayElement;\n+                if (iVar == o) {\n+                    iVar.bar();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ PUnique is the unique concrete sub class of AUnique and is not flat in array (with FlatArrayElementMaxSize=4).\n+    \/\/ The CheckCastPP output of the sub type check uses PUnique while the sub type check itself uses AUnique. This leads\n+    \/\/ to a bad graph because the type system determines that the flat in array super klass cannot be met with the\n+    \/\/ not flat in array sub klass. But the sub type check does not fold away because AUnique *could* be flat in array.\n+    \/\/ Fixed with in JDK-8328480 in mainline but not yet merged in. Applied manually to make this work.\n+    @Test\n+    static void testSubTypeCheckNotFoldedParsingAbstractClass() {\n+        Object[] arr = oArr;\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = arr[i];\n+            if (arrayElement instanceof AUnique) {\n+                AUnique aUnique = (AUnique)arrayElement;\n+                if (aUnique == o) {\n+                    aUnique.foo();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testSubTypeCheckNotFoldedParsingAbstractClass() but with interfaces. This worked before because IUnique\n+    \/\/ has type Object(IUnique) from which Object is a sub type of.\n+    @Test\n+    static void testSubTypeCheckNotFoldedParsingInterface() {\n+        Object[] arr = oArr;\n+        for (int i = 0; i < 100; i++) {\n+            Object arrayElement = arr[i];\n+            if (arrayElement instanceof IUnique) {\n+                IUnique iUnique = (IUnique)arrayElement;\n+                if (iUnique == o) {\n+                    iUnique.bar();\n+                }\n+            }\n+        }\n+    }\n+\n+    interface IUnique {\n+        abstract void bar();\n+    }\n+\n+    static abstract value class AUnique implements IUnique {\n+        abstract void foo();\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class PUnique extends AUnique {\n+        int x;\n+        int y;\n+        PUnique(int x) {\n+            this.x = x;\n+            this.y = 34;\n+        }\n+\n+        public void foo() {}\n+        public void bar() {}\n+    }\n+\n+    interface I {\n+        void bar();\n+    }\n+\n+    static abstract value class A implements I {\n+        abstract void foo();\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class FlatInArray extends A implements I {\n+        int x;\n+        FlatInArray(int x) {\n+            this.x = x;\n+        }\n+\n+        public void foo() {}\n+        public void bar() {}\n+    }\n+\n+    \/\/ Not flat in array with -XX:FlatArrayElementMaxSize=4\n+    static value class NotFlatInArray extends A implements I {\n+        int x;\n+        int y;\n+        NotFlatInArray(int x) {\n+            this.x = x;\n+            this.y = 34;\n+        }\n+\n+        public void foo() {}\n+        public void bar() {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}