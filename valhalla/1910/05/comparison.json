{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Source;\n@@ -36,0 +39,1 @@\n+import com.sun.tools.javac.util.List;\n@@ -37,0 +41,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -62,0 +67,4 @@\n+    \/** are null restricted types allowed?\n+      *\/\n+    private final boolean allowNullRestrictedTypes;\n+    private final boolean noUseSiteNullChecks;\n@@ -69,0 +78,5 @@\n+        Preview preview = Preview.instance(context);\n+        Source source = Source.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        noUseSiteNullChecks = Options.instance(context).isSet(\"noUseSiteNullChecks\");\n@@ -72,6 +86,8 @@\n-        try {\n-            this.make = make;\n-            return translate(cdef);\n-        } finally {\n-            \/\/ note that recursive invocations of this method fail hard\n-            this.make = null;\n+        if (allowNullRestrictedTypes) {\n+            try {\n+                this.make = make;\n+                return translate(cdef);\n+            } finally {\n+                \/\/ note that recursive invocations of this method fail hard\n+                this.make = null;\n+            }\n@@ -79,0 +95,1 @@\n+        return cdef;\n@@ -150,0 +167,58 @@\n+\n+    @Override\n+    public void visitApply(JCMethodInvocation tree) {\n+        Symbol.MethodSymbol msym = (Symbol.MethodSymbol) TreeInfo.symbolFor(tree.meth);\n+        if (!noUseSiteNullChecks) {\n+            tree.args = newArgs(msym, tree.args);\n+        }\n+        super.visitApply(tree);\n+        result = tree;\n+        if (!noUseSiteNullChecks) {\n+            if (types.isNonNullable(msym.type.asMethodType().restype)) {\n+                result = attr.makeNullCheck(tree, true);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewClass(JCNewClass tree) {\n+        if (!noUseSiteNullChecks) {\n+            tree.args = newArgs((Symbol.MethodSymbol) tree.constructor, tree.args);\n+        }\n+        super.visitNewClass(tree);\n+        result = tree;\n+    }\n+\n+    private List<JCExpression> newArgs(Symbol.MethodSymbol msym, List<JCExpression> actualArgs) {\n+        \/\/ skip signature polymorphic methods they won't have null restricted arguments\n+        if ((msym.flags_field & Flags.SIGNATURE_POLYMORPHIC) != 0) {\n+            return actualArgs;\n+        }\n+        ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n+        List<Type> declaredArgTypes = msym.type.asMethodType().argtypes;\n+        \/* there can be prefix arguments added by Lower, for example captured variables, etc\n+         * nothing to check for them\n+         *\/\n+        int declaredArgSize = declaredArgTypes.size();\n+        int prefixArgsLength = msym.externalType(types).getParameterTypes().size() - declaredArgSize;\n+        List<JCExpression> actualArgsTmp = actualArgs;\n+        while (prefixArgsLength-- > 0) {\n+            newArgs.add(actualArgsTmp.head);\n+            actualArgsTmp = actualArgsTmp.tail;\n+        }\n+        int noOfArgsToCheck = msym.isVarArgs() ? declaredArgSize - 1 : declaredArgSize;\n+        while (noOfArgsToCheck-- > 0) {\n+            Type formalArgType = declaredArgTypes.head;\n+            if (types.isNonNullable(formalArgType)) {\n+                newArgs.add(attr.makeNullCheck(actualArgsTmp.head, true));\n+            } else {\n+                newArgs.add(actualArgsTmp.head);\n+            }\n+            actualArgsTmp = actualArgsTmp.tail;\n+        }\n+        \/\/ now add the last vararg argument if applicable\n+        if (msym.isVarArgs()) {\n+            newArgs.add(actualArgsTmp.head);\n+        }\n+        return newArgs.toList();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":81,"deletions":6,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -321,1 +321,9 @@\n-            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature())\n+    };\n+\n+    private static String[] PREVIEW_PLUS_NO_USE_SITE_OPTIONS = {\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-XDnoUseSiteNullChecks\"\n+    };\n@@ -324,0 +332,4 @@\n+        testHelper(base, testCode, shouldFail, expectedError, PREVIEW_OPTIONS);\n+    }\n+\n+    private void testHelper(Path base, String testCode, boolean shouldFail, Class<?> expectedError, String[] compilerOptions) throws Exception {\n@@ -334,1 +346,1 @@\n-                .options(PREVIEW_OPTIONS)\n+                .options(compilerOptions)\n@@ -424,0 +436,217 @@\n+    @Test\n+    public void testClientSideChecks(Path base) throws Exception {\n+        String[] negativeCompilationTestCases = new String[] {\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object m(Object! arg) { return null; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object! m(Object arg) { return \"\"; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object m(Object! arg, Object... args) { return null; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg, Object... args) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null, null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object! m(Object arg, Object... args) { return \"\"; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg, Object... args) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null, null);\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String code : negativeCompilationTestCases) {\n+            testHelper(base, code, true, NullPointerException.class);\n+            testHelper(base, code, false, null, PREVIEW_PLUS_NO_USE_SITE_OPTIONS);\n+        }\n+    }\n+\n+    @Test\n+    public void testClientSideChecksSepCompilation(Path base) throws Exception {\n+        testSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object! arg) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object arg) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super sup = new Super(null);\n+                    }\n+                }\n+                \"\"\");\n+        testSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object! arg, Object... args) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object arg, Object... args) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super sup = new Super(null, null);\n+                    }\n+                }\n+                \"\"\");\n+        testSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object! arg) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object arg) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super.Inner inner = new Super().new Inner(null);\n+                    }\n+                }\n+                \"\"\");\n+        testSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object! arg, Object... args) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object arg, Object... args) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super.Inner inner = new Super().new Inner(null, null);\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    private void testSeparateCompilationHelper(\n+            Path base,\n+            String code1,\n+            String code2,\n+            String clientCode) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path ASrc = pkg.resolve(\"A\");\n+        Path client = pkg.resolve(\"Client\");\n+\n+        tb.writeJavaFiles(ASrc, code1);\n+        tb.writeJavaFiles(client, clientCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW_OPTIONS)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's producing the NPE\n+        System.err.println(\"running, this test should fail\");\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDERR);\n+        if (!output.startsWith(\"Exception in thread \\\"main\\\" java.lang.NullPointerException\")) {\n+            throw new AssertionError(\"java.lang.NullPointerException expected\");\n+        }\n+\n+        \/\/ now lets change the code\n+        tb.writeJavaFiles(ASrc, code2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW_PLUS_NO_USE_SITE_OPTIONS)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        System.err.println(\"running, this test should pass\");\n+        new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.SUCCESS);\n+    }\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":231,"deletions":2,"binary":false,"changes":233,"status":"modified"}]}