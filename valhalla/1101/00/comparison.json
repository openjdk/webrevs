{"files":[{"patch":"@@ -1557,10 +1557,1 @@\n-\n-  Register klass = op->tmp()->as_register();\n-  if (UseArrayMarkWordCheck) {\n-    __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n-  } else {\n-    __ load_klass(klass, op->array()->as_register());\n-    __ ldrw(klass, Address(klass, Klass::layout_helper_offset()));\n-    __ tst(klass, Klass::_lh_array_tag_flat_value_bit_inplace);\n-    __ br(Assembler::NE, *op->stub()->entry());\n-  }\n+  __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -1572,6 +1563,1 @@\n-    if (UseArrayMarkWordCheck) {\n-      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n-    } else {\n-      __ tst(klass, Klass::_lh_null_free_array_bit_inplace);\n-      __ br(Assembler::NE, *op->stub()->entry());\n-    }\n+    __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -1585,15 +1571,8 @@\n-  if (UseArrayMarkWordCheck) {\n-    Label test_mark_word;\n-    Register tmp = op->tmp()->as_register();\n-    __ ldr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n-    __ tst(tmp, markWord::unlocked_value);\n-    __ br(Assembler::NE, test_mark_word);\n-    __ load_prototype_header(tmp, op->array()->as_register());\n-    __ bind(test_mark_word);\n-    __ tst(tmp, markWord::null_free_array_bit_in_place);\n-  } else {\n-    Register klass = op->tmp()->as_register();\n-    __ load_klass(klass, op->array()->as_register());\n-    __ ldr(klass, Address(klass, Klass::layout_helper_offset()));\n-    __ tst(klass, Klass::_lh_null_free_array_bit_inplace);\n-  }\n+  Label test_mark_word;\n+  Register tmp = op->tmp()->as_register();\n+  __ ldr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+  __ tst(tmp, markWord::unlocked_value);\n+  __ br(Assembler::NE, test_mark_word);\n+  __ load_prototype_header(tmp, op->array()->as_register());\n+  __ bind(test_mark_word);\n+  __ tst(tmp, markWord::null_free_array_bit_in_place);\n@@ -2374,6 +2353,2 @@\n-  if (UseArrayMarkWordCheck) {\n-    if (is_dest) {\n-      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n-    } else {\n-      __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n-    }\n+  if (is_dest) {\n+    __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n@@ -2381,9 +2356,1 @@\n-    __ load_klass(tmp, obj);\n-    __ ldr(tmp, Address(tmp, Klass::layout_helper_offset()));\n-    if (is_dest) {\n-      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains nulls.\n-      __ tst(tmp, Klass::_lh_null_free_array_bit_inplace);\n-    } else {\n-      __ tst(tmp, Klass::_lh_array_tag_flat_value_bit_inplace);\n-    }\n-    __ br(Assembler::NE, *slow_path->entry());\n+    __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":13,"deletions":46,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1909,10 +1909,0 @@\n-void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n-  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n-  br(Assembler::NE, is_null_free_array);\n-}\n-\n-void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n-  tst(lh, Klass::_lh_null_free_array_bit_inplace);\n-  br(Assembler::EQ, is_non_null_free_array);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -664,2 +664,0 @@\n-  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n-  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2236,2 +2236,1 @@\n-    __ tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n-    __ br(Assembler::NE, L_failed);\n+    __ test_flat_array_oop(src, rscratch2, L_failed);\n@@ -2240,2 +2239,1 @@\n-    __ tst(lh, Klass::_lh_null_free_array_bit_inplace);\n-    __ br(Assembler::NE, L_failed);\n+    __ test_null_free_array_oop(src, rscratch2, L_objArray);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1973,10 +1973,1 @@\n-  Register klass = op->tmp()->as_register();\n-  if (UseArrayMarkWordCheck) {\n-    __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n-  } else {\n-    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n-    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n-    __ testl(klass, Klass::_lh_array_tag_flat_value_bit_inplace);\n-    __ jcc(Assembler::notZero, *op->stub()->entry());\n-  }\n+  __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -1989,6 +1980,1 @@\n-    if (UseArrayMarkWordCheck) {\n-      __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n-    } else {\n-      __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n-      __ jcc(Assembler::notZero, *op->stub()->entry());\n-    }\n+    __ test_null_free_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -2002,16 +1988,8 @@\n-  if (UseArrayMarkWordCheck) {\n-    Label test_mark_word;\n-    Register tmp = op->tmp()->as_register();\n-    __ movptr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n-    __ testl(tmp, markWord::unlocked_value);\n-    __ jccb(Assembler::notZero, test_mark_word);\n-    __ load_prototype_header(tmp, op->array()->as_register(), rscratch1);\n-    __ bind(test_mark_word);\n-    __ testl(tmp, markWord::null_free_array_bit_in_place);\n-  } else {\n-    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    Register klass = op->tmp()->as_register();\n-    __ load_klass(klass, op->array()->as_register(), tmp_load_klass);\n-    __ movl(klass, Address(klass, Klass::layout_helper_offset()));\n-    __ testl(klass, Klass::_lh_null_free_array_bit_inplace);\n-  }\n+  Label test_mark_word;\n+  Register tmp = op->tmp()->as_register();\n+  __ movptr(tmp, Address(op->array()->as_register(), oopDesc::mark_offset_in_bytes()));\n+  __ testl(tmp, markWord::unlocked_value);\n+  __ jccb(Assembler::notZero, test_mark_word);\n+  __ load_prototype_header(tmp, op->array()->as_register(), rscratch1);\n+  __ bind(test_mark_word);\n+  __ testl(tmp, markWord::null_free_array_bit_in_place);\n@@ -3238,6 +3216,2 @@\n-  if (UseArrayMarkWordCheck) {\n-    if (is_dest) {\n-      __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n-    } else {\n-      __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n-    }\n+  if (is_dest) {\n+    __ test_null_free_array_oop(obj, tmp, *slow_path->entry());\n@@ -3245,10 +3219,1 @@\n-    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    __ load_klass(tmp, obj, tmp_load_klass);\n-    __ movl(tmp, Address(tmp, Klass::layout_helper_offset()));\n-    if (is_dest) {\n-      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains nullptrs.\n-      __ testl(tmp, Klass::_lh_null_free_array_bit_inplace);\n-    } else {\n-      __ testl(tmp, Klass::_lh_array_tag_flat_value_bit_inplace);\n-    }\n-    __ jcc(Assembler::notZero, *slow_path->entry());\n+    __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":13,"deletions":48,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2984,3 +2984,1 @@\n-  load_klass(temp_reg, oop, noreg);\n-  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n-  test_null_free_array_layout(temp_reg, is_null_free_array);\n+  Unimplemented();\n@@ -2994,3 +2992,1 @@\n-  load_klass(temp_reg, oop, noreg);\n-  movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));\n-  test_non_null_free_array_layout(temp_reg, is_non_null_free_array);\n+  Unimplemented();\n@@ -3010,11 +3006,0 @@\n-void MacroAssembler::test_null_free_array_layout(Register lh, Label& is_null_free_array) {\n-  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n-  jcc(Assembler::notZero, is_null_free_array);\n-}\n-\n-void MacroAssembler::test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array) {\n-  testl(lh, Klass::_lh_null_free_array_bit_inplace);\n-  jcc(Assembler::zero, is_non_null_free_array);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-  void test_null_free_array_layout(Register lh, Label& is_null_free_array);\n-  void test_non_null_free_array_layout(Register lh, Label& is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2661,0 +2661,6 @@\n+  \/\/ Check for flat inline type array -> return -1\n+  __ test_flat_array_oop(src, rax, L_failed);\n+\n+  \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n+  __ test_null_free_array_oop(src, rax, L_objArray);\n+\n@@ -2668,4 +2674,0 @@\n-  \/\/ Check for null-free (non-flat) inline type array -> handle as object array\n-  __ testl(rax_lh, Klass::_lh_null_free_array_bit_inplace);\n-  __ jcc(Assembler::notZero, L_objArray);\n-\n@@ -2792,1 +2794,1 @@\n-    \/\/ This check also fails for flat\/null-free arrays which are not supported.\n+    \/\/ This check also fails for flat arrays which are not supported.\n@@ -2800,3 +2802,1 @@\n-      __ movl(rklass_tmp, Address(rax, lh_offset));\n-      __ testl(rklass_tmp, Klass::_lh_null_free_array_bit_inplace);\n-      __ jcc(Assembler::zero, L);\n+      __ test_non_null_free_array_oop(dst, rklass_tmp, L);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+\n+  virtual bool is_flat()      { return false; }\n+  virtual bool is_null_free() { return false; }\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+\n+public:\n+  bool is_flat()      { return true; }\n+  bool is_null_free() { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-ciType* ciInstance::java_mirror_type() {\n+ciType* ciInstance::java_mirror_type(bool* is_null_free_array) {\n@@ -56,0 +56,3 @@\n+    if (is_null_free_array != nullptr && (k->is_flatArray_klass() || (k->is_objArray_klass() && ObjArrayKlass::cast(k)->is_null_free_array_klass()))) {\n+      *is_null_free_array = true;\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ciType* java_mirror_type();\n+  ciType* java_mirror_type(bool* is_null_free_array = nullptr);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -793,3 +793,0 @@\n-      } else if (pdata->is_ReceiverTypeData()) {\n-        ciReceiverTypeData* vdata = (ciReceiverTypeData*)pdata;\n-        dump_replay_data_receiver_type_helper<ciReceiverTypeData>(out, round, count, vdata);\n@@ -797,2 +794,2 @@\n-          ciCallTypeData* call_type_data = (ciCallTypeData*)pdata;\n-          dump_replay_data_call_type_helper<ciCallTypeData>(out, round, count, call_type_data);\n+        ciCallTypeData* call_type_data = (ciCallTypeData*)pdata;\n+        dump_replay_data_call_type_helper<ciCallTypeData>(out, round, count, call_type_data);\n@@ -816,1 +813,3 @@\n-\n+      } else if (pdata->is_ReceiverTypeData()) {\n+        ciReceiverTypeData* vdata = (ciReceiverTypeData*)pdata;\n+        dump_replay_data_receiver_type_helper<ciReceiverTypeData>(out, round, count, vdata);\n@@ -974,1 +973,1 @@\n-  print_shared(st, \"ciArrayLoadStoreData\", extra);\n+  print_shared(st, \"ciArrayStoreData\", extra);\n@@ -980,1 +979,1 @@\n-  print_receiver_data_on(st);\n+  rtd_super()->print_receiver_data_on(st);\n@@ -984,1 +983,1 @@\n-  print_shared(st, \"ciArrayLoadStoreData\", extra);\n+  print_shared(st, \"ciArrayLoadData\", extra);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -47,0 +48,5 @@\n+\n+bool ciObjArray::is_null_free() {\n+  VM_ENTRY_MARK;\n+  return get_objArrayOop()->is_null_free_array();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciObjArray.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+\n+  bool is_flat()      { return false; }\n+  bool is_null_free();\n","filename":"src\/hotspot\/share\/ci\/ciObjArray.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,1 +427,0 @@\n-  static const jint _lh_null_free_array_bit_inplace = (jint) (_lh_null_free_mask << _lh_null_free_shift);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -681,0 +681,3 @@\n+  if (is_native()) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3688,1 +3688,2 @@\n-Node* GraphKit::inline_type_test(Node* obj, bool is_inline) {\n+Node* GraphKit::mark_word_test(Node* obj, uintptr_t mask_val, bool eq, bool check_lock) {\n+  \/\/ Load markword\n@@ -3691,2 +3692,35 @@\n-  Node* mask = MakeConX(markWord::inline_type_pattern);\n-  Node* masked = _gvn.transform(new AndXNode(mark, mask));\n+  if (check_lock) {\n+    \/\/ Check if obj is locked\n+    Node* locked_bit = MakeConX(markWord::unlocked_value);\n+    locked_bit = _gvn.transform(new AndXNode(locked_bit, mark));\n+    Node* cmp = _gvn.transform(new CmpXNode(locked_bit, MakeConX(0)));\n+    Node* is_unlocked = _gvn.transform(new BoolNode(cmp, BoolTest::ne));\n+    IfNode* iff = new IfNode(control(), is_unlocked, PROB_MAX, COUNT_UNKNOWN);\n+    _gvn.transform(iff);\n+    Node* locked_region = new RegionNode(3);\n+    Node* mark_phi = new PhiNode(locked_region, TypeX_X);\n+\n+    \/\/ Unlocked: Use bits from mark word\n+    locked_region->init_req(1, _gvn.transform(new IfTrueNode(iff)));\n+    mark_phi->init_req(1, mark);\n+\n+    \/\/ Locked: Load prototype header from klass\n+    set_control(_gvn.transform(new IfFalseNode(iff)));\n+    \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+    Node* klass_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n+    Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, control(), C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+    Node* proto = _gvn.transform(LoadNode::make(_gvn, control(), C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+\n+    locked_region->init_req(2, control());\n+    mark_phi->init_req(2, proto);\n+    set_control(_gvn.transform(locked_region));\n+    record_for_igvn(locked_region);\n+\n+    mark = mark_phi;\n+  }\n+\n+  \/\/ Now check if mark word bits are set\n+  Node* mask = MakeConX(mask_val);\n+  Node* masked = _gvn.transform(new AndXNode(_gvn.transform(mark), mask));\n+  record_for_igvn(masked); \/\/ Give it a chance to be optimized out by IGVN\n@@ -3694,1 +3728,1 @@\n-  return _gvn.transform(new BoolNode(cmp, is_inline ? BoolTest::eq : BoolTest::ne));\n+  return _gvn.transform(new BoolNode(cmp, eq ? BoolTest::eq : BoolTest::ne));\n@@ -3697,7 +3731,2 @@\n-Node* GraphKit::array_lh_test(Node* klass, jint mask, jint val, bool eq) {\n-  Node* lh_adr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n-  \/\/ Make sure to use immutable memory here to enable hoisting the check out of loops\n-  Node* lh_val = _gvn.transform(LoadNode::make(_gvn, nullptr, immutable_memory(), lh_adr, lh_adr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* masked = _gvn.transform(new AndINode(lh_val, intcon(mask)));\n-  Node* cmp = _gvn.transform(new CmpINode(masked, intcon(val)));\n-  return _gvn.transform(new BoolNode(cmp, eq ? BoolTest::eq : BoolTest::ne));\n+Node* GraphKit::inline_type_test(Node* obj, bool is_inline) {\n+  return mark_word_test(obj, markWord::inline_type_pattern, is_inline, \/* check_lock = *\/ false);\n@@ -3706,1 +3735,0 @@\n-\/\/ TODO 8325106 With JEP 401, flatness is not a property of the Class anymore.\n@@ -3711,2 +3739,1 @@\n-  Node* mem = UseArrayMarkWordCheck ? memory(Compile::AliasIdxRaw) : immutable_memory();\n-  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, mem, array_or_klass));\n+  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, memory(Compile::AliasIdxRaw), array_or_klass));\n@@ -3717,2 +3744,2 @@\n-Node* GraphKit::null_free_array_test(Node* klass, bool null_free) {\n-  return array_lh_test(klass, Klass::_lh_null_free_array_bit_inplace, 0, !null_free);\n+Node* GraphKit::null_free_array_test(Node* array, bool null_free) {\n+  return mark_word_test(array, markWord::null_free_array_bit_in_place, null_free);\n@@ -3731,1 +3758,1 @@\n-      BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n+      BuildCutout unless(this, null_free_array_test(ary, \/* null_free = *\/ false), PROB_MAX);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":44,"deletions":17,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -861,0 +861,1 @@\n+  Node* mark_word_test(Node* obj, uintptr_t mask_val, bool eq, bool check_lock = true);\n@@ -862,1 +863,0 @@\n-  Node* array_lh_test(Node* kls, jint mask, jint val, bool eq = true);\n@@ -864,1 +864,1 @@\n-  Node* null_free_array_test(Node* klass, bool null_free = true);\n+  Node* null_free_array_test(Node* array, bool null_free = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -840,1 +840,0 @@\n-    ciType* ft = field_type(i);\n@@ -843,0 +842,1 @@\n+      \/\/ Null-free value class field must have the default value\n@@ -848,1 +848,3 @@\n-      if (value->as_InlineType()->is_default(gvn)) {\n+      \/\/ Nullable value class field must be null\n+      const Type* tinit = gvn->type(value->as_InlineType()->get_is_init());\n+      if (tinit->isa_int() && tinit->is_int()->is_con(0)) {\n@@ -850,6 +852,0 @@\n-      } else {\n-        const Type* tinit = gvn->type(value->as_InlineType()->get_is_init());\n-        if (tinit->isa_int() && tinit->is_int()->is_con(0)) {\n-          continue;\n-        }\n-        return false;\n@@ -857,0 +853,1 @@\n+      return false;\n@@ -884,1 +881,8 @@\n-    assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n+    \/\/ TODO 8325106 Re-enable assert and fix OSR code\n+    \/\/ Issue triggers with TestValueConstruction.java and -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0 -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 -Xbatch -XX:-TieredCompilation\n+    \/\/ assert(!is_larval || oop->as_InlineType()->is_larval(), \"must be larval\");\n+    if (is_larval && !oop->as_InlineType()->is_larval()) {\n+      vt = oop->clone()->as_InlineType();\n+      vt->set_is_larval(true);\n+      return gvn.transform(vt)->as_InlineType();\n+    }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4144,1 +4144,2 @@\n-  ciType* tm = mirror_con->java_mirror_type();\n+  bool is_null_free_array = false;\n+  ciType* tm = mirror_con->java_mirror_type(&is_null_free_array);\n@@ -4151,1 +4152,5 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n+      const TypeKlassPtr* tklass = TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces);\n+      if (is_null_free_array) {\n+        tklass = tklass->is_aryklassptr()->cast_to_null_free();\n+      }\n+      int static_res = C->static_subtype_check(tklass, tp->as_klass_type());\n@@ -4600,0 +4605,5 @@\n+      \/\/ TODO JDK-8329224\n+      if (!orig_t->is_null_free()) {\n+        \/\/ Not statically known to be null free, add a check\n+        generate_fair_guard(null_free_array_test(original), bailout);\n+      }\n@@ -4625,1 +4635,2 @@\n-        generate_fair_guard(null_free_array_test(klass_node), bailout);\n+        generate_fair_guard(flat_array_test(klass_node), bailout);\n+        generate_fair_guard(null_free_array_test(original), bailout);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1083,5 +1083,4 @@\n-\/\/ If UseArrayMarkWordCheck is enabled, we can't use immutable memory for the flat array check\n-\/\/ because we are loading the mark word which is mutable. Although the bits we are interested in\n-\/\/ are immutable (we check for markWord::unlocked_value), we need to use raw memory to not break\n-\/\/ anti dependency analysis. Below code will attempt to still move flat array checks out of loops,\n-\/\/ mainly to enable loop unswitching.\n+\/\/ We can't use immutable memory for the flat array check because we are loading the mark word which is\n+\/\/ mutable. Although the bits we are interested in are immutable (we check for markWord::unlocked_value),\n+\/\/ we need to use raw memory to not break anti dependency analysis. Below code will attempt to still move\n+\/\/ flat array checks out of loops, mainly to enable loop unswitching.\n@@ -1145,1 +1144,1 @@\n-  if (UseArrayMarkWordCheck && n->isa_FlatArrayCheck()) {\n+  if (n->isa_FlatArrayCheck()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2776,1 +2776,1 @@\n-  if (UseArrayMarkWordCheck && array_inputs) {\n+  if (array_inputs) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,3 +135,3 @@\n-  Node* array_lh_test(Node* array, jint mask);\n-  Node* generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region);\n-  Node* generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region);\n+  Node* mark_word_test(Node** ctrl, Node* obj, MergeMemNode* mem, uintptr_t mask_val, RegionNode* region);\n+  Node* generate_flat_array_guard(Node** ctrl, Node* array, MergeMemNode* mem, RegionNode* region);\n+  Node* generate_null_free_array_guard(Node** ctrl, Node* array, MergeMemNode* mem, RegionNode* region);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -291,8 +291,33 @@\n-Node* PhaseMacroExpand::array_lh_test(Node* array, jint mask) {\n-  Node* klass_adr = basic_plus_adr(array, oopDesc::klass_offset_in_bytes());\n-  Node* klass = transform_later(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n-  Node* lh_addr = basic_plus_adr(klass, in_bytes(Klass::layout_helper_offset()));\n-  Node* lh_val = _igvn.transform(LoadNode::make(_igvn, nullptr, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* masked = transform_later(new AndINode(lh_val, intcon(mask)));\n-  Node* cmp = transform_later(new CmpINode(masked, intcon(0)));\n-  return transform_later(new BoolNode(cmp, BoolTest::ne));\n+Node* PhaseMacroExpand::mark_word_test(Node** ctrl, Node* obj, MergeMemNode* mem, uintptr_t mask_val, RegionNode* region) {\n+  \/\/ Load markword and check if obj is locked\n+  Node* mark = make_load(nullptr, mem->memory_at(Compile::AliasIdxRaw), obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n+  Node* locked_bit = MakeConX(markWord::unlocked_value);\n+  locked_bit = transform_later(new AndXNode(locked_bit, mark));\n+  Node* cmp = transform_later(new CmpXNode(locked_bit, MakeConX(0)));\n+  Node* is_unlocked = transform_later(new BoolNode(cmp, BoolTest::ne));\n+  IfNode* iff = transform_later(new IfNode(*ctrl, is_unlocked, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+  Node* locked_region = transform_later(new RegionNode(3));\n+  Node* mark_phi = transform_later(new PhiNode(locked_region, TypeX_X));\n+\n+  \/\/ Unlocked: Use bits from mark word\n+  locked_region->init_req(1, transform_later(new IfTrueNode(iff)));\n+  mark_phi->init_req(1, mark);\n+\n+  \/\/ Locked: Load prototype header from klass\n+  *ctrl = transform_later(new IfFalseNode(iff));\n+  \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+  Node* klass_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n+  Node* klass = transform_later(LoadKlassNode::make(_igvn, *ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+  Node* proto = transform_later(LoadNode::make(_igvn, *ctrl, C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+\n+  locked_region->init_req(2, *ctrl);\n+  mark_phi->init_req(2, proto);\n+  *ctrl = locked_region;\n+\n+  \/\/ Now check if mark word bits are set\n+  Node* mask = MakeConX(mask_val);\n+  Node* masked = transform_later(new AndXNode(mark_phi, mask));\n+  cmp = transform_later(new CmpXNode(masked, mask));\n+  Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n+  return generate_fair_guard(ctrl, bol, region);\n@@ -301,3 +326,2 @@\n-Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n-  assert(UseFlatArray, \"can never be flat\");\n-  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_array_tag_flat_value_bit_inplace), region);\n+Node* PhaseMacroExpand::generate_flat_array_guard(Node** ctrl, Node* array, MergeMemNode* mem, RegionNode* region) {\n+  return mark_word_test(ctrl, array, mem, markWord::flat_array_bit_in_place, region);\n@@ -306,3 +330,2 @@\n-Node* PhaseMacroExpand::generate_null_free_array_guard(Node** ctrl, Node* array, RegionNode* region) {\n-  assert(EnableValhalla, \"can never be null free\");\n-  return generate_fair_guard(ctrl, array_lh_test(array, Klass::_lh_null_free_array_bit_inplace), region);\n+Node* PhaseMacroExpand::generate_null_free_array_guard(Node** ctrl, Node* array, MergeMemNode* mem, RegionNode* region) {\n+  return mark_word_test(ctrl, array, mem, markWord::null_free_array_bit_in_place, region);\n@@ -1534,1 +1557,1 @@\n-        generate_flat_array_guard(&ctrl, src, slow_region);\n+        generate_flat_array_guard(&ctrl, src, merge_mem, slow_region);\n@@ -1539,1 +1562,1 @@\n-        generate_null_free_array_guard(&ctrl, dest, slow_region);\n+        generate_null_free_array_guard(&ctrl, dest, merge_mem, slow_region);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2451,1 +2451,2 @@\n-      ciType* t = tinst->java_mirror_type();\n+      bool is_null_free_array = false;\n+      ciType* t = tinst->java_mirror_type(&is_null_free_array);\n@@ -2461,1 +2462,5 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n+          const TypeKlassPtr* tklass = TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n+          if (is_null_free_array) {\n+            tklass = tklass->is_aryklassptr()->cast_to_null_free();\n+          }\n+          return tklass;\n@@ -2468,1 +2473,5 @@\n-        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n+        const TypeKlassPtr* tklass = TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n+        if (is_null_free_array) {\n+          tklass = tklass->is_aryklassptr()->cast_to_null_free();\n+        }\n+        return tklass;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -830,8 +830,0 @@\n-\n-    \/\/ Check if this is part of an inline type test\n-    if (con == markWord::inline_type_pattern && in(1)->is_Load() &&\n-        phase->type(in(1)->in(MemNode::Address))->is_inlinetypeptr() &&\n-        phase->type(in(1)->in(MemNode::Address))->is_ptr()->offset() == oopDesc::mark_offset_in_bytes()) {\n-      assert(EnableValhalla, \"should only be used for inline types\");\n-      return in(2); \/\/ Obj is known to be an inline type\n-    }\n@@ -893,0 +885,41 @@\n+  \/\/ Search for GraphKit::mark_word_test patterns and fold the test if the result is statically known\n+  Node* load1 = in(1);\n+  Node* load2 = nullptr;\n+  if (load1->is_Phi() && phase->type(load1)->isa_long()) {\n+    load1 = in(1)->in(1);\n+    load2 = in(1)->in(2);\n+  }\n+  if (load1 != nullptr && load1->is_Load() && phase->type(load1)->isa_long() &&\n+      (load2 == nullptr || (load2->is_Load() && phase->type(load2)->isa_long()))) {\n+    const TypePtr* adr_t1 = phase->type(load1->in(MemNode::Address))->isa_ptr();\n+    const TypePtr* adr_t2 = (load2 != nullptr) ? phase->type(load2->in(MemNode::Address))->isa_ptr() : nullptr;\n+    if (adr_t1 != nullptr && adr_t1->offset() == oopDesc::mark_offset_in_bytes() &&\n+        (load2 == nullptr || (adr_t2 != nullptr && adr_t2->offset() == in_bytes(Klass::prototype_header_offset())))) {\n+      if (mask == markWord::inline_type_pattern) {\n+        if (adr_t1->is_inlinetypeptr()) {\n+          set_req_X(1, in(2), phase);\n+          return this;\n+        } else if (!adr_t1->can_be_inline_type()) {\n+          set_req_X(1, phase->longcon(0), phase);\n+          return this;\n+        }\n+      } else if (mask == markWord::null_free_array_bit_in_place) {\n+        if (adr_t1->is_null_free()) {\n+          set_req_X(1, in(2), phase);\n+          return this;\n+        } else if (adr_t1->is_not_null_free()) {\n+          set_req_X(1, phase->longcon(0), phase);\n+          return this;\n+        }\n+      } else if (mask == markWord::flat_array_bit_in_place) {\n+        if (adr_t1->is_flat()) {\n+          set_req_X(1, in(2), phase);\n+          return this;\n+        } else if (adr_t1->is_not_flat()) {\n+          set_req_X(1, phase->longcon(0), phase);\n+          return this;\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+      \/\/ TODO 8325106 Dead code?\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&\n+    assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->is_not_null_free() &&\n@@ -317,1 +317,1 @@\n-      assert(elemtype->is_oopptr()->can_be_inline_type() && !ary_t->klass_is_exact(), \"array can't be null-free\");\n+      assert(elemtype->is_oopptr()->can_be_inline_type(), \"array can't be null-free\");\n@@ -500,1 +500,1 @@\n-        BuildCutout unless(this, null_free_array_test(load_object_klass(ary), \/* null_free = *\/ false), PROB_MAX);\n+        BuildCutout unless(this, null_free_array_test(ary, \/* null_free = *\/ false), PROB_MAX);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-  n->dump_bfs(1, 0, \"\");\n+  n->dump_bfs(3, 0, \"\");\n@@ -1513,0 +1513,11 @@\n+  \/\/ AndLNode::Ideal folds GraphKit::mark_word_test patterns. Give it a chance to run.\n+  \/\/ TODO 8325106 Improve this to handle all patterns\n+  if (n->is_Load() && use->is_Phi()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* u = use->fast_out(i);\n+      if (u->Opcode() == Op_AndL) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n+\n@@ -1806,1 +1817,1 @@\n-    n->dump(1);\n+    n->dump(3);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1146,0 +1146,1 @@\n+  \/\/ TODO 8325106 Handle null free arrays here?\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3931,0 +3931,5 @@\n+    bool is_flat = o->as_obj_array()->is_flat();\n+    bool is_null_free = o->as_obj_array()->is_null_free();\n+    if (is_null_free) {\n+      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n@@ -3932,1 +3937,1 @@\n-                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ !is_flat, \/* not_null_free= *\/ !is_null_free);\n@@ -4667,1 +4672,1 @@\n-ciType* TypeInstPtr::java_mirror_type() const {\n+ciType* TypeInstPtr::java_mirror_type(bool* is_null_free_array) const {\n@@ -4673,1 +4678,1 @@\n-  return const_oop()->as_instance()->java_mirror_type();\n+  return const_oop()->as_instance()->java_mirror_type(is_null_free_array);\n@@ -6677,0 +6682,1 @@\n+      \/\/ TODO 8325106 Still correct?\n@@ -7101,1 +7107,1 @@\n-  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = !method->is_native() && sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1400,1 +1400,1 @@\n-  ciType* java_mirror_type() const;\n+  ciType* java_mirror_type(bool* is_null_free_array = nullptr) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2014,3 +2014,0 @@\n-  product(bool, UseArrayMarkWordCheck, NOT_LP64(false) LP64_ONLY(true),     \\\n-          \"Use bits in the mark word to check for flat\/null-free arrays\")   \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-    @IR(counts = {IRNode.STORE_P, \"1\"})\n+    \/\/ TODO JDK-8331551\n+    \/\/ @IR(counts = {IRNode.STORE_P, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCUnrolling.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1418,2 +1418,1 @@\n-    \/\/ Ignore: JDK-8329224\n-    \/\/ @Test\n+    @Test\n@@ -1424,1 +1423,1 @@\n-    \/\/ @Run(test = \"test59\")\n+    @Run(test = \"test59\")\n@@ -1440,2 +1439,1 @@\n-    \/\/ Ignore: JDK-8329224\n-    \/\/ @Test\n+    @Test\n@@ -1446,1 +1444,1 @@\n-    \/\/ @Run(test = \"test60\")\n+    @Run(test = \"test60\")\n@@ -1527,2 +1525,1 @@\n-    \/\/ Ignore: JDK-8329224\n-    \/\/ @Test\n+    @Test\n@@ -1538,1 +1535,1 @@\n-    \/\/ @Run(test = \"test63\")\n+    @Run(test = \"test63\")\n@@ -1550,2 +1547,2 @@\n-        \/\/ Result is not a null-restricted array\n-        Asserts.assertEQ(result[len], null);\n+        \/\/ Result is a null-restricted array\n+        Asserts.assertEQ(result[len], MyValue1.createDefaultInline());\n@@ -2843,2 +2840,3 @@\n-    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"},\n-        failOn = INTRINSIC_SLOW_PATH)\n+    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    \/\/ TODO JDK-8329224\n+    \/\/ failOn = INTRINSIC_SLOW_PATH)\n@@ -2873,2 +2871,3 @@\n-    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"},\n-        failOn = INTRINSIC_SLOW_PATH)\n+    @IR(counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+    \/\/ TODO JDK-8329224\n+    \/\/ failOn = INTRINSIC_SLOW_PATH)\n@@ -2987,8 +2986,3 @@\n-        verify(val_src, res);\n-        try {\n-            test125(obj_null_src, val_src.getClass());\n-\/\/ TODO 8325106 Remove\n-\/\/            throw new RuntimeException(\"NullPointerException expected\");\n-        } catch (NullPointerException e) {\n-            \/\/ expected\n-        }\n+        verify(obj_src, res);\n+        res = test125(obj_null_src, val_src.getClass());\n+        verify(obj_null_src, res);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -48,0 +49,1 @@\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -51,1 +53,2 @@\n- * @run main\/othervm\/timeout=450 compiler.valhalla.inlinetypes.TestCallingConvention\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=450 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention\n@@ -57,0 +60,2 @@\n+    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n@@ -1332,0 +1337,13 @@\n+\n+    static long expectedFlatArrayElementMaxSize = WHITE_BOX.getIntxVMFlag(\"FlatArrayElementMaxSize\");\n+\n+    \/\/ Test value class return from native method\n+    @Test\n+    public long test57() {\n+        return WHITE_BOX.getIntxVMFlag(\"FlatArrayElementMaxSize\");\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier(RunInfo info) throws Throwable {\n+        Asserts.assertEQ(test57(), expectedFlatArrayElementMaxSize);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}