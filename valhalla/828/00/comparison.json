{"files":[{"patch":"@@ -915,1 +915,1 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n+  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);\n@@ -917,1 +917,1 @@\n-    res->set_req(i, in(i));\n+    vt->set_req(i, in(i));\n@@ -920,0 +920,1 @@\n+  Node* alloc_oop = NULL;\n@@ -925,1 +926,1 @@\n-    Node* alloc_oop  = kit->new_instance(klass_node, NULL, NULL, true);\n+    alloc_oop = kit->new_instance(klass_node, NULL, NULL, true);\n@@ -930,1 +931,1 @@\n-    res->set_oop(alloc_oop);\n+    vt->set_oop(alloc_oop);\n@@ -933,2 +934,12 @@\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n+  \/\/vt->set_type(TypeInlineType::make(vk, true));\n+  InlineTypeNode* res = kit->gvn().transform(vt)->as_InlineType();\n+  \/\/ Set larval state to the current oop if it is not the allocated\n+  \/\/ private buffer. This is a temporary fix for the larval state\n+  \/\/ assertion failure in \"Unsafe_FinishPrivateBuffer()\".\n+  Node* oop = res->get_oop();\n+  if (allocate && oop != alloc_oop) {\n+    Node* mark_addr = kit->basic_plus_adr(oop, oopDesc::mark_offset_in_bytes());\n+    Node* mark = kit->make_load(NULL, mark_addr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+    mark = kit->gvn().transform(new OrXNode(mark, kit->MakeConX(markWord::larval_bit_in_place)));\n+    kit->store_to_memory(kit->control(), mark_addr, mark, TypeX_X->basic_type(), kit->gvn().type(mark_addr)->is_ptr(), MemNode::unordered);\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8303416\n+ * @summary Fix JVM crash at Unsafe_FinishPrivateBuffer\n+ * @library \/test\/lib\n+ * @compile -XDenablePrimitiveClasses\n+ *          --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *          TestLarvalState.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ *                   --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   compiler.valhalla.inlinetypes.TestLarvalState\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.*;\n+import java.util.Random;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestLarvalState {\n+    private static int LENGTH = 10000;\n+\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    static byte[] arr = new byte[LENGTH];\n+\n+    static {\n+        for (int i = 0; i < LENGTH; i++) {\n+            arr[i] = (byte) RD.nextInt(127);\n+        }\n+    }\n+\n+    public static byte test(byte b) {\n+        Value obj = new Value();\n+        obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+        Unsafe.getUnsafe().putByte(obj, obj.offset, b);\n+        obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+        return Unsafe.getUnsafe().getByte(obj, obj.offset);\n+    }\n+\n+    public static void main(String[] args) {\n+        byte actual = 0;\n+        for (int i = 0; i < LENGTH; i++) {\n+            actual += test(arr[i]);\n+        }\n+\n+        byte expected = 0;\n+        for (int i = 0; i < LENGTH; i++) {\n+            expected += arr[i];\n+        }\n+        Asserts.assertEquals(expected, actual);\n+    }\n+\n+    primitive static class Value {\n+        byte field = 0;\n+\n+        static long offset = fieldOffset();\n+\n+        private static long fieldOffset() {\n+            try {\n+                var f = Value.class.getDeclaredField(\"field\");\n+                return Unsafe.getUnsafe().objectFieldOffset(f);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1L;\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLarvalState.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}