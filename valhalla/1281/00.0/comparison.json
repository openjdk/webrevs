{"files":[{"patch":"@@ -281,0 +281,12 @@\n+$(eval $(call SetupTarget, hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := build, \\\n+    DEPS := hotspot compile-commands-hotspot jdk-image, \\\n+))\n+\n+$(eval $(call SetupTarget, open-hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := open, \\\n+    DEPS := hotspot-xcode-project, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    CREATE_API_DIGEST := true, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview varargs dangling-doc-comments, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview restricted varargs dangling-doc-comments, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2362,1 +2362,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,0 +839,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -373,0 +373,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,1 +267,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -269,5 +270,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -277,1 +291,2 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n+                             static_cast<int>(name_len), false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  do_klass(IllegalCallerException_klass,                java_lang_IllegalCallerException                      ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -606,0 +606,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,0 +207,1 @@\n+  template(java_lang_IllegalCallerException,          \"java\/lang\/IllegalCallerException\")         \\\n@@ -413,0 +414,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n@@ -597,1 +600,1 @@\n-  template(classloader_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/String;)J\")             \\\n+  template(classloader_class_string_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/Class;Ljava\/lang\/String;Ljava\/lang\/String;)J\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -713,2 +713,4 @@\n-    if (!THREAD->has_last_Java_frame()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    \/\/ Ensure that current JNI handle scope is not the top-most JNIHandleBlock as handles\n+    \/\/ in that scope are only released when the thread exits.\n+    if (!THREAD->has_last_Java_frame() && THREAD->active_handles()->pop_frame_link() == nullptr) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor or a pushed JNI handle block\"));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -247,0 +248,1 @@\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -251,0 +253,1 @@\n+  nonstatic_field(ContinuationEntry,           _pin_count,                                    uint32_t)                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -440,3 +440,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -445,1 +442,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -506,1 +506,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -590,3 +593,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out, UseObjectMonitorTable == false)\n+\/\/    [header          | 10]  monitor            inflated lock (UseObjectMonitorTable == true)\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -739,0 +739,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -490,0 +490,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);\n+\n@@ -3436,0 +3439,1 @@\n+ * bool pinVirtualThread;\n@@ -3440,0 +3444,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3451,0 +3456,1 @@\n+ *   pinVirtualThread = false;\n@@ -3456,1 +3462,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3458,0 +3464,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3528,0 +3535,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3618,0 +3629,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3630,0 +3643,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3653,0 +3668,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3673,0 +3691,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n@@ -3921,0 +3942,87 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":109,"deletions":1,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  bool inline_native_Continuation_pinning(bool unpin);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1083,1 +1083,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || get_loop(lca)->_head->as_Loop()->is_in_infinite_subgraph(), \"must not be moved into inner loop\");\n@@ -1340,3 +1340,1 @@\n-    if (loop->is_member(get_loop(dom)) ||\n-        \/\/ NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -435,3 +436,9 @@\n-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n-  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+\/\/ Returns 'DomResult::Dominate' if all control inputs of 'dom'\n+\/\/ dominate 'sub', 'DomResult::NotDominate' if not,\n+\/\/ and 'DomResult::EncounteredDeadCode' if we can't decide due to\n+\/\/ dead code, but at the end of IGVN, we know the definite result\n+\/\/ once the dead code is cleaned up.\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -441,2 +448,3 @@\n-  if (dom == nullptr || dom->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (dom == nullptr || dom->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -447,1 +455,1 @@\n-    return false;\n+    return DomResult::NotDominate;\n@@ -450,2 +458,3 @@\n-  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub)\n-    return true;\n+  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub) {\n+    return DomResult::Dominate;\n+  }\n@@ -465,2 +474,3 @@\n-  if (sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -470,2 +480,3 @@\n-  if (sub == dom)\n-    return true;\n+  if (sub == dom) {\n+    return DomResult::Dominate;\n+  }\n@@ -473,2 +484,3 @@\n-  if (sub->is_Start() || sub->is_Root())\n-    return false;\n+  if (sub->is_Start() || sub->is_Root()) {\n+    return DomResult::NotDominate;\n+  }\n@@ -488,2 +500,3 @@\n-      if (n == orig_sub)\n-        return false; \/\/ One of dom's inputs dominated by sub.\n+      if (n == orig_sub) {\n+        return DomResult::NotDominate; \/\/ One of dom's inputs dominated by sub.\n+      }\n@@ -493,2 +506,3 @@\n-        if (n == nullptr || n->is_top())\n-          return false; \/\/ Conservative answer for dead code\n+        if (n == nullptr || n->is_top()) {\n+          return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+        }\n@@ -500,1 +514,2 @@\n-        if (n->dominates(sub, nlist))\n+        DomResult dom_result = n->dominates(sub, nlist);\n+        if (dom_result == DomResult::Dominate) {\n@@ -502,2 +517,3 @@\n-        else\n-          return false;\n+        } else {\n+          return dom_result;\n+        }\n@@ -508,2 +524,3 @@\n-          if (m->is_top())\n-            return false; \/\/ Conservative answer for dead code\n+          if (m->is_top()) {\n+            return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+          }\n@@ -516,1 +533,1 @@\n-          if (m == nullptr || m->is_top())\n+          if (m == nullptr || m->is_top()) {\n@@ -518,0 +535,1 @@\n+          }\n@@ -522,1 +540,1 @@\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n@@ -734,1 +752,1 @@\n-      if (st_alloc == nullptr)\n+      if (st_alloc == nullptr) {\n@@ -736,0 +754,1 @@\n+      }\n@@ -738,1 +757,1 @@\n-      if (alloc == st_alloc)\n+      if (alloc == st_alloc) {\n@@ -740,1 +759,1 @@\n-      else if (alloc != nullptr)\n+      } else if (alloc != nullptr) {\n@@ -742,1 +761,1 @@\n-      else if (all_controls_dominate(this, st_alloc))\n+      } else if (all_controls_dominate(this, st_alloc)) {\n@@ -744,0 +763,1 @@\n+      }\n@@ -1596,1 +1616,1 @@\n-    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n@@ -1598,0 +1618,1 @@\n+    }\n@@ -1688,0 +1709,1 @@\n+  DomResult dom_result = DomResult::Dominate;\n@@ -1692,2 +1714,2 @@\n-    if (!MemNode::all_controls_dominate(address, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n@@ -1698,2 +1720,2 @@\n-    if (!MemNode::all_controls_dominate(mem, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n@@ -1702,1 +1724,2 @@\n-    if (MemNode::all_controls_dominate(mem, base->in(0))) {\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n@@ -1704,3 +1727,5 @@\n-    } else if (MemNode::all_controls_dominate(address, mem->in(0))) {\n-      region = mem->in(0);\n-      return nullptr; \/\/ complex graph\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n@@ -1714,0 +1739,11 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+\n@@ -1716,1 +1752,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -4651,1 +4686,1 @@\n-      if (!MemNode::all_controls_dominate(n, this))\n+      if (!MemNode::all_controls_dominate(n, this)) {\n@@ -4653,0 +4688,1 @@\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":76,"deletions":40,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -108,2 +109,6 @@\n-  \/\/ This one should probably be a phase-specific function:\n-  static bool all_controls_dominate(Node* dom, Node* sub);\n+  \/\/ The following two should probably be phase-specific functions:\n+  static DomResult maybe_all_controls_dominate(Node* dom, Node* sub);\n+  static bool all_controls_dominate(Node* dom, Node* sub) {\n+    DomResult dom_result = maybe_all_controls_dominate(dom, sub);\n+    return dom_result == DomResult::Dominate;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1259,1 +1260,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+Node::DomResult Node::dominates(Node* sub, Node_List &nlist) {\n@@ -1279,1 +1280,4 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ Conservative answer for dead code.\n+      return DomResult::EncounteredDeadCode;\n+    }\n@@ -1284,1 +1288,1 @@\n-        return true;\n+        return DomResult::Dominate;\n@@ -1298,1 +1302,1 @@\n-      return met_dom;\n+      return met_dom ? DomResult::Dominate : DomResult::NotDominate;\n@@ -1329,1 +1333,1 @@\n-            return false;\n+            return DomResult::NotDominate;\n@@ -1372,2 +1376,1 @@\n-  \/\/ Conservative answer for dead code.\n-  return false;\n+  return DomResult::NotDominate;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1124,0 +1125,6 @@\n+  \/\/ Results of the dominance analysis.\n+  enum class DomResult {\n+    NotDominate,         \/\/ 'this' node does not dominate 'sub'.\n+    Dominate,            \/\/ 'this' node dominates or is equal to 'sub'.\n+    EncounteredDeadCode  \/\/ Result is undefined due to encountering dead code.\n+  };\n@@ -1125,1 +1132,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  DomResult dominates(Node* sub, Node_List &nlist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1725,18 +1725,1 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1929,0 +1912,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1932,0 +1940,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2673,1 +2673,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,0 +309,2 @@\n+#define ILLEGAL_NATIVE_ACCESS \"illegal.native.access\"\n+#define ILLEGAL_NATIVE_ACCESS_LEN 21\n@@ -330,0 +332,1 @@\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n@@ -507,0 +510,3 @@\n+#ifdef LINUX\n+  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#endif\n@@ -2315,0 +2321,4 @@\n+    } else if (match_option(option, \"--illegal-native-access=\", &tail)) {\n+      if (!create_module_property(\"jdk.module.illegal.native.access\", tail, InternalProperty)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -576,1 +576,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1910,1 +1910,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -359,1 +360,1 @@\n-    private static URL codeSource(Class<?> clazz) {\n+    static URL codeSource(Class<?> clazz) {\n@@ -2021,0 +2022,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2027,0 +2030,1 @@\n+    @Restricted\n@@ -2028,1 +2032,3 @@\n-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"load\", false);\n+        Runtime.getRuntime().load0(caller, filename);\n@@ -2059,0 +2065,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2065,0 +2073,1 @@\n+    @Restricted\n@@ -2066,1 +2075,3 @@\n-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"loadLibrary\", false);\n+        Runtime.getRuntime().loadLibrary0(caller, libname);\n@@ -2543,2 +2554,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n-                m.ensureNativeAccess(owner, methodName, currentClass);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n+                m.ensureNativeAccess(owner, methodName, currentClass, jni);\n@@ -2649,1 +2660,1 @@\n-                return ClassLoader.findNative(loader, entry);\n+                return ClassLoader.findNativeInternal(loader, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.util.stream.Stream;\n+\n@@ -52,0 +52,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -84,0 +85,2 @@\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -85,1 +88,11 @@\n-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n@@ -90,7 +103,3 @@\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n-    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(II)I\");\n-\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);\n@@ -183,1 +192,1 @@\n-\n+        target = target.asType(invocationType);\n@@ -275,2 +284,1 @@\n-        requireNonNull(labels);\n-        labels = labels.clone();\n+        labels = labels.clone(); \/\/ implicit null check\n@@ -304,1 +312,0 @@\n-\n@@ -437,0 +444,27 @@\n+    \/**\n+     * Check if the labelConstants can be converted statically to bytecode, or\n+     * whether we'll need to compute and pass in extra information at the call site.\n+     *\/\n+    private static boolean needsExtraInfo(Class<?> selectorType, Object[] labelConstants) {\n+        for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+            Object currentLabel = labelConstants[idx];\n+            if (currentLabel instanceof Class<?> classLabel) {\n+                \/\/ No extra info needed for exact matches or primitives\n+                if (unconditionalExactnessCheck(selectorType, classLabel) || classLabel.isPrimitive()) {\n+                    continue;\n+                }\n+                \/\/ Hidden classes - or arrays thereof - can't be nominally\n+                \/\/ represented. Passed in as arguments.\n+                while (classLabel.isArray()) {\n+                    classLabel = classLabel.getComponentType();\n+                }\n+                if (classLabel.isHidden()) {\n+                    return true;\n+                }\n+            } else if (currentLabel instanceof EnumDesc<?>) {\n+                \/\/ EnumDescs labels needs late binding\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n@@ -470,3 +504,4 @@\n-            record Element(Label target, Label next, Object caseLabel) { }\n-            List<Element> cases = new ArrayList<>();\n-            List<SwitchCase> switchCases = new ArrayList<>();\n+            Label[] caseTargets = new Label[labelConstants.length];\n+            Label[] caseNext = new Label[labelConstants.length];\n+            Object[] caseLabels = new Object[labelConstants.length];\n+            SwitchCase[] switchCases = new SwitchCase[labelConstants.length];\n@@ -481,1 +516,1 @@\n-                    next = cases.getLast().next();\n+                    next = caseNext[idx + 1];\n@@ -483,1 +518,1 @@\n-                    next = cases.getLast().target();\n+                    next = caseTargets[idx + 1];\n@@ -486,2 +521,4 @@\n-                cases.add(new Element(target, next, currentLabel));\n-                switchCases.add(SwitchCase.of(idx, target));\n+                caseTargets[idx] = target;\n+                caseNext[idx] = next;\n+                caseLabels[idx] = currentLabel;\n+                switchCases[idx] = SwitchCase.of(idx, target);\n@@ -489,8 +526,6 @@\n-            cases = cases.reversed();\n-            switchCases = switchCases.reversed();\n-            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n-            for (int idx = 0; idx < cases.size(); idx++) {\n-                Element element = cases.get(idx);\n-                Label next = element.next();\n-                cb.labelBinding(element.target());\n-                if (element.caseLabel() instanceof Class<?> classLabel) {\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, Arrays.asList(switchCases));\n+            for (int idx = 0; idx < labelConstants.length; idx++) {\n+                Label next = caseNext[idx];\n+                Object caseLabel = caseLabels[idx];\n+                cb.labelBinding(caseTargets[idx]);\n+                if (caseLabel instanceof Class<?> classLabel) {\n@@ -580,1 +615,1 @@\n-                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                } else if (caseLabel instanceof EnumDesc<?> enumLabel) {\n@@ -590,1 +625,1 @@\n-                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n+                    cb.invokeinterface(CD_BiPredicate,\n@@ -596,1 +631,1 @@\n-                } else if (element.caseLabel() instanceof String stringLabel) {\n+                } else if (caseLabel instanceof String stringLabel) {\n@@ -604,1 +639,1 @@\n-                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                } else if (caseLabel instanceof Integer integerLabel) {\n@@ -629,5 +664,5 @@\n-                } else if ((element.caseLabel() instanceof Long ||\n-                        element.caseLabel() instanceof Float ||\n-                        element.caseLabel() instanceof Double ||\n-                        element.caseLabel() instanceof Boolean)) {\n-                    if (element.caseLabel() instanceof Boolean c) {\n+                } else if ((caseLabel instanceof Long ||\n+                        caseLabel instanceof Float ||\n+                        caseLabel instanceof Double ||\n+                        caseLabel instanceof Boolean)) {\n+                    if (caseLabel instanceof Boolean c) {\n@@ -636,1 +671,1 @@\n-                        cb.loadConstant((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) caseLabel);\n@@ -638,1 +673,1 @@\n-                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    var caseLabelWrapper = Wrapper.forWrapperType(caseLabel.getClass());\n@@ -651,1 +686,1 @@\n-                            element.caseLabel().getClass());\n+                            caseLabel.getClass());\n@@ -657,1 +692,1 @@\n-            cb.loadConstant(cases.size());\n+            cb.loadConstant(labelConstants.length);\n@@ -666,2 +701,3 @@\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n+        boolean addExtraInfo = needsExtraInfo(selectorType, labelConstants);\n+        List<EnumDesc<?>> enumDescs = addExtraInfo ? new ArrayList<>() : null;\n+        List<Class<?>> extraClassLabels = addExtraInfo ? new ArrayList<>() : null;\n@@ -673,1 +709,1 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       addExtraInfo ? MTD_TYPE_SWITCH_EXTRA : MTD_TYPE_SWITCH,\n@@ -684,7 +720,5 @@\n-                                                        TYPES_SWITCH_TYPE);\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n-                                                       List.copyOf(extraClassLabels));\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n+                                                        addExtraInfo ? MT_TYPE_SWITCH_EXTRA : MT_TYPE_SWITCH);\n+            if (addExtraInfo) {\n+                typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n+                        List.copyOf(extraClassLabels));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":85,"deletions":51,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1970,0 +1970,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1973,1 +1981,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1927,1 +1927,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1402,1 +1402,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2218,1 +2218,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2220,1 +2222,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2222,1 +2225,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -285,4 +285,8 @@\n-     * Ensure that the given module has native access. If not, warn or\n-     * throw exception depending on the configuration.\n-     *\/\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n+     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * @param m the module in which native access occurred\n+     * @param owner the owner of the restricted method being called (or the JNI method being bound)\n+     * @param methodName the name of the restricted method being called (or the JNI method being bound)\n+     * @param currentClass the class calling the restricted method (for JNI, this is the same as {@code owner})\n+     * @param jni {@code true}, if this event is related to a JNI method being bound\n+     *\/\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n+                filled.add(Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2365,1 +2365,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2420,4 +2420,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5113,0 +5113,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -5079,0 +5080,1 @@\n+            boolean unclosedParameterList;\n@@ -5081,0 +5083,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5086,0 +5089,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5099,0 +5104,1 @@\n+                    accept(SEMI);\n@@ -5101,0 +5107,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5102,1 +5109,0 @@\n-                accept(SEMI);\n@@ -5105,2 +5111,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5123,0 +5132,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}