{"files":[{"patch":"@@ -255,0 +255,2 @@\n+    \/** The symbol representing the finalize method on Object *\/\n+    public final MethodSymbol objectFinalize;\n@@ -553,0 +555,6 @@\n+        throwableType = enterClass(\"java.lang.Throwable\");\n+        objectFinalize = new MethodSymbol(PROTECTED,\n+                names.finalize,\n+                new MethodType(List.nil(), voidType,\n+                        List.of(throwableType), methodClass),\n+                objectType.tsym);\n@@ -561,1 +569,0 @@\n-        throwableType = enterClass(\"java.lang.Throwable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5691,1 +5691,1 @@\n-            chk.checkSerialStructure(tree, c);\n+            chk.checkSerialStructure(env, tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -82,1 +81,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -85,2 +83,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -187,0 +183,2 @@\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -230,0 +228,4 @@\n+    \/** Are value classes allowed\n+     *\/\n+    private final boolean allowValueClasses;\n+\n@@ -2238,0 +2240,5 @@\n+        if (allowValueClasses && origin.isValueClass() && names.finalize.equals(m.name)) {\n+            if (m.overrides(syms.objectFinalize, origin, types, false)) {\n+                log.warning(tree.pos(), Warnings.ValueFinalize);\n+            }\n+        }\n@@ -5019,2 +5026,2 @@\n-    public void checkSerialStructure(JCClassDecl tree, ClassSymbol c) {\n-        (new SerialTypeVisitor()).visit(c, tree);\n+    public void checkSerialStructure(Env<AttrContext> env, JCClassDecl tree, ClassSymbol c) {\n+        (new SerialTypeVisitor(env)).visit(c, tree);\n@@ -5051,1 +5058,2 @@\n-        SerialTypeVisitor() {\n+        Env<AttrContext> env;\n+        SerialTypeVisitor(Env<AttrContext> env) {\n@@ -5053,0 +5061,1 @@\n+            this.env = env;\n@@ -5112,0 +5121,1 @@\n+            final boolean[] hasWriteReplace = {false};\n@@ -5186,1 +5196,1 @@\n-                            case \"writeReplace\"     -> checkWriteReplace(tree,e, method);\n+                            case \"writeReplace\"     -> {hasWriteReplace[0] = true; hasAppropriateWriteReplace(tree, method, true);}\n@@ -5197,1 +5207,20 @@\n-\n+            if (!hasWriteReplace[0] &&\n+                    (c.isValueClass() || hasAbstractValueSuperClass(c)) &&\n+                    !c.isAbstract() && !c.isRecord() &&\n+                    types.unboxedType(c.type) == Type.noType) {\n+                \/\/ we need to check if the class is inheriting an appropriate writeReplace method\n+                MethodSymbol ms = null;\n+                Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);\n+                try {\n+                    ms = rs.resolveInternalMethod(env.tree, env, c.type, names.writeReplace, List.nil(), List.nil());\n+                } catch (FatalError fe) {\n+                    \/\/ ignore no method was found\n+                } finally {\n+                    log.popDiagnosticHandler(discardHandler);\n+                }\n+                if (ms == null || !hasAppropriateWriteReplace(p, ms, false)) {\n+                    log.warning(LintCategory.SERIAL, p,\n+                            c.isValueClass() ? Warnings.SerializableValueClassWithoutWriteReplace1 :\n+                                    Warnings.SerializableValueClassWithoutWriteReplace2);\n+                }\n+            }\n@@ -5205,0 +5234,16 @@\n+        private boolean hasAbstractValueSuperClass(Symbol c) {\n+            while (c.getKind() == ElementKind.CLASS) {\n+                Type sup = ((ClassSymbol)c).getSuperclass();\n+                if (!sup.hasTag(CLASS) || sup.isErroneous() ||\n+                        sup.tsym == syms.objectType.tsym) {\n+                    return false;\n+                }\n+                \/\/ if it is a value super class it has to be abstract\n+                if (sup.isValueClass()) {\n+                    return true;\n+                }\n+                c = sup.tsym;\n+            }\n+            return false;\n+        }\n+\n@@ -5328,1 +5373,1 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n@@ -5330,1 +5375,1 @@\n-            checkExceptions(tree, e, method, syms.ioExceptionType);\n+            hasExpectedExceptions(tree, method, true, syms.ioExceptionType);\n@@ -5334,1 +5379,1 @@\n-        private void checkWriteReplace(JCClassDecl tree, Element e, MethodSymbol method) {\n+        private boolean hasAppropriateWriteReplace(JCClassDecl tree, MethodSymbol method, boolean warn) {\n@@ -5340,4 +5385,4 @@\n-            checkConcreteInstanceMethod(tree, e, method);\n-            checkReturnType(tree, e, method, syms.objectType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            return isConcreteInstanceMethod(tree, method, warn) &&\n+                    isExpectedReturnType(tree, method, syms.objectType, warn) &&\n+                    hasNoArgs(tree, method, warn) &&\n+                    hasExpectedExceptions(tree, method, warn, syms.objectStreamExceptionType);\n@@ -5354,1 +5399,1 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n@@ -5356,1 +5401,1 @@\n-            checkExceptions(tree, e, method, syms.ioExceptionType, syms.classNotFoundExceptionType);\n+            hasExpectedExceptions(tree, method, true, syms.ioExceptionType, syms.classNotFoundExceptionType);\n@@ -5363,3 +5408,3 @@\n-            checkReturnType(tree, e, method, syms.voidType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            isExpectedReturnType(tree, method, syms.voidType, true);\n+            hasNoArgs(tree, method, true);\n+            hasExpectedExceptions(tree, method, true, syms.objectStreamExceptionType);\n@@ -5375,4 +5420,4 @@\n-            checkConcreteInstanceMethod(tree, e, method);\n-            checkReturnType(tree,e, method, syms.objectType);\n-            checkNoArgs(tree, e, method);\n-            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            isConcreteInstanceMethod(tree, method, true);\n+            isExpectedReturnType(tree, method, syms.objectType, true);\n+            hasNoArgs(tree, method, true);\n+            hasExpectedExceptions(tree, method, true, syms.objectStreamExceptionType);\n@@ -5628,1 +5673,1 @@\n-                        case \"writeReplace\" -> checkWriteReplace(tree, e, method);\n+                        case \"writeReplace\" -> hasAppropriateWriteReplace(tree, method, true);\n@@ -5646,3 +5691,3 @@\n-        void checkConcreteInstanceMethod(JCClassDecl tree,\n-                                         Element enclosing,\n-                                         MethodSymbol method) {\n+        boolean isConcreteInstanceMethod(JCClassDecl tree,\n+                                         MethodSymbol method,\n+                                         boolean warn) {\n@@ -5650,0 +5695,1 @@\n+                if (warn) {\n@@ -5651,2 +5697,4 @@\n-                                TreeInfo.diagnosticPositionFor(method, tree),\n-                                Warnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+                }\n+                return false;\n@@ -5654,0 +5702,1 @@\n+            return true;\n@@ -5656,4 +5705,4 @@\n-        private void checkReturnType(JCClassDecl tree,\n-                                     Element enclosing,\n-                                     MethodSymbol method,\n-                                     Type expectedReturnType) {\n+        private boolean isExpectedReturnType(JCClassDecl tree,\n+                                          MethodSymbol method,\n+                                          Type expectedReturnType,\n+                                          boolean warn) {\n@@ -5667,1 +5716,2 @@\n-                log.warning(LintCategory.SERIAL,\n+                if (warn) {\n+                    log.warning(LintCategory.SERIAL,\n@@ -5670,1 +5720,3 @@\n-                                                                      rtype, expectedReturnType));\n+                                    rtype, expectedReturnType));\n+                }\n+                return false;\n@@ -5672,0 +5724,1 @@\n+            return true;\n@@ -5709,1 +5762,1 @@\n-        private void checkNoArgs(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+        boolean hasNoArgs(JCClassDecl tree, MethodSymbol method, boolean warn) {\n@@ -5712,1 +5765,2 @@\n-                log.warning(LintCategory.SERIAL,\n+                if (warn) {\n+                    log.warning(LintCategory.SERIAL,\n@@ -5715,0 +5769,2 @@\n+                }\n+                return false;\n@@ -5716,0 +5772,1 @@\n+            return true;\n@@ -5728,4 +5785,4 @@\n-        private void checkExceptions(JCClassDecl tree,\n-                                     Element enclosing,\n-                                     MethodSymbol method,\n-                                     Type... declaredExceptions) {\n+        private boolean hasExpectedExceptions(JCClassDecl tree,\n+                                              MethodSymbol method,\n+                                              boolean warn,\n+                                              Type... declaredExceptions) {\n@@ -5750,1 +5807,2 @@\n-                        log.warning(LintCategory.SERIAL,\n+                        if (warn) {\n+                            log.warning(LintCategory.SERIAL,\n@@ -5753,1 +5811,3 @@\n-                                                                             thrownType));\n+                                            thrownType));\n+                        }\n+                        return false;\n@@ -5757,1 +5817,1 @@\n-            return;\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":106,"deletions":46,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -5114,4 +5114,0 @@\n-\n-        boolean internal() {\n-            return internalResolution;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2078,0 +2078,6 @@\n+compiler.warn.serializable.value.class.without.write.replace.1=\\\n+    serializable value class does not declare, or inherits, a writeReplace method\n+\n+compiler.warn.serializable.value.class.without.write.replace.2=\\\n+    serializable class does not declare, or inherits, a writeReplace method\n+\n@@ -4125,0 +4131,3 @@\n+\n+compiler.warn.value.finalize=\\\n+    value classes should not have finalize methods, they are not invoked\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serializable.value.class.without.write.replace.2\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: -Xlint:serial --enable-preview -source ${jdk.version}\n+\n+import java.io.Serializable;\n+\n+abstract value class ValueSuper implements Serializable {\n+    private static final long serialVersionUID = 1;\n+}\n+\n+class SerializableIdentityClass extends ValueSuper {\n+    private static final long serialVersionUID = 1;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerializableIdentityClass.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.serializable.value.class.without.write.replace.1\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: -Xlint:serial --enable-preview -source ${jdk.version}\n+\n+import java.io.Serializable;\n+\n+value class SerializableValueClass implements Serializable {\n+    private static final long serialVersionUID = 1;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SerializableValueClass.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.value.finalize\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ key: compiler.warn.has.been.deprecated.for.removal\n+\/\/ options: --enable-preview  -source ${jdk.version}\n+\n+value class ValueWithFinalizeMethod {\n+    protected void finalize() throws Throwable { }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithFinalizeMethod.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -884,0 +884,141 @@\n+    @Test\n+    void testSerializationWarnings() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            setCompileOptions(new String[] {\"-Xlint:serial\", \"--enable-preview\", \"--source\",\n+                    Integer.toString(Runtime.version().feature())});\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class AVC implements Serializable {}\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.serializable.value.class.without.write.replace.1\",\n+                    \"\"\"\n+                    import java.io.*;\n+                    value class VC implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    class C implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        protected Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    value class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    value class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        public Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    value class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.serializable.value.class.without.write.replace.1\",\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        private Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    value class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.serializable.value.class.without.write.replace.2\",\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        private Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        public Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    abstract value class Super implements Serializable {\n+                        private static final long serialVersionUID = 0;\n+                        protected Object writeReplace() throws ObjectStreamException {\n+                            return null;\n+                        }\n+                    }\n+                    class ValueSerializable extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import java.io.*;\n+                    value record ValueRecord() implements Serializable {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"modified"}]}