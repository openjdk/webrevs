{"files":[{"patch":"@@ -241,2 +241,2 @@\n-      <p>This document is divided into \\\n-      $$(subst 2,two,$$(subst 3,three,$$(words $$($1_GROUPS)))) sections:<\/p> \\\n+      <p>This document has \\\n+      $$(subst 2,two,$$(subst 3,three,$$(words $$($1_GROUPS)))) major sections:<\/p> \\\n@@ -251,1 +251,4 @@\n-        #\n+    <p><a href=\"..\/specs\/index.html\">Related documents<\/a> specify the Java \\\n+    programming language, the Java Virtual Machine, various protocols and file \\\n+    formats pertaining to the Java platform, and tools included in the JDK.<\/p> \\\n+    #\n","filename":"make\/Docs.gmk","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -884,0 +884,40 @@\n+\/\/ Class for vector register V10\n+reg_class v10_veca_reg(\n+    V10, V10_H, V10_J, V10_K\n+);\n+\n+\/\/ Class for vector register V11\n+reg_class v11_veca_reg(\n+    V11, V11_H, V11_J, V11_K\n+);\n+\n+\/\/ Class for vector register V12\n+reg_class v12_veca_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ Class for vector register V13\n+reg_class v13_veca_reg(\n+    V13, V13_H, V13_J, V13_K\n+);\n+\n+\/\/ Class for vector register V17\n+reg_class v17_veca_reg(\n+    V17, V17_H, V17_J, V17_K\n+);\n+\n+\/\/ Class for vector register V18\n+reg_class v18_veca_reg(\n+    V18, V18_H, V18_J, V18_K\n+);\n+\n+\/\/ Class for vector register V23\n+reg_class v23_veca_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ Class for vector register V24\n+reg_class v24_veca_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n@@ -4994,0 +5034,80 @@\n+operand vReg_V10()\n+%{\n+  constraint(ALLOC_IN_RC(v10_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V11()\n+%{\n+  constraint(ALLOC_IN_RC(v11_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V17()\n+%{\n+  constraint(ALLOC_IN_RC(v17_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V18()\n+%{\n+  constraint(ALLOC_IN_RC(v18_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2887,0 +2887,121 @@\n+\n+\/\/ Selects elements from two source vectors (src1, src2) based on index values in the index register\n+\/\/ using Neon instructions and places it in the destination vector element corresponding to the\n+\/\/ index vector element. Each index in the index register must be in the range - [0, 2 * NUM_ELEM),\n+\/\/ where NUM_ELEM is the number of BasicType elements per vector.\n+\/\/ If idx < NUM_ELEM --> selects src1[idx] (idx is an element of the index register)\n+\/\/ Otherwise, selects src2[idx – NUM_ELEM]\n+void C2_MacroAssembler::select_from_two_vectors_neon(FloatRegister dst, FloatRegister src1,\n+                                                     FloatRegister src2, FloatRegister index,\n+                                                     FloatRegister tmp, unsigned vector_length_in_bytes) {\n+  assert_different_registers(dst, src1, src2, tmp);\n+  SIMD_Arrangement size = vector_length_in_bytes == 16 ? T16B : T8B;\n+\n+  if (vector_length_in_bytes == 16) {\n+    assert(UseSVE <= 1, \"sve must be <= 1\");\n+    assert(src1->successor() == src2, \"Source registers must be ordered\");\n+    \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n+    tbl(dst, size, src1, 2, index);\n+  } else { \/\/ vector length == 8\n+    assert(UseSVE == 0, \"must be Neon only\");\n+    \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register because the\n+    \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+    \/\/ instruction with one vector lookup\n+    ins(tmp, D, src1, 0, 0);\n+    ins(tmp, D, src2, 1, 0);\n+    tbl(dst, size, tmp, 1, index);\n+  }\n+}\n+\n+\/\/ Selects elements from two source vectors (src1, src2) based on index values in the index register\n+\/\/ using SVE\/SVE2 instructions and places it in the destination vector element corresponding to the\n+\/\/ index vector element. Each index in the index register must be in the range - [0, 2 * NUM_ELEM),\n+\/\/ where NUM_ELEM is the number of BasicType elements per vector.\n+\/\/ If idx < NUM_ELEM --> selects src1[idx] (idx is an element of the index register)\n+\/\/ Otherwise, selects src2[idx – NUM_ELEM]\n+void C2_MacroAssembler::select_from_two_vectors_sve(FloatRegister dst, FloatRegister src1,\n+                                                    FloatRegister src2, FloatRegister index,\n+                                                    FloatRegister tmp, SIMD_RegVariant T,\n+                                                    unsigned vector_length_in_bytes) {\n+  assert_different_registers(dst, src1, src2, index, tmp);\n+\n+  if (vector_length_in_bytes == 8) {\n+    \/\/ We need to fit both the source vectors (src1, src2) in a single vector register because the\n+    \/\/ SVE \"tbl\" instruction is unpredicated and works on the entire vector which can lead to\n+    \/\/ incorrect results if each source vector is only partially filled. We then use the SVE \"tbl\"\n+    \/\/ instruction with one vector lookup\n+    assert(UseSVE >= 1, \"sve must be >= 1\");\n+    ins(tmp, D, src1, 0, 0);\n+    ins(tmp, D, src2, 1, 0);\n+    sve_tbl(dst, T, tmp, index);\n+  } else {  \/\/ UseSVE == 2 and vector_length_in_bytes > 8\n+    \/\/ If the vector length is > 8, then use the SVE2 \"tbl\" instruction with the two vector table.\n+    \/\/ The assertion - vector_length_in_bytes == MaxVectorSize ensures that this operation\n+    \/\/ is not executed on machines where vector_length_in_bytes < MaxVectorSize\n+    \/\/ with the only exception of 8B vector length.\n+    assert(UseSVE == 2 && vector_length_in_bytes == MaxVectorSize, \"must be\");\n+    assert(src1->successor() == src2, \"Source registers must be ordered\");\n+    sve_tbl(dst, T, src1, src2, index);\n+  }\n+}\n+\n+void C2_MacroAssembler::select_from_two_vectors(FloatRegister dst, FloatRegister src1,\n+                                                FloatRegister src2, FloatRegister index,\n+                                                FloatRegister tmp, BasicType bt,\n+                                                unsigned vector_length_in_bytes) {\n+\n+  assert_different_registers(dst, src1, src2, index, tmp);\n+\n+  \/\/ The cases that can reach this method are -\n+  \/\/ - UseSVE = 0, vector_length_in_bytes = 8 or 16\n+  \/\/ - UseSVE = 1, vector_length_in_bytes = 8 or 16\n+  \/\/ - UseSVE = 2, vector_length_in_bytes >= 8\n+  \/\/\n+  \/\/ SVE\/SVE2 tbl instructions are generated when UseSVE = 1 with vector_length_in_bytes = 8\n+  \/\/ and UseSVE = 2 with vector_length_in_bytes >= 8\n+  \/\/\n+  \/\/ Neon instructions are generated when UseSVE = 0 with vector_length_in_bytes = 8 or 16 and\n+  \/\/ UseSVE = 1 with vector_length_in_bytes = 16\n+\n+  if ((UseSVE == 1 && vector_length_in_bytes == 8) || UseSVE == 2) {\n+    SIMD_RegVariant T = elemType_to_regVariant(bt);\n+    select_from_two_vectors_sve(dst, src1, src2, index, tmp, T, vector_length_in_bytes);\n+    return;\n+  }\n+\n+  \/\/ The only BasicTypes that can reach here are T_SHORT, T_BYTE, T_INT and T_FLOAT\n+  assert(bt != T_DOUBLE && bt != T_LONG, \"unsupported basic type\");\n+  assert(vector_length_in_bytes <= 16, \"length_in_bytes must be <= 16\");\n+\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Neon \"tbl\" instruction only supports byte tables, so we need to look at chunks of\n+  \/\/ 2B for selecting shorts or chunks of 4B for selecting ints\/floats from the table.\n+  \/\/ The index values in \"index\" register are in the range of [0, 2 * NUM_ELEM) where NUM_ELEM\n+  \/\/ is the number of elements that can fit in a vector. For ex. for T_SHORT with 64-bit vector length,\n+  \/\/ the indices can range from [0, 8).\n+  \/\/ As an example with 64-bit vector length and T_SHORT type - let index = [2, 5, 1, 0]\n+  \/\/ Move a constant 0x02 in every byte of tmp - tmp = [0x0202, 0x0202, 0x0202, 0x0202]\n+  \/\/ Multiply index vector with tmp to yield - dst = [0x0404, 0x0a0a, 0x0202, 0x0000]\n+  \/\/ Move a constant 0x0100 in every 2B of tmp - tmp = [0x0100, 0x0100, 0x0100, 0x0100]\n+  \/\/ Add the multiplied result to the vector in tmp to obtain the byte level\n+  \/\/ offsets - dst = [0x0504, 0x0b0a, 0x0302, 0x0100]\n+  \/\/ Use these offsets in the \"tbl\" instruction to select chunks of 2B.\n+\n+  if (bt == T_BYTE) {\n+    select_from_two_vectors_neon(dst, src1, src2, index, tmp, vector_length_in_bytes);\n+  } else {\n+    int elem_size = (bt == T_SHORT) ? 2 : 4;\n+    uint64_t tbl_offset = (bt == T_SHORT) ? 0x0100u : 0x03020100u;\n+\n+    mov(tmp, size1, elem_size);\n+    mulv(dst, size2, index, tmp);\n+    mov(tmp, size2, tbl_offset);\n+    addv(dst, size1, dst, tmp); \/\/ \"dst\" now contains the processed index elements\n+                                \/\/ to select a set of 2B\/4B\n+    select_from_two_vectors_neon(dst, src1, src2, dst, tmp, vector_length_in_bytes);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -37,0 +37,9 @@\n+  void select_from_two_vectors_neon(FloatRegister dst, FloatRegister src1,\n+                                    FloatRegister src2, FloatRegister index,\n+                                    FloatRegister tmp, unsigned vector_length_in_bytes);\n+\n+  void select_from_two_vectors_sve(FloatRegister dst, FloatRegister src1,\n+                                   FloatRegister src2, FloatRegister index,\n+                                   FloatRegister tmp, SIMD_RegVariant T,\n+                                   unsigned vector_length_in_bytes);\n+\n@@ -198,0 +207,5 @@\n+  \/\/ Select from a table of two vectors\n+  void select_from_two_vectors(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n+                               FloatRegister index, FloatRegister tmp, BasicType bt,\n+                               unsigned vector_length_in_bytes);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2232,10 +2232,3 @@\n-      if (UseCompressedClassPointers) {\n-        \/\/ We don't need decode because we just need to compare\n-        __ ldr_u32(tmp, Address(src, oopDesc::klass_offset_in_bytes()));\n-        __ ldr_u32(tmp2, Address(dst, oopDesc::klass_offset_in_bytes()));\n-        __ cmp_32(tmp, tmp2);\n-      } else {\n-        __ load_klass(tmp, src);\n-        __ load_klass(tmp2, dst);\n-        __ cmp(tmp, tmp2);\n-      }\n+      __ load_klass(tmp, src);\n+      __ load_klass(tmp2, dst);\n+      __ cmp(tmp, tmp2);\n@@ -2464,6 +2457,1 @@\n-\n-  if (UseCompressedClassPointers) { \/\/ On 32 bit arm??\n-    __ ldr_u32(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  } else {\n-    __ ldr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  __ ldr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -748,2 +748,2 @@\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n-      x->id() == vmIntrinsics::_dcbrt\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dsinh ||\n+      x->id() == vmIntrinsics::_dtanh || x->id() == vmIntrinsics::_dcbrt\n@@ -863,0 +863,6 @@\n+    case vmIntrinsics::_dsinh:\n+      assert(StubRoutines::dsinh() != nullptr, \"sinh intrinsic not found\");\n+      if (StubRoutines::dsinh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dsinh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3708,0 +3708,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsinh)) {\n+      StubRoutines::_dsinh = generate_libmSinh(); \/\/ from stubGenerator_x86_64_sinh.cpp\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -558,0 +558,1 @@\n+  address generate_libmSinh();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1072,0 +1072,1 @@\n+    FLAG_SET_ERGO(IntelJccErratumMitigation, _has_intel_jcc_erratum);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1834,1 +1834,4 @@\n-       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+       if (size_in_bits < 128) {\n+         return false;\n+       }\n+       if ((size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3577,0 +3577,1 @@\n+  case vmIntrinsics::_dsinh         : \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3393,0 +3393,1 @@\n+  case vmIntrinsics::_dsinh:          \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -375,0 +375,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dsinh());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n@@ -40,1 +40,0 @@\n-#include \"oops\/trainingData.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"oops\/trainingData.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -60,1 +61,0 @@\n-#include \"oops\/compressedKlass.hpp\"\n@@ -83,2 +83,2 @@\n-# include <sys\/stat.h>\n-# include <errno.h>\n+#include <errno.h>\n+#include <sys\/stat.h>\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -250,1 +250,1 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompressedClassPointers && CompressedKlassPointers::needs_class_space()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n@@ -83,1 +82,1 @@\n-#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-#include <stdlib.h>\n+#include <stdlib.h>\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"oops\/instanceMirrorKlass.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"oops\/klass.hpp\"\n@@ -65,2 +64,1 @@\n-#include \"oops\/oopCast.inline.hpp\"\n-#include \"oops\/symbol.hpp\"\n+#include \"oops\/oopCast.inline.hpp\"\n@@ -69,0 +67,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -875,0 +874,1 @@\n+int java_lang_Class::_raw_access_flags_offset;\n@@ -1078,0 +1078,4 @@\n+  \/\/ Set the raw access_flags, this is used by reflection instead of modifier flags.\n+  \/\/ The Java code for array classes gets the access flags from the element type.\n+  assert(!k->is_array_klass() || k->access_flags().as_unsigned_short() == 0, \"access flags are not set for arrays\");\n+  set_raw_access_flags(mirror(), k->access_flags().as_unsigned_short());\n@@ -1406,0 +1410,2 @@\n+  set_raw_access_flags(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+\n@@ -1550,0 +1556,1 @@\n+  macro(_raw_access_flags_offset,    k, \"classFileAccessFlags\",      char_signature,    false); \\\n@@ -1595,0 +1602,10 @@\n+int java_lang_Class::raw_access_flags(oop the_class_mirror) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->char_field(_raw_access_flags_offset);\n+}\n+\n+void java_lang_Class::set_raw_access_flags(oop the_class_mirror, u2 value) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->char_field_put(_raw_access_flags_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -262,0 +262,1 @@\n+  static int _raw_access_flags_offset;\n@@ -348,0 +349,3 @@\n+  static int raw_access_flags(oop java_class);\n+  static void set_raw_access_flags(oop java_class, u2 value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"logging\/logTag.hpp\"\n+#include \"logging\/logTag.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -64,2 +65,0 @@\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopHandle.hpp\"\n@@ -69,1 +68,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/stackMapTable.hpp\"\n+#include \"classfile\/stackMapTable.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/c2_globals.hpp\"\n-#endif\n@@ -36,0 +33,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/c2_globals.hpp\"\n+#endif\n@@ -94,0 +94,1 @@\n+  case vmIntrinsics::_dsinh:\n@@ -147,0 +148,1 @@\n+  case vmIntrinsics::_dsinh:\n@@ -320,0 +322,1 @@\n+  case vmIntrinsics::_dsinh:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -138,1 +138,2 @@\n-  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")       do_name(cbrt_name,\"cbrt\")                                                               \\\n+  do_name(round_name, \"round\")  do_name(sinh_name,\"sinh\")       do_name(tanh_name,\"tanh\")                               \\\n+  do_name(cbrt_name,\"cbrt\")                                                                                             \\\n@@ -164,0 +165,1 @@\n+  do_intrinsic(_dsinh,                    java_lang_Math,         sinh_name,  double_double_signature,           F_S)   \\\n@@ -317,2 +319,0 @@\n-  do_intrinsic(_getClassAccessFlags,      reflect_Reflection,     getClassAccessFlags_name, class_int_signature, F_SN)  \\\n-   do_name(     getClassAccessFlags_name,                        \"getClassAccessFlags\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/macros.hpp\"\n+#include \"utilities\/macros.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-#include <sys\/stat.h>\n+#include <sys\/stat.h>\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/javaFrameAnchor.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/stackValue.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/stackValue.hpp\"\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"compiler\/compileLog.hpp\"\n+#include \"compiler\/compileLog.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -41,1 +41,0 @@\n-#include \"runtime\/handles.hpp\"\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -62,1 +62,1 @@\n-#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuation.hpp\"\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -689,0 +689,3 @@\n+  \/\/ Need to clear claim bits for the next full-gc (marking and adjust-pointers).\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n@@ -962,5 +965,2 @@\n-\/\/ This method should contain all heap-specific policy for invoking a full\n-\/\/ collection.  invoke_no_policy() will only attempt to compact the heap; it\n-\/\/ will do nothing further.  If we need to bail out for policy reasons, scavenge\n-\/\/ before full gc, or any other specialized behavior, it needs to be added here.\n-\/\/\n+\/\/ This method invokes a full collection. The argument controls whether\n+\/\/ soft-refs should be cleared or not.\n@@ -969,5 +969,0 @@\n-\/\/\n-\/\/ Note that the all_soft_refs_clear flag in the soft ref policy\n-\/\/ may be true because this method can be called without intervening\n-\/\/ activity.  For example when the heap space is tight and full measure\n-\/\/ are being taken to free space.\n@@ -982,4 +977,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  clear_all_soft_refs = clear_all_soft_refs\n-                     || heap->soft_ref_policy()->should_clear_all_soft_refs();\n-\n@@ -1005,5 +996,0 @@\n-  \/\/ The scope of casr should end after code that can change\n-  \/\/ SoftRefPolicy::_should_clear_all_soft_refs.\n-  ClearedAllSoftRefs casr(clear_all_soft_refs,\n-                          heap->soft_ref_policy());\n-\n@@ -1309,3 +1295,0 @@\n-\n-    \/\/ Need to clear claim bits for the next mark.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -709,0 +709,10 @@\n+  \/\/ Usually, all class unloading work occurs at the end of phase 1, but Serial\n+  \/\/ full-gc accesses dead-objs' klass to find out the start of next live-obj\n+  \/\/ during phase 2. This requires klasses of dead-objs to be kept loaded.\n+  \/\/ Therefore, we declare ClassUnloadingContext at the same level as\n+  \/\/ full-gc phases, and purge dead classes (invoking\n+  \/\/ ClassLoaderDataGraph::purge) after all phases of full-gc.\n+  ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                            false \/* unregister_nmethods_during_purge *\/,\n+                            false \/* lock_nmethod_free_separately *\/);\n+\n@@ -759,0 +769,7 @@\n+  \/\/ Delete metaspaces for unloaded class loaders and clean up CLDG.\n+  ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+  DEBUG_ONLY(MetaspaceUtils::verify();)\n+\n+  \/\/ Need to clear claim bits for the next full-gc (specifically phase 1 and 3).\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  static_field(CompilerToVM::Data,             dsinh,                                  address)                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-  const bool use_class_space = parser.klass_needs_narrow_id();\n+  const bool use_class_space = UseClassMetaspaceForAllClasses || parser.klass_needs_narrow_id();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  return !is_abstract() && !is_interface();\n+  return UseClassMetaspaceForAllClasses || (!is_abstract() && !is_interface());\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -620,0 +620,1 @@\n+  case vmIntrinsics::_dsinh:\n@@ -774,1 +775,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4134,1 +4134,4 @@\n-          new_in2 = ConNode::make(t->make_narrowklass());\n+          ciKlass* klass = t->is_klassptr()->exact_klass();\n+          if (klass->is_in_encoding_range()) {\n+            new_in2 = ConNode::make(t->make_narrowklass());\n+          }\n@@ -4171,1 +4174,7 @@\n-        n->subsume_by(ConNode::make(t->make_narrowklass()), this);\n+        ciKlass* klass = t->is_klassptr()->exact_klass();\n+        if (klass->is_in_encoding_range()) {\n+          n->subsume_by(ConNode::make(t->make_narrowklass()), this);\n+        } else {\n+          assert(false, \"unencodable klass in ConP -> EncodeP\");\n+          C->record_failure(\"unencodable klass in ConP -> EncodeP\");\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  case vmIntrinsics::_dsinh:\n@@ -543,2 +544,1 @@\n-  case vmIntrinsics::_getSuperclass:\n-  case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());\n+  case vmIntrinsics::_getSuperclass:            return inline_native_Class_query(intrinsic_id());\n@@ -1911,0 +1911,3 @@\n+  case vmIntrinsics::_dsinh:\n+    return StubRoutines::dsinh() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsinh(), \"dsinh\") : false;\n@@ -4395,4 +4398,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n@@ -4494,5 +4493,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2133,1 +2133,0 @@\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n@@ -2139,1 +2138,0 @@\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2173,3 +2173,9 @@\n-Node* InvolutionNode::Identity(PhaseGVN* phase) {\n-  \/\/ Op ( Op x ) => x\n-  if (in(1)->Opcode() == Opcode()) {\n+Node* ReverseINode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseI) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+Node* ReverseLNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseL) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -464,7 +464,0 @@\n-\/\/------------------------------InvolutionNode----------------------------------\n-\/\/ Represents a self-inverse operation, i.e., op(op(x)) = x for any x\n-class InvolutionNode : public Node {\n-public:\n-  InvolutionNode(Node* in) : Node(nullptr, in) {}\n-  virtual Node* Identity(PhaseGVN* phase);\n-};\n@@ -473,1 +466,1 @@\n-class NegNode : public InvolutionNode {\n+class NegNode : public Node {\n@@ -475,1 +468,1 @@\n-  NegNode(Node* in1) : InvolutionNode(in1) {\n+  NegNode(Node* in1) : Node(nullptr, in1) {\n@@ -587,1 +580,1 @@\n-class ReverseBytesNode : public InvolutionNode {\n+class ReverseBytesNode : public Node {\n@@ -589,1 +582,1 @@\n-  ReverseBytesNode(Node* in) : InvolutionNode(in) {}\n+  ReverseBytesNode(Node* in) : Node(nullptr, in) {}\n@@ -596,3 +589,1 @@\n-  ReverseBytesINode(Node* in) : ReverseBytesNode(in) {\n-  }\n-\n+  ReverseBytesINode(Node* in) : ReverseBytesNode(in) {}\n@@ -636,1 +627,1 @@\n-class ReverseINode : public InvolutionNode {\n+class ReverseINode : public Node {\n@@ -638,1 +629,1 @@\n-  ReverseINode(Node* in) : InvolutionNode(in) {}\n+  ReverseINode(Node* in) : Node(nullptr,in) {}\n@@ -642,0 +633,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -647,1 +639,1 @@\n-class ReverseLNode : public InvolutionNode {\n+class ReverseLNode : public Node {\n@@ -649,1 +641,1 @@\n-  ReverseLNode(Node* in) : InvolutionNode(in) {}\n+  ReverseLNode(Node* in) : Node(nullptr, in) {}\n@@ -653,0 +645,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1922,13 +1922,0 @@\n-JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))\n-{\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive type\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  return k->access_flags().as_class_flags();\n-}\n-JVM_END\n-\n@@ -3073,1 +3060,1 @@\n-    if (!thread->sleep_nanos(nanos)) { \/\/ interrupted\n+    if (!thread->sleep_nanos(nanos)) { \/\/ interrupted or async exception was installed\n@@ -3078,4 +3065,5 @@\n-\n-        \/\/ TODO-FIXME: THROW_MSG returns which means we will not call set_state()\n-        \/\/ to properly restore the thread state.  That's likely wrong.\n-        THROW_MSG(vmSymbols::java_lang_InterruptedException(), \"sleep interrupted\");\n+        if (!thread->has_async_exception_condition()) {\n+          \/\/ TODO-FIXME: THROW_MSG returns which means we will not call set_state()\n+          \/\/ to properly restore the thread state.  That's likely wrong.\n+          THROW_MSG(vmSymbols::java_lang_InterruptedException(), \"sleep interrupted\");\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1510,3 +1510,3 @@\n-#if INCLUDE_G1GC || INCLUDE_SERIALGC\n-  if (UseG1GC || UseSerialGC) {\n-    \/\/ Needs to be cleared explicitly for G1 and Serial GC.\n+#if INCLUDE_G1GC\n+  if (UseG1GC) {\n+    \/\/ Needs to be cleared explicitly for G1 GC.\n@@ -1515,1 +1515,1 @@\n-#endif \/\/ INCLUDE_G1GC || INCLUDE_SERIALGC\n+#endif \/\/ INCLUDE_G1GC\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1503,13 +1503,10 @@\n-  size_t max_allocatable;\n-  size_t result = limit;\n-  if (os::has_allocatable_memory_limit(&max_allocatable)) {\n-    \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n-    \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n-    \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n-    \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n-    \/\/ removed, this can be cleaned up.\n-    size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n-    size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n-    result = MIN2(result, max_allocatable \/ fraction);\n-  }\n-  return result;\n+  \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n+  \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n+  \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n+  \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n+  \/\/ removed, this can be cleaned up.\n+  size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n+  size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n+  size_t max_allocatable = os::commit_memory_limit();\n+\n+  return MIN2(limit, max_allocatable \/ fraction);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -127,4 +127,0 @@\n-  product(bool, UseCompressedClassPointers, true,                           \\\n-          \"(Deprecated) Use 32-bit class pointers in 64-bit VM. \"           \\\n-          \"lp64_product means flag is always constant in 32 bit VM\")        \\\n-                                                                            \\\n@@ -149,1 +145,0 @@\n-const bool UseCompressedClassPointers = false;\n@@ -1428,0 +1423,3 @@\n+  product(bool, UseCompressedClassPointers, true,                           \\\n+          \"(Deprecated) Use 32-bit class pointers.\")                        \\\n+                                                                            \\\n@@ -2053,0 +2051,4 @@\n+                                                                            \\\n+  product(bool, UseClassMetaspaceForAllClasses, false, DIAGNOSTIC,          \\\n+          \"Use the class metaspace for all classes including \"              \\\n+          \"abstract and interface classes.\")                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -742,0 +742,2 @@\n+  JFR_ONLY(Jfr::on_thread_start(this);)\n+\n@@ -1150,1 +1152,0 @@\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n@@ -2102,1 +2103,1 @@\n-\/\/ if the thread was interrupted.\n+\/\/ if the thread was interrupted or async exception was installed.\n@@ -2122,0 +2123,3 @@\n+    if (has_async_exception_condition()) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -654,0 +655,1 @@\n+        VMError::set_safepoint_timed_out_thread(p2i(cur_thread));\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,0 +685,2 @@\n+  do_stub(initial, dsinh)                                               \\\n+  do_entry(initial, dsinh, dsinh, dsinh)                                \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1370,1 +1370,1 @@\n-  st->print_cr(\"Full thread dump %s (%s %s):\",\n+  st->print_cr(\"Full thread dump %s (%s %s)\",\n@@ -1374,0 +1374,14 @@\n+  JDK_Version::current().to_string(buf, sizeof(buf));\n+  const char* runtime_name = JDK_Version::runtime_name() != nullptr ?\n+                             JDK_Version::runtime_name() : \"\";\n+  const char* runtime_version = JDK_Version::runtime_version() != nullptr ?\n+                                JDK_Version::runtime_version() : \"\";\n+  const char* vendor_version = JDK_Version::runtime_vendor_version() != nullptr ?\n+                               JDK_Version::runtime_vendor_version() : \"\";\n+  const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != nullptr ?\n+                                VM_Version::printable_jdk_debug_level() : \"\";\n+\n+  st->print_cr(\"                 JDK version: %s%s%s (%s) (%sbuild %s)\", runtime_name,\n+                (*vendor_version != '\\0') ? \" \" : \"\", vendor_version,\n+                buf, jdk_debug_level, runtime_version);\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\/\/ Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in <jvm.h>.\n@@ -347,1 +346,1 @@\n-#define PROPERFMTARGS(s)      byte_size_in_proper_unit(s), proper_unit_for_byte_size(s)\n+#define PROPERFMTARGS(s)      byte_size_in_proper_unit<size_t>(s), proper_unit_for_byte_size(s)\n@@ -1078,0 +1077,9 @@\n+\/\/ same as nth_bit(n), but allows handing in a type as template parameter. Allows\n+\/\/ us to use nth_bit with 64-bit types on 32-bit platforms\n+template<class T> inline T nth_bit_typed(int n) {\n+  return ((T)1) << n;\n+}\n+template<class T> inline T right_n_bits_typed(int n) {\n+  return nth_bit_typed<T>(n) - 1;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim, char flags) {\n@@ -256,0 +256,1 @@\n+        classFileAccessFlags = flags;\n@@ -1080,0 +1081,1 @@\n+    private final transient char classFileAccessFlags;  \/\/ Set by the VM\n@@ -1454,1 +1456,1 @@\n-        \/\/ Use getClassAccessFlagsRaw to expose SUPER status.\n+        \/\/ Use getClassFileAccessFlags to expose SUPER status.\n@@ -1460,1 +1462,1 @@\n-        int accessFlags = location == AccessFlag.Location.CLASS ? getClassAccessFlagsRaw() : getModifiers();\n+        int accessFlags = location == AccessFlag.Location.CLASS ? getClassFileAccessFlags() : getModifiers();\n@@ -4216,13 +4218,12 @@\n-    \/*\n-     * Return the access flags as they were in the class's bytecode, including\n-     * the original setting of ACC_SUPER.\n-     *\n-     * If the class is an array type then the access flags of the element type is\n-     * returned.  If the class is a primitive then ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n-     *\/\n-    private int getClassAccessFlagsRaw() {\n-        Class<?> c = isArray() ? elementType() : this;\n-        return c.getClassAccessFlagsRaw0();\n-    }\n-\n-    private native int getClassAccessFlagsRaw0();\n+     \/**\n+      * Return the access flags as they were in the class's bytecode, including\n+      * the original setting of ACC_SUPER.\n+      *\n+      * If this {@code Class} object represents a primitive type or\n+      * void, the flags are {@code PUBLIC}, {@code ABSTRACT}, and\n+      * {@code FINAL}.\n+      * If this {@code Class} object represents an array type, return 0.\n+      *\/\n+     int getClassFileAccessFlags() {\n+         return classFileAccessFlags;\n+     }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2041,0 +2041,3 @@\n+            public int getClassFileAccessFlags(Class<?> klass) {\n+                return klass.getClassFileAccessFlags();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,0 +116,5 @@\n+    \/**\n+     * Get the int value of the Class's class-file access flags.\n+     *\/\n+    int getClassFileAccessFlags(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,2 @@\n+    final boolean useClassMetaspaceForAllClasses = getFlag(\"UseClassMetaspaceForAllClasses\", Boolean.class);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1459,0 +1459,15 @@\n+    public static final String MASK_ALL = PREFIX + \"MASK_ALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MASK_ALL, \"MaskAll\");\n+    }\n+\n+    public static final String VECTOR_LONG_TO_MASK = PREFIX + \"VECTOR_LONG_TO_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_LONG_TO_MASK, \"VectorLongToMask\");\n+    }\n+\n+    public static final String VECTOR_MASK_TO_LONG = PREFIX + \"VECTOR_MASK_TO_LONG\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_TO_LONG, \"VectorMaskToLong\");\n+    }\n+\n@@ -1555,10 +1570,0 @@\n-    public static final String NEG_F = PREFIX + \"NEG_F\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(NEG_F, \"NegF\");\n-    }\n-\n-    public static final String NEG_D = PREFIX + \"NEG_D\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(NEG_D, \"NegD\");\n-    }\n-\n@@ -2923,0 +2928,30 @@\n+    public static final String SELECT_FROM_TWO_VECTOR_VB = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VB, \"SelectFromTwoVector\", TYPE_BYTE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VS = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VS, \"SelectFromTwoVector\", TYPE_SHORT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VI = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VI, \"SelectFromTwoVector\", TYPE_INT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VF = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VF\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VF, \"SelectFromTwoVector\", TYPE_FLOAT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VD = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VD\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VD, \"SelectFromTwoVector\", TYPE_DOUBLE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VL = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VL, \"SelectFromTwoVector\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Set;\n@@ -52,1 +53,1 @@\n-        m = cl.getDeclaredMethod(\"getClassAccessFlagsRaw\", new Class[0]);\n+        m = cl.getDeclaredMethod(\"getClassFileAccessFlags\", new Class[0]);\n@@ -59,2 +60,6 @@\n-        \/\/ test primitive array.  should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n-        int flags = (int)m.invoke((new int[3]).getClass());\n+        \/\/ Test that primitive should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n+        int[] arr = new int[3];\n+        if (!arr.getClass().getComponentType().isPrimitive()) {\n+            throw new RuntimeException(\"not primitive\");\n+        }\n+        int flags = (int)m.invoke(arr.getClass().getComponentType());\n@@ -63,1 +68,22 @@\n-                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n+                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that primitive array raw access flags return 0.\n+        flags = (int)m.invoke(arr.getClass());\n+        if (flags != 0) {\n+            throw new RuntimeException(\n+                \"expected 0x0 got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n+        }\n+\n+        \/\/ Test that the modifier flags return element type flags.\n+        flags = (int)arr.getClass().getModifiers();\n+        if (flags != (Modifier.ABSTRACT | Modifier.FINAL | Modifier.PUBLIC | Modifier.IDENTITY)) {\n+            throw new RuntimeException(\n+                \"expected 0x431, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that AccessFlags set will return element type access flags.\n+        Set<AccessFlag> aacc = arr.getClass().accessFlags();\n+        if (!aacc.containsAll(Set.of(AccessFlag.FINAL, AccessFlag.ABSTRACT, AccessFlag.PUBLIC))) {\n+            throw new RuntimeException(\n+                \"AccessFlags should contain FINAL, ABSTRACT and PUBLIC for primitive type\");\n@@ -66,1 +92,1 @@\n-        \/\/ test object array.  should return flags of component.\n+        \/\/ Test object array.  Raw access flags are 0 for arrays.\n@@ -68,0 +94,7 @@\n+        if (flags != 0) {\n+            throw new RuntimeException(\n+                \"expected 0x0, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n+        }\n+\n+        \/\/ Test object array component type.\n+        flags = (int)m.invoke((new SUPERnotset[2]).getClass().getComponentType());\n@@ -76,2 +109,1 @@\n-        \/\/ Because of the repurposing of ACC_SUPER into ACC_IDENTITY by JEP 401, the VM now fixes missing ACC_IDENTITY flags in old class files\n-        if (flags != (Modifier.PUBLIC | Modifier.IDENTITY)) {\n+        if (flags != 0) {\n@@ -79,1 +111,1 @@\n-                \"expected 0x1, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n+                \"expected 0x0, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassAccessFlagsRawTest.java","additions":41,"deletions":9,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -563,2 +563,0 @@\n-com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java     8364314 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    private final ToolBox tb;\n+    final ToolBox tb;\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}