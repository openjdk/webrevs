{"files":[{"patch":"@@ -2882,1 +2882,1 @@\n-    mexp.eliminate_macro_nodes();\n+    mexp.eliminate_macro_nodes(\/* eliminate_locks= *\/ false);\n@@ -2907,1 +2907,1 @@\n-        mexp.eliminate_macro_nodes();\n+        mexp.eliminate_macro_nodes(\/* eliminate_locks= *\/ false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-           \"incorrect kind for Local transitioni: %s\", _kind_name[(int)_kind]);\n+           \"incorrect kind for Local transition: %s\", _kind_name[(int)_kind]);\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2975,1 +2975,1 @@\n-void PhaseMacroExpand::eliminate_macro_nodes() {\n+void PhaseMacroExpand::eliminate_macro_nodes(bool eliminate_locks) {\n@@ -2988,7 +2988,21 @@\n-    \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n-    \/\/ all associated (same box and obj) lock and unlock nodes.\n-    int cnt = C->macro_count();\n-    for (int i=0; i < cnt; i++) {\n-      Node *n = C->macro_node(i);\n-      if (n->is_AbstractLock()) { \/\/ Lock and Unlock nodes\n-        mark_eliminated_locking_nodes(n->as_AbstractLock());\n+    \/\/ Postpone lock elimination to after EA when most allocations are eliminated\n+    \/\/ because they might block lock elimination if their escape state isn't\n+    \/\/ determined yet and we only got one chance at eliminating the lock.\n+    if (eliminate_locks) {\n+      \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n+      \/\/ all associated (same box and obj) lock and unlock nodes.\n+      int cnt = C->macro_count();\n+      for (int i=0; i < cnt; i++) {\n+        Node *n = C->macro_node(i);\n+        if (n->is_AbstractLock()) { \/\/ Lock and Unlock nodes\n+          mark_eliminated_locking_nodes(n->as_AbstractLock());\n+        }\n+      }\n+      \/\/ Re-marking may break consistency of Coarsened locks.\n+      if (!C->coarsened_locks_consistent()) {\n+        return; \/\/ recompile without Coarsened locks if broken\n+      } else {\n+        \/\/ After coarsened locks are eliminated locking regions\n+        \/\/ become unbalanced. We should not execute any more\n+        \/\/ locks elimination optimizations on them.\n+        C->mark_unbalanced_boxes();\n@@ -2996,9 +3010,0 @@\n-    }\n-    \/\/ Re-marking may break consistency of Coarsened locks.\n-    if (!C->coarsened_locks_consistent()) {\n-      return; \/\/ recompile without Coarsened locks if broken\n-    } else {\n-      \/\/ After coarsened locks are eliminated locking regions\n-      \/\/ become unbalanced. We should not execute any more\n-      \/\/ locks elimination optimizations on them.\n-      C->mark_unbalanced_boxes();\n@@ -3031,1 +3036,2 @@\n-        success = eliminate_locking_node(n->as_AbstractLock());\n+        if (eliminate_locks) {\n+          success = eliminate_locking_node(n->as_AbstractLock());\n@@ -3033,3 +3039,3 @@\n-        if (success && PrintOptoStatistics) {\n-          Atomic::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n-        }\n+          if (success && PrintOptoStatistics) {\n+            Atomic::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n+          }\n@@ -3037,0 +3043,1 @@\n+        }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  void eliminate_macro_nodes();\n+  void eliminate_macro_nodes(bool eliminate_locks = true);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8366879\n+ * @summary Test that locks are successfully eliminated by C2.\n+ * @library \/test\/lib  \/\n+ * @run driver compiler.valhalla.inlinetypes.TestLockElimination\n+ *\/\n+public class TestLockElimination {\n+\n+    static class MyClass {\n+        public synchronized int val() {\n+            return 42;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC, IRNode.FAST_LOCK, IRNode.FAST_UNLOCK })\n+    public static int test(int max) {\n+        MyClass obj = new MyClass();\n+        int res = 0;\n+        for (int i = 0; i < max; i++) {\n+            int x = obj.val();\n+            int y = obj.val();\n+            res += x + y;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void test_runner() {\n+        int res = test(3);\n+        Asserts.assertEquals(res, 252);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestLockElimination.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}