{"files":[{"patch":"@@ -1688,5 +1688,0 @@\n-  if (!inline_type_field_access_prolog(x)) {\n-    \/\/ Field store will always deopt due to unloaded field or holder klass\n-    return;\n-  }\n-\n@@ -2079,24 +2074,0 @@\n-bool LIRGenerator::inline_type_field_access_prolog(AccessField* x) {\n-  ciField* field = x->field();\n-  assert(!field->is_flat(), \"Flattened field access should have been expanded\");\n-  \/\/ Deoptimize if the access is non-static and requires patching (holder not loaded\n-  \/\/ or not accessible) because then we only have partial field information and the\n-  \/\/ field could be flat (see ciField constructor).\n-  bool could_be_flat = field->type()->is_inlinetype() && InlineFieldMaxFlatSize >= 0 &&\n-                       !x->is_static() && x->needs_patching();\n-  \/\/ Deoptimize if we load from a static field with an uninitialized type because we\n-  \/\/ need to throw an exception if initialization of the type failed.\n-  \/\/ TODO 8325106 It seems that this fix for JDK-8273594 is not needed anymore or our tests don't trigger the issue anymore\n-  bool not_initialized = false && x->is_static() && x->as_LoadField() != nullptr &&\n-      !field->type()->as_instance_klass()->is_initialized();\n-  if (could_be_flat || not_initialized) {\n-    CodeEmitInfo* info = state_for(x, x->state_before());\n-    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n-                                        Deoptimization::Reason_unloaded,\n-                                        Deoptimization::Action_make_not_entrant);\n-    __ jump(stub);\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -2132,7 +2103,0 @@\n-  if (!inline_type_field_access_prolog(x)) {\n-    \/\/ Field load will always deopt due to unloaded field or holder klass\n-    LIR_Opr result = rlock_result(x, field_type);\n-    __ move(LIR_OprFact::oopConst(nullptr), result);\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-  bool inline_type_field_access_prolog(AccessField* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1093,0 +1093,1 @@\n+  bool deoptimize_for_flat = false;\n@@ -1109,1 +1110,0 @@\n-    assert(!result.is_flat(), \"Can not patch access to flat field\");\n@@ -1137,0 +1137,5 @@\n+    \/\/ The field we are patching is flat. Deoptimize and regenerate\n+    \/\/ the compiled code which can't handle the layout of the flat\n+    \/\/ field because it was unknown at compile time.\n+    deoptimize_for_flat = result.is_flat();\n+\n@@ -1222,1 +1227,1 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic) {\n+  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_flat) {\n@@ -1233,0 +1238,3 @@\n+      if (deoptimize_for_flat) {\n+        tty->print_cr(\"Deoptimizing for patching flat field reference\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}