{"files":[{"patch":"@@ -313,0 +313,11 @@\n+\n+        if (!env.info.ctorPrologue &&\n+                v.owner.isValueClass() &&\n+                !env.info.instanceInitializerBlock && \/\/ it is OK instance initializer blocks will go after super() anyways\n+                v.owner.kind == TYP &&\n+                v.owner == env.enclClass.sym &&\n+                (v.flags() & STATIC) == 0 &&\n+                (base == null ||\n+                        TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))) {\n+            log.error(pos, Errors.CantRefAfterCtorCalled(v));\n+        }\n@@ -1428,1 +1439,5 @@\n-            if ((tree.flags & STATIC) != 0) localEnv.info.staticLevel++;\n+            if ((tree.flags & STATIC) != 0) {\n+                localEnv.info.staticLevel++;\n+            } else {\n+                localEnv.info.instanceInitializerBlock = true;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+    boolean instanceInitializerBlock = false;\n+\n@@ -152,0 +154,1 @@\n+        info.instanceInitializerBlock = instanceInitializerBlock;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2891,0 +2891,1 @@\n+            ListBuffer<JCStatement> initializers = new ListBuffer<>();\n@@ -2895,6 +2896,4 @@\n-                    tree.body.stats = tree.body.stats.append(\n-                            make.Exec(\n-                                    make.Assign(\n-                                            make.Select(make.This(field.owner.erasure(types)), field),\n-                                            make.Ident(param)).setType(field.erasure(types))));\n-                    \/\/ we don't need the flag at the field anymore\n+                    initializers.add(make.Exec(\n+                            make.Assign(\n+                                    make.Select(make.This(field.owner.erasure(types)), field),\n+                                    make.Ident(param)).setType(field.erasure(types))));\n@@ -2904,0 +2903,7 @@\n+            if (initializers.nonEmpty()) {\n+                if (tree.sym.owner.isValueClass()) {\n+                    TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.toList().append(supercall)));\n+                } else {\n+                    tree.body.stats = tree.body.stats.appendList(initializers);\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -777,1 +777,1 @@\n-        if (isExplicitThisReference(types, currentClassType, tree)) {\n+        if (TreeInfo.isExplicitThisReference(types, currentClassType, tree)) {\n@@ -1161,37 +1161,0 @@\n-    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n-     *  class currently being compiled. This is true if tree is:\n-     *  - An unqualified 'this' identifier\n-     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *    but also NOT an enclosing outer class of 'currentClass'.\n-     *\/\n-    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n-            case IDENT:\n-            {\n-                JCIdent ident = (JCIdent)tree;\n-                Names names = ident.name.table.names;\n-                return ident.name == names._this;\n-            }\n-            case SELECT:\n-            {\n-                JCFieldAccess select = (JCFieldAccess)tree;\n-                Type selectedType = types.erasure(select.selected.type);\n-                if (!selectedType.hasTag(CLASS))\n-                    return false;\n-                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n-                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n-                Names names = select.name.table.names;\n-                return currentClassSym.isSubClass(selectedClassSym, types) &&\n-                        (select.name == names._super ||\n-                        (select.name == names._this &&\n-                            (currentClassSym == selectedClassSym ||\n-                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n-            }\n-            default:\n-                return false;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -4068,0 +4068,4 @@\n+# 0: symbol or name\n+compiler.err.cant.ref.after.ctor.called=\\\n+    cannot reference {0} after supertype constructor has been called\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,35 @@\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+            case IDENT: {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this || ident.name == names._super;\n+            }\n+            case SELECT: {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(TypeTag.CLASS))\n+                    return false;\n+                Symbol.ClassSymbol currentClassSym = (Symbol.ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                Symbol.ClassSymbol selectedClassSym = (Symbol.ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                                (select.name == names._this &&\n+                                        (currentClassSym == selectedClassSym ||\n+                                                !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.cant.ref.after.ctor.called\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class V {\n+    int i;\n+    V(int i) {\n+        super();\n+        this.i = i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FieldAssigmentAfterSuper.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -488,11 +488,6 @@\n-        for (String source : List.of(\n-                \"\"\"\n-                value class Test {\n-                    int i = 100;\n-                }\n-                \"\"\",\n-                \"\"\"\n-                value class Test {\n-                    int i;\n-                    Test() {\n-                        i = 100;\n+        record Data(String src, boolean isRecord) {}\n+        for (Data data : List.of(\n+                new Data(\n+                    \"\"\"\n+                    value class Test {\n+                        int i = 100;\n@@ -500,8 +495,8 @@\n-                }\n-                \"\"\",\n-                \"\"\"\n-                value class Test {\n-                    int i;\n-                    Test() {\n-                        i = 100;\n-                        super();\n+                    \"\"\", false),\n+                new Data(\n+                    \"\"\"\n+                    value class Test {\n+                        int i;\n+                        Test() {\n+                            i = 100;\n+                        }\n@@ -509,8 +504,9 @@\n-                }\n-                \"\"\",\n-                \"\"\"\n-                value class Test {\n-                    int i;\n-                    Test() {\n-                        this.i = 100;\n-                        super();\n+                    \"\"\", false),\n+                new Data(\n+                    \"\"\"\n+                    value class Test {\n+                        int i;\n+                        Test() {\n+                            i = 100;\n+                            super();\n+                        }\n@@ -518,2 +514,15 @@\n-                }\n-                \"\"\"\n+                    \"\"\", false),\n+                new Data(\n+                    \"\"\"\n+                    value class Test {\n+                        int i;\n+                        Test() {\n+                            this.i = 100;\n+                            super();\n+                        }\n+                    }\n+                    \"\"\", false),\n+                new Data(\n+                    \"\"\"\n+                    value record Test(int i) {}\n+                    \"\"\", true)\n@@ -522,1 +531,2 @@\n-            File dir = assertOK(true, source);\n+            String expectedCodeSequenceRecord = \"aload_0,iload_1,putfield,aload_0,invokespecial,return,\";\n+            File dir = assertOK(true, data.src);\n@@ -532,1 +542,5 @@\n-                        Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                        if (!data.isRecord) {\n+                            Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                        } else {\n+                            Assert.check(expectedCodeSequenceRecord.equals(foundCodeSequence));\n+                        }\n@@ -574,0 +588,11 @@\n+        assertFail(\"compiler.err.cant.ref.after.ctor.called\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        super();\n+                        this.i = i;\n+                    }\n+                }\n+                \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":56,"deletions":31,"binary":false,"changes":87,"status":"modified"}]}