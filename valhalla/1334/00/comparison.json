{"files":[{"patch":"@@ -278,0 +278,11 @@\n+    \/\/ Writing null to a nullable flat field\/element is usually done by writing\n+    \/\/ the whole pre-allocated null_reset_value at the payload address to ensure\n+    \/\/ that the null marker and all potential oops are reset to \"zeros\".\n+    \/\/ However, the null_reset_value is allocated during class initialization.\n+    \/\/ If the current value of the field is null, it is possible that the class\n+    \/\/ of the field has not been initialized yet and thus the null_reset_value\n+    \/\/ might not be available yet.\n+    \/\/ Writing null over an already null value should not trigger class initialization.\n+    \/\/ The solution is to detect null being written over null cases and return immediately\n+    \/\/ (writing null over null is a no-op from a field modification point of view)\n+    if (is_payload_marked_as_null((address)dst)) return;\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -488,3 +488,0 @@\n-  if (!vk->is_implicitly_constructible()) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -393,0 +393,3 @@\n+  if (base == nullptr) {\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n+  }\n@@ -396,0 +399,9 @@\n+  LayoutKind lk = LayoutKind::UNKNOWN;\n+  if (base->is_array()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n+    lk = fak->layout_kind();\n+  } else {\n+    fieldDescriptor fd;\n+    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n+    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n+  }\n@@ -397,1 +409,1 @@\n-  oop v = vk->read_payload_from_addr(base_h(), offset, LayoutKind::PAYLOAD, CHECK_NULL);\/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n+  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n@@ -403,0 +415,3 @@\n+  if (base == nullptr) {\n+    THROW(vmSymbols::java_lang_NullPointerException());\n+  }\n@@ -407,0 +422,9 @@\n+  LayoutKind lk = LayoutKind::UNKNOWN;\n+  if (base->is_array()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n+    lk = fak->layout_kind();\n+  } else {\n+    fieldDescriptor fd;\n+    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n+    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n+  }\n@@ -408,2 +432,1 @@\n-  \/\/ TODO FIXME: problem below, with new APIs, null checking depends on LayoutKind, but Unsafe APIs are not able to communicate the right layout kind yet\n-  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, LayoutKind::PAYLOAD, true, CHECK);\/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n+  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @modules java.base\/jdk.internal.value\n@@ -37,1 +38,1 @@\n- * @run main\/othervm -XX:+NullableFieldFlattening -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 runtime.valhalla.inlinetypes.UnsafeTest\n+ * @run main\/othervm -XX:+NullableFieldFlattening -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 -XX:+PrintInlineLayout -XX:+NullableFieldFlattening runtime.valhalla.inlinetypes.UnsafeTest\n@@ -42,0 +43,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -107,12 +109,0 @@\n-        \/*\n-         * Layout of Value3\n-         *\n-         * | valueheader | o | i | x | y | array |\n-         *                       ^-------^\n-         *                        Point\n-         *                       ^---------------^\n-         *                        Value1\n-         *\n-         *                   ^-------------------^\n-         *                    Value2\n-         *\/\n@@ -203,0 +193,118 @@\n+    static value class TestValue1  {\n+        short s0,s1;\n+\n+        TestValue1() {\n+            s0 = 0;\n+            s1 = 0;\n+        }\n+\n+        TestValue1(short v0, short v1) {\n+            s0 = v0;\n+            s1 = v1;\n+        }\n+    }\n+\n+    static class Container1 {\n+        TestValue1 value;\n+    }\n+\n+    \/\/ Testing of nullable flat field supports in Unsafe.getValue()\/Unsafe.putValue()\n+    public static void testNullableFlatFields() throws Throwable {\n+        Container1 c = new Container1();\n+        Class<?> cc = Container1.class;\n+        Field field = cc.getDeclaredField(\"value\");\n+        Class<?> fc = TestValue1.class;\n+        long offset = U.objectFieldOffset(field);\n+        if (!U.isFlatField(field)) return; \/\/ Field not flattened (due to VM flags?), test doesn't apply\n+        \/\/ Initial value of the field must be null\n+        Asserts.assertNull(U.getValue(c, offset, fc));\n+        \/\/ Writing all zero value to the field, field must become non-null\n+        TestValue1 val0 = new TestValue1((short)0, (short)0);\n+        U.putValue(c, offset, fc, val0);\n+        TestValue1 rval = U.getValue(c, offset, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertEQ((short)0, rval.s0);\n+        Asserts.assertEQ((short)0, rval.s1);\n+        Asserts.assertEQ((short)0, c.value.s0);\n+        Asserts.assertEQ((short)0, c.value.s1);\n+        \/\/ Writing null to the field, field must become null again\n+        U.putValue(c, offset, fc, null);\n+        Asserts.assertNull(U.getValue(c, offset, fc));\n+        Asserts.assertNull(c.value);\n+        \/\/ Writing non zero value to the field\n+        TestValue1 val1 = new TestValue1((short)-1, (short)-2);\n+        U.putValue(c, offset, fc, val1);\n+        rval = U.getValue(c, offset, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertNotNull(c.value);\n+        Asserts.assertEQ((short)-1, rval.s0);\n+        Asserts.assertEQ((short)-2, rval.s1);\n+        Asserts.assertEQ((short)-1, c.value.s0);\n+        Asserts.assertEQ((short)-2, c.value.s1);\n+        \/\/ Writing a different non zero value\n+        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)3);\n+        U.putValue(c, offset, fc, val2);\n+        rval = U.getValue(c, offset, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertNotNull(c.value);\n+        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n+        Asserts.assertEQ((short)3, rval.s1);\n+        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n+        Asserts.assertEQ((short)3, rval.s1);\n+    }\n+\n+    \/\/ Testing of nullable flat arrays supports in Unsafe.getValue()\/Unsafe.putValue()\n+    public static void testNullableFlatArrays() throws Throwable {\n+        final int ARRAY_LENGTH = 10;\n+        TestValue1[] array = (TestValue1[])ValueClass.newNullableAtomicArray(TestValue1.class, ARRAY_LENGTH);\n+        long baseOffset = U.arrayBaseOffset(array.getClass());\n+        int scaleIndex = U.arrayIndexScale(array.getClass());\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n+        }\n+        TestValue1 val = new TestValue1((short)0, (short)0);\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 == 0) {\n+                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val );\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 == 0) {\n+                Asserts.assertNotNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n+                Asserts.assertNotNull(array[i]);\n+            } else {\n+                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n+                Asserts.assertNull(array[i]);\n+            }\n+        }\n+        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)Short.MIN_VALUE);\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 != 0) {\n+                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, val2 );\n+            } else {\n+                U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 != 0) {\n+                TestValue1 rval = U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class);\n+                Asserts.assertNotNull(rval);\n+                Asserts.assertEQ(val2.s0, rval.s0);\n+                Asserts.assertEQ(val2.s1, rval.s1);\n+                Asserts.assertNotNull(array[i]);\n+                Asserts.assertEQ(val2.s0, array[i].s0);\n+                Asserts.assertEQ(val2.s1, array[i].s1);\n+            } else {\n+                Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n+                Asserts.assertNull(array[i]);\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            U.putValue(array, baseOffset + i * scaleIndex, TestValue1.class, null );\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            Asserts.assertNull(U.getValue(array, baseOffset + i * scaleIndex, TestValue1.class));\n+            Asserts.assertNull(array[i]);\n+        }\n+    }\n+\n@@ -206,0 +314,2 @@\n+        testNullableFlatFields();\n+        testNullableFlatArrays();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":123,"deletions":13,"binary":false,"changes":136,"status":"modified"}]}