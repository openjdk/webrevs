{"files":[{"patch":"@@ -54,2 +54,2 @@\n-  if (subk->flat_in_array() && superk->not_flat_in_array()) {\n-    \/\/ The subtype is in flat arrays and the supertype is not in flat arrays. Must be unrelated.\n+  if (subk->flat_in_array() && superk->not_flat_in_array_inexact()) {\n+    \/\/ The subtype is in flat arrays and the supertype is not in flat arrays and no subklass can be. Must be unrelated.\n@@ -71,12 +71,10 @@\n-  if (subk != nullptr) {\n-    switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n-      case Compile::SSC_always_false:\n-        return TypeInt::CC_GT;\n-      case Compile::SSC_always_true:\n-        return TypeInt::CC_EQ;\n-      case Compile::SSC_easy_test:\n-      case Compile::SSC_full_test:\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n+  switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n+    case Compile::SSC_always_false:\n+      return TypeInt::CC_GT;\n+    case Compile::SSC_always_true:\n+      return TypeInt::CC_EQ;\n+    case Compile::SSC_easy_test:\n+    case Compile::SSC_full_test:\n+      break;\n+    default:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1021,5 +1021,8 @@\n-  \/\/      !(t meet this)  meet !t ==\n-  \/\/      (!t join !this) meet !t == !t\n-  \/\/ and\n-  \/\/      !(t meet this)  meet !this ==\n-  \/\/      (!t join !this) meet !this == !this\n+  \/\/ 1)     mt_dual meet t_dual    == t_dual\n+  \/\/    which corresponds to\n+  \/\/       !(t meet this)  meet !t ==\n+  \/\/       (!t join !this) meet !t == !t\n+  \/\/ 2)    mt_dual meet this_dual     == this_dual\n+  \/\/    which corresponds to\n+  \/\/       !(t meet this)  meet !this ==\n+  \/\/       (!t join !this) meet !this == !this\n@@ -1036,0 +1039,1 @@\n+    \/\/ 1)\n@@ -1037,0 +1041,1 @@\n+    \/\/ 2)\n@@ -4582,9 +4587,56 @@\n-  \/\/ Check for subtyping:\n-  \/\/ Flat in array matrix, yes = y, no = n, maybe = m, top\/empty = T:\n-  \/\/        yes maybe no   -> Super Klass\n-  \/\/   yes   y    y    y\n-  \/\/ maybe   y    m    m\n-  \/\/    no   T    n    n\n-  \/\/    |\n-  \/\/    v\n-  \/\/ Sub Klass\n+  \/\/ Flat in Array property _flat_in_array.\n+  \/\/ For simplicity, _flat_in_array is a boolean but we actually have a tri state:\n+  \/\/ - Flat in array       -> flat_in_array()\n+  \/\/ - Not flat in array   -> not_flat_in_array()\n+  \/\/ - Maybe flat in array -> !not_flat_in_array()\n+  \/\/\n+  \/\/ Maybe we should convert _flat_in_array to a proper lattice with four elements at some point:\n+  \/\/\n+  \/\/                  Top\n+  \/\/    Flat in Array     Not Flat in Array\n+  \/\/          Maybe Flat in Array\n+  \/\/\n+  \/\/ where\n+  \/\/     Top = dual(maybe Flat In Array) = \"Flat in Array AND Not Flat in Array\"\n+  \/\/\n+  \/\/ But for now we stick with the current model with _flat_in_array as a boolean.\n+  \/\/\n+  \/\/ When meeting two InstPtr types, we want to have the following behavior:\n+  \/\/\n+  \/\/ (FiA-M) Meet(this, other):\n+  \/\/     'this' and 'other' are either the same klass OR sub klasses:\n+  \/\/\n+  \/\/                yes maybe no\n+  \/\/           yes   y    m    m                      y = Flat in Array\n+  \/\/         maybe   m    m    m                      n = Not Flat in Array\n+  \/\/            no   m    m    n                      m = Maybe Flat in Array\n+  \/\/\n+  \/\/  Join(this, other):\n+  \/\/     (FiA-J-Same) 'this' and 'other' are the SAME klass:\n+  \/\/\n+  \/\/                yes maybe no                      E = Empty set\n+  \/\/           yes   y    y    E                      y = Flat in Array\n+  \/\/         maybe   y    m    m                      n = Not Flat in Array\n+  \/\/            no   E    m    n                      m = Maybe Flat in Array\n+  \/\/\n+  \/\/     (FiA-J-Sub) 'this' and 'other' are SUB klasses:\n+  \/\/\n+  \/\/               yes maybe no   -> Super Klass      E = Empty set\n+  \/\/          yes   y    y    y                       y = Flat in Array\n+  \/\/        maybe   y    m    m                       n = Not Flat in Array\n+  \/\/           no   E    m    n                       m = Maybe Flat in Array\n+  \/\/           |\n+  \/\/           v\n+  \/\/       Sub Klass\n+  \/\/\n+  \/\/     Note the difference when joining a super klass that is not flat in array with a sub klass that is compared to\n+  \/\/     the same klass case. We will take over the flat in array property of the sub klass. This can be done because\n+  \/\/     the super klass could be Object (i.e. not an inline type and thus not flat in array) while the sub klass is a\n+  \/\/     value class which can be flat in array.\n+  \/\/\n+  \/\/     The empty set is only a possible result when matching 'ptr' above the center line (i.e. joining). In this case,\n+  \/\/     we can \"fall hard\" by setting 'ptr' to NotNull such that when we take the dual of that meet above the center\n+  \/\/     line, we get an empty set again.\n+  \/\/\n+  \/\/     Note: When changing to a separate lattice with _flat_in_array we may want to add TypeInst(Klass)Ptr::empty()\n+  \/\/           that returns true when the meet result is FlatInArray::Top (i.e. dual(maybe flat in array)).\n@@ -4595,0 +4647,1 @@\n+  bool is_empty = false;\n@@ -4596,0 +4649,1 @@\n+    \/\/ Same klass\n@@ -4598,1 +4652,5 @@\n-    flat_in_array = below_centerline(ptr) ? (this_flat_in_array && other_flat_in_array) : (this_flat_in_array || other_flat_in_array);\n+    if (above_centerline(ptr)) {\n+      \/\/ Case (FiA-J-Same)\n+      \/\/ One is flat in array and the other not? Result is empty\/\"fall hard\".\n+      is_empty = (this_flat_in_array && other_not_flat_in_array) || (this_not_flat_in_array && other_flat_in_array);\n+    }\n@@ -4602,2 +4660,8 @@\n-    bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n-    flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n+    if (above_centerline(ptr)) {\n+      \/\/ Case (FiA-J-Sub)\n+      is_empty = this_not_flat_in_array && other_flat_in_array;\n+      if (!is_empty) {\n+        bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n+        flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n+      }\n+    }\n@@ -4607,2 +4671,8 @@\n-    bool this_flat_other_maybe_flat = this_flat_in_array && (!other_flat_in_array && !other_not_flat_in_array);\n-    flat_in_array = other_flat_in_array || this_flat_other_maybe_flat;\n+    if (above_centerline(ptr)) {\n+      \/\/ Case (FiA-J-Sub)\n+      is_empty = this_flat_in_array && other_not_flat_in_array;\n+      if (!is_empty) {\n+        bool this_flat_other_maybe_flat = this_flat_in_array && (!other_flat_in_array && !other_not_flat_in_array);\n+        flat_in_array = other_flat_in_array || this_flat_other_maybe_flat;\n+      }\n+    }\n@@ -4611,1 +4681,2 @@\n-  if (subtype) {\n+\n+  if (subtype && !is_empty) {\n@@ -4616,0 +4687,5 @@\n+      \/\/ Case (FiA-J-Sub)\n+      bool other_flat_this_maybe_flat = other_flat_in_array && (!this_flat_in_array && !this_not_flat_in_array);\n+      flat_in_array = this_flat_in_array || other_flat_this_maybe_flat;\n+      \/\/ One is flat in array and the other not? Result is empty\/\"fall hard\".\n+      is_empty = (this_flat_in_array && other_not_flat_in_array) || (this_not_flat_in_array && other_flat_in_array);\n@@ -4628,0 +4704,3 @@\n+      \/\/ Case (FiA-M)\n+      \/\/ Meeting two types below the center line: Only flat in array if both are.\n+      flat_in_array = this_flat_in_array && other_flat_in_array;\n@@ -4632,1 +4711,1 @@\n-  if (this_type->is_same_java_type_as(other_type)) {\n+  if (this_type->is_same_java_type_as(other_type) && !is_empty) {\n@@ -4638,1 +4717,1 @@\n-    res_flat_in_array = subtype ? flat_in_array : this_flat_in_array;\n+    res_flat_in_array = flat_in_array;\n@@ -6121,0 +6200,4 @@\n+\n+  if (flat_in_array() && !klass()->is_inlinetype()) {\n+    st->print(\" (flat in array)\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":105,"deletions":22,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -1702,0 +1702,5 @@\n+\n+  virtual bool not_flat_in_array_inexact() const {\n+    return true;\n+  }\n+\n@@ -1786,1 +1791,17 @@\n-  virtual bool not_flat_in_array() const { return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flat_in_array()); }\n+\n+  \/\/ Checks if this klass pointer is not flat in array by also considering exactness information.\n+  virtual bool not_flat_in_array() const {\n+    return !_klass->can_be_inline_klass(klass_is_exact()) || (_klass->is_inlinetype() && !flat_in_array());\n+  }\n+\n+  \/\/ not_flat_in_array() version that assumes that the klass is inexact. This is used for sub type checks where the\n+  \/\/ super klass is always an exact klass constant (and thus possibly known to be not flat in array), while a sub\n+  \/\/ klass could very well be flat in array:\n+  \/\/\n+  \/\/           MyValue       <:       Object\n+  \/\/        flat in array       not flat in array\n+  \/\/\n+  \/\/ Thus, this version checks if we know that the klass is not flat in array even if it's not exact.\n+  virtual bool not_flat_in_array_inexact() const {\n+    return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flat_in_array());\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+  var original_type = type;\n@@ -43,0 +44,4 @@\n+  if (original_type.indexOf(\"(flat in array)\") !== -1) {\n+    \/\/ Always append \"flat in array\" property last if found in original type.\n+    type += \" (flat in array)\";\n+  }\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/showTypes.filter","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8321734\n+ * @bug 8321734 8348961\n@@ -40,1 +40,1 @@\n- * @bug 8321734\n+ * @bug 8321734 8348961\n@@ -62,0 +62,9 @@\n+    static Object[] oArrSmall = new Object[2];\n+    static Object[] vArr = new V[2];\n+    static {\n+        oArrSmall[0] = new Object();\n+        oArrSmall[1] = new Object();\n+        vArr[0] = new V();\n+        vArr[1] = new V();\n+    }\n+    static int limit = 2;\n@@ -92,0 +101,2 @@\n+        Scenario noMethodTraps = new Scenario(5, \"-XX:PerMethodTrapLimit=0\", \"-Xbatch\");\n+        testFramework.addScenarios(noMethodTraps);\n@@ -185,0 +196,35 @@\n+    @Test\n+    @Warmup(10000)\n+    static void testJoinSameKlassDifferentFlatInArray() {\n+        \/\/ Accessing the array: It could be a flat array. We therefore add a Phi to select from the normal vs.\n+        \/\/ flat in array access:\n+        \/\/     Phi(Object:flat_in_array, Object) -> CheckCastPP[Object:NotNull:exact]\n+        for (Object o : oArrSmall) {\n+            \/\/ We speculate that we always call Object::hashCode() and thus add a CheckCastPP[Object:NotNull:exact]\n+            \/\/ together with a speculate_class_check trap on the failing path.\n+            \/\/ We decide to unswitch the loop to get a loop version where we only have flat in array accesses. This\n+            \/\/ means we can get rid of the Phi. During IGVN and folding some nodes we eventually end up with:\n+            \/\/    CheckCastPP[Object:NotNull (flat_in_array)] -> CheckCastPP[Object:NotNull:exact]\n+            \/\/\n+            \/\/ We know that we have some kind of Value class that needs to be joined with an exact Object that is not\n+            \/\/ a value class. Thus, the result in an empty set. But this is missing in the type system. We fail with\n+            \/\/ an assertion. This is fixed with 8348961.\n+            \/\/\n+            \/\/ To make this type system change work, we require that the TypeInstKlassPtr::not_flat_in_array() takes\n+            \/\/ exactness information into account to also fold the corresponding control path. This requires another\n+            \/\/ follow up fix: The super class of a sub type check is always an exact class, i.e. \"o instanceof Super\".\n+            \/\/ We need a version of TypeInstKlassPtr::not_flat_in_array() that treats \"Super\" as inexact. Failing to do\n+            \/\/ so will erroneously fold a sub type check away (covered by testSubTypeCheckForObjectReceiver()).\n+            o.hashCode();\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    static void testSubTypeCheckForObjectReceiver() {\n+        for (int i = 0; i < limit; i++) {\n+            \/\/ We perform a sub type check that V is a sub type of Object. This is obviously true\n+            vArr[i].hashCode();\n+        }\n+    }\n+\n@@ -239,0 +285,2 @@\n+\n+    static value class V {}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"}]}