{"files":[{"patch":"@@ -106,5 +106,0 @@\n-\/\/ Offset of the default oop in the mirror\n-int ciInlineKlass::default_value_offset() const {\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->default_value_offset();)\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  int default_value_offset() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -178,3 +178,1 @@\n-  \/\/ TODO 8325106 Fix comment\n-  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n-  if (!is_loaded() || element_klass()->is_inlinetype()) {\n+  if (!is_loaded()) {\n@@ -186,0 +184,5 @@\n+    \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+    \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n+    if (ik->is_inlinetype() && !is_elem_null_free()) {\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -327,2 +327,0 @@\n-      bool null_free = k1->as_array_klass()->is_elem_null_free() &&\n-                       k2->as_array_klass()->is_elem_null_free();\n@@ -337,1 +335,1 @@\n-        assert(k1 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        assert(k1 == ciArrayKlass::make(elem), \"shortcut is OK\");\n@@ -340,1 +338,1 @@\n-        assert(k2 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n+        assert(k2 == ciArrayKlass::make(elem), \"shortcut is OK\");\n@@ -343,2 +341,0 @@\n-        \/\/ TODO 8325106 Remove\n-        assert(!null_free, \"should be dead\");\n@@ -607,6 +603,1 @@\n-    if (array_klass->is_elem_null_free()) {\n-      \/\/ TODO 8325106 Is this dead?\n-      push(outer()->mark_as_null_free(element_klass));\n-    } else {\n-      push_object(element_klass);\n-    }\n+    push_object(element_klass);\n@@ -637,6 +628,1 @@\n-    if (klass->is_inlinetype() && type->is_null_free()) {\n-      \/\/ TODO 8325106 Is this dead?\n-      push(outer()->mark_as_null_free(klass));\n-    } else {\n-      push_object(klass);\n-    }\n+    push_object(klass);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-    \/\/ TODO 8325106 Ignore flat \/ null-free arrays\n+    \/\/ TODO 8336006 Ignore flat \/ null-free arrays\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1107,3 +1107,0 @@\n-private:\n-  bool _null_free;\n-\n@@ -1122,1 +1119,0 @@\n-    _null_free = false;\n@@ -1143,3 +1139,0 @@\n-\n-  void set_null_free() { _null_free = true; }\n-  bool is_null_free() const { return _null_free; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-    \/\/ TODO 8325106 Can we avoid cloning?\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2075,1 +2075,1 @@\n-      \/\/ TODO 8325106 Can we avoid cloning?\n+      \/\/ TODO 8302217 Can we avoid cloning? See InlineTypeNode::clone_if_required\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,1 +2024,3 @@\n-    _inline_type_nodes.at(i)->as_InlineType()->make_scalar_in_safepoints(&igvn);\n+    InlineTypeNode* vt = _inline_type_nodes.at(i)->as_InlineType();\n+    vt->make_scalar_in_safepoints(&igvn);\n+    igvn.record_for_igvn(vt);\n@@ -4987,4 +4989,2 @@\n-    \/\/ TODO 8325106 Fix comment\n-    \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n-    \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n-    \/\/ the klass for [LMyValue. Perform a full test.\n+    \/\/ Do not fold the subtype check to an array klass pointer comparison for null-able inline type arrays\n+    \/\/ because null-free [LMyValue <: null-able [LMyValue but the klasses are different. Perform a full test.\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -585,2 +585,0 @@\n-    \/\/ TODO 8325106 re-enable the assert and add the same check for the receiver in the caller map\n-    \/\/assert(receiver->is_larval(), \"must be larval\");\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1489,2 +1489,1 @@\n-    \/\/ TODO 8325106 Can we avoid cloning?\n-    Node* vt = obj->clone();\n+    Node* vt = obj->isa_InlineType()->clone_if_required(&gvn(), map(), do_replace_in_map);\n@@ -3967,2 +3966,1 @@\n-      \/\/ TODO 8325106 Fix comment\n-      \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue. Don't constant fold.\n+      \/\/ Don't constant fold if the runtime type might be a flat array but the static type is not.\n@@ -4370,1 +4368,0 @@\n-  \/\/ TODO 8325106 Fix comment\n@@ -4372,3 +4369,3 @@\n-  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue\")\n-  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue\")\n-  \/\/ - null-free, flat     : MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n+  \/\/ - null-ok:         ciObjArrayKlass  with is_elem_null_free() = false\n+  \/\/ - null-free:       ciObjArrayKlass  with is_elem_null_free() = true\n+  \/\/ - null-free, flat: ciFlatArrayKlass with is_elem_null_free() = true\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -280,1 +280,2 @@\n-  if (!igvn->type(get_is_init())->is_int()->is_con(1)) {\n+  const TypeInt* tinit = igvn->type(get_is_init())->isa_int();\n+  if (tinit != nullptr && !tinit->is_con(1)) {\n@@ -311,3 +312,0 @@\n-  \/\/ TODO 8325106\n-  \/\/ TestBasicFunctionality::test3 fails without this. Add more tests?\n-  \/\/ Add proj nodes here? Recursive handling of phis required? We need a test that fails without.\n@@ -327,2 +325,0 @@\n-        \/\/ TestNullableArrays.test123 fails when enabling this, probably we should make sure that we don't load from a just allocated object\n-        \/\/} else if (!(in->is_Con() || in->is_Parm() || in->is_Load() || (in->isa_DecodeN() && in->in(1)->is_Load()))) {\n@@ -378,1 +374,1 @@\n-    igvn->_worklist.push(this);\n+    igvn->record_for_igvn(this);\n@@ -508,1 +504,1 @@\n-  store(kit, base, ptr, holder, holder_offset, decorators);\n+  store(kit, base, ptr, holder, holder_offset, -1, decorators);\n@@ -511,1 +507,1 @@\n-void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, int offsetOnly) const {\n+void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, int offsetOnly, DecoratorSet decorators) const {\n@@ -540,7 +536,0 @@\n-  \/\/ TODO 8325106\n-  \/*\n-  if (inline_klass()->is_initialized() && inline_klass()->is_empty()) {\n-    assert(false, \"Should not buffer empty inline klass\");\n-  }\n-  *\/\n-\n@@ -582,2 +571,0 @@\n-  int bci = kit->bci();\n-  bool reexecute = kit->jvms()->should_reexecute();\n@@ -586,2 +573,0 @@\n-\n-    \/\/ Allocate and initialize buffer\n@@ -589,6 +574,0 @@\n-    \/\/ Propagate re-execution state and bci\n-    kit->set_bci(bci);\n-    kit->jvms()->set_bci(bci);\n-    kit->jvms()->set_should_reexecute(reexecute);\n-\n-    kit->kill_dead_locals();\n@@ -596,13 +575,22 @@\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n-    \/\/ No need to initialize a larval buffer, we make sure that the oop can not escape\n-    if (!is_larval()) {\n-      \/\/ Larval will be initialized later\n-      \/\/ TODO 8325106 should this use C2_TIGHTLY_COUPLED_ALLOC?\n-      store(kit, alloc_oop, alloc_oop, vk);\n-\n-      \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-      \/\/ store that would make this buffer accessible by other threads.\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-      assert(alloc != nullptr, \"must have an allocation node\");\n-      kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+    if (vk->is_initialized() && (vk->is_empty() || (is_default(&kit->gvn()) && !is_larval(&kit->gvn()) && !is_larval()))) {\n+      \/\/ Don't buffer an empty or default inline type, use the default oop instead\n+      oop->init_req(3, default_oop(kit->gvn(), vk));\n+    } else {\n+      \/\/ Allocate and initialize buffer, re-execute on deoptimization.\n+      kit->jvms()->set_bci(kit->bci());\n+      kit->jvms()->set_should_reexecute(true);\n+      kit->kill_dead_locals();\n+      Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+      Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n+      \/\/ No need to initialize a larval buffer, we make sure that the oop can not escape\n+      if (!is_larval()) {\n+        \/\/ Larval will be initialized later\n+        store(kit, alloc_oop, alloc_oop, vk);\n+\n+        \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+        \/\/ store that would make this buffer accessible by other threads.\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+        assert(alloc != nullptr, \"must have an allocation node\");\n+        kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+      }\n+      oop->init_req(3, alloc_oop);\n@@ -610,1 +598,0 @@\n-\n@@ -612,1 +599,0 @@\n-    oop   ->init_req(3, alloc_oop);\n@@ -733,4 +719,3 @@\n-  const Type* tinit = phase->type(get_is_init());\n-  if (!is_larval(phase) && !is_larval() &&\n-      (tinit->isa_int() && tinit->is_int()->is_con(1)) &&\n-      (is_default(phase) || inline_klass()->is_empty()) &&\n+  const TypeInt* tinit = phase->type(get_is_init())->isa_int();\n+  if ((tinit != nullptr && tinit->is_con(1)) &&\n+      ((is_default(phase) && !is_larval(phase) && !is_larval()) || inline_klass()->is_empty()) &&\n@@ -754,10 +739,7 @@\n-  \/\/ TODO 8325106 Re-evaluate this: We prefer a \"loaded\" oop because it's free. The existing oop might come from a buffering.\n-  if (!is_larval(phase) && !is_larval()) {\n-    \/\/ Save base oop if fields are loaded from memory and the inline\n-    \/\/ type is not buffered (in this case we should not use the oop).\n-    Node* base = is_loaded(phase);\n-    if (base != nullptr && get_oop() != base && !phase->type(base)->maybe_null()) {\n-      set_oop(*phase, base);\n-      assert(is_allocated(phase), \"should now be allocated\");\n-      return this;\n-    }\n+\n+  \/\/ Use base oop if fields are loaded from memory\n+  Node* base = is_loaded(phase);\n+  if (base != nullptr && get_oop() != base && !phase->type(base)->maybe_null()) {\n+    set_oop(*phase, base);\n+    assert(is_allocated(phase), \"should now be allocated\");\n+    return this;\n@@ -844,2 +826,2 @@\n-  const Type* tinit = gvn->type(get_is_init());\n-  if (!tinit->isa_int() || !tinit->is_int()->is_con(1)) {\n+  const TypeInt* tinit = gvn->type(get_is_init())->isa_int();\n+  if (tinit == nullptr || !tinit->is_con(1)) {\n@@ -858,2 +840,2 @@\n-      const Type* tinit = gvn->type(value->as_InlineType()->get_is_init());\n-      if (tinit->isa_int() && tinit->is_int()->is_con(0)) {\n+      tinit = gvn->type(value->as_InlineType()->get_is_init())->isa_int();\n+      if (tinit != nullptr && tinit->is_con(0)) {\n@@ -890,1 +872,1 @@\n-    \/\/ TODO 8325106 Re-enable assert and fix OSR code\n+    \/\/ TODO 8335256 Re-enable assert and fix OSR code\n@@ -1050,0 +1032,3 @@\n+  if (is_larval() || is_larval(phase)) {\n+    return nullptr;\n+  }\n@@ -1054,3 +1039,2 @@\n-    const Type* tinit = phase->type(in(IsInit));\n-    \/\/ TODO 8325106\n-    if (false && !is_larval() && tinit->isa_int() && tinit->is_int()->is_con(1)) {\n+    const TypeInt* tinit = phase->type(get_is_init())->isa_int();\n+    if (tinit != nullptr && tinit->is_con(1)) {\n@@ -1255,2 +1239,1 @@\n-      \/\/ TODO 8325106\n-      \/\/ assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n+      assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":48,"deletions":65,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -57,2 +58,2 @@\n-  \/\/ TODO 8325106 why can't we gvn larvals?\n-  virtual bool cmp(const Node &n) const { return TypeNode::cmp(n) && !((InlineTypeNode&)n)._is_larval && !_is_larval; }\n+  \/\/ Don't GVN larvals because the inputs might be updated\n+  virtual bool cmp(const Node &n) const { return TypeNode::cmp(n) && !(n.isa_InlineType()->_is_larval || _is_larval); }\n@@ -137,1 +138,1 @@\n-  void store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  void store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const;\n@@ -139,1 +140,1 @@\n-  void store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED, int offset = -1) const;\n+  void store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset = 0, int offset = -1, DecoratorSet decorators = C2_TIGHTLY_COUPLED_ALLOC | IN_HEAP | MO_UNORDERED) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4406,2 +4406,0 @@\n-          AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj);\n-          alloc->set_null_free();\n@@ -4830,0 +4828,2 @@\n+  \/\/ Don't intrinsify hashcode on inline types for now.\n+  \/\/ The \"is locked\" runtime check below also serves as inline type check and goes to the slow path.\n@@ -5267,1 +5267,0 @@\n-\/\/ TODO 8325106 Remove this and corresponding tests. Flatness is not a property of the Class anymore with JEP 401.\n@@ -5594,2 +5593,2 @@\n-  \/\/ TODO 8325106 why can't we check via the type of the const klass node?\n-  if (alloc->is_null_free()) {\n+  const TypeAryKlassPtr* ary_klass_ptr = alloc->in(AllocateNode::KlassNode)->bottom_type()->is_aryklassptr();\n+  if (ary_klass_ptr->is_null_free()) {\n@@ -5599,1 +5598,1 @@\n-    ciArrayKlass* klass = alloc->in(AllocateNode::KlassNode)->bottom_type()->is_aryklassptr()->exact_klass()->as_array_klass();\n+    ciArrayKlass* klass = ary_klass_ptr->exact_klass()->as_array_klass();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -693,5 +693,1 @@\n-          if (res->is_Phi() && res->as_Phi()->can_be_inline_type()) {\n-            \/\/ Can only eliminate allocation if the phi had been replaced by an InlineTypeNode before which did not happen.\n-            \/\/ TODO 8325106 Why wasn't it replaced by an InlineTypeNode?\n-            can_eliminate = false;\n-          }\n+          assert(!res->is_Phi() || !res->as_Phi()->can_be_inline_type(), \"Inline type allocations should not have safepoint uses\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,2 +248,1 @@\n-      \/\/ TODO 8325106\n-      \/\/ assert(phase->C->get_alias_index(t) == phase->C->get_alias_index(t_adr), \"correct memory chain\");\n+      assert(phase->C->get_alias_index(t) == phase->C->get_alias_index(t_adr), \"correct memory chain\");\n@@ -2104,32 +2103,15 @@\n-  } else if (tp->base() == Type::RawPtr && !StressReflectiveCode) {\n-    if (adr->is_Load() && off == 0) {\n-      \/* With mirrors being an indirect in the Klass*\n-       * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n-       * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n-       *\n-       * So check the type and klass of the node before the LoadP.\n-       *\/\n-      Node* adr2 = adr->in(MemNode::Address);\n-      const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n-      if (tkls != nullptr) {\n-        if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n-          ciKlass* klass = tkls->exact_klass();\n-          assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-          assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n-          return TypeInstPtr::make(klass->java_mirror());\n-        }\n-      }\n-    } else {\n-      \/\/ Check for a load of the default value offset from the InlineKlassFixedBlock:\n-      \/\/ LoadI(LoadP(inline_klass, adr_inlineklass_fixed_block_offset), default_value_offset_offset)\n-      \/\/ TODO 8325106 remove?\n-      intptr_t offset = 0;\n-      Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);\n-      if (base != nullptr && base->is_Load() && offset == in_bytes(InlineKlass::default_value_offset_offset())) {\n-        const TypeKlassPtr* tkls = phase->type(base->in(MemNode::Address))->isa_klassptr();\n-        if (tkls != nullptr && tkls->is_loaded() && tkls->klass_is_exact() && tkls->exact_klass()->is_inlinetype() &&\n-            tkls->offset() == in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())) {\n-          assert(base->Opcode() == Op_LoadP, \"must load an oop from klass\");\n-          assert(Opcode() == Op_LoadI, \"must load an int from fixed block\");\n-          return TypeInt::make(tkls->exact_klass()->as_inline_klass()->default_value_offset());\n-        }\n+  } else if (tp->base() == Type::RawPtr && adr->is_Load() && off == 0) {\n+    \/* With mirrors being an indirect in the Klass*\n+     * the VM is now using two loads. LoadKlass(LoadP(LoadP(Klass, mirror_offset), zero_offset))\n+     * The LoadP from the Klass has a RawPtr type (see LibraryCallKit::load_mirror_from_klass).\n+     *\n+     * So check the type and klass of the node before the LoadP.\n+     *\/\n+    Node* adr2 = adr->in(MemNode::Address);\n+    const TypeKlassPtr* tkls = phase->type(adr2)->isa_klassptr();\n+    if (tkls != nullptr && !StressReflectiveCode) {\n+      if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n+        ciKlass* klass = tkls->exact_klass();\n+        assert(adr->Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+        assert(Opcode() == Op_LoadP, \"must load an oop from _java_mirror\");\n+        return TypeInstPtr::make(klass->java_mirror());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":16,"deletions":34,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -559,0 +559,1 @@\n+  void set_inline_type_field(Node* obj, ciField* field, Node* val);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-      \/\/ TODO 8325106 Dead code?\n@@ -628,2 +627,1 @@\n-      \/\/ TODO 8325106 Shouldn't we use replace_in_map here?\n-      set_local(i, cast);\n+      replace_in_map(parm, cast);\n@@ -2205,1 +2203,0 @@\n-    \/\/ TODO 8325106 Why can't we pass map here?\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -252,67 +252,0 @@\n-  if (obj->is_InlineType()) {\n-    \/\/ TODO 8325106 Factor into own method\n-    \/\/ TODO 8325106 Assert that we only do this in the constructor and align with checks in ::do_call\n-    \/\/if (_method->is_object_constructor() && _method->holder()->is_inlinetype()) {\n-    assert(obj->as_InlineType()->is_larval(), \"must be larval\");\n-\n-    \/\/ TODO 8325106 Assert that holder is null-free\n-    \/*\n-    int holder_depth = field->type()->size();\n-    null_check(peek(holder_depth));\n-    if (stopped()) {\n-      return;\n-    }\n-    *\/\n-\n-    if (field->is_null_free()) {\n-      PreserveReexecuteState preexecs(this);\n-      jvms()->set_should_reexecute(true);\n-      inc_sp(1);\n-      val = null_check(val);\n-      if (stopped()) {\n-        return;\n-      }\n-    }\n-    if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n-      \/\/ Scalarize inline type field value\n-      val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n-    } else if (val->is_InlineType() && !field->is_flat()) {\n-      \/\/ Field value needs to be allocated because it can be merged with an oop.\n-      \/\/ Re-execute if buffering triggers deoptimization.\n-      PreserveReexecuteState preexecs(this);\n-      jvms()->set_should_reexecute(true);\n-      inc_sp(1);\n-      val = val->as_InlineType()->buffer(this);\n-    }\n-\n-    \/\/ Clone the inline type node and set the new field value\n-    InlineTypeNode* new_vt = obj->as_InlineType()->clone_if_required(&_gvn, _map);\n-    new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n-    {\n-      PreserveReexecuteState preexecs(this);\n-      jvms()->set_should_reexecute(true);\n-      inc_sp(1);\n-      new_vt = new_vt->adjust_scalarization_depth(this);\n-    }\n-\n-    \/\/ TODO 8325106 Double check and explain these checks\n-    if ((!_caller->has_method() || C->inlining_incrementally() || _caller->method()->is_object_constructor()) && new_vt->is_allocated(&gvn())) {\n-      assert(new_vt->as_InlineType()->is_allocated(&gvn()), \"must be buffered\");\n-      \/\/ We need to store to the buffer\n-      \/\/ TODO 8325106 looks like G1BarrierSetC2::g1_can_remove_pre_barrier is not strong enough to remove the pre barrier\n-      \/\/ TODO is it really guaranteed that the preval is null?\n-      new_vt->store(this, new_vt->get_oop(), new_vt->get_oop(), new_vt->bottom_type()->inline_klass(), 0, C2_TIGHTLY_COUPLED_ALLOC | IN_HEAP | MO_UNORDERED, field->offset_in_bytes());\n-\n-      \/\/ Preserve allocation ptr to create precedent edge to it in membar\n-      \/\/ generated on exit from constructor.\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(new_vt->get_oop());\n-      if (alloc != nullptr) {\n-        set_alloc_with_final(new_vt->get_oop());\n-      }\n-      set_wrote_final(true);\n-    }\n-\n-    replace_in_map(obj, _gvn.transform(new_vt));\n-    return;\n-  }\n-\n@@ -321,1 +254,0 @@\n-    inc_sp(1);\n@@ -323,0 +255,1 @@\n+    inc_sp(1);\n@@ -324,0 +257,7 @@\n+    if (stopped()) {\n+      return;\n+    }\n+  }\n+  if (obj->is_InlineType()) {\n+    set_inline_type_field(obj, field, val);\n+    return;\n@@ -334,1 +274,1 @@\n-    val->as_InlineType()->store_flat(this, obj, obj, field->holder(), offset);\n+    val->as_InlineType()->store_flat(this, obj, obj, field->holder(), offset, IN_HEAP | MO_UNORDERED);\n@@ -386,0 +326,40 @@\n+void Parse::set_inline_type_field(Node* obj, ciField* field, Node* val) {\n+  assert(_method->is_object_constructor(), \"inline type is initialized outside of constructor\");\n+  assert(obj->as_InlineType()->is_larval(), \"must be larval\");\n+  assert(!_gvn.type(obj)->maybe_null(), \"should never be null\");\n+\n+  \/\/ Re-execute if buffering in below code triggers deoptimization.\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+  inc_sp(1);\n+\n+  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n+    \/\/ Scalarize inline type field value\n+    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n+  } else if (val->is_InlineType() && !field->is_flat()) {\n+    \/\/ Field value needs to be allocated because it can be merged with a non-inline type.\n+    val = val->as_InlineType()->buffer(this);\n+  }\n+\n+  \/\/ Clone the inline type node and set the new field value\n+  InlineTypeNode* new_vt = obj->as_InlineType()->clone_if_required(&_gvn, _map);\n+  new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+  new_vt = new_vt->adjust_scalarization_depth(this);\n+\n+  \/\/ If the inline type is buffered and the caller might use the buffer, update it.\n+  if (new_vt->is_allocated(&gvn()) && (!_caller->has_method() || C->inlining_incrementally() || _caller->method()->is_object_constructor())) {\n+    new_vt->store(this, new_vt->get_oop(), new_vt->get_oop(), new_vt->bottom_type()->inline_klass(), 0, field->offset_in_bytes());\n+\n+    \/\/ Preserve allocation ptr to create precedent edge to it in membar\n+    \/\/ generated on exit from constructor.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(new_vt->get_oop());\n+    if (alloc != nullptr) {\n+      set_alloc_with_final(new_vt->get_oop());\n+    }\n+    set_wrote_final(true);\n+  }\n+\n+  replace_in_map(obj, _gvn.transform(new_vt));\n+  return;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":49,"deletions":69,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -1514,1 +1514,0 @@\n-  \/\/ TODO 8325106 Improve this to handle all patterns\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1146,1 +1146,0 @@\n-  \/\/ TODO 8325106 Handle null free arrays here?\n@@ -1236,4 +1235,2 @@\n-  \/\/ TODO 8325106 Fix comment\n-  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n-  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n-  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for null-able inline type arrays\n+  \/\/ because null-free [LMyValue <: null-able [LMyValue but the klasses are different. Perform a full test.\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -135,2 +135,1 @@\n-  \/\/ TODO 8325106\n-  \/\/ assert(verify(phase), \"missing Value() optimization\");\n+  assert(verify(phase), \"missing Value() optimization\");\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2193,1 +2193,0 @@\n-    \/\/ TODO 8325106 The field could be null free, right? Shouldn't we set the type to null-free here?\n@@ -2592,2 +2591,1 @@\n-      \/\/ TODO 8325106 Fix comment\n-      \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+      \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n@@ -3679,15 +3677,8 @@\n-            \/\/ TODO 8325106 remove?\n-            if (k->is_inlinetype() && this->offset() == k->as_inline_klass()->default_value_offset()) {\n-              \/\/ Special hidden field that contains the oop of the default inline type\n-              \/\/ basic_elem_type = T_PRIMITIVE_OBJECT;\n-             _is_ptr_to_narrowoop = UseCompressedOops;\n-            } else {\n-              field = k->get_field_by_offset(this->offset(), true);\n-              if (field != nullptr) {\n-                BasicType basic_elem_type = field->layout_type();\n-                _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n-              } else {\n-                \/\/ unsafe access\n-                _is_ptr_to_narrowoop = UseCompressedOops;\n-              }\n-            }\n+            field = k->get_field_by_offset(this->offset(), true);\n+          }\n+          if (field != nullptr) {\n+            BasicType basic_elem_type = field->layout_type();\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n+          } else {\n+            \/\/ unsafe access\n+            _is_ptr_to_narrowoop = UseCompressedOops;\n@@ -3882,3 +3873,1 @@\n-\n-    \/\/ TODO 8325106 Fix comment\n-    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n@@ -5418,2 +5407,2 @@\n-        \/\/ TODO 8325106 Fix comment\n-        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+        \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n@@ -5437,2 +5426,2 @@\n-        \/\/ TODO 8325106 Fix comment\n-        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+        \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n@@ -5976,3 +5965,3 @@\n-        \/\/ TODO 8325106 Fix comment\n-        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n-        (is_null_free() || is_flat() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n+        \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n+        (is_null_free() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n@@ -6494,5 +6483,0 @@\n-    \/\/ TODO 8325106 Fix comment\n-    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n-    if (etype->klass_is_exact() && etype->isa_instklassptr() && etype->is_instklassptr()->klass()->is_inlinetype() && !null_free) {\n-      etype = TypeInstKlassPtr::make(NotNull, etype->is_instklassptr()->klass(), Offset(etype->is_instklassptr()->offset()));\n-    }\n@@ -6656,2 +6640,2 @@\n-  \/\/ TODO 8325106 Fix comment\n-  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+  \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+  \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n@@ -6681,1 +6665,0 @@\n-      \/\/ TODO 8325106 Still correct?\n@@ -6896,2 +6879,1 @@\n-      \/\/ TODO 8325106 Fix comment\n-      return false; \/\/ [LMyValue is not a subtype of [QMyValue\n+      return false; \/\/ A nullable array can't be a subtype of a null-free array\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":20,"deletions":38,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -771,1 +771,0 @@\n-  \/\/ TODO 8325106 Remove the last occurences of T_PRIMITIVE_OBJECT\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4146,1 +4146,1 @@\n-\/\/ TODO 8325106 This triggers #  assert(false) failed: Should have been buffered\n+\/\/ TODO 8336003 This triggers #  assert(false) failed: Should have been buffered\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}