{"files":[{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"ci\/ciSymbol.hpp\"\n@@ -33,0 +36,1 @@\n+#include \"jvm_io.h\"\n@@ -38,0 +42,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -221,18 +226,47 @@\n-ciField::ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) {\n-  assert(field->holder()->is_inlinetype() || field->holder()->is_abstract(), \"should only be used for inline type field flattening\");\n-  \/\/ Set the is_final flag\n-  jint final = is_final ? JVM_ACC_FINAL : ~JVM_ACC_FINAL;\n-  AccessFlags flags(field->flags().as_int() & final);\n-  _flags = ciFlags(flags);\n-  _holder = holder;\n-  _offset = offset;\n-  \/\/ Copy remaining fields\n-  _name = field->_name;\n-  _signature = field->_signature;\n-  _type = field->_type;\n-  \/\/ Trust final flat fields\n-  _is_constant = is_final;\n-  _known_to_link_with_put = field->_known_to_link_with_put;\n-  _known_to_link_with_get = field->_known_to_link_with_get;\n-  _constant_value = field->_constant_value;\n-  assert(!field->is_flat(), \"field must not be flat\");\n+ciField::ciField(ciField* declared_field, ciField* subfield) {\n+  assert(subfield->holder()->is_inlinetype() || subfield->holder()->is_abstract(), \"should only be used for inline type field flattening\");\n+  assert(!subfield->is_flat(), \"subfield must not be flat\");\n+  assert(declared_field->is_flat(), \"declared field must be flat\");\n+\n+  _flags = declared_field->flags();\n+  _holder = declared_field->holder();\n+  _offset = declared_field->offset_in_bytes() + (subfield->offset_in_bytes() - declared_field->type()->as_inline_klass()->payload_offset());\n+\n+  char buffer[256];\n+  jio_snprintf(buffer, sizeof(buffer), \"%s.%s\", declared_field->name()->as_utf8(), subfield->name()->as_utf8());\n+  _name = ciSymbol::make(buffer);\n+\n+  _signature = subfield->_signature;\n+  _type = subfield->_type;\n+  _is_constant = false;\n+  _known_to_link_with_put = subfield->_known_to_link_with_put;\n+  _known_to_link_with_get = subfield->_known_to_link_with_get;\n+  _constant_value = ciConstant();\n+\n+  _is_flat = false;\n+  _is_null_free = false;\n+  _null_marker_offset = -1;\n+  _original_holder = (subfield->_original_holder != nullptr) ? subfield->_original_holder : subfield->_holder;\n+}\n+\n+\/\/ Constructor for the ciField of a null marker\n+ciField::ciField(ciField* declared_field) {\n+  assert(declared_field->is_flat(), \"declared field must be flat\");\n+  assert(!declared_field->is_null_free(), \"must have a null marker\");\n+\n+  _flags = declared_field->flags();\n+  _holder = declared_field->holder();\n+  _offset = declared_field->null_marker_offset();\n+\n+  char buffer[256];\n+  jio_snprintf(buffer, sizeof(buffer), \"%s.$nullMarker$\", declared_field->name()->as_utf8());\n+  _name = ciSymbol::make(buffer);\n+\n+  _signature = ciSymbols::bool_signature();\n+  _type = ciType::make(T_BOOLEAN);\n+\n+  _is_constant = false;\n+  _known_to_link_with_put = nullptr;\n+  _known_to_link_with_get = nullptr;\n+  _constant_value = ciConstant();\n+\n@@ -240,3 +274,3 @@\n-  _is_null_free = field->_is_null_free;\n-  _null_marker_offset = field->_null_marker_offset;\n-  _original_holder = (field->_original_holder != nullptr) ? field->_original_holder : field->_holder;\n+  _is_null_free = false;\n+  _null_marker_offset = -1;\n+  _original_holder = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":55,"deletions":21,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-  ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final);\n+  ciField(ciField* declared_field, ciField* sudfield);\n+  ciField(ciField* declared_field);\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+      field_num += fd.has_null_marker() ? 1 : 0;\n@@ -566,7 +567,0 @@\n-        ciField* flat_field = vk->nonstatic_field_at(i);\n-        \/\/ Adjust offset to account for missing oop header\n-        int offset = field_offset + (flat_field->offset_in_bytes() - vk->payload_offset());\n-        \/\/ A flat field can be treated as final if the non-flat\n-        \/\/ field is declared final or the holder klass is an inline type itself.\n-        bool is_final = fd.is_final() || is_inlinetype();\n-        ciField* field = new (arena) ciField(flat_field, this, offset, is_final);\n@@ -574,1 +568,5 @@\n-        tmp_fields->append(field);\n+        tmp_fields->append(new (arena) ciField(declared_field, vk->nonstatic_field_at(i)));\n+      }\n+      if (fd.has_null_marker()) {\n+        assert(tmp_fields != nullptr, \"should be initialized\");\n+        tmp_fields->append(new (arena) ciField(declared_field));\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -513,1 +513,0 @@\n-        ciField* cifield;\n@@ -516,7 +515,1 @@\n-          if (0 < (uint)iklass->nof_nonstatic_fields()) {\n-            cifield = iklass->nonstatic_field_at(0);\n-            cifield->print_name_on(st);\n-          } else {\n-            \/\/ Must be a null marker\n-            st->print(\"null marker\");\n-          }\n+          iklass->nonstatic_field_at(0)->print_name_on(st);\n@@ -531,7 +524,1 @@\n-            if (j < (uint)iklass->nof_nonstatic_fields()) {\n-              cifield = iklass->nonstatic_field_at(j);\n-              cifield->print_name_on(st);\n-            } else {\n-              \/\/ Must be a null marker\n-              st->print(\"null marker\");\n-            }\n+            iklass->nonstatic_field_at(j)->print_name_on(st);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -198,22 +198,0 @@\n-\/\/ Get the value of the null marker at the given offset.\n-Node* InlineTypeNode::null_marker_by_offset(int offset, int holder_offset) const {\n-  \/\/ Search through the null markers of all flat fields\n-  for (uint i = 0; i < field_count(); ++i) {\n-    if (field_is_flat(i)) {\n-      InlineTypeNode* value = field_value(i)->as_InlineType();\n-      if (!field_is_null_free(i)) {\n-        int nm_offset = holder_offset + field_null_marker_offset(i);\n-        if (nm_offset == offset) {\n-          return value->get_is_init();\n-        }\n-      }\n-      int flat_holder_offset = holder_offset + field_offset(i) - value->inline_klass()->payload_offset();\n-      Node* nm_value = value->null_marker_by_offset(offset, flat_holder_offset);\n-      if (nm_value != nullptr) {\n-        return nm_value;\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -222,11 +200,2 @@\n-Node* InlineTypeNode::field_value_by_offset(int offset, bool recursive, bool search_null_marker) const {\n-  \/\/ First check if we are loading a null marker which is not a real field\n-  if (recursive && search_null_marker) {\n-    Node* value = null_marker_by_offset(offset);\n-    if (value != nullptr){\n-      return value;\n-    }\n-  }\n-\n-  \/\/ If the field at 'offset' belongs to a flat inline type field, 'index' refers to the\n-  \/\/ corresponding InlineTypeNode input and 'sub_offset' is the offset in the flattened inline type.\n+Node* InlineTypeNode::field_value_by_offset(int offset, bool recursive) const {\n+  \/\/ Find the declared field which contains the field we are looking for\n@@ -234,1 +203,0 @@\n-  int sub_offset = offset - field_offset(index);\n@@ -237,10 +205,14 @@\n-  if (recursive && value->is_InlineType()) {\n-    if (field_is_flat(index)) {\n-      \/\/ Flat inline type field\n-      InlineTypeNode* vt = value->as_InlineType();\n-      sub_offset += vt->inline_klass()->payload_offset(); \/\/ Add header size\n-      return vt->field_value_by_offset(sub_offset, recursive, false);\n-    } else {\n-      assert(sub_offset == 0, \"should not have a sub offset\");\n-      return value;\n-    }\n+\n+  if (!recursive || !field_is_flat(index)) {\n+    assert(offset == field_offset(index), \"offset mismatch\");\n+    return value;\n+  }\n+\n+  \/\/ Flat inline type field\n+  InlineTypeNode* vt = value->as_InlineType();\n+  if (offset == field_null_marker_offset(index)) {\n+    return vt->get_is_init();\n+  } else {\n+    int sub_offset = offset - field_offset(index); \/\/ Offset of the flattened field inside the declared field\n+    sub_offset += vt->inline_klass()->payload_offset(); \/\/ Add header size\n+    return vt->field_value_by_offset(sub_offset, recursive);\n@@ -248,3 +220,0 @@\n-  assert(!(recursive && value->is_InlineType()), \"should not be an inline type\");\n-  assert(sub_offset == 0, \"offset mismatch\");\n-  return value;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":16,"deletions":47,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -113,2 +113,1 @@\n-  Node*         field_value_by_offset(int offset, bool recursive = false, bool search_null_marker = true) const;\n-  Node*         null_marker_by_offset(int offset, int holder_offset = 0) const;\n+  Node*         field_value_by_offset(int offset, bool recursive) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, ciField* field, Node* adr, ProjNode*& base_local) {\n+static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, Node* adr, ProjNode*& base_local) {\n@@ -249,1 +249,1 @@\n-    Node* tmp = try_optimize_strict_final_load_memory(phase, field, adr, base_local);\n+    Node* tmp = try_optimize_strict_final_load_memory(phase, adr, base_local);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-    Node* value = vt->field_value_by_offset(field->offset_in_bytes());\n+    Node* value = vt->field_value_by_offset(field->offset_in_bytes(), false);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -592,2 +592,4 @@\n-    if (e1->_sort_offset != e2->_sort_offset) {\n-      return e1->_sort_offset - e2->_sort_offset;\n+    if (e1->_sort_offset < e2->_sort_offset) {\n+      return -1;\n+    } else if (e1->_sort_offset > e2->_sort_offset) {\n+      return 1;\n@@ -595,0 +597,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,1 +123,19 @@\n-            )\n+            ),\n+            new Scenario(6,\n+                         \"--enable-preview\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:+AlwaysIncrementalInline\",\n+                         \"-XX:FlatArrayElementMaxOops=5\",\n+                         \"-XX:+UseArrayFlattening\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:+UseFieldFlattening\",\n+                         \"-XX:+UseNullableValueFlattening\",\n+                         \"-XX:+UseAtomicValueFlattening\",\n+                         \"-XX:+UseNonAtomicValueFlattening\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:+InlineTypeReturnedAsFields\"\n+            ),\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Arrays;\n+\n@@ -136,7 +138,0 @@\n-    @Override\n-    public String toString() {\n-        return \"s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z +\n-               \", o=\" + (o != null ? (Integer)o : \"NULL\") + \", oa=\" + (oa != null ? oa[0] : \"NULL\") +\n-               \", v1=[\" + v1 + \"], v2=[\" + v2 + \"], v3=[\" + v3 + \"], v4=[\" + v4 + \"], v5=[\" + v5 +\"], c=\" + c;\n-    }\n-\n@@ -192,0 +187,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue1[s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + o + \", oa=\" + Arrays.toString(oa) +\n+                \", v1=\" + v1 + \", v2=\" + v2 + \", v4=\" + v4 + \", c=\" + c + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        return \"d=\" + d + \", l=\" + l;\n+        return \"MyValue2Inline[d=\" + d + \", l=\" + l + \"]\";\n@@ -132,5 +132,0 @@\n-    @Override\n-    public String toString() {\n-        return \"x=\" + x + \", y=\" + y + \", v=[\" + v + \"]\";\n-    }\n-\n@@ -151,0 +146,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue2[x=\" + x + \", y=\" + y + \", v=\" + v + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue2.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue3Inline[f7=\" + f7 + \", f8=\" + f8 + \"]\";\n+    }\n@@ -261,0 +266,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue3[c=\" + c + \", bb=\" + bb + \", s=\" + s + \", i=\" + i + \", l=\" + l + \", o=\" + o +\n+                \", f1=\" + f1 + \", f2=\" + f2 + \", f3=\" + f3 + \", f4=\" + f4 + \", f5=\" + f5 + \", f6=\" + f6 + \", v1=\" + v1 + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue3.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -82,0 +82,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue4[v1=\" + v1 + \", v2=\" + v2 + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue4.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Arrays;\n+\n@@ -180,0 +182,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass1[s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + o + \", oa=\" + Arrays.toString(oa) +\n+                \", v1=\" + v1 + \", v2=\" + v2 + \", v4=\" + v4 + \", c=\" + c + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass1.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass2Inline[d=\" + d + \", l=\" + l + \"]\";\n+    }\n@@ -136,0 +141,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass2[x=\" + x + \", y=\" + y + \", v=\" + v + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass2.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueEmpty[]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueEmpty.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"SimpleInlineType[x=\" + x + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/SimpleInlineType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-                .addScenarios(new Scenario(6, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n-                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n+                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n+                .addScenarios(new Scenario(8, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n@@ -52,1 +52,2 @@\n-    @IR(failOn = IRNode.ALLOC)\n+    \/\/ TODO 8353432\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = IRNode.ALLOC)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    \/\/ TODO 8357061\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n@@ -219,1 +220,2 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    \/\/ TODO 8357061\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n@@ -529,1 +531,2 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+    \/\/ TODO 8357061\n+    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n@@ -531,1 +534,1 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}