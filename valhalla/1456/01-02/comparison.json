{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"ci\/ciField.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"ci\/ciField.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -516,7 +516,1 @@\n-          if (0 < (uint)iklass->nof_nonstatic_fields()) {\n-            cifield = iklass->nonstatic_field_at(0);\n-            cifield->print_name_on(st);\n-          } else {\n-            \/\/ Must be a null marker\n-            st->print(\"null marker\");\n-          }\n+          iklass->nonstatic_field_at(0)->print_name_on(st);\n@@ -531,7 +525,1 @@\n-            if (j < (uint)iklass->nof_nonstatic_fields()) {\n-              cifield = iklass->nonstatic_field_at(j);\n-              cifield->print_name_on(st);\n-            } else {\n-              \/\/ Must be a null marker\n-              st->print(\"null marker\");\n-            }\n+            iklass->nonstatic_field_at(j)->print_name_on(st);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -198,22 +198,0 @@\n-\/\/ Get the value of the null marker at the given offset.\n-Node* InlineTypeNode::null_marker_by_offset(int offset, int holder_offset) const {\n-  \/\/ Search through the null markers of all flat fields\n-  for (uint i = 0; i < field_count(); ++i) {\n-    if (field_is_flat(i)) {\n-      InlineTypeNode* value = field_value(i)->as_InlineType();\n-      if (!field_is_null_free(i)) {\n-        int nm_offset = holder_offset + field_null_marker_offset(i);\n-        if (nm_offset == offset) {\n-          return value->get_is_init();\n-        }\n-      }\n-      int flat_holder_offset = holder_offset + field_offset(i) - value->inline_klass()->payload_offset();\n-      Node* nm_value = value->null_marker_by_offset(offset, flat_holder_offset);\n-      if (nm_value != nullptr) {\n-        return nm_value;\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -222,11 +200,2 @@\n-Node* InlineTypeNode::field_value_by_offset(int offset, bool recursive, bool search_null_marker) const {\n-  \/\/ First check if we are loading a null marker which is not a real field\n-  if (recursive && search_null_marker) {\n-    Node* value = null_marker_by_offset(offset);\n-    if (value != nullptr){\n-      return value;\n-    }\n-  }\n-\n-  \/\/ If the field at 'offset' belongs to a flat inline type field, 'index' refers to the\n-  \/\/ corresponding InlineTypeNode input and 'sub_offset' is the offset in the flattened inline type.\n+Node* InlineTypeNode::field_value_by_offset(int offset, bool recursive) const {\n+  \/\/ Find the declared field which contains the field we are looking for\n@@ -234,1 +203,0 @@\n-  int sub_offset = offset - field_offset(index);\n@@ -237,10 +205,14 @@\n-  if (recursive && value->is_InlineType()) {\n-    if (field_is_flat(index)) {\n-      \/\/ Flat inline type field\n-      InlineTypeNode* vt = value->as_InlineType();\n-      sub_offset += vt->inline_klass()->payload_offset(); \/\/ Add header size\n-      return vt->field_value_by_offset(sub_offset, recursive, false);\n-    } else {\n-      assert(sub_offset == 0, \"should not have a sub offset\");\n-      return value;\n-    }\n+\n+  if (!recursive || !field_is_flat(index)) {\n+    assert(offset == field_offset(index), \"offset mismatch\");\n+    return value;\n+  }\n+\n+  \/\/ Flat inline type field\n+  InlineTypeNode* vt = value->as_InlineType();\n+  if (offset == field_null_marker_offset(index)) {\n+    return vt->get_is_init();\n+  } else {\n+    int sub_offset = offset - field_offset(index); \/\/ Offset of the flattened field inside the declared field\n+    sub_offset += vt->inline_klass()->payload_offset(); \/\/ Add header size\n+    return vt->field_value_by_offset(sub_offset, recursive);\n@@ -248,3 +220,0 @@\n-  assert(!(recursive && value->is_InlineType()), \"should not be an inline type\");\n-  assert(sub_offset == 0, \"offset mismatch\");\n-  return value;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":16,"deletions":47,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -113,2 +113,1 @@\n-  Node*         field_value_by_offset(int offset, bool recursive = false, bool search_null_marker = true) const;\n-  Node*         null_marker_by_offset(int offset, int holder_offset = 0) const;\n+  Node*         field_value_by_offset(int offset, bool recursive) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, ciField* field, Node* adr, ProjNode*& base_local) {\n+static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, Node* adr, ProjNode*& base_local) {\n@@ -249,1 +249,1 @@\n-    Node* tmp = try_optimize_strict_final_load_memory(phase, field, adr, base_local);\n+    Node* tmp = try_optimize_strict_final_load_memory(phase, adr, base_local);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-    Node* value = vt->field_value_by_offset(field->offset_in_bytes());\n+    Node* value = vt->field_value_by_offset(field->offset_in_bytes(), false);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+                         \"-XX:+UseNonAtomicValueFlattening\",\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Arrays;\n+\n@@ -136,7 +138,0 @@\n-    @Override\n-    public String toString() {\n-        return \"s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z +\n-               \", o=\" + (o != null ? (Integer)o : \"NULL\") + \", oa=\" + (oa != null ? oa[0] : \"NULL\") +\n-               \", v1=[\" + v1 + \"], v2=[\" + v2 + \"], v3=[\" + v3 + \"], v4=[\" + v4 + \"], v5=[\" + v5 +\"], c=\" + c;\n-    }\n-\n@@ -192,0 +187,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue1[s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + o + \", oa=\" + Arrays.toString(oa) +\n+                \", v1=\" + v1 + \", v2=\" + v2 + \", v4=\" + v4 + \", c=\" + c + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        return \"d=\" + d + \", l=\" + l;\n+        return \"MyValue2Inline[d=\" + d + \", l=\" + l + \"]\";\n@@ -132,5 +132,0 @@\n-    @Override\n-    public String toString() {\n-        return \"x=\" + x + \", y=\" + y + \", v=[\" + v + \"]\";\n-    }\n-\n@@ -151,0 +146,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue2[x=\" + x + \", y=\" + y + \", v=\" + v + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue2.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue3Inline[f7=\" + f7 + \", f8=\" + f8 + \"]\";\n+    }\n@@ -261,0 +266,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue3[c=\" + c + \", bb=\" + bb + \", s=\" + s + \", i=\" + i + \", l=\" + l + \", o=\" + o +\n+                \", f1=\" + f1 + \", f2=\" + f2 + \", f3=\" + f3 + \", f4=\" + f4 + \", f5=\" + f5 + \", f6=\" + f6 + \", v1=\" + v1 + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue3.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -82,0 +82,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValue4[v1=\" + v1 + \", v2=\" + v2 + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue4.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Arrays;\n+\n@@ -180,0 +182,6 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass1[s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + o + \", oa=\" + Arrays.toString(oa) +\n+                \", v1=\" + v1 + \", v2=\" + v2 + \", v4=\" + v4 + \", c=\" + c + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass1.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass2Inline[d=\" + d + \", l=\" + l + \"]\";\n+    }\n@@ -136,0 +141,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueClass2[x=\" + x + \", y=\" + y + \", v=\" + v + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass2.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"MyValueEmpty[]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueEmpty.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"SimpleInlineType[x=\" + x + \"]\";\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/SimpleInlineType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}