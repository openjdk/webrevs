{"files":[{"patch":"@@ -26,0 +26,2 @@\n+#include \"ci\/ciConstant.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"ci\/ciSymbol.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -33,0 +37,1 @@\n+#include \"jvm_io.h\"\n@@ -38,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -221,18 +227,47 @@\n-ciField::ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) {\n-  assert(field->holder()->is_inlinetype() || field->holder()->is_abstract(), \"should only be used for inline type field flattening\");\n-  \/\/ Set the is_final flag\n-  jint final = is_final ? JVM_ACC_FINAL : ~JVM_ACC_FINAL;\n-  AccessFlags flags(field->flags().as_int() & final);\n-  _flags = ciFlags(flags);\n-  _holder = holder;\n-  _offset = offset;\n-  \/\/ Copy remaining fields\n-  _name = field->_name;\n-  _signature = field->_signature;\n-  _type = field->_type;\n-  \/\/ Trust final flat fields\n-  _is_constant = is_final;\n-  _known_to_link_with_put = field->_known_to_link_with_put;\n-  _known_to_link_with_get = field->_known_to_link_with_get;\n-  _constant_value = field->_constant_value;\n-  assert(!field->is_flat(), \"field must not be flat\");\n+ciField::ciField(ciField* declared_field, ciField* subfield) {\n+  assert(subfield->holder()->is_inlinetype() || subfield->holder()->is_abstract(), \"should only be used for inline type field flattening\");\n+  assert(!subfield->is_flat(), \"subfield must not be flat\");\n+  assert(declared_field->is_flat(), \"declared field must be flat\");\n+\n+  _flags = declared_field->flags();\n+  _holder = declared_field->holder();\n+  _offset = declared_field->offset_in_bytes() + (subfield->offset_in_bytes() - declared_field->type()->as_inline_klass()->payload_offset());\n+\n+  char buffer[256];\n+  jio_snprintf(buffer, sizeof(buffer), \"%s.%s\", declared_field->name()->as_utf8(), subfield->name()->as_utf8());\n+  _name = ciSymbol::make(buffer);\n+\n+  _signature = subfield->_signature;\n+  _type = subfield->_type;\n+  _is_constant = false;\n+  _known_to_link_with_put = subfield->_known_to_link_with_put;\n+  _known_to_link_with_get = subfield->_known_to_link_with_get;\n+  _constant_value = ciConstant();\n+\n+  _is_flat = false;\n+  _is_null_free = false;\n+  _null_marker_offset = -1;\n+  _original_holder = (subfield->_original_holder != nullptr) ? subfield->_original_holder : subfield->_holder;\n+}\n+\n+\/\/ Constructor for the ciField of a null marker\n+ciField::ciField(ciField* declared_field) {\n+  assert(declared_field->is_flat(), \"declared field must be flat\");\n+  assert(!declared_field->is_null_free(), \"must have a null marker\");\n+\n+  _flags = declared_field->flags();\n+  _holder = declared_field->holder();\n+  _offset = declared_field->null_marker_offset();\n+\n+  char buffer[256];\n+  jio_snprintf(buffer, sizeof(buffer), \"%s.$nullMarker$\", declared_field->name()->as_utf8());\n+  _name = ciSymbol::make(buffer);\n+\n+  _signature = ciSymbols::bool_signature();\n+  _type = ciType::make(T_BOOLEAN);\n+\n+  _is_constant = false;\n+  _known_to_link_with_put = nullptr;\n+  _known_to_link_with_get = nullptr;\n+  _constant_value = ciConstant();\n+\n@@ -240,3 +275,3 @@\n-  _is_null_free = field->_is_null_free;\n-  _null_marker_offset = field->_null_marker_offset;\n-  _original_holder = (field->_original_holder != nullptr) ? field->_original_holder : field->_holder;\n+  _is_null_free = false;\n+  _null_marker_offset = -1;\n+  _original_holder = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":56,"deletions":21,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-  ciField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final);\n+  ciField(ciField* declared_field, ciField* sudfield);\n+  ciField(ciField* declared_field);\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+      field_num += fd.has_null_marker() ? 1 : 0;\n@@ -566,7 +567,0 @@\n-        ciField* flat_field = vk->nonstatic_field_at(i);\n-        \/\/ Adjust offset to account for missing oop header\n-        int offset = field_offset + (flat_field->offset_in_bytes() - vk->payload_offset());\n-        \/\/ A flat field can be treated as final if the non-flat\n-        \/\/ field is declared final or the holder klass is an inline type itself.\n-        bool is_final = fd.is_final() || is_inlinetype();\n-        ciField* field = new (arena) ciField(flat_field, this, offset, is_final);\n@@ -574,1 +568,5 @@\n-        tmp_fields->append(field);\n+        tmp_fields->append(new (arena) ciField(declared_field, vk->nonstatic_field_at(i)));\n+      }\n+      if (fd.has_null_marker()) {\n+        assert(tmp_fields != nullptr, \"should be initialized\");\n+        tmp_fields->append(new (arena) ciField(declared_field));\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -123,1 +123,18 @@\n-            )\n+            ),\n+            new Scenario(6,\n+                         \"--enable-preview\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                         \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                         \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                         \"-XX:-UseACmpProfile\",\n+                         \"-XX:+AlwaysIncrementalInline\",\n+                         \"-XX:FlatArrayElementMaxOops=5\",\n+                         \"-XX:+UseArrayFlattening\",\n+                         \"-XX:-UseArrayLoadStoreProfile\",\n+                         \"-XX:+UseFieldFlattening\",\n+                         \"-XX:+UseNullableValueFlattening\",\n+                         \"-XX:+UseAtomicValueFlattening\",\n+                         \"-XX:+InlineTypePassFieldsAsArgs\",\n+                         \"-XX:+InlineTypeReturnedAsFields\"\n+            ),\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-                .addScenarios(new Scenario(6, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n-                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n+                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n+                .addScenarios(new Scenario(8, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n@@ -52,1 +52,2 @@\n-    @IR(failOn = IRNode.ALLOC)\n+    \/\/ TODO 8353432\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = IRNode.ALLOC)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    \/\/ TODO 8357061\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n@@ -219,1 +220,2 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    \/\/ TODO 8357061\n+    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n@@ -529,1 +531,2 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+    \/\/ TODO 8357061\n+    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n@@ -531,1 +534,1 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}