{"files":[{"patch":"@@ -167,0 +167,4 @@\n+  void value_copy_internal(void* src, void* dst, size_t length) {\n+    Copy::copy_value_content(src, dst, length);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,0 +163,2 @@\n+\n+  void value_copy_internal(void* src, void* dst, size_t length);\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,2 +336,2 @@\n-  assert(is_aligned(src, md->layout_alignment(lk)) && is_aligned(dst, md->layout_alignment(lk)), \"Unalign value_copy\");\n-  AccessInternal::arraycopy_conjoint_atomic(src, dst, static_cast<size_t>(md->layout_size_in_bytes(lk)));\n+  assert(is_aligned(src, md->layout_alignment(lk)) && is_aligned(dst, md->layout_alignment(lk)), \"Unaligned value_copy\");\n+  AccessInternal::value_copy_internal(src, dst, static_cast<size_t>(md->layout_size_in_bytes(lk)));\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,40 @@\n+#define COPY_ALIGNED_SEGMENT(t) \\\n+  if (bits % sizeof(t) == 0) { \\\n+    size_t segment = remain \/ sizeof(t); \\\n+    if (segment > 0) { \\\n+      Copy::conjoint_##t##s_atomic((const t*) cursor_from, (t*) cursor_to, segment); \\\n+      remain -= segment * sizeof(t); \\\n+      cursor_from = (void*)(((char*)cursor_from) + segment * sizeof(t)); \\\n+      cursor_to = (void*)(((char*)cursor_to) + segment * sizeof(t)); \\\n+    } \\\n+  } \\\n+\n+void Copy::copy_value_content(const void* from, void* to, size_t size) {\n+  \/\/ Simple cases first\n+  uintptr_t bits = (uintptr_t) from | (uintptr_t) to | (uintptr_t) size;\n+  if (bits % sizeof(jlong) == 0) {\n+    Copy::conjoint_jlongs_atomic((const jlong*) from, (jlong*) to, size \/ sizeof(jlong));\n+    return;\n+  } else if (bits % sizeof(jint) == 0) {\n+    Copy::conjoint_jints_atomic((const jint*) from, (jint*) to, size \/ sizeof(jint));\n+    return;\n+  } else if (bits % sizeof(jshort) == 0) {\n+    Copy::conjoint_jshorts_atomic((const jshort*) from, (jshort*) to, size \/ sizeof(jshort));\n+    return;\n+  }\n+\n+  \/\/ Complex cases\n+  bits = (uintptr_t) from | (uintptr_t) to;\n+  const void* cursor_from = from;\n+  void* cursor_to = to;\n+  size_t remain = size;\n+  COPY_ALIGNED_SEGMENT(jlong)\n+  COPY_ALIGNED_SEGMENT(jint)\n+  COPY_ALIGNED_SEGMENT(jshort)\n+  if (remain > 0) {\n+    Copy::conjoint_jbytes((const void*) cursor_from, (void*) cursor_to, remain);\n+  }\n+}\n+\n+#undef COPY_ALIGNED_SEGMENT\n+\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -164,0 +164,2 @@\n+  static void copy_value_content(const void* from, void* to, size_t size);\n+\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/**\n+ * @test ValueCopyingTest\n+ * @summary Verify that interpreter doesn't tear up primitive fields when copying a value\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile ValueCopyingTest.java\n+ * @run main\/othervm -Xint -XX:+PrintInlineLayout runtime.valhalla.inlinetypes.ValueCopyingTest\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.test.lib.Asserts;\n+\n+public class ValueCopyingTest {\n+\n+  static final int NUM_WORKERS = 16;\n+\n+  static ValueCopyingTest target = new ValueCopyingTest();\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class TestValue {\n+    int i;\n+    byte b;\n+    TestValue(int i0) {\n+      i = i0;\n+      b = 0;\n+    }\n+  }\n+\n+  @NullRestricted\n+  TestValue tv;\n+\n+  static class Worker implements Runnable {\n+    int i;\n+    TestValue v;\n+    Worker(byte b) {\n+      i = b | (b << 8) | (b << 16) | (b << 24);\n+      v = new TestValue(i);\n+    }\n+\n+    static void checkValue(int i) {\n+      byte b = (byte)(i & 0xFF);\n+      Asserts.assertTrue(((i >> 8) & 0xFF) == b, \"Tearing detected\");\n+      Asserts.assertTrue(((i >> 16) & 0xFF) == b, \"Tearing detected\");\n+      Asserts.assertTrue(((i >> 24) & 0xFF) == b, \"Tearing detected\");\n+    }\n+\n+    public void run() {\n+      for (int n = 0; n < 10000000; n++) {\n+        ValueCopyingTest.target.tv = v;\n+        int ri = ValueCopyingTest.target.tv.i;\n+        checkValue(ri);\n+      }\n+    }\n+  }\n+\n+  static public void main(String[] args) throws InterruptedException {\n+    Thread[] workers = new Thread[NUM_WORKERS];\n+    for (int i = 0; i < NUM_WORKERS; i++) {\n+      workers[i] = new Thread(new Worker((byte)i));\n+    }\n+    for (int i = 0; i < NUM_WORKERS; i++) {\n+      workers[i].start();\n+    }\n+    try {\n+      for (int i = 0; i < NUM_WORKERS; i++) {\n+        workers[i].join();\n+      }\n+    } catch(InterruptedException e) {\n+      e.printStackTrace();\n+      throw e;\n+    }\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueCopyingTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}