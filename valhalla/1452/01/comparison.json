{"files":[{"patch":"@@ -74,1 +74,0 @@\n-    $1_ARGS += -KArray\n@@ -81,1 +80,0 @@\n-      $1_ARGS += -KArray\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\t\t\t\t--add-exports java.base\/jdk.internal.value=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1251,1 +1251,1 @@\n-  if (UseSlowPath || op->is_null_free() ||\n+  if (UseSlowPath || op->always_slow_path() ||\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1207,2 +1207,7 @@\n-  ciKlass* obj = (ciKlass*) x->exact_type();\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  ciKlass* obj = ciArrayKlass::make(x->klass(), false, true, true);\n+\n+  \/\/ TODO 8265122 Implement a fast path for this\n+  bool is_flat = obj->is_loaded() && obj->is_flat_array_klass();\n+  bool is_null_free = obj->is_loaded() && obj->as_array_klass()->is_elem_null_free();\n+\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n@@ -1214,1 +1219,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, is_null_free || is_flat);\n@@ -1290,3 +1295,0 @@\n-  if (x->is_null_free()) {\n-    __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -750,1 +750,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ new \"[Ljava\/lang\/Object;\"\n+            __ cmpw(t0, Klass::_lh_array_tag_ref_value); \/\/ new \"[Ljava\/lang\/Object;\"\n@@ -752,1 +752,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ new \"[LVT;\"\n+            __ cmpw(t0, Klass::_lh_array_tag_flat_value);  \/\/ new \"[LVT;\"\n@@ -757,1 +757,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be a flat array.\n+            __ cmpw(t0, Klass::_lh_array_tag_flat_value);  \/\/ the array can be a flat array.\n@@ -759,1 +759,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be a flat array (due to InlineArrayElementMaxFlatSize, etc)\n+            __ cmpw(t0, Klass::_lh_array_tag_ref_value); \/\/ the array cannot be a flat array (due to the InlineArrayElementMaxFlatSize, etc.)\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2268,6 +2268,0 @@\n-void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n-  ldrh(temp_reg, Address(klass, Klass::access_flags_offset()));\n-  andr(temp_reg, temp_reg, JVM_ACC_IDENTITY);\n-  cbz(temp_reg, is_inline_type);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -662,1 +662,0 @@\n-  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-          int tag = (id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value;\n+          int tag = (id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_ref_value;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -756,1 +756,1 @@\n-          int tag = ((id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_obj_value);\n+          int tag = ((id == C1StubId::new_type_array_id) ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_ref_value);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -399,2 +399,1 @@\n-                     ? Klass::_lh_array_tag_type_value\n-                     : Klass::_lh_array_tag_obj_value);\n+                     ? Klass::_lh_array_tag_type_value : Klass::_lh_array_tag_ref_value);\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1278,1 +1278,1 @@\n-  if (UseSlowPath || op->is_null_free() ||\n+  if (UseSlowPath || op->always_slow_path() ||\n@@ -1413,0 +1413,1 @@\n+    \/\/ TODO 8366668 Is this correct? I don't think so. Probably we now always go to the slow path here. Same on AArch64.\n@@ -2869,0 +2870,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1209,2 +1209,7 @@\n-  ciKlass* obj = (ciKlass*) x->exact_type();\n-  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x->is_null_free());\n+  ciKlass* obj = ciArrayKlass::make(x->klass(), false, true, true);\n+\n+  \/\/ TODO 8265122 Implement a fast path for this\n+  bool is_flat = obj->is_loaded() && obj->is_flat_array_klass();\n+  bool is_null_free = obj->is_loaded() && obj->as_array_klass()->is_elem_null_free();\n+\n+  CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, is_null_free);\n@@ -1215,1 +1220,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, is_null_free || is_flat);\n@@ -1294,4 +1299,0 @@\n-  if (x->is_null_free()) {\n-    __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -914,1 +914,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ new \"[Ljava\/lang\/Object;\"\n+            __ cmpl(t0, (Klass::_lh_array_tag_ref_value)); \/\/ new \"[Ljava\/lang\/Object;\"\n@@ -916,1 +916,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ new \"[LVT;\"\n+            __ cmpl(t0, Klass::_lh_array_tag_flat_value);  \/\/ new \"[LVT;\"\n@@ -921,1 +921,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be a flat array.\n+            __ cmpl(t0, Klass::_lh_array_tag_flat_value);  \/\/ the array can be a flat array.\n@@ -923,1 +923,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be a flat array (due to InlineArrayElementMaxFlatSize, etc)\n+            __ cmpl(t0, (Klass::_lh_array_tag_ref_value)); \/\/ the array cannot be a flat array (due to InlineArrayElementMaxFlatSize, etc)\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2363,6 +2363,0 @@\n-void MacroAssembler::test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type) {\n-  load_unsigned_short(temp_reg, Address(klass, Klass::access_flags_offset()));\n-  testl(temp_reg, JVM_ACC_IDENTITY);\n-  jcc(Assembler::zero, is_inline_type);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-  void test_klass_is_inline_type(Register klass, Register temp_reg, Label& is_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1077,1 +1077,1 @@\n-    \/\/ TODO 8350865 This is currently dead code\n+    \/\/ TODO 8350865 This is currently dead code. Can we use set_null_free on the result here if the array is null-free?\n@@ -3517,2 +3517,1 @@\n-    state->store_local(idx, new Local(method()->holder(), objectType, idx,\n-             \/*receiver*\/ true, \/*null_free*\/ method()->holder()->is_flat_array_klass()));\n+    state->store_local(idx, new Local(method()->holder(), objectType, idx, true));\n@@ -3530,1 +3529,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, false));\n+    state->store_local(idx, new Local(type, vt, idx, false));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-    NeverNullFlag,          \/\/ For \"Q\" signatures\n+    NeverNullFlag,\n@@ -715,1 +715,1 @@\n-  Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)\n+  Local(ciType* declared, ValueType* type, int index, bool receiver)\n@@ -721,1 +721,0 @@\n-    set_null_free(null_free);\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1509,1 +1509,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array, bool is_null_free) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array, bool always_slow_path) {\n@@ -1521,1 +1521,1 @@\n-                           is_null_free));\n+                           always_slow_path));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1820,1 +1820,1 @@\n-  bool      _is_null_free;\n+  bool      _always_slow_path;\n@@ -1823,1 +1823,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array, bool is_null_free)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array, bool always_slow_path)\n@@ -1834,1 +1834,1 @@\n-    , _is_null_free(is_null_free) {}\n+    , _always_slow_path(always_slow_path) {}\n@@ -1845,2 +1845,2 @@\n-  bool      zero_array()   const                 { return _zero_array;  }\n-  bool      is_null_free() const                 { return _is_null_free;}\n+  bool      zero_array() const                   { return _zero_array;  }\n+  bool      always_slow_path() const             { return _always_slow_path; }\n@@ -2410,1 +2410,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true, bool is_null_free = false);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true, bool always_slow_path = false);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -900,0 +901,6 @@\n+\n+  \/\/ TODO 8366668\n+  if (expected_type != nullptr && expected_type->is_obj_array_klass()) {\n+    expected_type = ciArrayKlass::make(expected_type->as_array_klass()->element_klass(), false, true, true);\n+  }\n+\n@@ -2817,0 +2824,10 @@\n+    \/\/ TODO 8366668\n+    if (exact_klass != nullptr && exact_klass->is_obj_array_klass()) {\n+      if (exact_klass->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n+        \/\/ Could be flat, null free etc.\n+        exact_klass = nullptr;\n+      } else {\n+        exact_klass = ciObjArrayKlass::make(exact_klass->as_array_klass()->element_klass(), true);\n+      }\n+    }\n+\n@@ -2854,0 +2871,11 @@\n+\n+    \/\/ TODO 8366668\n+    if (exact_klass != nullptr && exact_klass->is_obj_array_klass()) {\n+      if (exact_klass->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n+        \/\/ Could be flat, null free etc.\n+        exact_klass = nullptr;\n+      } else {\n+        exact_klass = ciObjArrayKlass::make(exact_klass->as_array_klass()->element_klass(), true);\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -439,2 +439,2 @@\n-  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n-  objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);\n+  Klass* elem_klass = ObjArrayKlass::cast(array_klass)->element_klass();\n+  objArrayOop obj = oopFactory::new_objArray(elem_klass, length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -459,1 +459,1 @@\n-  Klass* elem_klass = ArrayKlass::cast(array_klass)->element_klass();\n+  Klass* elem_klass = ObjArrayKlass::cast(array_klass)->element_klass();\n@@ -464,6 +464,1 @@\n-  arrayOop obj= nullptr;\n-  if (UseArrayFlattening && vk->has_non_atomic_layout()) {\n-    obj = oopFactory::new_flatArray(elem_klass, length, LayoutKind::NON_ATOMIC_FLAT, CHECK);\n-  } else {\n-    obj = oopFactory::new_null_free_objArray(elem_klass, length, CHECK);\n-  }\n+  arrayOop obj= oopFactory::new_objArray(elem_klass, length, ArrayKlass::ArrayProperties::NULL_RESTRICTED, CHECK);\n@@ -536,1 +531,1 @@\n-  oop obj = array->read_value_from_flat_array(index, CHECK);\n+  oop obj = array->obj_at(index, CHECK);\n@@ -551,1 +546,1 @@\n-    array->write_value_to_flat_array(value, index, CHECK);\n+    array->obj_at_put(index, value, CHECK);\n@@ -1223,0 +1218,6 @@\n+          if (!k->is_typeArray_klass() && !k->is_refArray_klass() && !k->is_flatArray_klass()) {\n+            k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+          }\n+          if (k->is_flatArray_klass()) {\n+            deoptimize_for_flat = true;\n+          }\n@@ -1280,1 +1281,1 @@\n-        tty->print_cr(\"Deoptimizing for patching flat field reference\");\n+        tty->print_cr(\"Deoptimizing for patching flat field or array reference\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -821,1 +821,7 @@\n-    if (k->is_objArray_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      num_obj_array_klasses ++;\n+      type = \"flat array\";\n+    } else if (k->is_refArray_klass()) {\n+        num_obj_array_klasses ++;\n+        type = \"ref array\";\n+    } else if (k->is_objArray_klass()) {\n@@ -825,1 +831,1 @@\n-      type = \"array\";\n+      type = \"obj array\";\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  memset(mem, 0, objArrayOopDesc::object_size(element_count));\n+  memset(mem, 0, refArrayOopDesc::object_size(element_count));\n@@ -224,1 +224,1 @@\n-  assert(objArrayOopDesc::object_size(max_elem_count)*HeapWordSize == MIN_GC_REGION_ALIGNMENT,\n+  assert(refArrayOopDesc::object_size(max_elem_count)*HeapWordSize == MIN_GC_REGION_ALIGNMENT,\n@@ -338,1 +338,1 @@\n-  size_t byte_size = objArrayOopDesc::object_size(length) * HeapWordSize;\n+  size_t byte_size = refArrayOopDesc::object_size(length) * HeapWordSize;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-  return objArrayOopDesc::object_size(size_in_elems(seg_idx)) * HeapWordSize;\n+  return refArrayOopDesc::object_size(size_in_elems(seg_idx)) * HeapWordSize;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-  if (Arguments::is_incompatible_cds_internal_module_property(key)) {\n+  if (Arguments::is_incompatible_cds_internal_module_property(key) && !Arguments::patching_migrated_classes(key, value)) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  Klass* oop_field_klass = oop_field->is_objArray() ? oop_field->klass()->super() : oop_field->klass();\n@@ -95,1 +96,1 @@\n-  } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+  } else if (oop_field_klass != ik && oop_field_klass != ik->array_klass_or_null()) {\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -299,1 +300,2 @@\n-  ((objArrayOop)array.resolve())->replace_if_null(index, o);\n+  \/\/ ((objArrayOop)array.resolve())->replace_if_null(index, o);\n+  refArrayOopDesc::cast(array.resolve())->replace_if_null(index, o);\n@@ -309,1 +311,1 @@\n-        vmClasses::ProtectionDomain_klass(), size, CHECK);\n+        vmClasses::ProtectionDomain_klass(), size, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -321,1 +323,1 @@\n-        vmClasses::URL_klass(), size, CHECK);\n+        vmClasses::URL_klass(), size, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -333,1 +335,1 @@\n-        vmClasses::Jar_Manifest_klass(), size, CHECK);\n+        vmClasses::Jar_Manifest_klass(), size, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -70,1 +71,2 @@\n-  f(InlineKlass)\n+  f(InlineKlass) \\\n+  f(RefArrayKlass)\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,0 +369,3 @@\n+      if (oak->is_refined_objArray_klass()) {\n+        oak = ObjArrayKlass::cast(oak->super());\n+      }\n@@ -439,8 +442,10 @@\n-\n-      if (elm->is_instance_klass()) {\n-        assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n-        InstanceKlass::cast(elm)->set_array_klasses(oak);\n-      } else {\n-        assert(elm->is_array_klass(), \"sanity\");\n-        assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n-        ArrayKlass::cast(elm)->set_higher_dimension(oak);\n+      \/\/ Higher dimension may have been set when doing setup on ObjArrayKlass\n+      if (!oak->is_refined_objArray_klass()) {\n+        if (elm->is_instance_klass()) {\n+          assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n+          InstanceKlass::cast(elm)->set_array_klasses(oak);\n+        } else {\n+          assert(elm->is_array_klass(), \"sanity\");\n+          assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n+          ArrayKlass::cast(elm)->set_higher_dimension(oak);\n+        }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1298,1 +1298,5 @@\n-      assert(resolved_k == k, \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      if (resolved_k->is_array_klass()) {\n+        assert(resolved_k == k || ((ObjArrayKlass*)resolved_k)->next_refined_array_klass() == k, \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      } else {\n+        assert(resolved_k == k, \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-  soc->do_tag(objArrayOopDesc::base_offset_in_bytes());\n+  soc->do_tag(refArrayOopDesc::base_offset_in_bytes());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  if (bt == T_FLAT_ELEMENT) return T_OBJECT;\n@@ -127,0 +128,15 @@\n+bool ciArray::is_atomic() {\n+  VM_ENTRY_MARK;\n+  arrayOop oop = get_arrayOop();\n+  if (oop->is_refArray()) {\n+    return oop->klass()->is_inline_klass();\n+  }\n+  if (oop->is_flatArray()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(oop->klass());\n+    if (fak->element_klass()->is_naturally_atomic() || fak->layout_kind() == LayoutKind::ATOMIC_FLAT || fak->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-  virtual bool is_null_free();\n+  bool is_null_free();\n+  bool is_atomic();\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool flat, bool null_free, bool atomic) {\n+ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free, bool atomic, bool vm_type) {\n@@ -112,1 +112,1 @@\n-  if (klass->is_loaded() && klass->is_inlinetype()) {\n+  if (klass->is_loaded() && klass->is_inlinetype() && vm_type) {\n@@ -115,1 +115,0 @@\n-      Klass* ak = nullptr;\n@@ -117,22 +116,3 @@\n-      if (flat && vk->maybe_flat_in_array()) {\n-        LayoutKind lk;\n-        if (null_free) {\n-          if (!atomic && !vk->has_non_atomic_layout()) {\n-            \/\/ TODO 8350865 Impossible type\n-            lk = vk->has_atomic_layout() ? LayoutKind::ATOMIC_FLAT : LayoutKind::NULLABLE_ATOMIC_FLAT;\n-          } else {\n-            lk = atomic ? LayoutKind::ATOMIC_FLAT : LayoutKind::NON_ATOMIC_FLAT;\n-          }\n-        } else {\n-          if (!vk->has_nullable_atomic_layout()) {\n-            \/\/ TODO 8350865 Impossible type, null-able flat is always atomic.\n-            lk = vk->has_atomic_layout() ? LayoutKind::ATOMIC_FLAT : LayoutKind::NON_ATOMIC_FLAT;\n-          } else {\n-            lk = LayoutKind::NULLABLE_ATOMIC_FLAT;\n-          }\n-        }\n-        ak = vk->flat_array_klass(lk, THREAD);\n-      } else if (null_free) {\n-        ak = vk->null_free_reference_array(THREAD);\n-      } else {\n-        return ciObjArrayKlass::make(klass);\n+      ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+      if (null_free) {\n+        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n@@ -140,0 +120,5 @@\n+      if (!atomic) {\n+        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+      }\n+      ArrayKlass* ak = vk->array_klass(THREAD);\n+      ak = ObjArrayKlass::cast(ak)->klass_with_properties(props, THREAD);\n@@ -144,1 +129,1 @@\n-      } else if (ak->is_objArray_klass()) {\n+      } else if (ak->is_refArray_klass()) {\n@@ -149,1 +134,1 @@\n-  return ciObjArrayKlass::make(klass);\n+  return ciObjArrayKlass::make(klass, vm_type);\n@@ -164,1 +149,8 @@\n-  GUARDED_VM_ENTRY(return get_Klass()->is_null_free_array_klass();)\n+  GUARDED_VM_ENTRY(return is_loaded() && get_Klass()->is_null_free_array_klass();)\n+}\n+\n+bool ciArrayKlass::is_elem_atomic() {\n+  ciKlass* elem = element_klass();\n+  GUARDED_VM_ENTRY(return elem != nullptr && elem->is_inlinetype() &&\n+                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::INVALID) == 0 &&\n+                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::NON_ATOMIC) == 0;)\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  static ciArrayKlass* make(ciType* klass, bool flat = false, bool null_free = false, bool atomic = false);\n+  static ciArrayKlass* make(ciType* klass, bool null_free = false, bool atomic = false, bool vm_type = false);\n@@ -67,0 +67,1 @@\n+  bool is_elem_atomic();\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType* ciInstance::java_mirror_type(bool* is_null_free_array) {\n+ciType* ciInstance::java_mirror_type() {\n@@ -55,3 +55,0 @@\n-    if (is_null_free_array != nullptr && (k->is_array_klass() && k->is_null_free_array_klass())) {\n-      *is_null_free_array = true;\n-    }\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ciType* java_mirror_type(bool* is_null_free_array = nullptr);\n+  ciType* java_mirror_type();\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass) {\n+ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool vm_type) {\n@@ -142,0 +142,4 @@\n+    if (array->is_objArray_klass() && vm_type) {\n+      assert(!array->is_refArray_klass() && !array->is_flatArray_klass(), \"Unexpected refined klass\");\n+      array = ObjArrayKlass::cast(array)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+    }\n@@ -164,2 +168,2 @@\n-ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass);)\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool vm_type) {\n+  GUARDED_VM_ENTRY(return make_impl(element_klass, vm_type);)\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static ciObjArrayKlass* make_impl(ciKlass* element_klass);\n+  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool vm_type = false);\n@@ -71,1 +71,1 @@\n-  static ciObjArrayKlass* make(ciKlass* element_klass);\n+  static ciObjArrayKlass* make(ciKlass* element_klass, bool vm_type = false);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    if (type2name(t) != nullptr && !is_reference_type(t) &&\n+    if (type2name(t) != nullptr && t != T_FLAT_ELEMENT && !is_reference_type(t) &&\n@@ -364,1 +364,1 @@\n-  } else if (o->is_objArray()) {\n+  } else if (o->is_refArray()) {\n@@ -399,1 +399,1 @@\n-    } else if (k->is_objArray_klass()) {\n+    } else if (k->is_refArray_klass() || k->is_objArray_klass()) {\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1135,0 +1135,2 @@\n+            \/\/ This handling will change the array property argument passed to the\n+            \/\/ factory below\n@@ -1136,1 +1138,1 @@\n-            value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n+            value = oopFactory::new_objArray(kelem, length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(true));\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -604,0 +604,1 @@\n+  \/\/ TODO 8350865 Can we check that array_klass is null_free and use mark_as_null_free on the result here?\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -929,1 +929,1 @@\n-                                           loaded_class_pkgs->length(), CHECK_NULL);\n+                                           loaded_class_pkgs->length(), ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  objArrayOop pn = oopFactory::new_objArray(vmClasses::String_klass(), len, CHECK_NULL);\n+  objArrayOop pn = oopFactory::new_objArray(vmClasses::String_klass(), len, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -115,1 +115,1 @@\n-  objArrayOop cn = oopFactory::new_objArray(vmClasses::String_klass(), len, CHECK_NULL);\n+  objArrayOop cn = oopFactory::new_objArray(vmClasses::String_klass(), len, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaAssertions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1096,0 +1096,1 @@\n+      assert(!k->is_refArray_klass() || !k->is_flatArray_klass(), \"Must not have mirror\");\n@@ -1132,1 +1133,0 @@\n-\n@@ -1136,0 +1136,9 @@\n+\n+    if (k->is_refArray_klass() || k->is_flatArray_klass()) {\n+      Klass* super_klass = k->super();\n+      assert(super_klass != nullptr, \"Must be\");\n+      Handle mirror(THREAD, super_klass->java_mirror());\n+      k->set_java_mirror(mirror);\n+      return;\n+    }\n+\n@@ -1222,1 +1231,0 @@\n-  assert(as_Klass(m) == k, \"must be\");\n@@ -1226,0 +1234,1 @@\n+    assert(as_Klass(m) == k, \"must be\");\n@@ -1235,0 +1244,4 @@\n+  } else {\n+    ObjArrayKlass* objarray_k = (ObjArrayKlass*)as_Klass(m);\n+    \/\/ Mirror is either an ObjArrayKlass or one of its refined array klasses\n+    assert(objarray_k == k || objarray_k->next_refined_array_klass() == k, \"must be\");\n@@ -1472,4 +1485,1 @@\n-  if (klass->is_flatArray_klass() || (ArrayKlass::cast(klass)->is_null_free_array_klass())) {\n-    \/\/ TODO 8336006 Ignore flat \/ null-free arrays\n-    return;\n-  }\n+  assert(!klass->is_refArray_klass() && !klass->is_flatArray_klass(), \"should not be ref or flat array klass\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-  size_t single_array_size = objArrayOopDesc::object_size(total);\n+  size_t single_array_size = refArrayOopDesc::object_size(total);\n@@ -962,1 +962,1 @@\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), total, CHECK);\n+    objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), total, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -968,2 +968,2 @@\n-    size_t primary_array_size = objArrayOopDesc::object_size(primary_array_length);\n-    size_t secondary_array_size = objArrayOopDesc::object_size(_secondary_array_max_length);\n+    size_t primary_array_size = refArrayOopDesc::object_size(primary_array_length);\n+    size_t secondary_array_size = refArrayOopDesc::object_size(_secondary_array_max_length);\n@@ -979,1 +979,1 @@\n-    objArrayOop primary = oopFactory::new_objArray(vmClasses::Object_klass(), primary_array_length, CHECK);\n+    objArrayOop primary = oopFactory::new_objArray(vmClasses::Object_klass(), primary_array_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -993,1 +993,1 @@\n-      objArrayOop secondary = oopFactory::new_objArray(vmClasses::Object_klass(), len, CHECK);\n+      objArrayOop secondary = oopFactory::new_objArray(vmClasses::Object_klass(), len, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -1009,1 +1009,1 @@\n-    size_t next_size = objArrayOopDesc::object_size(1 << (max + 1));\n+    size_t next_size = refArrayOopDesc::object_size(1 << (max + 1));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -687,2 +687,0 @@\n-  do_intrinsic(_isFlatArray,              jdk_internal_misc_Unsafe,     isFlatArray_name, class_boolean_signature, F_RN)         \\\n-   do_name(     isFlatArray_name,                                       \"isFlatArray\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  _null_marker = read_from(stream);\n+  _properties = read_from(stream);\n@@ -183,5 +183,1 @@\n-    if (_null_marker == nullptr) {\n-      \/\/ MarkerValue is used for null-free objects\n-      _null_marker = new MarkerValue();\n-    }\n-    _null_marker->write_on(stream);\n+    _properties->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  ScopeValue*                _null_marker;\n+  ScopeValue*                _properties; \/\/ Used to pass additional data like the null marker or array properties.\n@@ -144,1 +144,1 @@\n-  ObjectValue(int id, ScopeValue* klass = nullptr, bool is_scalar_replaced = true, ScopeValue* null_marker = nullptr)\n+  ObjectValue(int id, ScopeValue* klass = nullptr, bool is_scalar_replaced = true, ScopeValue* properties = nullptr)\n@@ -147,1 +147,1 @@\n-     , _null_marker((null_marker == nullptr) ? new MarkerValue() : null_marker)\n+     , _properties((properties == nullptr) ? new MarkerValue() : properties)\n@@ -160,1 +160,1 @@\n-  virtual ScopeValue*         null_marker() const         { return _null_marker; }\n+  virtual ScopeValue*         properties() const          { return _properties; }\n@@ -168,1 +168,1 @@\n-  bool                        maybe_null() const          { return !_null_marker->is_marker(); }\n+  bool                        has_properties() const      { return !_properties->is_marker(); }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-\n-  array->oop_iterate_range(mark_closure(), beg_index, end_index);\n+  assert(array->is_refArray(), \"Must be\");\n+  refArrayOop(array)->oop_iterate_range(mark_closure(), beg_index, end_index);\n@@ -116,1 +116,1 @@\n-  if (obj->is_objArray()) {\n+  if (obj->is_refArray()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  to_array->oop_iterate_range(&_scanner,\n+  assert(to_array->is_refArray(), \"Must be\");\n+  refArrayOop(to_array)->oop_iterate_range(&_scanner,\n@@ -257,1 +258,2 @@\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n+  assert(to_array->is_refArray(), \"Must be\");\n+  refArrayOop(to_array)->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n@@ -431,1 +433,1 @@\n-      if (klass->is_objArray_klass()) {\n+      if (klass->is_refArray_klass()) {\n@@ -437,1 +439,1 @@\n-        assert(klass->is_typeArray_klass(), \"invariant\");\n+        assert(klass->is_typeArray_klass() || klass->is_objArray_klass(), \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    if (obj->is_objArray()) {\n+    if (obj->is_refArray()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-        new_obj->is_objArray() &&\n+        new_obj->is_refArray() &&\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,0 +383,1 @@\n+  assert(obj->is_refArray(), \"Must be\");\n@@ -398,1 +399,1 @@\n-  if (obj->is_objArray()) {\n+  if (obj->is_refArray()) {\n@@ -415,1 +416,1 @@\n-  array->oop_iterate_range(&mark_and_push_closure, beg_index, end_index);\n+  refArrayOop(array)->oop_iterate_range(&mark_and_push_closure, beg_index, end_index);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  assert(!klass->is_objArray_klass() || klass->is_refArray_klass() || klass->is_flatArray_klass(), \"ObjArrayKlass must never be used to allocate array instances directly\");\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\/\/ These fascilities are used for allocating, and initializing newly allocated objects.\n+\/\/ These facilities are used for allocating, and initializing newly allocated objects.\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    } else if (obj->is_objArray()) {\n+    } else if (obj->is_refArray()) {\n@@ -159,1 +159,1 @@\n-  assert(obj->is_objArray(), \"expect object array\");\n+  assert(obj->is_refArray(), \"expect object array\");\n@@ -226,1 +226,1 @@\n-  assert(obj->is_objArray(), \"expect object array\");\n+  assert(obj->is_refArray(), \"expect object array\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-      if (p < left && !obj->is_objArray()) {\n+      if (p < left && !obj->is_refArray()) {\n@@ -256,1 +256,1 @@\n-        if (!last_obj->is_objArray()) {\n+        if (!last_obj->is_refArray()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-  if (dst->is_objArray()) {\n+  if (dst->is_refArray()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-  if (obj->is_objArray()) {\n+  if (obj->is_refArray()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -48,1 +49,1 @@\n-  return obj->klass()->is_objArray_klass() && is_invisible_object(obj);\n+  return obj->klass()->is_refArray_klass() && is_invisible_object(obj);\n@@ -71,1 +72,2 @@\n-  obj->oop_iterate_range(cl, start, end);\n+  assert(obj->is_refArray(), \"Must be\");\n+  refArrayOop(obj)->oop_iterate_range(cl, start, end);\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-  return to_oop(addr)->is_objArray();\n+  return to_oop(addr)->is_refArray();\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    objArrayOop args_oop = oopFactory::new_objArray(vmClasses::Object_klass(), _argc, CHECK);\n+    objArrayOop args_oop = oopFactory::new_objArray(vmClasses::Object_klass(), _argc, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  arrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  arrayOop obj = oopFactory::new_objArray(klass, size, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -303,1 +303,1 @@\n-  oop res = farray->read_value_from_flat_array(index, CHECK);\n+  oop res = farray->obj_at(index, CHECK);\n@@ -310,1 +310,1 @@\n-  farray->write_value_to_flat_array(val, index, CHECK);\n+  farray->obj_at_put(index, val, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -189,1 +190,1 @@\n-  objArrayOop arr = ObjArrayKlass::cast(ak)->allocate(array_length, CHECK);\n+  objArrayOop arr = oopFactory::new_objArray(klass, array_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2984,1 +2984,1 @@\n-  objArrayOop filter_oop = oopFactory::new_objArray(vmClasses::Class_klass(), filter_length, CHECK_NULL);\n+  objArrayOop filter_oop = oopFactory::new_objArray(vmClasses::Class_klass(), filter_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1466,2 +1466,1 @@\n-    Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlass())->array_klass(CHECK_(JVMCIObject()));\n-    objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+    objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(JVMCIObject()));\n@@ -1895,1 +1894,1 @@\n-      objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \\\n+      objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(JVMCIObject())); \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    obj = oopFactory::new_objArray(elem_klass, length, CHECK);\n+    obj = oopFactory::new_objArray(elem_klass, length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -798,1 +798,1 @@\n-  declare_constant(Klass::_lh_array_tag_obj_value)                        \\\n+  declare_constant(Klass::_lh_array_tag_ref_value)                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/refArrayKlass.inline.hpp\"\n@@ -160,0 +161,1 @@\n+      set_init_function<RefArrayKlass>();\n@@ -225,0 +227,1 @@\n+      set_init_function<RefArrayKlass>();\n@@ -290,0 +293,1 @@\n+      set_init_function<RefArrayKlass>();\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -81,1 +82,1 @@\n-  return Universe::objectArrayKlass()->allocate(length, THREAD);\n+  return Universe::objectArrayKlass()->allocate_instance(length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n@@ -112,2 +113,1 @@\n-\n-objArrayOop oopFactory::new_objArray(Klass* klass, int length, TRAPS) {\n+objArrayOop oopFactory::new_objArray(Klass* klass, int length, ArrayKlass::ArrayProperties properties, TRAPS) {\n@@ -116,0 +116,1 @@\n+    assert(properties == ArrayKlass::ArrayProperties::DEFAULT, \"properties only apply to single dimension arrays\");\n@@ -118,1 +119,1 @@\n-    return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);\n+    return InstanceKlass::cast(klass)->allocate_objArray(length, properties, THREAD);\n@@ -122,1 +123,1 @@\n-objArrayOop oopFactory::new_null_free_objArray(Klass* k, int length, TRAPS) {\n+flatArrayOop oopFactory::new_flatArray(Klass* k, int length, ArrayKlass::ArrayProperties props, LayoutKind lk, TRAPS) {\n@@ -124,9 +125,0 @@\n-  ObjArrayKlass* array_klass = klass->null_free_reference_array(CHECK_NULL);\n-\n-  assert(array_klass->is_objArray_klass(), \"Must be\");\n-  assert(array_klass->is_null_free_array_klass(), \"Must be\");\n-\n-  objArrayOop oop = array_klass->allocate(length, CHECK_NULL);\n-\n-  assert(oop == nullptr || oop->is_objArray(), \"Sanity\");\n-  assert(oop == nullptr || oop->klass()->is_null_free_array_klass(), \"Sanity\");\n@@ -134,6 +126,2 @@\n-  return oop;\n-}\n-\n-flatArrayOop oopFactory::new_flatArray(Klass* k, int length, LayoutKind lk, TRAPS) {\n-  InlineKlass* klass = InlineKlass::cast(k);\n-  Klass* array_klass = klass->flat_array_klass(lk, CHECK_NULL);\n+  ArrayKlass* array_type = klass->array_klass(CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::cast(array_type)->klass_with_properties(props, CHECK_NULL);\n@@ -141,1 +129,2 @@\n-  assert(array_klass->is_flatArray_klass(), \"Must be\");\n+  assert(oak->is_flatArray_klass(), \"Expected to be\");\n+  assert(FlatArrayKlass::cast(oak)->layout_kind() == lk, \"Unexpected layout kind\");\n@@ -143,1 +132,1 @@\n-  flatArrayOop oop = FlatArrayKlass::cast(array_klass)->allocate(length, lk, CHECK_NULL);\n+  flatArrayOop oop = (flatArrayOop)FlatArrayKlass::cast(oak)->allocate_instance(length, props, CHECK_NULL);\n@@ -151,1 +140,2 @@\n-  objArrayOop obj = new_objArray(klass, length, CHECK_(objArrayHandle()));\n+  \/\/ TODO FIXME check if this method should take an array properties argument (probably should)\n+  objArrayOop obj = new_objArray(klass, length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(objArrayHandle()));\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -57,1 +58,1 @@\n-  static objArrayOop     new_objArray(Klass* klass, int length, TRAPS);\n+  static objArrayOop     new_objArray(Klass* klass, int length, ArrayKlass::ArrayProperties properties, TRAPS);\n@@ -66,2 +67,1 @@\n-  static flatArrayOop        new_flatArray(Klass* klass, int length, LayoutKind lk, TRAPS);\n-  static objArrayOop         new_null_free_objArray(Klass* klass, int length, TRAPS);\n+  static flatArrayOop        new_flatArray(Klass* klass, int length, ArrayKlass::ArrayProperties props, LayoutKind lk, TRAPS);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -505,2 +505,6 @@\n-    Klass* oak = vmClasses::Object_klass()->array_klass(CHECK);\n-    _objectArrayKlass = ObjArrayKlass::cast(oak);\n+    ArrayKlass* oak = vmClasses::Object_klass()->array_klass(CHECK);\n+    oak->append_to_sibling_list();\n+\n+    \/\/ Create a RefArrayKlass (which is the default) and initialize.\n+    ObjArrayKlass* rak = ObjArrayKlass::cast(oak)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+    _objectArrayKlass = rak;\n@@ -508,7 +512,0 @@\n-  \/\/ OLD\n-  \/\/ Add the class to the class hierarchy manually to make sure that\n-  \/\/ its vtable is initialized after core bootstrapping is completed.\n-  \/\/ ---\n-  \/\/ New\n-  \/\/ Have already been initialized.\n-  _objectArrayKlass->append_to_sibling_list();\n@@ -528,1 +525,1 @@\n-    objArrayOop    naked_array = oopFactory::new_objArray(vmClasses::Object_klass(), size, CHECK);\n+    objArrayOop    naked_array = oopFactory::new_objArray(vmClasses::Object_klass(), size, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -646,0 +643,3 @@\n+\n+  \/\/ This isn't added to the subclass list, so need to reinitialize vtables directly.\n+  Universe::objectArrayKlass()->vtable().initialize_vtable();\n@@ -778,1 +778,1 @@\n-  objArrayOop oa = oopFactory::new_objArray(ik, _oom_count, CHECK);\n+  objArrayOop oa = oopFactory::new_objArray(ik, _oom_count, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -812,1 +812,1 @@\n-  objArrayOop instance = oopFactory::new_objArray(ik, len, CHECK);\n+  objArrayOop instance = oopFactory::new_objArray(ik, len, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -1111,1 +1111,1 @@\n-  objArrayOop the_empty_class_array = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_false);\n+  objArrayOop the_empty_class_array = oopFactory::new_objArray(vmClasses::Class_klass(), 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -97,1 +98,1 @@\n-ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind, markWord prototype_header) :\n+ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind, ArrayProperties props, markWord prototype_header) :\n@@ -100,0 +101,1 @@\n+  _properties(props),\n@@ -145,1 +147,10 @@\n-  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);\n+\n+  if (k->is_refArray_klass() || k->is_flatArray_klass()) {\n+    assert(super_klass != nullptr, \"Must be\");\n+    assert(k->super() != nullptr, \"Must be\");\n+    assert(k->super() == super_klass, \"Must be\");\n+    Handle mirror(THREAD, super_klass->java_mirror());\n+    k->set_java_mirror(mirror);\n+  } else {\n+    java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);\n+  }\n@@ -162,2 +173,2 @@\n-      ObjArrayKlass* ak =\n-      ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, CHECK_NULL);\n+      ObjArrayKlass* ak = nullptr;\n+      ak = RefArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n@@ -213,1 +224,1 @@\n-  size_t size = objArrayOopDesc::object_size(length);\n+  size_t size = refArrayOopDesc::object_size(length);\n@@ -215,1 +226,2 @@\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n+  ObjArrayKlass* oak = ObjArrayKlass::cast(ak)->klass_with_properties(ArrayProperties::DEFAULT, CHECK_NULL);\n+  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(oak, size, length,\n@@ -264,1 +276,1 @@\n-    ArrayKlass *ak = higher_dimension();\n+    ObjArrayKlass *ak = higher_dimension();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,15 @@\n+\n+ public:\n+  enum ArrayProperties : uint32_t {\n+    DEFAULT         = 0,\n+    NULL_RESTRICTED = 1 << 0,\n+    NON_ATOMIC      = 1 << 1,\n+    \/\/ FINAL           = 1 << 2,\n+    \/\/ VOLATILE        = 1 << 3\n+    INVALID         = 1 << 4,\n+    DUMMY           = 1 << 5      \/\/ Just to transition the code, to be removed ASAP\n+  };\n+\n+  static bool is_null_restricted(ArrayProperties props) { return (props & NULL_RESTRICTED) != 0; }\n+  static bool is_non_atomic(ArrayProperties props) { return (props & NON_ATOMIC) != 0; }\n+\n@@ -42,0 +57,1 @@\n+  ArrayProperties _properties;\n@@ -46,7 +62,0 @@\n-  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n-                                    \/\/ The element type must be registered for both object arrays\n-                                    \/\/ (incl. object arrays with value type elements) and value type\n-                                    \/\/ arrays containing flat value types. However, the element\n-                                    \/\/ type must not be registered for arrays of primitive types.\n-                                    \/\/ TODO: Update the class hierarchy so that element klass appears\n-                                    \/\/ only in array that contain non-primitive types.\n@@ -56,1 +65,1 @@\n-  ArrayKlass(Symbol* name, KlassKind kind, markWord prototype_header = markWord::prototype());\n+  ArrayKlass(Symbol* name, KlassKind kind, ArrayProperties props, markWord prototype_header = markWord::prototype());\n@@ -65,6 +74,0 @@\n-  \/\/ Instance variables\n-  virtual Klass* element_klass() const      { return _element_klass; }\n-  virtual void set_element_klass(Klass* k)  { _element_klass = k; }\n-\n-  \/\/ Compiler\/Interpreter offset\n-  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }\n@@ -87,0 +90,4 @@\n+  ArrayProperties properties() const { return _properties; }\n+  void set_properties(ArrayProperties props) { _properties = props; }\n+  static ByteSize properties_offset() { return byte_offset_of(ArrayKlass, _properties); }\n+\n@@ -164,0 +171,8 @@\n+class ArrayDescription : public StackObj {\n+  public:\n+   Klass::KlassKind _kind;\n+   ArrayKlass::ArrayProperties _properties;\n+   LayoutKind _layout_kind;\n+   ArrayDescription(Klass::KlassKind k, ArrayKlass::ArrayProperties p, LayoutKind lk) { _kind = k; _properties = p; _layout_kind = lk; }\n+ };\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    assert(type != T_FLAT_ELEMENT, \"wrong type\");\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -195,1 +196,2 @@\n-  return resolved_references()->replace_if_null(index, new_result);\n+  \/\/ return resolved_references()->replace_if_null(index, new_result);\n+  return refArrayOopDesc::cast(resolved_references())->replace_if_null(index, new_result);\n@@ -226,1 +228,1 @@\n-    objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n+    objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -233,1 +235,1 @@\n-      objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n+      objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -417,1 +419,1 @@\n-        objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n+        objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -426,1 +428,1 @@\n-    objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), resolved_references()->length(), CHECK);\n+    objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), resolved_references()->length(), ArrayKlass::ArrayProperties::DEFAULT, CHECK);\n@@ -482,0 +484,1 @@\n+    assert(src_k->is_instance_klass() || src_k->is_typeArray_klass(), \"Sanity check\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  assert(obj == nullptr || obj->is_objArray(), \"should be objArray\");\n+  assert(obj == nullptr || obj->is_refArray(), \"should be refArray\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -57,1 +58,2 @@\n-FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk) : ArrayKlass(name, Kind, markWord::flat_array_prototype(lk)) {\n+FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name, ArrayProperties props, LayoutKind lk) :\n+                ObjArrayKlass(1, element_klass, name, Kind, props, markWord::flat_array_prototype(lk)) {\n@@ -97,1 +99,1 @@\n-FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, LayoutKind lk, TRAPS) {\n+FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, ArrayProperties props, LayoutKind lk, TRAPS) {\n@@ -111,8 +113,0 @@\n-    \/\/ Also, see if the element has secondary supertypes.\n-    \/\/ We need an array type for each.\n-    const Array<Klass*>* element_supers = element_klass->secondary_supers();\n-    for( int i = element_supers->length()-1; i >= 0; i-- ) {\n-      Klass* elem_super = element_supers->at(i);\n-      elem_super->array_klass(CHECK_NULL);\n-    }\n-   \/\/ Fall through because inheritance is acyclic and we hold the global recursive lock to allocate all the arrays.\n@@ -124,1 +118,1 @@\n-  FlatArrayKlass* vak = new (loader_data, size, THREAD) FlatArrayKlass(element_klass, name, lk);\n+  FlatArrayKlass* vak = new (loader_data, size, THREAD) FlatArrayKlass(element_klass, name, props, lk);\n@@ -140,2 +134,1 @@\n-  ArrayKlass::metaspace_pointers_do(it);\n-  it->push(&_element_klass);\n+  ObjArrayKlass::metaspace_pointers_do(it);\n@@ -145,1 +138,2 @@\n-flatArrayOop FlatArrayKlass::allocate(int length, LayoutKind lk, TRAPS) {\n+objArrayOop FlatArrayKlass::allocate_instance(int length, ArrayProperties props, TRAPS) {\n+  assert(UseArrayFlattening, \"Must be enabled\");\n@@ -162,1 +156,1 @@\n-  int lh = Klass::array_layout_helper(_lh_array_tag_vt_value, null_free, hsize, etype, esize);\n+  int lh = Klass::array_layout_helper(_lh_array_tag_flat_value, null_free, hsize, etype, esize);\n@@ -168,1 +162,0 @@\n-  assert(!layout_helper_is_objArray(lh), \"correct kind\");\n@@ -235,2 +228,2 @@\n-  ArrayKlass* sk = ArrayKlass::cast(s->klass());\n-  ArrayKlass* dk = ArrayKlass::cast(d->klass());\n+  ObjArrayKlass* sk = ObjArrayKlass::cast(s->klass());\n+  ObjArrayKlass* dk = ObjArrayKlass::cast(d->klass());\n@@ -314,1 +307,1 @@\n-      assert(dk->is_objArray_klass(), \"Expected objArray here\");\n+      assert(dk->is_refArray_klass(), \"Expected objArray here\");\n@@ -320,1 +313,1 @@\n-        oop o = sh->read_value_from_flat_array(src_pos + i, CHECK);\n+        oop o = sh->obj_at(src_pos + i, CHECK);\n@@ -334,1 +327,1 @@\n-      da->write_value_to_flat_array(sa->obj_at(src_pos + i), dst_pos + i, CHECK);\n+      da->obj_at_put( dst_pos + i, sa->obj_at(src_pos + i), CHECK);\n@@ -387,1 +380,1 @@\n-  assert(!is_objArray_klass(), \"Unimplemented\");\n+  assert(!is_refArray_klass(), \"Unimplemented\");\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -36,1 +37,1 @@\n-class FlatArrayKlass : public ArrayKlass {\n+class FlatArrayKlass : public ObjArrayKlass {\n@@ -44,1 +45,1 @@\n-  FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk);\n+  FlatArrayKlass(Klass* element_klass, Symbol* name, ArrayProperties props, LayoutKind lk);\n@@ -53,1 +54,1 @@\n-  void set_element_klass(Klass* k) { _element_klass = k; }\n+  void set_element_klass(Klass* k) { assert(k->is_inline_klass(), \"Must be\"); _element_klass = k; }\n@@ -66,1 +67,1 @@\n-  static FlatArrayKlass* allocate_klass(Klass* element_klass, LayoutKind lk, TRAPS);\n+  static FlatArrayKlass* allocate_klass(Klass* element_klass, ArrayProperties props, LayoutKind lk, TRAPS);\n@@ -100,1 +101,1 @@\n-  flatArrayOop allocate(int length, LayoutKind lk, TRAPS);\n+  objArrayOop allocate_instance(int length, ArrayProperties props, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/objArrayOop.hpp\"\n@@ -36,1 +37,1 @@\n-class flatArrayOopDesc : public arrayOopDesc {\n+class flatArrayOopDesc : public objArrayOopDesc {\n@@ -42,2 +43,4 @@\n-  inline oop read_value_from_flat_array( int index, TRAPS);\n-  inline void write_value_to_flat_array(oop value, int index, TRAPS);\n+  inline oop obj_at(int index) const;\n+  inline oop obj_at(int index, TRAPS) const;\n+  inline void obj_at_put(int index, oop value);\n+  inline void obj_at_put(int index, oop value, TRAPS);\n@@ -52,1 +55,1 @@\n-    julong size_in_bytes = base_offset_in_bytes(Klass::layout_helper_element_type(lh));\n+    julong size_in_bytes = arrayOopDesc::base_offset_in_bytes(Klass::layout_helper_element_type(lh));\n@@ -63,0 +66,3 @@\n+\/\/ See similar requirement for oopDesc.\n+static_assert(std::is_trivially_default_constructible<flatArrayOopDesc>::value, \"required\");\n+\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,2 +49,7 @@\n-inline oop flatArrayOopDesc::read_value_from_flat_array(int index, TRAPS) {\n-  \/\/ This method assumes that the validity of the index has already been checked\n+inline oop flatArrayOopDesc::obj_at(int index) const {\n+  EXCEPTION_MARK;\n+  return obj_at(index, THREAD);\n+}\n+\n+inline oop flatArrayOopDesc::obj_at(int index, TRAPS) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n@@ -54,1 +59,1 @@\n-  oop res = vk->read_payload_from_addr(this, offset, faklass->layout_kind(), CHECK_NULL);\n+  oop res = vk->read_payload_from_addr((oopDesc*)this, offset, faklass->layout_kind(), CHECK_NULL);\n@@ -58,2 +63,7 @@\n-inline void flatArrayOopDesc::write_value_to_flat_array(oop value, int index, TRAPS) {\n-  \/\/ This method assumes that the validity of the index has already been checked\n+inline void flatArrayOopDesc::obj_at_put(int index, oop value) {\n+  EXCEPTION_MARK;                                 \/\/ What if the caller is not a Java Thread?\n+  obj_at_put(index, value, THREAD);\n+}\n+\n+inline void flatArrayOopDesc::obj_at_put(int index, oop value, TRAPS) {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n@@ -66,0 +76,2 @@\n+  } else if(is_null_free_array()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted array\");\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -52,0 +54,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -73,4 +76,0 @@\n-  *((address*)adr_non_atomic_flat_array_klass()) = nullptr;\n-  *((address*)adr_atomic_flat_array_klass()) = nullptr;\n-  *((address*)adr_nullable_atomic_flat_array_klass()) = nullptr;\n-  *((address*)adr_null_free_reference_array_klass()) = nullptr;\n@@ -230,1 +229,1 @@\n-oop InlineKlass::read_payload_from_addr(oop src, int offset, LayoutKind lk, TRAPS) {\n+oop InlineKlass::read_payload_from_addr(const oop src, int offset, LayoutKind lk, TRAPS) {\n@@ -244,1 +243,1 @@\n-      copy_payload_to_addr((void*)((char*)(oopDesc*)obj_h() + offset), payload_addr(res), lk, false);\n+      copy_payload_to_addr((void*)(cast_from_oop<char*>(obj_h()) + offset), payload_addr(res), lk, false);\n@@ -302,73 +301,0 @@\n-ObjArrayKlass* InlineKlass::null_free_reference_array(TRAPS) {\n-  if (Atomic::load_acquire(adr_null_free_reference_array_klass()) == nullptr) {\n-    \/\/ Atomic creation of array_klasses\n-    RecursiveLocker rl(MultiArray_lock, THREAD);\n-\n-    \/\/ Check if update has already taken place\n-    if (null_free_reference_array_klass() == nullptr) {\n-      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n-\n-      \/\/ use 'release' to pair with lock-free load\n-      Atomic::release_store(adr_null_free_reference_array_klass(), k);\n-    }\n-  }\n-  return null_free_reference_array_klass();\n-}\n-\n-\n-\/\/ There's no reason for this method to have a TRAP argument\n-FlatArrayKlass* InlineKlass::flat_array_klass(LayoutKind lk, TRAPS) {\n-  FlatArrayKlass* volatile* adr_flat_array_klass = nullptr;\n-  switch(lk) {\n-    case LayoutKind::NON_ATOMIC_FLAT:\n-      assert(has_non_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_non_atomic_flat_array_klass();\n-      break;\n-    case LayoutKind::ATOMIC_FLAT:\n-    assert(has_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_atomic_flat_array_klass();\n-      break;\n-    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n-      assert(has_nullable_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_nullable_atomic_flat_array_klass();\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  if (Atomic::load_acquire(adr_flat_array_klass) == nullptr) {\n-    \/\/ Atomic creation of array_klasses\n-    RecursiveLocker rl(MultiArray_lock, THREAD);\n-\n-    if (*adr_flat_array_klass == nullptr) {\n-      FlatArrayKlass* k = FlatArrayKlass::allocate_klass(this, lk, CHECK_NULL);\n-      Atomic::release_store(adr_flat_array_klass, k);\n-    }\n-  }\n-  return *adr_flat_array_klass;\n-}\n-\n-FlatArrayKlass* InlineKlass::flat_array_klass_or_null(LayoutKind lk) {\n-    FlatArrayKlass* volatile* adr_flat_array_klass = nullptr;\n-  switch(lk) {\n-    case LayoutKind::NON_ATOMIC_FLAT:\n-      assert(has_non_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_non_atomic_flat_array_klass();\n-      break;\n-    case LayoutKind::ATOMIC_FLAT:\n-    assert(has_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_atomic_flat_array_klass();\n-      break;\n-    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n-      assert(has_nullable_atomic_layout(), \"Must be\");\n-      adr_flat_array_klass = adr_nullable_atomic_flat_array_klass();\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  \/\/ Need load-acquire for lock-free read\n-  FlatArrayKlass* k = Atomic::load_acquire(adr_flat_array_klass);\n-  return k;\n-}\n-\n@@ -711,6 +637,0 @@\n-\n-  InlineKlass* this_ptr = this;\n-  it->push((Klass**)adr_non_atomic_flat_array_klass());\n-  it->push((Klass**)adr_atomic_flat_array_klass());\n-  it->push((Klass**)adr_nullable_atomic_flat_array_klass());\n-  it->push((Klass**)adr_null_free_reference_array_klass());\n@@ -732,12 +652,0 @@\n-  if (non_atomic_flat_array_klass() != nullptr) {\n-    non_atomic_flat_array_klass()->remove_unshareable_info();\n-  }\n-  if (atomic_flat_array_klass() != nullptr) {\n-    atomic_flat_array_klass()->remove_unshareable_info();\n-  }\n-  if (nullable_atomic_flat_array_klass() != nullptr) {\n-    nullable_atomic_flat_array_klass()->remove_unshareable_info();\n-  }\n-  if (null_free_reference_array_klass() != nullptr) {\n-    null_free_reference_array_klass()->remove_unshareable_info();\n-  }\n@@ -748,12 +656,0 @@\n-  if (non_atomic_flat_array_klass() != nullptr) {\n-    non_atomic_flat_array_klass()->remove_java_mirror();\n-  }\n-  if (atomic_flat_array_klass() != nullptr) {\n-    atomic_flat_array_klass()->remove_java_mirror();\n-  }\n-  if (nullable_atomic_flat_array_klass() != nullptr) {\n-    nullable_atomic_flat_array_klass()->remove_java_mirror();\n-  }\n-  if (null_free_reference_array_klass() != nullptr) {\n-    null_free_reference_array_klass()->remove_java_mirror();\n-  }\n@@ -764,12 +660,0 @@\n-  if (non_atomic_flat_array_klass() != nullptr) {\n-    non_atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n-  }\n-  if (atomic_flat_array_klass() != nullptr) {\n-    atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n-  }\n-  if (nullable_atomic_flat_array_klass() != nullptr) {\n-    nullable_atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n-  }\n-  if (null_free_reference_array_klass() != nullptr) {\n-    null_free_reference_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n-  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":5,"deletions":121,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -83,36 +84,0 @@\n-  FlatArrayKlass* volatile* adr_non_atomic_flat_array_klass() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _non_atomic_flat_array_klass));\n-  }\n-\n-  FlatArrayKlass* non_atomic_flat_array_klass() const {\n-    return *adr_non_atomic_flat_array_klass();\n-  }\n-\n-  FlatArrayKlass* volatile* adr_atomic_flat_array_klass() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _atomic_flat_array_klass));\n-  }\n-\n-  FlatArrayKlass* atomic_flat_array_klass() const {\n-    return *adr_atomic_flat_array_klass();\n-  }\n-\n-  FlatArrayKlass* volatile* adr_nullable_atomic_flat_array_klass() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _nullable_atomic_flat_array_klass));\n-  }\n-\n-  FlatArrayKlass* nullable_atomic_flat_array_klass() const {\n-    return *adr_nullable_atomic_flat_array_klass();\n-  }\n-\n-  ObjArrayKlass* volatile* adr_null_free_reference_array_klass() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return (ObjArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_reference_array_klass));\n-  }\n-\n-  ObjArrayKlass* null_free_reference_array_klass() const {\n-    return *adr_null_free_reference_array_klass();\n-  }\n-\n@@ -264,7 +229,0 @@\n-  \/\/ null free inline arrays...\n-  \/\/\n-\n-  FlatArrayKlass* flat_array_klass(LayoutKind lk, TRAPS);\n-  FlatArrayKlass* flat_array_klass_or_null(LayoutKind lk);\n-  ObjArrayKlass* null_free_reference_array(TRAPS);\n-\n@@ -278,1 +236,1 @@\n-  oop read_payload_from_addr(oop src, int offset, LayoutKind lk, TRAPS);\n+  oop read_payload_from_addr(const oop src, int offset, LayoutKind lk, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":2,"deletions":44,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -1849,7 +1850,3 @@\n-objArrayOop InstanceKlass::allocate_objArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n, CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  return o;\n+objArrayOop InstanceKlass::allocate_objArray(int length, ArrayKlass::ArrayProperties props, TRAPS) {\n+  ArrayKlass* ak = array_klass(CHECK_NULL);\n+  return ObjArrayKlass::cast(ak)->allocate_instance(length, props, CHECK_NULL);\n@@ -1918,1 +1915,1 @@\n-      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, false, CHECK_NULL);\n+      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n@@ -3113,0 +3110,6 @@\n+    if (class_loader_data() == nullptr) {\n+      ResourceMark rm(THREAD);\n+      log_debug(cds)(\"  loader_data %s \", loader_data == nullptr ? \"nullptr\" : \"non null\");\n+      log_debug(cds)(\"  this %s array_klasses %s \", this->name()->as_C_string(), array_klasses()->name()->as_C_string());\n+    }\n+    assert(!array_klasses()->is_refined_objArray_klass(), \"must be non-refined objarrayklass\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -149,4 +150,0 @@\n-  FlatArrayKlass* _non_atomic_flat_array_klass;\n-  FlatArrayKlass* _atomic_flat_array_klass;\n-  FlatArrayKlass* _nullable_atomic_flat_array_klass;\n-  ObjArrayKlass* _null_free_reference_array_klass;\n@@ -239,1 +236,1 @@\n-  ArrayKlass* volatile _array_klasses;\n+  ObjArrayKlass* volatile _array_klasses;\n@@ -428,4 +425,4 @@\n-  ArrayKlass* array_klasses() const     { return _array_klasses; }\n-  inline ArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n-  inline void release_set_array_klasses(ArrayKlass* k); \/\/ store with release semantics\n-  void set_array_klasses(ArrayKlass* k) { _array_klasses = k; }\n+  ObjArrayKlass* array_klasses() const     { return _array_klasses; }\n+  inline ObjArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n+  inline void release_set_array_klasses(ObjArrayKlass* k); \/\/ store with release semantics\n+  void set_array_klasses(ObjArrayKlass* k) { _array_klasses = k; }\n@@ -914,1 +911,1 @@\n-  objArrayOop allocate_objArray(int n, int length, TRAPS);\n+  objArrayOop allocate_objArray(int lenght, ArrayKlass::ArrayProperties props, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-inline ArrayKlass* InstanceKlass::array_klasses_acquire() const {\n+inline ObjArrayKlass* InstanceKlass::array_klasses_acquire() const {\n@@ -85,1 +85,1 @@\n-inline void InstanceKlass::release_set_array_klasses(ArrayKlass* k) {\n+inline void InstanceKlass::release_set_array_klasses(ObjArrayKlass* k) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;\n+  int  tag   =  isobj ? _lh_array_tag_ref_value : _lh_array_tag_type_value;\n@@ -305,1 +305,1 @@\n-  assert(layout_helper_is_objArray(lh) == isobj, \"correct kind\");\n+  assert(layout_helper_is_refArray(lh) == isobj, \"correct kind\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,14 +69,16 @@\n-  enum KlassKind : u2 {\n-    InstanceKlassKind,\n-    InlineKlassKind,\n-    InstanceRefKlassKind,\n-    InstanceMirrorKlassKind,\n-    InstanceClassLoaderKlassKind,\n-    InstanceStackChunkKlassKind,\n-    TypeArrayKlassKind,\n-    FlatArrayKlassKind,\n-    ObjArrayKlassKind,\n-    UnknownKlassKind\n-  };\n-\n-  static const uint KLASS_KIND_COUNT = ObjArrayKlassKind + 1;\n+   enum KlassKind : u2\n+   {\n+     InstanceKlassKind,\n+     InlineKlassKind,\n+     InstanceRefKlassKind,\n+     InstanceMirrorKlassKind,\n+     InstanceClassLoaderKlassKind,\n+     InstanceStackChunkKlassKind,\n+     TypeArrayKlassKind,\n+     ObjArrayKlassKind,\n+     RefArrayKlassKind,\n+     FlatArrayKlassKind,\n+     UnknownKlassKind\n+   };\n+\n+   static const uint KLASS_KIND_COUNT = FlatArrayKlassKind + 1;\n@@ -466,1 +468,1 @@\n-  static const int _lh_array_tag_bits          = 3;\n+  static const int _lh_array_tag_bits          = 4;\n@@ -470,2 +472,2 @@\n-  static const unsigned int _lh_array_tag_vt_value   = 0Xfffffffd;\n-  static const unsigned int _lh_array_tag_obj_value  = 0Xfffffffe;\n+  static const unsigned int _lh_array_tag_flat_value = 0Xfffffffa;\n+  static const unsigned int _lh_array_tag_ref_value  = 0Xfffffff8;\n@@ -477,1 +479,1 @@\n-  static const jint _lh_array_tag_flat_value_bit_inplace = (jint) (1 << _lh_array_tag_shift);\n+  static const jint _lh_array_tag_flat_value_bit_inplace = (jint) (1 << (_lh_array_tag_shift + 1));\n@@ -496,2 +498,2 @@\n-  static bool layout_helper_is_objArray(jint lh) {\n-    return (juint)_lh_array_tag_obj_value == (juint)(lh >> _lh_array_tag_shift);\n+  static bool layout_helper_is_refArray(jint lh) {\n+    return (juint)_lh_array_tag_ref_value == (juint)(lh >> _lh_array_tag_shift);\n@@ -500,1 +502,1 @@\n-    return (juint)_lh_array_tag_vt_value == (juint)(lh >> _lh_array_tag_shift);\n+    return (juint)_lh_array_tag_flat_value == (juint)(lh >> _lh_array_tag_shift);\n@@ -503,1 +505,1 @@\n-    assert(layout_helper_is_flatArray(lh) || layout_helper_is_objArray(lh), \"must be array of inline types\");\n+    assert(layout_helper_is_flatArray(lh) || layout_helper_is_refArray(lh), \"must be array of inline types\");\n@@ -690,0 +692,1 @@\n+  virtual bool is_refArray_klass_slow()     const { return false; }\n@@ -717,1 +720,2 @@\n-  bool is_objArray_klass()              const { return assert_same_query( _kind == ObjArrayKlassKind,  is_objArray_klass_slow()); }\n+  bool is_objArray_klass()              const { return assert_same_query( _kind == ObjArrayKlassKind || _kind == RefArrayKlassKind || _kind == FlatArrayKlassKind,  is_objArray_klass_slow()); }\n+  bool is_refArray_klass()              const { return assert_same_query( _kind == RefArrayKlassKind, is_refArray_klass_slow()); }\n@@ -719,0 +723,1 @@\n+  bool is_refined_objArray_klass()      const { return is_refArray_klass() || is_flatArray_klass(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -928,1 +928,1 @@\n-    objArrayOop m_oop = oopFactory::new_objArray(vmClasses::Class_klass(), length, CHECK_(objArrayHandle()));\n+    objArrayOop m_oop = oopFactory::new_objArray(vmClasses::Class_klass(), length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(objArrayHandle()));\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -44,0 +46,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -45,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -49,2 +53,2 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n,\n-                                       Klass* k, Symbol* name, bool null_free,\n+ObjArrayKlass* ObjArrayKlass::allocate_klass(ClassLoaderData* loader_data, int n,\n+                                       Klass* k, Symbol* name, ArrayKlass::ArrayProperties props,\n@@ -57,1 +61,1 @@\n-  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, null_free);\n+  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, Kind, props, ArrayKlass::is_null_restricted(props) ? markWord::null_free_array_prototype() : markWord::prototype());\n@@ -61,3 +65,1 @@\n-                                                      int n, Klass* element_klass,\n-                                                      bool null_free, TRAPS) {\n-  assert(!null_free || (n == 1 && element_klass->is_inline_klass()), \"null-free unsupported\");\n+                                                      int n, Klass* element_klass,  TRAPS) {\n@@ -74,5 +76,1 @@\n-      if (null_free) {\n-        super_klass = element_klass->array_klass(CHECK_NULL);\n-      } else {\n-        super_klass = element_super->array_klass(CHECK_NULL);\n-      }\n+      super_klass = element_super->array_klass(CHECK_NULL);\n@@ -95,1 +93,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, null_free, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate_klass(loader_data, n, element_klass, name, ArrayProperties::INVALID, CHECK_NULL);\n@@ -113,2 +111,2 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) :\n-ArrayKlass(name, Kind, null_free ? markWord::null_free_array_prototype() : markWord::prototype()) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, KlassKind kind, ArrayKlass::ArrayProperties props, markWord mk) :\n+ArrayKlass(name, kind, props, mk) {\n@@ -117,0 +115,2 @@\n+  set_next_refined_klass_klass(nullptr);\n+  set_properties(props);\n@@ -122,1 +122,1 @@\n-    bk = FlatArrayKlass::cast(element_klass)->element_klass();\n+    bk = FlatArrayKlass::cast(element_klass)->element_klass();  \/\/ flat array case should be merge with refArray case once reparented\n@@ -124,0 +124,1 @@\n+    assert(!element_klass->is_refArray_klass(), \"Sanity\");\n@@ -135,1 +136,1 @@\n-  if (null_free) {\n+  if (ArrayKlass::is_null_restricted(props)) {\n@@ -152,1 +153,38 @@\n-  return objArrayOop(obj)->object_size();\n+  \/\/ return objArrayOop(obj)->object_size();\n+  return obj->is_flatArray() ? flatArrayOop(obj)->object_size() : refArrayOop(obj)->object_size();\n+}\n+\n+ArrayDescription ObjArrayKlass::array_layout_selection(Klass* element, ArrayProperties properties) {\n+  \/\/ TODO FIXME: the layout selection should take the array size in consideration\n+  \/\/ to avoid creation of arrays too big to be handled by the VM\n+  if (!UseArrayFlattening || element->is_array_klass() || element->is_identity_class() || element->is_abstract()) {\n+    return ArrayDescription(RefArrayKlassKind, properties, LayoutKind::REFERENCE);\n+  }\n+  assert(element->is_final(), \"Flat layouts below require monomorphic elements\");\n+  InlineKlass* vk = InlineKlass::cast(element);\n+  if (is_null_restricted(properties)) {\n+    if (is_non_atomic(properties)) {\n+      \/\/ Null-restricted + non-atomic\n+      if (vk->maybe_flat_in_array() && vk->has_non_atomic_layout()) {\n+        return ArrayDescription(FlatArrayKlassKind, properties, LayoutKind::NON_ATOMIC_FLAT);\n+      } else {\n+        return ArrayDescription(RefArrayKlassKind, properties, LayoutKind::REFERENCE);\n+      }\n+    } else {\n+      \/\/ Null-restricted + atomic\n+      if (vk->maybe_flat_in_array() && vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n+        return ArrayDescription(FlatArrayKlassKind, properties, LayoutKind::NON_ATOMIC_FLAT);\n+      } else if (vk->maybe_flat_in_array() && vk->has_atomic_layout()) {\n+        return ArrayDescription(FlatArrayKlassKind, properties, LayoutKind::ATOMIC_FLAT);\n+      } else {\n+        return ArrayDescription(RefArrayKlassKind, properties, LayoutKind::REFERENCE);\n+      }\n+    }\n+  } else {\n+    \/\/ nullable implies atomic, so the non-atomic property is ignored\n+    if (vk->maybe_flat_in_array() && vk->has_nullable_atomic_layout()) {\n+      return ArrayDescription(FlatArrayKlassKind, properties, LayoutKind::NULLABLE_ATOMIC_FLAT);\n+    } else {\n+      return ArrayDescription(RefArrayKlassKind, properties, LayoutKind::REFERENCE);\n+    }\n+  }\n@@ -155,1 +193,1 @@\n-objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {\n+objArrayOop ObjArrayKlass::allocate_instance(int length, ArrayProperties props, TRAPS) {\n@@ -157,3 +195,17 @@\n-  size_t size = objArrayOopDesc::object_size(length);\n-  objArrayOop array =  (objArrayOop)Universe::heap()->array_allocate(this, size, length,\n-                                                       \/* do_zero *\/ true, CHECK_NULL);\n+  ObjArrayKlass* ak = klass_with_properties(props, THREAD);\n+  size_t size = 0;\n+  switch(ak->kind()) {\n+    case Klass::RefArrayKlassKind:\n+      size = refArrayOopDesc::object_size(length);\n+      break;\n+    case Klass::FlatArrayKlassKind:\n+      size = flatArrayOopDesc::object_size(ak->layout_helper(), length);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  assert(size != 0, \"Sanity check\");\n+  objArrayOop array = (objArrayOop)Universe::heap()->array_allocate(\n+    ak, size, length,\n+    \/* do_zero *\/ true, CHECK_NULL);\n+  assert(array->is_refArray() || array->is_flatArray(), \"Must be\");\n@@ -168,1 +220,3 @@\n-  objArrayOop array = allocate(length, CHECK_NULL);\n+  ObjArrayKlass* oak = klass_with_properties(ArrayProperties::DEFAULT, CHECK_NULL);\n+  assert(oak->is_refArray_klass() || oak->is_flatArray_klass(), \"Must be\");\n+  objArrayOop array = oak->allocate_instance(length, ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -191,30 +245,0 @@\n-\/\/ Either oop or narrowOop depending on UseCompressedOops.\n-void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,\n-                            arrayOop d, size_t dst_offset, int length, TRAPS) {\n-  if (s == d) {\n-    \/\/ since source and destination are equal we do not need conversion checks.\n-    assert(length > 0, \"sanity check\");\n-    ArrayAccess<>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n-  } else {\n-    \/\/ We have to make sure all elements conform to the destination array\n-    Klass* bound = ObjArrayKlass::cast(d->klass())->element_klass();\n-    Klass* stype = ObjArrayKlass::cast(s->klass())->element_klass();\n-    \/\/ Perform null check if dst is null-free but src has no such guarantee\n-    bool null_check = ((!s->klass()->is_null_free_array_klass()) &&\n-        d->klass()->is_null_free_array_klass());\n-    if (stype == bound || stype->is_subtype_of(bound)) {\n-      if (null_check) {\n-        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n-      } else {\n-        ArrayAccess<ARRAYCOPY_DISJOINT>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n-      }\n-    } else {\n-      if (null_check) {\n-        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n-      } else {\n-        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n-      }\n-    }\n-  }\n-}\n-\n@@ -230,42 +254,3 @@\n-  }\n-\n-  if (!d->is_objArray()) {\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    if (d->is_typeArray()) {\n-      ss.print(\"arraycopy: type mismatch: can not copy object array[] into %s[]\",\n-               type2name_tab[ArrayKlass::cast(d->klass())->element_type()]);\n-    } else {\n-      ss.print(\"arraycopy: destination type %s is not an array\", d->klass()->external_name());\n-    }\n-    THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n-  }\n-\n-  \/\/ Check is all offsets and lengths are non negative\n-  if (src_pos < 0 || dst_pos < 0 || length < 0) {\n-    \/\/ Pass specific exception reason.\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    if (src_pos < 0) {\n-      ss.print(\"arraycopy: source index %d out of bounds for object array[%d]\",\n-               src_pos, s->length());\n-    } else if (dst_pos < 0) {\n-      ss.print(\"arraycopy: destination index %d out of bounds for object array[%d]\",\n-               dst_pos, d->length());\n-    } else {\n-      ss.print(\"arraycopy: length %d is negative\", length);\n-    }\n-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n-  }\n-  \/\/ Check if the ranges are valid\n-  if ((((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length()) ||\n-      (((unsigned int) length + (unsigned int) dst_pos) > (unsigned int) d->length())) {\n-    \/\/ Pass specific exception reason.\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    if (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length()) {\n-      ss.print(\"arraycopy: last source index %u out of bounds for object array[%d]\",\n-               (unsigned int) length + (unsigned int) src_pos, s->length());\n-    } else {\n-      ss.print(\"arraycopy: last destination index %u out of bounds for object array[%d]\",\n-               (unsigned int) length + (unsigned int) dst_pos, d->length());\n+    if (s->is_flatArray()) {\n+      FlatArrayKlass::cast(s->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);\n+      return;\n@@ -273,1 +258,0 @@\n-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n@@ -276,24 +260,2 @@\n-  \/\/ Special case. Boundary cases must be checked first\n-  \/\/ This allows the following call: copy_array(s, s.length(), d.length(), 0).\n-  \/\/ This is correct, since the position is supposed to be an 'in between point', i.e., s.length(),\n-  \/\/ points to the right of the last element.\n-  if (length==0) {\n-    return;\n-  }\n-  if (UseCompressedOops) {\n-    size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset<narrowOop>(src_pos);\n-    size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset<narrowOop>(dst_pos);\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, nullptr) ==\n-           objArrayOop(s)->obj_at_addr<narrowOop>(src_pos), \"sanity\");\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, nullptr) ==\n-           objArrayOop(d)->obj_at_addr<narrowOop>(dst_pos), \"sanity\");\n-    do_copy(s, src_offset, d, dst_offset, length, CHECK);\n-  } else {\n-    size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset<oop>(src_pos);\n-    size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset<oop>(dst_pos);\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, nullptr) ==\n-           objArrayOop(s)->obj_at_addr<oop>(src_pos), \"sanity\");\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, nullptr) ==\n-           objArrayOop(d)->obj_at_addr<oop>(dst_pos), \"sanity\");\n-    do_copy(s, src_offset, d, dst_offset, length, CHECK);\n-  }\n+  assert(s->is_refArray() && d->is_refArray(), \"Must be\");\n+  RefArrayKlass::cast(s->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);\n@@ -344,0 +306,26 @@\n+  if (_next_refined_array_klass != nullptr && !CDSConfig::is_dumping_dynamic_archive()) {\n+    it->push(&_next_refined_array_klass);\n+  }\n+}\n+\n+void ObjArrayKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {\n+  ArrayKlass::restore_unshareable_info(loader_data, protection_domain, CHECK);\n+  if (_next_refined_array_klass != nullptr) {\n+    _next_refined_array_klass->restore_unshareable_info(loader_data, protection_domain, CHECK);\n+  }\n+}\n+\n+void ObjArrayKlass::remove_unshareable_info() {\n+  ArrayKlass::remove_unshareable_info();\n+  if (_next_refined_array_klass != nullptr && !CDSConfig::is_dumping_dynamic_archive()) {\n+    _next_refined_array_klass->remove_unshareable_info();\n+  } else {\n+    _next_refined_array_klass = nullptr;\n+  }\n+}\n+\n+void ObjArrayKlass::remove_java_mirror() {\n+  ArrayKlass::remove_java_mirror();\n+  if (_next_refined_array_klass != nullptr) {\n+    _next_refined_array_klass->remove_java_mirror();\n+  }\n@@ -370,0 +358,39 @@\n+ObjArrayKlass* ObjArrayKlass::klass_with_properties(ArrayKlass::ArrayProperties props, TRAPS) {\n+  assert(props != ArrayProperties::INVALID, \"Sanity check\");\n+\n+  if (properties() == props) {\n+    assert(is_refArray_klass() || is_flatArray_klass(), \"Must be a concrete array klass\");\n+    return this;\n+  }\n+\n+  ObjArrayKlass* ak = next_refined_array_klass_acquire();\n+  if (ak == nullptr) {\n+    \/\/ Ensure atomic creation of refined array klasses\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    if (next_refined_array_klass() ==  nullptr) {\n+      ArrayDescription ad = ObjArrayKlass::array_layout_selection(element_klass(), props);\n+      switch (ad._kind) {\n+        case Klass::RefArrayKlassKind: {\n+          ak = RefArrayKlass::allocate_refArray_klass(class_loader_data(), dimension(), element_klass(), props, CHECK_NULL);\n+          break;\n+        }\n+        case Klass::FlatArrayKlassKind: {\n+          assert(dimension() == 1, \"Flat arrays can only be dimension 1 arrays\");\n+          ak = FlatArrayKlass::allocate_klass(element_klass(), props, ad._layout_kind, CHECK_NULL);\n+          break;\n+        }\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      release_set_next_refined_klass(ak);\n+    }\n+  }\n+\n+  ak = next_refined_array_klass();\n+  assert(ak != nullptr, \"should be set\");\n+  THREAD->check_possible_safepoint();\n+  return ak->klass_with_properties(props, THREAD); \/\/ why not CHECK_NULL ?\n+}\n+\n+\n@@ -391,17 +418,1 @@\n-  ArrayKlass::oop_print_on(obj, st);\n-  assert(obj->is_objArray(), \"must be objArray\");\n-  objArrayOop oa = objArrayOop(obj);\n-  int print_len = MIN2(oa->length(), MaxElementPrintSize);\n-  for(int index = 0; index < print_len; index++) {\n-    st->print(\" - %3d : \", index);\n-    if (oa->obj_at(index) != nullptr) {\n-      oa->obj_at(index)->print_value_on(st);\n-      st->cr();\n-    } else {\n-      st->print_cr(\"null\");\n-    }\n-  }\n-  int remaining = oa->length() - print_len;\n-  if (remaining > 0) {\n-    st->print_cr(\" - <%d more elements, increase MaxElementPrintSize to print>\", remaining);\n-  }\n+  ShouldNotReachHere();\n@@ -413,10 +424,1 @@\n-  assert(obj->is_objArray(), \"must be objArray\");\n-  st->print(\"a \");\n-  element_klass()->print_value_on(st);\n-  int len = objArrayOop(obj)->length();\n-  st->print(\"[%d] \", len);\n-  if (obj != nullptr) {\n-    obj->print_address_on(st);\n-  } else {\n-    st->print_cr(\"null\");\n-  }\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":148,"deletions":146,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+ protected:\n+  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n+  ObjArrayKlass* _next_refined_array_klass;\n@@ -47,0 +50,1 @@\n+ protected:\n@@ -48,2 +52,2 @@\n-  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free);\n-  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, bool null_free, TRAPS);\n+  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, KlassKind kind, ArrayKlass::ArrayProperties props, markWord mw);\n+  static ObjArrayKlass* allocate_klass(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, ArrayKlass::ArrayProperties props, TRAPS);\n@@ -54,0 +58,13 @@\n+  \/\/ Compiler\/Interpreter offset\n+  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ObjArrayKlass, _element_klass)); }\n+\n+  virtual Klass* element_klass() const      { return _element_klass; }\n+  virtual void set_element_klass(Klass* k)  { _element_klass = k; }\n+\n+  ObjArrayKlass* next_refined_array_klass() const      { return _next_refined_array_klass; }\n+  inline ObjArrayKlass* next_refined_array_klass_acquire() const;\n+  void set_next_refined_klass_klass(ObjArrayKlass* ak) { _next_refined_array_klass = ak; }\n+  inline void release_set_next_refined_klass(ObjArrayKlass* ak);\n+  ObjArrayKlass* klass_with_properties(ArrayKlass::ArrayProperties properties, TRAPS);\n+  static ByteSize next_refined_array_klass_offset() { return byte_offset_of(ObjArrayKlass, _next_refined_array_klass); }\n+\n@@ -70,2 +87,1 @@\n-                                                int n, Klass* element_klass,\n-                                                bool null_free, TRAPS);\n+                                                int n, Klass* element_klass, TRAPS);\n@@ -73,1 +89,3 @@\n-  objArrayOop allocate(int length, TRAPS);\n+  static ArrayDescription array_layout_selection(Klass* element, ArrayProperties properties);\n+\n+  virtual objArrayOop allocate_instance(int length, ArrayProperties props, TRAPS);\n@@ -83,0 +101,3 @@\n+  virtual void remove_unshareable_info();\n+  virtual void remove_java_mirror();\n+  void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);\n@@ -84,6 +105,0 @@\n- private:\n-  \/\/ Either oop or narrowOop depending on UseCompressedOops.\n-  \/\/ must be called from within ObjArrayKlass.cpp\n-  void do_copy(arrayOop s, size_t src_offset,\n-               arrayOop d, size_t dst_offset,\n-               int length, TRAPS);\n@@ -145,1 +160,1 @@\n-  void oop_print_value_on(oop obj, outputStream* st);\n+  virtual void oop_print_value_on(oop obj, outputStream* st);\n@@ -147,1 +162,1 @@\n-  void oop_print_on      (oop obj, outputStream* st);\n+  virtual void oop_print_on      (oop obj, outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,0 +40,9 @@\n+\n+inline ObjArrayKlass* ObjArrayKlass::next_refined_array_klass_acquire() const {\n+  return Atomic::load_acquire(&_next_refined_array_klass);\n+}\n+\n+inline void ObjArrayKlass::release_set_next_refined_klass(ObjArrayKlass* k) {\n+  Atomic::release_store(&_next_refined_array_klass, k);\n+}\n+\n@@ -41,6 +51,1 @@\n-  T* p         = (T*)a->base();\n-  T* const end = p + a->length();\n-\n-  for (;p < end; p++) {\n-    Devirtualizer::do_oop(closure, p);\n-  }\n+  ShouldNotReachHere();\n@@ -52,0 +57,1 @@\n+  ShouldNotReachHere();\n@@ -53,16 +59,0 @@\n-  T* const l = (T*)low;\n-  T* const h = (T*)high;\n-\n-  T* p   = (T*)a->base();\n-  T* end = p + a->length();\n-\n-  if (p < l) {\n-    p = l;\n-  }\n-  if (end > h) {\n-    end = h;\n-  }\n-\n-  for (;p < end; ++p) {\n-    Devirtualizer::do_oop(closure, p);\n-  }\n@@ -73,8 +63,1 @@\n-  assert(obj->is_array(), \"obj must be array\");\n-  objArrayOop a = objArrayOop(obj);\n-\n-  if (Devirtualizer::do_metadata(closure)) {\n-    Devirtualizer::do_klass(closure, obj->klass());\n-  }\n-\n-  oop_oop_iterate_elements<T>(a, closure);\n+  ShouldNotReachHere();\n@@ -85,2 +68,1 @@\n-  \/\/ No reverse implementation ATM.\n-  oop_oop_iterate<T>(obj, closure);\n+  ShouldNotReachHere();\n@@ -91,8 +73,1 @@\n-  assert(obj->is_array(), \"obj must be array\");\n-  objArrayOop a  = objArrayOop(obj);\n-\n-  if (Devirtualizer::do_metadata(closure)) {\n-    Devirtualizer::do_klass(closure, a->klass());\n-  }\n-\n-  oop_oop_iterate_elements_bounded<T>(a, closure, mr.start(), mr.end());\n+  ShouldNotReachHere();\n@@ -105,4 +80,1 @@\n-  T* low = (T*)a->base() + start;\n-  T* high = (T*)a->base() + end;\n-\n-  oop_oop_iterate_elements_bounded<T>(a, closure, low, high);\n+  ShouldNotReachHere();\n@@ -114,5 +86,1 @@\n-  if (UseCompressedOops) {\n-    ((ObjArrayKlass*)klass())->oop_oop_iterate_range<narrowOop>(this, blk, start, end);\n-  } else {\n-    ((ObjArrayKlass*)klass())->oop_oop_iterate_range<oop>(this, blk, start, end);\n-  }\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":17,"deletions":49,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,10 +30,0 @@\n-oop objArrayOopDesc::replace_if_null(int index, oop exchange_value) {\n-  ptrdiff_t offs;\n-  if (UseCompressedOops) {\n-    offs = objArrayOopDesc::obj_at_offset<narrowOop>(index);\n-  } else {\n-    offs = objArrayOopDesc::obj_at_offset<oop>(index);\n-  }\n-  return HeapAccess<IS_ARRAY>::oop_atomic_cmpxchg_at(as_oop(), offs, (oop)nullptr, exchange_value);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  inline static objArrayOop cast(oop o);\n+\n@@ -65,0 +67,1 @@\n+  oop obj_at(int index, TRAPS) const;\n@@ -67,14 +70,1 @@\n-\n-  oop replace_if_null(int index, oop exchange_value);\n-\n-  \/\/ Sizing\n-  size_t object_size()        { return object_size(length()); }\n-\n-  static size_t object_size(int length) {\n-    \/\/ This returns the object size in HeapWords.\n-    size_t asz = (size_t)length * heapOopSize;\n-    size_t size_words = heap_word_size(base_offset_in_bytes() + asz);\n-    size_t osz = align_object_size(size_words);\n-    assert(osz < max_jint, \"no overflow\");\n-    return osz;\n-  }\n+  void obj_at_put(int index, oop value, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"oops\/refArrayKlass.inline.hpp\"\n@@ -37,0 +39,5 @@\n+inline objArrayOop objArrayOopDesc::cast(oop o) {\n+  assert(o->is_objArray(), \"Must be a refArray\");\n+  return (objArrayOop)o;\n+}\n+\n@@ -44,2 +51,14 @@\n-  ptrdiff_t offset = UseCompressedOops ? obj_at_offset<narrowOop>(index) : obj_at_offset<oop>(index);\n-  return HeapAccess<IS_ARRAY>::oop_load_at(as_oop(), offset);\n+  if (is_flatArray()) {\n+    return ((const flatArrayOopDesc* )this)->obj_at(index);\n+  } else {\n+    return ((const refArrayOopDesc* )this)->obj_at(index);\n+  }\n+}\n+\n+inline oop objArrayOopDesc::obj_at(int index, TRAPS) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  if (is_flatArray()) {\n+    return ((const flatArrayOopDesc* )this)->obj_at(index, CHECK_NULL);\n+  } else {\n+    return ((const refArrayOopDesc* )this)->obj_at(index, CHECK_NULL);\n+  }\n@@ -50,2 +69,14 @@\n-  ptrdiff_t offset = UseCompressedOops ? obj_at_offset<narrowOop>(index) : obj_at_offset<oop>(index);\n-  HeapAccess<IS_ARRAY>::oop_store_at(as_oop(), offset, value);\n+  if (is_flatArray()) {\n+    ((flatArrayOopDesc* )this)->obj_at_put(index, value);\n+  } else {\n+    ((refArrayOopDesc* )this)->obj_at_put(index, value);\n+  }\n+}\n+\n+inline void objArrayOopDesc::obj_at_put(int index, oop value, TRAPS) {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  if (is_flatArray()) {\n+    ((flatArrayOopDesc* )this)->obj_at_put(index, value, CHECK);\n+  } else {\n+    ((refArrayOopDesc* )this)->obj_at_put(index, value, CHECK);\n+  }\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.inline.hpp","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+bool oopDesc::is_refArray_noinline()        const { return is_refArray();         }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  inline bool is_refArray()         const;\n@@ -138,0 +139,1 @@\n+  inline bool is_refined_objArray() const;\n@@ -145,0 +147,1 @@\n+  bool is_refArray_noinline()         const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+bool oopDesc::is_refArray()    const { return klass()->is_refArray_klass();             }\n@@ -234,0 +235,1 @@\n+bool oopDesc::is_refined_objArray() const { return klass()->is_refined_objArray_klass(); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+typedef class     refArrayOopDesc*            refArrayOop;\n@@ -160,0 +161,1 @@\n+DEF_OOP(refArray);\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,379 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/packageEntry.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/refArrayKlass.inline.hpp\"\n+#include \"oops\/refArrayOop.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+RefArrayKlass *RefArrayKlass::allocate_klass(ClassLoaderData *loader_data, int n,\n+                                       Klass *k, Symbol *name, ArrayKlass::ArrayProperties props,\n+                                       TRAPS) {\n+  assert(RefArrayKlass::header_size() <= InstanceKlass::header_size(),\n+         \"array klasses must be same size as InstanceKlass\");\n+\n+  int size = ArrayKlass::static_size(RefArrayKlass::header_size());\n+\n+  return new (loader_data, size, THREAD) RefArrayKlass(n, k, name, props);\n+}\n+\n+RefArrayKlass* RefArrayKlass::allocate_refArray_klass(ClassLoaderData *loader_data, int n,\n+                                       Klass *element_klass, ArrayKlass::ArrayProperties props,\n+                                       TRAPS) {\n+  assert(!ArrayKlass::is_null_restricted(props) || (n == 1 && element_klass->is_inline_klass()),\n+         \"null-free unsupported\");\n+\n+  \/\/ Eagerly allocate the direct array supertype.\n+  Klass *super_klass = nullptr;\n+  if (!Universe::is_bootstrapping() || vmClasses::Object_klass_loaded()) {\n+    assert(MultiArray_lock->holds_lock(THREAD),\n+           \"must hold lock after bootstrapping\");\n+    Klass *element_super = element_klass->super();\n+    super_klass = element_klass->array_klass(CHECK_NULL);\n+  }\n+\n+  \/\/ Create type name for klass.\n+  Symbol *name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+\n+  \/\/ Initialize instance variables\n+  RefArrayKlass *oak = RefArrayKlass::allocate_klass(loader_data, n, element_klass,\n+                                               name, props, CHECK_NULL);\n+\n+  ModuleEntry *module = oak->module();\n+  assert(module != nullptr, \"No module entry for array\");\n+\n+  \/\/ Call complete_create_array_klass after all instance variables has been\n+  \/\/ initialized.\n+  ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);\n+\n+  \/\/ Add all classes to our internal class loader list here,\n+  \/\/ including classes in the bootstrap (null) class loader.\n+  \/\/ Do this step after creating the mirror so that if the\n+  \/\/ mirror creation fails, loaded_classes_do() doesn't find\n+  \/\/ an array class without a mirror.\n+  loader_data->add_class(oak);\n+\n+  return oak;\n+}\n+\n+RefArrayKlass::RefArrayKlass(int n, Klass *element_klass, Symbol *name,\n+                             ArrayKlass::ArrayProperties props)\n+    : ObjArrayKlass(n, element_klass, name, Kind, props,\n+                    ArrayKlass::is_null_restricted(props) ? markWord::null_free_array_prototype() : markWord::prototype()) {\n+  set_dimension(n);\n+  set_element_klass(element_klass);\n+\n+  Klass *bk;\n+  if (element_klass->is_objArray_klass()) {\n+    bk = ObjArrayKlass::cast(element_klass)->bottom_klass();\n+  } else if (element_klass->is_flatArray_klass()) {\n+    bk = FlatArrayKlass::cast(element_klass)->element_klass();\n+  } else {\n+    bk = element_klass;\n+  }\n+  assert(bk != nullptr && (bk->is_instance_klass() || bk->is_typeArray_klass()),\n+         \"invalid bottom klass\");\n+  set_bottom_klass(bk);\n+  set_class_loader_data(bk->class_loader_data());\n+\n+  if (element_klass->is_array_klass()) {\n+    set_lower_dimension(ArrayKlass::cast(element_klass));\n+  }\n+\n+  int lh = array_layout_helper(T_OBJECT);\n+  if (ArrayKlass::is_null_restricted(props)) {\n+    assert(n == 1, \"Bytecode does not support null-free multi-dim\");\n+    lh = layout_helper_set_null_free(lh);\n+#ifdef _LP64\n+    assert(prototype_header().is_null_free_array(), \"sanity\");\n+#endif\n+  }\n+  set_layout_helper(lh);\n+  assert(is_array_klass(), \"sanity\");\n+  assert(is_refArray_klass(), \"sanity\");\n+}\n+\n+size_t RefArrayKlass::oop_size(oop obj) const {\n+  \/\/ In this assert, we cannot safely access the Klass* with compact headers,\n+  \/\/ because size_given_klass() calls oop_size() on objects that might be\n+  \/\/ concurrently forwarded, which would overwrite the Klass*.\n+  assert(UseCompactObjectHeaders || obj->is_refArray(), \"must be a reference array\");\n+  return refArrayOop(obj)->object_size();\n+}\n+\n+objArrayOop RefArrayKlass::allocate_instance(int length, ArrayProperties props, TRAPS) {\n+  check_array_allocation_length(\n+      length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n+  size_t size = refArrayOopDesc::object_size(length);\n+  objArrayOop array = (objArrayOop)Universe::heap()->array_allocate(\n+      this, size, length,\n+      \/* do_zero *\/ true, CHECK_NULL);\n+  assert(array->is_refArray(), \"Must be\");\n+  objArrayHandle array_h(THREAD, array);\n+  return array_h();\n+}\n+\n+\n+\/\/ Either oop or narrowOop depending on UseCompressedOops.\n+void RefArrayKlass::do_copy(arrayOop s, size_t src_offset, arrayOop d,\n+                            size_t dst_offset, int length, TRAPS) {\n+  if (s == d) {\n+    \/\/ since source and destination are equal we do not need conversion checks.\n+    assert(length > 0, \"sanity check\");\n+    ArrayAccess<>::oop_arraycopy(s, src_offset, d, dst_offset, length);\n+  } else {\n+    \/\/ We have to make sure all elements conform to the destination array\n+    Klass *bound = RefArrayKlass::cast(d->klass())->element_klass();\n+    Klass *stype = RefArrayKlass::cast(s->klass())->element_klass();\n+    \/\/ Perform null check if dst is null-free but src has no such guarantee\n+    bool null_check = ((!s->klass()->is_null_free_array_klass()) &&\n+                       d->klass()->is_null_free_array_klass());\n+    if (stype == bound || stype->is_subtype_of(bound)) {\n+      if (null_check) {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL>::oop_arraycopy(\n+            s, src_offset, d, dst_offset, length);\n+      } else {\n+        ArrayAccess<ARRAYCOPY_DISJOINT>::oop_arraycopy(s, src_offset, d,\n+                                                       dst_offset, length);\n+      }\n+    } else {\n+      if (null_check) {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST |\n+                    ARRAYCOPY_NOTNULL>::oop_arraycopy(s, src_offset, d,\n+                                                      dst_offset, length);\n+      } else {\n+        ArrayAccess<ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST>::oop_arraycopy(\n+            s, src_offset, d, dst_offset, length);\n+      }\n+    }\n+  }\n+}\n+\n+void RefArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos,\n+                               int length, TRAPS) {\n+  assert(s->is_refArray(), \"must be a reference array\");\n+\n+  if (UseArrayFlattening) {\n+    if (d->is_flatArray()) {\n+      FlatArrayKlass::cast(d->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);\n+      return;\n+    }\n+    if (s->is_flatArray()) {\n+      FlatArrayKlass::cast(s->klass())->copy_array(s, src_pos, d, dst_pos, length, THREAD);\n+      return;\n+    }\n+  }\n+\n+  if (!d->is_refArray()) {\n+    ResourceMark rm(THREAD);\n+    stringStream ss;\n+    if (d->is_typeArray()) {\n+      ss.print(\n+          \"arraycopy: type mismatch: can not copy object array[] into %s[]\",\n+          type2name_tab[ArrayKlass::cast(d->klass())->element_type()]);\n+    } else {\n+      ss.print(\"arraycopy: destination type %s is not an array\",\n+               d->klass()->external_name());\n+    }\n+    THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+  }\n+\n+  \/\/ Check is all offsets and lengths are non negative\n+  if (src_pos < 0 || dst_pos < 0 || length < 0) {\n+    \/\/ Pass specific exception reason.\n+    ResourceMark rm(THREAD);\n+    stringStream ss;\n+    if (src_pos < 0) {\n+      ss.print(\"arraycopy: source index %d out of bounds for object array[%d]\",\n+               src_pos, s->length());\n+    } else if (dst_pos < 0) {\n+      ss.print(\n+          \"arraycopy: destination index %d out of bounds for object array[%d]\",\n+          dst_pos, d->length());\n+    } else {\n+      ss.print(\"arraycopy: length %d is negative\", length);\n+    }\n+    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(),\n+              ss.as_string());\n+  }\n+  \/\/ Check if the ranges are valid\n+  if ((((unsigned int)length + (unsigned int)src_pos) >\n+       (unsigned int)s->length()) ||\n+      (((unsigned int)length + (unsigned int)dst_pos) >\n+       (unsigned int)d->length())) {\n+    \/\/ Pass specific exception reason.\n+    ResourceMark rm(THREAD);\n+    stringStream ss;\n+    if (((unsigned int)length + (unsigned int)src_pos) >\n+        (unsigned int)s->length()) {\n+      ss.print(\n+          \"arraycopy: last source index %u out of bounds for object array[%d]\",\n+          (unsigned int)length + (unsigned int)src_pos, s->length());\n+    } else {\n+      ss.print(\"arraycopy: last destination index %u out of bounds for object \"\n+               \"array[%d]\",\n+               (unsigned int)length + (unsigned int)dst_pos, d->length());\n+    }\n+    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(),\n+              ss.as_string());\n+  }\n+\n+  \/\/ Special case. Boundary cases must be checked first\n+  \/\/ This allows the following call: copy_array(s, s.length(), d.length(), 0).\n+  \/\/ This is correct, since the position is supposed to be an 'in between\n+  \/\/ point', i.e., s.length(), points to the right of the last element.\n+  if (length == 0) {\n+    return;\n+  }\n+  if (UseCompressedOops) {\n+    size_t src_offset =\n+        (size_t)refArrayOopDesc::obj_at_offset<narrowOop>(src_pos);\n+    size_t dst_offset =\n+        (size_t)refArrayOopDesc::obj_at_offset<narrowOop>(dst_pos);\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, nullptr) ==\n+               refArrayOop(s)->obj_at_addr<narrowOop>(src_pos),\n+           \"sanity\");\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, nullptr) ==\n+               refArrayOop(d)->obj_at_addr<narrowOop>(dst_pos),\n+           \"sanity\");\n+    do_copy(s, src_offset, d, dst_offset, length, CHECK);\n+  } else {\n+    size_t src_offset = (size_t)refArrayOopDesc::obj_at_offset<oop>(src_pos);\n+    size_t dst_offset = (size_t)refArrayOopDesc::obj_at_offset<oop>(dst_pos);\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, nullptr) ==\n+               refArrayOop(s)->obj_at_addr<oop>(src_pos),\n+           \"sanity\");\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, nullptr) ==\n+               refArrayOop(d)->obj_at_addr<oop>(dst_pos),\n+           \"sanity\");\n+    do_copy(s, src_offset, d, dst_offset, length, CHECK);\n+  }\n+}\n+\n+void RefArrayKlass::initialize(TRAPS) {\n+  bottom_klass()->initialize(\n+      THREAD); \/\/ dispatches to either InstanceKlass or TypeArrayKlass\n+}\n+\n+void RefArrayKlass::metaspace_pointers_do(MetaspaceClosure *it) {\n+  ObjArrayKlass::metaspace_pointers_do(it);\n+}\n+\n+\/\/ Printing\n+\n+void RefArrayKlass::print_on(outputStream *st) const {\n+#ifndef PRODUCT\n+  Klass::print_on(st);\n+  st->print(\" - element klass: \");\n+  element_klass()->print_value_on(st);\n+  st->cr();\n+#endif \/\/ PRODUCT\n+}\n+\n+void RefArrayKlass::print_value_on(outputStream *st) const {\n+  assert(is_klass(), \"must be klass\");\n+\n+  element_klass()->print_value_on(st);\n+  st->print(\"[]\");\n+}\n+\n+#ifndef PRODUCT\n+\n+void RefArrayKlass::oop_print_on(oop obj, outputStream *st) {\n+  ArrayKlass::oop_print_on(obj, st);\n+  assert(obj->is_refArray(), \"must be refArray\");\n+  refArrayOop oa = refArrayOop(obj);\n+  int print_len = MIN2(oa->length(), MaxElementPrintSize);\n+  for (int index = 0; index < print_len; index++) {\n+    st->print(\" - %3d : \", index);\n+    if (oa->obj_at(index) != nullptr) {\n+      oa->obj_at(index)->print_value_on(st);\n+      st->cr();\n+    } else {\n+      st->print_cr(\"null\");\n+    }\n+  }\n+  int remaining = oa->length() - print_len;\n+  if (remaining > 0) {\n+    st->print_cr(\" - <%d more elements, increase MaxElementPrintSize to print>\",\n+                 remaining);\n+  }\n+}\n+\n+#endif \/\/ PRODUCT\n+\n+void RefArrayKlass::oop_print_value_on(oop obj, outputStream *st) {\n+  assert(obj->is_refArray(), \"must be refArray\");\n+  st->print(\"a \");\n+  element_klass()->print_value_on(st);\n+  int len = refArrayOop(obj)->length();\n+  st->print(\"[%d] \", len);\n+  if (obj != nullptr) {\n+    obj->print_address_on(st);\n+  } else {\n+    st->print_cr(\"null\");\n+  }\n+}\n+\n+\/\/ Verification\n+\n+void RefArrayKlass::verify_on(outputStream *st) {\n+  ArrayKlass::verify_on(st);\n+  guarantee(element_klass()->is_klass(), \"should be klass\");\n+  guarantee(bottom_klass()->is_klass(), \"should be klass\");\n+  Klass *bk = bottom_klass();\n+  guarantee(bk->is_instance_klass() || bk->is_typeArray_klass() ||\n+                bk->is_flatArray_klass(),\n+            \"invalid bottom klass\");\n+}\n+\n+void RefArrayKlass::oop_verify_on(oop obj, outputStream *st) {\n+  ArrayKlass::oop_verify_on(obj, st);\n+  guarantee(obj->is_refArray(), \"must be refArray\");\n+  guarantee(obj->is_null_free_array() || (!is_null_free_array_klass()),\n+            \"null-free klass but not object\");\n+  refArrayOop oa = refArrayOop(obj);\n+  for (int index = 0; index < oa->length(); index++) {\n+    guarantee(oopDesc::is_oop_or_null(oa->obj_at(index)), \"should be oop\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/refArrayKlass.cpp","additions":379,"deletions":0,"binary":false,"changes":379,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_REFARRAYKLASS_HPP\n+#define SHARE_OOPS_REFARRAYKLASS_HPP\n+\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class ClassLoaderData;\n+\n+\/\/ RefArrayKlass is the klass for arrays of references\n+\n+class RefArrayKlass : public ObjArrayKlass {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+ public:\n+  static const KlassKind Kind = RefArrayKlassKind;\n+\n+ private:\n+  \/\/ Constructor\n+  RefArrayKlass(int n, Klass *element_klass, Symbol *name, ArrayKlass::ArrayProperties props);\n+  static RefArrayKlass* allocate_klass(ClassLoaderData *loader_data, int n, Klass *k, Symbol *name,\n+                                       ArrayKlass::ArrayProperties props, TRAPS);\n+\n+ public:\n+  \/\/ For dummy objects\n+  RefArrayKlass() {}\n+\n+  \/\/ Dispatched operation\n+  DEBUG_ONLY(bool is_refArray_klass_slow() const { return true; })\n+  size_t oop_size(oop obj) const;  \/\/ TODO FIXME make it virtual in objArrayKlass\n+\n+  \/\/ Allocation\n+  static RefArrayKlass *allocate_refArray_klass(ClassLoaderData *loader_data,\n+                                                int n, Klass *element_klass,\n+                                                ArrayKlass::ArrayProperties props, TRAPS);\n+\n+  objArrayOop allocate_instance(int length, ArrayProperties props, TRAPS);\n+\n+  \/\/ Copying TODO FIXME make copying method in objArrayKlass virtual and default implementation invalid (ShouldNotReachHere())\n+  void copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS);\n+\n+  virtual void metaspace_pointers_do(MetaspaceClosure *iter);\n+\n+ private:\n+  \/\/ Either oop or narrowOop depending on UseCompressedOops.\n+  \/\/ must be called from within ObjArrayKlass.cpp\n+  void do_copy(arrayOop s, size_t src_offset,\n+               arrayOop d, size_t dst_offset,\n+               int length, TRAPS);\n+\n+ public:\n+  static RefArrayKlass *cast(Klass *k) {\n+    return const_cast<RefArrayKlass *>(cast(const_cast<const Klass *>(k)));\n+  }\n+\n+  static const RefArrayKlass *cast(const Klass *k) {\n+    assert(k->is_refArray_klass(), \"cast to RefArrayKlass\");\n+    return static_cast<const RefArrayKlass *>(k);\n+  }\n+\n+  \/\/ Sizing\n+  static int header_size() { return sizeof(RefArrayKlass) \/ wordSize; }\n+  int size() const { return ArrayKlass::static_size(header_size()); }\n+\n+  \/\/ Initialization (virtual from Klass)\n+  void initialize(TRAPS);\n+\n+  \/\/ Oop fields (and metadata) iterators\n+  \/\/\n+  \/\/ The RefArrayKlass iterators also visits the Object's klass.\n+\n+  \/\/ Iterate over oop elements and metadata.\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate(oop obj, OopClosureType *closure);\n+\n+  \/\/ Iterate over oop elements and metadata.\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate_reverse(oop obj, OopClosureType *closure);\n+\n+  \/\/ Iterate over oop elements within mr, and metadata.\n+  template <typename T, typename OopClosureType>\n+  inline void oop_oop_iterate_bounded(oop obj, OopClosureType *closure, MemRegion mr);\n+\n+  \/\/ Iterate over oop elements within [start, end), and metadata.\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_range(refArrayOop a, OopClosureType *closure, int start, int end);\n+\n+ public:\n+  \/\/ Iterate over all oop elements.\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements(refArrayOop a, OopClosureType *closure);\n+\n+ private:\n+  \/\/ Iterate over all oop elements with indices within mr.\n+  template <typename T, class OopClosureType>\n+  inline void oop_oop_iterate_elements_bounded(refArrayOop a, OopClosureType *closure, void *low, void *high);\n+\n+ public:\n+  \/\/ Printing\n+  void print_on(outputStream *st) const;\n+  void print_value_on(outputStream *st) const;\n+\n+  void oop_print_value_on(oop obj, outputStream *st);\n+#ifndef PRODUCT\n+  void oop_print_on(oop obj, outputStream *st);\n+#endif \/\/ PRODUCT\n+\n+  \/\/ Verification\n+  void verify_on(outputStream *st);\n+\n+  void oop_verify_on(oop obj, outputStream *st);\n+};\n+\n+#endif \/\/ SHARE_OOPS_REFARRAYKLASS_HPP\n","filename":"src\/hotspot\/share\/oops\/refArrayKlass.hpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_REFARRAYKLASS_INLINE_HPP\n+#define SHARE_OOPS_REFARRAYKLASS_INLINE_HPP\n+\n+#include \"oops\/refArrayKlass.hpp\"\n+\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/refArrayOop.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/devirtualizer.inline.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+template <typename T, class OopClosureType>\n+void RefArrayKlass::oop_oop_iterate_elements(refArrayOop a,\n+                                             OopClosureType *closure) {\n+  T *p = (T *)a->base();\n+  T *const end = p + a->length();\n+\n+  for (; p < end; p++) {\n+    Devirtualizer::do_oop(closure, p);\n+  }\n+}\n+\n+template <typename T, class OopClosureType>\n+void RefArrayKlass::oop_oop_iterate_elements_bounded(refArrayOop a,\n+                                                     OopClosureType *closure,\n+                                                     void *low, void *high) {\n+\n+  T *const l = (T *)low;\n+  T *const h = (T *)high;\n+\n+  T *p = (T *)a->base();\n+  T *end = p + a->length();\n+\n+  if (p < l) {\n+    p = l;\n+  }\n+  if (end > h) {\n+    end = h;\n+  }\n+\n+  for (; p < end; ++p) {\n+    Devirtualizer::do_oop(closure, p);\n+  }\n+}\n+\n+template <typename T, typename OopClosureType>\n+void RefArrayKlass::oop_oop_iterate(oop obj, OopClosureType *closure) {\n+  assert(obj->is_array(), \"obj must be array\");\n+  refArrayOop a = refArrayOop(obj);\n+\n+  if (Devirtualizer::do_metadata(closure)) {\n+    Devirtualizer::do_klass(closure, obj->klass());\n+  }\n+\n+  oop_oop_iterate_elements<T>(a, closure);\n+}\n+\n+template <typename T, typename OopClosureType>\n+void RefArrayKlass::oop_oop_iterate_reverse(oop obj, OopClosureType *closure) {\n+  \/\/ No reverse implementation ATM.\n+  oop_oop_iterate<T>(obj, closure);\n+}\n+\n+template <typename T, typename OopClosureType>\n+void RefArrayKlass::oop_oop_iterate_bounded(oop obj, OopClosureType *closure,\n+                                            MemRegion mr) {\n+  assert(obj->is_array(), \"obj must be array\");\n+  refArrayOop a = refArrayOop(obj);\n+\n+  if (Devirtualizer::do_metadata(closure)) {\n+    Devirtualizer::do_klass(closure, a->klass());\n+  }\n+\n+  oop_oop_iterate_elements_bounded<T>(a, closure, mr.start(), mr.end());\n+}\n+\n+\/\/ Like oop_oop_iterate but only iterates over a specified range and only used\n+\/\/ for objArrayOops.\n+template <typename T, class OopClosureType>\n+void RefArrayKlass::oop_oop_iterate_range(refArrayOop a,\n+                                          OopClosureType *closure, int start,\n+                                          int end) {\n+  T *low = (T *)a->base() + start;\n+  T *high = (T *)a->base() + end;\n+\n+  oop_oop_iterate_elements_bounded<T>(a, closure, low, high);\n+}\n+\n+\/\/ Placed here to resolve include cycle between objArrayKlass.inline.hpp and\n+\/\/ objArrayOop.inline.hpp\n+template <typename OopClosureType>\n+void refArrayOopDesc::oop_iterate_range(OopClosureType *blk, int start,\n+                                        int end) {\n+  if (UseCompressedOops) {\n+    ((RefArrayKlass *)klass())\n+        ->oop_oop_iterate_range<narrowOop>(this, blk, start, end);\n+  } else {\n+    ((RefArrayKlass *)klass())\n+        ->oop_oop_iterate_range<oop>(this, blk, start, end);\n+  }\n+}\n+\n+#endif \/\/ SHARE_OOPS_REFARRAYKLASS_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/refArrayKlass.inline.hpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/refArrayKlass.hpp\"\n+#include \"oops\/refArrayOop.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+oop refArrayOopDesc::replace_if_null(int index, oop exchange_value) {\n+  ptrdiff_t offs;\n+  if (UseCompressedOops) {\n+    offs = refArrayOopDesc::obj_at_offset<narrowOop>(index);\n+  } else {\n+    offs = refArrayOopDesc::obj_at_offset<oop>(index);\n+  }\n+  return HeapAccess<IS_ARRAY>::oop_atomic_cmpxchg_at(as_oop(), offs, (oop)nullptr, exchange_value);\n+}\n+\n+Klass* refArrayOopDesc::element_klass() {\n+  return RefArrayKlass::cast(klass())->element_klass();\n+}\n","filename":"src\/hotspot\/share\/oops\/refArrayOop.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_REFARRAYOOP_HPP\n+#define SHARE_OOPS_REFARRAYOOP_HPP\n+\n+#include \"oops\/arrayOop.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include <type_traits>\n+\n+class Klass;\n+\n+\/\/ An refArrayOop is an array containing references (oops).\n+\/\/ Evaluating \"String arg[10]\" will create an refArrayOop.\n+\n+class refArrayOopDesc : public arrayOopDesc {\n+  friend class ArchiveHeapWriter;\n+  friend class RefArrayKlass;\n+  friend class Runtime1;\n+  friend class psPromotionManager;\n+  friend class CSetMarkWordClosure;\n+  friend class Continuation;\n+  template <typename T>\n+  friend class RawOopWriter;\n+\n+  template <class T> T* obj_at_addr(int index) const;\n+\n+  template <class T>\n+  static ptrdiff_t obj_at_offset(int index) {\n+    return base_offset_in_bytes() + sizeof(T) * index;\n+  }\n+\n+ public:\n+  \/\/ Returns the offset of the first element.\n+  static int base_offset_in_bytes() {\n+    return arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+  }\n+\n+  inline static refArrayOop cast(oop o);\n+\n+  \/\/ base is the address following the header.\n+  inline HeapWord* base() const;\n+\n+  \/\/ Accessing\n+  oop obj_at(int index) const;\n+  oop obj_at(int index, TRAPS) const;\n+\n+  void obj_at_put(int index, oop value);\n+  void obj_at_put(int index, oop value, TRAPS);\n+\n+  oop replace_if_null(int index, oop exchange_value);\n+\n+  \/\/ Sizing\n+  size_t object_size()        { return object_size(length()); }\n+\n+  static size_t object_size(int length) {\n+    \/\/ This returns the object size in HeapWords.\n+    size_t asz = (size_t)length * heapOopSize;\n+    size_t size_words = heap_word_size(base_offset_in_bytes() + asz);\n+    size_t osz = align_object_size(size_words);\n+    assert(osz < max_jint, \"no overflow\");\n+    return osz;\n+  }\n+\n+  Klass* element_klass();\n+\n+public:\n+  \/\/ special iterators for index ranges, returns size of object\n+  template <typename OopClosureType>\n+  void oop_iterate_range(OopClosureType* blk, int start, int end);\n+};\n+\n+\/\/ See similar requirement for oopDesc.\n+static_assert(std::is_trivially_default_constructible<refArrayOopDesc>::value, \"required\");\n+\n+#endif \/\/ SHARE_OOPS_REFARRAYOOP_HPP\n","filename":"src\/hotspot\/share\/oops\/refArrayOop.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_REFARRAYOOP_INLINE_HPP\n+#define SHARE_OOPS_REFARRAYOOP_INLINE_HPP\n+\n+#include \"oops\/refArrayOop.hpp\"\n+\n+#include \"oops\/access.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+inline HeapWord *refArrayOopDesc::base() const {\n+  return (HeapWord *)arrayOopDesc::base(T_OBJECT);\n+}\n+\n+inline refArrayOop refArrayOopDesc::cast(oop o) {\n+  assert(o->is_refArray(), \"Must be a refArray\");\n+  return (refArrayOop)o;\n+}\n+\n+template <class T> T *refArrayOopDesc::obj_at_addr(int index) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  return &((T *)base())[index];\n+}\n+\n+inline oop refArrayOopDesc::obj_at(int index) const {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  ptrdiff_t offset = UseCompressedOops ? obj_at_offset<narrowOop>(index)\n+                                       : obj_at_offset<oop>(index);\n+  return HeapAccess<IS_ARRAY>::oop_load_at(as_oop(), offset);\n+}\n+\n+inline oop refArrayOopDesc::obj_at(int index, TRAPS) const {\n+  return obj_at(index);\n+}\n+\n+inline void refArrayOopDesc::obj_at_put(int index, oop value) {\n+  assert(is_within_bounds(index), \"index %d out of bounds %d\", index, length());\n+  assert(!is_null_free_array() || value != nullptr, \"Trying to write null to a null free array\");\n+  ptrdiff_t offset = UseCompressedOops ? obj_at_offset<narrowOop>(index)\n+                                       : obj_at_offset<oop>(index);\n+  HeapAccess<IS_ARRAY>::oop_store_at(as_oop(), offset, value);\n+}\n+\n+inline void refArrayOopDesc::obj_at_put(int index, oop value, TRAPS) {\n+  if (is_null_free_array() && value == nullptr) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted array\");\n+  }\n+  obj_at_put(index, value);\n+}\n+\n+#endif \/\/ SHARE_OOPS_REFARRAYOOP_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/refArrayOop.inline.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -84,1 +85,1 @@\n-TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, Kind) {\n+TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, Kind, ArrayKlass::ArrayProperties::DEFAULT) {\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -871,2 +871,0 @@\n-  develop(ccstrlist, PrintInlineKlassFields, \"\",                            \\\n-          \"Print fields collected by InlineKlass::collect_fields\")          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -761,1 +761,0 @@\n-  case vmIntrinsics::_isFlatArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -506,4 +506,4 @@\n-          Node* init_node = mcall->in(first_ind++);\n-          if (!init_node->is_top()) {\n-            st->print(\" [is_init\");\n-            format_helper(regalloc, st, init_node, \":\", -1, nullptr);\n+          Node* null_marker = mcall->in(first_ind++);\n+          if (!null_marker->is_top()) {\n+            st->print(\" [null marker\");\n+            format_helper(regalloc, st, null_marker, \":\", -1, nullptr);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1573,1 +1573,1 @@\n-        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_flat(), tk->is_null_free());\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_flat(), tk->is_null_free(), tk->is_atomic(), tk->is_aryklassptr()->is_vm_type());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-Node* GraphKit::load_object_klass(Node* obj, bool fold_for_arrays) {\n+Node* GraphKit::load_object_klass(Node* obj) {\n@@ -1237,1 +1237,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT, fold_for_arrays));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1287,1 +1287,1 @@\n-                                  bool is_init_check) {\n+                                  bool null_marker_check) {\n@@ -1418,1 +1418,1 @@\n-  } else if (type == T_OBJECT || is_init_check) {\n+  } else if (type == T_OBJECT || null_marker_check) {\n@@ -1891,1 +1891,3 @@\n-  ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* flat *\/ true, is_null_free, is_atomic);\n+  ciArrayKlass* array_klass = ciArrayKlass::make(vk, is_null_free, is_atomic, true);\n+  assert(array_klass->is_elem_null_free() == is_null_free, \"inconsistency\");\n+  assert(array_klass->is_elem_atomic() == is_atomic, \"inconsistency\");\n@@ -1895,0 +1897,3 @@\n+  assert(arytype->is_null_free() == is_null_free, \"inconsistency\");\n+  assert(arytype->is_not_null_free() == is_not_null_free, \"inconsistency\");\n+  assert(arytype->is_atomic() == is_atomic, \"inconsistency\");\n@@ -2841,0 +2846,9 @@\n+  const TypeKlassPtr* klass_ptr_type = gvn.type(superklass)->is_klassptr();\n+  const TypeAryKlassPtr* ary_klass_t = klass_ptr_type->isa_aryklassptr();\n+  Node* vm_superklass = superklass;\n+  \/\/ TODO 8366668 Compute the VM type here for when we do a direct pointer comparison\n+  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+    ary_klass_t = ary_klass_t->get_vm_type();\n+    vm_superklass = gvn.makecon(ary_klass_t);\n+  }\n+\n@@ -2878,1 +2892,1 @@\n-        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, vm_superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);\n@@ -2900,1 +2914,2 @@\n-  bool might_be_cache = (chk_off_con == cacheoff_con);\n+  \/\/ TODO 8366668 Re-enable. This breaks test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java\n+  bool might_be_cache = true;\/\/(chk_off_con == cacheoff_con);\n@@ -2951,0 +2966,1 @@\n+        \/\/ TODO 8366668 Do we need adjustments here??\n@@ -3001,0 +3017,2 @@\n+  \/\/ TODO 8366668 Re-enable\n+\/*\n@@ -3005,1 +3023,1 @@\n-\n+*\/\n@@ -3009,1 +3027,1 @@\n-  IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);\n+  IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, vm_superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);\n@@ -3090,0 +3108,5 @@\n+  const TypeAryKlassPtr* ary_klass_t = tklass->isa_aryklassptr();\n+    \/\/ TODO 8366668 Compute the VM type\n+  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+    tklass = ary_klass_t->get_vm_type();\n+  }\n@@ -3623,6 +3646,0 @@\n-        Node* obj_klass = nullptr;\n-        if (not_null_obj->is_InlineType()) {\n-          obj_klass = makecon(TypeKlassPtr::make(_gvn.type(not_null_obj)->inline_klass()));\n-        } else {\n-          obj_klass = load_object_klass(not_null_obj);\n-        }\n@@ -3784,2 +3801,1 @@\n-  \/\/ TODO 8350865 Don't fold this klass load because atomicity is currently not included in the typesystem\n-  Node* array_klass = load_object_klass(array, \/* fold_for_arrays = *\/ false);\n+  Node* array_klass = load_object_klass(array);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  Node* load_object_klass(Node* object, bool fold_for_arrays = true);\n+  Node* load_object_klass(Node* object);\n@@ -387,1 +387,1 @@\n-                          bool is_init_check = false);\n+                          bool null_marker_check = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -521,1 +521,0 @@\n-  case vmIntrinsics::_isFlatArray:              return inline_unsafe_isFlatArray();\n@@ -2347,1 +2346,1 @@\n-    if (adr_type->offset() >= objArrayOopDesc::base_offset_in_bytes()) {\n+    if (adr_type->offset() >= refArrayOopDesc::base_offset_in_bytes()) {\n@@ -2756,1 +2755,6 @@\n-  ciInlineKlass* value_klass = value_klass_node->const_oop()->as_instance()->java_mirror_type()->as_inline_klass();\n+  ciType* mirror_type = value_klass_node->const_oop()->as_instance()->java_mirror_type();\n+  if (!mirror_type->is_inlinetype()) {\n+    \/\/ Dead code\n+    return false;\n+  }\n+  ciInlineKlass* value_klass = mirror_type->as_inline_klass();\n@@ -4485,2 +4489,1 @@\n-  bool is_null_free_array = false;\n-  ciType* tm = mirror_con->java_mirror_type(&is_null_free_array);\n+  ciType* tm = mirror_con->java_mirror_type();\n@@ -4494,3 +4497,0 @@\n-      if (is_null_free_array) {\n-        tklass = tklass->is_aryklassptr()->cast_to_null_free();\n-      }\n@@ -4685,2 +4685,2 @@\n-      case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;\n-      case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;\n+      case RefArray:       query = Klass::layout_helper_is_refArray(layout_con); break;\n+      case NonRefArray:    query = !Klass::layout_helper_is_refArray(layout_con); break;\n@@ -4706,3 +4706,3 @@\n-    case ObjectArray:\n-    case NonObjectArray: {\n-      value = Klass::_lh_array_tag_obj_value;\n+    case RefArray:\n+    case NonRefArray: {\n+      value = Klass::_lh_array_tag_ref_value;\n@@ -4710,1 +4710,1 @@\n-      btest = (kind == ObjectArray) ? BoolTest::eq : BoolTest::ne;\n+      btest = (kind == RefArray) ? BoolTest::eq : BoolTest::ne;\n@@ -4753,10 +4753,4 @@\n-        ciInlineKlass* vk = t->as_inline_klass();\n-        bool flat = vk->maybe_flat_in_array();\n-        if (flat && atomic) {\n-          \/\/ Only flat if we have a corresponding atomic layout\n-          flat = null_free ? vk->has_atomic_layout() : vk->has_nullable_atomic_layout();\n-        }\n-        \/\/ TODO 8350865 refactor\n-        if (flat && !atomic) {\n-          flat = vk->has_non_atomic_layout();\n-        }\n+\n+        ciArrayKlass* array_klass = ciArrayKlass::make(t, null_free, atomic, true);\n+        assert(array_klass->is_elem_null_free() == null_free, \"inconsistency\");\n+        assert(array_klass->is_elem_atomic() == atomic, \"inconsistency\");\n@@ -4765,1 +4759,1 @@\n-        if (UseZGC && null_free && !flat) {\n+        if (UseZGC && null_free && !array_klass->is_flat_array_klass()) {\n@@ -4769,1 +4763,0 @@\n-        ciArrayKlass* array_klass = ciArrayKlass::make(t, flat, null_free, atomic);\n@@ -4771,1 +4764,1 @@\n-          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n+          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces, true);\n@@ -4787,2 +4780,1 @@\n-          assert(arytype->is_flat() == flat, \"inconsistency\");\n-          assert(arytype->is_aryptr()->is_not_flat() == !flat, \"inconsistency\");\n+          assert(arytype->is_atomic() == atomic, \"inconsistency\");\n@@ -4798,0 +4790,65 @@\n+Node* LibraryCallKit::load_default_array_klass(Node* klass_node) {\n+  \/\/ TODO 8366668\n+  \/\/ - Fred suggested that we could just have the first entry in the refined list point to the array with ArrayKlass::ArrayProperties::DEFAULT property\n+  \/\/   For now, we just load from ObjArrayKlass::_next_refined_array_klass, which would always be the refKlass for non-values, and deopt if it's not\n+  \/\/ - Convert this to an IGVN optimization, so it's also folded after parsing\n+  \/\/ - The generate_typeArray_guard is not needed by all callers, double-check that it's folded\n+\n+  const Type* klass_t = _gvn.type(klass_node);\n+  const TypeAryKlassPtr* ary_klass_t = klass_t->isa_aryklassptr();\n+  if (ary_klass_t && ary_klass_t->klass_is_exact()) {\n+    if (ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+      ary_klass_t = ary_klass_t->get_vm_type(false);\n+      return makecon(ary_klass_t);\n+    } else {\n+      return klass_node;\n+    }\n+  }\n+\n+  \/\/ Load next refined array klass if klass is an ObjArrayKlass\n+  RegionNode* refined_region = new RegionNode(2);\n+  Node* refined_phi = new PhiNode(refined_region, klass_t);\n+\n+  generate_typeArray_guard(klass_node, refined_region);\n+  if (refined_region->req() == 3) {\n+    refined_phi->add_req(klass_node);\n+  }\n+\n+  Node* adr_refined_klass = basic_plus_adr(klass_node, in_bytes(ObjArrayKlass::next_refined_array_klass_offset()));\n+  Node* refined_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), adr_refined_klass, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+\n+  RegionNode* refined_region2 = new RegionNode(3);\n+  Node* refined_phi2 = new PhiNode(refined_region2, klass_t);\n+\n+  Node* null_ctl = top();\n+  Node* null_free_klass = null_check_common(refined_klass, T_OBJECT, false, &null_ctl);\n+  refined_region2->init_req(1, null_ctl);\n+  refined_phi2->init_req(1, klass_node);\n+\n+  refined_region2->init_req(2, control());\n+  refined_phi2->init_req(2, null_free_klass);\n+\n+  set_control(_gvn.transform(refined_region2));\n+  refined_klass = _gvn.transform(refined_phi2);\n+\n+  Node* adr_properties = basic_plus_adr(refined_klass, in_bytes(ObjArrayKlass::properties_offset()));\n+\n+  Node* properties = _gvn.transform(LoadNode::make(_gvn, control(), immutable_memory(), adr_properties, TypeRawPtr::BOTTOM, TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* default_val = makecon(TypeInt::make(ArrayKlass::ArrayProperties::DEFAULT));\n+  Node* chk = _gvn.transform(new CmpINode(properties, default_val));\n+  Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));\n+\n+  { \/\/ Deoptimize if not the default property\n+    BuildCutout unless(this, tst, PROB_MAX);\n+    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+  }\n+\n+  refined_region->init_req(1, control());\n+  refined_phi->init_req(1, refined_klass);\n+\n+  set_control(_gvn.transform(refined_region));\n+  klass_node = _gvn.transform(refined_phi);\n+\n+  return klass_node;\n+}\n+\n@@ -4857,0 +4914,3 @@\n+\n+    klass_node = load_default_array_klass(klass_node);\n+\n@@ -4957,1 +5017,5 @@\n-    Node* not_objArray = exclude_flat ? generate_non_objArray_guard(klass_node, bailout) : generate_typeArray_guard(klass_node, bailout);\n+    \/\/ TODO 8366668 generate_non_refArray_guard also passed for ref arrays??\n+    Node* not_objArray = exclude_flat ? generate_non_refArray_guard(klass_node, bailout) : generate_typeArray_guard(klass_node, bailout);\n+\n+    klass_node = load_default_array_klass(klass_node);\n+\n@@ -5706,14 +5770,0 @@\n-\/\/----------------------inline_unsafe_isFlatArray------------------------\n-\/\/ public native boolean Unsafe.isFlatArray(Class<?> arrayClass);\n-\/\/ This intrinsic exploits assumptions made by the native implementation\n-\/\/ (arrayClass is neither null nor primitive) to avoid unnecessary null checks.\n-bool LibraryCallKit::inline_unsafe_isFlatArray() {\n-  Node* cls = argument(1);\n-  Node* p = basic_plus_adr(cls, java_lang_Class::klass_offset());\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p,\n-                                                 TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT));\n-  Node* result = flat_array_test(kls);\n-  set_result(result);\n-  return true;\n-}\n-\n@@ -5837,1 +5887,0 @@\n-    \/\/ TODO 8350865 For arrays, this might be folded and then not account for atomic arrays\n@@ -5870,1 +5919,1 @@\n-          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)nullptr);\n+          Node* is_obja = generate_refArray_guard(obj_klass, (RegionNode*)nullptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":95,"deletions":46,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -171,0 +171,2 @@\n+  Node* load_default_array_klass(Node* klass_node);\n+\n@@ -181,2 +183,2 @@\n-    ObjectArray,\n-    NonObjectArray,\n+    RefArray,\n+    NonRefArray,\n@@ -194,2 +196,2 @@\n-  Node* generate_objArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n-    return generate_array_guard_common(kls, region, ObjectArray, obj);\n+  Node* generate_refArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, RefArray, obj);\n@@ -197,2 +199,2 @@\n-  Node* generate_non_objArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n-    return generate_array_guard_common(kls, region, NonObjectArray, obj);\n+  Node* generate_non_refArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, NonRefArray, obj);\n@@ -260,1 +262,0 @@\n-  bool inline_unsafe_isFlatArray();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2206,0 +2206,6 @@\n+  \/\/ TODO 8366668 Compute the VM type, is this even needed now that we set it earlier? Should we assert instead?\n+  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+    ary_klass_t = ary_klass_t->get_vm_type();\n+    klass_node = makecon(ary_klass_t);\n+    _igvn.replace_input_of(alloc, AllocateNode::KlassNode, klass_node);\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2587,1 +2587,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, bool fold_for_arrays) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n@@ -2594,1 +2594,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered, fold_for_arrays));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n@@ -2599,1 +2599,1 @@\n-  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered, fold_for_arrays);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n@@ -2604,1 +2604,1 @@\n-  return klass_value_common(phase, _fold_for_arrays);\n+  return klass_value_common(phase);\n@@ -2607,1 +2607,1 @@\n-const Type* LoadNode::klass_value_common(PhaseGVN* phase, bool fold_for_arrays) const {\n+const Type* LoadNode::klass_value_common(PhaseGVN* phase) const {\n@@ -2628,2 +2628,1 @@\n-      bool is_null_free_array = false;\n-      ciType* t = tinst->java_mirror_type(&is_null_free_array);\n+      ciType* t = tinst->java_mirror_type();\n@@ -2639,5 +2638,1 @@\n-          const TypeKlassPtr* tklass = TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n-          if (is_null_free_array) {\n-            tklass = tklass->is_aryklassptr()->cast_to_null_free();\n-          }\n-          return tklass;\n+          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n@@ -2650,5 +2645,1 @@\n-        const TypeKlassPtr* tklass = TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n-        if (is_null_free_array) {\n-          tklass = tklass->is_aryklassptr()->cast_to_null_free();\n-        }\n-        return tklass;\n+        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n@@ -2667,1 +2658,1 @@\n-  if (tary != nullptr && fold_for_arrays &&\n+  if (tary != nullptr &&\n@@ -2757,0 +2748,1 @@\n+        \/\/ TODO 8366668 Re-enable this for arrays\n@@ -2758,1 +2750,1 @@\n-            && (tkls->isa_instklassptr() || tkls->isa_aryklassptr())\n+            && ((tkls->isa_instklassptr() && !tkls->is_instklassptr()->might_be_an_array()) || (tkls->isa_aryklassptr() && false))\n@@ -2782,1 +2774,1 @@\n-  const Type *t = klass_value_common(phase, _fold_for_arrays);\n+  const Type *t = klass_value_common(phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  const Type* klass_value_common(PhaseGVN* phase, bool fold_for_arrays) const;\n+  const Type* klass_value_common(PhaseGVN* phase) const;\n@@ -534,8 +534,0 @@\n-  bool _fold_for_arrays;\n-\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual uint hash() const { return LoadNode::hash() + _fold_for_arrays; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _fold_for_arrays == ((LoadKlassNode&)n)._fold_for_arrays && LoadNode::cmp(n);\n-  }\n-\n@@ -543,2 +535,2 @@\n-  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo, bool fold_for_arrays)\n-    : LoadPNode(nullptr, mem, adr, at, tk, mo), _fold_for_arrays(fold_for_arrays) {}\n+  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo)\n+    : LoadPNode(nullptr, mem, adr, at, tk, mo) {}\n@@ -554,1 +546,1 @@\n-                    const TypeKlassPtr* tk = TypeInstKlassPtr::OBJECT, bool fold_for_arrays = true);\n+                    const TypeKlassPtr* tk = TypeInstKlassPtr::OBJECT);\n@@ -566,8 +558,0 @@\n-  bool _fold_for_arrays;\n-\n-  virtual uint size_of() const { return sizeof(*this); }\n-  virtual uint hash() const { return LoadNode::hash() + _fold_for_arrays; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _fold_for_arrays == ((LoadNKlassNode&)n)._fold_for_arrays && LoadNode::cmp(n);\n-  }\n-\n@@ -575,3 +559,3 @@\n-  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*, bool fold_for_arrays);\n-  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo, bool fold_for_arrays)\n-    : LoadNNode(nullptr, mem, adr, at, tk, mo), _fold_for_arrays(fold_for_arrays) {}\n+  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*);\n+  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo)\n+    : LoadNNode(nullptr, mem, adr, at, tk, mo) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-      ScopeValue* null_marker = nullptr;\n+      ScopeValue* properties = nullptr;\n@@ -814,1 +814,1 @@\n-            null_marker = new ConstantIntValue(null_marker_type->get_con());\n+            properties = new ConstantIntValue(null_marker_type->get_con());\n@@ -817,1 +817,1 @@\n-            null_marker = new_loc_value(C->regalloc(), null_marker_reg, Location::normal);\n+            properties = new_loc_value(C->regalloc(), null_marker_reg, Location::normal);\n@@ -821,0 +821,12 @@\n+      if (cik->is_array_klass() && !cik->is_type_array_klass()) {\n+        jint props = ArrayKlass::ArrayProperties::DEFAULT;\n+        if (cik->as_array_klass()->element_klass()->is_inlinetype()) {\n+          if (cik->as_array_klass()->is_elem_null_free()) {\n+            props |= ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+          }\n+          if (!cik->as_array_klass()->is_elem_atomic()) {\n+            props |= ArrayKlass::ArrayProperties::NON_ATOMIC;\n+          }\n+        }\n+        properties = new ConstantIntValue(props);\n+      }\n@@ -822,1 +834,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), true, null_marker);\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), true, properties);\n@@ -1167,0 +1179,14 @@\n+          assert(!cik->is_inlinetype(), \"Synchronization on value object?\");\n+          ScopeValue* properties = nullptr;\n+          if (cik->is_array_klass() && !cik->is_type_array_klass()) {\n+            jint props = ArrayKlass::ArrayProperties::DEFAULT;\n+            if (cik->as_array_klass()->element_klass()->is_inlinetype()) {\n+              if (cik->as_array_klass()->is_elem_null_free()) {\n+                props |= ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+              }\n+              if (!cik->as_array_klass()->is_elem_atomic()) {\n+                props |= ArrayKlass::ArrayProperties::NON_ATOMIC;\n+              }\n+            }\n+            properties = new ConstantIntValue(props);\n+          }\n@@ -1168,1 +1194,1 @@\n-                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), true, properties);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -365,0 +365,3 @@\n+  if (array_klass_type->exact_klass()->is_obj_array_klass()) {\n+    array_klass_type = array_klass_type->isa_aryklassptr()->get_vm_type();\n+  }\n@@ -386,1 +389,5 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n+  const TypeKlassPtr* array_klass_ptr = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n+  if (array_klass_ptr->exact_klass()->is_obj_array_klass()) {\n+    array_klass_ptr = array_klass_ptr->isa_aryklassptr()->get_vm_type();\n+  }\n+  Node* array = new_array(makecon(array_klass_ptr), length, nargs);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+      \/\/ TODO 8366668 TestLWorld and TestLWorldProfiling are sensitive to this. But this hack just assumes we always have the default properties ...\n+      if (extak->exact_klass()->is_obj_array_klass()) {\n+        extak = extak->get_vm_type();\n+      }\n+\n@@ -251,1 +256,1 @@\n-  int element_klass_offset = in_bytes(ArrayKlass::element_klass_offset());\n+  int element_klass_offset = in_bytes(ObjArrayKlass::element_klass_offset());\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -391,1 +391,15 @@\n-    result = oopFactory::new_flatArray(vk, len, fak->layout_kind(), THREAD);\n+    ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+    switch(fak->layout_kind()) {\n+      case LayoutKind::ATOMIC_FLAT:\n+        props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+      break;\n+      case LayoutKind::NON_ATOMIC_FLAT:\n+        props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+      break;\n+      case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      props = ArrayKlass::ArrayProperties::NON_ATOMIC;\n+      break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    result = oopFactory::new_flatArray(vk, len, props, fak->layout_kind(), THREAD);\n@@ -405,2 +419,2 @@\n-    ObjArrayKlass* array_klass = ObjArrayKlass::cast(array_type);\n-    result = array_klass->allocate(len, THREAD);\n+    RefArrayKlass* array_klass = RefArrayKlass::cast(array_type);\n+    result = array_klass->allocate_instance(len, RefArrayKlass::cast(array_type)->properties(), THREAD);\n@@ -2425,1 +2439,1 @@\n-  oop buffer = array->read_value_from_flat_array(index, THREAD);\n+  oop buffer = array->obj_at(index, THREAD);\n@@ -2450,1 +2464,1 @@\n-  array->write_value_to_flat_array(buffer, index, THREAD);\n+  array->obj_at_put(index, buffer, THREAD);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1211,1 +1211,3 @@\n-    if (k1 && (k2 || conk2)) {\n+    \/\/ TODO 8366668 add a test for this. Improve this condition\n+    bool doIt = (conk2 && !phase->type(conk2)->isa_aryklassptr());\n+    if (k1 && (k2 || conk2) && doIt) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -209,1 +209,2 @@\n-        bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+        \/\/ TODO 8366668 Re-enable. This breaks TestArrays.java with -XX:+StressReflectiveCode\n+        bool might_be_cache = true; \/\/ (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2660,1 +2660,1 @@\n-                             bool flat, bool not_flat, bool not_null_free) {\n+                             bool flat, bool not_flat, bool not_null_free, bool atomic) {\n@@ -2665,1 +2665,1 @@\n-  return (TypeAry*)(new TypeAry(elem, size, stable, flat, not_flat, not_null_free))->hashcons();\n+  return (TypeAry*)(new TypeAry(elem, size, stable, flat, not_flat, not_null_free, atomic))->hashcons();\n@@ -2690,1 +2690,2 @@\n-                         _not_null_free && a->_not_null_free);\n+                         _not_null_free && a->_not_null_free,\n+                         _atomic && a->_atomic);\n@@ -2703,1 +2704,1 @@\n-  return new TypeAry(_elem->dual(), size_dual, !_stable, !_flat, !_not_flat, !_not_null_free);\n+  return new TypeAry(_elem->dual(), size_dual, !_stable, !_flat, !_not_flat, !_not_null_free, !_atomic);\n@@ -2715,1 +2716,2 @@\n-    _not_null_free == a->_not_null_free;\n+    _not_null_free == a->_not_null_free &&\n+    _atomic == a->_atomic;\n@@ -2723,1 +2725,1 @@\n-      (uint)(_flat ? 44 : 0) + (uint)(_not_flat ? 45 : 0) + (uint)(_not_null_free ? 46 : 0);\n+      (uint)(_flat ? 44 : 0) + (uint)(_not_flat ? 45 : 0) + (uint)(_not_null_free ? 46 : 0) + (uint)(_atomic ? 47 : 0);\n@@ -2730,1 +2732,1 @@\n-  return make(_elem->remove_speculative(), _size, _stable, _flat, _not_flat, _not_null_free);\n+  return make(_elem->remove_speculative(), _size, _stable, _flat, _not_flat, _not_null_free, _atomic);\n@@ -2737,1 +2739,1 @@\n-  return make(_elem->cleanup_speculative(), _size, _stable, _flat, _not_flat, _not_null_free);\n+  return make(_elem->cleanup_speculative(), _size, _stable, _flat, _not_flat, _not_null_free, _atomic);\n@@ -2761,0 +2763,1 @@\n+  if (_atomic) st->print(\"atomic:\");\n@@ -4085,0 +4088,4 @@\n+    const bool is_null_free = klass->as_array_klass()->is_elem_null_free();\n+    if (is_null_free) {\n+      etype = etype->join_speculative(NOTNULL)->is_oopptr();\n+    }\n@@ -4093,0 +4100,1 @@\n+    bool atomic = klass->as_array_klass()->is_elem_atomic();\n@@ -4095,1 +4103,1 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, not_flat, not_null_free);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, not_flat, not_null_free, atomic);\n@@ -4116,1 +4124,2 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true);\n+    bool atomic = klass->as_array_klass()->is_elem_atomic();\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ false, atomic);\n@@ -4144,2 +4153,2 @@\n-    bool is_flat = o->as_obj_array()->is_flat();\n-    bool is_null_free = o->as_obj_array()->is_null_free();\n+    bool is_flat = o->as_array()->is_flat();\n+    bool is_null_free = o->as_array()->is_null_free();\n@@ -4149,2 +4158,3 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()),\n-                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ !is_flat, \/* not_null_free= *\/ !is_null_free);\n+    bool is_atomic = o->as_array()->is_atomic();\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ false,\n+                                        \/* not_flat= *\/ !is_flat, \/* not_null_free= *\/ !is_null_free, \/* atomic= *\/ is_atomic);\n@@ -4162,2 +4172,2 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()),\n-                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ false,\n+                                        \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -4177,0 +4187,1 @@\n+    bool is_atomic = o->as_array()->is_atomic();\n@@ -4178,1 +4189,1 @@\n-                                        \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free);\n+                                        \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, \/* atomic= *\/ is_atomic);\n@@ -4964,1 +4975,1 @@\n-ciType* TypeInstPtr::java_mirror_type(bool* is_null_free_array) const {\n+ciType* TypeInstPtr::java_mirror_type() const {\n@@ -4970,1 +4981,1 @@\n-  return const_oop()->as_instance()->java_mirror_type(is_null_free_array);\n+  return const_oop()->as_instance()->java_mirror_type();\n@@ -5300,1 +5311,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_flat(), is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n@@ -5310,1 +5321,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), not_flat, is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), not_flat, is_not_null_free(), is_atomic());\n@@ -5326,1 +5337,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), is_not_flat(), not_null_free);\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), is_not_flat(), not_null_free, is_atomic());\n@@ -5380,1 +5391,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_flat(), is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n@@ -5402,1 +5413,1 @@\n-  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n@@ -5532,0 +5543,1 @@\n+    bool res_atomic = false;\n@@ -5533,1 +5545,1 @@\n-    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk, res_flat, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk, res_flat, res_not_flat, res_not_null_free, res_atomic) == NOT_SUBTYPE) {\n@@ -5566,1 +5578,1 @@\n-    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_flat, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n+    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_flat, res_not_flat, res_not_null_free, res_atomic), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n@@ -5631,1 +5643,1 @@\n-                                                           ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool& res_not_flat, bool& res_not_null_free) {\n+                                                           ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool& res_not_flat, bool& res_not_null_free, bool &res_atomic) {\n@@ -5647,0 +5659,2 @@\n+  bool this_atomic = this_ary->is_atomic();\n+  bool other_atomic = other_ary->is_atomic();\n@@ -5654,0 +5668,1 @@\n+  res_atomic = this_atomic && other_atomic;\n@@ -5804,3 +5819,12 @@\n-    st->print(\":null_free\");\n-  } else if (is_not_null_free()) {\n-    st->print(\":nullable\");\n+    st->print(\":null free\");\n+  }\n+  if (is_atomic()) {\n+    st->print(\":atomic\");\n+  }\n+  if (Verbose) {\n+    if (is_not_flat()) {\n+      st->print(\":not flat\");\n+    }\n+    if (is_not_null_free()) {\n+      st->print(\":nullable\");\n+    }\n@@ -6295,1 +6319,1 @@\n-  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_flat() || is_null_free());\n@@ -6647,1 +6671,1 @@\n-        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free());\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_vm_type());\n@@ -6666,1 +6690,1 @@\n-          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free());\n+          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_vm_type());\n@@ -6816,2 +6840,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free) {\n-  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, flat, null_free))->hashcons();\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type))->hashcons();\n@@ -6820,1 +6844,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type) {\n@@ -6825,1 +6849,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n@@ -6829,1 +6853,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic);\n@@ -6833,1 +6857,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n@@ -6840,2 +6864,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling) {\n-  bool null_free = k->as_array_klass()->is_elem_null_free();\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool vm_type) {\n@@ -6843,0 +6866,2 @@\n+  bool null_free = k->as_array_klass()->is_elem_null_free();\n+  bool atomic = k->as_array_klass()->is_elem_atomic();\n@@ -6851,1 +6876,1 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free);\n+  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n@@ -6854,2 +6879,11 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n-  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling, bool vm_type) {\n+  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling, vm_type);\n+}\n+\n+const TypeAryKlassPtr* TypeAryKlassPtr::get_vm_type(bool vm_type) const {\n+  ciKlass* eklass = elem()->is_klassptr()->exact_klass_helper();\n+  if (elem()->isa_aryklassptr()) {\n+    eklass = exact_klass()->as_obj_array_klass()->element_klass();\n+  }\n+  ciKlass* array_klass = ciArrayKlass::make(eklass, is_null_free(), is_atomic(), true);\n+  return make(_ptr, array_klass, Offset(0), trust_interfaces, vm_type);\n@@ -6864,0 +6898,1 @@\n+    _flat == p->_flat &&\n@@ -6865,1 +6900,0 @@\n-    _not_null_free == p->_not_null_free &&\n@@ -6867,1 +6901,3 @@\n-    _flat == p->_flat &&\n+    _not_null_free == p->_not_null_free &&\n+    _atomic == p->_atomic &&\n+    _vm_type == p->_vm_type &&\n@@ -6875,1 +6911,1 @@\n-      (uint)(_not_null_free ? 44 : 0) + (uint)(_flat ? 45 : 0) + (uint)(_null_free ? 46 : 0);\n+      (uint)(_not_null_free ? 44 : 0) + (uint)(_flat ? 45 : 0) + (uint)(_null_free ? 46 : 0)  + (uint)(_atomic ? 47 : 0) + (uint)(_vm_type ? 48 : 0);\n@@ -6894,1 +6930,1 @@\n-      \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n+      \/\/ TODO 8350865 We assume atomic if the atomic layout is available, use is_atomic() here\n@@ -6896,1 +6932,1 @@\n-      k_ary = ciArrayKlass::make(el->inline_klass(), \/* flat *\/ true, is_null_free(), atomic);\n+      k_ary = ciArrayKlass::make(el->inline_klass(), is_null_free(), atomic, true);\n@@ -6949,1 +6985,1 @@\n-    k = ciArrayKlass::make(k, is_flat(), is_null_free());\n+    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), is_flat() || is_null_free());\n@@ -6969,1 +7005,1 @@\n-  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free);\n+  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n@@ -6973,1 +7009,1 @@\n-  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free);\n+  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n@@ -6980,1 +7016,1 @@\n-  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _flat, _null_free);\n+  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n@@ -7028,5 +7064,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free);\n-}\n-\n-const TypeAryKlassPtr* TypeAryKlassPtr::cast_to_null_free() const {\n-  return make(_ptr, elem(), klass(), _offset, is_not_flat(), false, is_flat(), true);\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free, _atomic, _vm_type);\n@@ -7052,1 +7084,1 @@\n-  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS, false, is_flat(), is_not_flat(), is_not_null_free()), k, xk, Offset(0));\n+  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS, false, is_flat(), is_not_flat(), is_not_null_free(), is_atomic()), k, xk, Offset(0));\n@@ -7097,1 +7129,1 @@\n-      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n+      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n@@ -7138,0 +7170,1 @@\n+    bool res_atomic = false;\n@@ -7139,1 +7172,1 @@\n-                                 res_klass, res_xk, res_flat, res_not_flat, res_not_null_free);\n+                                 res_klass, res_xk, res_flat, res_not_flat, res_not_null_free, res_atomic);\n@@ -7143,0 +7176,2 @@\n+    bool atomic = meet_atomic(tap->_atomic);\n+    bool vm_type = _vm_type && tap->_vm_type;\n@@ -7146,0 +7181,2 @@\n+      atomic = false;\n+      vm_type = false;\n@@ -7150,0 +7187,2 @@\n+        atomic = _atomic;\n+        vm_type = _vm_type;\n@@ -7153,0 +7192,2 @@\n+        atomic = tap->_atomic;\n+        vm_type = tap->_vm_type;\n@@ -7154,1 +7195,0 @@\n-        null_free = _null_free || tap->_null_free;\n@@ -7156,0 +7196,3 @@\n+        null_free = _null_free || tap->_null_free;\n+        atomic = _atomic || tap->_atomic;\n+        vm_type = _vm_type || tap->_vm_type;\n@@ -7158,1 +7201,1 @@\n-    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, flat, null_free);\n+    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, flat, null_free, atomic, vm_type);\n@@ -7176,1 +7219,1 @@\n-        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n@@ -7196,1 +7239,1 @@\n-          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n+          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n@@ -7337,1 +7380,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_flat(), dual_null_free());\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_flat(), dual_null_free(), dual_atomic(), _vm_type);\n@@ -7347,6 +7390,1 @@\n-    \/\/ TODO 8350865 LibraryCallKit::inline_newArray passes a constant TypeAryKlassPtr to GraphKit::new_array\n-    \/\/ As long as atomicity is not tracked by TypeAryKlassPtr, don't re-compute it here to avoid loosing atomicity information\n-    if (k->is_inlinetype() && _klass != nullptr) {\n-      return _klass;\n-    }\n-    k = ciArrayKlass::make(k, is_flat(), is_null_free());\n+    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), _vm_type);\n@@ -7401,0 +7439,2 @@\n+  if (_atomic) st->print(\":atomic\");\n+  if (_vm_type) st->print(\":vm_type\");\n@@ -7403,1 +7443,1 @@\n-    if (_not_null_free) st->print(\":not null free\");\n+    if (_not_null_free) st->print(\":nullable\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":113,"deletions":73,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -830,2 +830,2 @@\n-  TypeAry(const Type* elem, const TypeInt* size, bool stable, bool flat, bool not_flat, bool not_null_free) : Type(Array),\n-      _elem(elem), _size(size), _stable(stable), _flat(flat), _not_flat(not_flat), _not_null_free(not_null_free) {}\n+  TypeAry(const Type* elem, const TypeInt* size, bool stable, bool flat, bool not_flat, bool not_null_free, bool atomic) : Type(Array),\n+      _elem(elem), _size(size), _stable(stable), _flat(flat), _not_flat(not_flat), _not_null_free(not_null_free), _atomic(atomic) {}\n@@ -847,0 +847,1 @@\n+  const bool _atomic;           \/\/ Array is atomic\n@@ -852,1 +853,1 @@\n-                             bool flat = false, bool not_flat = false, bool not_null_free = false);\n+                             bool flat = false, bool not_flat = false, bool not_null_free = false, bool atomic = false);\n@@ -1061,1 +1062,1 @@\n-                                                  ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool &res_not_flat, bool &res_not_null_free);\n+                                                  ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool &res_not_flat, bool &res_not_null_free, bool &res_atomic);\n@@ -1134,0 +1135,1 @@\n+  virtual bool is_atomic()          const { return false; }\n@@ -1430,1 +1432,1 @@\n-  ciType* java_mirror_type(bool* is_null_free_array = nullptr) const;\n+  ciType* java_mirror_type() const;\n@@ -1547,0 +1549,1 @@\n+  bool is_atomic()        const { return _ary->_atomic; }\n@@ -1875,0 +1878,2 @@\n+  const bool _atomic;\n+  const bool _vm_type;\n@@ -1877,2 +1882,2 @@\n-  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool flat, bool null_free)\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _flat(flat), _null_free(null_free) {\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool flat, bool null_free, bool atomic, bool vm_type)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _flat(flat), _null_free(null_free), _atomic(atomic), _vm_type(vm_type) {\n@@ -1904,0 +1909,8 @@\n+  bool dual_atomic() const {\n+    return _atomic;\n+  }\n+\n+  bool meet_atomic(bool other) const {\n+    return _atomic && other;\n+  }\n+\n@@ -1909,1 +1922,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type = false);\n@@ -1917,3 +1930,5 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free);\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling);\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool vm_type = false);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling, bool vm_type = false);\n+\n+  const TypeAryKlassPtr* get_vm_type(bool vm_type = true) const;\n@@ -1930,2 +1945,0 @@\n-  const TypeAryKlassPtr* cast_to_null_free() const;\n-\n@@ -1949,0 +1962,2 @@\n+  bool is_atomic()        const { return _atomic; }\n+  bool is_vm_type()       const { return _vm_type; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -843,2 +843,1 @@\n-    case T_OBJECT:\n-    case T_FLAT_ELEMENT: push_object((_ap++)->l); break;\n+    case T_OBJECT:      push_object((_ap++)->l); break;\n@@ -2355,3 +2354,5 @@\n-  Klass* ak = ek->array_klass(CHECK_NULL);\n-  ObjArrayKlass::cast(ak)->initialize(CHECK_NULL);\n-  objArrayOop result = ObjArrayKlass::cast(ak)->allocate(length, CHECK_NULL);\n+\n+  \/\/ Make sure bottom_klass is initialized.\n+  ek->initialize(CHECK_NULL);\n+  objArrayOop result = oopFactory::new_objArray(ek, length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n+\n@@ -2375,12 +2376,6 @@\n-  oop res = nullptr;\n-  arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n-  if (arr->is_within_bounds(index)) {\n-    if (arr->is_flatArray()) {\n-      flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n-      res = a->read_value_from_flat_array(index, CHECK_NULL);\n-      assert(res != nullptr || !arr->is_null_free_array(), \"Invalid value\");\n-    } else {\n-      assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n-      objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-      res = a->obj_at(index);\n-    }\n+  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+  if (a->is_within_bounds(index)) {\n+    oop res = a->obj_at(index, CHECK_NULL);\n+    assert(res != nullptr || !a->is_null_free_array(), \"Invalid value\");\n+    ret = JNIHandles::make_local(THREAD, res);\n+    return ret;\n@@ -2390,1 +2385,1 @@\n-    ss.print(\"Index %d out of bounds for length %d\", index,arr->length());\n+    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n@@ -2393,2 +2388,0 @@\n-  ret = JNIHandles::make_local(THREAD, res);\n-  return ret;\n@@ -2404,34 +2397,20 @@\n-   bool oob = false;\n-   int length = -1;\n-   oop res = nullptr;\n-   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));\n-   if (arr->is_within_bounds(index)) {\n-     if (arr->is_flatArray()) {\n-       flatArrayOop a = flatArrayOop(JNIHandles::resolve_non_null(array));\n-       oop v = JNIHandles::resolve(value);\n-       FlatArrayKlass* vaklass = FlatArrayKlass::cast(a->klass());\n-       InlineKlass* element_vklass = vaklass->element_klass();\n-       a->write_value_to_flat_array(v, index, CHECK);\n-     } else {\n-       assert(arr->is_objArray(), \"If not a valueArray. must be an objArray\");\n-       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-       oop v = JNIHandles::resolve(value);\n-       if (v == nullptr || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n-         if (v == nullptr && ObjArrayKlass::cast(a->klass())->is_null_free_array_klass()) {\n-           THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted array\");\n-         }\n-         a->obj_at_put(index, v);\n-       } else {\n-         ResourceMark rm(THREAD);\n-         stringStream ss;\n-         Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n-         ss.print(\"type mismatch: can not store %s to %s[%d]\",\n-             v->klass()->external_name(),\n-             bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n-                 index);\n-         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n-           ss.print(\"[]\");\n-         }\n-         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n-       }\n-     }\n+   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+   oop v = JNIHandles::resolve(value);\n+   if (a->is_within_bounds(index)) {\n+    \/\/ TODO FIXME Temporary hack, to be removed when FlatArrayKlass is made a sub-class of ObjArrayKlass\n+    Klass* ek = a->is_flatArray() ? FlatArrayKlass::cast(a->klass())->element_klass() : RefArrayKlass::cast(a->klass())->element_klass();\n+    if (v == nullptr || v->is_a(ek)) {\n+      a->obj_at_put(index, v, CHECK);\n+    } else {\n+      ResourceMark rm(THREAD);\n+      stringStream ss;\n+      Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();\n+      ss.print(\"type mismatch: can not store %s to %s[%d]\",\n+               v->klass()->external_name(),\n+               bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),\n+               index);\n+      for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {\n+        ss.print(\"[]\");\n+      }\n+      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());\n+    }\n@@ -2441,1 +2420,1 @@\n-     ss.print(\"Index %d out of bounds for length %d\", index, arr->length());\n+     ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":34,"deletions":55,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"oops\/refArrayOop.inline.hpp\"\n@@ -333,1 +334,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -436,1 +437,1 @@\n-  ArrayKlass* ak = ArrayKlass::cast(org->klass());\n+  ObjArrayKlass* ak = ObjArrayKlass::cast(org->klass());\n@@ -440,1 +441,1 @@\n-    if (from >= org->length() || to > org->length()) {\n+    if ((len != 0) && (from >= org->length() || to > org->length())) {\n@@ -447,1 +448,15 @@\n-    array = oopFactory::new_flatArray(vk, len, lk, CHECK_NULL);\n+    ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+    switch(lk) {\n+      case LayoutKind::ATOMIC_FLAT:\n+        props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+      break;\n+      case LayoutKind::NON_ATOMIC_FLAT:\n+        props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+      break;\n+      case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      props = ArrayKlass::ArrayProperties::NON_ATOMIC;\n+      break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    array = oopFactory::new_flatArray(vk, len, props, lk, CHECK_NULL);\n@@ -457,5 +472,2 @@\n-    if (org->is_null_free_array()) {\n-      array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n-    } else {\n-      array = oopFactory::new_objArray(vk, len, CHECK_NULL);\n-    }\n+    ArrayKlass::ArrayProperties props = org->is_null_free_array() ? ArrayKlass::ArrayProperties::NULL_RESTRICTED : ArrayKlass::ArrayProperties::DEFAULT;\n+    array = oopFactory::new_objArray(vk, len, props,  CHECK_NULL);\n@@ -488,11 +500,4 @@\n-  oop array = nullptr;\n-  if (vk->maybe_flat_in_array() && vk->has_non_atomic_layout()) {\n-    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n-    for (int i = 0; i < len; i++) {\n-      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n-    }\n-  } else {\n-    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n-    for (int i = 0; i < len; i++) {\n-      ((objArrayOop)array)->obj_at_put(i, init_h());\n-    }\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NON_ATOMIC | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n+  for (int i = 0; i < len; i++) {\n+    array->obj_at_put(i, init_h() \/*, CHECK_NULL*\/ );\n@@ -516,18 +521,4 @@\n-  oop array = nullptr;\n-  if (vk->maybe_flat_in_array() && vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n-    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n-    for (int i = 0; i < len; i++) {\n-      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n-    }\n-  } else if (vk->maybe_flat_in_array() && vk->has_atomic_layout()) {\n-    array = oopFactory::new_flatArray(vk, len, LayoutKind::ATOMIC_FLAT, CHECK_NULL);\n-    for (int i = 0; i < len; i++) {\n-      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n-    }\n-  } else {\n-    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n-    for (int i = 0; i < len; i++) {\n-      \/\/ need a type check here\n-\n-      ((objArrayOop)array)->obj_at_put(i, init_h());\n-    }\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n+  for (int i = 0; i < len; i++) {\n+    array->obj_at_put(i, init_h() \/*, CHECK_NULL*\/ );\n@@ -544,6 +535,2 @@\n-  oop array = nullptr;\n-  if (vk->maybe_flat_in_array() && vk->has_nullable_atomic_layout()) {\n-    array = oopFactory::new_flatArray(vk, len, LayoutKind::NULLABLE_ATOMIC_FLAT, CHECK_NULL);\n-  } else {\n-    array = oopFactory::new_objArray(vk, len, CHECK_NULL);\n-  }\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::DEFAULT);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n@@ -569,1 +556,1 @@\n-  if (oop->is_objArray()) return true;\n+  if (oop->is_refArray()) return true;\n@@ -1348,1 +1335,1 @@\n-    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1359,1 +1346,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n@@ -1364,1 +1351,1 @@\n-  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), size, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), size, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1447,1 +1434,1 @@\n-    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1456,1 +1443,1 @@\n-    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1465,1 +1452,1 @@\n-  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), length\/4, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), length\/4, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1495,1 +1482,1 @@\n-    objArrayOop res = oopFactory::new_objArray(vmClasses::Class_klass(), members, CHECK_NULL);\n+    objArrayOop res = oopFactory::new_objArray(vmClasses::Class_klass(), members, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1723,1 +1710,1 @@\n-    objArrayOop result_oop = oopFactory::new_objArray(vmClasses::reflect_Parameter_klass(), num_params, CHECK_NULL);\n+    objArrayOop result_oop = oopFactory::new_objArray(vmClasses::reflect_Parameter_klass(), num_params, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1752,1 +1739,1 @@\n-    oop res = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), 0, CHECK_NULL);\n+    oop res = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1774,1 +1761,1 @@\n-  objArrayOop r = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), num_fields, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), num_fields, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1824,1 +1811,1 @@\n-      oopFactory::new_objArray(vmClasses::RecordComponent_klass(), length, CHECK_NULL);\n+      oopFactory::new_objArray(vmClasses::RecordComponent_klass(), length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1853,1 +1840,1 @@\n-    oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);\n+    oop res = oopFactory::new_objArray(klass, 0, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1891,1 +1878,1 @@\n-  objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(klass, num_methods, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1992,1 +1979,1 @@\n-                                             length + 1, CHECK_NULL);\n+                                             length + 1, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -2036,1 +2023,1 @@\n-                                                  count + 1, CHECK_NULL);\n+                                                  count + 1, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -2070,1 +2057,1 @@\n-                                             length, CHECK_NULL);\n+                                             length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -2099,1 +2086,1 @@\n-                                                count, CHECK_NULL);\n+                                                count, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -2276,1 +2263,1 @@\n-  objArrayOop  dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 3, CHECK_NULL);\n+  objArrayOop  dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 3, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -2325,1 +2312,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 2, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 2, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -3744,1 +3731,1 @@\n-  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -3780,0 +3767,1 @@\n+  refArrayHandle rah(THREAD, (refArrayOop)ah()); \/\/ j.l.Thread is an identity class, arrays are always reference arrays\n@@ -3785,1 +3773,1 @@\n-    oop thread_obj = ah->obj_at(i);\n+    oop thread_obj = rah->obj_at(i);\n@@ -3837,1 +3825,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::Object_klass(), 3, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::Object_klass(), 3, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -3872,1 +3860,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":56,"deletions":68,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-                                                   length, CHECK_(empty));\n+                                                   length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(empty));\n@@ -322,1 +322,1 @@\n-                                                   length, CHECK_(objArrayHandle()));\n+                                                   length, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(objArrayHandle()));\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,3 +379,4 @@\n-UNSAFE_ENTRY(jint, Unsafe_ArrayLayout(JNIEnv *env, jobject unsafe, jclass c)) {\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n-  if (!k->is_flatArray_klass()) {\n+UNSAFE_ENTRY(jint, Unsafe_ArrayLayout(JNIEnv *env, jobject unsafe, jarray array)) {\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n@@ -383,0 +384,2 @@\n+  } else if (ak->is_flatArray_klass()) {\n+    return (jint)FlatArrayKlass::cast(ak)->layout_kind();\n@@ -384,1 +387,2 @@\n-    return (jint)FlatArrayKlass::cast(k)->layout_kind();\n+    ShouldNotReachHere();\n+    return -1;\n@@ -432,1 +436,15 @@\n-  oop array = oopFactory::new_flatArray(vk, len, lk, CHECK_NULL);\n+  ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+  switch(lk) {\n+    case LayoutKind::ATOMIC_FLAT:\n+      props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+    break;\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+      props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+    break;\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+    props = ArrayKlass::ArrayProperties::NON_ATOMIC;\n+    break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  oop array = oopFactory::new_flatArray(vk, len, props, lk, CHECK_NULL);\n@@ -436,5 +454,0 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_IsFlatArray(JNIEnv *env, jobject unsafe, jclass c)) {\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n-  return k->is_flatArray_klass();\n-} UNSAFE_END\n-\n@@ -868,3 +881,0 @@\n-  } else if (k->is_objArray_klass()) {\n-    base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n-    scale = heapOopSize;\n@@ -876,5 +886,9 @@\n-  } else if (k->is_flatArray_klass()) {\n-    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n-    InlineKlass* vklass = vak->element_klass();\n-    base = vak->array_header_in_bytes();\n-    scale = vak->element_byte_size();\n+  } else if (k->is_objArray_klass()) {\n+    Klass* ek = ObjArrayKlass::cast(k)->element_klass();\n+    if (!ek->is_identity_class() && !ek->is_abstract()) {\n+      \/\/ Arrays of a concrete value class type can have multiple layouts\n+      \/\/ There's no good value to return, so throwing an exception is the way out\n+      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Arrays of a concrete value class don't have a single base and offset\");\n+    }\n+    base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+    scale = heapOopSize;\n@@ -886,0 +900,15 @@\n+UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset1(JNIEnv *env, jobject unsafe, jarray array)) {\n+  assert(array != nullptr, \"array must not be null\");\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  assert(ar->is_array(), \"Must be an array\");\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n+    return arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+  } else if (ak->is_flatArray_klass()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(ak);\n+    return fak->array_header_in_bytes();\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+} UNSAFE_END\n+\n@@ -915,0 +944,14 @@\n+UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale1(JNIEnv *env, jobject unsafe, jarray array)) {\n+  assert(array != nullptr, \"array must not be null\");\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  assert(ar->is_array(), \"Must be an array\");\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n+    return heapOopSize;\n+  } else if (ak->is_flatArray_klass()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(ak);\n+    return fak->element_byte_size();\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+} UNSAFE_END\n@@ -1134,0 +1177,2 @@\n+#define OBJ_ARR \"[\" OBJ\n+\n@@ -1153,1 +1198,0 @@\n-    {CC \"isFlatArray\",          CC \"(\" CLS \")Z\",          FN_PTR(Unsafe_IsFlatArray)},\n@@ -1157,1 +1201,1 @@\n-    {CC \"arrayLayout0\",         CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_ArrayLayout)},\n+    {CC \"arrayLayout0\",         CC \"(\" OBJ_ARR \")I\",      FN_PTR(Unsafe_ArrayLayout)},\n@@ -1189,0 +1233,1 @@\n+    {CC \"arrayBaseOffset1\",   CC \"(\" OBJ_ARR \")I\",       FN_PTR(Unsafe_ArrayBaseOffset1)},\n@@ -1190,0 +1235,1 @@\n+    {CC \"arrayIndexScale1\",   CC \"(\" OBJ_ARR \")I\",       FN_PTR(Unsafe_ArrayIndexScale1)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  objArrayOop returnvalue_array = oopFactory::new_objArray(k, parser.num_arguments() * 2, CHECK_NULL);\n+  objArrayOop returnvalue_array = oopFactory::new_objArray(k, parser.num_arguments() * 2, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,0 +361,12 @@\n+bool Arguments::patching_migrated_classes(const char* property, const char* value) {\n+  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+    const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN)) {\n+      if (strcmp(value, \"java.base-valueclasses.jar\")) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+  static bool patching_migrated_classes(const char* property, const char* value);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1270,0 +1270,13 @@\n+    \/\/ If it's an array, get the properties\n+    if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+      assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+      nmethod* nm = fr->cb()->as_nmethod_or_null();\n+      if (nm->is_compiled_by_c2()) {\n+        assert(sv->has_properties(), \"Property information is missing\");\n+        ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint());\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+      } else {\n+        \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+      }\n+    }\n@@ -1273,3 +1286,2 @@\n-    if (sv->maybe_null()) {\n-      assert(k->is_inline_klass(), \"must be an inline klass\");\n-      jint null_marker = StackValue::create_stack_value(fr, reg_map, sv->null_marker())->get_jint();\n+    if (k->is_inline_klass() && sv->has_properties()) {\n+      jint null_marker = StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint();\n@@ -1312,1 +1324,1 @@\n-      obj = ak->allocate(sv->field_size(), ak->layout_kind(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1319,2 +1331,2 @@\n-    } else if (k->is_objArray_klass()) {\n-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+    } else if (k->is_refArray_klass()) {\n+      RefArrayKlass* ak = RefArrayKlass::cast(k);\n@@ -1322,1 +1334,1 @@\n-      obj = ak->allocate(sv->field_size(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1677,0 +1689,14 @@\n+    \/\/ If it's an array, get the properties\n+    if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+      assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+      nmethod* nm = fr->cb()->as_nmethod_or_null();\n+      if (nm->is_compiled_by_c2()) {\n+        assert(sv->has_properties(), \"Property information is missing\");\n+        ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint());\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+      } else {\n+        \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+      }\n+    }\n+\n@@ -1678,1 +1704,1 @@\n-    assert(obj.not_null() || realloc_failures || sv->maybe_null(), \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->has_properties(), \"reallocation was missed\");\n@@ -1723,1 +1749,1 @@\n-    } else if (k->is_objArray_klass()) {\n+    } else if (k->is_refArray_klass()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -843,0 +843,3 @@\n+  develop(ccstrlist, PrintInlineKlassFields, \"\",                            \\\n+          \"Print fields collected by InlineKlass::collect_fields\")          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+DEF_HANDLE(refArray         , is_refArray_noinline         )\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+DEF_HANDLE_CONSTR(refArray , is_refArray_noinline )\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,1 +233,2 @@\n-    value->l = cast_from_oop<jobject>(objArrayOop(a)->obj_at(index));\n+    oop o = objArrayOop(a)->obj_at(index, CHECK_(T_ILLEGAL)); \/\/ reading from a flat array can throw an OOM\n+    value->l = cast_from_oop<jobject>(o);\n@@ -356,1 +357,1 @@\n-    return oopFactory::new_objArray(k, length, THREAD);\n+    return oopFactory::new_objArray(k, length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n@@ -727,1 +728,1 @@\n-    m = oopFactory::new_objArray(vmClasses::Class_klass(), parameter_count, CHECK_(objArrayHandle()));\n+    m = oopFactory::new_objArray(vmClasses::Class_klass(), parameter_count, ArrayKlass::ArrayProperties::DEFAULT, CHECK_(objArrayHandle()));\n@@ -1069,2 +1070,2 @@\n-    oop type_mirror = ptypes->obj_at(i);\n-    oop arg = args->obj_at(i);\n+    oop type_mirror = ptypes->obj_at(i, CHECK_NULL);\n+    oop arg = args->obj_at(i, CHECK_NULL);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -251,4 +251,7 @@\n-    if (ov->maybe_null()) {\n-      \/\/ Don't treat inline type as scalar replaced if it is null\n-      jint null_marker = StackValue::create_stack_value(fr, reg_map, ov->null_marker())->get_jint();\n-      scalar_replaced &= (null_marker != 0);\n+    if (ov->has_properties()) {\n+      Klass* k = java_lang_Class::as_Klass(ov->klass()->as_ConstantOopReadValue()->value()());\n+      if (!k->is_array_klass()) {\n+        \/\/ Don't treat inline type as scalar replaced if it is null\n+        jint null_marker = StackValue::create_stack_value(fr, reg_map, ov->properties())->get_jint();\n+        scalar_replaced &= (null_marker != 0);\n+      }\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ArrayKlass*)                        \\\n+  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ObjArrayKlass*)                        \\\n@@ -942,2 +942,0 @@\n-           declare_type(FlatArrayKlass, ArrayKlass)                       \\\n-           declare_type(ObjArrayKlass, ArrayKlass)                        \\\n@@ -945,0 +943,3 @@\n+           declare_type(ObjArrayKlass, ArrayKlass)                        \\\n+             declare_type(FlatArrayKlass, ArrayKlass)                     \\\n+             declare_type(RefArrayKlass, ArrayKlass)                      \\\n@@ -1410,1 +1411,1 @@\n-  declare_constant(Klass::_lh_array_tag_obj_value)                        \\\n+  declare_constant(Klass::_lh_array_tag_ref_value)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  objArrayOop bu = oopFactory::new_objArray(mu_klass, MemoryService::num_memory_pools(), CHECK_NH);\n+  objArrayOop bu = oopFactory::new_objArray(mu_klass, MemoryService::num_memory_pools(), ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n@@ -113,1 +113,1 @@\n-  objArrayOop au = oopFactory::new_objArray(mu_klass, MemoryService::num_memory_pools(), CHECK_NH);\n+  objArrayOop au = oopFactory::new_objArray(mu_klass, MemoryService::num_memory_pools(), ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n@@ -135,1 +135,1 @@\n-  objArrayOop extra_args_array = oopFactory::new_objArray(vmClasses::Integer_klass(), 1, CHECK_NH);\n+  objArrayOop extra_args_array = oopFactory::new_objArray(vmClasses::Integer_klass(), 1, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n","filename":"src\/hotspot\/share\/services\/gcNotifier.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, num_memory_pools, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(ik, num_memory_pools, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -563,1 +563,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, num_mgrs, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(ik, num_mgrs, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1213,1 +1213,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, num_snapshots, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(ik, num_snapshots, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1245,1 +1245,1 @@\n-      objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), num_locked_monitors, CHECK_NULL);\n+      objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), num_locked_monitors, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1287,1 +1287,1 @@\n-      objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), num_locked_synchronizers, CHECK_NULL);\n+      objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), num_locked_synchronizers, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1428,1 +1428,1 @@\n-                                           nFlags, CHECK_NULL);\n+                                           nFlags, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1447,1 +1447,1 @@\n-    objArrayOop res = oopFactory::new_objArray(vmClasses::String_klass(), num_entries, CHECK_NULL);\n+    objArrayOop res = oopFactory::new_objArray(vmClasses::String_klass(), num_entries, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n@@ -1754,1 +1754,1 @@\n-  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, CHECK_NH);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n@@ -1963,1 +1963,1 @@\n-          dcmd_list->length(), CHECK_NULL);\n+          dcmd_list->length(), ArrayKlass::ArrayProperties::DEFAULT, CHECK_NULL);\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-  objArrayOop r = oopFactory::new_objArray(ik, num_threads, CHECK_NH);\n+  objArrayOop r = oopFactory::new_objArray(ik, num_threads, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n@@ -748,1 +748,1 @@\n-  objArrayOop ste = oopFactory::new_objArray(ik, _depth, CHECK_NH);\n+  objArrayOop ste = oopFactory::new_objArray(ik, _depth, ArrayKlass::ArrayProperties::DEFAULT, CHECK_NH);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  assert(num_type_chars == 12, \"must have tested the right number of mappings\");\n+  assert(num_type_chars == 11, \"must have tested the right number of mappings\");\n@@ -200,1 +200,0 @@\n-  _type2aelembytes[T_FLAT_ELEMENT]  = heapOopSize;\n@@ -212,2 +211,2 @@\n-  JVM_SIGNATURE_FLAT_ELEMENT, JVM_SIGNATURE_VOID,\n-  0, 0, 0, 0, 0\n+  JVM_SIGNATURE_VOID,\n+  0, 0, 0, 0, 0, 0\n@@ -229,1 +228,0 @@\n-  \"inline_type\",\n@@ -231,0 +229,1 @@\n+  \"flat element\",\n@@ -260,1 +259,1 @@\n-int type2size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 0, 1, 1, 1, 1, -1};\n+int type2size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, -1, 1, 1, 1, 1, -1};\n@@ -277,2 +276,2 @@\n-  T_OBJECT,                \/\/ T_PRIMITIVE_OBJECT = 14,\n-  T_VOID,                  \/\/ T_VOID     = 15,\n+  T_VOID,                  \/\/ T_VOID     = 14,\n+  (BasicType)0,            \/\/ T_FLAT_ELEMENT = 15,\n@@ -302,2 +301,2 @@\n-  T_OBJECT,  \/\/ T_PRIMITIVE_OBJECT = 14,\n-  T_VOID,    \/\/ T_VOID     = 15,\n+  T_VOID,    \/\/ T_VOID     = 14,\n+  (BasicType)0,  \/\/ T_FLAT_ELEMENT = 15,\n@@ -327,2 +326,2 @@\n-  T_FLAT_ELEMENT_aelem_bytes, \/\/ T_PRIMITIVE_OBJECT = 14,\n-  0,                         \/\/ T_VOID     = 15,\n+  0,                         \/\/ T_VOID     = 14,\n+  0,                         \/\/ T_FLAT_ELEMENT = 15,\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -695,2 +695,2 @@\n-  T_FLAT_ELEMENT = 14, \/\/ Not a true BasicType, only use in headers of flat arrays\n-  T_VOID        = 15,\n+  T_VOID        = 14,\n+  T_FLAT_ELEMENT = 15, \/\/ Not a true BasicType, only used in layout helpers of flat arrays\n@@ -716,1 +716,0 @@\n-    F(JVM_SIGNATURE_FLAT_ELEMENT, T_FLAT_ELEMENT, N) \\\n@@ -746,1 +745,2 @@\n-  return (t == T_OBJECT || t == T_ARRAY || t == T_FLAT_ELEMENT || (include_narrow_oop && t == T_NARROWOOP));\n+  assert(t != T_FLAT_ELEMENT, \"\");  \/\/ Strong assert to detect misuses of T_FLAT_ELEMENT\n+  return (t == T_OBJECT || t == T_ARRAY || (include_narrow_oop && t == T_NARROWOOP));\n@@ -813,1 +813,1 @@\n-  T_FLAT_ELEMENT_size = 1\n+  T_FLAT_ELEMENT_size = 0\n@@ -843,1 +843,0 @@\n-  T_FLAT_ELEMENT_aelem_bytes = 8,\n@@ -847,1 +846,0 @@\n-  T_FLAT_ELEMENT_aelem_bytes = 4,\n@@ -851,1 +849,2 @@\n-  T_VOID_aelem_bytes        = 0\n+  T_VOID_aelem_bytes        = 0,\n+  T_FLAT_ELEMENT_aelem_bytes = 0\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.invoke;\n+\n+import java.util.Optional;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Preconditions;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+\n+\/\/\/ The var handle for polymorphic arrays.\n+final class ArrayVarHandle extends VarHandle {\n+    static final int REFERENCE_BASE = Math.toIntExact(Unsafe.ARRAY_OBJECT_BASE_OFFSET);\n+    static final int REFERENCE_SHIFT = Integer.numberOfTrailingZeros(Unsafe.ARRAY_OBJECT_INDEX_SCALE);\n+    final Class<?> arrayType;\n+    final Class<?> componentType;\n+\n+    ArrayVarHandle(Class<?> arrayType) {\n+        this(arrayType, false);\n+    }\n+\n+    private ArrayVarHandle(Class<?> arrayType, boolean exact) {\n+        super(ArrayVarHandle.FORM, exact);\n+        this.arrayType = arrayType;\n+        this.componentType = arrayType.getComponentType();\n+    }\n+\n+    @Override\n+    public ArrayVarHandle withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior()\n+                ? this\n+                : new ArrayVarHandle(arrayType, true);\n+    }\n+\n+    @Override\n+    public ArrayVarHandle withInvokeBehavior() {\n+        return !hasInvokeExactBehavior()\n+                ? this\n+                : new ArrayVarHandle(arrayType, false);\n+    }\n+\n+    @Override\n+    public Optional<VarHandleDesc> describeConstable() {\n+        var arrayTypeRef = arrayType.describeConstable();\n+        if (arrayTypeRef.isEmpty())\n+            return Optional.empty();\n+\n+        return Optional.of(VarHandleDesc.ofArray(arrayTypeRef.get()));\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(AccessType at) {\n+        return at.accessModeType(arrayType, componentType, int.class);\n+    }\n+\n+    @ForceInline\n+    static Object storeCheck(ArrayVarHandle handle, Object[] oarray, Object value) {\n+        if (value == null && ValueClass.isNullRestrictedArray(oarray)) {\n+            throw new NullPointerException(\"null not allowed for null-restricted array \" + oarray.getClass().toGenericString());\n+        }\n+        if (handle.arrayType == oarray.getClass()) {\n+            \/\/ Fast path: static array type same as argument array type\n+            return handle.componentType.cast(value);\n+        } else {\n+            \/\/ Slow path: check value against argument array component type\n+            return reflectiveTypeCheck(oarray, value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static Object reflectiveTypeCheck(Object[] oarray, Object value) {\n+        try {\n+            return oarray.getClass().getComponentType().cast(value);\n+        } catch (ClassCastException e) {\n+            throw new ArrayStoreException();\n+        }\n+    }\n+\n+    @ForceInline\n+    static Object get(VarHandle ob, Object oarray, int index) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        return array[index];\n+    }\n+\n+    @ForceInline\n+    static void set(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        array[index] = storeCheck(handle, array, value);\n+    }\n+\n+    @ForceInline\n+    static Object getVolatile(VarHandle ob, Object oarray, int index) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getFlatValueVolatile(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n+        }\n+        return UNSAFE.getReferenceVolatile(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE);\n+    }\n+\n+    @ForceInline\n+    static void setVolatile(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            UNSAFE.putFlatValueVolatile(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+            return;\n+        }\n+        UNSAFE.putReferenceVolatile(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object getOpaque(VarHandle ob, Object oarray, int index) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getFlatValueOpaque(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n+        }\n+        return UNSAFE.getReferenceOpaque(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE);\n+    }\n+\n+    @ForceInline\n+    static void setOpaque(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            UNSAFE.putFlatValueOpaque(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+            return;\n+        }\n+        UNSAFE.putReferenceOpaque(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object getAcquire(VarHandle ob, Object oarray, int index) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getFlatValueAcquire(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n+        }\n+        return UNSAFE.getReferenceAcquire(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE);\n+    }\n+\n+    @ForceInline\n+    static void setRelease(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            UNSAFE.putFlatValueRelease(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+            return;\n+        }\n+        UNSAFE.putReferenceRelease(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static boolean compareAndSet(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.compareAndSetFlatValue(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.compareAndSetReference(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object compareAndExchange(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.compareAndExchangeFlatValue(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.compareAndExchangeReference(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object compareAndExchangeAcquire(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.compareAndExchangeFlatValueAcquire(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.compareAndExchangeReferenceAcquire(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object compareAndExchangeRelease(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.compareAndExchangeFlatValueRelease(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.compareAndExchangeReferenceRelease(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.weakCompareAndSetFlatValuePlain(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.weakCompareAndSetReferencePlain(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSet(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.weakCompareAndSetFlatValue(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.weakCompareAndSetReference(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.weakCompareAndSetFlatValueAcquire(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.weakCompareAndSetReferenceAcquire(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object oarray, int index, Object expected, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.weakCompareAndSetFlatValueRelease(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    arrayType.componentType().cast(expected),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.weakCompareAndSetReferenceRelease(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE, handle.componentType,\n+                handle.componentType.cast(expected),\n+                storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object getAndSet(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getAndSetFlatValue(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.getAndSetReference(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                handle.componentType, storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object getAndSetAcquire(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getAndSetFlatValueAcquire(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.getAndSetReferenceAcquire(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                handle.componentType, storeCheck(handle, array, value));\n+    }\n+\n+    @ForceInline\n+    static Object getAndSetRelease(VarHandle ob, Object oarray, int index, Object value) {\n+        ArrayVarHandle handle = (ArrayVarHandle) ob;\n+        Object[] array = (Object[]) handle.arrayType.cast(oarray);\n+        Class<?> arrayType = oarray.getClass();\n+        if (ValueClass.isFlatArray(oarray)) {\n+            \/\/ delegate to flat access primitives\n+            VarHandles.checkAtomicFlatArray(array);\n+            int aoffset = (int) UNSAFE.arrayBaseOffset(array);\n+            int ascale = UNSAFE.arrayIndexScale(array);\n+            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+            int layout = UNSAFE.arrayLayout(array);\n+            return UNSAFE.getAndSetFlatValueRelease(array,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                    storeCheck(handle, array, value));\n+        }\n+        return UNSAFE.getAndSetReferenceRelease(array,\n+                (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << REFERENCE_SHIFT) + REFERENCE_BASE,\n+                handle.componentType, storeCheck(handle, array, value));\n+    }\n+\n+    static final VarForm FORM = new VarForm(ArrayVarHandle.class, Object[].class, Object.class, int.class);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ArrayVarHandle.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -476,0 +476,1 @@\n+             ArrayVarHandle,\n@@ -503,1 +504,0 @@\n-             VarHandleReferences.Array,\n@@ -510,1 +510,0 @@\n-             VarHandleNonAtomicReferences.Array,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -279,5 +279,0 @@\n-\n-        int aoffset = (int) UNSAFE.arrayBaseOffset(arrayClass);\n-        int ascale = UNSAFE.arrayIndexScale(arrayClass);\n-        int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-\n@@ -289,1 +284,1 @@\n-            return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));\n+            return maybeAdapt(new ArrayVarHandle(arrayClass));\n@@ -292,1 +287,1 @@\n-            return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleBooleans.Array.NON_EXACT_INSTANCE);\n@@ -295,1 +290,1 @@\n-            return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleBytes.Array.NON_EXACT_INSTANCE);\n@@ -298,1 +293,1 @@\n-            return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleShorts.Array.NON_EXACT_INSTANCE);\n@@ -301,1 +296,1 @@\n-            return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleChars.Array.NON_EXACT_INSTANCE);\n@@ -304,1 +299,1 @@\n-            return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleInts.Array.NON_EXACT_INSTANCE);\n@@ -307,1 +302,1 @@\n-            return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleLongs.Array.NON_EXACT_INSTANCE);\n@@ -310,1 +305,1 @@\n-            return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleFloats.Array.NON_EXACT_INSTANCE);\n@@ -313,1 +308,1 @@\n-            return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));\n+            return maybeAdapt(VarHandleDoubles.Array.NON_EXACT_INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -828,13 +828,2 @@\n-        final int abase;\n-        final int ashift;\n-#if[Object]\n-        final Class<{#if[Object]??:$type$[]}> arrayType;\n-        final Class<?> componentType;\n-#end[Object]\n-#if[FlatValue]\n-        final int layout;\n-#end[FlatValue]\n-\n-        Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}{#if[FlatValue]?, int layout}) {\n-            this(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, false);\n-        }\n+        static final long BASE = UNSAFE.arrayBaseOffset($type$[].class);\n+        static final int SHIFT = Integer.numberOfTrailingZeros(UNSAFE.arrayIndexScale($type$[].class));\n@@ -842,1 +831,1 @@\n-        private Array(int abase, int ashift{#if[Object]?, Class<?> arrayType}{#if[FlatValue]?, int layout}, boolean exact) {\n+        private Array(boolean exact) {\n@@ -844,9 +833,0 @@\n-            this.abase = abase;\n-            this.ashift = ashift;\n-#if[Object]\n-            this.arrayType = {#if[Object]?arrayType:$type$[].class};\n-            this.componentType = arrayType.getComponentType();\n-#end[Object]\n-#if[FlatValue]\n-            this.layout = layout;\n-#end[FlatValue]\n@@ -859,1 +839,1 @@\n-                : new Array(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, true);\n+                : EXACT_INSTANCE;\n@@ -866,1 +846,1 @@\n-                : new Array(abase, ashift{#if[Object]?, arrayType}{#if[FlatValue]?, layout}, false);\n+                : NON_EXACT_INSTANCE;\n@@ -871,5 +851,1 @@\n-            var arrayTypeRef = {#if[Object]?arrayType:$type$[].class}.describeConstable();\n-            if (!arrayTypeRef.isPresent())\n-                return Optional.empty();\n-\n-            return Optional.of(VarHandleDesc.ofArray(arrayTypeRef.get()));\n+            return Optional.of(VarHandleDesc.ofArray($type$[].class.describeConstable().orElseThrow()));\n@@ -880,25 +856,1 @@\n-            return at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?componentType:$type$.class}, int.class);\n-        }\n-\n-#if[Object]\n-        @ForceInline\n-        static Object runtimeTypeCheck(Array handle, Object[] oarray, Object value) {\n-            if (value == null && ValueClass.isNullRestrictedArray(oarray)) {\n-                throw new NullPointerException(\"null not allowed for null-restricted array \" + oarray.getClass().toGenericString());\n-            }\n-            if (handle.arrayType == oarray.getClass()) {\n-                \/\/ Fast path: static array type same as argument array type\n-                return handle.componentType.cast(value);\n-            } else {\n-                \/\/ Slow path: check value against argument array component type\n-                return reflectiveTypeCheck(oarray, value);\n-            }\n-        }\n-\n-        @ForceInline\n-        static Object reflectiveTypeCheck(Object[] oarray, Object value) {\n-            try {\n-                return oarray.getClass().getComponentType().cast(value);\n-            } catch (ClassCastException e) {\n-                throw new ArrayStoreException();\n-            }\n+            return at.accessModeType($type$[].class, $type$.class, int.class);\n@@ -906,1 +858,0 @@\n-#end[Object]\n@@ -910,4 +861,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -915,1 +862,0 @@\n-#end[Object]\n@@ -921,4 +867,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -926,2 +868,1 @@\n-#end[Object]\n-            array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};\n+            array[index] = value;\n@@ -933,4 +874,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -938,14 +875,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getFlatValueVolatile(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n-            }\n-#end[Reference]\n@@ -953,1 +876,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE);\n@@ -958,4 +881,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -963,16 +882,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                UNSAFE.putFlatValueVolatile(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-                return;\n-            }\n-#end[Reference]\n@@ -980,2 +883,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -986,4 +889,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -991,14 +890,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getFlatValueOpaque(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n-            }\n-#end[Reference]\n@@ -1006,1 +891,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE);\n@@ -1011,4 +896,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1016,16 +897,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                UNSAFE.putFlatValueOpaque(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-                return;\n-            }\n-#end[Reference]\n@@ -1033,2 +898,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -1039,4 +904,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1044,14 +905,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getFlatValueAcquire(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n-            }\n-#end[Reference]\n@@ -1059,1 +906,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE);\n@@ -1064,4 +911,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1069,16 +912,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                UNSAFE.putFlatValueRelease(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-                return;\n-            }\n-#end[Reference]\n@@ -1086,2 +913,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -1093,4 +920,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1098,16 +921,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.compareAndSetFlatValue(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1115,3 +922,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1122,4 +929,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1127,16 +930,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.compareAndExchangeFlatValue(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1144,3 +931,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1151,4 +938,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1156,16 +939,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.compareAndExchangeFlatValueAcquire(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1173,3 +940,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1180,4 +947,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1185,16 +948,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.compareAndExchangeFlatValueRelease(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1202,3 +949,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1209,4 +956,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1214,16 +957,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.weakCompareAndSetFlatValuePlain(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1231,3 +958,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1238,4 +965,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1243,16 +966,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.weakCompareAndSetFlatValue(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1260,3 +967,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1267,4 +974,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1272,16 +975,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.weakCompareAndSetFlatValueAcquire(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1289,3 +976,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1296,4 +983,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1301,16 +984,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.weakCompareAndSetFlatValueRelease(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         arrayType.componentType().cast(expected),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1318,3 +985,3 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n-                    {#if[Object]?handle.componentType.cast(expected):expected},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    expected,\n+                    value);\n@@ -1325,4 +992,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1330,15 +993,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getAndSetFlatValue(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1346,2 +994,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -1352,4 +1000,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1357,15 +1001,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getAndSetFlatValueAcquire(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1373,2 +1002,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -1379,4 +1008,0 @@\n-            Array handle = (Array)ob;\n-#if[Object]\n-            Object[] array = (Object[]) handle.arrayType.cast(oarray);\n-#else[Object]\n@@ -1384,15 +1009,0 @@\n-#end[Object]\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n-                \/\/ delegate to flat access primitives\n-                VarHandles.checkAtomicFlatArray(array);\n-                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n-                int ascale = UNSAFE.arrayIndexScale(arrayType);\n-                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-                int layout = UNSAFE.arrayLayout(arrayType);\n-                return UNSAFE.getAndSetFlatValueRelease(array,\n-                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n-                         runtimeTypeCheck(handle, array, value));\n-            }\n-#end[Reference]\n@@ -1400,2 +1010,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n-                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n+                    value);\n@@ -1408,1 +1018,0 @@\n-            Array handle = (Array)ob;\n@@ -1411,1 +1020,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1417,1 +1026,0 @@\n-            Array handle = (Array)ob;\n@@ -1420,1 +1028,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1426,1 +1034,0 @@\n-            Array handle = (Array)ob;\n@@ -1429,1 +1036,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1437,1 +1044,0 @@\n-            Array handle = (Array)ob;\n@@ -1440,1 +1046,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1446,1 +1052,0 @@\n-            Array handle = (Array)ob;\n@@ -1449,1 +1054,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1455,1 +1060,0 @@\n-            Array handle = (Array)ob;\n@@ -1458,1 +1062,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1464,1 +1068,0 @@\n-            Array handle = (Array)ob;\n@@ -1467,1 +1070,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1473,1 +1076,0 @@\n-            Array handle = (Array)ob;\n@@ -1476,1 +1078,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1482,1 +1084,0 @@\n-            Array handle = (Array)ob;\n@@ -1485,1 +1086,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1491,1 +1092,0 @@\n-            Array handle = (Array)ob;\n@@ -1494,1 +1094,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1500,1 +1100,0 @@\n-            Array handle = (Array)ob;\n@@ -1503,1 +1102,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1509,1 +1108,0 @@\n-            Array handle = (Array)ob;\n@@ -1512,1 +1110,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << SHIFT) + BASE,\n@@ -1518,1 +1116,3 @@\n-        static final VarForm FORM = new VarForm(Array.class, {#if[Object]?Object[].class:$type$[].class}, {#if[Object]?Object.class:$type$.class}, int.class);\n+        static final VarForm FORM = new VarForm(Array.class, $type$[].class, $type$.class, int.class);\n+        static final Array NON_EXACT_INSTANCE = new Array(false);\n+        static final Array EXACT_INSTANCE = new Array(true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":62,"deletions":462,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-    public int arrayLayout(Class<?> arrayClass) {\n-        if (arrayClass == null) {\n+    public int arrayLayout(Object[] array) {\n+        if (array == null) {\n@@ -241,1 +241,1 @@\n-        return arrayLayout0(arrayClass);\n+        return arrayLayout0(array);\n@@ -244,1 +244,1 @@\n-    private native int arrayLayout0(Object o);\n+    private native int arrayLayout0(Object[] array);\n@@ -266,6 +266,0 @@\n-    \/**\n-     * Returns true if the given class is a flattened array.\n-     *\/\n-    @IntrinsicCandidate\n-    public native boolean isFlatArray(Class<?> arrayClass);\n-\n@@ -1416,0 +1410,7 @@\n+    public long arrayBaseOffset(Object[] array) {\n+        if (array == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        return arrayBaseOffset1(array);\n+    }\n@@ -1475,0 +1476,8 @@\n+    public int arrayIndexScale(Object[] array) {\n+        if (array == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        return arrayIndexScale1(array);\n+    }\n+\n@@ -2870,1 +2879,1 @@\n-        Object expectedArray = newSpecialArray(valueType, 1, layout);\n+        Object[] expectedArray = newSpecialArray(valueType, 1, layout);\n@@ -2872,2 +2881,2 @@\n-        long base = arrayBaseOffset(expectedArray.getClass());\n-        int scale = arrayIndexScale(expectedArray.getClass());\n+        long base = arrayBaseOffset(expectedArray);\n+        int scale = arrayIndexScale(expectedArray);\n@@ -4402,0 +4411,1 @@\n+    private native int arrayBaseOffset1(Object[] array);\n@@ -4403,0 +4413,1 @@\n+    private native int arrayIndexScale1(Object[] array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    metadataTypeArray = new Type[11];\n+    metadataTypeArray = new Type[12];\n@@ -132,0 +132,1 @@\n+    metadataTypeArray[11] = db.lookupType(\"RefArrayKlass\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  public static int LH_ARRAY_TAG_OBJ_VALUE;\n+\n@@ -77,1 +77,0 @@\n-    LH_ARRAY_TAG_OBJ_VALUE     = db.lookupIntConstant(\"Klass::_lh_array_tag_obj_value\").intValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -28,0 +29,2 @@\n+\/\/ TODO FIXME This test needs to be rewritten after objArray\/refArray\/flatArray rework\n+\n@@ -60,1 +63,1 @@\n-      EXPECT_EQ(objArrayOopDesc::object_size(1), (size_t)x[i].result);\n+      EXPECT_EQ(refArrayOopDesc::object_size(1), (size_t)x[i].result);\n","filename":"test\/hotspot\/gtest\/oops\/test_objArrayOop.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -224,0 +224,26 @@\n+runtime\/valhalla\/inlinetypes\/ValuePreloadTest.java 8366440 generic-all\n+runtime\/verifier\/CFLH\/TestVerify.java 8366440 generic-all\n+\n+# Array Changes TODO\n+serviceability\/sa\/CDSJMapClstats.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbClasses.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DisableRegistryTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbDumpheap.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbTestConnectArgument.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJhisto.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id1 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackWithConcurrentLock.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackXcompStress.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#process 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#core 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id0 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id1 8365722 generic-all\n+serviceability\/sa\/DeadlockDetectionTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id0 8365722 generic-all\n+serviceability\/sa\/TestInstanceKlassSize.java 8365722 generic-all\n+serviceability\/sa\/TestSysProps.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java 8365722 generic-all\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8365722 generic-all\n+serviceability\/HeapDump\/DuplicateArrayClassesTest.java 8365722 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore TODO 8366668\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,2 @@\n-        ARRAY_STORE_EXCEPTION(\"array_check\"),\n+        \/\/ TODO 8366668 This currently fails\n+        \/\/ ARRAY_STORE_EXCEPTION(\"array_check\"),\n@@ -105,0 +106,2 @@\n+            \/\/ TODO 8366668 Re-enable\n+            \/*\n@@ -108,0 +111,1 @@\n+            *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-        test.addFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n+        \/\/ TODO 8366668 Re-enable IR verification\n+        test.addFlags(\"-DVerifyIR=false\", \"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test the VM internal metadata for arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:-MonomorphicArrayCheck -XX:-OmitStackTraceInFastThrow\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -Xcomp\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -XX:MultiArrayExpandLimit=0\n+                     compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::* -XX:CompileCommand=dontinline,*TestArrayMetadata::test*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::* -XX:CompileCommand=dontinline,*TestArrayMetadata::*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::main -XX:CompileCommand=dontinline,*TestArrayMetadata::test*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestArrayMetadata {\n+\n+    static interface MyInterface {\n+\n+    }\n+\n+    public static Object[] testArrayAllocation1() {\n+        return new Object[1];\n+    }\n+\n+    public static Object[][] testArrayAllocation2() {\n+        return new Object[1][1];\n+    }\n+\n+    public static Class getClass1() {\n+        return Object.class;\n+    }\n+\n+    public static Object[] testArrayAllocation3() {\n+        return (Object[])Array.newInstance(getClass1(), 1);\n+    }\n+\n+    public static Class getClass2() {\n+        return TestArrayMetadata.class;\n+    }\n+\n+    public static Object[] testArrayAllocation4() {\n+        return (TestArrayMetadata[])Array.newInstance(getClass2(), 1);\n+    }\n+\n+    public static Object[] testArrayAllocation5() {\n+        return new MyInterface[1];\n+    }\n+\n+    public static Object[] testArrayAllocation6() {\n+        return new Integer[1];\n+    }\n+\n+    public static Object[] testCheckcast1(Object arg) {\n+        return (Object[])arg;\n+    }\n+\n+    public static Object[] testCheckcast2(Object arg) {\n+        return (TestArrayMetadata[])arg;\n+    }\n+\n+    public static Cloneable testCheckcast3(Object arg) {\n+        return (Cloneable)arg;\n+    }\n+\n+    public static Object testCheckcast4(Object arg) {\n+        return (Object)arg;\n+    }\n+\n+    public static Object[][] testCheckcast5(Object arg) {\n+        return (Object[][])arg;\n+    }\n+\n+    public static MyInterface[] testCheckcast6(Object arg) {\n+        return (MyInterface[])arg;\n+    }\n+\n+    public static Integer[] testCheckcast7(Object arg) {\n+        return (Integer[])arg;\n+    }\n+\n+    public static Class getArrayClass1() {\n+        return Object[].class;\n+    }\n+\n+    public static boolean testIsInstance1(Object arg) {\n+        return getArrayClass1().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass2() {\n+        return TestArrayMetadata[].class;\n+    }\n+\n+    public static boolean testIsInstance2(Object arg) {\n+        return getArrayClass2().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass3() {\n+        return Cloneable.class;\n+    }\n+\n+    public static boolean testIsInstance3(Object arg) {\n+        return getArrayClass3().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass4() {\n+        return Object.class;\n+    }\n+\n+    public static boolean testIsInstance4(Object arg) {\n+        return getArrayClass4().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass5() {\n+        return Object[][].class;\n+    }\n+\n+    public static boolean testIsInstance5(Object arg) {\n+        return getArrayClass5().isInstance(arg);\n+    }\n+\n+    public static Object[] testCopyOf1(Object[] array, Class<? extends Object[]> clazz) {\n+        return Arrays.copyOf(array, 1, clazz);\n+    }\n+\n+    public static Object[] testCopyOf2(Object[] array) {\n+        return Arrays.copyOf(array, array.length, array.getClass());\n+    }\n+\n+    public static Class testGetSuperclass1(Object[] array) {\n+        return array.getClass().getSuperclass();\n+    }\n+\n+    public static Class testGetSuperclass2() {\n+        return Object[].class.getSuperclass();\n+    }\n+\n+    public static Class testGetSuperclass3() {\n+        return TestArrayMetadata[].class.getSuperclass();\n+    }\n+\n+    public static Object[] testClassCast1(Object array) {\n+        return Object[].class.cast(array);\n+    }\n+\n+    public static Object[] testClassCast2(Object array) {\n+        return TestArrayMetadata[].class.cast(array);\n+    }\n+\n+    public static Object testClassCast3(Class c, Object array) {\n+        return c.cast(array);\n+    }\n+\n+    public static void test5(Object[] array, Object obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test6(Object[][] array, Object[] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test7(Object[][][] array, Object[][] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test8(Object[][][][] array, Object[][][] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test9(Object[][] array) {\n+        array[0] = (Object[]) new Object[0];\n+    }\n+\n+    public static void test10(Object[][] array) {\n+        array[0] = new String[0];\n+    }\n+\n+    public static boolean testIsAssignableFrom1(Class clazz1, Class clazz2) {\n+        return clazz1.isAssignableFrom(clazz2);\n+    }\n+\n+    public static boolean testIsAssignableFrom2(Object obj, Class clazz) {\n+        return obj.getClass().isAssignableFrom(clazz);\n+    }\n+\n+    public static boolean testIsAssignableFrom3(Class clazz, Object obj) {\n+        return clazz.isAssignableFrom(obj.getClass());\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100_000; ++i) {\n+            Object[] array1 = testArrayAllocation1();\n+            Object[][] array2 = testArrayAllocation2();\n+            Object[] array3 = testArrayAllocation3();\n+            Object[] array4 = testArrayAllocation4();\n+            Object[] array5 = testArrayAllocation5();\n+            Object[] array6 = testArrayAllocation6();\n+\n+            testCheckcast1(new Object[0]);\n+            testCheckcast1(new TestArrayMetadata[0]);\n+            testCheckcast1(array1);\n+            testCheckcast1(array3);\n+            testCheckcast1(array4);\n+            testCheckcast1(array5);\n+            testCheckcast1(array6);\n+            try {\n+                testCheckcast1(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(new Object[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(array1);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            testCheckcast2(new TestArrayMetadata[0]);\n+            testCheckcast2(array4);\n+            try {\n+                testCheckcast2(array5);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            testCheckcast3(new Object[0]);\n+            testCheckcast3(new TestArrayMetadata[0]);\n+            testCheckcast3(array1);\n+            testCheckcast3(array3);\n+            testCheckcast3(array4);\n+            testCheckcast3(array5);\n+            testCheckcast3(array6);\n+            try {\n+                testCheckcast3(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCheckcast4(new Object[0]);\n+            testCheckcast4(new TestArrayMetadata[0]);\n+            testCheckcast4(array1);\n+            testCheckcast4(array3);\n+            testCheckcast4(array4);\n+            testCheckcast4(array5);\n+            testCheckcast4(array6);\n+            testCheckcast4(42);\n+\n+            testCheckcast5(new Object[0][0]);\n+            testCheckcast5(new TestArrayMetadata[0][0]);\n+            testCheckcast5(array2);\n+            try {\n+                testCheckcast5(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCheckcast6(array5);\n+\n+            testCheckcast7(array6);\n+\n+            testCopyOf1(new Object[1], Object[].class);\n+            testCopyOf1(new TestArrayMetadata[1], Object[].class);\n+            testCopyOf1(new Object[1], TestArrayMetadata[].class);\n+            testCopyOf1(new TestArrayMetadata[1], TestArrayMetadata[].class);\n+            try {\n+                testCopyOf1(new TestArrayMetadata[]{new TestArrayMetadata()}, Integer[].class);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCopyOf2(new Object[1]);\n+            testCopyOf2(new TestArrayMetadata[1]);\n+\n+            testClassCast1(new Object[0]);\n+            testClassCast1(new TestArrayMetadata[0]);\n+            try {\n+                testClassCast1(new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testClassCast2(new TestArrayMetadata[0]);\n+            try {\n+                testClassCast2(new Object[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testClassCast2(new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testClassCast3(TestArrayMetadata[].class, new TestArrayMetadata[0]);\n+            testClassCast3(Object[].class, new TestArrayMetadata[0]);\n+            testClassCast3(Object[].class, new Object[0]);\n+            testClassCast3(int[].class, new int[0]);\n+            try {\n+                testClassCast3(TestArrayMetadata[].class, new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            Asserts.assertEQ(testGetSuperclass1(new Object[1]), Object.class);\n+            Asserts.assertEQ(testGetSuperclass1(new TestArrayMetadata[1]), Object.class);\n+            Asserts.assertEQ(testGetSuperclass2(), Object.class);\n+            Asserts.assertEQ(testGetSuperclass3(), Object.class);\n+\n+            Asserts.assertTrue(testIsInstance1(new Object[0]));\n+            Asserts.assertTrue(testIsInstance1(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance1(42));\n+            Asserts.assertTrue(testIsInstance1(array1));\n+            Asserts.assertTrue(testIsInstance1(array3));\n+            Asserts.assertTrue(testIsInstance1(array4));\n+            Asserts.assertTrue(testIsInstance1(array5));\n+            Asserts.assertTrue(testIsInstance1(array6));\n+\n+            Asserts.assertFalse(testIsInstance2(new Object[0]));\n+            Asserts.assertTrue(testIsInstance2(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance2(42));\n+            Asserts.assertFalse(testIsInstance2(array1));\n+            Asserts.assertFalse(testIsInstance2(array3));\n+            Asserts.assertTrue(testIsInstance2(array4));\n+            Asserts.assertFalse(testIsInstance2(array5));\n+            Asserts.assertFalse(testIsInstance2(array6));\n+\n+            Asserts.assertTrue(testIsInstance3(new Object[0]));\n+            Asserts.assertTrue(testIsInstance3(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance3(42));\n+            Asserts.assertTrue(testIsInstance3(array1));\n+            Asserts.assertTrue(testIsInstance3(array3));\n+            Asserts.assertTrue(testIsInstance3(array4));\n+            Asserts.assertTrue(testIsInstance3(array5));\n+            Asserts.assertTrue(testIsInstance3(array6));\n+\n+            Asserts.assertTrue(testIsInstance4(new Object[0]));\n+            Asserts.assertTrue(testIsInstance4(new TestArrayMetadata[0]));\n+            Asserts.assertTrue(testIsInstance4(42));\n+            Asserts.assertTrue(testIsInstance4(array1));\n+            Asserts.assertTrue(testIsInstance4(array3));\n+            Asserts.assertTrue(testIsInstance4(array4));\n+            Asserts.assertTrue(testIsInstance4(array5));\n+            Asserts.assertTrue(testIsInstance4(array6));\n+\n+            Asserts.assertTrue(testIsInstance5(new Object[0][0]));\n+            Asserts.assertTrue(testIsInstance5(new TestArrayMetadata[0][0]));\n+            Asserts.assertTrue(testIsInstance5(array2));\n+            Asserts.assertFalse(testIsInstance5(42));\n+\n+            test5(new Object[1], new TestArrayMetadata());\n+            test5((new Object[1][1])[0], (new TestArrayMetadata[1])[0]);\n+            test5(new String[1], \"42\");\n+            test5((new String[1][1])[0], (new String[1])[0]);\n+            test5(array1, new TestArrayMetadata());\n+            test5(array3, new TestArrayMetadata());\n+            test5(array4, new TestArrayMetadata());\n+            try {\n+                test5(array5, new TestArrayMetadata());\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n+\n+            test6(new Object[1][1], new TestArrayMetadata[0]);\n+            test6((new Object[1][1][1])[0], (new TestArrayMetadata[1][0])[0]);\n+            test6(new String[1][1], new String[0]);\n+            test6((new String[1][1][1])[0], (new String[1][0])[0]);\n+            test6(array2, new TestArrayMetadata[0]);\n+\n+            test7(new Object[1][1][1], new TestArrayMetadata[0][0]);\n+            test7((new Object[1][1][1][1])[0], (new TestArrayMetadata[1][0][0])[0]);\n+            test7(new String[1][1][1], new String[0][0]);\n+            test7((new String[1][1][1][1])[0], (new String[1][0][0])[0]);\n+\n+            test8(new Object[1][1][1][1], new TestArrayMetadata[0][0][0]);\n+            test8((new Object[1][1][1][1][1])[0], (new TestArrayMetadata[1][0][0][0])[0]);\n+            test8(new String[1][1][1][1], new String[0][0][0]);\n+            test8((new String[1][1][1][1][1])[0], (new String[1][0][0][0])[0]);\n+\n+            test9(new Object[1][1]);\n+            test9(array2);\n+\n+            test10(new String[1][1]);\n+            test10(array2);\n+\n+            Asserts.assertTrue(testIsAssignableFrom1(Object[].class, Object[].class));\n+            Asserts.assertTrue(testIsAssignableFrom1(Object[].class, TestArrayMetadata[].class));\n+            Asserts.assertTrue(testIsAssignableFrom1(int[].class, int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom1(Object[].class, int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom1(Object[].class, TestArrayMetadata.class));\n+\n+            Asserts.assertTrue(testIsAssignableFrom2(new Object[0], Object[].class));\n+            Asserts.assertTrue(testIsAssignableFrom2(new Object[0], TestArrayMetadata[].class));\n+            Asserts.assertTrue(testIsAssignableFrom2(new int[0], int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom2(new Object[0], int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom2(new Object[0], TestArrayMetadata.class));\n+\n+            Asserts.assertTrue(testIsAssignableFrom3(Object[].class, new Object[0]));\n+            Asserts.assertTrue(testIsAssignableFrom3(Object[].class, new TestArrayMetadata[0]));\n+            Asserts.assertTrue(testIsAssignableFrom3(int[].class, new int[0]));\n+            Asserts.assertFalse(testIsAssignableFrom3(Object[].class, new int[0]));\n+            Asserts.assertFalse(testIsAssignableFrom3(Object[].class, new TestArrayMetadata()));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayMetadata.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that rematerialized arrays keep their properties.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm compiler.valhalla.inlinetypes.TestArrayRematerializationWithProperties\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayRematerializationWithProperties::test\n+ *                   compiler.valhalla.inlinetypes.TestArrayRematerializationWithProperties\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+import jdk.test.lib.Asserts;\n+\n+@LooselyConsistentValue\n+value class MyValue  {\n+    byte x = 42;\n+    byte y = 43;\n+\n+    static final MyValue DEFAULT = new MyValue();\n+}\n+\n+public class TestArrayRematerializationWithProperties {\n+\n+    static final boolean FLAT0 = ValueClass.isFlatArray(new MyValue[1]);\n+    static final boolean FLAT1 = ValueClass.isFlatArray(ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT));\n+    static final boolean FLAT2 = ValueClass.isFlatArray(ValueClass.newNullableAtomicArray(MyValue.class, 1));\n+    static final boolean FLAT3 = ValueClass.isFlatArray(ValueClass.newNullRestrictedNonAtomicArray(MyValue.class, 1, MyValue.DEFAULT));\n+\n+    static final boolean ATOMIC0 = ValueClass.isAtomicArray(new MyValue[1]);\n+    static final boolean ATOMIC1 = ValueClass.isAtomicArray(ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT));\n+    static final boolean ATOMIC2 = ValueClass.isAtomicArray(ValueClass.newNullableAtomicArray(MyValue.class, 1));\n+    static final boolean ATOMIC3 = ValueClass.isAtomicArray(ValueClass.newNullRestrictedNonAtomicArray(MyValue.class, 1, MyValue.DEFAULT));\n+\n+    static void test(boolean b) {\n+        \/\/ C2 will scalar replace these arrays\n+        MyValue[] array0 = { MyValue.DEFAULT };\n+        MyValue[] array1 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+        MyValue[] array2 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+        array2[0] = MyValue.DEFAULT;\n+        MyValue[] array3 = (MyValue[])ValueClass.newNullRestrictedNonAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n+\n+        if (b) {\n+            \/\/ Uncommon trap, check content and properties of rematerialized arrays\n+            Asserts.assertEquals(array0[0], MyValue.DEFAULT);\n+            Asserts.assertEquals(array1[0], MyValue.DEFAULT);\n+            Asserts.assertEquals(array2[0], MyValue.DEFAULT);\n+            Asserts.assertEquals(array3[0], MyValue.DEFAULT);\n+\n+            Asserts.assertEquals(ValueClass.isAtomicArray(array0), ATOMIC0);\n+            Asserts.assertEquals(ValueClass.isAtomicArray(array1), ATOMIC1);\n+            Asserts.assertEquals(ValueClass.isAtomicArray(array2), ATOMIC2);\n+            Asserts.assertEquals(ValueClass.isAtomicArray(array3), ATOMIC3);\n+\n+            Asserts.assertFalse(ValueClass.isNullRestrictedArray(array0));\n+            Asserts.assertTrue(ValueClass.isNullRestrictedArray(array1));\n+            Asserts.assertFalse(ValueClass.isNullRestrictedArray(array2));\n+            Asserts.assertTrue(ValueClass.isNullRestrictedArray(array3));\n+\n+            Asserts.assertEquals(ValueClass.isFlatArray(array0), FLAT0);\n+            Asserts.assertEquals(ValueClass.isFlatArray(array1), FLAT1);\n+            Asserts.assertEquals(ValueClass.isFlatArray(array2), FLAT2);\n+            Asserts.assertEquals(ValueClass.isFlatArray(array3), FLAT3);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\n+        for (int i = 0; i < 100_000; ++i) {\n+            test(false);\n+        }\n+        \/\/ Trigger deopt\n+        test(true);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayRematerializationWithProperties.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2335,1 +2335,0 @@\n-    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2338,2 +2337,0 @@\n-        \/\/ Always throws a ClassCastException because we just successfully\n-        \/\/ stored null and therefore the array can't be a null-free value class array.\n@@ -2363,1 +2360,0 @@\n-    @IR(failOn = IRNode.SUBTYPE_CHECK)\n@@ -2366,2 +2362,0 @@\n-        \/\/ Always throws a ClassCastException because we just successfully\n-        \/\/ stored null and therefore the array can't be a null-free value class array.\n@@ -2555,6 +2549,1 @@\n-        try {\n-            test101NullFree(array1);\n-            throw new RuntimeException(\"Should throw ClassCastException\");\n-        } catch (ClassCastException e) {\n-            \/\/ Expected\n-        }\n+        test101NullFree(array1);\n@@ -2570,0 +2559,3 @@\n+    \/\/ TODO 8251971 Used for copyOf because we can't create a null-free, non-atomic, flat array via the mirror as a destination array\n+    static final MyValue2[] val_src2 = new MyValue2[8];\n+\n@@ -2767,1 +2759,1 @@\n-        return Arrays.copyOf(val_src, 8, val_src.getClass());\n+        return Arrays.copyOf(val_src2, 8, val_src2.getClass());\n@@ -2773,1 +2765,1 @@\n-        verify(val_src, res);\n+        verify(val_src2, res);\n@@ -2849,1 +2841,2 @@\n-    @IR(failOn = {INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, CLASS_CHECK_TRAP})\n+    \/\/ TODO 8366668\n+    \/\/ @IR(failOn = {INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, CLASS_CHECK_TRAP})\n@@ -2863,1 +2856,2 @@\n-        return Arrays.copyOf((Object[])get_obj_src(), 8, get_val_class());\n+        \/\/ TODO 8251971 Use get_val_class() here\n+        return Arrays.copyOf((Object[])get_obj_src(), 8, val_src2.getClass());\n@@ -2875,1 +2869,2 @@\n-        return Arrays.copyOf((Object[])get_obj_null_src(), 8, get_val_class());\n+        \/\/ TODO 8251971 Use get_val_class() here\n+        return Arrays.copyOf((Object[])get_obj_null_src(), 8, val_src2.getClass());\n@@ -3219,1 +3214,2 @@\n-    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    \/\/ TODO 8366668\n+    \/\/ @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                                                     \"-XX:LoopMaxUnroll=0\");\n+                                                     \"-XX:LoopMaxUnroll=0\", \"-XX:+UseArrayFlattening\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,5 +165,6 @@\n-          for (int j = 0; j < 10; ++j) {\n-            array1[0] = array1[0];\n-            if (i == 1) {\n-              h = h;\n-              array2[0] *= 42;\n+            for (int j = 0; j < 10; ++j) {\n+                array1[0] = array1[0];\n+                if (i == 1) {\n+                    h = h;\n+                    array2[0] *= 42;\n+                }\n@@ -171,1 +172,0 @@\n-          }\n@@ -174,1 +174,1 @@\n-          f5 = n;\n+            f5 = n;\n@@ -317,1 +317,1 @@\n-            for (int j = 0; j < 10; ++j)\n+            for (int j = 0; j < 10; ++j) {\n@@ -319,0 +319,1 @@\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -643,4 +643,4 @@\n-            TEST33_BASE_OFFSET = U.arrayBaseOffset(TEST33_ARRAY.getClass());\n-            TEST33_INDEX_SCALE = U.arrayIndexScale(TEST33_ARRAY.getClass());\n-            TEST33_FLATTENED_ARRAY = U.isFlatArray(TEST33_ARRAY.getClass());\n-            TEST33_LAYOUT = U.arrayLayout(TEST33_ARRAY.getClass());\n+            TEST33_BASE_OFFSET = U.arrayBaseOffset(TEST33_ARRAY);\n+            TEST33_INDEX_SCALE = U.arrayIndexScale(TEST33_ARRAY);\n+            TEST33_FLATTENED_ARRAY = ValueClass.isFlatArray(TEST33_ARRAY);\n+            TEST33_LAYOUT = U.arrayLayout(TEST33_ARRAY);\n@@ -966,5 +966,2 @@\n-        try {\n-            test50(va.getClass(), vba);\n-            throw new RuntimeException(\"should have thrown\");\n-        } catch (ClassCastException cce) {\n-        }\n+        result = test50(va.getClass(), vba);\n+        Asserts.assertEQ(result, vba);\n@@ -1611,1 +1608,1 @@\n-    \/\/ Test correctness of the Unsafe::isFlatArray intrinsic\n+    \/\/ Test correctness of the ValueClass::isFlatArray intrinsic\n@@ -1613,2 +1610,2 @@\n-    public boolean test81(Class<?> cls) {\n-        return U.isFlatArray(cls);\n+    public boolean test81(Object array) {\n+        return ValueClass.isFlatArray(array);\n@@ -1619,4 +1616,4 @@\n-        Asserts.assertEQ(test81(TEST33_ARRAY.getClass()), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n-        Asserts.assertFalse(test81(String[].class), \"test81_2 failed\");\n-        Asserts.assertFalse(test81(String.class), \"test81_3 failed\");\n-        Asserts.assertFalse(test81(int[].class), \"test81_4 failed\");\n+        Asserts.assertEQ(test81(TEST33_ARRAY), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n+        Asserts.assertFalse(test81(new String[0]), \"test81_2 failed\");\n+        Asserts.assertFalse(test81(\"test\"), \"test81_3 failed\");\n+        Asserts.assertFalse(test81(new int[0]), \"test81_4 failed\");\n@@ -1625,1 +1622,1 @@\n-    \/\/ Verify that Unsafe::isFlatArray checks with statically known classes\n+    \/\/ Verify that ValueClass::isFlatArray checks with statically known classes\n@@ -1630,1 +1627,1 @@\n-        boolean check1 = U.isFlatArray(TEST33_ARRAY.getClass());\n+        boolean check1 = ValueClass.isFlatArray(TEST33_ARRAY);\n@@ -1634,3 +1631,3 @@\n-        boolean check2 = !U.isFlatArray(String[].class);\n-        boolean check3 = !U.isFlatArray(String.class);\n-        boolean check4 = !U.isFlatArray(int[].class);\n+        boolean check2 = !ValueClass.isFlatArray(new String[0]);\n+        boolean check3 = !ValueClass.isFlatArray(\"test\");\n+        boolean check4 = !ValueClass.isFlatArray(new int[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2531,1 +2531,1 @@\n-        Asserts.assertFalse(test91((MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT)));\n+        Asserts.assertTrue(test91((MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT)));\n@@ -3551,1 +3551,2 @@\n-        Asserts.assertEquals(array1[0], empty);\n+        \/\/ TODO enable\n+        \/\/ Asserts.assertEquals(array1[0], empty);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,3 +133,46 @@\n-    private static final Integer[] testIntegerArray = new Integer[] { 42 };\n-    private static final Long[] testLongArray = new Long[] { 42L };\n-    private static final Double[] testDoubleArray = new Double[] { 42.0D };\n+\n+    \/\/ Some non-value classes\n+    static class MyInteger extends Number {\n+        int val;\n+\n+        public MyInteger(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof MyInteger)) {\n+                return false;\n+            }\n+            return this.val == ((MyInteger)o).val;\n+        }\n+\n+        public double doubleValue() { return val; }\n+        public float floatValue() { return val; }\n+        public int intValue() { return val; }\n+        public long longValue() { return val; }\n+    }\n+\n+    static class MyLong extends Number {\n+        long val;\n+\n+        public MyLong(long val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof MyLong)) {\n+                return false;\n+            }\n+            return this.val == ((MyLong)o).val;\n+        }\n+\n+        public double doubleValue() { return val; }\n+        public float floatValue() { return val; }\n+        public int intValue() { return (int)val; }\n+        public long longValue() { return val; }\n+    }\n+\n+    private static final MyInteger[] testMyIntegerArray = new MyInteger[] { new MyInteger(42) };\n+    private static final MyLong[] testMyLongArray = new MyLong[] { new MyLong(42L) };\n@@ -208,2 +251,2 @@\n-            Object o = test2(testIntegerArray);\n-            Asserts.assertEQ(o, 42);\n+            Object o = test2(testMyIntegerArray);\n+            Asserts.assertEQ(o, new MyInteger(42));\n@@ -211,2 +254,2 @@\n-            Object o = test2(testLongArray);\n-            Asserts.assertEQ(o, 42L);\n+            Object o = test2(testMyLongArray);\n+            Asserts.assertEQ(o, new MyLong(42L));\n@@ -244,4 +287,4 @@\n-            Object o = test4(testIntegerArray);\n-            Asserts.assertEQ(o, 42);\n-            o = test4(testLongArray);\n-            Asserts.assertEQ(o, 42L);\n+            Object o = test4(testMyIntegerArray);\n+            Asserts.assertEQ(o, new MyInteger(42));\n+            o = test4(testMyLongArray);\n+            Asserts.assertEQ(o, new MyLong(42L));\n@@ -401,1 +444,1 @@\n-        test10(testIntegerArray, 42);\n+        test10(testMyIntegerArray, new MyInteger(42));\n@@ -429,2 +472,2 @@\n-        test12(testIntegerArray, 42);\n-        test12(testLongArray, 42L);\n+        test12(testMyIntegerArray, new MyInteger(42));\n+        test12(testMyLongArray, new MyLong(42L));\n@@ -456,1 +499,1 @@\n-            test14(testIntegerArray, 42);\n+            test14(testMyIntegerArray, new MyInteger(42));\n@@ -461,1 +504,1 @@\n-                test14(testIntegerArray, 42);\n+                test14(testMyIntegerArray, new MyInteger(42));\n@@ -532,1 +575,1 @@\n-        test16(testIntegerArray, 42);\n+        test16(testMyIntegerArray, new MyInteger(42));\n@@ -548,4 +591,4 @@\n-        test17(testIntegerArray, 42);\n-        test17(testIntegerArray, null);\n-        testIntegerArray[0] = 42;\n-        test17(testLongArray, 42L);\n+        test17(testMyIntegerArray, new MyInteger(42));\n+        test17(testMyIntegerArray, null);\n+        testMyIntegerArray[0] = new MyInteger(42);\n+        test17(testMyLongArray, new MyLong(42L));\n@@ -574,4 +617,4 @@\n-        test18(testIntegerArray, 42);\n-        test18(testIntegerArray, null);\n-        testIntegerArray[0] = 42;\n-        test18(testLongArray, 42L);\n+        test18(testMyIntegerArray, new MyInteger(42));\n+        test18(testMyIntegerArray, null);\n+        testMyIntegerArray[0] = new MyInteger(42);\n+        test18(testMyLongArray, new MyLong(42L));\n@@ -594,2 +637,2 @@\n-        Object o = test19(testIntegerArray);\n-        Asserts.assertEQ(o, 42);\n+        Object o = test19(testMyIntegerArray);\n+        Asserts.assertEQ(o, new MyInteger(42));\n@@ -612,1 +655,1 @@\n-        test20(testIntegerArray, 42);\n+        test20(testMyIntegerArray, new MyInteger(42));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":71,"deletions":28,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @summary Test correct handling of multidimensional arrays.\n+ * @enablePreview\n+ * @run main TestMultidimArrays\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,TestMultidimArrays::test*\n+ *                   TestMultidimArrays\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:MultiArrayExpandLimit=0\n+ *                   -XX:CompileCommand=compileonly,TestMultidimArrays::test*\n+ *                   TestMultidimArrays\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=compileonly,TestMultidimArrays::test*\n+ *                   TestMultidimArrays\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:-DoEscapeAnalysis\n+ *                   -XX:CompileCommand=compileonly,TestMultidimArrays::test*\n+ *                   TestMultidimArrays\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestMultidimArrays {\n+\n+    static value class MyValue {\n+        int val;\n+\n+        public MyValue(int val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    static MyValue[][] test1() {\n+        MyValue[][] arr = new MyValue[2][2];\n+        arr[0][1] = new MyValue(42);\n+        for (int i = 0; i < 50_000; i++) {\n+        }\n+        return arr;\n+    }\n+\n+    static MyValue[][] test2() {\n+        MyValue[][] arr = new MyValue[2][2];\n+        arr[0][1] = new MyValue(42);\n+        return arr;\n+    }\n+\n+    static int[][] test3() {\n+        int[][] arr = new int[2][2];\n+        arr[0][1] = 42;\n+        return arr;\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            MyValue[][] res1 = test1();\n+            Asserts.assertEQ(res1[0][0], null);\n+            Asserts.assertEQ(res1[0][1], new MyValue(42));\n+\n+            MyValue[][] res2 = test2();\n+            Asserts.assertEQ(res2[0][0], null);\n+            Asserts.assertEQ(res2[0][1], new MyValue(42));\n+\n+            int[][] res3 = test3();\n+            Asserts.assertEQ(res3[0][0], 0);\n+            Asserts.assertEQ(res3[0][1], 42);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMultidimArrays.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2377,0 +2377,1 @@\n+        Class c = va.getClass();\n@@ -2378,1 +2379,1 @@\n-        MyValue1[] res = test88(va.getClass(), va);\n+        MyValue1[] res = test88(c, va);\n@@ -2380,0 +2381,1 @@\n+        Asserts.assertEquals(res, va);\n@@ -2381,7 +2383,4 @@\n-        test88(va.getClass(), null); \/\/ Should not throw NPE\n-        try {\n-            test88(va.getClass(), new MyValue1[1]);\n-            throw new RuntimeException(\"ClassCastException expected\");\n-        } catch (ClassCastException cce) {\n-            \/\/ Expected\n-        }\n+        test88(c, null); \/\/ Should not throw NPE\n+        va = new MyValue1[1];\n+        res = test88(c, va);\n+        Asserts.assertEquals(res, va);\n@@ -2400,0 +2399,1 @@\n+        Class c = va.getClass();\n@@ -2401,1 +2401,1 @@\n-        MyValue1[] res = test89(va.getClass(), va);\n+        MyValue1[] res = test89(c, va);\n@@ -2404,7 +2404,4 @@\n-        test89(va.getClass(), null); \/\/ Should not throw NPE\n-        try {\n-            test89(va.getClass(), new MyValue1[1]);\n-            throw new RuntimeException(\"ClassCastException expected\");\n-        } catch (ClassCastException cce) {\n-            \/\/ Expected\n-        }\n+        test89(c, null); \/\/ Should not throw NPE\n+        va = new MyValue1[1];\n+        res = test89(c, va);\n+        Asserts.assertEquals(res, va);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @summary Detect tearing on flat writes and buffering due to missing barriers.\n+ * @summary Detect tearing on flat accesses and buffering.\n@@ -64,1 +64,4 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ *                   -Xcomp -XX:-TieredCompilation\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -67,1 +70,1 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -71,1 +74,1 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -75,1 +78,1 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        Asserts.assertFalse(ValueClass.isFlatArray(array0));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array0));\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ArrayQueryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,1 +430,3 @@\n-      assertFalse(ValueClass.isFlatArray(array));\n+      Method ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      boolean expectFlat = (Boolean) ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n@@ -435,2 +437,2 @@\n-      Method ef = c.getMethod(\"expectingFlatNullRestrictedArray\", null);\n-      boolean expectFlat = (Boolean)ef.invoke(null, null);\n+      ef = c.getMethod(\"expectingFlatNullRestrictedArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n@@ -471,1 +473,1 @@\n-    int lk = UNSAFE.arrayLayout(array.getClass());\n+    int lk = UNSAFE.arrayLayout(array);\n@@ -475,1 +477,1 @@\n-      int newLk = UNSAFE.arrayLayout(newArray.getClass());\n+      int newLk = UNSAFE.arrayLayout(newArray);\n@@ -488,1 +490,1 @@\n-      int lk = UNSAFE.arrayLayout(array.getClass());\n+      int lk = UNSAFE.arrayLayout(array);\n@@ -510,1 +512,1 @@\n-    testSpecialArrayLayoutFromArray(array0, true);\n+    testSpecialArrayLayoutFromArray(array0, !arrayFlatteningEnabled);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+                \/\/ Copy of zero length on a zero-length array, must work\n@@ -386,0 +386,9 @@\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedNonAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n@@ -473,1 +482,1 @@\n-        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        \/\/ Copy of zero length on a zero-length array, must work\n@@ -475,0 +484,9 @@\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm NullRestrictedArrayTest\n+ * @run main\/othervm -XX:+UseArrayFlattening NullRestrictedArrayTest\n@@ -107,1 +107,1 @@\n-        Asserts.assertTrue(UNSAFE.isFlatArray(array.getClass()), \"Expecting flat array but array is not flat\");\n+        Asserts.assertTrue(ValueClass.isFlatArray(array), \"Expecting flat array but array is not flat\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullRestrictedArrayTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -302,2 +302,3 @@\n-        long baseOffset = U.arrayBaseOffset(array.getClass());\n-        int scaleIndex = U.arrayIndexScale(array.getClass());\n+        Asserts.assertTrue(ValueClass.isFlatArray(array));\n+        long baseOffset = U.arrayBaseOffset(array);\n+        int scaleIndex = U.arrayIndexScale(array);\n@@ -357,3 +358,3 @@\n-        long baseOffset = U.arrayBaseOffset(array.getClass());\n-        int scaleIndex = U.arrayIndexScale(array.getClass());\n-        int layoutKind = U.arrayLayout(array.getClass());\n+        long baseOffset = U.arrayBaseOffset(array);\n+        int scaleIndex = U.arrayIndexScale(array);\n+        int layoutKind = U.arrayLayout(array);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.misc.Unsafe;\n+import jdk.internal.value.ValueClass;\n@@ -37,0 +37,1 @@\n+                       \"--add-opens\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n@@ -42,1 +43,0 @@\n-    private static final Unsafe U = Unsafe.getUnsafe();\n@@ -48,2 +48,2 @@\n-        public Class flatArrayClass = Point[].class;\n-        public Class nonFlatArrayClass = String[].class;\n+        public Object[] flatArray = new Point[10];\n+        public Object[] nonFlatArray = new String[10];\n@@ -58,1 +58,1 @@\n-        return U.isFlatArray(Point[].class);\n+        return ValueClass.isFlatArray(new Point[8]);\n@@ -63,1 +63,1 @@\n-        return U.isFlatArray(String[].class);\n+        return ValueClass.isFlatArray(new String[8]);\n@@ -68,1 +68,1 @@\n-        return U.isFlatArray(state.flatArrayClass);\n+        return ValueClass.isFlatArray(state.flatArray);\n@@ -73,1 +73,1 @@\n-        return U.isFlatArray(state.nonFlatArrayClass);\n+        return ValueClass.isFlatArray(state.nonFlatArray);\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/intrinsics\/IsFlatArray.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}