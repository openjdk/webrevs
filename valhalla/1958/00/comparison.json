{"files":[{"patch":"@@ -72,0 +72,10 @@\n+\n+    \/**\n+     * {@return {@code true} if the operands are considered equal by the\n+     * IEEE 754 standard and {@code falue} otherwise}\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+    boolean equalsStd(SFP op1, SFP op2);\n+\n@@ -95,1 +105,1 @@\n-     * {@code Orderable.super.lessThanEqual(op1, op2)}.\n+     * {@code lessThan(op1, op2) || equalsStd(op1, op2)}.\n@@ -102,1 +112,1 @@\n-         return Orderable.super.lessThanEqual(op1, op2);\n+         return lessThan(op1, op2) || equalsStd(op1, op2);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StandardFloatingPoint.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -56,0 +57,1 @@\n+        checkOrderable();\n@@ -167,0 +169,10 @@\n+\n+    private static void checkBoolean(Bfloat16 op1, Bfloat16 op2, boolean result, boolean expected, String operator) {\n+        if (result != expected) {\n+            throwRE(String.format(\"Didn't get expected value for \" +\n+                                  \"%s %s %s %nexpected %b, got %b%n\",\n+                                  op1, operator, op2,\n+                                  expected, result));\n+        }\n+    }\n+\n@@ -198,0 +210,1 @@\n+            Bfloat16 argBf16 = valueOfExact(arg);\n@@ -199,1 +212,2 @@\n-            Bfloat16 result =  Bfloat16.negate(valueOfExact(arg));\n+            Bfloat16 result =  Bfloat16.negate(argBf16);\n+            Bfloat16 resultOp = -argBf16;\n@@ -204,0 +218,4 @@\n+\n+            if (Float.compare(expected, resultOp.floatValue()) != 0) {\n+                checkBfloat16(resultOp, expected, \"negate(\" + arg + \")\");\n+            }\n@@ -327,1 +345,2 @@\n-     * with arguments in proper order.\n+     * with arguments in proper order for both two-argument methods\n+     * and binary operators of the Numerical interface.\n@@ -336,0 +355,1 @@\n+        \/\/ Addition\n@@ -339,0 +359,4 @@\n+        if ((a16 + b16).floatValue() != (a + b)) { \/\/ check + operator\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+\n@@ -342,0 +366,3 @@\n+        if ((b16 + a16).floatValue() != (b + a)) {  \/\/ check + operator\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n@@ -343,0 +370,1 @@\n+        \/\/ Subtraction\n@@ -346,0 +374,4 @@\n+        if ((a16 - b16).floatValue() != (a - b)) { \/\/ check - operator\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+\n@@ -349,0 +381,3 @@\n+        if ((b16 - a16).floatValue() != (b - a)) { \/\/ check - operator\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n@@ -350,0 +385,1 @@\n+        \/\/ Multiplication\n@@ -353,0 +389,4 @@\n+        if ((a16 * b16).floatValue() != (a * b)) { \/\/ check * operator\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+\n@@ -356,0 +396,3 @@\n+        if ((b16 * a16).floatValue() != (b * a)) { \/\/ check * operator\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n@@ -357,0 +400,1 @@\n+        \/\/ Division\n@@ -360,0 +404,4 @@\n+        if ((a16 \/ b16).floatValue() != (a \/ b)) { \/\/ check \/ operator\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+\n@@ -363,0 +411,43 @@\n+        if ((b16 \/ a16).floatValue() != (b \/ a)) { \/\/ check \/ operator\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+\n+        return;\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct the ordered comparison\n+     * operators are behaving as expected.\n+     *\/\n+    private static void checkOrderable() {\n+        float[] testCases = {NaNf,\n+                             -InfinityF,\n+                             -1.0f,\n+                             -0.0f,\n+                             +0.0f,\n+                             1.0f,\n+                             InfinityF};\n+\n+        for (float op1_f : testCases) {\n+            for (float op2_f : testCases) {\n+\n+                Bfloat16 op1_f16 = valueOfExact(op1_f);\n+                Bfloat16 op2_f16 = valueOfExact(op2_f);\n+\n+                checkBoolean(op1_f16,  op2_f16,\n+                             op1_f16 < op2_f16,\n+                             op1_f   < op2_f,  \"<\");\n+\n+                checkBoolean(op1_f16,   op2_f16,\n+                             op1_f16 <= op2_f16,\n+                             op1_f   <= op2_f, \"<=\");\n+\n+                checkBoolean(op1_f16,   op2_f16,\n+                             op1_f16 >  op2_f16,\n+                             op1_f   >  op2_f, \">\");\n+\n+                checkBoolean(op1_f16,   op2_f16,\n+                             op1_f16 >= op2_f16,\n+                             op1_f   >= op2_f, \">=\");\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/BasicBfloat16ArithTests.java","additions":94,"deletions":3,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-public final class Bfloat16\n+public final value class Bfloat16\n@@ -97,0 +97,96 @@\n+    private static StandardFloatingPoint<Bfloat16> SFP = new StandardFloatingPoint<Bfloat16>() {\n+        public Bfloat16 add(Bfloat16 addend, Bfloat16 augend) {\n+            return Bfloat16.add(addend, augend);\n+        }\n+\n+        @Override\n+        public Bfloat16 subtract(Bfloat16 minuend, Bfloat16 subtrahend) {\n+            return Bfloat16.subtract(minuend, subtrahend);\n+        }\n+\n+        public Bfloat16 multiply(Bfloat16 multiplier, Bfloat16 multiplicand) {\n+            return Bfloat16.multiply(multiplier, multiplicand);\n+        }\n+\n+        public Bfloat16 remainder(Bfloat16 dividend, Bfloat16 divisor) {\n+            throw new UnsupportedOperationException(\"tbd\");\n+        }\n+\n+        public Bfloat16 negate(Bfloat16 operand) {\n+            return Bfloat16.negate(operand);\n+        }\n+\n+        public Bfloat16 divide(Bfloat16 dividend, Bfloat16 divisor) {\n+            return Bfloat16.divide(dividend, divisor);\n+        }\n+\n+        @Override\n+        public boolean equalsStd(Bfloat16 op1, Bfloat16 op2) {\n+            return op1.floatValue() == op2.floatValue();\n+        }\n+\n+        @Override\n+        public boolean lessThan(Bfloat16 op1, Bfloat16 op2) {\n+            return op1.floatValue() < op2.floatValue();\n+        }\n+\n+        \/\/ If the following three methods are commented out, the default\n+        \/\/ implementations in StandardFloatingPoint will be used.\n+        \/\/          @Override\n+        \/\/          public boolean lessThanEqual(Bfloat16 op1, Bfloat16 op2) {\n+        \/\/              return op1.floatValue() <= op2.floatValue();\n+        \/\/          }\n+\n+        \/\/          @Override\n+        \/\/          public boolean greaterThan(Bfloat16 op1, Bfloat16 op2) {\n+        \/\/              return op1.floatValue() > op2.floatValue();\n+        \/\/          }\n+\n+        \/\/          @Override\n+        \/\/          public boolean greaterThanEqual(Bfloat16 op1, Bfloat16 op2) {\n+        \/\/              return op1.floatValue() >= op2.floatValue();\n+        \/\/          }\n+\n+        public Bfloat16 min(Bfloat16 op1, Bfloat16 op2) {\n+            return Bfloat16.min(op1, op2);\n+        }\n+\n+        public Bfloat16 max(Bfloat16 op1, Bfloat16 op2) {\n+            return Bfloat16.min(op1, op2);\n+        }\n+\n+        public Bfloat16 sqrt(Bfloat16 radicand) {\n+            return Bfloat16.sqrt(radicand);\n+        }\n+\n+        public Bfloat16 fma(Bfloat16 a, Bfloat16 b, Bfloat16 c) {\n+            return Bfloat16.fma(a, b, c);\n+        }\n+\n+        public boolean isNaN(Bfloat16 operand) {\n+            return Bfloat16.isNaN(operand);\n+        }\n+\n+        public boolean isInfinite(Bfloat16 operand) {\n+            return Bfloat16.isInfinite(operand);\n+        }\n+\n+        public Bfloat16 ulp(Bfloat16 operand) {\n+            return Bfloat16.ulp(operand);\n+        }\n+\n+        public String toHexString(Bfloat16 operand) {\n+            return Bfloat16.toHexString(operand);\n+        }\n+    };\n+\n+    \/**\n+     * Witness for the {@code Numerical} interface.\n+     *\/\n+    public __witness Numerical<Bfloat16> NUM = SFP;\n+\n+    \/**\n+     * Witness for the {@code Orderable} interface.\n+     *\/\n+    public __witness Orderable<Bfloat16> ORD = SFP;\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Bfloat16.java","additions":97,"deletions":1,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Binary16Conversion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Bfloat16\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}