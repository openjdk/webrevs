{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/layoutKind.hpp\"\n@@ -131,10 +133,1 @@\n-  if (oop->is_refArray()) {\n-    return oop->klass()->is_inline_klass();\n-  }\n-  if (oop->is_flatArray()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(oop->klass());\n-    if (fak->element_klass()->is_naturally_atomic() || LayoutKindHelper::is_atomic_flat(fak->layout_kind())) {\n-      return true;\n-    }\n-  }\n-  return false;\n+  return !oop->is_flatArray() || FlatArrayKlass::cast(oop->klass())->layout_kind() != LayoutKind::NON_ATOMIC_FLAT;\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -124,1 +125,3 @@\n-  GUARDED_VM_ENTRY(return is_loaded() && get_Klass()->is_null_free_array_klass();)\n+  ArrayKlass::ArrayProperties props = properties();\n+  assert(props != ArrayKlass::INVALID, \"meaningless\");\n+  return ArrayKlass::is_null_restricted(props);\n@@ -127,5 +130,4 @@\n-bool ciArrayKlass::is_elem_atomic() {\n-  ciKlass* elem = element_klass();\n-  GUARDED_VM_ENTRY(return elem != nullptr && elem->is_inlinetype() &&\n-                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::INVALID) == 0 &&\n-                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::NON_ATOMIC) == 0;)\n+bool ciArrayKlass::is_elem_atomic() const {\n+  ArrayKlass::ArrayProperties props = properties();\n+  assert(props != ArrayKlass::INVALID, \"meaningless\");\n+  return !ArrayKlass::is_non_atomic(props);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  bool is_refined() const { return !is_type_array_klass() && properties() != ArrayKlass::INVALID; }\n+\n@@ -68,1 +70,1 @@\n-  bool is_elem_atomic();\n+  bool is_elem_atomic() const;\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,18 +194,1 @@\n-  if (!is_loaded()) {\n-    return nullptr;\n-  }\n-  ciType* base = base_element_type();\n-  if (base->is_instance_klass()) {\n-    ciInstanceKlass* ik = base->as_instance_klass();\n-    \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-    \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n-    if (ik->is_inlinetype() && !is_elem_null_free()) {\n-      return nullptr;\n-    }\n-    if (ik->exact_klass() != nullptr) {\n-      return this;\n-    }\n-  } else if (base->is_primitive_type()) {\n-    return this;\n-  }\n-  return nullptr;\n+  return (is_loaded() && is_refined()) ? this : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -140,0 +141,1 @@\n+    assert(!element_klass->is_refined_objArray_klass(), \"no such mechanism yet\");\n@@ -212,0 +214,3 @@\n+  assert(ArrayKlass::is_null_restricted(props) || !ArrayKlass::is_non_atomic(props), \"only null-restricted array can be non-atomic\");\n+  assert(!ArrayKlass::is_non_atomic(props) || (element_klass()->is_inline_klass() && InlineKlass::cast(element_klass())->has_non_atomic_layout()),\n+         \"cannot create non-atomic species\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1391,13 +1391,0 @@\n-  if (ta && ta->is_stable()) {\n-    \/\/ Erase stability property for alias analysis.\n-    tj = ta = ta->cast_to_stable(false);\n-  }\n-  if (ta && ta->is_not_flat()) {\n-    \/\/ Erase not flat property for alias analysis.\n-    tj = ta = ta->cast_to_not_flat(false);\n-  }\n-  if (ta && ta->is_not_null_free()) {\n-    \/\/ Erase not null free property for alias analysis.\n-    tj = ta = ta->cast_to_not_null_free(false);\n-  }\n-\n@@ -1414,55 +1401,23 @@\n-    \/\/ For arrays indexed by constant indices, we flatten the alias\n-    \/\/ space to include all of the array body.  Only the header, klass\n-    \/\/ and array length can be accessed un-aliased.\n-    \/\/ For flat inline type array, each field has its own slice so\n-    \/\/ we must include the field offset.\n-    if( offset != Type::OffsetBot ) {\n-      if( ta->const_oop() ) { \/\/ MethodData* or Method*\n-        offset = Type::OffsetBot;   \/\/ Flatten constant access into array body\n-        tj = ta = ta->\n-                remove_speculative()->\n-                cast_to_ptr_type(ptr)->\n-                cast_to_exactness(false)->\n-                with_offset(offset);\n-      } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {\n-        \/\/ range is OK as-is.\n-        tj = ta = TypeAryPtr::RANGE;\n-      } else if( offset == oopDesc::klass_offset_in_bytes() ) {\n-        tj = TypeInstPtr::KLASS; \/\/ all klass loads look alike\n-        ta = TypeAryPtr::RANGE; \/\/ generic ignored junk\n-        ptr = TypePtr::BotPTR;\n-      } else if( offset == oopDesc::mark_offset_in_bytes() ) {\n-        tj = TypeInstPtr::MARK;\n-        ta = TypeAryPtr::RANGE; \/\/ generic ignored junk\n-        ptr = TypePtr::BotPTR;\n-      } else {                  \/\/ Random constant offset into array body\n-        offset = Type::OffsetBot;   \/\/ Flatten constant access into array body\n-        tj = ta = ta->\n-                remove_speculative()->\n-                cast_to_ptr_type(ptr)->\n-                cast_to_exactness(false)->\n-                with_offset(offset);\n-      }\n-    }\n-    \/\/ Arrays of fixed size alias with arrays of unknown size.\n-    if (ta->size() != TypeInt::POS) {\n-      const TypeAry *tary = TypeAry::make(ta->elem(), TypeInt::POS);\n-      tj = ta = ta->\n-              remove_speculative()->\n-              cast_to_ptr_type(ptr)->\n-              with_ary(tary)->\n-              cast_to_exactness(false);\n-    }\n-    \/\/ Arrays of known objects become arrays of unknown objects.\n-    if (ta->elem()->isa_narrowoop() && ta->elem() != TypeNarrowOop::BOTTOM) {\n-      const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta->size());\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    if (ta->elem()->isa_oopptr() && ta->elem() != TypeInstPtr::BOTTOM) {\n-      const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size());\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    \/\/ Initially all flattened array accesses share a single slice\n-    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flat_accesses_share_alias) {\n-      const TypeAry* tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size(), \/* stable= *\/ false, \/* flat= *\/ true);\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n+    \/\/ Common slices\n+    if (offset == arrayOopDesc::length_offset_in_bytes()) {\n+      return TypeAryPtr::RANGE;\n+    } else if (offset == oopDesc::klass_offset_in_bytes()) {\n+      return TypeInstPtr::KLASS;\n+    } else if (offset == oopDesc::mark_offset_in_bytes()) {\n+      return TypeInstPtr::MARK;\n+    }\n+\n+    \/\/ Remove size and stability\n+    const TypeAry* normalized_ary = TypeAry::make(ta->elem(), TypeInt::POS, false, ta->is_flat(), ta->is_not_flat(), ta->is_not_null_free(), ta->is_atomic());\n+    \/\/ Remove ptr, const_oop, and offset\n+    if (ta->elem() == Type::BOTTOM) {\n+      \/\/ Bottom array (meet of int[] and byte[] for example), accesses to it will be done with\n+      \/\/ Unsafe. This should alias with all arrays. For now just leave it as it is (this is\n+      \/\/ incorrect!).\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, nullptr, false, Type::Offset::bottom);\n+    } else if (ta->elem()->make_oopptr() != nullptr) {\n+      \/\/ Object arrays, keep field_offset\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, nullptr, ta->klass_is_exact(), Type::Offset::bottom, Type::Offset(ta->field_offset()));\n+    } else {\n+      \/\/ Primitive arrays\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, ta->exact_klass(), true, Type::Offset::bottom);\n@@ -1470,0 +1425,1 @@\n+\n@@ -1473,13 +1429,17 @@\n-      const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta->size());\n-      ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    \/\/ During the 2nd round of IterGVN, NotNull castings are removed.\n-    \/\/ Make sure the Bottom and NotNull variants alias the same.\n-    \/\/ Also, make sure exact and non-exact variants alias the same.\n-    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != nullptr) {\n-      tj = ta = ta->\n-              remove_speculative()->\n-              cast_to_ptr_type(TypePtr::BotPTR)->\n-              cast_to_exactness(false)->\n-              with_offset(offset);\n+      tj = ta = TypeAryPtr::BYTES;\n+    }\n+\n+    \/\/ All arrays of references share the same slice\n+    if (!ta->is_flat() && ta->elem()->make_oopptr() != nullptr) {\n+      const TypeAry* tary = TypeAry::make(TypeInstPtr::BOTTOM, TypeInt::POS, false, false, true, true, true);\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, tary, nullptr, false, Type::Offset::bottom);\n+    }\n+\n+    if (ta->is_flat()) {\n+      if (_flat_accesses_share_alias) {\n+        \/\/ Initially all flattened array accesses share a single slice\n+        tj = ta = TypeAryPtr::INLINES;\n+      } else {\n+        \/\/ Flat accesses are always exact\n+        tj = ta = ta->cast_to_exactness(true);\n+      }\n@@ -2035,0 +1995,2 @@\n+    \/\/ keep the graph canonical\n+    igvn.optimize();\n@@ -2132,0 +2094,1 @@\n+  DEBUG_ONLY(igvn.verify_empty_worklist(nullptr));\n@@ -2217,0 +2180,5 @@\n+      if (current->outcnt() == 0) {\n+        \/\/ This node is killed by a previous iteration\n+        continue;\n+      }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":49,"deletions":81,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1879,3 +1879,12 @@\n-Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* vk, bool is_null_free, bool is_not_null_free, bool is_atomic) {\n-  assert(vk->maybe_flat_in_array(), \"element of type %s cannot be flat in array\", vk->name()->as_utf8());\n-  if (!vk->has_nullable_atomic_layout()) {\n+Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* elem_vk) {\n+  assert(elem_vk->maybe_flat_in_array(), \"no flat array for %s\", elem_vk->name()->as_utf8());\n+  if (!elem_vk->has_atomic_layout() && !elem_vk->has_nullable_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, false);\n+  } else if (!elem_vk->has_nullable_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, true);\n+  } else if (!elem_vk->has_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, false, true);\n+  }\n+\n+  bool is_null_free = false;\n+  if (!elem_vk->has_nullable_atomic_layout()) {\n@@ -1885,8 +1894,0 @@\n-  if (!vk->has_atomic_layout() && !vk->has_non_atomic_layout()) {\n-    \/\/ Element does not have a null-free flat layout, cannot be null-free\n-    is_not_null_free = true;\n-  }\n-  if (is_null_free) {\n-    \/\/ TODO 8350865 Impossible type\n-    is_not_null_free = false;\n-  }\n@@ -1894,4 +1895,9 @@\n-  bool is_exact = is_null_free || is_not_null_free;\n-  ciArrayKlass* array_klass = ciArrayKlass::make(vk, is_null_free, is_atomic, true);\n-  assert(array_klass->is_elem_null_free() == is_null_free, \"inconsistency\");\n-  assert(array_klass->is_elem_atomic() == is_atomic, \"inconsistency\");\n+  ciArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, false);\n+  const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+  arytype = arytype->cast_to_flat(true)->cast_to_null_free(is_null_free);\n+  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+}\n+\n+Node* GraphKit::cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic) {\n+  assert(is_null_free || is_atomic, \"nullable arrays must be atomic\");\n+  ciArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, true, is_null_free, is_atomic);\n@@ -1899,2 +1905,2 @@\n-  arytype = arytype->cast_to_exactness(is_exact);\n-  arytype = arytype->cast_to_not_null_free(is_not_null_free);\n+  assert(arytype->klass_is_exact(), \"inconsistency\");\n+  assert(arytype->is_flat(), \"inconsistency\");\n@@ -1902,1 +1908,1 @@\n-  assert(arytype->is_not_null_free() == is_not_null_free, \"inconsistency\");\n+  assert(arytype->is_not_null_free() == !is_null_free, \"inconsistency\");\n@@ -4682,1 +4688,1 @@\n-                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true),\n+                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true, true),\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -663,1 +663,2 @@\n-  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_not_null_free, bool is_atomic);\n+  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk);\n+  Node* cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -579,1 +579,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -593,1 +593,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n@@ -1084,1 +1084,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -1106,1 +1106,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -1120,1 +1120,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -2892,1 +2893,1 @@\n-        Node* new_base = cast_to_flat_array(base, value_klass, is_null_free, !is_null_free, is_atomic);\n+        Node* new_base = cast_to_flat_array_exact(base, value_klass, is_null_free, is_atomic);\n@@ -4277,1 +4278,1 @@\n-  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -4881,0 +4882,3 @@\n+        if (!t->as_inline_klass()->has_non_atomic_layout()) {\n+          atomic = true;\n+        }\n@@ -4892,1 +4896,1 @@\n-          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces, true);\n+          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -5167,1 +5171,2 @@\n-      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));\n+      bool not_flat = !UseArrayFlattening;\n+      const Type* akls = TypeAryKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), Type::trust_interfaces, not_flat, false, false, false, not_flat, true);\n@@ -6804,1 +6809,9 @@\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(refined_dest_klass)->is_klassptr();\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->isa_klassptr();\n+    if (dest_klass_t == nullptr) {\n+      \/\/ refined_dest_klass may not be an array, which leads to dest_klass being top. This means we\n+      \/\/ are in a dead path.\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_make_not_entrant);\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"opto\/callnode.hpp\"\n@@ -1239,0 +1241,1 @@\n+\/\/ This method may find an unencoded node instead of the corresponding encoded one.\n@@ -1355,3 +1358,25 @@\n-        \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n-        \/\/ Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n-        return init_value;\n+        const TypeAryPtr* ld_adr_type = phase->type(ld_adr)->isa_aryptr();\n+        if (ld_adr_type == nullptr) {\n+          return nullptr;\n+        }\n+\n+        \/\/ We know that this is not a flat array, the load should return the whole oop\n+        if (ld_adr_type->is_not_flat()) {\n+          return init_value;\n+        }\n+\n+        \/\/ If this is a flat array, try to see through init_value\n+        if (init_value->is_EncodeP()) {\n+          init_value = init_value->in(1);\n+        }\n+        if (!init_value->is_InlineType() || ld_adr_type->field_offset() == Type::Offset::bottom) {\n+          return nullptr;\n+        }\n+\n+        ciInlineKlass* vk = phase->type(init_value)->inline_klass();\n+        int field_offset_in_payload = ld_adr_type->field_offset().get();\n+        if (field_offset_in_payload == vk->null_marker_offset_in_payload()) {\n+          return init_value->as_InlineType()->get_null_marker();\n+        } else {\n+          return init_value->as_InlineType()->field_value_by_offset(field_offset_in_payload + vk->payload_offset(), true);\n+        }\n@@ -1442,0 +1467,4 @@\n+\n+    if (phase->type(value)->isa_ptr() && phase->type(this)->isa_narrowoop()) {\n+      return this;\n+    }\n@@ -2174,2 +2203,6 @@\n-    assert(value->bottom_type()->higher_equal(_type), \"sanity\");\n-    return value->bottom_type();\n+    if (phase->type(value)->isa_ptr() && _type->isa_narrowoop()) {\n+      return phase->type(value)->make_narrowoop();\n+    } else {\n+      assert(value->bottom_type()->higher_equal(_type), \"sanity\");\n+      return phase->type(value);\n+    }\n@@ -2592,0 +2625,7 @@\n+  \/\/ Can see the corresponding value, may need to add an EncodeP\n+  value = can_see_stored_value(in(Memory), phase);\n+  if (value != nullptr && phase->type(value)->isa_ptr() && type()->isa_narrowoop()) {\n+    return new EncodePNode(value, type());\n+  }\n+\n+  \/\/ Identity call will handle the case where EncodeP is unnecessary\n@@ -2671,3 +2711,1 @@\n-    const TypeAryKlassPtr* res = tary->as_klass_type(true)->is_aryklassptr();\n-    \/\/ The klass of an array object must be a refined array klass\n-    return res->cast_to_refined_array_klass_ptr();\n+    return tary->as_klass_type(true)->is_aryklassptr();\n@@ -2696,1 +2734,1 @@\n-      return tkls->is_aryklassptr()->cast_to_refined_array_klass_ptr(false);\n+      return tkls->is_aryklassptr()->with_offset(0)->cast_to_non_refined();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-  Node* check_interpreter_type(Node* l, const Type* type, SafePointNode* &bad_type_exit, bool is_larval);\n+  Node* check_interpreter_type(Node* l, const Type* type, const TypeKlassPtr* klass_type, SafePointNode* &bad_type_exit, bool is_larval);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-Node* Parse::check_interpreter_type(Node* l, const Type* type,\n+Node* Parse::check_interpreter_type(Node* l, const Type* type, const TypeKlassPtr* klass_type,\n@@ -187,1 +187,1 @@\n-    l = gen_checkcast(l, makecon(tp->as_klass_type()->cast_to_exactness(true)), &bad_type_ctrl, false, is_early_larval);\n+    l = gen_checkcast(l, makecon(klass_type), &bad_type_ctrl, false, is_early_larval);\n@@ -378,0 +378,5 @@\n+    const TypeKlassPtr* klass_type = nullptr;\n+    if (type->isa_oopptr()) {\n+      klass_type = TypeKlassPtr::make(osr_block->flow()->local_type_at(index)->unwrap()->as_klass(), Type::ignore_interfaces);\n+      klass_type = klass_type->try_improve();\n+    }\n@@ -379,1 +384,1 @@\n-    set_local(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n+    set_local(index, check_interpreter_type(l, type, klass_type, bad_type_exit, is_early_larval));\n@@ -386,1 +391,6 @@\n-    const Type *type = osr_block->stack_type_at(index);\n+    const Type* type = osr_block->stack_type_at(index);\n+    const TypeKlassPtr* klass_type = nullptr;\n+    if (type->isa_oopptr()) {\n+      klass_type = TypeKlassPtr::make(osr_block->flow()->stack_type_at(index)->unwrap()->as_klass(), Type::ignore_interfaces);\n+      klass_type = klass_type->try_improve();\n+    }\n@@ -388,1 +398,1 @@\n-    set_stack(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n+    set_stack(index, check_interpreter_type(l, type, klass_type, bad_type_exit, is_early_larval));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-          Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+          Node* flat_array = cast_to_flat_array(array, vk);\n@@ -270,1 +270,1 @@\n-            Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+            Node* flat_array = cast_to_flat_array(array, vk);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -1195,1 +1196,1 @@\n-  if (mirror_klass->is_array_klass()) {\n+  if (mirror_klass->is_array_klass() && !mirror_klass->is_type_array_klass()) {\n@@ -1198,1 +1199,2 @@\n-      return phase->makecon(TypeAryKlassPtr::make(mirror_klass, Type::trust_interfaces, true));\n+      ciArrayKlass* refined_mirror_klass = ciObjArrayKlass::make(mirror_klass->as_array_klass()->element_klass(), true);\n+      return phase->makecon(TypeAryKlassPtr::make(refined_mirror_klass, Type::trust_interfaces));\n@@ -1327,2 +1329,1 @@\n-    if (!superklass->as_array_klass()->is_elem_null_free() &&\n-         superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    if (superklass->as_array_klass()->element_klass()->is_inlinetype() && !superklass->as_array_klass()->is_refined()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -656,2 +658,2 @@\n-  TypeAryPtr::BOTTOM = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM, TypeInt::POS), nullptr, false, Offset::bottom);\n-  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), nullptr \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n+  TypeAryPtr::BOTTOM = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM, TypeInt::POS, false, false, false, false, false), nullptr, false, Offset::bottom);\n+  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS, false, false, false, false, false), nullptr \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n@@ -659,1 +661,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS, false, false, false, false, false), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -669,1 +671,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, false, false, false, false, false), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -671,8 +673,8 @@\n-  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);\n-  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);\n-  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);\n-  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);\n-  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);\n-  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);\n-  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);\n-  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true), nullptr, false, Offset::bottom);\n+  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);\n+  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);\n+  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);\n+  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);\n+  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);\n+  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);\n+  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);\n+  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, false, false, false), nullptr, false, Offset::bottom);\n@@ -3840,0 +3842,1 @@\n+    bool xk = klass->is_loaded() && klass->as_obj_array_klass()->is_refined();\n@@ -3841,1 +3844,1 @@\n-    const bool is_null_free = klass->as_array_klass()->is_elem_null_free();\n+    const bool is_null_free = xk && klass->as_array_klass()->is_elem_null_free();\n@@ -3851,5 +3854,3 @@\n-    bool not_null_free = not_inline;\n-    bool not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n-    bool atomic = klass->as_array_klass()->is_elem_atomic();\n-    \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n-    bool xk = etype->klass_is_exact() && !etype->is_inlinetypeptr();\n+    bool not_null_free = xk ? !is_null_free : not_inline;\n+    bool not_flat = xk || !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n+    bool atomic = not_flat;\n@@ -3866,1 +3867,1 @@\n-                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -3878,3 +3879,2 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ false, atomic);\n-    const bool exact = is_null_free; \/\/ Only exact if null-free because \"null-free [LMyValue <: null-able [LMyValue\".\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, exact, Offset(0));\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, atomic);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));\n@@ -3926,1 +3926,1 @@\n-                                        \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -5070,0 +5070,13 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_flat(bool flat) const {\n+  if (flat == is_flat()) {\n+    return this;\n+  }\n+  assert(!flat || !is_not_flat(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), flat, is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -5086,0 +5099,21 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_null_free(bool null_free) const {\n+  if (null_free == is_null_free()) {\n+    return this;\n+  }\n+  assert(!null_free || !is_not_null_free(), \"inconsistency\");\n+  const Type* elem = this->elem();\n+  const Type* new_elem = elem->make_ptr();\n+  if (null_free) {\n+    new_elem = new_elem->join_speculative(TypePtr::NOTNULL);\n+  } else {\n+    new_elem = new_elem->meet_speculative(TypePtr::NULL_PTR);\n+  }\n+  new_elem = elem->isa_narrowoop() ? new_elem->make_narrowoop() : new_elem;\n+  const TypeAry* new_ary = TypeAry::make(new_elem, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -6070,0 +6104,1 @@\n+  bool is_refined = false;\n@@ -6071,0 +6106,1 @@\n+    is_refined = true;\n@@ -6072,7 +6108,11 @@\n-    if (elem->is_klassptr()->klass_is_exact() &&\n-        \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-        \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n-        \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n-        \/\/ If so, we should add '|| is_not_null_free()'\n-        (is_null_free() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n-      xk = true;\n+    if (elem->isa_aryklassptr()) {\n+      const TypeAryKlassPtr* elem_klass = elem->is_aryklassptr();\n+      if (elem_klass->is_refined_type()) {\n+        elem = elem_klass->cast_to_non_refined();\n+      }\n+    } else {\n+      const TypeInstKlassPtr* elem_klass = elem->is_instklassptr();\n+      if (try_for_exact && !xk && elem_klass->klass_is_exact() &&\n+          !elem_klass->exact_klass()->as_instance_klass()->can_be_inline_klass()) {\n+        xk = true;\n+      }\n@@ -6081,1 +6121,1 @@\n-  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_flat() || is_null_free());\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_refined);\n@@ -6091,8 +6131,0 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling) {\n-  if (klass->is_instance_klass()) {\n-    const TypeInterfaces* interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n-  }\n-  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n-}\n-\n@@ -6566,1 +6598,0 @@\n-  const TypeInterfaces* interfaces = _interfaces;\n@@ -6569,3 +6600,1 @@\n-    bool klass_is_exact = ik->is_final();\n-    if (!klass_is_exact &&\n-        deps != nullptr) {\n+    if (deps != nullptr) {\n@@ -6574,1 +6603,3 @@\n-        if (_interfaces->eq(sub)) {\n+        bool improve_to_exact = sub->is_final() && _ptr == NotNull;\n+        const TypeInstKlassPtr* improved = TypeInstKlassPtr::make(improve_to_exact ? Constant : _ptr, sub, _offset);\n+        if (improved->_interfaces->contains(_interfaces)) {\n@@ -6576,3 +6607,1 @@\n-          k = ik = sub;\n-          klass_is_exact = sub->is_final();\n-          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+          return improved;\n@@ -6607,0 +6636,1 @@\n+  const Type* etype;\n@@ -6610,2 +6640,2 @@\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+    etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    k = nullptr;\n@@ -6614,2 +6644,1 @@\n-    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic);\n+    etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n@@ -6618,2 +6647,2 @@\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+    etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    k = nullptr;\n@@ -6622,1 +6651,0 @@\n-    return nullptr;\n@@ -6624,6 +6652,0 @@\n-}\n-\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type) {\n-  bool flat = k->is_flat_array_klass();\n-  bool null_free = k->as_array_klass()->is_elem_null_free();\n-  bool atomic = k->as_array_klass()->is_elem_atomic();\n@@ -6631,6 +6653,2 @@\n-  bool not_inline = k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false);\n-  bool not_null_free = (ptr == Constant) ? !null_free : not_inline;\n-  bool not_flat = (ptr == Constant) ? !flat : (!UseArrayFlattening || not_inline ||\n-                   (k->as_array_klass()->element_klass() != nullptr &&\n-                    k->as_array_klass()->element_klass()->is_inlinetype() &&\n-                   !k->as_array_klass()->element_klass()->maybe_flat_in_array()));\n+  return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+}\n@@ -6638,1 +6656,9 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  ciArrayKlass* k = klass->as_array_klass();\n+  if (k->is_refined()) {\n+    return TypeAryKlassPtr::make(Constant, k, Offset(0), interface_handling, !k->is_flat_array_klass(), !k->is_elem_null_free(),\n+                                 k->is_flat_array_klass(), k->is_elem_null_free(), k->is_elem_atomic(), true);\n+  } else {\n+    \/\/ Use the default combination to canonicalize all non-refined klass pointers\n+    return TypeAryKlassPtr::make(Constant, k, Offset(0), interface_handling, true, true, false, false, true, false);\n+  }\n@@ -6641,2 +6667,8 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type) {\n-  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling, refined_type);\n+const TypeAryKlassPtr* TypeAryKlassPtr::cast_to_non_refined() const {\n+  assert(is_refined_type(), \"must be a refined type\");\n+  PTR ptr = _ptr;\n+  \/\/ There can be multiple refined array types corresponding to a single unrefined type\n+  if (ptr == NotNull && elem()->is_klassptr()->klass_is_exact()) {\n+    ptr = Constant;\n+  }\n+  return make(ptr, elem(), nullptr, _offset, true, true, false, false, true, false);\n@@ -6650,3 +6682,5 @@\n-  ciKlass* eklass = elem()->is_klassptr()->exact_klass_helper();\n-  if (elem()->isa_aryklassptr()) {\n-    eklass = exact_klass()->as_obj_array_klass()->element_klass();\n+  ciArrayKlass* k = exact_klass()->as_array_klass();\n+  if (refined) {\n+    k = ciObjArrayKlass::make(k->element_klass(), true);\n+  } else {\n+    k = ciObjArrayKlass::make(k->element_klass(), false);\n@@ -6654,2 +6688,1 @@\n-  ciKlass* array_klass = ciArrayKlass::make(eklass, eklass->is_inlinetype() ? is_null_free() : false, eklass->is_inlinetype() ? is_atomic() : true, refined);\n-  return make(_ptr, array_klass, Offset(0), trust_interfaces, refined);\n+  return make(k, trust_interfaces);\n@@ -6744,2 +6777,10 @@\n-    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), is_flat() || is_null_free());\n-    return k;\n+    if (k->is_array_klass() && k->as_array_klass()->is_refined()) {\n+      \/\/ We have no mechanism to create an array of refined arrays\n+      k = ciObjArrayKlass::make(k->as_array_klass()->element_klass(), false);\n+    }\n+    if (klass_is_exact()) {\n+      return ciObjArrayKlass::make(k, true, is_null_free(), is_atomic());\n+    } else {\n+      \/\/ We may reach here if called recursively, must be an unrefined type then\n+      return ciObjArrayKlass::make(k, false);\n+    }\n@@ -6779,9 +6820,2 @@\n-  if (_elem == Type::BOTTOM) return false;\n-  if (_elem == Type::TOP   ) return false;\n-  const TypeKlassPtr*  tk = _elem->isa_klassptr();\n-  if (!tk)             return true;   \/\/ a primitive type, like int\n-  \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-  \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n-  \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n-  \/\/ If so, we should add '&& !is_not_null_free()'\n-  if (tk->isa_instklassptr() && tk->klass()->is_inlinetype() && !is_null_free()) {\n+  assert(klass_is_exact(), \"precondition\");\n+  if (_elem == Type::BOTTOM || _elem == Type::TOP) {\n@@ -6790,2 +6824,5 @@\n-  return tk->must_be_exact();\n-}\n+  const TypeKlassPtr* elem = _elem->isa_klassptr();\n+  if (elem == nullptr) {\n+    \/\/ primitive arrays\n+    return true;\n+  }\n@@ -6793,0 +6830,3 @@\n+  \/\/ refined types are final\n+  return _refined_type;\n+}\n@@ -6796,1 +6836,0 @@\n-  if (must_be_exact() && !klass_is_exact) return this;  \/\/ cannot clear xk\n@@ -6800,1 +6839,3 @@\n-  ciKlass* k = _klass;\n+  if (!klass_is_exact && must_be_exact()) {\n+    return this;\n+  }\n@@ -6805,17 +6846,14 @@\n-  bool not_flat = is_not_flat();\n-  bool not_null_free = is_not_null_free();\n-  if (_elem->isa_klassptr()) {\n-    if (klass_is_exact || _elem->isa_aryklassptr()) {\n-      assert((!is_null_free() && !is_flat()) ||\n-             _elem->is_klassptr()->klass()->is_abstract() || _elem->is_klassptr()->klass()->is_java_lang_Object(),\n-             \"null-free (or flat) concrete inline type arrays should always be exact\");\n-      \/\/ An array can't be null-free (or flat) if the klass is exact\n-      not_null_free = true;\n-      not_flat = true;\n-    } else {\n-      \/\/ Klass is not exact (anymore), re-compute null-free\/flat properties\n-      const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_unique(_elem->is_instklassptr()->instance_klass());\n-      bool not_inline = !exact_etype->can_be_inline_type();\n-      not_null_free = not_inline;\n-      not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n-    }\n+\n+  if (klass_is_exact) {\n+    \/\/ cast_to_exactness(true) really means get the LCA of all values represented by this\n+    \/\/ TypeAryKlassPtr. As a result, it must be an unrefined klass pointer.\n+    return make(Constant, elem, nullptr, _offset, true, true, false, false, true, false);\n+  } else {\n+    \/\/ cast_to_exactness(false) means get the TypeAryKlassPtr representing all values that subtype\n+    \/\/ this value\n+    bool not_inline = !_elem->isa_instklassptr() || !_elem->is_instklassptr()->instance_klass()->can_be_inline_klass();\n+    bool not_flat = !UseArrayFlattening || not_inline ||\n+                    (_elem->isa_instklassptr() && _elem->is_instklassptr()->instance_klass()->is_inlinetype() && !_elem->is_instklassptr()->instance_klass()->maybe_flat_in_array());\n+    bool not_null_free = not_inline;\n+    bool atomic = not_flat;\n+    return make(NotNull, elem, nullptr, _offset, not_flat, not_null_free, false, false, atomic, false);\n@@ -6823,1 +6861,0 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free, _atomic, _refined_type);\n@@ -7154,1 +7191,2 @@\n-    k = ciArrayKlass::make(k, k->is_inlinetype() ? is_null_free() : false, k->is_inlinetype() ? is_atomic() : true, _refined_type);\n+    assert(!k->is_array_klass() || !k->as_array_klass()->is_refined(), \"no mechanism to create an array of refined arrays %s\", k->name()->as_utf8());\n+    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), _refined_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":146,"deletions":108,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -1034,2 +1034,2 @@\n-  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,\n-                             bool flat = false, bool not_flat = false, bool not_null_free = false, bool atomic = false);\n+  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable,\n+                             bool flat, bool not_flat, bool not_null_free, bool atomic);\n@@ -1776,0 +1776,1 @@\n+  const TypeAryPtr* cast_to_flat(bool flat) const;\n@@ -1777,0 +1778,1 @@\n+  const TypeAryPtr* cast_to_null_free(bool null_free) const;\n@@ -1913,1 +1915,0 @@\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -2106,1 +2107,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type);\n@@ -2114,3 +2115,2 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type = false);\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -2118,0 +2118,1 @@\n+  const TypeAryKlassPtr* cast_to_non_refined() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -487,1 +488,6 @@\n-  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NON_ATOMIC | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  ArrayKlass::ArrayProperties props;\n+  if (vk->has_non_atomic_layout()) {\n+    props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NON_ATOMIC | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  } else {\n+    props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -414,1 +414,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -428,1 +427,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -431,1 +430,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -441,1 +439,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -444,1 +442,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -456,1 +453,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -459,1 +456,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-        counts = {SCOPE_OBJECT, \">= 1\", LOAD_OF_ANY_KLASS, \"<= 12\"}) \/\/ TODO 8227588 (loads should be removed)\n+        counts = {SCOPE_OBJECT, \">= 1\"}) \/\/ LOAD_OF_ANY_KLASS, \"<= 12\"}) \/\/ TODO 8372332, 8227588 (loads should be removed)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}