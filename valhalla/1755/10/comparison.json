{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/layoutKind.hpp\"\n@@ -131,10 +133,1 @@\n-  if (oop->is_refArray()) {\n-    return oop->klass()->is_inline_klass();\n-  }\n-  if (oop->is_flatArray()) {\n-    FlatArrayKlass* fak = FlatArrayKlass::cast(oop->klass());\n-    if (fak->element_klass()->is_naturally_atomic() || LayoutKindHelper::is_atomic_flat(fak->layout_kind())) {\n-      return true;\n-    }\n-  }\n-  return false;\n+  return !oop->is_flatArray() || LayoutKindHelper::is_atomic_flat(FlatArrayKlass::cast(oop->klass())->layout_kind());\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -124,1 +125,3 @@\n-  GUARDED_VM_ENTRY(return is_loaded() && get_Klass()->is_null_free_array_klass();)\n+  ArrayKlass::ArrayProperties props = properties();\n+  assert(props != ArrayKlass::INVALID, \"meaningless\");\n+  return ArrayKlass::is_null_restricted(props);\n@@ -127,5 +130,4 @@\n-bool ciArrayKlass::is_elem_atomic() {\n-  ciKlass* elem = element_klass();\n-  GUARDED_VM_ENTRY(return elem != nullptr && elem->is_inlinetype() &&\n-                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::INVALID) == 0 &&\n-                          (ArrayKlass::cast(get_Klass())->properties() & ArrayKlass::ArrayProperties::NON_ATOMIC) == 0;)\n+bool ciArrayKlass::is_elem_atomic() const {\n+  ArrayKlass::ArrayProperties props = properties();\n+  assert(props != ArrayKlass::INVALID, \"meaningless\");\n+  return !ArrayKlass::is_non_atomic(props);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  bool is_refined() const { return !is_type_array_klass() && properties() != ArrayKlass::INVALID; }\n+\n@@ -68,1 +70,1 @@\n-  bool is_elem_atomic();\n+  bool is_elem_atomic() const;\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,18 +194,1 @@\n-  if (!is_loaded()) {\n-    return nullptr;\n-  }\n-  ciType* base = base_element_type();\n-  if (base->is_instance_klass()) {\n-    ciInstanceKlass* ik = base->as_instance_klass();\n-    \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-    \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n-    if (ik->is_inlinetype() && !is_elem_null_free()) {\n-      return nullptr;\n-    }\n-    if (ik->exact_klass() != nullptr) {\n-      return this;\n-    }\n-  } else if (base->is_primitive_type()) {\n-    return this;\n-  }\n-  return nullptr;\n+  return (is_loaded() && is_refined()) ? this : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -173,5 +173,15 @@\n-  public:\n-   Klass::KlassKind _kind;\n-   ArrayKlass::ArrayProperties _properties;\n-   LayoutKind _layout_kind;\n-   ArrayDescription(Klass::KlassKind k, ArrayKlass::ArrayProperties p, LayoutKind lk) { _kind = k; _properties = p; _layout_kind = lk; }\n+public:\n+  Klass::KlassKind _kind;\n+  ArrayKlass::ArrayProperties _properties;\n+  LayoutKind _layout_kind;\n+  ArrayDescription(Klass::KlassKind k, ArrayKlass::ArrayProperties p, LayoutKind lk) {\n+    _kind = k;\n+    _layout_kind = lk;\n+\n+    if (lk == LayoutKind::REFERENCE || LayoutKindHelper::is_atomic_flat(lk)) {\n+      p = (ArrayKlass::ArrayProperties) (p &~ ArrayKlass::NON_ATOMIC);\n+    } else {\n+      p = (ArrayKlass::ArrayProperties) (p | ArrayKlass::NON_ATOMIC);\n+    }\n+    _properties = p;\n+  }\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/layoutKind.hpp\"\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -140,0 +142,1 @@\n+    assert(!element_klass->is_refined_objArray_klass(), \"no such mechanism yet\");\n@@ -183,0 +186,4 @@\n+  if (!vk->maybe_flat_in_array()) {\n+    return ArrayDescription(RefArrayKlassKind, properties, LayoutKind::REFERENCE);\n+  }\n+\n@@ -186,1 +193,1 @@\n-      if (vk->maybe_flat_in_array() && vk->has_non_atomic_layout()) {\n+      if (vk->has_non_atomic_layout()) {\n@@ -188,0 +195,2 @@\n+      } else if (vk->has_atomic_layout()) {\n+        return ArrayDescription(FlatArrayKlassKind, properties, LayoutKind::NULL_FREE_ATOMIC_FLAT);\n@@ -193,1 +202,1 @@\n-      if (vk->maybe_flat_in_array() && vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n+      if (vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n@@ -195,1 +204,1 @@\n-      } else if (vk->maybe_flat_in_array() && vk->has_atomic_layout()) {\n+      } else if (vk->has_atomic_layout()) {\n@@ -203,1 +212,1 @@\n-    if (vk->maybe_flat_in_array() && vk->has_nullable_atomic_layout()) {\n+    if (vk->has_nullable_atomic_layout()) {\n@@ -212,0 +221,1 @@\n+  assert(ArrayKlass::is_null_restricted(props) || !ArrayKlass::is_non_atomic(props), \"only null-restricted array can be non-atomic\");\n@@ -216,1 +226,1 @@\n-      ak = RefArrayKlass::allocate_refArray_klass(class_loader_data(), dimension(), element_klass(), props, CHECK_NULL);\n+      ak = RefArrayKlass::allocate_refArray_klass(class_loader_data(), dimension(), element_klass(), ad._properties, CHECK_NULL);\n@@ -221,1 +231,1 @@\n-      ak = FlatArrayKlass::allocate_klass(element_klass(), props, ad._layout_kind, CHECK_NULL);\n+      ak = FlatArrayKlass::allocate_klass(element_klass(), ad._properties, ad._layout_kind, CHECK_NULL);\n@@ -398,0 +408,2 @@\n+  ArrayDescription ad = array_layout_selection(element_klass(), props);\n+  props = ad._properties;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -72,0 +73,1 @@\n+#include \"opto\/multnode.hpp\"\n@@ -1391,13 +1393,0 @@\n-  if (ta && ta->is_stable()) {\n-    \/\/ Erase stability property for alias analysis.\n-    tj = ta = ta->cast_to_stable(false);\n-  }\n-  if (ta && ta->is_not_flat()) {\n-    \/\/ Erase not flat property for alias analysis.\n-    tj = ta = ta->cast_to_not_flat(false);\n-  }\n-  if (ta && ta->is_not_null_free()) {\n-    \/\/ Erase not null free property for alias analysis.\n-    tj = ta = ta->cast_to_not_null_free(false);\n-  }\n-\n@@ -1414,55 +1403,23 @@\n-    \/\/ For arrays indexed by constant indices, we flatten the alias\n-    \/\/ space to include all of the array body.  Only the header, klass\n-    \/\/ and array length can be accessed un-aliased.\n-    \/\/ For flat inline type array, each field has its own slice so\n-    \/\/ we must include the field offset.\n-    if( offset != Type::OffsetBot ) {\n-      if( ta->const_oop() ) { \/\/ MethodData* or Method*\n-        offset = Type::OffsetBot;   \/\/ Flatten constant access into array body\n-        tj = ta = ta->\n-                remove_speculative()->\n-                cast_to_ptr_type(ptr)->\n-                cast_to_exactness(false)->\n-                with_offset(offset);\n-      } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {\n-        \/\/ range is OK as-is.\n-        tj = ta = TypeAryPtr::RANGE;\n-      } else if( offset == oopDesc::klass_offset_in_bytes() ) {\n-        tj = TypeInstPtr::KLASS; \/\/ all klass loads look alike\n-        ta = TypeAryPtr::RANGE; \/\/ generic ignored junk\n-        ptr = TypePtr::BotPTR;\n-      } else if( offset == oopDesc::mark_offset_in_bytes() ) {\n-        tj = TypeInstPtr::MARK;\n-        ta = TypeAryPtr::RANGE; \/\/ generic ignored junk\n-        ptr = TypePtr::BotPTR;\n-      } else {                  \/\/ Random constant offset into array body\n-        offset = Type::OffsetBot;   \/\/ Flatten constant access into array body\n-        tj = ta = ta->\n-                remove_speculative()->\n-                cast_to_ptr_type(ptr)->\n-                cast_to_exactness(false)->\n-                with_offset(offset);\n-      }\n-    }\n-    \/\/ Arrays of fixed size alias with arrays of unknown size.\n-    if (ta->size() != TypeInt::POS) {\n-      const TypeAry *tary = TypeAry::make(ta->elem(), TypeInt::POS);\n-      tj = ta = ta->\n-              remove_speculative()->\n-              cast_to_ptr_type(ptr)->\n-              with_ary(tary)->\n-              cast_to_exactness(false);\n-    }\n-    \/\/ Arrays of known objects become arrays of unknown objects.\n-    if (ta->elem()->isa_narrowoop() && ta->elem() != TypeNarrowOop::BOTTOM) {\n-      const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta->size());\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    if (ta->elem()->isa_oopptr() && ta->elem() != TypeInstPtr::BOTTOM) {\n-      const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size());\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    \/\/ Initially all flattened array accesses share a single slice\n-    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flat_accesses_share_alias) {\n-      const TypeAry* tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size(), \/* stable= *\/ false, \/* flat= *\/ true);\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n+    \/\/ Common slices\n+    if (offset == arrayOopDesc::length_offset_in_bytes()) {\n+      return TypeAryPtr::RANGE;\n+    } else if (offset == oopDesc::klass_offset_in_bytes()) {\n+      return TypeInstPtr::KLASS;\n+    } else if (offset == oopDesc::mark_offset_in_bytes()) {\n+      return TypeInstPtr::MARK;\n+    }\n+\n+    \/\/ Remove size and stability\n+    const TypeAry* normalized_ary = TypeAry::make(ta->elem(), TypeInt::POS, false, ta->is_flat(), ta->is_not_flat(), ta->is_not_null_free(), ta->is_atomic());\n+    \/\/ Remove ptr, const_oop, and offset\n+    if (ta->elem() == Type::BOTTOM) {\n+      \/\/ Bottom array (meet of int[] and byte[] for example), accesses to it will be done with\n+      \/\/ Unsafe. This should alias with all arrays. For now just leave it as it is (this is\n+      \/\/ incorrect, see JDK-8331133).\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, nullptr, false, Type::Offset::bottom);\n+    } else if (ta->elem()->make_oopptr() != nullptr) {\n+      \/\/ Object arrays, keep field_offset\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, nullptr, ta->klass_is_exact(), Type::Offset::bottom, Type::Offset(ta->field_offset()));\n+    } else {\n+      \/\/ Primitive arrays\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, ta->exact_klass(), true, Type::Offset::bottom);\n@@ -1470,0 +1427,1 @@\n+\n@@ -1473,13 +1431,17 @@\n-      const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta->size());\n-      ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,aklass,false,Type::Offset(offset), ta->field_offset());\n-    }\n-    \/\/ During the 2nd round of IterGVN, NotNull castings are removed.\n-    \/\/ Make sure the Bottom and NotNull variants alias the same.\n-    \/\/ Also, make sure exact and non-exact variants alias the same.\n-    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != nullptr) {\n-      tj = ta = ta->\n-              remove_speculative()->\n-              cast_to_ptr_type(TypePtr::BotPTR)->\n-              cast_to_exactness(false)->\n-              with_offset(offset);\n+      tj = ta = TypeAryPtr::BYTES;\n+    }\n+\n+    \/\/ All arrays of references share the same slice\n+    if (!ta->is_flat() && ta->elem()->make_oopptr() != nullptr) {\n+      const TypeAry* tary = TypeAry::make(TypeInstPtr::BOTTOM, TypeInt::POS, false, false, true, true, true);\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, tary, nullptr, false, Type::Offset::bottom);\n+    }\n+\n+    if (ta->is_flat()) {\n+      if (_flat_accesses_share_alias) {\n+        \/\/ Initially all flattened array accesses share a single slice\n+        tj = ta = TypeAryPtr::INLINES;\n+      } else {\n+        \/\/ Flat accesses are always exact\n+        tj = ta = ta->cast_to_exactness(true);\n+      }\n@@ -2039,0 +2001,2 @@\n+    \/\/ keep the graph canonical\n+    igvn.optimize();\n@@ -2136,0 +2100,1 @@\n+  DEBUG_ONLY(igvn.verify_empty_worklist(nullptr));\n@@ -2221,0 +2186,5 @@\n+      if (current->outcnt() == 0) {\n+        \/\/ This node is killed by a previous iteration\n+        continue;\n+      }\n+\n@@ -2229,1 +2199,2 @@\n-        if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() || n->adr_type() == TypeAryPtr::INLINES) {\n+        if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() ||\n+            (n->adr_type() == TypeAryPtr::INLINES && !n->is_NarrowMemProj())) {\n@@ -2279,1 +2250,1 @@\n-          assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || (n->is_Proj() && n->in(0)->is_Initialize()), \"\");\n+          assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || n->is_NarrowMemProj(), \"\");\n@@ -2283,1 +2254,51 @@\n-          mm = MergeMemNode::make(n);\n+          if (n->is_NarrowMemProj()) {\n+            \/\/ We need 1 NarrowMemProj for each slice of this array\n+            InitializeNode* init = n->in(0)->as_Initialize();\n+            AllocateNode* alloc = init->allocation();\n+            Node* klass_node = alloc->in(AllocateNode::KlassNode);\n+            const TypeAryKlassPtr* klass_type = klass_node->bottom_type()->isa_aryklassptr();\n+            assert(klass_type != nullptr, \"must be an array\");\n+            assert(klass_type->klass_is_exact(), \"must be an exact klass\");\n+            ciArrayKlass* klass = klass_type->exact_klass()->as_array_klass();\n+            assert(klass->is_flat_array_klass(), \"must be a flat array\");\n+            ciInlineKlass* elem_klass = klass->element_klass()->as_inline_klass();\n+            const TypeAryPtr* oop_type = klass_type->as_instance_type()->is_aryptr();\n+            assert(oop_type->klass_is_exact(), \"must be an exact klass\");\n+\n+            Node* base = alloc->in(TypeFunc::Memory);\n+            assert(base->bottom_type() == Type::MEMORY, \"the memory input of AllocateNode must be a memory\");\n+            assert(base->adr_type() == TypePtr::BOTTOM, \"the memory input of AllocateNode must be a bottom memory\");\n+            \/\/ Must create a MergeMem with base as the base memory, do not clone if base is a\n+            \/\/ MergeMem because it may not be processed yet\n+            mm = MergeMemNode::make(nullptr);\n+            mm->set_base_memory(base);\n+            for (int j = 0; j < elem_klass->nof_nonstatic_fields(); j++) {\n+              int field_offset = elem_klass->nonstatic_field_at(j)->offset_in_bytes() - elem_klass->payload_offset();\n+              const TypeAryPtr* field_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(field_offset);\n+              int field_alias_idx = get_alias_index(field_ptr);\n+              assert(field_ptr == get_adr_type(field_alias_idx), \"must match\");\n+              Node* new_proj = new NarrowMemProjNode(init, field_ptr);\n+              igvn.register_new_node_with_optimizer(new_proj);\n+              mm->set_memory_at(field_alias_idx, new_proj);\n+            }\n+            if (!klass->is_elem_null_free()) {\n+              int nm_offset = elem_klass->null_marker_offset_in_payload();\n+              const TypeAryPtr* nm_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(nm_offset);\n+              int nm_alias_idx = get_alias_index(nm_ptr);\n+              assert(nm_ptr == get_adr_type(nm_alias_idx), \"must match\");\n+              Node* new_proj = new NarrowMemProjNode(init, nm_ptr);\n+              igvn.register_new_node_with_optimizer(new_proj);\n+              mm->set_memory_at(nm_alias_idx, new_proj);\n+            }\n+\n+            \/\/ Replace all uses of the old NarrowMemProj with the correct state\n+            MergeMemNode* new_n = MergeMemNode::make(mm);\n+            igvn.register_new_node_with_optimizer(new_n);\n+            igvn.replace_node(n, new_n);\n+          } else {\n+            \/\/ Must create a MergeMem with n as the base memory, do not clone if n is a MergeMem\n+            \/\/ because it may not be processed yet\n+            mm = MergeMemNode::make(nullptr);\n+            mm->set_base_memory(n);\n+          }\n+\n@@ -2297,1 +2318,3 @@\n-              igvn.replace_input_of(m, idx, mm);\n+              Node* new_phi_in = MergeMemNode::make(mm);\n+              igvn.register_new_node_with_optimizer(new_phi_in);\n+              igvn.replace_input_of(m, idx, new_phi_in);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":108,"deletions":85,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -4656,1 +4656,6 @@\n-          const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+          const TypePtr* new_adr_type = tinst->with_offset(adr_type->offset());\n+          if (adr_type->isa_aryptr()) {\n+            \/\/ In the case of a flat inline type array, each field has its own slice so we need a\n+            \/\/ NarrowMemProj for each field of the flat array elements\n+            new_adr_type = new_adr_type->is_aryptr()->with_field_offset(adr_type->is_aryptr()->field_offset().get());\n+          }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"opto\/multnode.hpp\"\n@@ -1879,3 +1880,12 @@\n-Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* vk, bool is_null_free, bool is_not_null_free, bool is_atomic) {\n-  assert(vk->maybe_flat_in_array(), \"element of type %s cannot be flat in array\", vk->name()->as_utf8());\n-  if (!vk->has_nullable_atomic_layout()) {\n+Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* elem_vk) {\n+  assert(elem_vk->maybe_flat_in_array(), \"no flat array for %s\", elem_vk->name()->as_utf8());\n+  if (!elem_vk->has_atomic_layout() && !elem_vk->has_nullable_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, false);\n+  } else if (!elem_vk->has_nullable_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, true);\n+  } else if (!elem_vk->has_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, false, true);\n+  }\n+\n+  bool is_null_free = false;\n+  if (!elem_vk->has_nullable_atomic_layout()) {\n@@ -1885,8 +1895,0 @@\n-  if (!vk->has_atomic_layout() && !vk->has_non_atomic_layout()) {\n-    \/\/ Element does not have a null-free flat layout, cannot be null-free\n-    is_not_null_free = true;\n-  }\n-  if (is_null_free) {\n-    \/\/ TODO 8350865 Impossible type\n-    is_not_null_free = false;\n-  }\n@@ -1894,4 +1896,9 @@\n-  bool is_exact = is_null_free || is_not_null_free;\n-  ciArrayKlass* array_klass = ciArrayKlass::make(vk, is_null_free, is_atomic, true);\n-  assert(array_klass->is_elem_null_free() == is_null_free, \"inconsistency\");\n-  assert(array_klass->is_elem_atomic() == is_atomic, \"inconsistency\");\n+  ciArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, false);\n+  const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+  arytype = arytype->cast_to_flat(true)->cast_to_null_free(is_null_free);\n+  return _gvn.transform(new CheckCastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+}\n+\n+Node* GraphKit::cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic) {\n+  assert(is_null_free || is_atomic, \"nullable arrays must be atomic\");\n+  ciArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, true, is_null_free, is_atomic);\n@@ -1899,2 +1906,2 @@\n-  arytype = arytype->cast_to_exactness(is_exact);\n-  arytype = arytype->cast_to_not_null_free(is_not_null_free);\n+  assert(arytype->klass_is_exact(), \"inconsistency\");\n+  assert(arytype->is_flat(), \"inconsistency\");\n@@ -1902,3 +1909,2 @@\n-  assert(arytype->is_not_null_free() == is_not_null_free, \"inconsistency\");\n-  assert(arytype->is_atomic() == is_atomic, \"inconsistency\");\n-  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+  assert(arytype->is_not_null_free() == !is_null_free, \"inconsistency\");\n+  return _gvn.transform(new CheckCastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n@@ -4173,28 +4179,8 @@\n-      const TypeAryPtr* arytype = oop_type->is_aryptr();\n-      if (arytype->is_flat()) {\n-        \/\/ Initially all flat array accesses share a single slice\n-        \/\/ but that changes after parsing. Prepare the memory graph so\n-        \/\/ it can optimize flat array accesses properly once they\n-        \/\/ don't share a single slice.\n-        assert(C->flat_accesses_share_alias(), \"should be set at parse time\");\n-        C->set_flat_accesses_share_alias(false);\n-        ciInlineKlass* vk = arytype->elem()->inline_klass();\n-        for (int i = 0, len = vk->nof_nonstatic_fields(); i < len; i++) {\n-          ciField* field = vk->nonstatic_field_at(i);\n-          if (field->offset_in_bytes() >= TrackedInitializationLimit * HeapWordSize)\n-            continue;  \/\/ do not bother to track really large numbers of fields\n-          int off_in_vt = field->offset_in_bytes() - vk->payload_offset();\n-          const TypePtr* adr_type = arytype->with_field_offset(off_in_vt)->add_offset(Type::OffsetBot);\n-          int fieldidx = C->get_alias_index(adr_type, true);\n-          \/\/ Pass nullptr for init_out. Having per flat array element field memory edges as uses of the Initialize node\n-          \/\/ can result in per flat array field Phis to be created which confuses the logic of\n-          \/\/ Compile::adjust_flat_array_access_aliases().\n-          hook_memory_on_init(*this, fieldidx, minit_in, nullptr);\n-        }\n-        C->set_flat_accesses_share_alias(true);\n-        hook_memory_on_init(*this, C->get_alias_index(TypeAryPtr::INLINES), minit_in, minit_out);\n-      } else {\n-        const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n-        int            elemidx  = C->get_alias_index(telemref);\n-        hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n-      }\n+      \/\/ Initially all flat array accesses share a single slice\n+      \/\/ but that changes after parsing. Prepare the memory graph so\n+      \/\/ it can optimize flat array accesses properly once they\n+      \/\/ don't share a single slice.\n+      assert(C->flat_accesses_share_alias(), \"should be set at parse time\");\n+      const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n+      int            elemidx  = C->get_alias_index(telemref);\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n@@ -4682,1 +4668,1 @@\n-                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true),\n+                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true, true),\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":35,"deletions":49,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -663,1 +663,2 @@\n-  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_not_null_free, bool is_atomic);\n+  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk);\n+  Node* cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -579,1 +579,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -593,1 +593,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n@@ -1084,1 +1084,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -1106,1 +1106,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -1120,1 +1120,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -2849,1 +2850,1 @@\n-        Node* new_base = cast_to_flat_array(base, value_klass, is_null_free, !is_null_free, is_atomic);\n+        Node* new_base = cast_to_flat_array_exact(base, value_klass, is_null_free, is_atomic);\n@@ -4268,1 +4269,1 @@\n-  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+  const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -4875,1 +4876,0 @@\n-        assert(array_klass->is_elem_atomic() == atomic, \"inconsistency\");\n@@ -4883,1 +4883,1 @@\n-          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces, true);\n+          const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -4899,1 +4899,0 @@\n-          assert(arytype->is_atomic() == atomic, \"inconsistency\");\n@@ -5158,1 +5157,2 @@\n-      const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));\n+      bool not_flat = !UseArrayFlattening;\n+      const Type* akls = TypeAryKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), Type::trust_interfaces, not_flat, false, false, false, not_flat, true);\n@@ -6795,1 +6795,9 @@\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(refined_dest_klass)->is_klassptr();\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->isa_klassptr();\n+    if (dest_klass_t == nullptr) {\n+      \/\/ refined_dest_klass may not be an array, which leads to dest_klass being top. This means we\n+      \/\/ are in a dead path.\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_make_not_entrant);\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -547,0 +547,3 @@\n+          if (!init_value->is_InlineType()) {\n+            return nullptr;\n+          }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"opto\/callnode.hpp\"\n@@ -1239,0 +1241,1 @@\n+\/\/ This method may find an unencoded node instead of the corresponding encoded one.\n@@ -1355,3 +1358,25 @@\n-        \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n-        \/\/ Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n-        return init_value;\n+        const TypeAryPtr* ld_adr_type = phase->type(ld_adr)->isa_aryptr();\n+        if (ld_adr_type == nullptr) {\n+          return nullptr;\n+        }\n+\n+        \/\/ We know that this is not a flat array, the load should return the whole oop\n+        if (ld_adr_type->is_not_flat()) {\n+          return init_value;\n+        }\n+\n+        \/\/ If this is a flat array, try to see through init_value\n+        if (init_value->is_EncodeP()) {\n+          init_value = init_value->in(1);\n+        }\n+        if (!init_value->is_InlineType() || ld_adr_type->field_offset() == Type::Offset::bottom) {\n+          return nullptr;\n+        }\n+\n+        ciInlineKlass* vk = phase->type(init_value)->inline_klass();\n+        int field_offset_in_payload = ld_adr_type->field_offset().get();\n+        if (field_offset_in_payload == vk->null_marker_offset_in_payload()) {\n+          return init_value->as_InlineType()->get_null_marker();\n+        } else {\n+          return init_value->as_InlineType()->field_value_by_offset(field_offset_in_payload + vk->payload_offset(), true);\n+        }\n@@ -1442,0 +1467,4 @@\n+\n+    if (phase->type(value)->isa_ptr() && phase->type(this)->isa_narrowoop()) {\n+      return this;\n+    }\n@@ -2170,2 +2199,6 @@\n-    assert(value->bottom_type()->higher_equal(_type), \"sanity\");\n-    return value->bottom_type();\n+    if (phase->type(value)->isa_ptr() && _type->isa_narrowoop()) {\n+      return phase->type(value)->make_narrowoop();\n+    } else {\n+      assert(value->bottom_type()->higher_equal(_type), \"sanity\");\n+      return phase->type(value);\n+    }\n@@ -2591,0 +2624,7 @@\n+  \/\/ Can see the corresponding value, may need to add an EncodeP\n+  value = can_see_stored_value(in(Memory), phase);\n+  if (value != nullptr && phase->type(value)->isa_ptr() && type()->isa_narrowoop()) {\n+    return new EncodePNode(value, type());\n+  }\n+\n+  \/\/ Identity call will handle the case where EncodeP is unnecessary\n@@ -2670,3 +2710,1 @@\n-    const TypeAryKlassPtr* res = tary->as_klass_type(true)->is_aryklassptr();\n-    \/\/ The klass of an array object must be a refined array klass\n-    return res->cast_to_refined_array_klass_ptr();\n+    return tary->as_klass_type(true)->is_aryklassptr();\n@@ -2695,1 +2733,1 @@\n-      return tkls->is_aryklassptr()->cast_to_refined_array_klass_ptr(false);\n+      return tkls->is_aryklassptr()->with_offset(0)->cast_to_non_refined();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-  Node* check_interpreter_type(Node* l, const Type* type, SafePointNode* &bad_type_exit, bool is_larval);\n+  Node* check_interpreter_type(Node* l, const Type* type, const TypeKlassPtr* klass_type, SafePointNode* &bad_type_exit, bool is_larval);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-Node* Parse::check_interpreter_type(Node* l, const Type* type,\n+Node* Parse::check_interpreter_type(Node* l, const Type* type, const TypeKlassPtr* klass_type,\n@@ -187,1 +187,1 @@\n-    l = gen_checkcast(l, makecon(tp->as_klass_type()->cast_to_exactness(true)), &bad_type_ctrl, false, is_early_larval);\n+    l = gen_checkcast(l, makecon(klass_type), &bad_type_ctrl, false, is_early_larval);\n@@ -378,0 +378,5 @@\n+    const TypeKlassPtr* klass_type = nullptr;\n+    if (type->isa_oopptr()) {\n+      klass_type = TypeKlassPtr::make(osr_block->flow()->local_type_at(index)->unwrap()->as_klass(), Type::ignore_interfaces);\n+      klass_type = klass_type->try_improve();\n+    }\n@@ -379,1 +384,1 @@\n-    set_local(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n+    set_local(index, check_interpreter_type(l, type, klass_type, bad_type_exit, is_early_larval));\n@@ -386,1 +391,6 @@\n-    const Type *type = osr_block->stack_type_at(index);\n+    const Type* type = osr_block->stack_type_at(index);\n+    const TypeKlassPtr* klass_type = nullptr;\n+    if (type->isa_oopptr()) {\n+      klass_type = TypeKlassPtr::make(osr_block->flow()->stack_type_at(index)->unwrap()->as_klass(), Type::ignore_interfaces);\n+      klass_type = klass_type->try_improve();\n+    }\n@@ -388,1 +398,1 @@\n-    set_stack(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n+    set_stack(index, check_interpreter_type(l, type, klass_type, bad_type_exit, is_early_larval));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-          Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+          Node* flat_array = cast_to_flat_array(array, vk);\n@@ -232,2 +232,2 @@\n-    if (!array_type->is_flat() && array_type->is_null_free()) {\n-      \/\/ Store to non-flat null-free inline type array (elements can never be null)\n+    if (array_type->is_null_free() && elemtype->is_inlinetypeptr() && elemtype->inline_klass()->is_empty()) {\n+      \/\/ Array of null-free empty inline type, there is only 1 state for the elements\n@@ -235,5 +235,4 @@\n-      if (elemtype->is_inlinetypeptr() && elemtype->inline_klass()->is_empty()) {\n-        \/\/ Ignore empty inline stores, array is already initialized.\n-        return;\n-      }\n-    } else if (!array_type->is_not_flat()) {\n+      return;\n+    }\n+\n+    if (!array_type->is_not_flat()) {\n@@ -270,1 +269,1 @@\n-            Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+            Node* flat_array = cast_to_flat_array(array, vk);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -1195,1 +1196,1 @@\n-  if (mirror_klass->is_array_klass()) {\n+  if (mirror_klass->is_array_klass() && !mirror_klass->is_type_array_klass()) {\n@@ -1198,1 +1199,2 @@\n-      return phase->makecon(TypeAryKlassPtr::make(mirror_klass, Type::trust_interfaces, true));\n+      ciArrayKlass* refined_mirror_klass = ciObjArrayKlass::make(mirror_klass->as_array_klass()->element_klass(), true);\n+      return phase->makecon(TypeAryKlassPtr::make(refined_mirror_klass, Type::trust_interfaces));\n@@ -1327,2 +1329,1 @@\n-    if (!superklass->as_array_klass()->is_elem_null_free() &&\n-         superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    if (superklass->as_array_klass()->element_klass()->is_inlinetype() && !superklass->as_array_klass()->is_refined()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -658,2 +660,2 @@\n-  TypeAryPtr::BOTTOM = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM, TypeInt::POS), nullptr, false, Offset::bottom);\n-  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), nullptr \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n+  TypeAryPtr::BOTTOM = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM, TypeInt::POS, false, false, false, false, false), nullptr, false, Offset::bottom);\n+  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS, false, false, false, false, false), nullptr \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n@@ -661,1 +663,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS, false, false, false, false, false), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -671,1 +673,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, false, false, false, false, false), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -673,8 +675,8 @@\n-  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);\n-  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);\n-  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);\n-  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);\n-  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);\n-  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);\n-  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);\n-  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true), nullptr, false, Offset::bottom);\n+  TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);\n+  TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);\n+  TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);\n+  TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);\n+  TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);\n+  TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);\n+  TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS, false, false, true, true, true), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);\n+  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, false, false, false), nullptr, false, Offset::bottom);\n@@ -3910,0 +3912,1 @@\n+    bool xk = klass->is_loaded() && klass->as_obj_array_klass()->is_refined();\n@@ -3911,1 +3914,1 @@\n-    const bool is_null_free = klass->as_array_klass()->is_elem_null_free();\n+    const bool is_null_free = xk && klass->as_array_klass()->is_elem_null_free();\n@@ -3921,5 +3924,3 @@\n-    bool not_null_free = not_inline;\n-    bool not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n-    bool atomic = klass->as_array_klass()->is_elem_atomic();\n-    \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n-    bool xk = etype->klass_is_exact() && !etype->is_inlinetypeptr();\n+    bool not_null_free = xk ? !is_null_free : not_inline;\n+    bool not_flat = xk || !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n+    bool atomic = not_flat;\n@@ -3936,1 +3937,1 @@\n-                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -3948,3 +3949,2 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ false, atomic);\n-    const bool exact = is_null_free; \/\/ Only exact if null-free because \"null-free [LMyValue <: null-able [LMyValue\".\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, exact, Offset(0));\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, atomic);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));\n@@ -3996,1 +3996,1 @@\n-                                        \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* not_flat= *\/ true, \/* not_null_free= *\/ true, true);\n@@ -5081,0 +5081,13 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_flat(bool flat) const {\n+  if (flat == is_flat()) {\n+    return this;\n+  }\n+  assert(!flat || !is_not_flat(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), flat, is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -5097,0 +5110,21 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_null_free(bool null_free) const {\n+  if (null_free == is_null_free()) {\n+    return this;\n+  }\n+  assert(!null_free || !is_not_null_free(), \"inconsistency\");\n+  const Type* elem = this->elem();\n+  const Type* new_elem = elem->make_ptr();\n+  if (null_free) {\n+    new_elem = new_elem->join_speculative(TypePtr::NOTNULL);\n+  } else {\n+    new_elem = new_elem->meet_speculative(TypePtr::NULL_PTR);\n+  }\n+  new_elem = elem->isa_narrowoop() ? new_elem->make_narrowoop() : new_elem;\n+  const TypeAry* new_ary = TypeAry::make(new_elem, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -6085,0 +6119,1 @@\n+  bool is_refined = false;\n@@ -6086,0 +6121,1 @@\n+    is_refined = true;\n@@ -6087,7 +6123,11 @@\n-    if (elem->is_klassptr()->klass_is_exact() &&\n-        \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-        \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n-        \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n-        \/\/ If so, we should add '|| is_not_null_free()'\n-        (is_null_free() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n-      xk = true;\n+    if (elem->isa_aryklassptr()) {\n+      const TypeAryKlassPtr* elem_klass = elem->is_aryklassptr();\n+      if (elem_klass->is_refined_type()) {\n+        elem = elem_klass->cast_to_non_refined();\n+      }\n+    } else {\n+      const TypeInstKlassPtr* elem_klass = elem->is_instklassptr();\n+      if (try_for_exact && !xk && elem_klass->klass_is_exact() &&\n+          !elem_klass->exact_klass()->as_instance_klass()->can_be_inline_klass()) {\n+        xk = true;\n+      }\n@@ -6096,1 +6136,1 @@\n-  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_flat() || is_null_free());\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_refined);\n@@ -6106,8 +6146,0 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling) {\n-  if (klass->is_instance_klass()) {\n-    const TypeInterfaces* interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n-  }\n-  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n-}\n-\n@@ -6562,1 +6594,0 @@\n-  const TypeInterfaces* interfaces = _interfaces;\n@@ -6565,3 +6596,1 @@\n-    bool klass_is_exact = ik->is_final();\n-    if (!klass_is_exact &&\n-        deps != nullptr) {\n+    if (deps != nullptr) {\n@@ -6570,1 +6599,3 @@\n-        if (_interfaces->eq(sub)) {\n+        bool improve_to_exact = sub->is_final() && _ptr == NotNull;\n+        const TypeInstKlassPtr* improved = TypeInstKlassPtr::make(improve_to_exact ? Constant : _ptr, sub, _offset);\n+        if (improved->_interfaces->contains(_interfaces)) {\n@@ -6572,3 +6603,1 @@\n-          k = ik = sub;\n-          klass_is_exact = sub->is_final();\n-          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+          return improved;\n@@ -6614,0 +6643,1 @@\n+  const Type* etype;\n@@ -6617,2 +6647,2 @@\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+    etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    k = nullptr;\n@@ -6621,2 +6651,1 @@\n-    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic);\n+    etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n@@ -6625,2 +6654,2 @@\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+    etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    k = nullptr;\n@@ -6629,1 +6658,0 @@\n-    return nullptr;\n@@ -6631,6 +6659,0 @@\n-}\n-\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type) {\n-  bool flat = k->is_flat_array_klass();\n-  bool null_free = k->as_array_klass()->is_elem_null_free();\n-  bool atomic = k->as_array_klass()->is_elem_atomic();\n@@ -6638,6 +6660,2 @@\n-  bool not_inline = k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false);\n-  bool not_null_free = (ptr == Constant) ? !null_free : not_inline;\n-  bool not_flat = (ptr == Constant) ? !flat : (!UseArrayFlattening || not_inline ||\n-                   (k->as_array_klass()->element_klass() != nullptr &&\n-                    k->as_array_klass()->element_klass()->is_inlinetype() &&\n-                   !k->as_array_klass()->element_klass()->maybe_flat_in_array()));\n+  return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+}\n@@ -6645,1 +6663,9 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  ciArrayKlass* k = klass->as_array_klass();\n+  if (k->is_refined()) {\n+    return TypeAryKlassPtr::make(Constant, k, Offset(0), interface_handling, !k->is_flat_array_klass(), !k->is_elem_null_free(),\n+                                 k->is_flat_array_klass(), k->is_elem_null_free(), k->is_elem_atomic(), true);\n+  } else {\n+    \/\/ Use the default combination to canonicalize all non-refined klass pointers\n+    return TypeAryKlassPtr::make(Constant, k, Offset(0), interface_handling, true, true, false, false, true, false);\n+  }\n@@ -6648,2 +6674,8 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type) {\n-  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling, refined_type);\n+const TypeAryKlassPtr* TypeAryKlassPtr::cast_to_non_refined() const {\n+  assert(is_refined_type(), \"must be a refined type\");\n+  PTR ptr = _ptr;\n+  \/\/ There can be multiple refined array types corresponding to a single unrefined type\n+  if (ptr == NotNull && elem()->is_klassptr()->klass_is_exact()) {\n+    ptr = Constant;\n+  }\n+  return make(ptr, elem(), nullptr, _offset, true, true, false, false, true, false);\n@@ -6657,6 +6689,3 @@\n-  ciKlass* eklass = elem()->is_klassptr()->exact_klass_helper();\n-  if (elem()->isa_aryklassptr()) {\n-    eklass = exact_klass()->as_obj_array_klass()->element_klass();\n-  }\n-  ciKlass* array_klass = ciArrayKlass::make(eklass, eklass->is_inlinetype() ? is_null_free() : false, eklass->is_inlinetype() ? is_atomic() : true, refined);\n-  return make(_ptr, array_klass, Offset(0), trust_interfaces, refined);\n+  ciArrayKlass* k = exact_klass()->as_array_klass();\n+  k = ciObjArrayKlass::make(k->element_klass(), refined);\n+  return make(k, trust_interfaces);\n@@ -6751,2 +6780,10 @@\n-    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), is_flat() || is_null_free());\n-    return k;\n+    if (k->is_array_klass() && k->as_array_klass()->is_refined()) {\n+      \/\/ We have no mechanism to create an array of refined arrays\n+      k = ciObjArrayKlass::make(k->as_array_klass()->element_klass(), false);\n+    }\n+    if (klass_is_exact()) {\n+      return ciObjArrayKlass::make(k, true, is_null_free(), is_atomic());\n+    } else {\n+      \/\/ We may reach here if called recursively, must be an unrefined type then\n+      return ciObjArrayKlass::make(k, false);\n+    }\n@@ -6786,9 +6823,2 @@\n-  if (_elem == Type::BOTTOM) return false;\n-  if (_elem == Type::TOP   ) return false;\n-  const TypeKlassPtr*  tk = _elem->isa_klassptr();\n-  if (!tk)             return true;   \/\/ a primitive type, like int\n-  \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-  \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n-  \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n-  \/\/ If so, we should add '&& !is_not_null_free()'\n-  if (tk->isa_instklassptr() && tk->klass()->is_inlinetype() && !is_null_free()) {\n+  assert(klass_is_exact(), \"precondition\");\n+  if (_elem == Type::BOTTOM || _elem == Type::TOP) {\n@@ -6797,2 +6827,5 @@\n-  return tk->must_be_exact();\n-}\n+  const TypeKlassPtr* elem = _elem->isa_klassptr();\n+  if (elem == nullptr) {\n+    \/\/ primitive arrays\n+    return true;\n+  }\n@@ -6800,0 +6833,3 @@\n+  \/\/ refined types are final\n+  return _refined_type;\n+}\n@@ -6803,1 +6839,0 @@\n-  if (must_be_exact() && !klass_is_exact) return this;  \/\/ cannot clear xk\n@@ -6807,1 +6842,3 @@\n-  ciKlass* k = _klass;\n+  if (!klass_is_exact && must_be_exact()) {\n+    return this;\n+  }\n@@ -6812,17 +6849,14 @@\n-  bool not_flat = is_not_flat();\n-  bool not_null_free = is_not_null_free();\n-  if (_elem->isa_klassptr()) {\n-    if (klass_is_exact || _elem->isa_aryklassptr()) {\n-      assert((!is_null_free() && !is_flat()) ||\n-             _elem->is_klassptr()->klass()->is_abstract() || _elem->is_klassptr()->klass()->is_java_lang_Object(),\n-             \"null-free (or flat) concrete inline type arrays should always be exact\");\n-      \/\/ An array can't be null-free (or flat) if the klass is exact\n-      not_null_free = true;\n-      not_flat = true;\n-    } else {\n-      \/\/ Klass is not exact (anymore), re-compute null-free\/flat properties\n-      const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_unique(_elem->is_instklassptr()->instance_klass());\n-      bool not_inline = !exact_etype->can_be_inline_type();\n-      not_null_free = not_inline;\n-      not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n-    }\n+\n+  if (klass_is_exact) {\n+    \/\/ cast_to_exactness(true) really means get the LCA of all values represented by this\n+    \/\/ TypeAryKlassPtr. As a result, it must be an unrefined klass pointer.\n+    return make(Constant, elem, nullptr, _offset, true, true, false, false, true, false);\n+  } else {\n+    \/\/ cast_to_exactness(false) means get the TypeAryKlassPtr representing all values that subtype\n+    \/\/ this value\n+    bool not_inline = !_elem->isa_instklassptr() || !_elem->is_instklassptr()->instance_klass()->can_be_inline_klass();\n+    bool not_flat = !UseArrayFlattening || not_inline ||\n+                    (_elem->isa_instklassptr() && _elem->is_instklassptr()->instance_klass()->is_inlinetype() && !_elem->is_instklassptr()->instance_klass()->maybe_flat_in_array());\n+    bool not_null_free = not_inline;\n+    bool atomic = not_flat;\n+    return make(NotNull, elem, nullptr, _offset, not_flat, not_null_free, false, false, atomic, false);\n@@ -6830,1 +6864,0 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free, _atomic, _refined_type);\n@@ -7168,1 +7201,2 @@\n-    k = ciArrayKlass::make(k, k->is_inlinetype() ? is_null_free() : false, k->is_inlinetype() ? is_atomic() : true, _refined_type);\n+    assert(!k->is_array_klass() || !k->as_array_klass()->is_refined(), \"no mechanism to create an array of refined arrays %s\", k->name()->as_utf8());\n+    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), _refined_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":143,"deletions":109,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -1034,2 +1034,2 @@\n-  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,\n-                             bool flat = false, bool not_flat = false, bool not_null_free = false, bool atomic = false);\n+  static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable,\n+                             bool flat, bool not_flat, bool not_null_free, bool atomic);\n@@ -1816,0 +1816,1 @@\n+  const TypeAryPtr* cast_to_flat(bool flat) const;\n@@ -1817,0 +1818,1 @@\n+  const TypeAryPtr* cast_to_null_free(bool null_free) const;\n@@ -1953,1 +1955,0 @@\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -2136,1 +2137,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type);\n@@ -2144,3 +2145,2 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type = false);\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -2148,0 +2148,1 @@\n+  const TypeAryKlassPtr* cast_to_non_refined() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -414,1 +414,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -428,1 +427,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -431,1 +430,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -441,1 +439,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -444,1 +442,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n@@ -456,1 +453,1 @@\n-            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && (UseNonAtomicValueFlattening || UseAtomicValueFlattening));\n@@ -459,1 +456,0 @@\n-        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-        counts = {SCOPE_OBJECT, \">= 1\", LOAD_OF_ANY_KLASS, \"<= 12\"}) \/\/ TODO 8227588 (loads should be removed)\n+        counts = {SCOPE_OBJECT, \">= 1\"}) \/\/ LOAD_OF_ANY_KLASS, \"<= 12\"}) \/\/ TODO 8372332, 8227588 (loads should be removed)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}