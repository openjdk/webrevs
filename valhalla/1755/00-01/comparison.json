{"files":[{"patch":"@@ -1413,1 +1413,6 @@\n-    if (ta->elem()->make_oopptr() != nullptr) {\n+    if (ta->elem() == Type::BOTTOM) {\n+      \/\/ Bottom array (meet of int[] and byte[] for example), accesses to it will be done with\n+      \/\/ Unsafe. This should alias with all arrays. For now just leave it as it is (this is\n+      \/\/ incorrect!).\n+      tj = ta = TypeAryPtr::make(TypePtr::BotPTR, nullptr, normalized_ary, nullptr, false, Type::Offset::bottom);\n+    } else if (ta->elem()->make_oopptr() != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -5091,1 +5092,2 @@\n-      const Type* akls = TypeAryKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), Type::trust_interfaces, false, false, false, false, false, true);\n+      bool not_flat = !UseArrayFlattening;\n+      const Type* akls = TypeAryKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), Type::trust_interfaces, not_flat, false, false, false, not_flat, true);\n@@ -6716,1 +6718,9 @@\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->isa_klassptr();\n+    if (dest_klass_t == nullptr) {\n+      \/\/ refined_dest_klass may not be an array, which leads to dest_klass being top. This means we\n+      \/\/ are in a dead path.\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_make_not_entrant);\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6103,2 +6103,11 @@\n-    if (elem->isa_aryklassptr() && elem->is_aryklassptr()->is_refined_type()) {\n-      elem = elem->is_aryklassptr()->cast_to_non_refined();\n+    if (elem->isa_aryklassptr()) {\n+      const TypeAryKlassPtr* elem_klass = elem->is_aryklassptr();\n+      if (elem_klass->is_refined_type()) {\n+        elem = elem_klass->cast_to_non_refined();\n+      }\n+    } else {\n+      const TypeInstKlassPtr* elem_klass = elem->is_instklassptr();\n+      if (try_for_exact && !xk && elem_klass->klass_is_exact() &&\n+          !elem_klass->exact_klass()->as_instance_klass()->can_be_inline_klass()) {\n+        xk = true;\n+      }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}