{"files":[{"patch":"@@ -2631,0 +2631,13 @@\n+    \/**\n+     * Special operator symbol for type classes-mediated unary\/binary operator.\n+     * Holds a reference to the method that should be used to perform the operation.\n+     *\/\n+    public static class TypeClassOperatorSymbol extends OperatorSymbol {\n+        public final MethodSymbol opMethod;\n+\n+        public TypeClassOperatorSymbol(Name name, Type type, int opcode, Symbol owner, MethodSymbol opMethod) {\n+            super(name, type, opcode, owner);\n+            this.opMethod = opMethod;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -257,0 +257,4 @@\n+    public final Type numericalType;\n+    public final Type orderableType;\n+    public final Type integralType;\n+    public final Type standardFloatingPointType;\n@@ -667,1 +671,8 @@\n-\n+        numericalType = enterClass(\"java.lang.Numerical\");\n+        orderableType = enterClass(\"java.lang.Orderable\");\n+        integralType = enterClass(\"java.lang.Integral\");\n+        standardFloatingPointType = enterClass(\"java.lang.StandardFloatingPoint\");\n+        synthesizeEmptyInterfaceIfMissing(numericalType);\n+        synthesizeEmptyInterfaceIfMissing(orderableType);\n+        synthesizeEmptyInterfaceIfMissing(integralType);\n+        synthesizeEmptyInterfaceIfMissing(standardFloatingPointType);\n@@ -948,0 +959,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3502,1 +3502,1 @@\n-        tree.operator = operators.resolveUnary(arg, optag, arg.type);\n+        tree.operator = operators.resolveUnary(arg, env, optag, arg.type);\n@@ -4386,1 +4386,1 @@\n-        Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);\n+        Symbol operator = tree.operator = operators.resolveBinary(tree, env, tree.getTag().noAssignOp(), owntype, operand);\n@@ -4407,1 +4407,1 @@\n-        OperatorSymbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);\n+        OperatorSymbol operator = tree.operator = operators.resolveUnary(tree, env, tree.getTag(), argtype);\n@@ -4461,1 +4461,1 @@\n-        OperatorSymbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);\n+        OperatorSymbol operator = tree.operator = operators.resolveBinary(tree, env, tree.getTag(), left, right);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -760,2 +760,2 @@\n-        JCBinary testExpr = make.Binary(Tag.EQ, arg1, arg2);\n-        testExpr.operator = operators.resolveBinary(testExpr, Tag.EQ, argType, argType);\n+        JCBinary testExpr = make.Binary(JCTree.Tag.EQ, arg1, arg2);\n+        testExpr.operator = operators.resolveBinary(testExpr, attrEnv, JCTree.Tag.EQ, argType, argType);\n@@ -774,2 +774,2 @@\n-        JCBinary compound = make.Binary(Tag.AND, prev, eqtest);\n-        compound.operator = operators.resolveBinary(compound, Tag.AND, syms.booleanType, syms.booleanType);\n+        JCBinary compound = make.Binary(JCTree.Tag.AND, prev, eqtest);\n+        compound.operator = operators.resolveBinary(compound, attrEnv, JCTree.Tag.AND, syms.booleanType, syms.booleanType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-        tree.operator = operators.resolveUnary(tree, optag, arg.type);\n+        tree.operator = operators.resolveUnary(tree, attrEnv, optag, arg.type);\n@@ -585,1 +585,1 @@\n-        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n+        tree.operator = operators.resolveBinary(tree, attrEnv, optag, lhs.type, rhs.type);\n@@ -597,1 +597,1 @@\n-        tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);\n+        tree.operator = operators.resolveBinary(tree, attrEnv, tree.getTag().noAssignOp(), lhs.type, rhs.type);\n@@ -3419,0 +3419,1 @@\n+        final boolean typeClassReq = tree.operator.opcode == type_classes_binop;\n@@ -3423,1 +3424,1 @@\n-        if (boxingReq || depScanner.dependencyFound) {\n+        if (boxingReq || typeClassReq || depScanner.dependencyFound) {\n@@ -3434,3 +3435,3 @@\n-                                                              newTag,\n-                                                              tree.type,\n-                                                              tree.rhs.type);\n+                                                              attrEnv, newTag,\n+                                                              typeClassReq ? tree.operator.type.getParameterTypes().head : tree.type,\n+                                                              typeClassReq ? tree.operator.type.getParameterTypes().tail.head : tree.rhs.type);\n@@ -3564,9 +3565,8 @@\n-        if (tree.hasTag(NOT) && tree.arg.type.constValue() != null) {\n-            tree.type = cfolder.fold1(bool_not, tree.arg.type);\n-        }\n-\n-        \/\/ If translated left hand side is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, return\n-        \/\/ that access method invocation as result.\n-        if (isUpdateOperator && tree.arg.hasTag(APPLY)) {\n-            result = tree.arg;\n+        if (tree.operator.opcode == type_classes_unop) {\n+            \/\/ type classes unary operation\n+            TypeClassOperatorSymbol tcOp = (TypeClassOperatorSymbol)tree.operator;\n+            Type opType = tree.operator.type.getParameterTypes().head;\n+            ClassType witness = new ClassType(Type.noType, List.of(opType), (TypeSymbol) tcOp.opMethod.owner);\n+            JCExpression witnessRcvr = make.Ident(witnessOf((WitnessSymbol) rs.findWitness(attrEnv, witness)));\n+            JCExpression witnessMeth = make.Select(witnessRcvr, tcOp.opMethod);\n+            result = make.App(witnessMeth, List.of(tree.arg)).setType(tree.type);\n@@ -3574,1 +3574,12 @@\n-            result = tree;\n+            if (tree.hasTag(NOT) && tree.arg.type.constValue() != null) {\n+                tree.type = cfolder.fold1(bool_not, tree.arg.type);\n+            }\n+\n+            \/\/ If translated left hand side is an Apply, we are\n+            \/\/ seeing an access method invocation. In this case, return\n+            \/\/ that access method invocation as result.\n+            if (isUpdateOperator && tree.arg.hasTag(APPLY)) {\n+                result = tree.arg;\n+            } else {\n+                result = tree;\n+            }\n@@ -3604,1 +3615,11 @@\n-        result = tree;\n+        if (tree.operator.opcode == type_classes_binop) {\n+            \/\/ type classes unary operation\n+            TypeClassOperatorSymbol tcOp = (TypeClassOperatorSymbol)tree.operator;\n+            Type opType = tree.operator.type.getParameterTypes().head;\n+            ClassType witness = new ClassType(Type.noType, List.of(opType), (TypeSymbol) tcOp.opMethod.owner);\n+            JCExpression witnessRcvr = make.Ident(witnessOf((WitnessSymbol) rs.findWitness(attrEnv, witness)));\n+            JCExpression witnessMeth = make.Select(witnessRcvr, tcOp.opMethod);\n+            result = make.App(witnessMeth, List.of(tree.lhs, tree.rhs)).setType(tree.type);\n+        } else {\n+            result = tree;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":39,"deletions":18,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -29,0 +30,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n@@ -30,0 +32,1 @@\n+import com.sun.tools.javac.code.Symbol.TypeClassOperatorSymbol;\n@@ -32,0 +35,1 @@\n+import com.sun.tools.javac.code.Type.ClassType;\n@@ -51,1 +55,0 @@\n-import java.util.function.BiPredicate;\n@@ -75,0 +78,1 @@\n+    private final Resolve resolve;\n@@ -99,0 +103,1 @@\n+        resolve = Resolve.instance(context);\n@@ -150,1 +155,1 @@\n-    OperatorSymbol resolveUnary(DiagnosticPosition pos, JCTree.Tag tag, Type op) {\n+    OperatorSymbol resolveUnary(DiagnosticPosition pos, Env<AttrContext> env, JCTree.Tag tag, Type op) {\n@@ -153,2 +158,2 @@\n-                unop -> unop.test(op),\n-                unop -> unop.resolve(op),\n+                unop -> unop.test(env, op),\n+                unop -> unop.resolve(env, op),\n@@ -161,1 +166,1 @@\n-    OperatorSymbol resolveBinary(DiagnosticPosition pos, JCTree.Tag tag, Type op1, Type op2) {\n+    OperatorSymbol resolveBinary(DiagnosticPosition pos, Env<AttrContext> env, JCTree.Tag tag, Type op1, Type op2) {\n@@ -164,2 +169,2 @@\n-                binop -> binop.test(op1, op2),\n-                binop -> binop.resolve(op1, op2),\n+                binop -> binop.test(env, op1, op2),\n+                binop -> binop.resolve(env, op1, op2),\n@@ -305,0 +310,11 @@\n+\n+        \/\/ type class support\n+\n+        final MethodSymbol findOpMethod(Type site, Name name) {\n+            return (MethodSymbol) site.tsym.members()\n+                    .findFirst(name, s -> s.kind == Kind.MTH);\n+        }\n+\n+        final ClassType witnessType(Type site, Type arg) {\n+            return new ClassType(Type.noType, List.of(arg), site.tsym);\n+        }\n@@ -310,1 +326,1 @@\n-    abstract class UnaryOperatorHelper extends OperatorHelper implements Predicate<Type> {\n+    abstract class UnaryOperatorHelper extends OperatorHelper {\n@@ -340,0 +356,6 @@\n+        \/**\n+         * This method will be overridden by unary operator helpers to provide custom operator\n+         * applicability logic.\n+         *\/\n+        abstract boolean test(Env<AttrContext> env, Type arg);\n+\n@@ -344,1 +366,1 @@\n-        abstract OperatorSymbol resolve(Type t);\n+        abstract OperatorSymbol resolve(Env<AttrContext> env, Type t);\n@@ -347,1 +369,1 @@\n-    abstract class BinaryOperatorHelper extends OperatorHelper implements BiPredicate<Type, Type> {\n+    abstract class BinaryOperatorHelper extends OperatorHelper {\n@@ -379,0 +401,6 @@\n+        \/**\n+         * This method will be overridden by binary operator helpers to provide custom operator\n+         * applicability logic.\n+         *\/\n+        abstract boolean test(Env<AttrContext> env, Type arg1, Type arg2);\n+\n@@ -383,1 +411,1 @@\n-        abstract OperatorSymbol resolve(Type t1, Type t2);\n+        abstract OperatorSymbol resolve(Env<AttrContext> env, Type t1, Type t2);\n@@ -396,1 +424,1 @@\n-        public boolean test(Type type) {\n+        public boolean test(Env<AttrContext> env, Type type) {\n@@ -401,1 +429,1 @@\n-        public OperatorSymbol resolve(Type arg) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg) {\n@@ -424,1 +452,1 @@\n-        public boolean test(Type type) {\n+        public boolean test(Env<AttrContext> env, Type type) {\n@@ -429,1 +457,1 @@\n-        public OperatorSymbol resolve(Type arg) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg) {\n@@ -434,0 +462,39 @@\n+    \/**\n+     * Class representing type classes-mediated unary operator helpers.\n+     *\/\n+    class UnaryTypeClassOperator extends UnaryOperatorHelper {\n+\n+        final Function<Symtab, Type> typeClassFunc;\n+        final Name opMethodName;\n+\n+        UnaryTypeClassOperator(Tag tag, Function<Symtab, Type> typeClassFunc, String opMethodName) {\n+            super(tag);\n+            this.typeClassFunc = typeClassFunc;\n+            this.opMethodName = names.fromString(opMethodName);\n+        }\n+\n+        @Override\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg) {\n+            \/\/ return new \"virtual\" op symbol\n+            MethodSymbol opMethod = findOpMethod(typeClassFunc.apply(syms), opMethodName);\n+            Type mtype = types.memberType(witnessType(typeClassFunc.apply(syms), arg), opMethod);\n+            return new TypeClassOperatorSymbol(name, mtype,\n+                    type_classes_unop, syms.noSymbol, opMethod);\n+        }\n+\n+        @Override\n+        public boolean test(Env<AttrContext> env, Type arg) {\n+            if (types.unboxedTypeOrType(arg).isPrimitive()) {\n+                return false;\n+            }\n+            Type witnessType = witnessType(typeClassFunc.apply(syms), arg);\n+            Symbol witnessSym = resolve.findWitness(env, witnessType);\n+            if (!witnessSym.exists()) {\n+                return false;\n+            }\n+            Symbol found = resolve.resolveQualifiedMethod(env.enclClass, env, witnessType,\n+                    opMethodName, List.of(arg), List.nil());\n+            return found.kind.isValid();\n+        }\n+    }\n+\n@@ -445,1 +512,1 @@\n-        public boolean test(Type type) {\n+        public boolean test(Env<AttrContext> env, Type type) {\n@@ -450,1 +517,1 @@\n-        public OperatorSymbol resolve(Type arg) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg) {\n@@ -466,1 +533,1 @@\n-        public OperatorSymbol resolve(Type arg) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg) {\n@@ -489,1 +556,1 @@\n-        public OperatorSymbol resolve(Type arg1, Type arg2) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -495,1 +562,1 @@\n-        public boolean test(Type arg1, Type arg2) {\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -501,0 +568,39 @@\n+    \/**\n+     * Class representing type classes-mediated binary operator helpers.\n+     *\/\n+    class BinaryTypeClassOperator extends BinaryOperatorHelper {\n+\n+        final Function<Symtab, Type> typeClassFunc;\n+        final Name opMethodName;\n+\n+        BinaryTypeClassOperator(Tag tag, Function<Symtab, Type> typeClassFunc, String opMethodName) {\n+            super(tag);\n+            this.typeClassFunc = typeClassFunc;\n+            this.opMethodName = names.fromString(opMethodName);\n+        }\n+\n+        @Override\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg1, Type arg2) {\n+            \/\/ return new \"virtual\" op symbol\n+            MethodSymbol opMethod = findOpMethod(typeClassFunc.apply(syms), opMethodName);\n+            Type mtype = types.memberType(witnessType(typeClassFunc.apply(syms), arg1), opMethod);\n+            return new TypeClassOperatorSymbol(name, mtype,\n+                    type_classes_binop, syms.noSymbol, opMethod);\n+        }\n+\n+        @Override\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n+            if (types.unboxedTypeOrType(arg1).isPrimitive()) {\n+                return false;\n+            }\n+            Type witnessType = witnessType(typeClassFunc.apply(syms), arg1);\n+            Symbol witnessSym = resolve.findWitness(env, witnessType);\n+            if (!witnessSym.exists()) {\n+                return false;\n+            }\n+            Symbol found = resolve.resolveQualifiedMethod(env.enclClass, env, witnessType,\n+                    opMethodName, List.of(arg1, arg2), List.nil());\n+            return found.kind.isValid();\n+        }\n+    }\n+\n@@ -512,1 +618,1 @@\n-        public OperatorSymbol resolve(Type arg1, Type arg2) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -517,1 +623,1 @@\n-        public boolean test(Type arg1, Type arg2) {\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -535,1 +641,1 @@\n-        public OperatorSymbol resolve(Type arg1, Type arg2) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -540,1 +646,1 @@\n-        public boolean test(Type arg1, Type arg2) {\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -578,1 +684,1 @@\n-        public OperatorSymbol resolve(Type arg1, Type arg2) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -583,1 +689,1 @@\n-        public boolean test(Type arg1, Type arg2) {\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -616,1 +722,1 @@\n-        public boolean test(Type arg1, Type arg2) {\n+        public boolean test(Env<AttrContext> env, Type arg1, Type arg2) {\n@@ -621,1 +727,1 @@\n-        public OperatorSymbol resolve(Type t1, Type t2) {\n+        public OperatorSymbol resolve(Env<AttrContext> env, Type t1, Type t2) {\n@@ -650,0 +756,27 @@\n+    \/**\n+     * Operator                     Method\n+     * ---------------------------  ---------------------------\n+     * Addition (+)                 Numerical::add\n+     * Subtraction (-)              Numerical::subtract\n+     * Multiplication (*)           Numerical::multiply\n+     * Division (\/)                 Numerical::divide\n+     * Remainder (%)                Numerical::remainder\n+     * Unary plus (+)               Numerical::plus\n+     * Unary minus (-)              Numerical::negate\n+     * Bitwise AND (&)              Integral::and\n+     * Bitwise OR (|)               Integral::or\n+     * Bitwise XOR (^)              Integral::xor\n+     * Bitwise complement (~)       Integral::complement\n+     * Left shift (<<)              Integral::shiftLeft\n+     * Right shift (>>)             Integral::shiftRight\n+     * Unsigned right shift (>>>)   Integral::shiftRightUnsigned\n+     * Less than (<)                Orderable::lessThan\n+     * Less than or equal (<=)      Orderable::lessThanEqual\n+     * Greater than (>)             Orderable::greaterThan\n+     * Greater than or equal (>=)   Orderable::greaterThanEqual\n+     *\/\n+\n+    final Function<Symtab, Type> orderable = symtab -> symtab.orderableType;\n+    final Function<Symtab, Type> numerical = symtab -> symtab.numericalType;\n+    final Function<Symtab, Type> integral = symtab -> symtab.integralType;\n+\n@@ -652,0 +785,1 @@\n+     * Operators with same tag are tested in the same order as they are declared below.\n@@ -660,0 +794,1 @@\n+                new UnaryTypeClassOperator(Tag.POS, numerical, \"plus\"),\n@@ -665,0 +800,1 @@\n+                new UnaryTypeClassOperator(Tag.NEG, numerical, \"negate\"),\n@@ -668,0 +804,1 @@\n+                new UnaryTypeClassOperator(Tag.COMPL, integral, \"complement\"),\n@@ -692,0 +829,1 @@\n+     * Operators with same tag are tested in the same order as they are declared below.\n@@ -716,0 +854,1 @@\n+            new BinaryTypeClassOperator(Tag.PLUS, numerical, \"add\"),\n@@ -721,0 +860,1 @@\n+            new BinaryTypeClassOperator(Tag.MINUS, numerical, \"subtract\"),\n@@ -726,0 +866,1 @@\n+            new BinaryTypeClassOperator(Tag.MUL, numerical, \"multiply\"),\n@@ -731,0 +872,1 @@\n+            new BinaryTypeClassOperator(Tag.DIV, numerical, \"divide\"),\n@@ -736,0 +878,1 @@\n+            new BinaryTypeClassOperator(Tag.MOD, numerical, \"remainder\"),\n@@ -741,0 +884,1 @@\n+            new BinaryTypeClassOperator(Tag.BITAND, integral, \"and\"),\n@@ -746,0 +890,1 @@\n+            new BinaryTypeClassOperator(Tag.BITOR, integral, \"or\"),\n@@ -751,0 +896,1 @@\n+            new BinaryTypeClassOperator(Tag.BITXOR, integral, \"xor\"),\n@@ -756,0 +902,1 @@\n+            new BinaryTypeClassOperator(Tag.SL, integral, \"shiftLeft\"),\n@@ -761,0 +908,1 @@\n+            new BinaryTypeClassOperator(Tag.SR, integral, \"shiftRight\"),\n@@ -766,0 +914,1 @@\n+            new BinaryTypeClassOperator(Tag.USR, integral, \"shiftRightUnsigned\"),\n@@ -771,0 +920,1 @@\n+            new BinaryTypeClassOperator(Tag.LT, orderable, \"lessThan\"),\n@@ -776,0 +926,1 @@\n+            new BinaryTypeClassOperator(Tag.GT, orderable, \"greaterThan\"),\n@@ -781,0 +932,1 @@\n+            new BinaryTypeClassOperator(Tag.LE, orderable, \"lessThanEqual\"),\n@@ -786,0 +938,1 @@\n+            new BinaryTypeClassOperator(Tag.GE, orderable, \"greaterThanEqual\"),\n@@ -823,1 +976,1 @@\n-            opsMap.put(opName, helpers.prepend(o));\n+            opsMap.put(opName, helpers.append(o));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Operators.java","additions":182,"deletions":29,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -1427,1 +1427,1 @@\n-        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n+        tree.operator = operators.resolveBinary(tree, env, optag, lhs.type, rhs.type);\n@@ -1438,1 +1438,1 @@\n-        tree.operator = operators.resolveUnary(tree, optag, arg.type);\n+        tree.operator = operators.resolveUnary(tree, env, optag, arg.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -268,0 +268,8 @@\n+    \/** Virtual opcode for type class overload binary operators\n+     *\/\n+    int type_classes_binop           = 277;\n+\n+    \/** Virtual opcode for type class overload unary operators\n+     *\/\n+    int type_classes_unop           = 278;\n+\n@@ -270,1 +278,1 @@\n-    int error           = 277;\n+    int error           = 279;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ByteCodes.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -242,0 +242,2 @@\n+    public final Name lookupWitness;\n+    public final Name add;\n@@ -437,0 +439,2 @@\n+        lookupWitness = fromString(\"lookupWitness\");\n+        add = fromString(\"add\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run junit TypeClassesOperatorResolutionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class TypeClassesOperatorResolutionTest {\n+    record NumBox(int x) {\n+        __witness Numerical<NumBox> NUM = new Numerical<>() {\n+            @Override\n+            public NumBox add(NumBox addend, NumBox augend) {\n+                return new NumBox(addend.x + augend.x);\n+            }\n+\n+            @Override\n+            public NumBox subtract(NumBox minuend, NumBox subtrahend) {\n+                return new NumBox(minuend.x - subtrahend.x);\n+            }\n+\n+            @Override\n+            public NumBox multiply(NumBox multiplier, NumBox multiplicand) {\n+                return new NumBox(multiplier.x * multiplicand.x);\n+            }\n+\n+            @Override\n+            public NumBox divide(NumBox dividend, NumBox divisor) {\n+                return new NumBox(dividend.x \/ divisor.x);\n+            }\n+\n+            @Override\n+            public NumBox remainder(NumBox dividend, NumBox divisor) {\n+                return new NumBox(dividend.x % divisor.x);\n+            }\n+\n+            @Override\n+            public NumBox plus(NumBox operand) {\n+                return operand;\n+            }\n+\n+            @Override\n+            public NumBox negate(NumBox operand) {\n+                return new NumBox(-operand.x);\n+            }\n+        };\n+\n+        __witness Orderable<NumBox> ORD = new Orderable<NumBox>() {\n+            @Override\n+            public boolean lessThan(NumBox op1, NumBox op2) {\n+                return op1.x < op2.x;\n+            }\n+\n+            @Override\n+            public boolean lessThanEqual(NumBox op1, NumBox op2) {\n+                return op1.x <= op2.x;\n+            }\n+\n+            @Override\n+            public boolean greaterThan(NumBox op1, NumBox op2) {\n+                return op1.x > op2.x;\n+            }\n+\n+            @Override\n+            public boolean greaterThanEqual(NumBox op1, NumBox op2) {\n+                return op1.x >= op2.x;\n+            }\n+\n+            @Override\n+            public NumBox min(NumBox op1, NumBox op2) {\n+                return new NumBox(Math.min(op1.x, op2.x));\n+            }\n+\n+            @Override\n+            public NumBox max(NumBox op1, NumBox op2) {\n+                return new NumBox(Math.max(op1.x, op2.x));\n+            }\n+        };\n+\n+        __witness Integral<NumBox> INT = new Integral<>() {\n+            @Override\n+            public NumBox add(NumBox addend, NumBox augend) {\n+                return NUM.add(addend, augend);\n+            }\n+\n+            @Override\n+            public NumBox subtract(NumBox minuend, NumBox subtrahend) {\n+                return NUM.subtract(minuend, subtrahend);\n+            }\n+\n+            @Override\n+            public NumBox multiply(NumBox multiplier, NumBox multiplicand) {\n+                return NUM.multiply(multiplier, multiplicand);\n+            }\n+\n+            @Override\n+            public NumBox divide(NumBox dividend, NumBox divisor) {\n+                return NUM.divide(dividend, divisor);\n+            }\n+\n+            @Override\n+            public NumBox remainder(NumBox dividend, NumBox divisor) {\n+                return NUM.remainder(dividend, divisor);\n+            }\n+\n+            @Override\n+            public NumBox plus(NumBox operand) {\n+                return NUM.plus(operand);\n+            }\n+\n+            @Override\n+            public NumBox negate(NumBox operand) {\n+                return NUM.negate(operand);\n+            }\n+\n+            @Override\n+            public NumBox and(NumBox op1, NumBox op2) {\n+                return new NumBox(op1.x & op2.x);\n+            }\n+\n+            @Override\n+            public NumBox or(NumBox op1, NumBox op2) {\n+                return new NumBox(op1.x | op2.x);\n+            }\n+\n+            @Override\n+            public NumBox xor(NumBox op1, NumBox op2) {\n+                return new NumBox(op1.x ^ op2.x);\n+            }\n+\n+            @Override\n+            public NumBox complement(NumBox op1) {\n+                return new NumBox(~op1.x);\n+            }\n+\n+            @Override\n+            public NumBox shiftLeft(NumBox x, int shiftDistance) {\n+                return new NumBox(x.x << shiftDistance);\n+            }\n+\n+            @Override\n+            public NumBox shiftRight(NumBox x, int shiftDistance) {\n+                return new NumBox(x.x >> shiftDistance);\n+            }\n+\n+            @Override\n+            public NumBox shiftRightUnsigned(NumBox x, int shiftDistance) {\n+                return new NumBox(x.x >>> shiftDistance);\n+            }\n+\n+            @Override\n+            public boolean lessThan(NumBox op1, NumBox op2) {\n+                return ORD.lessThan(op1, op2);\n+            }\n+\n+            @Override\n+            public boolean lessThanEqual(NumBox op1, NumBox op2) {\n+                return ORD.lessThanEqual(op1, op2);\n+            }\n+\n+            @Override\n+            public boolean greaterThan(NumBox op1, NumBox op2) {\n+                return ORD.greaterThan(op1, op2);\n+            }\n+\n+            @Override\n+            public boolean greaterThanEqual(NumBox op1, NumBox op2) {\n+                return ORD.greaterThanEqual(op1, op2);\n+            }\n+\n+            @Override\n+            public NumBox min(NumBox op1, NumBox op2) {\n+                return ORD.min(op1, op2);\n+            }\n+\n+            @Override\n+            public NumBox max(NumBox op1, NumBox op2) {\n+                return ORD.max(op1, op2);\n+            }\n+        };\n+    }\n+\n+    static NumBox numBox(int x) {\n+        return new NumBox(x);\n+    }\n+\n+    @Test\n+    void testNumerical() {\n+        assertEquals(numBox(1 + 2), numBox(1) + numBox(2)); \/\/ 3\n+        assertEquals(numBox(1 - 2), numBox(1) - numBox(2)); \/\/ -1\n+        assertEquals(numBox(2 * 3), numBox(2) * numBox(3)); \/\/ 6\n+        assertEquals(numBox(5 \/ 2), numBox(5) \/ numBox(2)); \/\/ 2\n+        assertEquals(numBox(5 % 2), numBox(5) % numBox(2)); \/\/ 1\n+        assertEquals(numBox(+1), +numBox(1));                       \/\/ 1\n+        assertEquals(numBox(-1), -numBox(1));                       \/\/ -1\n+    }\n+\n+    @Test\n+    void testIntegral() {\n+        assertEquals(numBox(1 & 2), numBox(1) & numBox(2));        \/\/ 0\n+        assertEquals(numBox(1 | 2), numBox(1) | numBox(2));        \/\/ 3\n+        assertEquals(numBox(1 ^ 2), numBox(1) ^ numBox(2));        \/\/ 3\n+        assertEquals(numBox(~1), ~numBox(1));                           \/\/ -2\n+        assertEquals(numBox(1 << 2), numBox(1) << 2);                 \/\/ 4\n+        assertEquals(numBox(4 >> 2), numBox(4) >> 2);                 \/\/ 1\n+        assertEquals(numBox(-4 >>> 30), numBox(-4) >>> 30);           \/\/ 3\n+    }\n+\n+    @Test\n+    void testOrderable() {\n+        assertTrue(numBox(1) < numBox(2));\n+        assertTrue(numBox(1) <= numBox(2));\n+        assertTrue(numBox(2) > numBox(1));\n+        assertTrue(numBox(2) >= numBox(1));\n+        assertTrue(numBox(2) >= numBox(2));\n+        assertTrue(numBox(2) <= numBox(2));\n+    }\n+\n+    @Test\n+    void testAssignopNumerical() {\n+        var plus = numBox(1);\n+        plus += numBox(2);\n+        assertEquals(numBox(1 + 2), plus); \/\/ 3\n+\n+        var sub = numBox(1);\n+        sub -= numBox(2);\n+        assertEquals(numBox(1 - 2), sub); \/\/ -1\n+\n+        var mul = numBox(2);\n+        mul *= numBox(3);\n+        assertEquals(numBox(2 * 3), mul); \/\/ 6\n+\n+        var div = numBox(5);\n+        div \/= numBox(2);\n+        assertEquals(numBox(5 \/ 2), div); \/\/ 2\n+\n+        var mod = numBox(5);\n+        mod %= numBox(2);\n+        assertEquals(numBox(5 % 2), mod); \/\/ 1\n+    }\n+\n+    @Test\n+    void testAssignopIntegral() {\n+        var and = numBox(1);\n+        and &= numBox(2);\n+        assertEquals(numBox(1 & 2), and); \/\/ 0\n+\n+        var or = numBox(1);\n+        or |= numBox(2);\n+        assertEquals(numBox(1 | 2), or); \/\/ 3\n+\n+        var xor = numBox(1);\n+        xor ^= numBox(2);\n+        assertEquals(numBox(1 ^ 2), xor); \/\/ 3\n+\n+        var shl = numBox(1);\n+        shl <<= 2;\n+        assertEquals(numBox(1 << 2), shl); \/\/ 4\n+\n+        var shr = numBox(4);\n+        shr >>= 2;\n+        assertEquals(numBox(4 >> 2), shr); \/\/ 1\n+\n+        var ushr = numBox(-4);\n+        ushr >>= 30;\n+        assertEquals(numBox(-4 >> 30), ushr); \/\/ 3\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesOperatorResolutionTest.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"}]}