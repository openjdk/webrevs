{"files":[{"patch":"@@ -5351,0 +5351,6 @@\n+    if (obj_type->is_inlinetypeptr()) {\n+      \/\/ If the object to clone is an inline type, we can simply return it (i.e. a nop) since inline types have\n+      \/\/ no identity.\n+      set_result(obj);\n+      return true;\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1675,0 +1675,29 @@\n+\n+    static value class MyValueClonable implements Cloneable {\n+        int x;\n+\n+        MyValueClonable(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public Object clone() throws CloneNotSupportedException {\n+            return super.clone();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC, \"1\"})\n+    public Object testClone() throws CloneNotSupportedException {\n+        MyValueClonable obj = new MyValueClonable(3);\n+        return obj.clone();\n+    }\n+\n+    @Run(test = \"testClone\")\n+    public void testClone_verifier() {\n+        try {\n+            testClone();\n+        } catch (Exception e) {\n+            Asserts.fail(\"testClone() failed\", e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}