{"files":[{"patch":"@@ -711,1 +711,0 @@\n-            \/\/ TODO will be fixed by 8328470\n@@ -862,0 +861,11 @@\n+\n+    if (res->bottom_type()->is_inlinetypeptr()) {\n+      assert(C->has_circular_inline_type(), \"non-circular inline types should have been replaced earlier\");\n+      \/\/ Nullable inline types have an IsInit field which is added to the safepoint when scalarizing them (see\n+      \/\/ InlineTypeNode::make_scalar_in_safepoint()). When having circular inline types, we stop scalarizing at depth 1\n+      \/\/ to avoid an endless recursion. Therefore, we do not have a SafePointScalarObjectNode node here, yet.\n+      \/\/ We are about to create a SafePointScalarObjectNode as if this is a normal object. Add an additional int input\n+      \/\/ with value 1 to indicate that the buffer is always initialized (i.e. IsInit is true). This input is checked\n+      \/\/ later in PhaseOutput::filLocArray() for inline types.\n+      sfpt->add_req(_igvn.intcon(1));\n+    }\n@@ -984,1 +994,2 @@\n-  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n+  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr() || C->has_circular_inline_type(),\n+         \"Inline type allocations should have been scalarized earlier\");\n@@ -1243,1 +1254,2 @@\n-      assert(!inline_alloc, \"Inline type allocations should not have safepoint uses\");\n+      assert(!inline_alloc || C->has_circular_inline_type(),\n+             \"Inline type allocations should have been scalarized earlier\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3290,0 +3290,58 @@\n+\n+    static value class CircularValue7 {\n+        CircularValue7 v;\n+        int i;\n+\n+        public CircularValue7(int i) {\n+            this.v = new CircularValue7(); \/\/ When <init> is incrementally inlined: StoreN into object\n+            dontInline(); \/\/ Not inlined -> safepoint which also saves StoreN.\n+            this.i = i;\n+        }\n+\n+        public CircularValue7(boolean ignored) {\n+            this.v = new CircularValue7();\n+            this.i = 23;\n+        }\n+\n+        public CircularValue7() {\n+            this.v = null;\n+            this.i = 34;\n+        }\n+\n+        @DontInline\n+        static void dontInline() {}\n+    }\n+\n+    @Test\n+    @IR(failOn = ALLOC_G)\n+    int testCircularSafepointUse() {\n+        CircularValue7 v = new CircularValue7(true);  \/\/ v is non escaping -> EA can remove allocation\n+        dontInline(); \/\/ Not inlined -> safepoint\n+        return v.i; \/\/ Use v such that it is still required in the safepoint at dontInline()\n+    }\n+\n+    @DontInline\n+    void dontInline() {}\n+\n+    @Run(test = \"testCircularSafepointUse\")\n+    public void testCircularSafepointUse_verifier() {\n+        Asserts.assertEQ(testCircularSafepointUse(), new CircularValue7(true).i);\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = ALLOC_G)\n+    int testCircularSafepointUse2(int i) {\n+        \/\/ With AlwaysIncrementalInline:\n+        \/\/ We allocate here because <init> is not inlined at parsing.\n+        \/\/ At late inline: The store of v.v is done with a StoreN into the allocation to make the effect visible.\n+        CircularValue7 v = new CircularValue7(i);\n+        return v.i;\n+    }\n+\n+    @Run(test = \"testCircularSafepointUse2\")\n+    public void testCircularSafepointUse2_verifier() {\n+        int rand = rI;\n+        Asserts.assertEQ(testCircularSafepointUse2(rand), new CircularValue7(rand).i);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"}]}