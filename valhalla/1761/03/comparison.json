{"files":[{"patch":"@@ -186,0 +186,12 @@\n+    \/**\n+     * <p>Support for a \"preview version\" of classfiles when running with preview\n+     * mode. This is modeled as a new version (@) and since preview mode is only\n+     * supported for the current version, a single identifier token is sufficient.\n+     *\n+     * <p>For example, inside ct.sym, 27 will be modeled as 'R', and the preview\n+     * for 27 will be '@'. Classfiles unchanged between 27 and 27-preview will\n+     * not be duplicated (in the same way classfiles that are common between 26\n+     * and 27 are shared).\n+     *\/\n+    private static final String PREVIEW_VERSION = \"@\";\n+\n@@ -215,0 +227,3 @@\n+        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath,\n+                includedModules, PREVIEW_VERSION, currentVersion);\n+\n@@ -221,0 +236,2 @@\n+        String currentVersionFin = currentVersion;\n+\n@@ -229,0 +246,3 @@\n+                                            if (PREVIEW_VERSION.equals(versionString)) {\n+                                                versionString = currentVersionFin;\n+                                            }\n@@ -817,0 +837,3 @@\n+            if (header.preview) {\n+                clb.withVersion(ClassFile.latestMajorVersion(), ClassFile.PREVIEW_MINOR_VERSION);\n+            }\n@@ -1319,0 +1342,1 @@\n+            record ExportedDir(Path modulePath, Path exportedDir) {}\n@@ -1320,1 +1344,1 @@\n-            List<Path> pendingExportedDirectories = new ArrayList<>();\n+            List<ExportedDir> pendingExportedDirectories = new ArrayList<>();\n@@ -1328,1 +1352,1 @@\n-                    Path moduleInfo = p.resolve(\"module-info.class\");\n+                    Path moduleInfo = resolvePossiblyPreviewClassFile(version, p, p.resolve(\"module-info.class\"));\n@@ -1347,1 +1371,1 @@\n-                            pendingExportedDirectories.add(p.resolve(dir));\n+                            pendingExportedDirectories.add(new ExportedDir(p, p.resolve(dir)));\n@@ -1359,2 +1383,2 @@\n-            for (Path exported : pendingExportedDirectories) {\n-                try (DirectoryStream<Path> ds = Files.newDirectoryStream(exported)) {\n+            for (ExportedDir exported : pendingExportedDirectories) {\n+                try (DirectoryStream<Path> ds = Files.newDirectoryStream(exported.exportedDir())) {\n@@ -1366,0 +1390,2 @@\n+                        p2 = resolvePossiblyPreviewClassFile(version, exported.modulePath(), p2);\n+\n@@ -1384,0 +1410,1 @@\n+                        currentPath = resolvePossiblyPreviewClassFile(version, e.getKey(), currentPath);\n@@ -1416,0 +1443,15 @@\n+    private Path resolvePossiblyPreviewClassFile(String version, Path moduleClassDir, Path classfile) {\n+        if (!PREVIEW_VERSION.equals(version)) {\n+            return classfile;\n+        }\n+\n+        Path relativePath = moduleClassDir.relativize(classfile);\n+        Path previewCandidate = moduleClassDir.resolve(\"META-INF\").resolve(\"preview\").resolve(relativePath);\n+\n+        if (Files.exists(previewCandidate)) {\n+            return previewCandidate;\n+        }\n+\n+        return classfile;\n+    }\n+\n@@ -1944,0 +1986,1 @@\n+        headerDesc.preview = cm.minorVersion() == ClassFile.PREVIEW_MINOR_VERSION;\n@@ -2010,0 +2053,1 @@\n+        headerDesc.preview = cm.minorVersion() == ClassFile.PREVIEW_MINOR_VERSION;\n@@ -2277,1 +2321,7 @@\n-            default -> throw new IllegalArgumentException(\"Unhandled attribute: \" + attr.attributeName()); \/\/ Do nothing\n+            default -> {\n+                if (attr.attributeName().equalsString(\"LoadableDescriptors\")) {\n+                    \/\/OK, do nothing\n+                } else {\n+                    throw new IllegalArgumentException(\"Unhandled attribute: \" + attr.attributeName());\n+                }\n+            }\n@@ -3322,0 +3372,1 @@\n+        boolean preview;\n@@ -3327,0 +3378,1 @@\n+            hash = 19 * hash + Objects.hashCode(this.preview);\n@@ -3342,0 +3394,3 @@\n+            if (this.preview != other.preview) {\n+                return false;\n+            }\n@@ -3380,0 +3435,16 @@\n+        @Override\n+        protected void writeAttributes(Appendable output) throws IOException {\n+            super.writeAttributes(output);\n+            if (preview) {\n+                output.append(\" preview true\");\n+            }\n+        }\n+\n+        @Override\n+        protected void readAttributes(LineBasedReader reader) {\n+            super.readAttributes(reader);\n+            String inPreview = reader.attributes.get(\"preview\");\n+            if (\"true\".equals(inPreview)) {\n+                preview = true;\n+            }\n+        }\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":77,"deletions":6,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2092,0 +2092,3 @@\n+\/\/ See also:\n+\/\/ * src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java\n+\/\/ * src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+    \/\/ See also:\n+    \/\/ * src\/hotspot\/share\/runtime\/arguments.cpp\n+    \/\/ * src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.Preview;\n@@ -200,0 +201,6 @@\n+            \/\/ pass preview mode to the file manager:\n+            if (fileManager.isSupportedOption(Option.PREVIEWMODE.primaryName) == 1) {\n+                Preview preview = Preview.instance(context);\n+                fileManager.handleOption(Option.PREVIEWMODE.primaryName, List.of(String.valueOf(preview.isEnabled())).iterator());\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTool.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.main.JavaCompiler;\n@@ -59,1 +60,0 @@\n-import com.sun.tools.javac.platform.PlatformDescription;\n@@ -67,2 +67,1 @@\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.CompletionFailure;\n+\n@@ -221,1 +220,8 @@\n-        jrtIndex = useCtProps && JRTIndex.isAvailable() ? JRTIndex.getSharedInstance() : null;\n+        if (useCtProps && JRTIndex.isAvailable()) {\n+            Preview preview = Preview.instance(context);\n+            JavaCompiler comp = JavaCompiler.instance(context);\n+            jrtIndex = JRTIndex.instance(preview.isEnabled());\n+            comp.closeables = comp.closeables.prepend(jrtIndex);\n+        } else {\n+            jrtIndex = null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+    protected boolean previewMode;\n@@ -295,0 +296,5 @@\n+            case PREVIEWMODE:\n+                previewMode = Boolean.parseBoolean(value);\n+                locations.setPreviewMode(previewMode);\n+                return true;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.Closeable;\n@@ -41,0 +42,1 @@\n+import java.util.HashSet;\n@@ -51,1 +53,1 @@\n-import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Assert;\n@@ -55,0 +57,5 @@\n+ *\n+ * <p>Instances of this class may share underlying file-system resources. This\n+ * is to avoid the need for singleton instances with unbounded lifetimes which\n+ * could never release and close the underlying JRT file-system, effectively\n+ * creating a resource leak.\n@@ -56,10 +63,22 @@\n-public class JRTIndex {\n-    \/** Get a shared instance of the cache. *\/\n-    private static JRTIndex sharedInstance;\n-    public static synchronized JRTIndex getSharedInstance() {\n-        if (sharedInstance == null) {\n-            try {\n-                sharedInstance = new JRTIndex();\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n+\/\/ Final to ensure equals\/hashCode are not overridden (instance sharing relies\n+\/\/ on default identity semantics).\n+public final class JRTIndex implements Closeable {\n+    \/**\n+     * Potentially shared access to underlying resources. Resources exist for\n+     * both preview and non-preview mode, and this field holds the version\n+     * corresponding to the preview mode flag with which it was created.\n+     *\/\n+    private final FileSystemResources sharedResources;\n+\n+    \/**\n+     * Create and initialize an index based on the preview mode flag.\n+     *\/\n+    private JRTIndex(boolean previewMode) throws IOException {\n+        this.sharedResources = FileSystemResources.claim(previewMode, this);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        \/\/ Release is atomic and succeeds at most once per index.\n+        if (!sharedResources.release(this)) {\n+            throw new IllegalStateException(\"JRTIndex is closed\");\n@@ -67,1 +86,0 @@\n-        return sharedInstance;\n@@ -70,2 +88,6 @@\n-    \/** Get a context-specific instance of a cache. *\/\n-    public static JRTIndex instance(Context context) {\n+    \/**\n+     * {@return a JRT index suitable for the given preview mode}\n+     *\n+     * <p>The returned instance must be closed by the caller.\n+     *\/\n+    public static JRTIndex instance(boolean previewMode) {\n@@ -73,6 +95,3 @@\n-            JRTIndex instance = context.get(JRTIndex.class);\n-            if (instance == null)\n-                context.put(JRTIndex.class, instance = new JRTIndex());\n-            return instance;\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+            return new JRTIndex(previewMode);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -82,0 +101,1 @@\n+    \/** {@return whether the JRT file-system is available to create an index} *\/\n@@ -91,1 +111,0 @@\n-\n@@ -93,1 +112,4 @@\n-     * The jrt: file system.\n+     * Underlying file system resources potentially shared between many indexes.\n+     *\n+     * <p>This class is thread-safe so JRT indexes can be created from arbitrary\n+     * threads.\n@@ -95,1 +117,4 @@\n-    private final FileSystem jrtfs;\n+    private static class FileSystemResources {\n+        \/\/ Holds the active non-preview (index 0) and preview (index 1) indexes.\n+        \/\/ Active instances can be reset multiple times.\n+        private static final FileSystemResources[] instances = new FileSystemResources[2];\n@@ -97,4 +122,159 @@\n-    \/**\n-     * A lazily evaluated set of entries about the contents of the jrt: file system.\n-     *\/\n-    private final Map<RelativeDirectory, SoftReference<Entry>> entries;\n+        \/** The jrt: file system. *\/\n+        private final FileSystem jrtfs;\n+\n+        \/** A lazily evaluated set of entries about the contents of the jrt: file system. *\/\n+        \/\/ Synchronized by this instance.\n+        private final Map<RelativeDirectory, SoftReference<Entry>> entries = new HashMap<>();\n+\n+        \/\/ The set of indexes which have claimed this resource. This assumes\n+        \/\/ that index instances have default identity semantics.\n+        \/\/ Synchronized by FileSystemResources.class, NOT instance.\n+        private final Set<JRTIndex> owners = new HashSet<>();\n+        private final boolean previewMode;\n+\n+        \/\/ Created on demand in getCtInfo(), synchronized by this instance.\n+        private ResourceBundle ctBundle = null;\n+\n+        \/\/ Monotonic, synchronized by this instance.\n+        private boolean isClosed = false;\n+\n+        private FileSystemResources(boolean previewMode) throws IOException {\n+            this.jrtfs = FileSystems.newFileSystem(URI.create(\"jrt:\/\"), Map.of(\"previewMode\", Boolean.toString(previewMode)));\n+            this.previewMode = previewMode;\n+        }\n+\n+        \/** Claims shared ownership of resources for in index. *\/\n+        static FileSystemResources claim(boolean previewMode, JRTIndex owner) throws IOException {\n+            int idx = previewMode ? 1 : 0;\n+            synchronized (FileSystemResources.class) {\n+                var active = instances[idx];\n+                if (active == null) {\n+                    active = new FileSystemResources(previewMode);\n+                    instances[idx] = active;\n+                }\n+                \/\/ Since claim is only called once per instance (during init)\n+                \/\/ seeing an index that's already claimed should be impossible.\n+                Assert.check(!active.owners.add(owner));\n+                return active;\n+            }\n+        }\n+\n+        \/**\n+         * Releases ownership of this resource for an index with an existing claim.\n+         *\n+         * @return whether the given index is being released for the first time\n+         *\/\n+        boolean release(JRTIndex owner) throws IOException {\n+            int idx = previewMode ? 1 : 0;\n+            boolean shouldClose;\n+            synchronized (FileSystemResources.class) {\n+                Assert.check(instances[idx] == this);\n+                \/\/ Not finding a claim means the index was already released\/closed.\n+                if (!owners.remove(owner)) {\n+                    return false;\n+                }\n+                shouldClose = owners.isEmpty();\n+                if (shouldClose) {\n+                    instances[idx] = null;\n+                }\n+            }\n+            if (shouldClose) {\n+                \/\/ This should be the only call to close() on the resource instance.\n+                close();\n+            }\n+            return true;\n+        }\n+\n+        \/** Close underlying shared resources once no users exist (called exactly once). *\/\n+        private synchronized void close() throws IOException {\n+            Assert.check(!isClosed);\n+            jrtfs.close();\n+            entries.clear();\n+            ctBundle = null;\n+            isClosed = true;\n+        }\n+\n+        synchronized Entry getEntry(RelativeDirectory rd) throws IOException {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"JRTIndex is closed\");\n+            }\n+            SoftReference<Entry> ref = entries.get(rd);\n+            Entry e = (ref == null) ? null : ref.get();\n+            if (e == null) {\n+                Map<String, Path> files = new LinkedHashMap<>();\n+                Set<RelativeDirectory> subdirs = new LinkedHashSet<>();\n+                Path dir;\n+                if (rd.path.isEmpty()) {\n+                    dir = jrtfs.getPath(\"\/modules\");\n+                } else {\n+                    Path pkgs = jrtfs.getPath(\"\/packages\");\n+                    dir = pkgs.resolve(rd.getPath().replaceAll(\"\/$\", \"\").replace(\"\/\", \".\"));\n+                }\n+                if (Files.exists(dir)) {\n+                    try (DirectoryStream<Path> modules = Files.newDirectoryStream(dir)) {\n+                        for (Path module: modules) {\n+                            if (Files.isSymbolicLink(module))\n+                                module = Files.readSymbolicLink(module);\n+                            Path p = rd.resolveAgainst(module);\n+                            if (!Files.exists(p))\n+                                continue;\n+                            try (DirectoryStream<Path> stream = Files.newDirectoryStream(p)) {\n+                                for (Path entry: stream) {\n+                                    String name = entry.getFileName().toString();\n+                                    if (Files.isRegularFile(entry)) {\n+                                        \/\/ TODO: consider issue of files with same name in different modules\n+                                        files.put(name, entry);\n+                                    } else if (Files.isDirectory(entry)) {\n+                                        subdirs.add(new RelativeDirectory(rd, name));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                e = new Entry(Collections.unmodifiableMap(files),\n+                        Collections.unmodifiableSet(subdirs),\n+                        getCtInfo(rd));\n+                entries.put(rd, new SoftReference<>(e));\n+            }\n+            return e;\n+        }\n+\n+        private CtSym getCtInfo(RelativeDirectory dir) {\n+            if (dir.path.isEmpty())\n+                return CtSym.EMPTY;\n+            \/\/ It's a side-effect of the default build rules that ct.properties\n+            \/\/ ends up as a resource bundle.\n+            if (ctBundle == null) {\n+                final String bundleName = \"com.sun.tools.javac.resources.ct\";\n+                ctBundle = ResourceBundle.getBundle(bundleName);\n+            }\n+            try {\n+                String attrs = ctBundle.getString(dir.path.replace('\/', '.') + '*');\n+                boolean hidden = false;\n+                boolean proprietary = false;\n+                String minProfile = null;\n+                for (String attr: attrs.split(\" +\", 0)) {\n+                    switch (attr) {\n+                        case \"hidden\":\n+                            hidden = true;\n+                            break;\n+                        case \"proprietary\":\n+                            proprietary = true;\n+                            break;\n+                        default:\n+                            minProfile = attr;\n+                    }\n+                }\n+                return new CtSym(hidden, proprietary, minProfile);\n+            } catch (MissingResourceException e) {\n+                return CtSym.EMPTY;\n+            }\n+\n+        }\n+\n+        boolean isJrtPath(Path p) {\n+            \/\/ This still succeeds after the jrtfs is closed.\n+            return (p.getFileSystem() == jrtfs);\n+        }\n+    }\n@@ -105,1 +285,1 @@\n-    class Entry {\n+    static class Entry {\n@@ -177,1 +357,4 @@\n-     * Create and initialize the index.\n+     * Returns a non-owned reference to the file system underlying this index.\n+     *\n+     * <p>When this index is closed its file system, and any {@link Path paths}\n+     * derived from it, will become unusable.\n@@ -179,3 +362,2 @@\n-    private JRTIndex() throws IOException {\n-        jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-        entries = new HashMap<>();\n+    public FileSystem getFileSystem() {\n+        return sharedResources.jrtfs;\n@@ -184,0 +366,5 @@\n+    \/**\n+     * Returns symbol information (possibly cached) for a given package.\n+     *\n+     * <p>This remains usable after the index is closed.\n+     *\/\n@@ -188,41 +375,9 @@\n-    synchronized Entry getEntry(RelativeDirectory rd) throws IOException {\n-        SoftReference<Entry> ref = entries.get(rd);\n-        Entry e = (ref == null) ? null : ref.get();\n-        if (e == null) {\n-            Map<String, Path> files = new LinkedHashMap<>();\n-            Set<RelativeDirectory> subdirs = new LinkedHashSet<>();\n-            Path dir;\n-            if (rd.path.isEmpty()) {\n-                dir = jrtfs.getPath(\"\/modules\");\n-            } else {\n-                Path pkgs = jrtfs.getPath(\"\/packages\");\n-                dir = pkgs.resolve(rd.getPath().replaceAll(\"\/$\", \"\").replace(\"\/\", \".\"));\n-            }\n-            if (Files.exists(dir)) {\n-                try (DirectoryStream<Path> modules = Files.newDirectoryStream(dir)) {\n-                    for (Path module: modules) {\n-                        if (Files.isSymbolicLink(module))\n-                            module = Files.readSymbolicLink(module);\n-                        Path p = rd.resolveAgainst(module);\n-                        if (!Files.exists(p))\n-                            continue;\n-                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(p)) {\n-                            for (Path entry: stream) {\n-                                String name = entry.getFileName().toString();\n-                                if (Files.isRegularFile(entry)) {\n-                                    \/\/ TODO: consider issue of files with same name in different modules\n-                                    files.put(name, entry);\n-                                } else if (Files.isDirectory(entry)) {\n-                                    subdirs.add(new RelativeDirectory(rd, name));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            e = new Entry(Collections.unmodifiableMap(files),\n-                    Collections.unmodifiableSet(subdirs),\n-                    getCtInfo(rd));\n-            entries.put(rd, new SoftReference<>(e));\n-        }\n-        return e;\n+    \/**\n+     * Returns package information (possibly cached) for the given directory.\n+     *\n+     * <p>When this index is closed its file system, and any {@link Path paths}\n+     * derived from it, will become unusable. This includes paths inside this\n+     * entry.\n+     *\/\n+    Entry getEntry(RelativeDirectory rd) throws IOException {\n+        return sharedResources.getEntry(rd);\n@@ -231,0 +386,11 @@\n+    \/**\n+     * {@returns whether the given {@link FileObject file} belongs to this index}\n+     *\n+     * <p>A file \"belongs\" to an index if it was found in that index by {@code\n+     * ClassFinder}. Since indexes can differ with respect to preview mode, it\n+     * is important that the {@code ClassFinder} and {@link JavacFileManager}\n+     * agree on the preview mode setting being used during compilation.\n+     *\n+     * <p>This test will continue to succeed after the index is closed, but the\n+     * file object will no longer be usable.\n+     *\/\n@@ -232,0 +398,3 @@\n+        \/\/ It is not sufficient to test if the file's path is *any* JRT path,\n+        \/\/ it must exist in the file-system instance of this index (which should\n+        \/\/ be the same index used by ClassFinder to obtain file objects).\n@@ -233,2 +402,1 @@\n-            Path path = pathFileObject.getPath();\n-            return (path.getFileSystem() == jrtfs);\n+            return sharedResources.isJrtPath(pathFileObject.getPath());\n@@ -239,35 +407,0 @@\n-\n-    private CtSym getCtInfo(RelativeDirectory dir) {\n-        if (dir.path.isEmpty())\n-            return CtSym.EMPTY;\n-        \/\/ It's a side-effect of the default build rules that ct.properties\n-        \/\/ ends up as a resource bundle.\n-        if (ctBundle == null) {\n-            final String bundleName = \"com.sun.tools.javac.resources.ct\";\n-            ctBundle = ResourceBundle.getBundle(bundleName);\n-        }\n-        try {\n-            String attrs = ctBundle.getString(dir.path.replace('\/', '.') + '*');\n-            boolean hidden = false;\n-            boolean proprietary = false;\n-            String minProfile = null;\n-            for (String attr: attrs.split(\" +\", 0)) {\n-                switch (attr) {\n-                    case \"hidden\":\n-                        hidden = true;\n-                        break;\n-                    case \"proprietary\":\n-                        proprietary = true;\n-                        break;\n-                    default:\n-                        minProfile = attr;\n-                }\n-            }\n-            return new CtSym(hidden, proprietary, minProfile);\n-        } catch (MissingResourceException e) {\n-            return CtSym.EMPTY;\n-        }\n-\n-    }\n-\n-    private ResourceBundle ctBundle;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JRTIndex.java","additions":244,"deletions":111,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -391,0 +391,9 @@\n+        \/\/ Monotonic, created on demand.\n+        private JRTIndex jrtIndex = null;\n+\n+        private synchronized JRTIndex getJRTIndex() {\n+            if (jrtIndex == null) {\n+                jrtIndex = JRTIndex.instance(previewMode);\n+            }\n+            return jrtIndex;\n+        }\n@@ -440,0 +449,3 @@\n+            if (jrtIndex != null) {\n+                jrtIndex.close();\n+            }\n@@ -453,8 +465,0 @@\n-    private synchronized JRTIndex getJRTIndex() {\n-        if (jrtIndex == null)\n-            jrtIndex = JRTIndex.getSharedInstance();\n-        return jrtIndex;\n-    }\n-\n-    private JRTIndex jrtIndex;\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -133,1 +133,2 @@\n-    List<Closeable> closeables = new ArrayList<>();\n+    \/\/ List of resources to be closed (self-sychronized).\n+    private final List<Closeable> closeables = new ArrayList<>();\n@@ -135,0 +136,1 @@\n+    private boolean previewMode = false;\n@@ -148,0 +150,6 @@\n+    private void addCloseable(Closeable c) {\n+        synchronized (closeables) {\n+            closeables.add(c);\n+        }\n+    }\n+\n@@ -150,1 +158,6 @@\n-        closeables.forEach(closeable -> {\n+        Closeable[] arr;\n+        synchronized (closeables) {\n+            arr = closeables.toArray(Closeable[]::new);\n+            closeables.clear();\n+        }\n+        for (Closeable closeable : arr) {\n@@ -156,1 +169,1 @@\n-        });\n+        }\n@@ -229,0 +242,5 @@\n+    public void setPreviewMode(boolean previewMode) {\n+        \/\/ Null is implicitly allowed and unsets the value.\n+        this.previewMode = previewMode;\n+    }\n+\n@@ -1462,1 +1480,1 @@\n-                                closeables.add(fs);\n+                                addCloseable(fs);\n@@ -1953,1 +1971,3 @@\n-                        jrtfs = FileSystems.getFileSystem(jrtURI);\n+                        JRTIndex jrtIndex = JRTIndex.instance(previewMode);\n+                        addCloseable(jrtIndex);\n+                        jrtfs = jrtIndex.getFileSystem();\n@@ -1957,1 +1977,2 @@\n-                                    Collections.singletonMap(\"java.home\", systemJavaHome.toString());\n+                                    Map.of(\"java.home\", systemJavaHome.toString(),\n+                                            \"previewMode\", String.valueOf(previewMode));\n@@ -1967,1 +1988,1 @@\n-                            closeables.add(fsLoader);\n+                            addCloseable(fsLoader);\n@@ -1970,1 +1991,1 @@\n-                        closeables.add(jrtfs);\n+                        addCloseable(jrtfs);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1560,1 +1560,7 @@\n-            } else if (proxy.type.tsym.flatName() == syms.migratedValueClassInternalType.tsym.flatName()) {\n+            } else if (!DISABLE_PREVIEW_PATCHING\n+                    && proxy.type.tsym.flatName() == syms.migratedValueClassInternalType.tsym.flatName()) {\n+                \/\/ This is a temporary workaround until preview patching is removed and preview\n+                \/\/ versions of classes are loaded directly from the JRT file system.\n+                \/\/ Migrated value classes are marked with @jdk.internal.MigratedValueClass (or a\n+                \/\/ corresponding javac-internal annotation). This code marks such classes as\n+                \/\/ value-based, even if the original classfile is not the preview classfile.\n@@ -1586,1 +1592,2 @@\n-                }  else if (proxy.type.tsym == syms.migratedValueClassType.tsym && sym.kind == TYP) {\n+                }  else if (!DISABLE_PREVIEW_PATCHING\n+                        && proxy.type.tsym == syms.migratedValueClassType.tsym && sym.kind == TYP) {\n@@ -3594,0 +3601,12 @@\n+\n+    \/\/ Temporary system property to disable preview patching and enable the new preview mode\n+    \/\/ feature for testing\/development. Once the preview mode feature is finished, the value\n+    \/\/ will be always 'true' and this code, and all related dead-code can be removed.\n+    \/\/ See also:\n+    \/\/ * src\/hotspot\/share\/runtime\/arguments.cpp\n+    \/\/ * src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java\n+    private static final boolean DISABLE_PREVIEW_PATCHING_DEFAULT = false;\n+    private static final boolean DISABLE_PREVIEW_PATCHING = Boolean.parseBoolean(\n+            System.getProperty(\n+                    \"DISABLE_PREVIEW_PATCHING\",\n+                    Boolean.toString(DISABLE_PREVIEW_PATCHING_DEFAULT)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import com.sun.tools.javac.platform.JDKPlatformProvider;\n@@ -320,0 +321,4 @@\n+            String platformAndOptions = platformString;\n+            if (options.isSet(Option.PREVIEW)) {\n+                platformAndOptions += \":\" + JDKPlatformProvider.PREVIEW_OPTION;\n+            }\n@@ -321,1 +326,1 @@\n-                    PlatformUtils.lookupPlatformDescription(platformString);\n+                    PlatformUtils.lookupPlatformDescription(platformAndOptions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import com.sun.tools.javac.code.Preview;\n@@ -303,0 +304,6 @@\n+        \/\/ pass preview mode to the file manager:\n+        if (fileManager.isSupportedOption(Option.PREVIEWMODE.primaryName) == 1) {\n+            Preview preview = Preview.instance(context);\n+            fileManager.handleOption(Option.PREVIEWMODE.primaryName, List.of(String.valueOf(preview.isEnabled())).iterator());\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Main.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -819,0 +819,1 @@\n+    PREVIEWMODE(\"--preview-mode\", \"opt.arg.preview-mode\", \"opt.preview-mode\", HIDDEN, FILEMANAGER),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import com.sun.tools.javac.util.Assert;\n@@ -79,0 +78,3 @@\n+    public static final String PREVIEW_OPTION = \"preview\";\n+    private static final String CT_SYM_PREVIEW_VERSION = \"@\";\n+\n@@ -89,1 +91,4 @@\n-        return getPlatformTrusted(platformName);\n+        if (PREVIEW_OPTION.equals(options) && !Source.DEFAULT.name.equals(platformName)) {\n+            throw new PlatformNotSupported();\n+        }\n+        return getPlatformTrusted(platformName, options);\n@@ -92,2 +97,11 @@\n-    public PlatformDescription getPlatformTrusted(String platformName) {\n-        return new PlatformDescriptionImpl(platformName);\n+    public PlatformDescription getPlatformTrusted(String platformName, String options) {\n+        String ctSymVersion;\n+\n+        if (PREVIEW_OPTION.equals(options)) {\n+            ctSymVersion = CT_SYM_PREVIEW_VERSION;\n+        } else {\n+            ctSymVersion =\n+                    StringUtils.toUpperCase(Integer.toString(Integer.parseInt(platformName), Character.MAX_RADIX));\n+        }\n+\n+        return new PlatformDescriptionImpl(platformName, ctSymVersion);\n@@ -135,0 +149,5 @@\n+\n+                        if (CT_SYM_PREVIEW_VERSION.equals(verString)) {\n+                            continue; \/\/ignore - preview is just an option\n+                        }\n+\n@@ -157,1 +176,1 @@\n-        PlatformDescriptionImpl(String sourceVersion) {\n+        PlatformDescriptionImpl(String sourceVersion, String ctSymVersion) {\n@@ -159,2 +178,1 @@\n-            this.ctSymVersion =\n-                    StringUtils.toUpperCase(Integer.toString(Integer.parseInt(sourceVersion), Character.MAX_RADIX));\n+            this.ctSymVersion = ctSymVersion;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+javac.opt.preview-mode=\\\n+    Specify whether preview mode should be enabled\n@@ -147,0 +149,2 @@\n+javac.opt.arg.preview-mode=\\\n+    true\/false\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-            JavaFileManager fm = pp.getPlatformTrusted(release).getFileManager();\n+            JavaFileManager fm = pp.getPlatformTrusted(release, \"\").getFileManager();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify javac handles preview files in JRT FS reasonably.\n+ * @library \/tools\/lib\n+ * @modules\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.platform\n+ *          jdk.compiler\/com.sun.tools.javac.util:+open\n+ * @run junit\/othervm -DDISABLE_PREVIEW_PATCHING=false PreviewJRTImage\n+ * @run junit\/othervm -DDISABLE_PREVIEW_PATCHING=false --enable-preview PreviewJRTImage\n+ * @run junit\/othervm -DDISABLE_PREVIEW_PATCHING=true PreviewJRTImage\n+ * @run junit\/othervm -DDISABLE_PREVIEW_PATCHING=true --enable-preview PreviewJRTImage\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Expect;\n+import toolbox.Task.Mode;\n+import toolbox.ToolBox;\n+\n+import static org.junit.Assert.*;\n+\n+public class PreviewJRTImage {\n+\n+    private final ToolBox tb = new ToolBox();\n+    private final String specificationVersion = System.getProperty(\"java.specification.version\");\n+\n+    @Test\n+    public void testVersionInDependency() throws Exception {\n+        Path root = Paths.get(\".\");\n+        Path src = root.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                import sun.misc.Unsafe;\n+                public class Test {\n+                    void test() {\n+                        Boolean b = true;\n+                        synchronized (b) {\n+                        }\n+                        Unsafe u;\n+                    }\n+                }\n+                \"\"\");\n+\n+        Path classes = root.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        List<String> log;\n+        List<String> expected;\n+\n+        for (String option : new String[]{\"--source\", \"--release\"}) {\n+            for (Mode mode : new Mode[]{Mode.API, Mode.CMDLINE}) {\n+                \/\/ Without preview:\n+                log = new JavacTask(tb, mode)\n+                        .outdir(classes)\n+                        .options(option, specificationVersion, \"-XDrawDiagnostics\")\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+                expected = List.of(\n+                        \"Test.java:1:16: compiler.warn.sun.proprietary: sun.misc.Unsafe\",\n+                        \"Test.java:7:9: compiler.warn.sun.proprietary: sun.misc.Unsafe\",\n+                        \"Test.java:5:9: compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\",\n+                        \"3 warnings\"\n+                );\n+\n+                assertEquals(expected, log);\n+\n+                \/\/ With preview:\n+                log = new JavacTask(tb, mode)\n+                        .outdir(classes)\n+                        .options(option, specificationVersion, \"--enable-preview\", \"-XDrawDiagnostics\")\n+                        .files(tb.findJavaFiles(src))\n+                        .run(Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+                expected = List.of(\n+                        \"Test.java:1:16: compiler.warn.sun.proprietary: sun.misc.Unsafe\",\n+                        \"Test.java:5:9: compiler.err.type.found.req: java.lang.Boolean, (compiler.misc.type.req.identity)\",\n+                        \"Test.java:7:9: compiler.warn.sun.proprietary: sun.misc.Unsafe\",\n+                        \"1 error\",\n+                        \"2 warnings\"\n+                );\n+\n+                assertEquals(expected, log);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewJRTImage.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}