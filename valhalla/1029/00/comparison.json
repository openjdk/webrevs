{"files":[{"patch":"@@ -255,1 +255,0 @@\n-         stub_id == Runtime1::new_instance_no_inline_id       ||\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = state_for(x, x->needs_state_before() ? x->state_before() : x->state());\n@@ -1329,16 +1329,0 @@\n-               LIR_OprFact::illegalOpr,\n-               FrameMap::rdx_metadata_opr, info);\n-  LIR_Opr result = rlock_result(x);\n-  __ move(reg, result);\n-}\n-\n-void LIRGenerator::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n-  \/\/ Mapping to do_NewInstance (same code) but use state_before for reexecution.\n-  CodeEmitInfo* info = state_for(x, x->state_before());\n-  x->set_to_object_type();\n-  LIR_Opr reg = result_register_for(x->type());\n-  new_instance(reg, x->klass(), false,\n-               \/* allow_inline *\/ true,\n-               FrameMap::rcx_oop_opr,\n-               FrameMap::rdi_oop_opr,\n-               FrameMap::rsi_oop_opr,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1022,1 +1022,0 @@\n-    case new_instance_no_inline_id:\n@@ -1031,2 +1030,0 @@\n-        } else if (id == new_instance_no_inline_id) {\n-          __ set_info(\"new_instance_no_inline\", dont_gc_arguments);\n@@ -1043,5 +1040,1 @@\n-        if (id == new_instance_no_inline_id) {\n-          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance_no_inline), klass);\n-        } else {\n-          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n-        }\n+        call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-  if (x->obj()->as_NewArray() != nullptr || x->obj()->as_NewInstance() != nullptr || x->obj()->as_NewInlineTypeInstance()) {\n+  if (x->obj()->as_NewArray() != nullptr || x->obj()->as_NewInstance() != nullptr) {\n@@ -662,1 +662,0 @@\n-void Canonicalizer::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {}\n@@ -695,1 +694,1 @@\n-    if (exact != nullptr && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray() || obj->as_NewInlineTypeInstance())) {\n+    if (exact != nullptr && exact->is_loaded() && (obj->as_NewInstance() || obj->as_NewArray())) {\n@@ -818,1 +817,1 @@\n-           (l->as_NewInstance() || l->as_NewArray() || l->as_NewInlineTypeInstance() ||\n+           (l->as_NewInstance() || l->as_NewArray() ||\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -258,0 +258,3 @@\n+    if (PrintCFGToFile) {  \/\/ borrowing flag for JDK build\n+      tty->print_cr(\"Starting C1 compilation of %s.%s\", method->holder()->name()->as_utf8(), method->name()->as_utf8());\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -730,11 +730,0 @@\n-  \/\/ Record this newly allocated object\n-  void new_instance(NewInlineTypeInstance* object) {\n-    int index = _newobjects.length();\n-    _newobjects.append(object);\n-    if (_fields.at_grow(index, nullptr) == nullptr) {\n-      _fields.at_put(index, new FieldBuffer());\n-    } else {\n-      _fields.at(index)->kill();\n-    }\n-  }\n-\n@@ -1132,1 +1121,1 @@\n-        NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before);\n+        NewInstance* new_instance = new NewInstance(elem_klass, state_before, true, true);\n@@ -1240,6 +1229,0 @@\n-        \/\/ special handling for the dup_x2\/pop sequence (see JDK-8251046)\n-        if (w1 != nullptr && w1->as_NewInlineTypeInstance() != nullptr) {\n-          ciBytecodeStream s(method());\n-          s.force_bci(bci());\n-          s.next();\n-        }\n@@ -2058,1 +2041,1 @@\n-              NewInlineTypeInstance* vt = new NewInlineTypeInstance(inline_klass, pending_load_indexed()->state_before());\n+              NewInstance* vt = new NewInstance(inline_klass, pending_load_indexed()->state_before(), true, true);\n@@ -2066,1 +2049,1 @@\n-              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before);\n+              NewInstance* new_instance = new NewInstance(inline_klass, state_before, true, true);\n@@ -2498,1 +2481,1 @@\n-  NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass());\n+  NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass(), false);\n@@ -2736,1 +2719,1 @@\n-  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr || value->as_NewInlineTypeInstance() != nullptr) {\n+  if (value->as_NewArray() != nullptr || value->as_NewInstance() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -309,8 +309,0 @@\n-ciType* NewInlineTypeInstance::exact_type() const {\n-  return klass();\n-}\n-\n-ciType* NewInlineTypeInstance::declared_type() const {\n-  return exact_type();\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-class     NewInlineTypeInstance;\n@@ -175,1 +174,0 @@\n-  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x) = 0;\n@@ -572,1 +570,0 @@\n-  virtual NewInlineTypeInstance* as_NewInlineTypeInstance() { return nullptr; }\n@@ -985,1 +982,1 @@\n-  NewInlineTypeInstance* _vt;\n+  NewInstance* _vt;\n@@ -1004,2 +1001,2 @@\n-  NewInlineTypeInstance* vt() const { return _vt; }\n-  void set_vt(NewInlineTypeInstance* vt) { _vt = vt; }\n+  NewInstance* vt() const { return _vt; }\n+  void set_vt(NewInstance* vt) { _vt = vt; }\n@@ -1345,0 +1342,1 @@\n+  bool _needs_state_before;\n@@ -1348,1 +1346,1 @@\n-  NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)\n+  NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved, bool needs_state_before)\n@@ -1350,1 +1348,1 @@\n-  , _klass(klass), _is_unresolved(is_unresolved)\n+  , _klass(klass), _is_unresolved(is_unresolved), _needs_state_before(needs_state_before)\n@@ -1356,0 +1354,1 @@\n+  bool needs_state_before() const                { return _needs_state_before; }\n@@ -1365,26 +1364,0 @@\n-LEAF(NewInlineTypeInstance, StateSplit)\n-  ciInlineKlass* _klass;\n-\n-public:\n-\n-  \/\/ Default creation, always allocated for now\n-  NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before)\n-  : StateSplit(instanceType, state_before)\n-   , _klass(klass)\n-  {\n-    set_null_free(true);\n-  }\n-\n-  \/\/ accessors\n-  ciInlineKlass* klass() const { return _klass; }\n-  virtual bool needs_exception_state() const     { return false; }\n-\n-  \/\/ generic\n-  virtual bool can_trap() const                  { return true; }\n-  ciType* exact_type() const;\n-  ciType* declared_type() const;\n-\n-  \/\/ Only done in LIR Generator -> map everything to object\n-  void set_to_object_type() { set_type(instanceType); }\n-};\n-\n@@ -2093,2 +2066,3 @@\n-      assert(x->as_NewInlineTypeInstance() == nullptr || y->type() == objectNull, \"Sanity check\");\n-      assert(y->as_NewInlineTypeInstance() == nullptr || x->type() == objectNull, \"Sanity check\");\n+      \/\/ FIXME: Removal of NewInlineTypeInstance instruction makes those assert hard to write\n+      \/\/ assert(x->as_NewInlineTypeInstance() == nullptr || y->type() == objectNull, \"Sanity check\");\n+      \/\/ assert(y->as_NewInlineTypeInstance() == nullptr || x->type() == objectNull, \"Sanity check\");\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":10,"deletions":36,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -504,5 +504,0 @@\n-void InstructionPrinter::do_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n-  output()->print(\"new inline type instance \");\n-  print_klass(x->klass());\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -662,0 +662,1 @@\n+    assert(!klass->is_inlinetype() || !klass->as_inline_klass()->is_empty(), \"Sanity check\");\n@@ -668,1 +669,1 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, allow_inline ? Runtime1::new_instance_id : Runtime1::new_instance_no_inline_id);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -582,1 +582,0 @@\n-  virtual void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -568,1 +568,0 @@\n-  void do_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -716,1 +715,0 @@\n-  void handle_NewInlineTypeInstance(NewInlineTypeInstance* x);\n@@ -756,1 +754,0 @@\n-void NullCheckVisitor::do_NewInlineTypeInstance(NewInlineTypeInstance* x) { nce()->handle_NewInlineTypeInstance(x); }\n@@ -1108,7 +1105,0 @@\n-void NullCheckEliminator::handle_NewInlineTypeInstance(NewInlineTypeInstance* x) {\n-  set_put(x);\n-  if (PrintNullCheckElimination) {\n-    tty->print_cr(\"NewInlineTypeInstance %d is non-null\", x->id());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -142,1 +142,0 @@\n-    void do_NewInlineTypeInstance(NewInlineTypeInstance* x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -372,2 +372,9 @@\n-  \/\/ allocate instance and return via TLS\n-  oop obj = h->allocate_instance(CHECK);\n+  oop obj = nullptr;\n+  if(h->is_empty_inline_type()) {\n+    assert(h->is_inline_klass(), \"Sanity check\");\n+    assert(InlineKlass::cast(h)->default_value() != nullptr, \"\");\n+    obj = InlineKlass::cast(h)->default_value();\n+  } else {\n+    \/\/ allocate instance and return via TLS\n+    obj = h->allocate_instance(CHECK);\n+  }\n@@ -381,9 +388,0 @@\n-\/\/ Same as new_instance but throws error for inline klasses\n-JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* current, Klass* klass))\n-  if (klass->is_inline_klass()) {\n-    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_InstantiationError());\n-  } else {\n-    allocate_instance(current, klass, CHECK);\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  stub(new_instance_no_inline)       \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  void do_NewInlineTypeInstance(NewInlineTypeInstance* x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-    return !get_instanceKlass()->access_flags().is_identity_class();\n+    return !get_instanceKlass()->access_flags().is_identity_class() || is_java_lang_Object() ;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}