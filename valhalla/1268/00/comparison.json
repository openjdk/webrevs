{"files":[{"patch":"@@ -79,2 +79,0 @@\n-    \/\/ float16ToShortBits that normalizes NaNs, c.f. floatToIntBits vs floatToRawIntBits\n-    \/\/ copysign\n@@ -82,1 +80,0 @@\n-    \/\/ signum\n@@ -580,1 +577,2 @@\n-     * according to the IEEE 754 floating-point binary16 bit layout.\n+     * according to the IEEE 754 floating-point binary16 bit layout,\n+     * preserving Not-a-Number (NaN) values.\n@@ -592,0 +590,17 @@\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   fp16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToIntBits(float)\n+     * @see Double#doubleToLongBits(double)\n+     *\/\n+    public static short float16ToShortBits(Float16 fp16) {\n+        if (!isNaN(fp16)) {\n+            return float16ToRawShortBits(fp16);\n+        }\n+        return 0x7e00;\n+    }\n+\n@@ -1316,0 +1331,44 @@\n+    \/**\n+     * Returns the first floating-point argument with the sign of the\n+     * second floating-point argument.\n+     * This method does not require NaN {@code sign}\n+     * arguments to be treated as positive values; implementations are\n+     * permitted to treat some NaN arguments as positive and other NaN\n+     * arguments as negative to allow greater performance.\n+     *\n+     * @apiNote\n+     * This method corresponds to the copySign operation defined in\n+     * IEEE 754.\n+     *\n+     * @param magnitude  the parameter providing the magnitude of the result\n+     * @param sign   the parameter providing the sign of the result\n+     * @return a value with the magnitude of {@code magnitude}\n+     * and the sign of {@code sign}.\n+     *\/\n+    public static Float16 copySign(Float16 magnitude, Float16 sign) {\n+        return shortBitsToFloat16((short) ((float16ToRawShortBits(sign) &\n+                        (Float16Consts.SIGN_BIT_MASK)) |\n+                        (float16ToRawShortBits(magnitude) &\n+                                (Float16Consts.EXP_BIT_MASK |\n+                                        Float16Consts.SIGNIF_BIT_MASK))));\n+    }\n+\n+    \/**\n+     * Returns the signum function of the argument; zero if the argument\n+     * is zero, 1.0 if the argument is greater than zero, -1.0 if the\n+     * argument is less than zero.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive zero or negative zero, then the\n+     *      result is the same as the argument.\n+     * <\/ul>\n+     *\n+     * @param f the floating-point value whose signum is to be returned\n+     * @return the signum function of the argument\n+     *\/\n+    public static Float16 signum(Float16 f) {\n+        return (f.floatValue() == 0.0f || isNaN(f)) ? f : copySign(valueOf(1), f);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -874,0 +874,63 @@\n+    public static int testFloat16CopySign() {\n+        int failures = 0;\n+\n+        \/\/ testCases[0] are logically positive numbers;\n+        \/\/ testCases[1] are negative numbers.\n+        float testCases [][] = {\n+                {+0.0f,\n+                        Float16.MIN_VALUE.floatValue(),\n+                        Float16_MAX_SUBNORMALmm.floatValue(),\n+                        Float16_MAX_SUBNORMAL.floatValue(),\n+                        Float16.MIN_NORMAL.floatValue(),\n+                        1.0f,\n+                        3.0f,\n+                        Float16_MAX_VALUEmm.floatValue(),\n+                        Float16.MAX_VALUE.floatValue(),\n+                        infinityF16.floatValue(),\n+                },\n+                {-infinityF16.floatValue(),\n+                        -Float16.MAX_VALUE.floatValue(),\n+                        -3.0f,\n+                        -1.0f,\n+                        -Float16.MIN_NORMAL.floatValue(),\n+                        -Float16_MAX_SUBNORMALmm.floatValue(),\n+                        -Float16_MAX_SUBNORMAL.floatValue(),\n+                        -Float16.MIN_VALUE.floatValue(),\n+                        -0.0f}\n+        };\n+\n+        float NaNs[] = {Float16.shortBitsToFloat16((short) 0x7e00).floatValue(),       \/\/ \"positive\" NaN\n+                Float16.shortBitsToFloat16((short) 0xfe00).floatValue()};      \/\/ \"negative\" NaN\n+\n+        \/\/ Tests shared between raw and non-raw versions\n+        for(int i = 0; i < 2; i++) {\n+            for(int j = 0; j < 2; j++) {\n+                for(int m = 0; m < testCases[i].length; m++) {\n+                    for(int n = 0; n < testCases[j].length; n++) {\n+                        \/\/ copySign(magnitude, sign)\n+                        failures+=Tests.test(\"Float16.copySign(Float16,Float16)\",\n+                                Float16.valueOf(testCases[i][m]),Float16.valueOf(testCases[j][n]),\n+                                Float16.copySign(Float16.valueOf(testCases[i][m]), Float16.valueOf(testCases[j][n])),\n+                                Float16.valueOf((j==0?1.0f:-1.0f)*Math.abs(testCases[i][m])) );\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ For rawCopySign, NaN may effectively have either sign bit\n+        \/\/ while for copySign NaNs are treated as if they always have\n+        \/\/ a zero sign bit (i.e. as positive numbers)\n+        for(int i = 0; i < 2; i++) {\n+            for(int j = 0; j < NaNs.length; j++) {\n+                for(int m = 0; m < testCases[i].length; m++) {\n+                    \/\/ copySign(magnitude, sign)\n+\n+                    failures += (Float16.abs(Float16.copySign(Float16.valueOf(testCases[i][m]), Float16.valueOf(NaNs[j]))).floatValue() ==\n+                            Float16.abs(Float16.valueOf(testCases[i][m])).floatValue()) ? 0:1;\n+                }\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -1895,0 +1958,32 @@\n+    public static int testFloat16Signum() {\n+        int failures = 0;\n+        float testCases [][] = {\n+                {NaNf16.floatValue(),                      NaNf16.floatValue()},\n+                {-infinityF16.floatValue(),                -1.0f},\n+                {-Float16.MAX_VALUE.floatValue(),          -1.0f},\n+                {-Float16.MIN_NORMAL.floatValue(),         -1.0f},\n+                {-1.0f,                                    -1.0f},\n+                {-2.0f,                                    -1.0f},\n+                {-Float16_MAX_SUBNORMAL.floatValue(),      -1.0f},\n+                {-Float16.MIN_VALUE.floatValue(),          -1.0f},\n+                {-0.0f,                                    -0.0f},\n+                {+0.0f,                                    +0.0f},\n+                {Float16.MIN_VALUE.floatValue(),            1.0f},\n+                {Float16_MAX_SUBNORMALmm.floatValue(),      1.0f},\n+                {Float16_MAX_SUBNORMAL.floatValue(),        1.0f},\n+                {Float16.MIN_NORMAL.floatValue(),           1.0f},\n+                {1.0f,                                      1.0f},\n+                {2.0f,                                      1.0f},\n+                {Float16_MAX_VALUEmm.floatValue(),          1.0f},\n+                {Float16.MAX_VALUE.floatValue(),            1.0f},\n+                {infinityF16.floatValue(),                  1.0f}\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures+=Tests.test(\"Float16.signum(Float16)\",\n+                    Float16.valueOf(testCases[i][0]), Float16.signum(Float16.valueOf(testCases[i][0])), Float16.valueOf(testCases[i][1]));\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -1984,0 +2079,1 @@\n+        failures += testFloat16CopySign();\n@@ -1994,0 +2090,1 @@\n+        failures += testFloat16Signum();\n","filename":"test\/jdk\/java\/lang\/Math\/IeeeRecommendedTests.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -497,0 +497,15 @@\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public static int test(String testName,\n+            Float16 input1, Float16 input2,\n+            Float16 result, Float16 expected) {\n+        if (Float16.compare(expected, result ) != 0) {\n+            System.err.println(\"Failure for \"  + testName + \":\\n\" +\n+                    \"\\tFor inputs \" + input1   + \"\\t(\" + toHexString(input1) + \") and \"\n+                    + input2   + \"\\t(\" + toHexString(input2) + \")\\n\" +\n+                    \"\\texpected  \"  + expected + \"\\t(\" + toHexString(expected) + \")\\n\" +\n+                    \"\\tgot       \"  + result   + \"\\t(\" + toHexString(result) + \").\");\n","filename":"test\/jdk\/java\/lang\/Math\/Tests.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}