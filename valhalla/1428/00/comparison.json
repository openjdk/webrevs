{"files":[{"patch":"@@ -1146,1 +1146,1 @@\n-               \/* allow_inline *\/ false,\n+               !x->is_unresolved() && x->klass()->is_inlinetype(),\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,0 @@\n-\n@@ -157,1 +156,1 @@\n-                       RegSet::of($tmp1$$Register, $tmp4$$Register) \/* preserve *\/);\n+                       RegSet::of($src$$Register, $tmp4$$Register) \/* preserve *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-    __ movq($mem$$Address, $src$$Register);\n+    __ movq(Address($tmp1$$Register, 0), $src$$Register);\n@@ -167,0 +167,2 @@\n+    \/\/ Adjust address again to point to the first narrow oop in the long value\n+    __ subq($tmp1$$Register, 4);\n@@ -168,1 +170,1 @@\n-    __ movq($mem$$Address, $src$$Register);\n+    __ movq(Address($tmp1$$Register, 0), $src$$Register);\n@@ -175,1 +177,0 @@\n-\n@@ -178,1 +179,1 @@\n-                       $src$$Register \/* new_val *\/,\n+                       $tmp4$$Register \/* new_val *\/,\n@@ -181,3 +182,2 @@\n-                       RegSet::of($tmp1$$Register, $tmp4$$Register) \/* preserve *\/);\n-    \/\/ Adjust address again to point to the first narrow oop in the long value\n-    __ subq($tmp1$$Register, 4);\n+                       RegSet::of($tmp1$$Register, $src$$Register) \/* preserve *\/);\n+    __ addq($tmp1$$Register, 4);\n@@ -186,1 +186,1 @@\n-                       $tmp4$$Register \/* new_val *\/,\n+                       $src$$Register \/* new_val *\/,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1_x86_64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1803,2 +1803,0 @@\n-      bool needs_atomic_access = !field->is_null_free() || field->is_volatile();\n-      assert(!needs_atomic_access, \"Atomic access in non-atomic container\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  bool is_strict               () const { return flags().is_strict(); }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  bool is_strict               () const { return _flags.is_strict();       }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -530,2 +530,3 @@\n-    if (fd.is_flat() && is_flat) {\n-      \/\/ Inline type fields are embedded\n+    if (fd.is_flat() && is_flat && !is_abstract()) {\n+      \/\/ Inline type fields are embedded (don't do this for abstract classes because\n+      \/\/ ciInlineKlass::compute_nonstatic_fields needs the declared fields from its superclass)\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -215,1 +215,0 @@\n-  bool _is_implicitly_constructible;\n@@ -217,1 +216,0 @@\n-  bool _has_implicitly_constructible_annotation;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1089,5 +1089,0 @@\n-          \/\/ if (!vk->is_implicitly_constructible()) {\n-          \/\/    THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-          \/\/               err_msg(\"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n-          \/\/               klass->external_name()), false);\n-          \/\/ }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -523,4 +523,2 @@\n-      bool needs_atomic_access = !null_free || field_is_volatile(i);\n-      assert(!needs_atomic_access, \"Atomic access in non-atomic container\");\n-      int nm_offset = field_is_null_free(i) ? -1 : (holder_offset + field_null_marker_offset(i));\n-      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, nullptr, holder, offset, false, nm_offset, decorators, visited);\n+      int nm_offset = null_free ? -1 : (holder_offset + field_null_marker_offset(i));\n+      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, nullptr, holder, offset, \/* atomic *\/ false, nm_offset, decorators, visited);\n@@ -690,0 +688,1 @@\n+        assert(inner_offset != -1, \"sanity\");\n@@ -697,0 +696,5 @@\n+        if (value->is_InlineType()) {\n+          PreserveReexecuteState preexecs(kit);\n+          kit->jvms()->set_should_reexecute(true);\n+          value = value->as_InlineType()->buffer(kit, false);\n+        }\n@@ -716,0 +720,1 @@\n+    bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n@@ -717,1 +722,1 @@\n-    bool is_naturally_atomic = null_free && vk->nof_declared_nonstatic_fields() <= 1;\n+    bool is_naturally_atomic = (!is_array && vk->is_empty()) || (null_free && vk->nof_declared_nonstatic_fields() == 1);\n@@ -739,2 +744,0 @@\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n-\n@@ -798,3 +801,0 @@\n-          kit->set_control(kit->IfTrue(iff));\n-          region_null_free->init_req(1, kit->control());\n-\n@@ -802,0 +802,1 @@\n+          kit->set_control(kit->IfTrue(iff));\n@@ -817,3 +818,1 @@\n-\n-          kit->set_control(kit->IfFalse(iff));\n-          region_null_free->init_req(2, kit->control());\n+          region_null_free->init_req(1, kit->control());\n@@ -822,0 +821,1 @@\n+          kit->set_control(kit->IfFalse(iff));\n@@ -832,0 +832,1 @@\n+          region_null_free->init_req(2, kit->control());\n@@ -843,0 +844,7 @@\n+      if (oop_off_2 == -1 && UseCompressedOops && vk->nof_declared_nonstatic_fields() == 1) {\n+        \/\/ TODO 8350865 Implement this\n+        \/\/ If null free, it's not a long but an int store. Deoptimize for now.\n+        BuildCutout unless(kit, kit->null_free_array_test(base, \/* null_free = *\/ false), PROB_MAX);\n+        kit->uncommon_trap_exact(Deoptimization::Reason_unhandled, Deoptimization::Action_none);\n+      }\n+\n@@ -858,1 +866,0 @@\n-  assert(null_free, \"Nullable flat implies atomic\");\n@@ -862,3 +869,0 @@\n-  if (holder == nullptr) {\n-    holder = vk;\n-  }\n@@ -866,0 +870,6 @@\n+\n+  if (!null_free) {\n+    bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n+    Node* adr = kit->basic_plus_adr(base, ptr, null_marker_offset);\n+    kit->access_store_at(base, adr, TypeRawPtr::BOTTOM, get_is_init(), TypeInt::BOOL, T_BOOLEAN, is_array ? (decorators | IS_ARRAY) : decorators);\n+  }\n@@ -878,2 +888,0 @@\n-      bool needs_atomic_access = !field_is_null_free(i) || field_is_volatile(i);\n-      assert(!needs_atomic_access, \"Atomic access in non-atomic container\");\n@@ -881,1 +889,1 @@\n-      value->as_InlineType()->store_flat(kit, base, ptr, nullptr, holder, offset, false, nm_offset, decorators);\n+      value->as_InlineType()->store_flat(kit, base, ptr, nullptr, holder, offset, \/* atomic *\/ false, nm_offset, decorators);\n@@ -1295,0 +1303,1 @@\n+    bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n@@ -1296,1 +1305,1 @@\n-    bool is_naturally_atomic = null_free && vk->nof_declared_nonstatic_fields() <= 1;\n+    bool is_naturally_atomic = (!is_array && vk->is_empty()) || (null_free && vk->nof_declared_nonstatic_fields() == 1);\n@@ -1303,1 +1312,0 @@\n-    bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n@@ -1319,0 +1327,11 @@\n+      Node* input_memory_state = kit->reset_memory();\n+      kit->set_all_memory(input_memory_state);\n+\n+      Node* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+      kit->gvn().set_type(mem, Type::MEMORY);\n+      kit->record_for_igvn(mem);\n+\n+      PhiNode* io = PhiNode::make(region, kit->i_o(), Type::ABIO);\n+      kit->gvn().set_type(io, Type::ABIO);\n+      kit->record_for_igvn(io);\n+\n@@ -1330,0 +1349,2 @@\n+        mem->init_req(1, kit->reset_memory());\n+        io->init_req(1, kit->i_o());\n@@ -1336,0 +1357,2 @@\n+        kit->set_all_memory(input_memory_state);\n+\n@@ -1345,0 +1368,8 @@\n+        Node* mem_null_free = PhiNode::make(region_null_free, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+        kit->gvn().set_type(mem_null_free, Type::MEMORY);\n+        kit->record_for_igvn(mem_null_free);\n+\n+        PhiNode* io_null_free = PhiNode::make(region_null_free, kit->i_o(), Type::ABIO);\n+        kit->gvn().set_type(io_null_free, Type::ABIO);\n+        kit->record_for_igvn(io_null_free);\n+\n@@ -1348,3 +1379,0 @@\n-        kit->set_control(kit->IfTrue(iff));\n-        region_null_free->init_req(1, kit->control());\n-\n@@ -1352,0 +1380,1 @@\n+        kit->set_control(kit->IfTrue(iff));\n@@ -1355,0 +1384,1 @@\n+          kit->set_all_memory(input_memory_state);\n@@ -1367,0 +1397,2 @@\n+          mem_null_free->init_req(1, kit->reset_memory());\n+          io_null_free->init_req(1, kit->i_o());\n@@ -1368,3 +1400,1 @@\n-\n-        kit->set_control(kit->IfFalse(iff));\n-        region_null_free->init_req(2, kit->control());\n+        region_null_free->init_req(1, kit->control());\n@@ -1373,0 +1403,1 @@\n+        kit->set_control(kit->IfFalse(iff));\n@@ -1374,1 +1405,3 @@\n-          \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly\n+          \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly.\n+          \/\/ Also remove the PreserveReexecuteState in Parse::array_load when buffering is no longer possible.\n+          kit->set_all_memory(input_memory_state);\n@@ -1387,0 +1420,2 @@\n+          mem_null_free->init_req(2, kit->reset_memory());\n+          io_null_free->init_req(2, kit->i_o());\n@@ -1388,0 +1423,1 @@\n+        region_null_free->init_req(2, kit->control());\n@@ -1391,0 +1427,2 @@\n+        mem->init_req(2, kit->gvn().transform(mem_null_free));\n+        io->init_req(2, kit->gvn().transform(io_null_free));\n@@ -1394,0 +1432,2 @@\n+      kit->set_all_memory(kit->gvn().transform(mem));\n+      kit->set_i_o(kit->gvn().transform(io));\n@@ -1399,1 +1439,0 @@\n-  assert(null_free, \"Nullable flat implies atomic\");\n@@ -1401,2 +1440,2 @@\n-  \/\/ The inline type is flattened into the object without an oop header. Subtract the\n-  \/\/ offset of the first field to account for the missing header when loading the values.\n+  \/\/ The inline type is embedded into the object without an oop header. Subtract the\n+  \/\/ offset of the first field to account for the missing header when storing the values.\n@@ -1404,0 +1443,7 @@\n+\n+  if (!null_free) {\n+    bool is_array = (kit->gvn().type(obj)->isa_aryptr() != nullptr);\n+    Node* adr = kit->basic_plus_adr(obj, ptr, null_marker_offset);\n+    Node* nm_value = kit->access_load_at(obj, adr, TypeRawPtr::BOTTOM, TypeInt::BOOL, T_BOOLEAN, is_array ? (decorators | IS_ARRAY) : decorators);\n+    vt->set_req(IsInit, nm_value);\n+  }\n@@ -1405,0 +1451,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":79,"deletions":32,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2692,1 +2692,1 @@\n-        val->as_InlineType()->store_flat(this, base, adr, nullptr, nullptr, 0, false, -1, decorators);\n+        val->as_InlineType()->store_flat(this, base, adr, nullptr, val->bottom_type()->inline_klass(), 0, false, -1, decorators);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-          bool is_naturally_atomic = is_null_free && vk->nof_declared_nonstatic_fields() <= 1;\n+          bool is_naturally_atomic = (is_null_free && vk->nof_declared_nonstatic_fields() <= 1);\n@@ -128,0 +128,5 @@\n+          \/\/ Re-execute flat array load if buffering triggers deoptimization\n+          PreserveReexecuteState preexecs(this);\n+          jvms()->set_should_reexecute(true);\n+          inc_sp(3);\n+\n@@ -282,1 +287,1 @@\n-            bool is_naturally_atomic = is_null_free && vk->nof_declared_nonstatic_fields() <= 1;\n+            bool is_naturally_atomic = (is_null_free && vk->nof_declared_nonstatic_fields() <= 1);\n@@ -296,1 +301,1 @@\n-            stored_value_casted->as_InlineType()->store_flat(this, array, adr, array_index, nullptr, 0, may_need_atomicity, nm_offset, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+            stored_value_casted->as_InlineType()->store_flat(this, array, adr, array_index, vk, 0, may_need_atomicity, nm_offset, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -154,2 +154,3 @@\n-    bool is_naturally_atomic = field->is_null_free() && vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = (!field->is_null_free() || field->is_volatile()) && !is_naturally_atomic;\n+    bool is_immutable = field->is_final() && field->is_strict();\n+    bool is_naturally_atomic = vk->is_empty() || (field->is_null_free() && vk->nof_declared_nonstatic_fields() == 1);\n+    bool needs_atomic_access = (!field->is_null_free() || field->is_volatile()) && !is_naturally_atomic && !is_immutable;\n@@ -273,2 +274,3 @@\n-    bool is_naturally_atomic = field->is_null_free() && vk->nof_declared_nonstatic_fields() <= 1;\n-    bool needs_atomic_access = (!field->is_null_free() || field->is_volatile()) && !is_naturally_atomic;\n+    bool is_immutable = field->is_final() && field->is_strict();\n+    bool is_naturally_atomic = vk->is_empty() || (field->is_null_free() && vk->nof_declared_nonstatic_fields() == 1);\n+    bool needs_atomic_access = (!field->is_null_free() || field->is_volatile()) && !is_naturally_atomic && !is_immutable;\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -488,3 +488,0 @@\n-  \/\/ if (!vk->is_implicitly_constructible()) {\n-  \/\/   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n-  \/\/ }\n@@ -519,3 +516,0 @@\n-  \/\/ if (!vk->is_implicitly_constructible()) {\n-  \/\/   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n-  \/\/ }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -88,0 +88,1 @@\n+    private static final boolean ForceNonTearable = !WHITEBOX.getStringVMFlag(\"ForceNonTearable\").equals(\"\");\n@@ -292,1 +293,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n@@ -306,1 +309,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n@@ -316,1 +321,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n@@ -328,1 +335,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n@@ -338,1 +347,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n@@ -348,1 +359,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n@@ -358,1 +371,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n@@ -368,1 +383,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n@@ -378,1 +395,3 @@\n-        Asserts.assertEquals(ValueClass.isFlatArray(nullableAtomicArray), UseArrayFlattening && UseNullableValueFlattening);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullableAtomicArray), UseArrayFlattening && UseNullableValueFlattening);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -69,1 +69,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -72,1 +72,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -372,0 +372,51 @@\n+    \/\/ Combinations of strict fields\n+    static class StrictFieldHolder {\n+        @Strict\n+        MyValue8 strictField1;\n+        @Strict\n+        final MyValue8 strictField2;\n+        @Strict\n+        @NullRestricted\n+        MyValue8 strictField3;\n+        @Strict\n+        @NullRestricted\n+        final MyValue8 strictField4;\n+        @Strict\n+        volatile MyValue8 strictField5;\n+        @Strict\n+        @NullRestricted\n+        volatile MyValue8 strictField6;\n+\n+        @Strict\n+        TwoBytes strictField7;\n+        @Strict\n+        final TwoBytes strictField8;\n+        @Strict\n+        @NullRestricted\n+        TwoBytes strictField9;\n+        @Strict\n+        @NullRestricted\n+        final TwoBytes strictField10;\n+        @Strict\n+        volatile TwoBytes strictField11;\n+        @Strict\n+        @NullRestricted\n+        volatile TwoBytes strictField12;\n+\n+        public StrictFieldHolder(MyValue8 val8, MyValue8 val8NullFree, TwoBytes twoBytes, TwoBytes twoBytesNullFree) {\n+            strictField1 = val8;\n+            strictField2 = val8;\n+            strictField3 = val8NullFree;\n+            strictField4 = val8NullFree;\n+            strictField5 = val8NullFree;\n+            strictField6 = val8NullFree;\n+\n+            strictField7 = twoBytes;\n+            strictField8 = twoBytes;\n+            strictField9 = twoBytesNullFree;\n+            strictField10 = twoBytesNullFree;\n+            strictField11 = twoBytesNullFree;\n+            strictField12 = twoBytesNullFree;\n+        }\n+    }\n+\n@@ -784,0 +835,16 @@\n+    public void testStrictFields(StrictFieldHolder holder, MyValue8 val8, MyValue8 val8NullFree, TwoBytes twoBytes, TwoBytes twoBytesNullFree) {\n+        Asserts.assertEQ(holder.strictField1, val8);\n+        Asserts.assertEQ(holder.strictField2, val8);\n+        Asserts.assertEQ(holder.strictField3, val8NullFree);\n+        Asserts.assertEQ(holder.strictField4, val8NullFree);\n+        Asserts.assertEQ(holder.strictField5, val8NullFree);\n+        Asserts.assertEQ(holder.strictField6, val8NullFree);\n+\n+        Asserts.assertEQ(holder.strictField7, twoBytes);\n+        Asserts.assertEQ(holder.strictField8, twoBytes);\n+        Asserts.assertEQ(holder.strictField9, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField10, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField11, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField12, twoBytesNullFree);\n+    }\n+\n@@ -1124,0 +1191,8 @@\n+\n+            \/\/ Test strict fields\n+            \/\/ TODO 8355277 Re-enable\n+            \/*\n+            TwoBytes twoBytes = new TwoBytes((byte)i, (byte)(i + 1));\n+            t.testStrictFields(new StrictFieldHolder(val8, val8, twoBytes, twoBytes), val8, val8, twoBytes, twoBytes);\n+            t.testStrictFields(new StrictFieldHolder(null, val8, null, twoBytes), null, val8, null, twoBytes);\n+            *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":80,"deletions":5,"binary":false,"changes":85,"status":"modified"}]}