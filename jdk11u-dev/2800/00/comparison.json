{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,2 @@\n-                FOLD_SELECT_ARGS_TO_VOID = 16;\n+                FOLD_SELECT_ARGS_TO_VOID = 16,\n+                FILTER_SELECT_ARGS = 17;\n@@ -733,1 +734,1 @@\n-        Name[] newParams;\n+        Name newParam = null;\n@@ -735,1 +736,0 @@\n-            newParams = new Name[0];\n@@ -741,3 +741,8 @@\n-            newParams = new Name[combinerArity];\n-            for (int i = 0; i < newParams.length; i++) {\n-                newParams[i] = lambdaForm.parameter(1 + argPositions[i]);\n+            newParam = new Name(pos, BasicType.basicType(combinerType.returnType()));\n+            for (int i = 0; i < combinerArity; i++) {\n+                int argPos = 1 + argPositions[i];\n+                if (argPos == pos) {\n+                    combinerArgs[i + 1] = newParam;\n+                } else {\n+                    combinerArgs[i + 1] = lambdaForm.parameter(argPos);\n+                }\n@@ -746,2 +751,0 @@\n-            System.arraycopy(newParams, 0,\n-                             combinerArgs, 1, combinerArity);\n@@ -758,1 +761,1 @@\n-        for (Name newParam : newParams) {\n+        if (newParam != null) {\n@@ -760,0 +763,1 @@\n+            exprPos++;\n@@ -761,1 +765,1 @@\n-        assert(buf.lastIndexOf(callCombiner) == exprPos+1+newParams.length);\n+        assert(buf.lastIndexOf(callCombiner) == exprPos+1);\n@@ -763,1 +767,1 @@\n-            buf.replaceParameterByCopy(pos, exprPos+1+newParams.length);\n+            buf.replaceParameterByCopy(pos, exprPos+1);\n@@ -848,0 +852,14 @@\n+    LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {\n+        byte kind = Transform.FILTER_SELECT_ARGS;\n+        int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);\n+        keyArgs[argPositions.length] = filterPos;\n+        Transform key = Transform.of(kind, keyArgs);\n+        LambdaForm form = getInCache(key);\n+        if (form != null) {\n+            assert(form.arity == lambdaForm.arity);\n+            return form;\n+        }\n+        form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);\n+        return putInCache(key, form);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4310,22 +4310,0 @@\n-    \/**\n-     * As {@see foldArguments(MethodHandle, int, MethodHandle)}, but with the\n-     * added capability of selecting the arguments from the targets parameters\n-     * to call the combiner with. This allows us to avoid some simple cases of\n-     * permutations and padding the combiner with dropArguments to select the\n-     * right argument, which may ultimately produce fewer intermediaries.\n-     *\/\n-    static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner, int ... argPositions) {\n-        MethodType targetType = target.type();\n-        MethodType combinerType = combiner.type();\n-        Class<?> rtype = foldArgumentChecks(pos, targetType, combinerType, argPositions);\n-        BoundMethodHandle result = target.rebind();\n-        boolean dropResult = rtype == void.class;\n-        LambdaForm lform = result.editor().foldArgumentsForm(1 + pos, dropResult, combinerType.basicType(), argPositions);\n-        MethodType newType = targetType;\n-        if (!dropResult) {\n-            newType = newType.dropParameterTypes(pos, pos + 1);\n-        }\n-        result = result.copyWithExtendL(newType, lform, combiner);\n-        return result;\n-    }\n-\n@@ -4353,3 +4331,67 @@\n-    private static Class<?> foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType, int ... argPos) {\n-        int foldArgs = combinerType.parameterCount();\n-        if (argPos.length != foldArgs) {\n+    \/**\n+     * Adapts a target method handle by pre-processing some of its arguments, then calling the target with the result\n+     * of the pre-processing replacing the argument at the given position.\n+     *\n+     * @param target the method handle to invoke after arguments are combined\n+     * @param position the position at which to start folding and at which to insert the folding result; if this is {@code\n+     *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.\n+     * @param combiner method handle to call initially on the incoming arguments\n+     * @param argPositions indexes of the target to pick arguments sent to the combiner from\n+     * @return method handle which incorporates the specified argument folding logic\n+     * @throws NullPointerException if either argument is null\n+     * @throws IllegalArgumentException if either of the following two conditions holds:\n+     *          (1) {@code combiner}'s return type is not the same as the argument type at position\n+     *              {@code pos} of the target signature;\n+     *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are\n+     *              not identical with the argument types of {@code combiner}.\n+     *\/\n+    \/*non-public*\/ static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {\n+        return argumentsWithCombiner(true, target, position, combiner, argPositions);\n+    }\n+\n+    \/**\n+     * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of\n+     * the pre-processing inserted into the original sequence of arguments at the given position.\n+     *\n+     * @param target the method handle to invoke after arguments are combined\n+     * @param position the position at which to start folding and at which to insert the folding result; if this is {@code\n+     *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.\n+     * @param combiner method handle to call initially on the incoming arguments\n+     * @param argPositions indexes of the target to pick arguments sent to the combiner from\n+     * @return method handle which incorporates the specified argument folding logic\n+     * @throws NullPointerException if either argument is null\n+     * @throws IllegalArgumentException if either of the following two conditions holds:\n+     *          (1) {@code combiner}'s return type is non-{@code void} and not the same as the argument type at position\n+     *              {@code pos} of the target signature;\n+     *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature\n+     *              (skipping {@code position} where the {@code combiner}'s return will be folded in) are not identical\n+     *              with the argument types of {@code combiner}.\n+     *\/\n+    \/*non-public*\/ static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {\n+        return argumentsWithCombiner(false, target, position, combiner, argPositions);\n+    }\n+\n+    private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {\n+        MethodType targetType = target.type();\n+        MethodType combinerType = combiner.type();\n+        Class<?> rtype = argumentsWithCombinerChecks(position, filter, targetType, combinerType, argPositions);\n+        BoundMethodHandle result = target.rebind();\n+\n+        MethodType newType = targetType;\n+        LambdaForm lform;\n+        if (filter) {\n+            lform = result.editor().filterArgumentsForm(1 + position, combinerType.basicType(), argPositions);\n+        } else {\n+            boolean dropResult = rtype == void.class;\n+            lform = result.editor().foldArgumentsForm(1 + position, dropResult, combinerType.basicType(), argPositions);\n+            if (!dropResult) {\n+                newType = newType.dropParameterTypes(position, position + 1);\n+            }\n+        }\n+        result = result.copyWithExtendL(newType, lform, combiner);\n+        return result;\n+    }\n+\n+    private static Class<?> argumentsWithCombinerChecks(int position, boolean filter, MethodType targetType, MethodType combinerType, int ... argPos) {\n+        int combinerArgs = combinerType.parameterCount();\n+        if (argPos.length != combinerArgs) {\n@@ -4359,3 +4401,2 @@\n-        int foldVals = rtype == void.class ? 0 : 1;\n-        boolean ok = true;\n-        for (int i = 0; i < foldArgs; i++) {\n+\n+        for (int i = 0; i < combinerArgs; i++) {\n@@ -4372,4 +4413,1 @@\n-        if (ok && foldVals != 0 && combinerType.returnType() != targetType.parameterType(foldPos)) {\n-            ok = false;\n-        }\n-        if (!ok)\n+        if (filter && combinerType.returnType() != targetType.parameterType(position)) {\n@@ -4377,0 +4415,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":71,"deletions":32,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -1536,1 +1536,0 @@\n-                mh = MethodHandles.dropArguments(mh, 2, int.class);\n@@ -1540,2 +1539,2 @@\n-                        mh = MethodHandles.foldArguments(mh, 1, prepender,\n-                                2, 0, 3 \/\/ index, storage, coder\n+                        mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,\n+                                1, 0, 2 \/\/ index, storage, coder\n@@ -1548,3 +1547,3 @@\n-                        mh = MethodHandles.foldArguments(mh, 1, prepender,\n-                                2, 0, 3, \/\/ index, storage, coder\n-                                4 + pos  \/\/ selected argument\n+                        mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,\n+                                1, 0, 2, \/\/ index, storage, coder\n+                                3 + pos  \/\/ selected argument\n@@ -1560,1 +1559,1 @@\n-            mh = MethodHandles.foldArguments(mh, 0, NEW_ARRAY,\n+            mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,\n@@ -1575,1 +1574,1 @@\n-            \/\/ The method handle shape after all length and coder mixers is:\n+            \/\/ The method handle shape before and after all length and coder mixers is:\n@@ -1591,1 +1590,0 @@\n-                        MethodHandle cm = coderMixer(argClass);\n@@ -1593,1 +1591,6 @@\n-                        \/\/ Read this bottom up:\n+                        if (argClass.isPrimitive() && argClass != char.class) {\n+                            \/\/ Compute new \"index\" in-place using old value plus the appropriate argument.\n+                            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, lm,\n+                                    0, \/\/ old-index\n+                                    2 + ac \/\/ selected argument\n+                            );\n@@ -1595,16 +1598,15 @@\n-                        \/\/ 4. Drop old index and coder, producing (\"new-index\", \"new-coder\", <args>)\n-                        mh = MethodHandles.dropArguments(mh, 2, int.class, byte.class);\n-\n-                        \/\/ 3. Compute \"new-index\", producing (\"new-index\", \"new-coder\", \"old-index\", \"old-coder\", <args>)\n-                        \/\/    Length mixer needs old index, plus the appropriate argument\n-                        mh = MethodHandles.foldArguments(mh, 0, lm,\n-                                2, \/\/ old-index\n-                                4 + ac \/\/ selected argument\n-                        );\n-\n-                        \/\/ 2. Compute \"new-coder\", producing (\"new-coder\", \"old-index\", \"old-coder\", <args>)\n-                        \/\/    Coder mixer needs old coder, plus the appropriate argument.\n-                        mh = MethodHandles.foldArguments(mh, 0, cm,\n-                                2, \/\/ old-coder\n-                                3 + ac \/\/ selected argument\n-                        );\n+                        } else {\n+                            MethodHandle cm = coderMixer(argClass);\n+\n+                            \/\/ Compute new \"index\" in-place using old value plus the appropriate argument.\n+                            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, lm,\n+                                    0, \/\/ old-index\n+                                    2 + ac \/\/ selected argument\n+                            );\n+\n+                            \/\/ Compute new \"coder\" in-place using old value plus the appropriate argument.\n+                            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, cm,\n+                                    1, \/\/ old-coder\n+                                    2 + ac \/\/ selected argument\n+                            );\n+                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"}]}