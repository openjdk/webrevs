{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n@@ -32,3 +32,13 @@\n-import java.net.*;\n-import java.io.*;\n-import sun.net.www.MessageHeader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n+import jdk.test.lib.net.URIBuilder;\n@@ -127,2 +137,1 @@\n-\n-            MessageHeader headers =  new MessageHeader (is);\n+            HttpHeaderParser httpHeaderParser = new HttpHeaderParser(is);\n@@ -130,2 +139,1 @@\n-\n-            headers =  new MessageHeader (is);\n+            httpHeaderParser = new HttpHeaderParser(is);\n@@ -135,1 +143,0 @@\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/ProxyFromCache.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n@@ -34,1 +34,2 @@\n-import sun.net.www.MessageHeader;\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -94,2 +95,2 @@\n-            MessageHeader headers =  new MessageHeader (is);\n-            String requestLine = headers.getValue(0);\n+            HttpHeaderParser headers =  new HttpHeaderParser (is);\n+            String requestLine = headers.getRequestDetails();\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/RequestURI.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @modules java.base\/sun.net.www\n@@ -33,4 +32,12 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import sun.net.www.MessageHeader;\n+import java.io.BufferedOutputStream;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.util.List;\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -52,4 +59,9 @@\n-            MessageHeader mh = new MessageHeader(is);\n-            String connHeader = mh.findValue(\"Connection\");\n-            if (connHeader != null && connHeader.equalsIgnoreCase(\"close\")) {\n-                hasCloseHeader = true;\n+            HttpHeaderParser mh = new HttpHeaderParser(is);\n+            List <String> connHeader = mh.getHeaderValue(\"Connection\");\n+            if (connHeader != null) {\n+                for(String value : connHeader) {\n+                    if (value.equalsIgnoreCase(\"close\")) {\n+                        hasCloseHeader = true;\n+                        break;\n+                    }\n+                }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/CloseOptionHeader.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,498 @@\n+\n+\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8061729\n+ * @library \/test\/lib\n+ * @summary Sanity check that HttpHeaderParser works same as MessageHeader\n+ * @modules java.base\/sun.net.www java.base\/sun.net.www.protocol.http:open\n+ * @run testng\/othervm HttpHeaderParserTest\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import jdk.test.lib.net.HttpHeaderParser;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import sun.net.www.MessageHeader;\n+\n+public class HttpHeaderParserTest {\n+    @DataProvider(name = \"responses\")\n+    public Object[][] responses() {\n+        List<String> responses = new ArrayList<>();\n+\n+        String[] basic =\n+                { \"HTTP\/1.1 200 OK\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+                                \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+                                \"Connection: close\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=iso-8859-1\\r\\n\" +\n+                                \"Content-Length: 10\\r\\n\\r\\n\" +\n+                                \"123456789\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 9\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Header: U\\u00ffU\\r\\n\" + \/\/ value with U+00FF - Extended Latin-1\n+                                \"Content-Length: 9\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length:   9\\r\\n\" +\n+                                \"Content-Type:   text\/html; charset=UTF-8\\r\\n\\r\\n\" +   \/\/ more than one SP after ':'\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length:\\t10\\r\\n\" +\n+                                \"Content-Type:\\ttext\/html; charset=UTF-8\\r\\n\\r\\n\" +   \/\/ HT separator\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length:\\t\\t10\\r\\n\" +\n+                                \"Content-Type:\\t\\ttext\/html; charset=UTF-8\\r\\n\\r\\n\" +   \/\/ more than one HT after ':'\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 407 Proxy Authorization Required\\r\\n\" +\n+                                \"Proxy-Authenticate: Basic realm=\\\"a fake realm\\\"\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+                                \"WWW-Authenticate: Digest realm=\\\"wally land\\\" domain=\/ \" +\n+                                \"nonce=\\\"2B7F3A2B\\\" qop=\\\"auth\\\"\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo:\\r\\n\\r\\n\",      \/\/ no value\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo:\\r\\n\\r\\n\" +     \/\/ no value, with response body\n+                                \"Some Response Body\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo:\\r\\n\" +    \/\/ no value, followed by another header\n+                                \"Content-Length: 10\\r\\n\\r\\n\" +\n+                                \"Some Response Body\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo:\\r\\n\" +    \/\/ no value, followed by another header, with response body\n+                                \"Content-Length: 10\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo: chegar\\r\\n\" +\n+                                \"X-Foo: dfuchs\\r\\n\" +  \/\/ same header appears multiple times\n+                                \"Content-Length: 0\\r\\n\" +\n+                                \"X-Foo: michaelm\\r\\n\" +\n+                                \"X-Foo: prappo\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-Foo:\\r\\n\" +    \/\/ no value, same header appears multiple times\n+                                \"X-Foo: dfuchs\\r\\n\" +\n+                                \"Content-Length: 0\\r\\n\" +\n+                                \"X-Foo: michaelm\\r\\n\" +\n+                                \"X-Foo: prappo\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Accept-Ranges: bytes\\r\\n\" +\n+                                \"Cache-control: max-age=0, no-cache=\\\"set-cookie\\\"\\r\\n\" +\n+                                \"Content-Length: 132868\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\" +\n+                                \"Date: Sun, 05 Nov 2017 22:24:03 GMT\\r\\n\" +\n+                                \"Server: Apache\/2.4.6 (Red Hat Enterprise Linux) OpenSSL\/1.0.1e-fips Communique\/4.2.2\\r\\n\" +\n+                                \"Set-Cookie: AWSELB=AF7927F5100F4202119876ED2436B5005EE;PATH=\/;MAX-AGE=900\\r\\n\" +\n+                                \"Vary: Host,Accept-Encoding,User-Agent\\r\\n\" +\n+                                \"X-Mod-Pagespeed: 1.12.34.2-0\\r\\n\" +\n+                                \"Connection: keep-alive\\r\\n\\r\\n\"\n+                };\n+        Arrays.stream(basic).forEach(responses::add);\n+        \/\/ add some tests where some of the CRLF are replaced\n+        \/\/ by a single LF\n+        Arrays.stream(basic)\n+                .map(HttpHeaderParserTest::mixedCRLF)\n+                .forEach(responses::add);\n+\n+        String[] foldingTemplate =\n+                {  \"HTTP\/1.1 200 OK\\r\\n\" +\n+                        \"Content-Length: 9\\r\\n\" +\n+                        \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r'\n+                        \" charset=UTF-8\\r\\n\" +                \/\/ one preceding SP\n+                        \"Connection: close\\r\\n\\r\\n\" +\n+                        \"XXYYZZAABBCCDDEE\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 19\\r\\n\" +\n+                                \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r\n+                                \"   charset=UTF-8\\r\\n\" +              \/\/ more than one preceding SP\n+                                \"Connection: keep-alive\\r\\n\\r\\n\" +\n+                                \"XXYYZZAABBCCDDEEFFGG\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 999\\r\\n\" +\n+                                \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r\n+                                \"\\tcharset=UTF-8\\r\\n\" +               \/\/ one preceding HT\n+                                \"Connection: close\\r\\n\\r\\n\" +\n+                                \"XXYYZZAABBCCDDEE\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 54\\r\\n\" +\n+                                \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r\n+                                \"\\t\\t\\tcharset=UTF-8\\r\\n\" +           \/\/ more than one preceding HT\n+                                \"Connection: keep-alive\\r\\n\\r\\n\" +\n+                                \"XXYYZZAABBCCDDEEFFGG\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: -1\\r\\n\" +\n+                                \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r\n+                                \"\\t \\t \\tcharset=UTF-8\\r\\n\" +         \/\/ mix of preceding HT and SP\n+                                \"Connection: keep-alive\\r\\n\\r\\n\" +\n+                                \"XXYYZZAABBCCDDEEFFGGHH\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 65\\r\\n\" +\n+                                \"Content-Type: text\/html;$NEWLINE\" +  \/\/ folding field-value with '\\n'|'\\r\n+                                \" \\t \\t charset=UTF-8\\r\\n\" +          \/\/ mix of preceding SP and HT\n+                                \"Connection: keep-alive\\r\\n\\r\\n\" +\n+                                \"XXYYZZAABBCCDDEEFFGGHHII\",\n+\n+                        \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+                                \"WWW-Authenticate: Digest realm=\\\"wally land\\\",\"\n+                                +\"$NEWLINE    domain=\/,\"\n+                                +\"$NEWLINE nonce=\\\"2B7F3A2B\\\",\"\n+                                +\"$NEWLINE\\tqop=\\\"auth\\\"\\r\\n\\r\\n\",\n+\n+                };\n+        for (String newLineChar : new String[] { \"\\n\", \"\\r\", \"\\r\\n\" }) {\n+            for (String template : foldingTemplate)\n+                responses.add(template.replace(\"$NEWLINE\", newLineChar));\n+        }\n+        \/\/ add some tests where some of the CRLF are replaced\n+        \/\/ by a single LF\n+        for (String newLineChar : new String[] { \"\\n\", \"\\r\", \"\\r\\n\" }) {\n+            for (String template : foldingTemplate)\n+                responses.add(mixedCRLF(template).replace(\"$NEWLINE\", newLineChar));\n+        }\n+\n+        String[] bad = \/\/ much of this is to retain parity with legacy MessageHeaders\n+                { \"HTTP\/1.1 200 OK\\r\\n\" +\n+                        \"Connection:\\r\\n\\r\\n\",   \/\/ empty value, no body\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Connection:\\r\\n\\r\\n\" +  \/\/ empty value, with body\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \": no header\\r\\n\\r\\n\",  \/\/ no\/empty header-name, no body, no following header\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \": no; header\\r\\n\" +  \/\/ no\/empty header-name, no body, following header\n+                                \"Content-Length: 65\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \": no header\\r\\n\" +  \/\/ no\/empty header-name\n+                                \"Content-Length: 65\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-foo: bar\\r\\n\" +\n+                                \" : no header\\r\\n\" +  \/\/ fold, not a blank header-name\n+                                \"Content-Length: 65\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-foo: bar\\r\\n\" +\n+                                \" \\t : no header\\r\\n\" +  \/\/ fold, not a blank header-name\n+                                \"Content-Length: 65\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \": no header\\r\\n\\r\\n\" +  \/\/ no\/empty header-name, followed by header\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Conte\\r\" +\n+                                \"nt-Length: 9\\r\\n\" +    \/\/ fold\/bad header name ??? without preceding space\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXXYYZZ\",\n+\n+                        \"HTTP\/1.0 404 Not Found\\r\\n\" +\n+                                \"header-without-colon\\r\\n\\r\\n\",\n+\n+                        \"HTTP\/1.0 404 Not Found\\r\\n\" +\n+                                \"header-without-colon\\r\\n\\r\\n\" +\n+                                \"SOMEBODY\",\n+\n+                };\n+        Arrays.stream(bad).forEach(responses::add);\n+\n+        return responses.stream().map(p -> new Object[] { p }).toArray(Object[][]::new);\n+    }\n+\n+    static final AtomicInteger index = new AtomicInteger();\n+    static final AtomicInteger limit = new AtomicInteger(1);\n+    static final AtomicBoolean useCRLF = new AtomicBoolean();\n+    \/\/ A small method to replace part of the CRLF present in a string\n+    \/\/ with simple LF. The method uses a deterministic algorithm based\n+    \/\/ on current values of static index\/limit\/useCRLF counters.\n+    \/\/ These counters are used to produce a stream of substitutes that\n+    \/\/ looks like this:\n+    \/\/ LF CRLF LF LF CRLF CRLF LF LF LF CRLF CRLF CRLF (then repeat from start)\n+    static final String mixedCRLF(String headers) {\n+        int next;\n+        int start = 0;\n+        int last = headers.lastIndexOf(\"\\r\\n\");\n+        String prev = \"\";\n+        StringBuilder res = new StringBuilder();\n+        while ((next = headers.indexOf(\"\\r\\n\", start)) > 0) {\n+            res.append(headers.substring(start, next));\n+            if (\"\\n\".equals(prev) && next == last) {\n+                \/\/ for some reason the legacy MessageHeader parser will\n+                \/\/ not consume the final LF if the headers are terminated\n+                \/\/ by <LF><CRLF> instead of <CRLF><CRLF>. It consume\n+                \/\/ <LF><CR> but leaves the last <LF> in the stream.\n+                \/\/ Here we just make sure to avoid using <LF><CRLF>\n+                \/\/ as that would cause the legacy parser to consume\n+                \/\/ 1 byte less than the Http1HeadersParser - which\n+                \/\/ does consume the last <LF>, as it should.\n+                \/\/ if this is the last CRLF and the previous one\n+                \/\/ was replaced by LF then use LF.\n+                res.append(prev);\n+            } else {\n+                prev = useCRLF.get() ? \"\\r\\n\" : \"\\n\";\n+                res.append(prev);\n+            }\n+            \/\/ skip CRLF\n+            start = next + 2;\n+\n+            \/\/ The idea is to substitute some of the CRLF with LF.\n+            \/\/ Rather than doing this randomly, always use the following\n+            \/\/ sequence:\n+            \/\/ LF CRLF LF LF CRLF CRLF LF LF LF CRLF CRLF CRLF\n+            index.incrementAndGet();\n+            if (index.get() == limit.get()) {\n+                index.set(0);\n+                if (useCRLF.get()) limit.incrementAndGet();\n+                if (limit.get() > 3) limit.set(1);\n+                useCRLF.set(!useCRLF.get());\n+            }\n+        }\n+        res.append(headers.substring(start));\n+        return res.toString();\n+    }\n+\n+\n+    @Test(dataProvider = \"responses\")\n+    public void verifyHeaders(String respString) throws Exception {\n+        System.out.println(\"\\ntesting:\\n\\t\" + respString\n+                .replace(\"\\r\\n\", \"<CRLF>\")\n+                .replace(\"\\r\", \"<CR>\")\n+                .replace(\"\\n\",\"<LF>\")\n+                .replace(\"LF>\", \"LF>\\n\\t\"));\n+        byte[] bytes = respString.getBytes(ISO_8859_1);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        MessageHeader m = new MessageHeader(bais);\n+        Map<String,List<String>> messageHeaderMap = m.getHeaders();\n+        int availableBytes = bais.available();\n+\n+        HttpHeaderParser decoder = new HttpHeaderParser();\n+        ByteArrayInputStream headerStream = new ByteArrayInputStream(bytes);\n+        int initialBytes = headerStream.available();\n+        decoder.parse(headerStream);\n+        System.out.printf(\"HttpHeaderParser parsed %d bytes out of %d%n\", initialBytes - headerStream.available(), bytes.length);\n+        Map<String,List<String>> decoderMap1 = decoder.getHeaderMap();\n+\n+\n+        \/\/ assert status-line\n+        String statusLine1 = messageHeaderMap.get(null).get(0);\n+        String statusLine2 = decoder.getRequestDetails();\n+        if (statusLine1.startsWith(\"HTTP\")) {\/\/ skip the case where MH's messes up the status-line\n+            assertEquals(statusLine2, statusLine1, \"Status-line not equal\");\n+        } else {\n+            assertTrue(statusLine2.startsWith(\"HTTP\/1.\"), \"Status-line not HTTP\/1.\");\n+        }\n+\n+        \/\/ remove the null'th entry with is the status-line\n+        Map<String,List<String>> map = new HashMap<>();\n+        for (Map.Entry<String,List<String>> e : messageHeaderMap.entrySet()) {\n+            if (e.getKey() != null) {\n+                map.put(e.getKey(), e.getValue());\n+            }\n+        }\n+        messageHeaderMap = map;\n+\n+        assertHeadersEqual(messageHeaderMap, decoderMap1,\n+                \"messageHeaderMap not equal to decoderMap1\");\n+\n+        assertEquals(availableBytes, headerStream.available(),\n+                String.format(\"stream available (%d) not equal to remaining (%d)\",\n+                        availableBytes, headerStream.available()));\n+    }\n+\n+    @DataProvider(name = \"errors\")\n+    public Object[][] errors() {\n+        List<String> responses = new ArrayList<>();\n+\n+        \/\/ These responses are parsed, somewhat, by MessageHeaders but give\n+        \/\/ nonsensible results. They, correctly, fail with the Http1HeaderParser.\n+        String[] bad =\n+                {\/\/ \"HTTP\/1.1 402 Payment Required\\r\\n\" +\n+                        \/\/ \"Content-Length: 65\\r\\n\\r\",   \/\/ missing trailing LF   \/\/TODO: incomplete\n+\n+                        \"HTTP\/1.1 402 Payment Required\\r\\n\" +\n+                                \"Content-Length: 65\\r\\n\\rT\\r\\n\\r\\nGGGGGG\",\n+\n+                        \"HTTP\/1.1 200OK\\r\\n\\rT\",\n+\n+                        \"HTTP\/1.1 200OK\\rT\",\n+\n+                        \"HTTP\/1.0 FOO\\r\\n\",\n+\n+                        \"HTTP\/1.1 BAR\\r\\n\",\n+\n+                        \"HTTP\/1.1 +99\\r\\n\",\n+\n+                        \"HTTP\/1.1 -22\\r\\n\",\n+\n+                        \"HTTP\/1.1 -20 \\r\\n\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-fo\\u00ffo: foo\\r\\n\" +     \/\/ invalid char in name\n+                                \"Content-Length: 5\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X-foo : bar\\r\\n\" +          \/\/  trim space after name\n+                                \"Content-Length: 5\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \" X-foo: bar\\r\\n\" +          \/\/ trim space before name\n+                                \"Content-Length: 5\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"X foo: bar\\r\\n\" +           \/\/ invalid space in name\n+                                \"Content-Length: 5\\r\\n\" +\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Content-Length: 5\\r\\n\" +\n+                                \"Content Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" + \/\/ invalid space in name\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \"Conte\\r\" +\n+                                \" nt-Length: 9\\r\\n\" +    \/\/ fold results in space in header name\n+                                \"Content-Type: text\/html; charset=UTF-8\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \" : no header\\r\\n\" +  \/\/ all blank header-name (not fold)\n+                                \"Content-Length: 65\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                        \"HTTP\/1.1 200 OK\\r\\n\" +\n+                                \" \\t : no header\\r\\n\" +  \/\/ all blank header-name (not fold)\n+                                \"Content-Length: 65\\r\\n\\r\\n\" +\n+                                \"XXXXX\",\n+\n+                };\n+        Arrays.stream(bad).forEach(responses::add);\n+\n+        return responses.stream().map(p -> new Object[] { p }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"errors\", expectedExceptions = IOException.class)\n+    public void errors(String respString) throws IOException {\n+        byte[] bytes = respString.getBytes(US_ASCII);\n+        HttpHeaderParser decoder = new HttpHeaderParser();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        decoder.parse(bais);\n+    }\n+\n+    void assertHeadersEqual(Map<String,List<String>> expected,\n+                            Map<String,List<String>> actual,\n+                            String msg) {\n+\n+        if (expected.equals(actual))\n+            return;\n+\n+        assertEquals(expected.size(), actual.size(),\n+                format(\"%s. Expected size %d, actual size %s. %nexpected= %s,%n actual=%s.\",\n+                        msg, expected.size(), actual.size(), mapToString(expected), mapToString(actual)));\n+\n+        for (Map.Entry<String,List<String>> e : expected.entrySet()) {\n+            String key = e.getKey();\n+            List<String> values = e.getValue();\n+\n+            boolean found = false;\n+            for (Map.Entry<String,List<String>> other: actual.entrySet()) {\n+                if (key.equalsIgnoreCase(other.getKey())) {\n+                    found = true;\n+                    List<String> otherValues = other.getValue();\n+                    assertEquals(values.size(), otherValues.size(),\n+                            format(\"%s. Expected list size %d, actual size %s\",\n+                                    msg, values.size(), otherValues.size()));\n+                    if (!(values.containsAll(otherValues) && otherValues.containsAll(values)))\n+                        assertTrue(false, format(\"Lists are unequal [%s] [%s]\", values, otherValues));\n+                    break;\n+                }\n+            }\n+            assertTrue(found, format(\"header name, %s, not found in %s\", key, actual));\n+        }\n+    }\n+\n+    static String mapToString(Map<String,List<String>> map) {\n+        StringBuilder sb = new StringBuilder();\n+        List<String> sortedKeys = new ArrayList(map.keySet());\n+        Collections.sort(sortedKeys);\n+        for (String key : sortedKeys) {\n+            List<String> values = map.get(key);\n+            sb.append(\"\\n\\t\" + key + \" | \" + values);\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/HttpHeaderParserTest.java","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @modules java.base\/sun.net.www\n@@ -35,1 +34,2 @@\n-import sun.net.www.MessageHeader;\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -163,1 +163,1 @@\n-                MessageHeader header = new MessageHeader (s.getInputStream());\n+                HttpHeaderParser httpHeaderParser = new HttpHeaderParser(s.getInputStream());\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NTLMTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n- * @modules java.base\/sun.net.www\n- *          java.base\/sun.net.www.protocol.http:open\n+ * @modules java.base\/sun.net.www.protocol.http:open\n@@ -45,0 +44,2 @@\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -46,1 +47,0 @@\n-import sun.net.www.MessageHeader;\n@@ -166,1 +166,1 @@\n-                new MessageHeader().parseHeader(s.getInputStream());\n+                new HttpHeaderParser().parse(s.getInputStream());\n@@ -174,2 +174,2 @@\n-                MessageHeader mh = new MessageHeader();\n-                mh.parseHeader(s.getInputStream());\n+                HttpHeaderParser mh = new HttpHeaderParser();\n+                mh.parse(s.getInputStream());\n@@ -177,1 +177,1 @@\n-                auth = mh.findValue(\"Authorization\");\n+                auth = mh.getHeaderValue(\"Authorization\").get(0);\n@@ -211,1 +211,1 @@\n-                new MessageHeader().parseHeader(s.getInputStream());\n+                new HttpHeaderParser().parse(s.getInputStream());\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NoNTLM.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @modules java.base\/sun.net.www\n@@ -34,0 +33,2 @@\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -35,1 +36,0 @@\n-import sun.net.www.*;\n@@ -45,1 +45,1 @@\n-                MessageHeader header = new MessageHeader (is);\n+                HttpHeaderParser header = new HttpHeaderParser (is);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/RetryUponTimeout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @modules java.base\/sun.net.www\n@@ -37,0 +36,2 @@\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n@@ -38,1 +39,0 @@\n-import sun.net.www.MessageHeader;\n@@ -49,2 +49,2 @@\n-            MessageHeader header = new MessageHeader (s.getInputStream());\n-            String v = header.findValue (\"User-Agent\");\n+            HttpHeaderParser header = new HttpHeaderParser (s.getInputStream());\n+            String v = header.getHeaderValue (\"User-Agent\").get(0);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/UserAgent.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n@@ -40,1 +40,3 @@\n-import sun.net.www.MessageHeader;\n+\n+import jdk.test.lib.net.HttpHeaderParser;\n+\n@@ -141,2 +143,2 @@\n-        MessageHeader mheader = new MessageHeader(in);\n-        String statusLine = mheader.getValue(0);\n+        HttpHeaderParser mheader = new HttpHeaderParser(in);\n+        String statusLine = mheader.getRequestDetails();\n@@ -148,1 +150,1 @@\n-           if (mheader.findValue(\"X-TestHeader\") != null) {\n+           if (mheader.getHeaderValue(\"X-TestHeader\") != null) {\n@@ -155,1 +157,1 @@\n-           if ((value = mheader.findValue(\"Proxy-Connection\")) == null ||\n+           if ((value = mheader.getHeaderValue(\"Proxy-Connection\").get(0)) == null ||\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6226610.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,2 @@\n-import sun.net.www.MessageHeader;\n+import jdk.test.lib.net.HttpHeaderParser;\n+\n@@ -266,1 +267,1 @@\n-                MessageHeader mhead = new MessageHeader (is);\n+                HttpHeaderParser mhead = new HttpHeaderParser (is);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.net;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.ProtocolException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class HttpHeaderParser {\n+    private static final char CR = '\\r';\n+    private static final char LF = '\\n';\n+    private static final char HT = '\\t';\n+    private static final char SP = ' ';\n+    \/\/ ABNF primitives defined in RFC 7230\n+    private static boolean[] tchar      = new boolean[256];\n+    private static boolean[] fieldvchar = new boolean[256];\n+\n+    static {\n+        char[] allowedTokenChars =\n+                (\"!#$%&'*+-.^_`|~0123456789\" +\n+                        \"abcdefghijklmnopqrstuvwxyz\" +\n+                        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").toCharArray();\n+        for (char c : allowedTokenChars) {\n+            tchar[c] = true;\n+        }\n+        for (char c = 0x21; c <= 0xFF; c++) {\n+            fieldvchar[c] = true;\n+        }\n+        fieldvchar[0x7F] = false; \/\/ a little hole (DEL) in the range\n+    }\n+\n+    private StringBuilder sb = new StringBuilder();\n+\n+    private Map <String, List<String>>  headerMap = new LinkedHashMap<>();\n+    private List <String> keyList = new ArrayList<>();\n+    private String requestOrStatusLine;\n+    private int responseCode;\n+    private boolean eof;\n+\n+\n+\n+    enum State { INITIAL,\n+        STATUS_OR_REQUEST_LINE,\n+        STATUS_OR_REQUEST_LINE_FOUND_CR,\n+        STATUS_OR_REQUEST_LINE_FOUND_LF,\n+        STATUS_OR_REQUEST_LINE_END,\n+        STATUS_OR_REQUEST_LINE_END_CR,\n+        STATUS_OR_REQUEST_LINE_END_LF,\n+        HEADER,\n+        HEADER_FOUND_CR,\n+        HEADER_FOUND_LF,\n+        HEADER_FOUND_CR_LF,\n+        HEADER_FOUND_CR_LF_CR,\n+        FINISHED }\n+\n+    private HttpHeaderParser.State state = HttpHeaderParser.State.INITIAL;\n+\n+    public HttpHeaderParser() {\n+    }\n+\n+\n+    public HttpHeaderParser(InputStream is) throws IOException, ProtocolException {\n+        parse(is);\n+    }\n+\n+    public Map<String, List<String>> getHeaderMap() {\n+        return headerMap;\n+    }\n+\n+    public List<String> getHeaderValue(String key) {\n+        if(headerMap.containsKey(key.toLowerCase(Locale.ROOT))) {\n+            return headerMap.get(key.toLowerCase(Locale.ROOT));\n+        }\n+        return null;\n+    }\n+    public List<String> getValue(int id) {\n+        String key = keyList.get(id);\n+        return headerMap.get(key);\n+    }\n+\n+    public String getRequestDetails() {\n+        return requestOrStatusLine;\n+    }\n+\n+    \/**\n+     * Parses HTTP\/1.X status-line or request-line and headers from the given input stream.\n+     * @param input Containing the input stream of bytes representing request or response header data\n+     * @return true if the end of the headers block has been reached\n+     *\/\n+    public boolean parse(InputStream input) throws IOException {\n+        requireNonNull(input, \"null input\");\n+        while (canContinueParsing()) {\n+            switch (state) {\n+                case INITIAL                                    :  state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE; break;\n+                case STATUS_OR_REQUEST_LINE :  readResumeStatusLine(input); break;\n+                case STATUS_OR_REQUEST_LINE_FOUND_CR: case STATUS_OR_REQUEST_LINE_FOUND_LF :  readStatusLineFeed(input); break;\n+                case STATUS_OR_REQUEST_LINE_END :  maybeStartHeaders(input); break;\n+                case STATUS_OR_REQUEST_LINE_END_CR: case STATUS_OR_REQUEST_LINE_END_LF :  maybeEndHeaders(input); break;\n+                case HEADER                                     :  readResumeHeader(input); break;\n+                case HEADER_FOUND_CR: case HEADER_FOUND_LF      :  resumeOrLF(input); break;\n+                case HEADER_FOUND_CR_LF                         :  resumeOrSecondCR(input); break;\n+                case HEADER_FOUND_CR_LF_CR                      :  resumeOrEndHeaders(input); break;\n+                default : throw new InternalError(\"Unexpected state: \" + state);\n+            }\n+        }\n+        return state == HttpHeaderParser.State.FINISHED;\n+    }\n+\n+    private boolean canContinueParsing() {\n+        \/\/ some states don't require any input to transition\n+        \/\/ to the next state.\n+        switch (state) {\n+            case FINISHED : return false;\n+            case STATUS_OR_REQUEST_LINE_FOUND_LF: STATUS_OR_REQUEST_LINE_END_LF: HEADER_FOUND_LF : return true;\n+            default : return !eof;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a character (char) corresponding to the next byte in the\n+     * input, interpreted as an ISO-8859-1 encoded character.\n+     * <p>\n+     * The ISO-8859-1 encoding is a 8-bit character coding that\n+     * corresponds to the first 256 Unicode characters - from U+0000 to\n+     * U+00FF. UTF-16 is backward compatible with ISO-8859-1 - which\n+     * means each byte in the input should be interpreted as an unsigned\n+     * value from [0, 255] representing the character code.\n+     *\n+     * @param input a {@code InputStream} containing input stream of Bytes.\n+     * @return the next byte in the input, interpreted as an ISO-8859-1\n+     * encoded char\n+     * @throws IOException\n+     *          if an I\/O error occurs.\n+     *\/\n+    private char get(InputStream input) throws IOException {\n+        int c = input.read();\n+        if(c < 0)\n+            eof = true;\n+        return (char)(c & 0xFF);\n+    }\n+\n+    private void readResumeStatusLine(InputStream input) throws IOException {\n+        char c;\n+        while ((c = get(input)) != CR && !eof) {\n+            if (c == LF) break;\n+            sb.append(c);\n+        }\n+        if (c == CR) {\n+            state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_FOUND_CR;\n+        } else if (c == LF) {\n+            state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_FOUND_LF;\n+        }\n+    }\n+\n+    private void readStatusLineFeed(InputStream input) throws IOException {\n+        char c = state == HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_FOUND_LF ? LF : get(input);\n+        if (c != LF) {\n+            throw protocolException(\"Bad trailing char, \\\"%s\\\", when parsing status line, \\\"%s\\\"\",\n+                    c, sb.toString());\n+        }\n+        requestOrStatusLine = sb.toString();\n+        sb = new StringBuilder();\n+        if (!requestOrStatusLine.startsWith(\"HTTP\/1.\")) {\n+            if(!requestOrStatusLine.startsWith(\"GET\") && !requestOrStatusLine.startsWith(\"POST\") &&\n+                    !requestOrStatusLine.startsWith(\"PUT\") && !requestOrStatusLine.startsWith(\"DELETE\") &&\n+                    !requestOrStatusLine.startsWith(\"OPTIONS\") && !requestOrStatusLine.startsWith(\"HEAD\") &&\n+            !requestOrStatusLine.startsWith(\"PATCH\") && !requestOrStatusLine.startsWith(\"CONNECT\")) {\n+                throw protocolException(\"Invalid request Or Status line: \\\"%s\\\"\", requestOrStatusLine);\n+            } else { \/\/This is request\n+                System.out.println(\"Request is :\"+requestOrStatusLine);\n+            }\n+        } else { \/\/This is response\n+            if (requestOrStatusLine.length() < 12) {\n+                throw protocolException(\"Invalid status line: \\\"%s\\\"\", requestOrStatusLine);\n+            }\n+            try {\n+                responseCode = Integer.parseInt(requestOrStatusLine.substring(9, 12));\n+            } catch (NumberFormatException nfe) {\n+                throw protocolException(\"Invalid status line: \\\"%s\\\"\", requestOrStatusLine);\n+            }\n+            \/\/ response code expected to be a 3-digit integer (RFC-2616, section 6.1.1)\n+            if (responseCode < 100) {\n+                throw protocolException(\"Invalid status line: \\\"%s\\\"\", requestOrStatusLine);\n+            }\n+        }\n+        state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END;\n+    }\n+\n+    private void maybeStartHeaders(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END;\n+        assert sb.length() == 0;\n+        char c = get(input);\n+        if(!eof) {\n+            if (c == CR) {\n+                state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END_CR;\n+            } else if (c == LF) {\n+                state = HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END_LF;\n+            } else {\n+                sb.append(c);\n+                state = HttpHeaderParser.State.HEADER;\n+            }\n+        }\n+    }\n+\n+    private void maybeEndHeaders(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END_CR || state == HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END_LF;\n+        assert sb.length() == 0;\n+        char c = state == HttpHeaderParser.State.STATUS_OR_REQUEST_LINE_END_LF ? LF : get(input);\n+        if (c == LF) {\n+            state = HttpHeaderParser.State.FINISHED;  \/\/ no headers\n+        } else {\n+            throw protocolException(\"Unexpected \\\"%s\\\", after status line CR\", c);\n+        }\n+    }\n+\n+    private void readResumeHeader(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.HEADER;\n+        assert !eof;\n+        char c = get(input);\n+        while (!eof) {\n+            if (c == CR) {\n+                state = HttpHeaderParser.State.HEADER_FOUND_CR;\n+                break;\n+            } else if (c == LF) {\n+                state = HttpHeaderParser.State.HEADER_FOUND_LF;\n+                break;\n+            }\n+            if (c == HT)\n+                c = SP;\n+            sb.append(c);\n+            c = get(input);\n+        }\n+    }\n+\n+    private void addHeaderFromString(String headerString) throws ProtocolException {\n+        assert sb.length() == 0;\n+        int idx = headerString.indexOf(':');\n+        if (idx == -1)\n+            return;\n+        String name = headerString.substring(0, idx);\n+\n+        \/\/ compatibility with HttpURLConnection;\n+        if (name.isEmpty()) return;\n+\n+        if (!isValidName(name)) {\n+            throw protocolException(\"Invalid header name \\\"%s\\\"\", name);\n+        }\n+        String value = headerString.substring(idx + 1).trim();\n+        if (!isValidValue(value)) {\n+            throw protocolException(\"Invalid header value \\\"%s: %s\\\"\", name, value);\n+        }\n+\n+        keyList.add(name);\n+        headerMap.computeIfAbsent(name.toLowerCase(Locale.US),\n+                k -> new ArrayList<>()).add(value);\n+    }\n+\n+    private void resumeOrLF(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.HEADER_FOUND_CR || state == HttpHeaderParser.State.HEADER_FOUND_LF;\n+        char c = state == HttpHeaderParser.State.HEADER_FOUND_LF ? LF : get(input);\n+        if (!eof) {\n+            if (c == LF) {\n+                state = HttpHeaderParser.State.HEADER_FOUND_CR_LF;\n+            } else if (c == SP || c == HT) {\n+                sb.append(SP); \/\/ parity with MessageHeaders\n+                state = HttpHeaderParser.State.HEADER;\n+            } else {\n+                sb = new StringBuilder();\n+                sb.append(c);\n+                state = HttpHeaderParser.State.HEADER;\n+            }\n+        }\n+    }\n+\n+    private void resumeOrSecondCR(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.HEADER_FOUND_CR_LF;\n+        char c = get(input);\n+        if (!eof) {\n+            if (c == CR || c == LF) {\n+                if (sb.length() > 0) {\n+                    \/\/ no continuation line - flush\n+                    \/\/ previous header value.\n+                    String headerString = sb.toString();\n+                    sb = new StringBuilder();\n+                    addHeaderFromString(headerString);\n+                }\n+                if (c == CR) {\n+                    state = HttpHeaderParser.State.HEADER_FOUND_CR_LF_CR;\n+                } else {\n+                    state = HttpHeaderParser.State.FINISHED;\n+                }\n+            } else if (c == SP || c == HT) {\n+                assert sb.length() != 0;\n+                sb.append(SP); \/\/ continuation line\n+                state = HttpHeaderParser.State.HEADER;\n+            } else {\n+                if (sb.length() > 0) {\n+                    \/\/ no continuation line - flush\n+                    \/\/ previous header value.\n+                    String headerString = sb.toString();\n+                    sb = new StringBuilder();\n+                    addHeaderFromString(headerString);\n+                }\n+                sb.append(c);\n+                state = HttpHeaderParser.State.HEADER;\n+            }\n+        }\n+    }\n+\n+    private void resumeOrEndHeaders(InputStream input) throws IOException {\n+        assert state == HttpHeaderParser.State.HEADER_FOUND_CR_LF_CR;\n+        char c = get(input);\n+        if (!eof) {\n+            if (c == LF) {\n+                state = HttpHeaderParser.State.FINISHED;\n+            } else {\n+                throw protocolException(\"Unexpected \\\"%s\\\", after CR LF CR\", c);\n+            }\n+        }\n+    }\n+\n+    private ProtocolException protocolException(String format, Object ... args) {\n+        return new ProtocolException(String.format(format, args));\n+    }\n+\n+    \/*\n+     * Validates a RFC 7230 field-name.\n+     *\/\n+    public boolean isValidName(String token) {\n+        for (int i = 0; i < token.length(); i++) {\n+            char c = token.charAt(i);\n+            if (c > 255 || !tchar[c]) {\n+                return false;\n+            }\n+        }\n+        return !token.isEmpty();\n+    }\n+\n+    \/*\n+     * Validates a RFC 7230 field-value.\n+     *\n+     * \"Obsolete line folding\" rule\n+     *\n+     *     obs-fold = CRLF 1*( SP \/ HTAB )\n+     *\n+     * is not permitted!\n+     *\/\n+    public boolean isValidValue(String token) {\n+        for (int i = 0; i < token.length(); i++) {\n+            char c = token.charAt(i);\n+            if (c > 255) {\n+                return false;\n+            }\n+            if (c == ' ' || c == '\\t') {\n+                continue;\n+            } else if (!fieldvchar[c]) {\n+                return false; \/\/ forbidden byte\n+            }\n+        }\n+        return true;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/net\/HttpHeaderParser.java","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"}]}