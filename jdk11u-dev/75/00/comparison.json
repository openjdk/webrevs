{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+#include \"memory\/heapInspection.hpp\"\n@@ -2123,0 +2124,24 @@\n+class G1ParallelObjectIterator : public ParallelObjectIterator {\n+private:\n+  G1CollectedHeap*  _heap;\n+  HeapRegionClaimer _claimer;\n+\n+public:\n+  G1ParallelObjectIterator(uint thread_num) :\n+      _heap(G1CollectedHeap::heap()),\n+      _claimer(thread_num == 0 ? G1CollectedHeap::heap()->workers()->active_workers() : thread_num) {}\n+\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) {\n+    _heap->object_iterate_parallel(cl, worker_id, &_claimer);\n+  }\n+};\n+\n+ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+  return new G1ParallelObjectIterator(thread_num);\n+}\n+\n+void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer) {\n+  IterateObjectClosureRegionClosure blk(cl);\n+  heap_region_par_iterate_from_worker_offset(&blk, claimer, worker_id);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1119,0 +1119,2 @@\n+  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer);\n+\n@@ -1126,0 +1128,2 @@\n+  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+class WorkGang;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/heapInspection.hpp\"\n@@ -45,0 +46,1 @@\n+class AbstractGangTask;\n@@ -86,0 +88,6 @@\n+class ParallelObjectIterator : public CHeapObj<mtGC> {\n+public:\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) = 0;\n+  virtual ~ParallelObjectIterator() {}\n+};\n+\n@@ -468,0 +476,4 @@\n+  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-  inspect.heap_inspection(_out);\n+  inspect.heap_inspection(_out, _parallel_thread_num);\n","filename":"src\/hotspot\/share\/gc\/shared\/vmGCOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,0 +128,1 @@\n+  uint _parallel_thread_num;\n@@ -133,1 +134,2 @@\n-  VM_GC_HeapInspection(outputStream* out, bool request_full_gc) :\n+  VM_GC_HeapInspection(outputStream* out, bool request_full_gc,\n+                       uint parallel_thread_num = 1) :\n@@ -140,0 +142,1 @@\n+    _parallel_thread_num = parallel_thread_num;\n","filename":"src\/hotspot\/share\/gc\/shared\/vmGCOperations.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -232,0 +232,21 @@\n+\/\/ Temporarily try to set the number of active workers.\n+\/\/ It's not guaranteed that it succeeds, and users need to\n+\/\/ query the number of active workers.\n+class WithUpdatedActiveWorkers : public StackObj {\n+private:\n+  AbstractWorkGang* const _gang;\n+  const uint              _old_active_workers;\n+\n+public:\n+  WithUpdatedActiveWorkers(AbstractWorkGang* gang, uint requested_num_workers) :\n+      _gang(gang),\n+      _old_active_workers(gang->active_workers()) {\n+    uint capped_num_workers = MIN2(requested_num_workers, gang->total_workers());\n+    gang->update_active_workers(capped_num_workers);\n+  }\n+\n+  ~WithUpdatedActiveWorkers() {\n+    _gang->update_active_workers(_old_active_workers);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -239,0 +240,35 @@\n+\/\/ Return false if the entry could not be recorded on account\n+\/\/ of running out of space required to create a new entry.\n+bool KlassInfoTable::merge_entry(const KlassInfoEntry* cie) {\n+  Klass*          k = cie->klass();\n+  KlassInfoEntry* elt = lookup(k);\n+  \/\/ elt may be NULL if it's a new klass for which we\n+  \/\/ could not allocate space for a new entry in the hashtable.\n+  if (elt != NULL) {\n+    elt->set_count(elt->count() + cie->count());\n+    elt->set_words(elt->words() + cie->words());\n+    _size_of_instances_in_words += cie->words();\n+    return true;\n+  }\n+  return false;\n+}\n+\n+class KlassInfoTableMergeClosure : public KlassInfoClosure {\n+private:\n+  KlassInfoTable* _dest;\n+  bool _success;\n+public:\n+  KlassInfoTableMergeClosure(KlassInfoTable* table) : _dest(table), _success(true) {}\n+  void do_cinfo(KlassInfoEntry* cie) {\n+    _success &= _dest->merge_entry(cie);\n+  }\n+  bool success() { return _success; }\n+};\n+\n+\/\/ merge from table\n+bool KlassInfoTable::merge(KlassInfoTable* table) {\n+  KlassInfoTableMergeClosure closure(this);\n+  table->iterate(&closure);\n+  return closure.success();\n+}\n+\n@@ -690,1 +726,1 @@\n-  size_t _missed_count;\n+  uintx _missed_count;\n@@ -704,1 +740,1 @@\n-  size_t missed_count() { return _missed_count; }\n+  uintx missed_count() { return _missed_count; }\n@@ -712,1 +748,59 @@\n-size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {\n+\/\/ Heap inspection for every worker.\n+\/\/ When native OOM happens for KlassInfoTable, set _success to false.\n+void ParHeapInspectTask::work(uint worker_id) {\n+  uintx missed_count = 0;\n+  bool merge_success = true;\n+  if (!Atomic::load(&_success)) {\n+    \/\/ other worker has failed on parallel iteration.\n+    return;\n+  }\n+\n+  KlassInfoTable cit(false);\n+  if (cit.allocation_failed()) {\n+    \/\/ fail to allocate memory, stop parallel mode\n+    Atomic::store(false, &_success);\n+    return;\n+  }\n+  RecordInstanceClosure ric(&cit, _filter);\n+  _poi->object_iterate(&ric, worker_id);\n+  missed_count = ric.missed_count();\n+  {\n+    MutexLocker x(&_mutex);\n+    merge_success = _shared_cit->merge(&cit);\n+  }\n+  if (merge_success) {\n+    Atomic::add(missed_count, &_missed_count);\n+  } else {\n+    Atomic::store(false, &_success);\n+  }\n+}\n+\n+uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, uint parallel_thread_num) {\n+\n+  \/\/ Try parallel first.\n+  if (parallel_thread_num > 1) {\n+    ResourceMark rm;\n+\n+    WorkGang* gang = Universe::heap()->get_safepoint_workers();\n+    if (gang != NULL) {\n+      \/\/ The GC provided a WorkGang to be used during a safepoint.\n+\n+      \/\/ Can't run with more threads than provided by the WorkGang.\n+      WithUpdatedActiveWorkers update_and_restore(gang, parallel_thread_num);\n+\n+      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(gang->active_workers());\n+      if (poi != NULL) {\n+        \/\/ The GC supports parallel object iteration.\n+\n+        ParHeapInspectTask task(poi, cit, filter);\n+        \/\/ Run task with the active workers.\n+        gang->run_task(&task);\n+\n+        delete poi;\n+        if (task.success()) {\n+          return task.missed_count();\n+        }\n+      }\n+    }\n+  }\n+\n@@ -714,0 +808,1 @@\n+  \/\/ If no parallel iteration available, run serially.\n@@ -720,1 +815,1 @@\n-void HeapInspection::heap_inspection(outputStream* st) {\n+void HeapInspection::heap_inspection(outputStream* st, uint parallel_thread_num) {\n@@ -744,1 +839,1 @@\n-    size_t missed_count = populate_table(&cit);\n+    uintx missed_count = populate_table(&cit, NULL, parallel_thread_num);\n@@ -746,1 +841,1 @@\n-      st->print_cr(\"WARNING: Ran out of C-heap; undercounted \" SIZE_FORMAT\n+      st->print_cr(\"WARNING: Ran out of C-heap; undercounted \" UINTX_FORMAT\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":102,"deletions":7,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+#include \"gc\/shared\/workgroup.hpp\"\n+\n+class ParallelObjectIterator;\n@@ -264,0 +267,2 @@\n+  bool merge(KlassInfoTable* table);\n+  bool merge_entry(const KlassInfoEntry* cie);\n@@ -367,2 +372,2 @@\n-  void heap_inspection(outputStream* st) NOT_SERVICES_RETURN;\n-  size_t populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL) NOT_SERVICES_RETURN_(0);\n+  void heap_inspection(outputStream* st, uint parallel_thread_num = 1) NOT_SERVICES_RETURN;\n+  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n@@ -374,0 +379,34 @@\n+\/\/ Parallel heap inspection task. Parallel inspection can fail due to\n+\/\/ a native OOM when allocating memory for TL-KlassInfoTable.\n+\/\/ _success will be set false on an OOM, and serial inspection tried.\n+class ParHeapInspectTask : public AbstractGangTask {\n+ private:\n+  ParallelObjectIterator* _poi;\n+  KlassInfoTable* _shared_cit;\n+  BoolObjectClosure* _filter;\n+  uintx _missed_count;\n+  bool _success;\n+  Mutex _mutex;\n+\n+ public:\n+  ParHeapInspectTask(ParallelObjectIterator* poi,\n+                     KlassInfoTable* shared_cit,\n+                     BoolObjectClosure* filter) :\n+      AbstractGangTask(\"Iterating heap\"),\n+      _poi(poi),\n+      _shared_cit(shared_cit),\n+      _filter(filter),\n+      _missed_count(0),\n+      _success(true),\n+      _mutex(Mutex::leaf, \"Parallel heap iteration data merge lock\") {}\n+\n+  uintx missed_count() const {\n+    return _missed_count;\n+  }\n+\n+  bool success() {\n+    return _success;\n+  }\n+\n+  virtual void work(uint worker_id);\n+};\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -453,6 +453,0 @@\n-  \/\/ Parse a string for a unsigned integer.  Returns true if value\n-  \/\/ is an unsigned integer greater than or equal to the minimum\n-  \/\/ parameter passed and returns the value in uintx_arg.  Returns\n-  \/\/ false otherwise, with uintx_arg undefined.\n-  static bool parse_uintx(const char* value, uintx* uintx_arg,\n-                          uintx min_size);\n@@ -496,0 +490,6 @@\n+  \/\/ Parse a string for a unsigned integer.  Returns true if value\n+  \/\/ is an unsigned integer greater than or equal to the minimum\n+  \/\/ parameter passed and returns the value in uintx_arg.  Returns\n+  \/\/ false otherwise, with uintx_arg undefined.\n+  static bool parse_uintx(const char* value, uintx* uintx_arg,\n+                          uintx min_size);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,1 @@\n+\/\/   arg1: parallel thread number\n@@ -264,0 +265,1 @@\n+  uint parallel_thread_num = MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8);\n@@ -271,1 +273,12 @@\n-  VM_GC_HeapInspection heapop(out, live_objects_only \/* request full gc *\/);\n+\n+  const char* num_str = op->arg(1);\n+  if (num_str != NULL && num_str[0] != '\\0') {\n+    uintx num;\n+    if (!Arguments::parse_uintx(num_str, &num, 0)) {\n+      out->print_cr(\"Invalid parallel thread number: [%s]\", num_str);\n+      return JNI_ERR;\n+    }\n+    parallel_thread_num = num == 0 ? parallel_thread_num : (uint)num;\n+  }\n+\n+  VM_GC_HeapInspection heapop(out, live_objects_only \/* request full gc *\/, parallel_thread_num);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,8 +152,18 @@\n-        if (options.equals(\"\") || options.equals(\"all\")) {\n-            \/\/  pass\n-        }\n-        else if (options.equals(\"live\")) {\n-            liveopt = \"-live\";\n-        }\n-        else {\n-            usage(1);\n+        String parallel = null;\n+        String subopts[] = options.split(\",\");\n+        for (int i = 0; i < subopts.length; i++) {\n+            String subopt = subopts[i];\n+            if (subopt.equals(\"\") || options.equals(\"all\")) {\n+                \/\/  pass\n+            } else if (subopt.equals(\"live\")) {\n+                liveopt = \"-live\";\n+            } else if (subopt.startsWith(\"parallel=\")) {\n+                parallel = subopt.substring(\"parallel=\".length());\n+                if (parallel == null) {\n+                    System.err.println(\"Fail: no number provided in option: '\" + subopt + \"'\");\n+                    usage(1);\n+                }\n+            } else {\n+                System.err.println(\"Fail: invalid option: '\" + subopt + \"'\");\n+                usage(1);\n+            }\n@@ -162,0 +172,1 @@\n+        System.out.flush();\n@@ -163,1 +174,1 @@\n-        executeCommandForPid(pid, \"inspectheap\", liveopt);\n+        executeCommandForPid(pid, \"inspectheap\", liveopt, parallel);\n@@ -187,1 +198,2 @@\n-            usage(1);  \/\/ invalid options or no filename\n+            System.err.println(\"Fail: invalid option or no file name\");\n+            usage(1);\n@@ -262,0 +274,4 @@\n+        System.err.println(\"      parallel=<number>  parallel threads number for heap iteration:\");\n+        System.err.println(\"                         parallel=0 default behavior, use predefined number of threads\");\n+        System.err.println(\"                         parallel=1 disable parallel heap iteration\");\n+        System.err.println(\"                         parallel=<N> use N threads for parallel heap iteration\");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,15 @@\n+    private static void testHistoParallelZero() throws Exception {\n+        OutputAnalyzer output = jmap(\"-histo:parallel=0\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testHistoParallel() throws Exception {\n+        OutputAnalyzer output = jmap(\"-histo:parallel=2\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testHistoNonParallel() throws Exception {\n+        OutputAnalyzer output = jmap(\"-histo:parallel=1\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n","filename":"test\/jdk\/sun\/tools\/jmap\/BasicJMapTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}