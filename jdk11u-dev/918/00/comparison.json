{"files":[{"patch":"@@ -26,2 +26,3 @@\n- * @bug 4533243\n- * @summary Closing a keep alive stream gives NullPointerException\n+ * @bug 4533243 8263364\n+ * @summary Closing a keep alive stream should not give NullPointerException and should accept a connection from  a\n+ *          client only from this test\n@@ -35,0 +36,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -38,5 +42,2 @@\n-    static class XServer extends Thread {\n-        ServerSocket srv;\n-        Socket s;\n-        InputStream is;\n-        OutputStream os;\n+    private final static String path = \"\/KeepAliveStreamCloseWithWrongContentLength\";\n+    private final static String getRequest1stLine = \"GET \/KeepAliveStreamCloseWithWrongContentLength\";\n@@ -44,2 +45,14 @@\n-        XServer (ServerSocket s) {\n-            srv = s;\n+    static class XServer extends Thread implements AutoCloseable {\n+\n+        final ServerSocket serverSocket;\n+        volatile Socket clientSocket;\n+\n+        XServer (InetAddress address) throws IOException {\n+            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n+            ServerSocket serversocket = serverSocketChannel.socket();\n+            serversocket.bind(new InetSocketAddress(address, 0));\n+            this.serverSocket = serversocket;\n+        }\n+\n+        public int getLocalPort() {\n+            return serverSocket.getLocalPort();\n@@ -49,0 +62,1 @@\n+\n@@ -50,6 +64,26 @@\n-                s = srv.accept ();\n-                \/\/ read HTTP request from client\n-                InputStream is = s.getInputStream();\n-                \/\/ read the first ten bytes\n-                for (int i=0; i<10; i++) {\n-                    is.read();\n+                ByteArrayOutputStream clientBytes;\n+                clientSocket = null;\n+\n+                \/\/ in a concurrent test environment it can happen that other rouge clients connect to this server\n+                \/\/ so we need to identify and connect only to the client from this test\n+                \/\/ if the rouge client sends as least bytes as there is in getRequest1stLine it will be discarded and\n+                \/\/ the test should proceed otherwise it should timeout on readNBytes below\n+                do {\n+                    if (clientSocket != null) {\n+                        final String client =\n+                            clientSocket.getInetAddress().getHostAddress() + \":\" +\n+                            clientSocket.getPort();\n+                        try {\n+                            clientSocket.close();\n+                        }\n+                        catch (IOException ioe) {\n+                            ioe.printStackTrace();\n+                        }\n+                        finally {\n+                            System.err.println(\"rogue client (\" + client + \") connection attempt, ignoring\");\n+                        }\n+                    }\n+                    clientSocket = serverSocket.accept();\n+                    \/\/ read HTTP request from client\n+                    clientBytes = new ByteArrayOutputStream();\n+                    clientBytes.write(clientSocket.getInputStream().readNBytes(getRequest1stLine.getBytes().length));\n@@ -57,3 +91,8 @@\n-                OutputStreamWriter ow =\n-                    new OutputStreamWriter((os = s.getOutputStream()));\n-                ow.write(\"HTTP\/1.0 200 OK\\n\");\n+                while(!getRequest1stLine.equals(clientBytes.toString()));\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try  {\n+                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(clientSocket.getOutputStream());\n+                outputStreamWriter.write(\"HTTP\/1.0 200 OK\\n\");\n@@ -62,2 +101,2 @@\n-                ow.write(\"Content-Length: 10\\n\");\n-                ow.write(\"Content-Type: text\/html\\n\");\n+                outputStreamWriter.write(\"Content-Length: 10\\n\");\n+                outputStreamWriter.write(\"Content-Type: text\/html\\n\");\n@@ -66,2 +105,2 @@\n-                ow.write(\"Connection: Keep-Alive\\n\");\n-                ow.write(\"\\n\");\n+                outputStreamWriter.write(\"Connection: Keep-Alive\\n\");\n+                outputStreamWriter.write(\"\\n\");\n@@ -70,5 +109,18 @@\n-                ow.write(\"123456789\");\n-                ow.flush();\n-            } catch (Exception e) {\n-            } finally {\n-                try {if (os != null) { os.close(); }} catch (IOException e) {}\n+                outputStreamWriter.write(\"123456789\");\n+                outputStreamWriter.flush();\n+                clientSocket.getChannel().shutdownOutput();\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            final var clientSocket = this.clientSocket;\n+            try {\n+                long drained = drain(clientSocket.getChannel());\n+                System.err.printf(\"Server drained %d bytes from the channel%n\", drained);\n+            } catch (Exception x) {\n+                System.err.println(\"Server failed to drain client socket: \" + x);\n+                x.printStackTrace();\n@@ -76,0 +128,1 @@\n+            serverSocket.close();\n@@ -77,0 +130,1 @@\n+\n@@ -79,0 +133,22 @@\n+    static long drain(SocketChannel channel) throws IOException {\n+        if (!channel.isOpen()) return 0;\n+        System.err.println(\"Not reading server: draining socket\");\n+        var blocking = channel.isBlocking();\n+        if (blocking) channel.configureBlocking(false);\n+        long count = 0;\n+        try {\n+            ByteBuffer buffer = ByteBuffer.allocateDirect(8 * 1024);\n+            int read;\n+            while ((read = channel.read(buffer)) > 0) {\n+                count += read;\n+                buffer.clear();\n+            }\n+            return count;\n+        } finally {\n+            if (blocking != channel.isBlocking()) {\n+                channel.configureBlocking(blocking);\n+            }\n+        }\n+    }\n+\n+\n@@ -80,0 +156,1 @@\n+\n@@ -81,2 +158,0 @@\n-        final ServerSocket serversocket = new ServerSocket();\n-        serversocket.bind(new InetSocketAddress(loopback, 0));\n@@ -84,4 +159,2 @@\n-        try {\n-            int port = serversocket.getLocalPort ();\n-            XServer server = new XServer (serversocket);\n-            server.start ();\n+        try (XServer server = new XServer(loopback)) {\n+            server.start();\n@@ -91,1 +164,2 @@\n-                .port(port)\n+                .path(path)\n+                .port(server.getLocalPort())\n@@ -94,1 +168,1 @@\n-            InputStream is = urlc.getInputStream ();\n+            InputStream is = urlc.getInputStream();\n@@ -99,0 +173,1 @@\n+                    System.out.println(\"client reads: \"+c);\n@@ -105,6 +180,0 @@\n-        } catch (IOException e) {\n-            return;\n-        } catch (NullPointerException e) {\n-            throw new RuntimeException (e);\n-        } finally {\n-            serversocket.close();\n@@ -112,0 +181,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":111,"deletions":41,"binary":false,"changes":152,"status":"modified"}]}