{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-ifeq ($(call isTargetOs, solaris linux macosx), true)\n+ifeq ($(call isTargetOs, solaris linux macosx windows), true)\n@@ -38,1 +38,1 @@\n-      LIBS := -ljava, \\\n+      LIBS_unix := -ljava, \\\n@@ -41,0 +41,1 @@\n+      LIBS_windows := jvm.lib ws2_32.lib $(WIN_JAVA_LIB), \\\n","filename":"make\/lib\/Lib-jdk.net.gmk","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -34,0 +37,2 @@\n+import sun.net.ext.ExtendedSocketOptions;\n+import static sun.net.ext.ExtendedSocketOptions.SOCK_STREAM;\n@@ -55,0 +60,3 @@\n+    static final ExtendedSocketOptions extendedOptions =\n+            ExtendedSocketOptions.getInstance();\n+\n@@ -305,0 +313,37 @@\n+    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {\n+        if (isClosedOrPending()) {\n+            throw new SocketException(\"Socket closed\");\n+        }\n+        if (supportedOptions().contains(name)) {\n+            if (extendedOptions.isOptionSupported(name)) {\n+                extendedOptions.setOption(fd, name, value);\n+            } else {\n+                super.setOption(name, value);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"unsupported option\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T getOption(SocketOption<T> name) throws IOException {\n+        if (isClosedOrPending()) {\n+            throw new SocketException(\"Socket closed\");\n+        }\n+        if (supportedOptions().contains(name)) {\n+            if (extendedOptions.isOptionSupported(name)) {\n+                return (T) extendedOptions.getOption(fd, name);\n+            } else {\n+                return super.getOption(name);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"unsupported option\");\n+        }\n+    }\n+\n+    protected Set<SocketOption<?>> supportedOptions() {\n+        HashSet<SocketOption<?>> options = new HashSet<>(super.supportedOptions());\n+        options.addAll(ExtendedSocketOptions.options(SOCK_STREAM));\n+        return options;\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/java\/net\/PlainSocketImpl.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n-        setTcpkeepAliveProbes0(fd, value);\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n@@ -73,2 +73,2 @@\n-    int getTcpkeepAliveProbes(int fd) throws SocketException {\n-        return getTcpkeepAliveProbes0(fd);\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n@@ -87,1 +87,1 @@\n-    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n@@ -90,1 +90,1 @@\n-    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n- * Method:    setTcpkeepAliveProbes0\n+ * Method:    setTcpKeepAliveProbes0\n@@ -152,1 +152,1 @@\n-JNIEXPORT void JNICALL Java_jdk_net_LinuxSocketOptions_setTcpkeepAliveProbes0\n+JNIEXPORT void JNICALL Java_jdk_net_LinuxSocketOptions_setTcpKeepAliveProbes0\n@@ -182,1 +182,1 @@\n- * Method:    getTcpkeepAliveProbes0\n+ * Method:    getTcpKeepAliveProbes0\n@@ -185,1 +185,1 @@\n-JNIEXPORT jint JNICALL Java_jdk_net_LinuxSocketOptions_getTcpkeepAliveProbes0\n+JNIEXPORT jint JNICALL Java_jdk_net_LinuxSocketOptions_getTcpKeepAliveProbes0\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n-        setTcpkeepAliveProbes0(fd, value);\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n@@ -58,2 +58,2 @@\n-    int getTcpkeepAliveProbes(int fd) throws SocketException {\n-        return getTcpkeepAliveProbes0(fd);\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n@@ -72,1 +72,1 @@\n-    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n@@ -75,1 +75,1 @@\n-    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- * Method:    setTcpkeepAliveProbes0\n+ * Method:    setTcpKeepAliveProbes0\n@@ -84,1 +84,1 @@\n-JNIEXPORT void JNICALL Java_jdk_net_MacOSXSocketOptions_setTcpkeepAliveProbes0\n+JNIEXPORT void JNICALL Java_jdk_net_MacOSXSocketOptions_setTcpKeepAliveProbes0\n@@ -114,1 +114,1 @@\n- * Method:    getTcpkeepAliveProbes0\n+ * Method:    getTcpKeepAliveProbes0\n@@ -117,1 +117,1 @@\n-JNIEXPORT jint JNICALL Java_jdk_net_MacOSXSocketOptions_getTcpkeepAliveProbes0\n+JNIEXPORT jint JNICALL Java_jdk_net_MacOSXSocketOptions_getTcpKeepAliveProbes0\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-                    setTcpkeepAliveProbes(fd, (Integer) value);\n+                    setTcpKeepAliveProbes(fd, (Integer) value);\n@@ -244,1 +244,1 @@\n-                    return getTcpkeepAliveProbes(fd);\n+                    return getTcpKeepAliveProbes(fd);\n@@ -293,1 +293,1 @@\n-    private static void setTcpkeepAliveProbes(FileDescriptor fd, int value)\n+    private static void setTcpKeepAliveProbes(FileDescriptor fd, int value)\n@@ -295,1 +295,1 @@\n-        platformSocketOptions.setTcpkeepAliveProbes(fdAccess.get(fd), value);\n+        platformSocketOptions.setTcpKeepAliveProbes(fdAccess.get(fd), value);\n@@ -308,2 +308,2 @@\n-    private static int getTcpkeepAliveProbes(FileDescriptor fd) throws SocketException {\n-        return platformSocketOptions.getTcpkeepAliveProbes(fdAccess.get(fd));\n+    private static int getTcpKeepAliveProbes(FileDescriptor fd) throws SocketException {\n+        return platformSocketOptions.getTcpKeepAliveProbes(fdAccess.get(fd));\n@@ -348,0 +348,2 @@\n+            } else if (osname.startsWith(\"Windows\")) {\n+                return newInstance(\"jdk.net.WindowsSocketOptions\");\n@@ -389,1 +391,1 @@\n-        void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n+        void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n@@ -401,1 +403,1 @@\n-        int getTcpkeepAliveProbes(int fd) throws SocketException {\n+        int getTcpKeepAliveProbes(int fd) throws SocketException {\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.net;\n+\n+import java.net.SocketException;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import jdk.net.ExtendedSocketOptions.PlatformSocketOptions;\n+\n+\n+@SuppressWarnings(\"removal\")\n+class WindowsSocketOptions extends PlatformSocketOptions {\n+\n+    public WindowsSocketOptions() {\n+    }\n+\n+    @Override\n+    boolean keepAliveOptionsSupported() {\n+        return keepAliveOptionsSupported0();\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveTime(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveTime0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveTime(int fd) throws SocketException {\n+        return getTcpKeepAliveTime0(fd);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveIntvl(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveIntvl0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveIntvl(int fd) throws SocketException {\n+        return getTcpKeepAliveIntvl0(fd);\n+    }\n+\n+    private static native boolean keepAliveOptionsSupported0();\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n+    private static native void setTcpKeepAliveTime0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveTime0(int fd) throws SocketException;\n+    private static native void setTcpKeepAliveIntvl0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveIntvl0(int fd) throws SocketException;\n+\n+    static {\n+        if (System.getSecurityManager() == null) {\n+            System.loadLibrary(\"extnet\");\n+        } else {\n+            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+                System.loadLibrary(\"extnet\");\n+                return null;\n+            });\n+        }\n+    }\n+}\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include <WS2tcpip.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+\n+static void handleError(JNIEnv *env, jint rv, const char *errmsg) {\n+    if (rv < 0) {\n+        int error = WSAGetLastError();\n+        if (error == WSAENOPROTOOPT) {\n+            JNU_ThrowByName(env, \"java\/lang\/UnsupportedOperationException\",\n+                    \"unsupported socket option\");\n+        } else {\n+            JNU_ThrowByNameWithLastError(env, \"java\/net\/SocketException\", errmsg);\n+        }\n+    }\n+}\n+\n+static jint socketOptionSupported(jint level, jint optname) {\n+    WSADATA wsaData;\n+    jint error = WSAStartup(MAKEWORD(2, 2), &wsaData);\n+\n+    if (error != 0) {\n+        return 0;\n+    }\n+\n+    SOCKET sock;\n+    jint one = 1;\n+    jint rv;\n+    socklen_t sz = sizeof(one);\n+\n+    \/* First try IPv6; fall back to IPv4. *\/\n+    sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);\n+    if (sock == INVALID_SOCKET) {\n+        error = WSAGetLastError();\n+        if (error == WSAEPFNOSUPPORT || error == WSAEAFNOSUPPORT) {\n+            sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+        }\n+        if (sock == INVALID_SOCKET) {\n+            return 0;\n+        }\n+    }\n+\n+    rv = getsockopt(sock, level, optname, (char*) &one, &sz);\n+    error = WSAGetLastError();\n+\n+    if (rv != 0 && error == WSAENOPROTOOPT) {\n+        rv = 0;\n+    } else {\n+        rv = 1;\n+    }\n+\n+    closesocket(sock);\n+    WSACleanup();\n+\n+    return rv;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    keepAliveOptionsSupported0\n+ * Signature: ()Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_WindowsSocketOptions_keepAliveOptionsSupported0\n+(JNIEnv *env, jobject unused) {\n+    return socketOptionSupported(IPPROTO_TCP, TCP_KEEPIDLE) && socketOptionSupported(IPPROTO_TCP, TCP_KEEPCNT)\n+            && socketOptionSupported(IPPROTO_TCP, TCP_KEEPINTVL);\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveProbes0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPCNT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveProbes0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPCNT failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveTime0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPIDLE failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveTime0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPIDLE failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveIntvl0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPINTVL failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveIntvl0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPINTVL failed\");\n+    return optval;\n+}\n+\n","filename":"src\/jdk.net\/windows\/native\/libextnet\/WindowsSocketOptions.c","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}