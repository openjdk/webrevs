{"files":[{"patch":"@@ -80,2 +80,9 @@\n-     * any previous entry. The default compression method will be\n-     * used if no compression method was specified for the entry.\n+     * any previous entry.\n+     * <p>\n+     * The default compression method will be used if no compression\n+     * method was specified for the entry. When writing a compressed\n+     * (DEFLATED) entry, and the compressed size has not been explicitly\n+     * set with the {@link ZipEntry#setCompressedSize(long)} method,\n+     * then the compressed size will be set to the actual compressed\n+     * size after deflation.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarOutputStream.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    boolean csizeSet = false; \/\/ Only true if csize was explicitely set by\n+                        \/\/ a call to setCompressedSize()\n@@ -131,0 +133,1 @@\n+        csizeSet = e.csizeSet;\n@@ -451,0 +454,1 @@\n+        this.csizeSet = true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+     * <p>\n@@ -184,5 +185,10 @@\n-     * was specified for the entry, and the current time will be used if\n-     * the entry has no set modification time.\n-     * @param e the ZIP entry to be written\n-     * @exception ZipException if a ZIP format error has occurred\n-     * @exception IOException if an I\/O error has occurred\n+     * was specified for the entry. When writing a compressed (DEFLATED)\n+     * entry, and the compressed size has not been explicitly set with the\n+     * {@link ZipEntry#setCompressedSize(long)} method, then the compressed\n+     * size will be set to the actual compressed size after deflation.\n+     * <p>\n+     * The current time will be used if the entry has no set modification time.\n+     *\n+     * @param     e the ZIP entry to be written\n+     * @throws    ZipException if a ZIP format error has occurred\n+     * @throws    IOException if an I\/O error has occurred\n@@ -207,3 +213,6 @@\n-            \/\/ store size, compressed size, and crc-32 in data descriptor\n-            \/\/ immediately following the compressed entry data\n-            if (e.size  == -1 || e.csize == -1 || e.crc   == -1)\n+            \/\/ If not set, store size, compressed size, and crc-32 in data\n+            \/\/ descriptor immediately following the compressed entry data.\n+            \/\/ Ignore the compressed size of a ZipEntry if it was implcitely set\n+            \/\/ while reading that ZipEntry from a  ZipFile or ZipInputStream because\n+            \/\/ we can't know the compression level of the source zip file\/stream.\n+            if (e.size  == -1 || e.csize == -1 || e.crc   == -1 || !e.csizeSet) {\n@@ -211,1 +220,1 @@\n-\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test behaviour when copying ZipEntries between zip files.\n+ * @run main\/othervm CopyZipFile\n+ *\/\n+\n+import java.io.File;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Enumeration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+public class CopyZipFile {\n+    private static final String ZIP_FILE = \"first.zip\";\n+    private static final String TEST_STRING = \"TestTestTest\";\n+\n+    private static void createZip(String zipFile) throws Exception {\n+        File f = new File(zipFile);\n+        f.deleteOnExit();\n+        try (OutputStream os = new FileOutputStream(f);\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            \/\/ First file will be compressed with DEFAULT_COMPRESSION (i.e. -1 or 6)\n+            zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n+            zos.write(TEST_STRING.getBytes());\n+            zos.closeEntry();\n+            \/\/ Second file won't be compressed at all (i.e. STORED)\n+            zos.setMethod(ZipOutputStream.STORED);\n+            ZipEntry ze = new ZipEntry(\"test2.txt\");\n+            int length = TEST_STRING.length();\n+            ze.setSize(length);\n+            ze.setCompressedSize(length);\n+            CRC32 crc = new CRC32();\n+            crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+            ze.setCrc(crc.getValue());\n+            zos.putNextEntry(ze);\n+            zos.write(TEST_STRING.getBytes());\n+            \/\/ Third file will be compressed with NO_COMPRESSION (i.e. 0)\n+            zos.setMethod(ZipOutputStream.DEFLATED);\n+            zos.setLevel(Deflater.NO_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n+            zos.write(TEST_STRING.getBytes());\n+            \/\/ Fourth file will be compressed with BEST_SPEED (i.e. 1)\n+            zos.setLevel(Deflater.BEST_SPEED);\n+            zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n+            zos.write(TEST_STRING.getBytes());\n+            \/\/ Fifth file will be compressed with BEST_COMPRESSION (i.e. 9)\n+            zos.setLevel(Deflater.BEST_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n+            zos.write(TEST_STRING.getBytes());\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressedSize and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        createZip(ZIP_FILE);\n+\n+        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n+        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n+        \/\/ This only works reliably because the generated zip file has no values for the\n+        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n+        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n+        \/\/ all these fields set to '-1'.\n+        ZipEntry entry;\n+        byte[] buf = new byte[512];\n+        try (InputStream is = new FileInputStream(ZIP_FILE);\n+             ZipInputStream zis = new ZipInputStream(is);\n+             OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os)) {\n+            while((entry = zis.getNextEntry())!=null) {\n+                \/\/ ZipInputStream.getNextEntry() only reads the Local File Header of a zip entry,\n+                \/\/ so for the zip file we've just generated the ZipEntry fields 'size', 'compressedSize`\n+                \/\/ and 'crc' for deflated entries should be uninitialized (i.e. '-1').\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED &&\n+                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n+                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                }\n+                zos.putNextEntry(entry);\n+                zis.transferTo(zos);\n+                \/\/ After all the data belonging to a zip entry has been inflated (i.e. after ZipInputStream.read()\n+                \/\/ returned '-1'), it is guaranteed that the ZipInputStream will also have consumed the Data\n+                \/\/ Descriptor (if any) after the data and will have updated the 'size', 'compressedSize' and 'crc'\n+                \/\/ fields of the ZipEntry object.\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+                }\n+            }\n+        }\n+\n+        \/\/ Now we read all the entries of the initially generated zip file with the help\n+        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n+        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n+        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n+        \/\/ settings for these fields.\n+        \/\/ If the compression level was different in the initial zip file (which we can't find\n+        \/\/ out any more now because the zip file format doesn't record this information) the\n+        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n+        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+        \/\/ or ZipInputStream.\n+        try (OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os);\n+             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+            Enumeration<? extends ZipEntry> entries = zf.entries();\n+            while (entries.hasMoreElements()) {\n+                entry = entries.nextElement();\n+                System.out.println(\n+                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                  entry.getName(), entry.getCompressedSize(),\n+                                  entry.getSize(), entry.getCrc()));\n+                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n+                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n+                }\n+                InputStream is = zf.getInputStream(entry);\n+                zos.putNextEntry(entry);\n+                is.transferTo(zos);\n+                zos.closeEntry();\n+            }\n+        }\n+\n+        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n+        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n+        try (OutputStream os = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(os);\n+             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+            Enumeration<? extends ZipEntry> entries = zf.entries();\n+            while (entries.hasMoreElements()) {\n+                try {\n+                    entry = entries.nextElement();\n+                    entry.setCompressedSize(entry.getCompressedSize());\n+                    InputStream is = zf.getInputStream(entry);\n+                    zos.putNextEntry(entry);\n+                    is.transferTo(zos);\n+                    zos.closeEntry();\n+                    if (\"test3.txt\".equals(entry.getName())) {\n+                        throw new Exception(\n+                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n+                    }\n+                } catch (ZipException ze) {\n+                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n+                        throw new Exception(\n+                            \"Shouldn't throw a ZipExcpetion for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    }\n+                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n+                    \/\/ The exception message is something like:\n+                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                    \/\/ and we need to extract the second integer.\n+                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                    Matcher m = cSize.matcher(ze.getMessage());\n+                    m.find();\n+                    m.find();\n+                    entry.setCompressedSize(Integer.parseInt(m.group()));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}