{"files":[{"patch":"@@ -35,0 +35,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -39,1 +41,1 @@\n-class CgroupSubsystemFactory {\n+public class CgroupSubsystemFactory {\n@@ -48,1 +50,1 @@\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+        Optional<CgroupTypeResult> optResult = null;\n@@ -50,14 +52,1 @@\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n-            for (String line : lines) {\n-                if (line.startsWith(\"#\")) {\n-                    continue;\n-                }\n-                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n-                switch (info.getName()) {\n-                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n-                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n-                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n-                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n-                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n-                }\n-            }\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n@@ -68,10 +57,2 @@\n-        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n-        boolean isCgroupsV2 = true;\n-        boolean anyControllersEnabled = false;\n-        boolean anyCgroupsV2Controller = false;\n-        boolean anyCgroupsV1Controller = false;\n-        for (CgroupInfo info: infos.values()) {\n-            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n-            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n-            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n-            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        if (optResult.isEmpty()) {\n+            return null;\n@@ -79,0 +60,1 @@\n+        CgroupTypeResult result = optResult.get();\n@@ -81,1 +63,1 @@\n-        if (!anyControllersEnabled) {\n+        if (!result.isAnyControllersEnabled()) {\n@@ -84,0 +66,1 @@\n+\n@@ -87,1 +70,1 @@\n-        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+        if (result.isAnyCgroupV1Controllers() && result.isAnyCgroupV2Controllers()) {\n@@ -93,1 +76,1 @@\n-        if (isCgroupsV2) {\n+        if (result.isCgroupV2()) {\n@@ -101,0 +84,79 @@\n+\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        for (String line : lines) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+            switch (info.getName()) {\n+            case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+            case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+            case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+            case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+            case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+            }\n+        }\n+\n+        \/\/ For cgroups v2 all controllers need to have zero hierarchy id\n+        \/\/ and \/proc\/self\/mountinfo needs to have at least one cgroup filesystem\n+        \/\/ mounted. Note that hybrid hierarchy has controllers mounted via\n+        \/\/ cgroup v1. In that case hierarchy id's will be non-zero.\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If there are no mounted controllers in mountinfo, but we've only\n+        \/\/ seen 0 hierarchy IDs in \/proc\/cgroups, we are on a cgroups v1 system.\n+        \/\/ However, continuing in that case does not make sense as we'd need\n+        \/\/ information from mountinfo for the mounted controller paths anyway.\n+        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n+            boolean anyCgroupMounted = mntInfo.anyMatch(line -> line.contains(\"cgroup\"));\n+            if (!anyCgroupMounted && isCgroupsV2) {\n+                return Optional.empty();\n+            }\n+        }\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+        return Optional.of(result);\n+    }\n+\n+    public static final class CgroupTypeResult {\n+        private final boolean isCgroupV2;\n+        private final boolean anyControllersEnabled;\n+        private final boolean anyCgroupV2Controllers;\n+        private final boolean anyCgroupV1Controllers;\n+\n+        private CgroupTypeResult(boolean isCgroupV2,\n+                                 boolean anyControllersEnabled,\n+                                 boolean anyCgroupV2Controllers,\n+                                 boolean anyCgroupV1Controllers) {\n+            this.isCgroupV2 = isCgroupV2;\n+            this.anyControllersEnabled = anyControllersEnabled;\n+            this.anyCgroupV1Controllers = anyCgroupV1Controllers;\n+            this.anyCgroupV2Controllers = anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isCgroupV2() {\n+            return isCgroupV2;\n+        }\n+\n+        public boolean isAnyControllersEnabled() {\n+            return anyControllersEnabled;\n+        }\n+\n+        public boolean isAnyCgroupV2Controllers() {\n+            return anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isAnyCgroupV1Controllers() {\n+            return anyCgroupV1Controllers;\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":91,"deletions":29,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemFactory;\n+import jdk.internal.platform.CgroupSubsystemFactory.CgroupTypeResult;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @run junit\/othervm TestCgroupSubsystemFactory\n+ *\/\n+public class TestCgroupSubsystemFactory {\n+\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String mntInfoHybrid =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  9   1   1\\n\" +\n+            \"cpu 7   1   1\\n\" +\n+            \"cpuacct 7   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testHybridCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"hybrid hierarchy expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"zero hierarchy ids with no mounted controllers => empty result\", result.isEmpty());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV2() throws IOException {\n+        String cgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"zero hierarchy ids with mounted controllers expected cgroups v2\", res.isCgroupV2());\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void mountInfoFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = Paths.get(existingDirectory.toString(), \"not-existing-mountinfo\").toString();\n+\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void cgroupsFileNotFound() throws IOException {\n+        String cgroups = Paths.get(existingDirectory.toString(), \"not-existing-cgroups\").toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"}]}