{"files":[{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4085183 8000630\n+  @summary tests that clipboard contents is retrieved even if the app didn't\n+           receive native events for a long time.\n+  @requires (os.family != \"mac\")\n+  @key headful\n+  @run main DelayedQueryTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.InputEvent;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class DelayedQueryTest implements ClipboardOwner, Runnable {\n+    int returnCode = Child.CHILD_RETURN_CODE_NOT_READY;\n+\n+    Process childProcess = null;\n+    Frame frame;\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, InvocationTargetException {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName.toLowerCase().contains(\"os x\")) {\n+            System.out.println(\"This test is not for MacOS, considered passed.\");\n+            return;\n+        }\n+        DelayedQueryTest delayedQueryTest = new DelayedQueryTest();\n+        EventQueue.invokeAndWait(delayedQueryTest::initAndShowGui);\n+        try {\n+            delayedQueryTest.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> delayedQueryTest.frame.dispose());\n+        }\n+    }\n+\n+    public void initAndShowGui(){\n+        frame = new Frame(\"DelayedQueryTest\");\n+        frame.add(new Panel());\n+        frame.setBounds(200,200, 200, 200);\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() {\n+        try {\n+            Robot robot = new Robot();\n+            \/\/ Some mouse activity to update the Xt time stamp at\n+            \/\/ the parent process.\n+            robot.delay(1000);\n+            robot.waitForIdle();\n+\n+            Point p = frame.getLocationOnScreen();\n+            robot.mouseMove(p.x + 100, p.y + 100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        } catch (AWTException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+        Child.sysClipboard.setContents(Child.transferable, this);\n+\n+        String javaPath = System.getProperty(\"java.home\", \"\");\n+        String[] command = {\n+                javaPath + File.separator + \"bin\" + File.separator + \"java\",\n+                \"-cp\", System.getProperty(\"test.classes\", \".\"),\n+                \"Child\"\n+        };\n+\n+        try {\n+            Process process = Runtime.getRuntime().exec(command);\n+            childProcess = process;\n+            returnCode = process.waitFor();\n+            childProcess = null;\n+\n+            InputStream errorStream = process.getErrorStream();\n+            int count = errorStream.available();\n+            if (count > 0) {\n+                byte[] b = new byte[count];\n+                errorStream.read(b);\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(new String(b));\n+                System.err.println(\"======================================\");\n+            }\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+        if (returnCode != Child.CHILD_RETURN_CODE_OK) {\n+            System.err.println(\"Child VM: returned \" + returnCode);\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+    } \/\/ start()\n+\n+    public void lostOwnership(Clipboard clipboard,\n+                              Transferable contents) {\n+        \/\/ At this moment the child process has definitely started.\n+        \/\/ So we can try to retrieve the clipboard contents set\n+        \/\/ by the child process.\n+        new Thread(this).start();\n+    }\n+\n+    public void run() {\n+        \/\/ We are going to check if it is possible to retrieve the data\n+        \/\/ after the child process has set the clipboard contents twice,\n+        \/\/ since after the first setting the retrieval is always successful.\n+        \/\/ So we wait to let the child process set the clipboard contents\n+        \/\/ twice.\n+        try {\n+            Thread.sleep(Child.CHILD_SELECTION_CHANGE_TIMEOUT);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+\n+        try {\n+            String s = (String)Child.sysClipboard\n+                    .getContents(null)\n+                    .getTransferData(DataFlavor.stringFlavor);\n+            if (!\"String\".equals(s)) {\n+                System.err.println(\"Data retrieved: \" + s);\n+                throw new RuntimeException(\"Retrieved data is incorrect.\");\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            if (childProcess != null) {\n+                childProcess.destroy();\n+                childProcess = null;\n+            }\n+            throw new RuntimeException(\"Failed to retrieve the data.\");\n+        }\n+        Child.sysClipboard.setContents(Child.transferable, null);\n+    }\n+}\n+\n+class Child {\n+    static final Clipboard sysClipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    static final Transferable transferable = new StringSelection(\"String\");\n+\n+    \/*\n+     * Timeouts.\n+     *\/\n+    static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    static final int PARENT_TIME_STAMP_TIMEOUT = 1000;\n+    static final int CHILD_SELECTION_CHANGE_TIMEOUT =\n+            FRAME_ACTIVATION_TIMEOUT + PARENT_TIME_STAMP_TIMEOUT + 5000;\n+    static final int PARENT_RETRIEVE_DATA_TIMEOUT = 10000;\n+\n+    \/*\n+     * Child process return codes.\n+     *\/\n+    static final int CHILD_RETURN_CODE_NOT_READY            = -1;\n+    static final int CHILD_RETURN_CODE_OK                   = 0;\n+    static final int CHILD_RETURN_CODE_UNEXPECTED_EXCEPTION = 1;\n+    static final int CHILD_RETURN_CODE_OTHER_FAILURE        = 2;\n+    static Button button;\n+\n+    static void initAndShowGui() {\n+        final Frame frame = new Frame();\n+        button = new Button(\"button\");\n+        frame.add(button);\n+        frame.pack();\n+        frame.setLocation(100, 100);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) {\n+        sysClipboard.setContents(\n+                new StringSelection(\"First String\"), null);\n+\n+        \/\/ Some mouse activity to update the Xt time stamp at\n+        \/\/ the child process.\n+        try {\n+            EventQueue.invokeAndWait(Child::initAndShowGui);\n+            try {\n+                Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                System.exit(CHILD_RETURN_CODE_UNEXPECTED_EXCEPTION);\n+            }\n+\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+\n+            Point p = button.getLocationOnScreen();\n+            robot.mouseMove(p.x + 10, p.y + 10);\n+            \/\/ Wait to let the Xt time stamp become out-of-date.\n+            try {\n+                Thread.sleep(PARENT_TIME_STAMP_TIMEOUT);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                System.exit(CHILD_RETURN_CODE_UNEXPECTED_EXCEPTION);\n+            }\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            System.exit(CHILD_RETURN_CODE_UNEXPECTED_EXCEPTION);\n+        }\n+\n+        sysClipboard.setContents(transferable, new ClipboardOwner() {\n+            public void lostOwnership(Clipboard clipboard,\n+                                      Transferable contents) {\n+                System.exit(CHILD_RETURN_CODE_OK);\n+            }\n+        });\n+        \/\/ Wait to let the parent process retrieve the data.\n+        try {\n+            Thread.sleep(PARENT_RETRIEVE_DATA_TIMEOUT);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        \/\/ Parent failed to set clipboard contents, so we signal test failure\n+        System.exit(CHILD_RETURN_CODE_OTHER_FAILURE);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/DelayedQueryTest.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4378007 4250859\n+  @summary Verifies that setting the contents of the system Clipboard to null\n+           throws a NullPointerException\n+  @key headful\n+  @run main NullContentsTest\n+*\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.StringSelection;\n+\n+public class NullContentsTest {\n+\n+    public static void main(String[] args) {\n+        \/\/ Clipboard.setContents(null, foo) should throw an NPE, but\n+        \/\/ Clipboard.setContents(bar, foo), where bar.getTransferData(baz)\n+        \/\/ returns null, should not.\n+        Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        try {\n+            clip.setContents(null, null);\n+        } catch (NullPointerException e) {\n+            StringSelection ss = new StringSelection(null);\n+            try {\n+                clip.setContents(ss, null);\n+            } catch (NullPointerException ee) {\n+                throw new RuntimeException(\"test failed: null transfer data\");\n+            }\n+            System.err.println(\"test passed\");\n+            return;\n+        }\n+        throw new RuntimeException(\"test failed: null Transferable\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/NullContentsTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4696186\n+  @summary tests that NotSerializableException is not printed in the console if\n+           non-serializable object with DataFlavor.javaJVMLocalObjectMimeType\n+           is set into the clipboard\n+  @key headful\n+  @run main SerializeLocalFlavorTest\n+*\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+\n+\n+public class SerializeLocalFlavorTest {\n+    private boolean failed = false;\n+\n+    public static void main(String[] args) {\n+        new SerializeLocalFlavorTest().start();\n+    }\n+\n+    public void start () {\n+        try {\n+            String[] command = {\n+                    System.getProperty(\"java.home\", \"\")\n+                            + File.separator + \"bin\" + File.separator\n+                            + \"java\",\n+                    \"-cp\",\n+                    System.getProperty(\"test.classes\", \".\"),\n+                    \"Child\"\n+            };\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            ProcessResults pres = ProcessResults.doWaitFor(process);\n+\n+            if (pres.stderr != null && pres.stderr.length() > 0) {\n+                System.err.println(\"========= Child err ========\");\n+                System.err.print(pres.stderr);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stdout != null && pres.stdout.length() > 0) {\n+                System.err.println(\"========= Child out ========\");\n+                System.err.print(pres.stdout);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stderr.indexOf(\"java.io.NotSerializableException\") >= 0) {\n+                failed = true;\n+            }\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\n+                    \"The test failed: java.io.NotSerializableException printed!\");\n+        } else {\n+            System.err.println(\"The test passed!\");\n+        }\n+    }\n+}\n+\n+class Child {\n+    public static void main (String [] args) throws Exception {\n+        NotSerializableLocalTransferable t =\n+                new NotSerializableLocalTransferable(new NotSer());\n+        Toolkit.getDefaultToolkit()\n+                .getSystemClipboard().setContents(t, null);\n+    }\n+}\n+\n+class NotSerializableLocalTransferable implements Transferable {\n+    public final DataFlavor flavor;\n+\n+    private final DataFlavor[] flavors;\n+\n+    private final Object data;\n+\n+\n+    public NotSerializableLocalTransferable(Object data) throws Exception {\n+        this.data = data;\n+        flavor = new DataFlavor(\n+            DataFlavor.javaJVMLocalObjectMimeType +\n+            \";class=\" +  \"\\\"\" + data.getClass().getName() + \"\\\"\");\n+        this.flavors = new DataFlavor[] { flavor };\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return flavors.clone();\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor flavor) {\n+        return this.flavor.equals(flavor);\n+    }\n+\n+    public Object getTransferData(DataFlavor flavor)\n+        throws UnsupportedFlavorException\n+    {\n+        if (this.flavor.equals(flavor)) {\n+            return (Object)data;\n+        }\n+        throw new UnsupportedFlavorException(flavor);\n+    }\n+\n+}\n+\n+class NotSer implements Serializable {\n+    private Object field = new Object(); \/\/ not serializable field\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished  = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/SerializeLocalFlavorTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4330102\n+  @summary Tests that Color object is serializable\n+  @run main ColorSerializationTest\n+*\/\n+\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.IndexColorModel;\n+import java.io.ObjectOutputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+public class ColorSerializationTest {\n+\n+    public static void main(String[] args) {\n+        java.awt.Color cobj = new java.awt.Color(255, 255, 255);\n+        try {\n+            cobj.createContext(\n+                    new IndexColorModel(\n+                            8, 1,\n+                            new byte[]{0}, new byte[]{0}, new byte[]{0}),\n+                    new Rectangle(1, 1, 2, 3),\n+                    new Rectangle(3, 3),\n+                    new AffineTransform(),\n+                    new RenderingHints(null));\n+            ByteArrayOutputStream ostream = new ByteArrayOutputStream();\n+            ObjectOutputStream objos = new ObjectOutputStream(ostream);\n+            objos.writeObject(cobj);\n+            objos.close();\n+            System.out.println(\"Test PASSED\");\n+        } catch (java.io.IOException e) {\n+            System.out.println(\"Test FAILED\");\n+            throw new RuntimeException(\"Test FAILED: Color is not serializable: \" + e.getMessage());\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/ColorClass\/ColorSerializationTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}