{"files":[{"patch":"@@ -254,0 +254,5 @@\n+  if (UseMD5Intrinsics) {\n+    warning(\"MD5 intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,5 @@\n+  }\n+\n+  if (UseMD5Intrinsics) {\n+    warning(\"MD5 intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, false);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -297,0 +297,5 @@\n+  if (UseMD5Intrinsics) {\n+    warning(\"MD5 intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+  if (UseMD5Intrinsics) {\n+    warning(\"MD5 intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -4519,0 +4519,13 @@\n+void Assembler::roll(Register dst, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  int encode = prefix_and_encode(dst->encoding());\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_int8((unsigned char)(0xC0 | encode));\n+  } else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_int8((unsigned char)(0xc0 | encode));\n+    emit_int8(imm8);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1769,0 +1769,2 @@\n+  void roll(Register dst, int imm8);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -989,0 +989,3 @@\n+  void fast_md5(Register buf, Address state, Address ofs, Address limit,\n+                bool multi_block);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Copyright (c) 2017 Project Nayuki. (MIT License)\n+ * https:\/\/www.nayuki.io\/page\/fast-md5-hash-implementation-in-x86-assembly\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy of\n+ * this software and associated documentation files (the \"Software\"), to deal in\n+ * the Software without restriction, including without limitation the rights to\n+ * use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of\n+ * the Software, and to permit persons to whom the Software is furnished to do so,\n+ * subject to the following conditions:\n+ * - The above copyright notice and this permission notice shall be included in\n+ *   all copies or substantial portions of the Software.\n+ * - The Software is provided \"as is\", without warranty of any kind, express or\n+ *   implied, including but not limited to the warranties of merchantability,\n+ *   fitness for a particular purpose and noninfringement. In no event shall the\n+ *   authors or copyright holders be liable for any claim, damages or other\n+ *   liability, whether in an action of contract, tort or otherwise, arising from,\n+ *   out of or in connection with the Software or the use or other dealings in the\n+ *   Software.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+\n+\/\/ int com.sun.security.provider.MD5.implCompress0(byte[] b, int ofs)\n+void MacroAssembler::fast_md5(Register buf, Address state, Address ofs, Address limit, bool multi_block) {\n+\n+  Label start, done_hash, loop0;\n+\n+  bind(start);\n+\n+  bind(loop0);\n+\n+  \/\/ Save hash values for addition after rounds\n+  movptr(rdi, state);\n+  movl(rax, Address(rdi,  0));\n+  movl(rbx, Address(rdi,  4));\n+  movl(rcx, Address(rdi,  8));\n+  movl(rdx, Address(rdi, 12));\n+\n+#define FF(r1, r2, r3, r4, k, s, t)              \\\n+  movl(rsi, r3);                                 \\\n+  addl(r1, Address(buf, k*4));                   \\\n+  xorl(rsi, r4);                                 \\\n+  andl(rsi, r2);                                 \\\n+  xorl(rsi, r4);                                 \\\n+  leal(r1, Address(r1, rsi, Address::times_1, t)); \\\n+  roll(r1, s);                                   \\\n+  addl(r1, r2);\n+\n+#define GG(r1, r2, r3, r4, k, s, t)              \\\n+  movl(rsi, r4);                                 \\\n+  movl(rdi, r4);                                 \\\n+  addl(r1, Address(buf, k*4));                   \\\n+  notl(rsi);                                     \\\n+  andl(rdi, r2);                                 \\\n+  andl(rsi, r3);                                 \\\n+  orl(rsi, rdi);                                 \\\n+  leal(r1, Address(r1, rsi, Address::times_1, t)); \\\n+  roll(r1, s);                                   \\\n+  addl(r1, r2);\n+\n+#define HH(r1, r2, r3, r4, k, s, t)              \\\n+  movl(rsi, r3);                                 \\\n+  addl(r1, Address(buf, k*4));                   \\\n+  xorl(rsi, r4);                                 \\\n+  xorl(rsi, r2);                                 \\\n+  leal(r1, Address(r1, rsi, Address::times_1, t)); \\\n+  roll(r1, s);                                   \\\n+  addl(r1, r2);\n+\n+#define II(r1, r2, r3, r4, k, s, t)              \\\n+  movl(rsi, r4);                                 \\\n+  notl(rsi);                                     \\\n+  addl(r1, Address(buf, k*4));                   \\\n+  orl(rsi, r2);                                  \\\n+  xorl(rsi, r3);                                 \\\n+  leal(r1, Address(r1, rsi, Address::times_1, t)); \\\n+  roll(r1, s);                                   \\\n+  addl(r1, r2);\n+\n+  \/\/ Round 1\n+  FF(rax, rbx, rcx, rdx,  0,  7, 0xd76aa478)\n+  FF(rdx, rax, rbx, rcx,  1, 12, 0xe8c7b756)\n+  FF(rcx, rdx, rax, rbx,  2, 17, 0x242070db)\n+  FF(rbx, rcx, rdx, rax,  3, 22, 0xc1bdceee)\n+  FF(rax, rbx, rcx, rdx,  4,  7, 0xf57c0faf)\n+  FF(rdx, rax, rbx, rcx,  5, 12, 0x4787c62a)\n+  FF(rcx, rdx, rax, rbx,  6, 17, 0xa8304613)\n+  FF(rbx, rcx, rdx, rax,  7, 22, 0xfd469501)\n+  FF(rax, rbx, rcx, rdx,  8,  7, 0x698098d8)\n+  FF(rdx, rax, rbx, rcx,  9, 12, 0x8b44f7af)\n+  FF(rcx, rdx, rax, rbx, 10, 17, 0xffff5bb1)\n+  FF(rbx, rcx, rdx, rax, 11, 22, 0x895cd7be)\n+  FF(rax, rbx, rcx, rdx, 12,  7, 0x6b901122)\n+  FF(rdx, rax, rbx, rcx, 13, 12, 0xfd987193)\n+  FF(rcx, rdx, rax, rbx, 14, 17, 0xa679438e)\n+  FF(rbx, rcx, rdx, rax, 15, 22, 0x49b40821)\n+\n+  \/\/ Round 2\n+  GG(rax, rbx, rcx, rdx,  1,  5, 0xf61e2562)\n+  GG(rdx, rax, rbx, rcx,  6,  9, 0xc040b340)\n+  GG(rcx, rdx, rax, rbx, 11, 14, 0x265e5a51)\n+  GG(rbx, rcx, rdx, rax,  0, 20, 0xe9b6c7aa)\n+  GG(rax, rbx, rcx, rdx,  5,  5, 0xd62f105d)\n+  GG(rdx, rax, rbx, rcx, 10,  9, 0x02441453)\n+  GG(rcx, rdx, rax, rbx, 15, 14, 0xd8a1e681)\n+  GG(rbx, rcx, rdx, rax,  4, 20, 0xe7d3fbc8)\n+  GG(rax, rbx, rcx, rdx,  9,  5, 0x21e1cde6)\n+  GG(rdx, rax, rbx, rcx, 14,  9, 0xc33707d6)\n+  GG(rcx, rdx, rax, rbx,  3, 14, 0xf4d50d87)\n+  GG(rbx, rcx, rdx, rax,  8, 20, 0x455a14ed)\n+  GG(rax, rbx, rcx, rdx, 13,  5, 0xa9e3e905)\n+  GG(rdx, rax, rbx, rcx,  2,  9, 0xfcefa3f8)\n+  GG(rcx, rdx, rax, rbx,  7, 14, 0x676f02d9)\n+  GG(rbx, rcx, rdx, rax, 12, 20, 0x8d2a4c8a)\n+\n+  \/\/ Round 3\n+  HH(rax, rbx, rcx, rdx,  5,  4, 0xfffa3942)\n+  HH(rdx, rax, rbx, rcx,  8, 11, 0x8771f681)\n+  HH(rcx, rdx, rax, rbx, 11, 16, 0x6d9d6122)\n+  HH(rbx, rcx, rdx, rax, 14, 23, 0xfde5380c)\n+  HH(rax, rbx, rcx, rdx,  1,  4, 0xa4beea44)\n+  HH(rdx, rax, rbx, rcx,  4, 11, 0x4bdecfa9)\n+  HH(rcx, rdx, rax, rbx,  7, 16, 0xf6bb4b60)\n+  HH(rbx, rcx, rdx, rax, 10, 23, 0xbebfbc70)\n+  HH(rax, rbx, rcx, rdx, 13,  4, 0x289b7ec6)\n+  HH(rdx, rax, rbx, rcx,  0, 11, 0xeaa127fa)\n+  HH(rcx, rdx, rax, rbx,  3, 16, 0xd4ef3085)\n+  HH(rbx, rcx, rdx, rax,  6, 23, 0x04881d05)\n+  HH(rax, rbx, rcx, rdx,  9,  4, 0xd9d4d039)\n+  HH(rdx, rax, rbx, rcx, 12, 11, 0xe6db99e5)\n+  HH(rcx, rdx, rax, rbx, 15, 16, 0x1fa27cf8)\n+  HH(rbx, rcx, rdx, rax,  2, 23, 0xc4ac5665)\n+\n+  \/\/ Round 4\n+  II(rax, rbx, rcx, rdx,  0,  6, 0xf4292244)\n+  II(rdx, rax, rbx, rcx,  7, 10, 0x432aff97)\n+  II(rcx, rdx, rax, rbx, 14, 15, 0xab9423a7)\n+  II(rbx, rcx, rdx, rax,  5, 21, 0xfc93a039)\n+  II(rax, rbx, rcx, rdx, 12,  6, 0x655b59c3)\n+  II(rdx, rax, rbx, rcx,  3, 10, 0x8f0ccc92)\n+  II(rcx, rdx, rax, rbx, 10, 15, 0xffeff47d)\n+  II(rbx, rcx, rdx, rax,  1, 21, 0x85845dd1)\n+  II(rax, rbx, rcx, rdx,  8,  6, 0x6fa87e4f)\n+  II(rdx, rax, rbx, rcx, 15, 10, 0xfe2ce6e0)\n+  II(rcx, rdx, rax, rbx,  6, 15, 0xa3014314)\n+  II(rbx, rcx, rdx, rax, 13, 21, 0x4e0811a1)\n+  II(rax, rbx, rcx, rdx,  4,  6, 0xf7537e82)\n+  II(rdx, rax, rbx, rcx, 11, 10, 0xbd3af235)\n+  II(rcx, rdx, rax, rbx,  2, 15, 0x2ad7d2bb)\n+  II(rbx, rcx, rdx, rax,  9, 21, 0xeb86d391)\n+\n+#undef FF\n+#undef GG\n+#undef HH\n+#undef II\n+\n+  \/\/ write hash values back in the correct order\n+  movptr(rdi, state);\n+  addl(Address(rdi,  0), rax);\n+  addl(Address(rdi,  4), rbx);\n+  addl(Address(rdi,  8), rcx);\n+  addl(Address(rdi, 12), rdx);\n+\n+  if (multi_block) {\n+    \/\/ increment data pointer and loop if more to process\n+    addptr(buf, 64);\n+    addl(ofs, 64);\n+    movl(rsi, ofs);\n+    cmpl(rsi, limit);\n+    jcc(Assembler::belowEqual, loop0);\n+    movptr(rax, rsi); \/\/return ofs\n+  }\n+\n+  bind(done_hash);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_md5.cpp","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -2972,0 +2972,40 @@\n+  \/\/ ofs and limit are use for multi-block byte array.\n+  \/\/ int com.sun.security.provider.MD5.implCompress(byte[] b, int ofs)\n+  address generate_md5_implCompress(bool multi_block, const char *name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", name);\n+    address start = __ pc();\n+\n+    const Register buf_param = rbp;\n+    const Address state_param(rsp, 0 * wordSize);\n+    const Address ofs_param  (rsp, 1 * wordSize);\n+    const Address limit_param(rsp, 2 * wordSize);\n+\n+    __ enter();\n+    __ push(rbx);\n+    __ push(rdi);\n+    __ push(rsi);\n+    __ push(rbp);\n+    __ subptr(rsp, 3 * wordSize);\n+\n+    __ movptr(rsi, Address(rbp, 8 + 4));\n+    __ movptr(state_param, rsi);\n+    if (multi_block) {\n+      __ movptr(rsi, Address(rbp, 8 + 8));\n+      __ movptr(ofs_param, rsi);\n+      __ movptr(rsi, Address(rbp, 8 + 12));\n+      __ movptr(limit_param, rsi);\n+    }\n+    __ movptr(buf_param, Address(rbp, 8 + 0)); \/\/ do it last because it override rbp\n+    __ fast_md5(buf_param, state_param, ofs_param, limit_param, multi_block);\n+\n+    __ addptr(rsp, 3 * wordSize);\n+    __ pop(rbp);\n+    __ pop(rsi);\n+    __ pop(rdi);\n+    __ pop(rbx);\n+    __ leave();\n+    __ ret(0);\n+    return start;\n+  }\n+\n@@ -3909,0 +3949,4 @@\n+    if (UseMD5Intrinsics) {\n+      StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3673,0 +3673,37 @@\n+  \/\/ ofs and limit are use for multi-block byte array.\n+  \/\/ int com.sun.security.provider.MD5.implCompress(byte[] b, int ofs)\n+  address generate_md5_implCompress(bool multi_block, const char *name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", name);\n+    address start = __ pc();\n+\n+    const Register buf_param = r15;\n+    const Address state_param(rsp, 0 * wordSize);\n+    const Address ofs_param  (rsp, 1 * wordSize    );\n+    const Address limit_param(rsp, 1 * wordSize + 4);\n+\n+    __ enter();\n+    __ push(rbx);\n+    __ push(rdi);\n+    __ push(rsi);\n+    __ push(r15);\n+    __ subptr(rsp, 2 * wordSize);\n+\n+    __ movptr(buf_param, c_rarg0);\n+    __ movptr(state_param, c_rarg1);\n+    if (multi_block) {\n+      __ movl(ofs_param, c_rarg2);\n+      __ movl(limit_param, c_rarg3);\n+    }\n+    __ fast_md5(buf_param, state_param, ofs_param, limit_param, multi_block);\n+\n+    __ addptr(rsp, 2 * wordSize);\n+    __ pop(r15);\n+    __ pop(rsi);\n+    __ pop(rdi);\n+    __ pop(rbx);\n+    __ leave();\n+    __ ret(0);\n+    return start;\n+  }\n+\n@@ -6032,0 +6069,4 @@\n+    if (UseMD5Intrinsics) {\n+      StubRoutines::_md5_implCompress = generate_md5_implCompress(false, \"md5_implCompress\");\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true, \"md5_implCompressMB\");\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -938,0 +938,4 @@\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+    UseMD5Intrinsics = true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-    return 3;\n+    return 4;\n@@ -750,0 +750,3 @@\n+  case vmIntrinsics::_md5_implCompress:\n+    if (!UseMD5Intrinsics) return true;\n+    break;\n@@ -760,1 +763,1 @@\n-    if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;\n+    if (!(UseMD5Intrinsics || UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1039,0 +1039,6 @@\n+  \/* support for sun.security.provider.MD5 *\/                                                                           \\\n+  do_class(sun_security_provider_md5,                              \"sun\/security\/provider\/MD5\")                         \\\n+  do_intrinsic(_md5_implCompress, sun_security_provider_md5, implCompress_name, implCompress_signature, F_R)            \\\n+   do_name(     implCompress_name,                                 \"implCompress0\")                                     \\\n+   do_signature(implCompress_signature,                            \"([BI)V\")                                            \\\n+                                                                                                                        \\\n@@ -1042,2 +1048,0 @@\n-   do_name(     implCompress_name,                                 \"implCompress0\")                                     \\\n-   do_signature(implCompress_signature,                            \"([BI)V\")                                            \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -639,0 +639,1 @@\n+  case vmIntrinsics::_md5_implCompress:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1074,0 +1074,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"md5_implCompress\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"md5_implCompressMB\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  bool inline_sha_implCompress(vmIntrinsics::ID id);\n+  bool inline_digestBase_implCompress(vmIntrinsics::ID id);\n@@ -307,5 +307,5 @@\n-  bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,\n-                                 bool long_state, address stubAddr, const char *stubName,\n-                                 Node* src_start, Node* ofs, Node* limit);\n-  Node* get_state_from_sha_object(Node *sha_object);\n-  Node* get_state_from_sha5_object(Node *sha_object);\n+  bool inline_digestBase_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass,\n+                                        bool long_state, address stubAddr, const char *stubName,\n+                                        Node* src_start, Node* ofs, Node* limit);\n+  Node* get_state_from_digest_object(Node *digestBase_object);\n+  Node* get_long_state_from_digest_object(Node *digestBase_object);\n@@ -829,0 +829,1 @@\n+  case vmIntrinsics::_md5_implCompress:\n@@ -832,1 +833,1 @@\n-    return inline_sha_implCompress(intrinsic_id());\n+    return inline_digestBase_implCompress(intrinsic_id());\n@@ -6441,1 +6442,4 @@\n-\/\/------------------------------inline_sha_implCompress-----------------------\n+\/\/------------------------------inline_digestBase_implCompress-----------------------\n+\/\/\n+\/\/ Calculate MD5 for single-block byte[] array.\n+\/\/ void com.sun.security.provider.MD5.implCompress(byte[] buf, int ofs)\n@@ -6452,1 +6456,1 @@\n-bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {\n+bool LibraryCallKit::inline_digestBase_implCompress(vmIntrinsics::ID id) {\n@@ -6455,3 +6459,3 @@\n-  Node* sha_obj = argument(0);\n-  Node* src     = argument(1); \/\/ type oop\n-  Node* ofs     = argument(2); \/\/ type int\n+  Node* digestBase_obj = argument(0);\n+  Node* src            = argument(1); \/\/ type oop\n+  Node* ofs            = argument(2); \/\/ type int\n@@ -6478,0 +6482,6 @@\n+  case vmIntrinsics::_md5_implCompress:\n+    assert(UseMD5Intrinsics, \"need MD5 instruction support\");\n+    state = get_state_from_digest_object(digestBase_obj);\n+    stubAddr = StubRoutines::md5_implCompress();\n+    stubName = \"md5_implCompress\";\n+    break;\n@@ -6480,1 +6490,1 @@\n-    state = get_state_from_sha_object(sha_obj);\n+    state = get_state_from_digest_object(digestBase_obj);\n@@ -6486,1 +6496,1 @@\n-    state = get_state_from_sha_object(sha_obj);\n+    state = get_state_from_digest_object(digestBase_obj);\n@@ -6492,1 +6502,1 @@\n-    state = get_state_from_sha5_object(sha_obj);\n+    state = get_long_state_from_digest_object(digestBase_obj);\n@@ -6506,1 +6516,1 @@\n-  Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),\n+  Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::digestBase_implCompress_Type(),\n@@ -6515,1 +6525,1 @@\n-\/\/ Calculate SHA\/SHA2\/SHA5 for multi-block byte[] array.\n+\/\/ Calculate MD5\/SHA\/SHA2\/SHA5 for multi-block byte[] array.\n@@ -6519,3 +6529,3 @@\n-  assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,\n-         \"need SHA1\/SHA256\/SHA512 instruction support\");\n-  assert((uint)predicate < 3, \"sanity\");\n+  assert(UseMD5Intrinsics || UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,\n+         \"need MD5\/SHA1\/SHA256\/SHA512 instruction support\");\n+  assert((uint)predicate < 4, \"sanity\");\n@@ -6544,1 +6554,1 @@\n-  const char* klass_SHA_name = NULL;\n+  const char* klass_digestBase_name = NULL;\n@@ -6551,0 +6561,7 @@\n+    if (UseMD5Intrinsics) {\n+      klass_digestBase_name = \"sun\/security\/provider\/MD5\";\n+      stub_name = \"md5_implCompressMB\";\n+      stub_addr = StubRoutines::md5_implCompressMB();\n+    }\n+    break;\n+  case 1:\n@@ -6552,1 +6569,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA\";\n+      klass_digestBase_name = \"sun\/security\/provider\/SHA\";\n@@ -6557,1 +6574,1 @@\n-  case 1:\n+  case 2:\n@@ -6559,1 +6576,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA2\";\n+      klass_digestBase_name = \"sun\/security\/provider\/SHA2\";\n@@ -6564,1 +6581,1 @@\n-  case 2:\n+  case 3:\n@@ -6566,1 +6583,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA5\";\n+      klass_digestBase_name = \"sun\/security\/provider\/SHA5\";\n@@ -6573,1 +6590,1 @@\n-    fatal(\"unknown SHA intrinsic predicate: %d\", predicate);\n+    fatal(\"unknown DigestBase intrinsic predicate: %d\", predicate);\n@@ -6575,1 +6592,1 @@\n-  if (klass_SHA_name != NULL) {\n+  if (klass_digestBase_name != NULL) {\n@@ -6584,4 +6601,4 @@\n-    ciKlass* klass_SHA = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_SHA_name));\n-    assert(klass_SHA->is_loaded(), \"predicate checks that this class is loaded\");\n-    ciInstanceKlass* instklass_SHA = klass_SHA->as_instance_klass();\n-    return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);\n+    ciKlass* klass_digestBase = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_digestBase_name));\n+    assert(klass_digestBase->is_loaded(), \"predicate checks that this class is loaded\");\n+    ciInstanceKlass* instklass_digestBase = klass_digestBase->as_instance_klass();\n+    return inline_digestBase_implCompressMB(digestBase_obj, instklass_digestBase, long_state, stub_addr, stub_name, src_start, ofs, limit);\n@@ -6591,5 +6608,6 @@\n-\/\/------------------------------inline_sha_implCompressMB-----------------------\n-bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,\n-                                               bool long_state, address stubAddr, const char *stubName,\n-                                               Node* src_start, Node* ofs, Node* limit) {\n-  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);\n+\n+\/\/------------------------------inline_digestBase_implCompressMB-----------------------\n+bool LibraryCallKit::inline_digestBase_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_digestBase,\n+                                                      bool long_state, address stubAddr, const char *stubName,\n+                                                      Node* src_start, Node* ofs, Node* limit) {\n+  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_digestBase);\n@@ -6597,2 +6615,2 @@\n-  Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);\n-  sha_obj = _gvn.transform(sha_obj);\n+  Node* digest_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);\n+  digest_obj = _gvn.transform(digest_obj);\n@@ -6602,1 +6620,1 @@\n-    state = get_state_from_sha5_object(sha_obj);\n+    state = get_long_state_from_digest_object(digest_obj);\n@@ -6604,1 +6622,1 @@\n-    state = get_state_from_sha_object(sha_obj);\n+    state = get_state_from_digest_object(digest_obj);\n@@ -6620,5 +6638,5 @@\n-\/\/------------------------------get_state_from_sha_object-----------------------\n-Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {\n-  Node* sha_state = load_field_from_object(sha_object, \"state\", \"[I\", \/*is_exact*\/ false);\n-  assert (sha_state != NULL, \"wrong version of sun.security.provider.SHA\/SHA2\");\n-  if (sha_state == NULL) return (Node *) NULL;\n+\/\/------------------------------get_state_from_digest_object-----------------------\n+Node * LibraryCallKit::get_state_from_digest_object(Node *digest_object) {\n+  Node* digest_state = load_field_from_object(digest_object, \"state\", \"[I\", \/*is_exact*\/ false);\n+  assert (digest_state != NULL, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\");\n+  if (digest_state == NULL) return (Node *) NULL;\n@@ -6627,1 +6645,1 @@\n-  Node* state = array_element_address(sha_state, intcon(0), T_INT);\n+  Node* state = array_element_address(digest_state, intcon(0), T_INT);\n@@ -6631,5 +6649,5 @@\n-\/\/------------------------------get_state_from_sha5_object-----------------------\n-Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {\n-  Node* sha_state = load_field_from_object(sha_object, \"state\", \"[J\", \/*is_exact*\/ false);\n-  assert (sha_state != NULL, \"wrong version of sun.security.provider.SHA5\");\n-  if (sha_state == NULL) return (Node *) NULL;\n+\/\/------------------------------get_long_state_from_digest_object-----------------------\n+Node * LibraryCallKit::get_long_state_from_digest_object(Node *digest_object) {\n+  Node* digest_state = load_field_from_object(digest_object, \"state\", \"[J\", \/*is_exact*\/ false);\n+  assert (digest_state != NULL, \"wrong version of sun.security.provider.SHA5\");\n+  if (digest_state == NULL) return (Node *) NULL;\n@@ -6638,1 +6656,1 @@\n-  Node* state = array_element_address(sha_state, intcon(0), T_LONG);\n+  Node* state = array_element_address(digest_state, intcon(0), T_LONG);\n@@ -6645,1 +6663,1 @@\n-\/\/    if (digestBaseObj instanceof SHA\/SHA2\/SHA5) do_intrinsic, else do_javapath\n+\/\/    if (digestBaseObj instanceof MD5\/SHA\/SHA2\/SHA5) do_intrinsic, else do_javapath\n@@ -6648,3 +6666,3 @@\n-  assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,\n-         \"need SHA1\/SHA256\/SHA512 instruction support\");\n-  assert((uint)predicate < 3, \"sanity\");\n+  assert(UseMD5Intrinsics || UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,\n+         \"need MD5\/SHA1\/SHA256\/SHA512 instruction support\");\n+  assert((uint)predicate < 4, \"sanity\");\n@@ -6660,1 +6678,1 @@\n-  const char* klass_SHA_name = NULL;\n+  const char* klass_name = NULL;\n@@ -6663,0 +6681,6 @@\n+    if (UseMD5Intrinsics) {\n+      \/\/ we want to do an instanceof comparison against the MD5 class\n+      klass_name = \"sun\/security\/provider\/MD5\";\n+    }\n+    break;\n+  case 1:\n@@ -6665,1 +6689,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA\";\n+      klass_name = \"sun\/security\/provider\/SHA\";\n@@ -6668,1 +6692,1 @@\n-  case 1:\n+  case 2:\n@@ -6671,1 +6695,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA2\";\n+      klass_name = \"sun\/security\/provider\/SHA2\";\n@@ -6674,1 +6698,1 @@\n-  case 2:\n+  case 3:\n@@ -6677,1 +6701,1 @@\n-      klass_SHA_name = \"sun\/security\/provider\/SHA5\";\n+      klass_name = \"sun\/security\/provider\/SHA5\";\n@@ -6684,3 +6708,3 @@\n-  ciKlass* klass_SHA = NULL;\n-  if (klass_SHA_name != NULL) {\n-    klass_SHA = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_SHA_name));\n+  ciKlass* klass = NULL;\n+  if (klass_name != NULL) {\n+    klass = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_name));\n@@ -6688,2 +6712,2 @@\n-  if ((klass_SHA == NULL) || !klass_SHA->is_loaded()) {\n-    \/\/ if none of SHA\/SHA2\/SHA5 is loaded, we never take the intrinsic fast path\n+  if ((klass == NULL) || !klass->is_loaded()) {\n+    \/\/ if none of MD5\/SHA\/SHA2\/SHA5 is loaded, we never take the intrinsic fast path\n@@ -6694,1 +6718,1 @@\n-  ciInstanceKlass* instklass_SHA = klass_SHA->as_instance_klass();\n+  ciInstanceKlass* instklass = klass->as_instance_klass();\n@@ -6696,2 +6720,2 @@\n-  Node* instofSHA = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass_SHA)));\n-  Node* cmp_instof = _gvn.transform(new CmpINode(instofSHA, intcon(1)));\n+  Node* instof = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass)));\n+  Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":95,"deletions":71,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -962,1 +962,1 @@\n-const TypeFunc* OptoRuntime::sha_implCompress_Type() {\n+const TypeFunc* OptoRuntime::digestBase_implCompress_Type() {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,1 +281,1 @@\n-  static const TypeFunc* sha_implCompress_Type();\n+  static const TypeFunc* digestBase_implCompress_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -450,0 +450,3 @@\n+  diagnostic(bool, UseMD5Intrinsics, false,                                 \\\n+          \"Use intrinsics for MD5 crypto hash function\")                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+address StubRoutines::_md5_implCompress      = NULL;\n+address StubRoutines::_md5_implCompressMB    = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+  static address _md5_implCompress;\n+  static address _md5_implCompressMB;\n@@ -356,0 +358,2 @@\n+  static address md5_implCompress()      { return _md5_implCompress; }\n+  static address md5_implCompressMB()    { return _md5_implCompressMB; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -31,0 +32,1 @@\n+import jdk.internal.HotSpotIntrinsicCandidate;\n@@ -150,0 +152,11 @@\n+        implCompressCheck(buf, ofs);\n+        implCompress0(buf, ofs);\n+    }\n+\n+    private void implCompressCheck(byte[] buf, int ofs) {\n+        Objects.requireNonNull(buf);\n+\n+        \/\/ The checks performed by the method 'b2iBig64'\n+        \/\/ are sufficient for the case when the method\n+        \/\/ 'implCompressImpl' is replaced with a compiler\n+        \/\/ intrinsic.\n@@ -151,0 +164,1 @@\n+    }\n@@ -152,0 +166,7 @@\n+    \/\/ The method 'implCompress0 seems not to use its parameters.\n+    \/\/ The method can, however, be replaced with a compiler intrinsic\n+    \/\/ that operates directly on the array 'buf' (starting from\n+    \/\/ offset 'ofs') and not on array 'x', therefore 'buf' and 'ofs'\n+    \/\/ must be passed as parameter to the method.\n+    @HotSpotIntrinsicCandidate\n+    void implCompress0(byte[] buf, int ofs) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/MD5.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-        \/\/ 'implCompressImpl' is replaced with a compiler\n+        \/\/ 'implCompress0' is replaced with a compiler\n@@ -142,1 +142,1 @@\n-    \/\/ The method 'implCompressImpl seems not to use its parameters.\n+    \/\/ The method 'implCompress0 seems not to use its parameters.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,1 +390,2 @@\n-                            \"jdk\/jfr\/internal\/JVM.getEventWriter()Ljava\/lang\/Object;\");\n+                            \"jdk\/jfr\/internal\/JVM.getEventWriter()Ljava\/lang\/Object;\",\n+                            \"sun\/security\/provider\/MD5.implCompress0([BI)V\");\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8035968\n+ * @summary C2 support for MD5\/SHA-1\/SHA-224\/SHA-256\/SHA-384\/SHA-512\n+ *\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=MD5\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-224\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-256\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-384\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-512\n+ *      compiler.intrinsics.sha.TestDigest\n+ *\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=MD5   -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-1   -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-224 -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-256 -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-384 -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-512 -Doffset=1\n+ *      compiler.intrinsics.sha.TestDigest\n+ *\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-1   -Dalgorithm2=SHA-256\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-1   -Dalgorithm2=SHA-512\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-256 -Dalgorithm2=SHA-512\n+ *      compiler.intrinsics.sha.TestDigest\n+ *\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=SHA-1   -Dalgorithm2=MD5\n+ *      compiler.intrinsics.sha.TestDigest\n+ * @run main\/othervm\/timeout=600 -Xbatch\n+ *      -Dalgorithm=MD5     -Dalgorithm2=SHA-1\n+ *      compiler.intrinsics.sha.TestDigest\n+ *\/\n+\n+package compiler.intrinsics.sha;\n+\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+\n+public class TestDigest {\n+    private static final int HASH_LEN = 64; \/* up to 512-bit *\/\n+    private static final int ALIGN = 8;     \/* for different data alignments *\/\n+\n+    public static void main(String[] args) throws Exception {\n+        String provider = System.getProperty(\"provider\", \"SUN\");\n+        String algorithm = System.getProperty(\"algorithm\", \"SHA-1\");\n+        String algorithm2 = System.getProperty(\"algorithm2\", \"\");\n+        int msgSize = Integer.getInteger(\"msgSize\", 1024);\n+        int offset = Integer.getInteger(\"offset\", 0)  % ALIGN;\n+        int iters = (args.length > 0 ? Integer.valueOf(args[0]) : 100000);\n+        int warmupIters = (args.length > 1 ? Integer.valueOf(args[1]) : 20000);\n+\n+        testDigest(provider, algorithm, msgSize, offset, iters, warmupIters);\n+\n+        if (algorithm2.equals(\"\") == false) {\n+            testDigest(provider, algorithm2, msgSize, offset, iters, warmupIters);\n+        }\n+    }\n+\n+    public static void testDigest(String provider, String algorithm, int msgSize,\n+                        int offset, int iters, int warmupIters) throws Exception {\n+        System.out.println(\"provider = \" + provider);\n+        System.out.println(\"algorithm = \" + algorithm);\n+        System.out.println(\"msgSize = \" + msgSize + \" bytes\");\n+        System.out.println(\"offset = \" + offset);\n+        System.out.println(\"iters = \" + iters);\n+\n+        byte[] expectedHash = new byte[HASH_LEN];\n+        byte[] hash = new byte[HASH_LEN];\n+        byte[] data = new byte[msgSize + offset];\n+        for (int i = 0; i < (msgSize + offset); i++) {\n+            data[i] = (byte)(i & 0xff);\n+        }\n+\n+        try {\n+            MessageDigest digest = MessageDigest.getInstance(algorithm, provider);\n+\n+            \/* do once, which doesn't use intrinsics *\/\n+            digest.reset();\n+            digest.update(data, offset, msgSize);\n+            expectedHash = digest.digest();\n+\n+            \/* warm up *\/\n+            for (int i = 0; i < warmupIters; i++) {\n+                digest.reset();\n+                digest.update(data, offset, msgSize);\n+                hash = digest.digest();\n+            }\n+\n+            \/* check result *\/\n+            if (Arrays.equals(hash, expectedHash) == false) {\n+                System.out.println(\"TestDigest Error: \");\n+                showArray(expectedHash, \"expectedHash\");\n+                showArray(hash,         \"computedHash\");\n+                \/\/System.exit(1);\n+                throw new Exception(\"TestDigest Error\");\n+            } else {\n+                showArray(hash, \"hash\");\n+            }\n+\n+            \/* measure performance *\/\n+            long start = System.nanoTime();\n+            for (int i = 0; i < iters; i++) {\n+                digest.reset();\n+                digest.update(data, offset, msgSize);\n+                hash = digest.digest();\n+            }\n+            long end = System.nanoTime();\n+            double total = (double)(end - start)\/1e9;         \/* in seconds *\/\n+            double thruput = (double)msgSize*iters\/1e6\/total; \/* in MB\/s *\/\n+            System.out.println(\"TestDigest runtime = \" + total + \" seconds\");\n+            System.out.println(\"TestDigest throughput = \" + thruput + \" MB\/s\");\n+            System.out.println();\n+        } catch (Exception e) {\n+            System.out.println(\"Exception: \" + e);\n+            \/\/System.exit(1);\n+            throw new Exception(e);\n+        }\n+    }\n+\n+    static void showArray(byte b[], String name) {\n+        System.out.format(\"%s [%d]: \", name, b.length);\n+        for (int i = 0; i < Math.min(b.length, HASH_LEN); i++) {\n+            System.out.format(\"%02x \", b[i] & 0xff);\n+        }\n+        System.out.println();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/TestDigest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8035968\n- * @summary C2 support for SHA on SPARC\n- *\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-1\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-224\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-256\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-384\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-512\n- *      compiler.intrinsics.sha.TestSHA\n- *\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-1   -Doffset=1\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-224 -Doffset=1\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-256 -Doffset=1\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-384 -Doffset=1\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-512 -Doffset=1\n- *      compiler.intrinsics.sha.TestSHA\n- *\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-1   -Dalgorithm2=SHA-256\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-1   -Dalgorithm2=SHA-512\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-256 -Dalgorithm2=SHA-512\n- *      compiler.intrinsics.sha.TestSHA\n- *\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=SHA-1   -Dalgorithm2=MD5\n- *      compiler.intrinsics.sha.TestSHA\n- * @run main\/othervm\/timeout=600 -Xbatch\n- *      -Dalgorithm=MD5     -Dalgorithm2=SHA-1\n- *      compiler.intrinsics.sha.TestSHA\n- *\/\n-\n-package compiler.intrinsics.sha;\n-\n-import java.security.MessageDigest;\n-import java.util.Arrays;\n-\n-public class TestSHA {\n-    private static final int HASH_LEN = 64; \/* up to 512-bit *\/\n-    private static final int ALIGN = 8;     \/* for different data alignments *\/\n-\n-    public static void main(String[] args) throws Exception {\n-        String provider = System.getProperty(\"provider\", \"SUN\");\n-        String algorithm = System.getProperty(\"algorithm\", \"SHA-1\");\n-        String algorithm2 = System.getProperty(\"algorithm2\", \"\");\n-        int msgSize = Integer.getInteger(\"msgSize\", 1024);\n-        int offset = Integer.getInteger(\"offset\", 0)  % ALIGN;\n-        int iters = (args.length > 0 ? Integer.valueOf(args[0]) : 100000);\n-        int warmupIters = (args.length > 1 ? Integer.valueOf(args[1]) : 20000);\n-\n-        testSHA(provider, algorithm, msgSize, offset, iters, warmupIters);\n-\n-        if (algorithm2.equals(\"\") == false) {\n-            testSHA(provider, algorithm2, msgSize, offset, iters, warmupIters);\n-        }\n-    }\n-\n-    public static void testSHA(String provider, String algorithm, int msgSize,\n-                        int offset, int iters, int warmupIters) throws Exception {\n-        System.out.println(\"provider = \" + provider);\n-        System.out.println(\"algorithm = \" + algorithm);\n-        System.out.println(\"msgSize = \" + msgSize + \" bytes\");\n-        System.out.println(\"offset = \" + offset);\n-        System.out.println(\"iters = \" + iters);\n-\n-        byte[] expectedHash = new byte[HASH_LEN];\n-        byte[] hash = new byte[HASH_LEN];\n-        byte[] data = new byte[msgSize + offset];\n-        for (int i = 0; i < (msgSize + offset); i++) {\n-            data[i] = (byte)(i & 0xff);\n-        }\n-\n-        try {\n-            MessageDigest sha = MessageDigest.getInstance(algorithm, provider);\n-\n-            \/* do once, which doesn't use intrinsics *\/\n-            sha.reset();\n-            sha.update(data, offset, msgSize);\n-            expectedHash = sha.digest();\n-\n-            \/* warm up *\/\n-            for (int i = 0; i < warmupIters; i++) {\n-                sha.reset();\n-                sha.update(data, offset, msgSize);\n-                hash = sha.digest();\n-            }\n-\n-            \/* check result *\/\n-            if (Arrays.equals(hash, expectedHash) == false) {\n-                System.out.println(\"TestSHA Error: \");\n-                showArray(expectedHash, \"expectedHash\");\n-                showArray(hash,         \"computedHash\");\n-                \/\/System.exit(1);\n-                throw new Exception(\"TestSHA Error\");\n-            } else {\n-                showArray(hash, \"hash\");\n-            }\n-\n-            \/* measure performance *\/\n-            long start = System.nanoTime();\n-            for (int i = 0; i < iters; i++) {\n-                sha.reset();\n-                sha.update(data, offset, msgSize);\n-                hash = sha.digest();\n-            }\n-            long end = System.nanoTime();\n-            double total = (double)(end - start)\/1e9;         \/* in seconds *\/\n-            double thruput = (double)msgSize*iters\/1e6\/total; \/* in MB\/s *\/\n-            System.out.println(\"TestSHA runtime = \" + total + \" seconds\");\n-            System.out.println(\"TestSHA throughput = \" + thruput + \" MB\/s\");\n-            System.out.println();\n-        } catch (Exception e) {\n-            System.out.println(\"Exception: \" + e);\n-            \/\/System.exit(1);\n-            throw new Exception(e);\n-        }\n-    }\n-\n-    static void showArray(byte b[], String name) {\n-        System.out.format(\"%s [%d]: \", name, b.length);\n-        for (int i = 0; i < Math.min(b.length, HASH_LEN); i++) {\n-            System.out.format(\"%02x \", b[i] & 0xff);\n-        }\n-        System.out.println();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/TestSHA.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.sha.cli;\n+\n+import compiler.testlibrary.sha.predicate.IntrinsicPredicates;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.cli.CommandLineOptionTest;\n+\n+import java.util.function.BooleanSupplier;\n+\n+\/**\n+ * Base class for all CLI tests on SHA-related options.\n+ *\n+ * Instead of using huge complex tests for each option, each test is constructed\n+ * from several test cases shared among different tests.\n+ *\/\n+public class DigestOptionsBase extends CommandLineOptionTest {\n+    public static final String USE_MD5_INTRINSICS_OPTION\n+            = \"UseMD5Intrinsics\";\n+    public static final String USE_SHA_OPTION = \"UseSHA\";\n+    public static final String USE_SHA1_INTRINSICS_OPTION\n+            = \"UseSHA1Intrinsics\";\n+    public static final String USE_SHA256_INTRINSICS_OPTION\n+            = \"UseSHA256Intrinsics\";\n+    public static final String USE_SHA512_INTRINSICS_OPTION\n+            = \"UseSHA512Intrinsics\";\n+\n+    \/\/ Intrinsics flags are of diagnostic type\n+    \/\/ and must be preceded by UnlockDiagnosticVMOptions.\n+    public static final String UNLOCK_DIAGNOSTIC_VM_OPTIONS\n+            = \"-XX:+UnlockDiagnosticVMOptions\";\n+\n+    \/\/ Note that strings below will be passed to\n+    \/\/ CommandLineOptionTest.verifySameJVMStartup and thus are regular\n+    \/\/ expressions, not just a plain strings.\n+    protected static final String MD5_INTRINSICS_ARE_NOT_AVAILABLE\n+            = \"Intrinsics for MD5 crypto hash functions not available on this CPU.\";\n+    protected static final String SHA_INSTRUCTIONS_ARE_NOT_AVAILABLE\n+            = \"SHA instructions are not available on this CPU\";\n+    protected static final String SHA1_INTRINSICS_ARE_NOT_AVAILABLE\n+            = \"Intrinsics for SHA-1 crypto hash functions not available on this CPU.\";\n+    protected static final String SHA256_INTRINSICS_ARE_NOT_AVAILABLE\n+            = \"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.\";\n+    protected static final String SHA512_INTRINSICS_ARE_NOT_AVAILABLE\n+            = \"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.\";\n+\n+    private final TestCase[] testCases;\n+\n+    \/**\n+     * Returns warning message that should occur in VM output if an option with\n+     * the name {@code optionName} was turned on and CPU does not support\n+     * required instructions.\n+     *\n+     * @param optionName The name of the option for which warning message should\n+     *                   be returned.\n+     * @return A warning message that will be printed out to VM output if CPU\n+     *         instructions required by the option are not supported.\n+     *\/\n+    public static String getWarningForUnsupportedCPU(String optionName) {\n+        switch (optionName) {\n+        case DigestOptionsBase.USE_MD5_INTRINSICS_OPTION:\n+            return DigestOptionsBase.MD5_INTRINSICS_ARE_NOT_AVAILABLE;\n+        case DigestOptionsBase.USE_SHA_OPTION:\n+            return DigestOptionsBase.SHA_INSTRUCTIONS_ARE_NOT_AVAILABLE;\n+        case DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION:\n+            return DigestOptionsBase.SHA1_INTRINSICS_ARE_NOT_AVAILABLE;\n+        case DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION:\n+            return DigestOptionsBase.SHA256_INTRINSICS_ARE_NOT_AVAILABLE;\n+        case DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION:\n+            return DigestOptionsBase.SHA512_INTRINSICS_ARE_NOT_AVAILABLE;\n+        default:\n+            throw new Error(\"Unexpected option \" + optionName);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the predicate indicating whether or not CPU instructions required\n+     * by the option with name {@code optionName} are available.\n+     *\n+     * @param optionName The name of the option for which a predicate should be\n+     *                   returned.\n+     * @return The predicate on availability of CPU instructions required by the\n+     *         option.\n+     *\/\n+    public static BooleanSupplier getPredicateForOption(String optionName) {\n+        switch (optionName) {\n+            case DigestOptionsBase.USE_MD5_INTRINSICS_OPTION:\n+                return IntrinsicPredicates.MD5_INSTRUCTION_AVAILABLE;\n+            case DigestOptionsBase.USE_SHA_OPTION:\n+                return IntrinsicPredicates.ANY_SHA_INSTRUCTION_AVAILABLE;\n+            case DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION:\n+                return IntrinsicPredicates.SHA1_INSTRUCTION_AVAILABLE;\n+            case DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION:\n+                return IntrinsicPredicates.SHA256_INSTRUCTION_AVAILABLE;\n+            case DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION:\n+                return IntrinsicPredicates.SHA512_INSTRUCTION_AVAILABLE;\n+            default:\n+                throw new Error(\"Unexpected option \" + optionName);\n+        }\n+    }\n+\n+    public DigestOptionsBase(TestCase... testCases) {\n+        super(Boolean.TRUE::booleanValue);\n+        this.testCases = testCases;\n+    }\n+\n+    @Override\n+    protected void runTestCases() throws Throwable {\n+        for (TestCase testCase : testCases) {\n+            testCase.test();\n+        }\n+    }\n+\n+    public static abstract class TestCase {\n+        protected final String optionName;\n+        private final BooleanSupplier predicate;\n+\n+        protected TestCase(String optionName, BooleanSupplier predicate) {\n+            this.optionName = optionName;\n+            this.predicate = predicate;\n+        }\n+\n+        protected final void test() throws Throwable {\n+            String testCaseName = this.getClass().getName();\n+            if (!predicate.getAsBoolean()) {\n+                System.out.println(\"Skipping \" + testCaseName\n+                        + \" due to predicate failure.\");\n+                return;\n+            } else {\n+                System.out.println(\"Running \" + testCaseName);\n+            }\n+\n+            verifyWarnings();\n+            verifyOptionValues();\n+        }\n+\n+        protected void verifyWarnings() throws Throwable {\n+        }\n+\n+        protected void verifyOptionValues() throws Throwable {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/DigestOptionsBase.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.intrinsics.sha.cli;\n-\n-import compiler.testlibrary.sha.predicate.IntrinsicPredicates;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.function.BooleanSupplier;\n-\n-\/**\n- * Base class for all CLI tests on SHA-related options.\n- *\n- * Instead of using huge complex tests for each option, each test is constructed\n- * from several test cases shared among different tests.\n- *\/\n-public class SHAOptionsBase extends CommandLineOptionTest {\n-    public static final String USE_SHA_OPTION = \"UseSHA\";\n-    public static final String USE_SHA1_INTRINSICS_OPTION\n-            = \"UseSHA1Intrinsics\";\n-    public static final String USE_SHA256_INTRINSICS_OPTION\n-            = \"UseSHA256Intrinsics\";\n-    public static final String USE_SHA512_INTRINSICS_OPTION\n-            = \"UseSHA512Intrinsics\";\n-\n-    \/\/ Intrinsics flags are of diagnostic type\n-    \/\/ and must be preceded by UnlockDiagnosticVMOptions.\n-    public static final String UNLOCK_DIAGNOSTIC_VM_OPTIONS\n-            = \"-XX:+UnlockDiagnosticVMOptions\";\n-\n-    \/\/ Note that strings below will be passed to\n-    \/\/ CommandLineOptionTest.verifySameJVMStartup and thus are regular\n-    \/\/ expressions, not just a plain strings.\n-    protected static final String SHA_INSTRUCTIONS_ARE_NOT_AVAILABLE\n-            = \"SHA instructions are not available on this CPU\";\n-    protected static final String SHA1_INTRINSICS_ARE_NOT_AVAILABLE\n-            = \"Intrinsics for SHA-1 crypto hash functions not available on this CPU.\";\n-    protected static final String SHA256_INTRINSICS_ARE_NOT_AVAILABLE\n-            = \"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.\";\n-    protected static final String SHA512_INTRINSICS_ARE_NOT_AVAILABLE\n-            = \"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.\";\n-\n-    private final TestCase[] testCases;\n-\n-    \/**\n-     * Returns warning message that should occur in VM output if an option with\n-     * the name {@code optionName} was turned on and CPU does not support\n-     * required instructions.\n-     *\n-     * @param optionName The name of the option for which warning message should\n-     *                   be returned.\n-     * @return A warning message that will be printed out to VM output if CPU\n-     *         instructions required by the option are not supported.\n-     *\/\n-    public static String getWarningForUnsupportedCPU(String optionName) {\n-        switch (optionName) {\n-        case SHAOptionsBase.USE_SHA_OPTION:\n-            return SHAOptionsBase.SHA_INSTRUCTIONS_ARE_NOT_AVAILABLE;\n-        case SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION:\n-            return SHAOptionsBase.SHA1_INTRINSICS_ARE_NOT_AVAILABLE;\n-        case SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION:\n-            return SHAOptionsBase.SHA256_INTRINSICS_ARE_NOT_AVAILABLE;\n-        case SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION:\n-            return SHAOptionsBase.SHA512_INTRINSICS_ARE_NOT_AVAILABLE;\n-        default:\n-            throw new Error(\"Unexpected option \" + optionName);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the predicate indicating whether or not CPU instructions required\n-     * by the option with name {@code optionName} are available.\n-     *\n-     * @param optionName The name of the option for which a predicate should be\n-     *                   returned.\n-     * @return The predicate on availability of CPU instructions required by the\n-     *         option.\n-     *\/\n-    public static BooleanSupplier getPredicateForOption(String optionName) {\n-        switch (optionName) {\n-            case SHAOptionsBase.USE_SHA_OPTION:\n-                return IntrinsicPredicates.ANY_SHA_INSTRUCTION_AVAILABLE;\n-            case SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION:\n-                return IntrinsicPredicates.SHA1_INSTRUCTION_AVAILABLE;\n-            case SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION:\n-                return IntrinsicPredicates.SHA256_INSTRUCTION_AVAILABLE;\n-            case SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION:\n-                return IntrinsicPredicates.SHA512_INSTRUCTION_AVAILABLE;\n-            default:\n-                throw new Error(\"Unexpected option \" + optionName);\n-        }\n-    }\n-\n-    public SHAOptionsBase(TestCase... testCases) {\n-        super(Boolean.TRUE::booleanValue);\n-        this.testCases = testCases;\n-    }\n-\n-    @Override\n-    protected void runTestCases() throws Throwable {\n-        for (TestCase testCase : testCases) {\n-            testCase.test();\n-        }\n-    }\n-\n-    public static abstract class TestCase {\n-        protected final String optionName;\n-        private final BooleanSupplier predicate;\n-\n-        protected TestCase(String optionName, BooleanSupplier predicate) {\n-            this.optionName = optionName;\n-            this.predicate = predicate;\n-        }\n-\n-        protected final void test() throws Throwable {\n-            String testCaseName = this.getClass().getName();\n-            if (!predicate.getAsBoolean()) {\n-                System.out.println(\"Skipping \" + testCaseName\n-                        + \" due to predicate failure.\");\n-                return;\n-            } else {\n-                System.out.println(\"Running \" + testCaseName);\n-            }\n-\n-            verifyWarnings();\n-            verifyOptionValues();\n-        }\n-\n-        protected void verifyWarnings() throws Throwable {\n-        }\n-\n-        protected void verifyOptionValues() throws Throwable {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/SHAOptionsBase.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8035968\n+ * @summary Verify UseMD5Intrinsics option processing on supported CPU.\n+ * @library \/test\/lib testcases \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.intrinsics.sha.cli.TestUseMD5IntrinsicsOptionOnSupportedCPU\n+ *\/\n+\n+package compiler.intrinsics.sha.cli;\n+\n+import compiler.intrinsics.sha.cli.testcases.GenericTestCaseForSupportedCPU;\n+\n+public class TestUseMD5IntrinsicsOptionOnSupportedCPU {\n+    public static void main(String args[]) throws Throwable {\n+        new DigestOptionsBase(new GenericTestCaseForSupportedCPU(\n+                DigestOptionsBase.USE_MD5_INTRINSICS_OPTION, \/* checkUseSHA = *\/ false)).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseMD5IntrinsicsOptionOnSupportedCPU.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8035968\n+ * @summary Verify UseMD5Intrinsics option processing on unsupported CPU.\n+ * @library \/test\/lib testcases \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.intrinsics.sha.cli.TestUseMD5IntrinsicsOptionOnUnsupportedCPU\n+ *\/\n+\n+package compiler.intrinsics.sha.cli;\n+\n+import compiler.intrinsics.sha.cli.testcases.GenericTestCaseForOtherCPU;\n+import compiler.intrinsics.sha.cli.testcases.GenericTestCaseForUnsupportedAArch64CPU;\n+import compiler.intrinsics.sha.cli.testcases.GenericTestCaseForUnsupportedX86CPU;\n+import compiler.intrinsics.sha.cli.testcases.UseSHAIntrinsicsSpecificTestCaseForUnsupportedCPU;\n+\n+public class TestUseMD5IntrinsicsOptionOnUnsupportedCPU {\n+    public static void main(String args[]) throws Throwable {\n+        new DigestOptionsBase(\n+                new GenericTestCaseForUnsupportedX86CPU(\n+                        DigestOptionsBase.USE_MD5_INTRINSICS_OPTION, \/* checkUseSHA = *\/ false),\n+                new GenericTestCaseForUnsupportedAArch64CPU(\n+                        DigestOptionsBase.USE_MD5_INTRINSICS_OPTION, \/* checkUseSHA = *\/ false),\n+                new GenericTestCaseForOtherCPU(\n+                        DigestOptionsBase.USE_MD5_INTRINSICS_OPTION, \/* checkUseSHA = *\/ false)).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseMD5IntrinsicsOptionOnUnsupportedCPU.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -46,2 +46,2 @@\n-        new SHAOptionsBase(new GenericTestCaseForSupportedCPU(\n-                SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION)).test();\n+        new DigestOptionsBase(new GenericTestCaseForSupportedCPU(\n+                DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA1IntrinsicsOptionOnSupportedCPU.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        new SHAOptionsBase(\n+        new DigestOptionsBase(\n@@ -52,1 +52,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n@@ -54,1 +54,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n@@ -56,1 +56,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n@@ -58,1 +58,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION),\n@@ -60,1 +60,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION)).test();\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA1IntrinsicsOptionOnUnsupportedCPU.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-        new SHAOptionsBase(new GenericTestCaseForSupportedCPU(\n-                SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION)).test();\n+        new DigestOptionsBase(new GenericTestCaseForSupportedCPU(\n+                DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA256IntrinsicsOptionOnSupportedCPU.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        new SHAOptionsBase(\n+        new DigestOptionsBase(\n@@ -52,1 +52,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n@@ -54,1 +54,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n@@ -56,1 +56,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n@@ -58,1 +58,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION),\n@@ -60,1 +60,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION)).test();\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA256IntrinsicsOptionOnUnsupportedCPU.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-        new SHAOptionsBase(new GenericTestCaseForSupportedCPU(\n-                SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION)).test();\n+        new DigestOptionsBase(new GenericTestCaseForSupportedCPU(\n+                DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA512IntrinsicsOptionOnSupportedCPU.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        new SHAOptionsBase(\n+        new DigestOptionsBase(\n@@ -52,1 +52,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n@@ -54,1 +54,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n@@ -56,1 +56,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n@@ -58,1 +58,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION),\n@@ -60,1 +60,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION)).test();\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHA512IntrinsicsOptionOnUnsupportedCPU.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        new SHAOptionsBase(\n+        new DigestOptionsBase(\n@@ -49,1 +49,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION),\n+                        DigestOptionsBase.USE_SHA_OPTION),\n@@ -51,1 +51,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION)).test();\n+                        DigestOptionsBase.USE_SHA_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHAOptionOnSupportedCPU.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        new SHAOptionsBase(\n+        new DigestOptionsBase(\n@@ -51,1 +51,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION),\n+                        DigestOptionsBase.USE_SHA_OPTION),\n@@ -53,1 +53,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION),\n+                        DigestOptionsBase.USE_SHA_OPTION),\n@@ -55,1 +55,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION),\n+                        DigestOptionsBase.USE_SHA_OPTION),\n@@ -57,1 +57,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION),\n+                        DigestOptionsBase.USE_SHA_OPTION),\n@@ -59,1 +59,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION)).test();\n+                        DigestOptionsBase.USE_SHA_OPTION)).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/TestUseSHAOptionOnUnsupportedCPU.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -38,1 +38,4 @@\n-        SHAOptionsBase.TestCase {\n+        DigestOptionsBase.TestCase {\n+\n+    final private boolean checkUseSHA;\n+\n@@ -40,1 +43,5 @@\n-        \/\/ Execute the test case on any CPU except AArch64, PPC, S390x, SPARC and X86.\n+        this(optionName, true);\n+    }\n+\n+    public GenericTestCaseForOtherCPU(String optionName, boolean checkUseSHA) {\n+        \/\/ Execute the test case on any CPU except AArch64, PPC, S390x, and X86.\n@@ -48,0 +55,2 @@\n+\n+        this.checkUseSHA = checkUseSHA;\n@@ -59,1 +68,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -65,1 +74,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -75,1 +84,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n@@ -82,1 +91,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -85,9 +94,11 @@\n-        \/\/ Verify that option is disabled when it explicitly disabled\n-        \/\/ using CLI options.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should be off on unsupported CPU\"\n-                        + \" even if '%s' flag set to JVM\", optionName,\n-                        CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n+        if (checkUseSHA) {\n+            \/\/ Verify that option is disabled when it explicitly disabled\n+            \/\/ using CLI options.\n+            CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should be off on unsupported CPU\"\n+                            + \" even if '%s' flag set to JVM\", optionName,\n+                            CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/GenericTestCaseForOtherCPU.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -38,1 +38,4 @@\n-        SHAOptionsBase.TestCase {\n+        DigestOptionsBase.TestCase {\n+\n+    final private boolean checkUseSHA;\n+\n@@ -40,1 +43,7 @@\n-        super(optionName, SHAOptionsBase.getPredicateForOption(optionName));\n+        this(optionName, true);\n+    }\n+\n+    public GenericTestCaseForSupportedCPU(String optionName, boolean checkUseSHA) {\n+        super(optionName, DigestOptionsBase.getPredicateForOption(optionName));\n+\n+        this.checkUseSHA = checkUseSHA;\n@@ -50,1 +59,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -52,1 +61,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -55,24 +64,9 @@\n-        \/\/ Verify that option could be disabled even if +UseSHA was passed to\n-        \/\/ JVM.\n-        CommandLineOptionTest.verifySameJVMStartup(null, new String[] {\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n-                }, shouldPassMessage, String.format(\"It should be able to \"\n-                        + \"disable option '%s' even if %s was passed to JVM\",\n-                        optionName, CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, true)),\n-                ExitCode.OK,\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true),\n-                CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n-\n-        if (!optionName.equals(SHAOptionsBase.USE_SHA_OPTION)) {\n-            \/\/ Verify that if -XX:-UseSHA is passed to the JVM, it is not possible\n-            \/\/ to enable the tested option and a warning is printed.\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { SHAOptionsBase.getWarningForUnsupportedCPU(optionName) },\n-                    null,\n-                    shouldPassMessage,\n-                    String.format(\"Enabling option '%s' should not be possible and should result in a warning if %s was passed to JVM\",\n-                                  optionName,\n-                                  CommandLineOptionTest.prepareBooleanFlag(SHAOptionsBase.USE_SHA_OPTION, false)),\n+        if (checkUseSHA) {\n+            \/\/ Verify that option could be disabled even if +UseSHA was passed to\n+            \/\/ JVM.\n+            CommandLineOptionTest.verifySameJVMStartup(null, new String[] {\n+                            DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                    }, shouldPassMessage, String.format(\"It should be able to \"\n+                            + \"disable option '%s' even if %s was passed to JVM\",\n+                            optionName, CommandLineOptionTest.prepareBooleanFlag(\n+                                DigestOptionsBase.USE_SHA_OPTION, true)),\n@@ -80,3 +74,20 @@\n-                    SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                    CommandLineOptionTest.prepareBooleanFlag(SHAOptionsBase.USE_SHA_OPTION, false),\n-                    CommandLineOptionTest.prepareBooleanFlag(optionName, true));\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true),\n+                    CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n+\n+            if (!optionName.equals(DigestOptionsBase.USE_SHA_OPTION)) {\n+                \/\/ Verify that if -XX:-UseSHA is passed to the JVM, it is not possible\n+                \/\/ to enable the tested option and a warning is printed.\n+                CommandLineOptionTest.verifySameJVMStartup(\n+                        new String[] { DigestOptionsBase.getWarningForUnsupportedCPU(optionName) },\n+                        null,\n+                        shouldPassMessage,\n+                        String.format(\"Enabling option '%s' should not be possible and should result in a warning if %s was passed to JVM\",\n+                                    optionName,\n+                                    CommandLineOptionTest.prepareBooleanFlag(DigestOptionsBase.USE_SHA_OPTION, false)),\n+                        ExitCode.OK,\n+                        DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                        CommandLineOptionTest.prepareBooleanFlag(DigestOptionsBase.USE_SHA_OPTION, false),\n+                        CommandLineOptionTest.prepareBooleanFlag(optionName, true));\n+            }\n@@ -93,1 +104,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n@@ -99,1 +110,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -106,1 +117,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -109,22 +120,24 @@\n-        \/\/ verify that option is disabled when -UseSHA was passed to JVM.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should have value 'false' when %s\"\n-                        + \" flag set to JVM\", optionName,\n-                        CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, false)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(optionName, true),\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, false));\n-\n-        \/\/ Verify that it is possible to explicitly disable the tested option\n-        \/\/ even if +UseSHA was passed to JVM.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should have value 'false' if set so\"\n-                        + \" even if %s flag set to JVM\", optionName,\n-                        CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true),\n-                CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n+        if (checkUseSHA) {\n+            \/\/ verify that option is disabled when -UseSHA was passed to JVM.\n+            CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should have value 'false' when %s\"\n+                            + \" flag set to JVM\", optionName,\n+                            CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, false)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(optionName, true),\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, false));\n+\n+            \/\/ Verify that it is possible to explicitly disable the tested option\n+            \/\/ even if +UseSHA was passed to JVM.\n+            CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should have value 'false' if set so\"\n+                            + \" even if %s flag set to JVM\", optionName,\n+                            CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true),\n+                    CommandLineOptionTest.prepareBooleanFlag(optionName, false));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/GenericTestCaseForSupportedCPU.java","additions":71,"deletions":58,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -38,1 +38,4 @@\n-        SHAOptionsBase.TestCase {\n+        DigestOptionsBase.TestCase {\n+\n+    final private boolean checkUseSHA;\n+\n@@ -40,0 +43,4 @@\n+        this(optionName, true);\n+    }\n+\n+    public GenericTestCaseForUnsupportedAArch64CPU(String optionName, boolean checkUseSHA) {\n@@ -41,1 +48,1 @@\n-                new NotPredicate(SHAOptionsBase.getPredicateForOption(\n+                new NotPredicate(DigestOptionsBase.getPredicateForOption(\n@@ -43,0 +50,2 @@\n+\n+        this.checkUseSHA = checkUseSHA;\n@@ -51,1 +60,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -53,1 +62,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -56,3 +65,4 @@\n-        shouldPassMessage = String.format(\"If JVM is started with '-XX:-\"\n-                + \"%s' '-XX:+%s', output should contain warning.\",\n-                SHAOptionsBase.USE_SHA_OPTION, optionName);\n+        if (checkUseSHA) {\n+            shouldPassMessage = String.format(\"If JVM is started with '-XX:-\"\n+                    + \"%s' '-XX:+%s', output should contain warning.\",\n+                    DigestOptionsBase.USE_SHA_OPTION, optionName);\n@@ -60,12 +70,13 @@\n-        \/\/ Verify that when the tested option is enabled, then\n-        \/\/ a warning will occur in VM output if UseSHA is disabled.\n-        if (!optionName.equals(SHAOptionsBase.USE_SHA_OPTION)) {\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { SHAOptionsBase.getWarningForUnsupportedCPU(optionName) },\n-                    null,\n-                    shouldPassMessage,\n-                    shouldPassMessage,\n-                    ExitCode.OK,\n-                    SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                    CommandLineOptionTest.prepareBooleanFlag(SHAOptionsBase.USE_SHA_OPTION, false),\n-                    CommandLineOptionTest.prepareBooleanFlag(optionName, true));\n+            \/\/ Verify that when the tested option is enabled, then\n+            \/\/ a warning will occur in VM output if UseSHA is disabled.\n+            if (!optionName.equals(DigestOptionsBase.USE_SHA_OPTION)) {\n+                CommandLineOptionTest.verifySameJVMStartup(\n+                        new String[] { DigestOptionsBase.getWarningForUnsupportedCPU(optionName) },\n+                        null,\n+                        shouldPassMessage,\n+                        shouldPassMessage,\n+                        ExitCode.OK,\n+                        DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                        CommandLineOptionTest.prepareBooleanFlag(DigestOptionsBase.USE_SHA_OPTION, false),\n+                        CommandLineOptionTest.prepareBooleanFlag(optionName, true));\n+            }\n@@ -81,1 +92,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n@@ -88,1 +99,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -91,9 +102,11 @@\n-        \/\/ Verify that option is disabled when +UseSHA was passed to JVM.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should be off on unsupported \"\n-                        + \"AArch64CPU even if %s flag set to JVM\",\n-                        optionName, CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true));\n+        if (checkUseSHA) {\n+            \/\/ Verify that option is disabled when +UseSHA was passed to JVM.\n+            CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should be off on unsupported \"\n+                            + \"AArch64CPU even if %s flag set to JVM\",\n+                            optionName, CommandLineOptionTest.prepareBooleanFlag(\n+                                DigestOptionsBase.USE_SHA_OPTION, true)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/GenericTestCaseForUnsupportedAArch64CPU.java","additions":45,"deletions":32,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -38,1 +38,4 @@\n-        SHAOptionsBase.TestCase {\n+        DigestOptionsBase.TestCase {\n+\n+    final private boolean checkUseSHA;\n+\n@@ -40,0 +43,4 @@\n+        this(optionName, true);\n+    }\n+\n+    public GenericTestCaseForUnsupportedSparcCPU(String optionName, boolean checkUseSHA) {\n@@ -41,1 +48,1 @@\n-                new NotPredicate(SHAOptionsBase.getPredicateForOption(\n+                new NotPredicate(DigestOptionsBase.getPredicateForOption(\n@@ -43,0 +50,2 @@\n+\n+        this.checkUseSHA = checkUseSHA;\n@@ -51,1 +60,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -53,1 +62,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -58,1 +67,1 @@\n-        if (!optionName.equals(SHAOptionsBase.USE_SHA_OPTION)) {\n+        if (checkUseSHA && !optionName.equals(DigestOptionsBase.USE_SHA_OPTION)) {\n@@ -60,1 +69,1 @@\n-                    new String[] { SHAOptionsBase.getWarningForUnsupportedCPU(optionName) },\n+                    new String[] { DigestOptionsBase.getWarningForUnsupportedCPU(optionName) },\n@@ -65,2 +74,2 @@\n-                    SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                    CommandLineOptionTest.prepareBooleanFlag(SHAOptionsBase.USE_SHA_OPTION, false),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(DigestOptionsBase.USE_SHA_OPTION, false),\n@@ -77,1 +86,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n@@ -84,1 +93,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -87,9 +96,11 @@\n-        \/\/ Verify that option is disabled when +UseSHA was passed to JVM.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should be off on unsupported \"\n-                        + \"SparcCPU even if %s flag set to JVM\",\n-                        optionName, CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true));\n+        if (checkUseSHA) {\n+             \/\/ Verify that option is disabled when +UseSHA was passed to JVM.\n+             CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should be off on unsupported \"\n+                            + \"SparcCPU even if %s flag set to JVM\",\n+                            optionName, CommandLineOptionTest.prepareBooleanFlag(\n+                                DigestOptionsBase.USE_SHA_OPTION, true)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/GenericTestCaseForUnsupportedSparcCPU.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -39,1 +39,4 @@\n-        extends SHAOptionsBase.TestCase {\n+        extends DigestOptionsBase.TestCase {\n+\n+    final private boolean checkUseSHA;\n+\n@@ -41,0 +44,4 @@\n+        this(optionName, true);\n+    }\n+\n+    public GenericTestCaseForUnsupportedX86CPU(String optionName, boolean checkUseSHA) {\n@@ -42,1 +49,1 @@\n-                new NotPredicate(SHAOptionsBase.getPredicateForOption(\n+                new NotPredicate(DigestOptionsBase.getPredicateForOption(\n@@ -44,0 +51,2 @@\n+\n+        this.checkUseSHA = checkUseSHA;\n@@ -53,1 +62,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -55,1 +64,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -60,1 +69,1 @@\n-        if (!optionName.equals(SHAOptionsBase.USE_SHA_OPTION)) {\n+        if (checkUseSHA && !optionName.equals(DigestOptionsBase.USE_SHA_OPTION)) {\n@@ -62,1 +71,1 @@\n-                    new String[] { SHAOptionsBase.getWarningForUnsupportedCPU(optionName) },\n+                    new String[] { DigestOptionsBase.getWarningForUnsupportedCPU(optionName) },\n@@ -67,2 +76,2 @@\n-                    SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                    CommandLineOptionTest.prepareBooleanFlag(SHAOptionsBase.USE_SHA_OPTION, false),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(DigestOptionsBase.USE_SHA_OPTION, false),\n@@ -79,1 +88,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n@@ -85,1 +94,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -88,10 +97,12 @@\n-        \/\/ Verify that the tested option is disabled even if +UseSHA was passed\n-        \/\/ to JVM.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n-                String.format(\"Option '%s' should be off on unsupported \"\n-                        + \"X86CPU even if %s flag set to JVM\",\n-                        optionName, CommandLineOptionTest.prepareBooleanFlag(\n-                            SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        SHAOptionsBase.USE_SHA_OPTION, true));\n+        if (checkUseSHA) {\n+            \/\/ Verify that the tested option is disabled even if +UseSHA was passed\n+            \/\/ to JVM.\n+            CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"false\",\n+                    String.format(\"Option '%s' should be off on unsupported \"\n+                            + \"X86CPU even if %s flag set to JVM\",\n+                            optionName, CommandLineOptionTest.prepareBooleanFlag(\n+                                DigestOptionsBase.USE_SHA_OPTION, true)),\n+                    DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    CommandLineOptionTest.prepareBooleanFlag(\n+                            DigestOptionsBase.USE_SHA_OPTION, true));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/GenericTestCaseForUnsupportedX86CPU.java","additions":33,"deletions":22,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -44,1 +44,1 @@\n-        extends SHAOptionsBase.TestCase {\n+        extends DigestOptionsBase.TestCase {\n@@ -51,1 +51,1 @@\n-                new NotPredicate(SHAOptionsBase.getPredicateForOption(optionName))));\n+                new NotPredicate(DigestOptionsBase.getPredicateForOption(optionName))));\n@@ -60,1 +60,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -62,1 +62,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/UseSHAIntrinsicsSpecificTestCaseForUnsupportedCPU.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -39,1 +39,1 @@\n-        extends SHAOptionsBase.TestCase {\n+        extends DigestOptionsBase.TestCase {\n@@ -41,1 +41,1 @@\n-        super(SHAOptionsBase.USE_SHA_OPTION,\n+        super(DigestOptionsBase.USE_SHA_OPTION,\n@@ -44,1 +44,1 @@\n-        Asserts.assertEQ(optionName, SHAOptionsBase.USE_SHA_OPTION,\n+        Asserts.assertEQ(optionName, DigestOptionsBase.USE_SHA_OPTION,\n@@ -46,1 +46,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION));\n+                        DigestOptionsBase.USE_SHA_OPTION));\n@@ -55,1 +55,1 @@\n-                            SHAOptionsBase.USE_SHA_OPTION, true));\n+                            DigestOptionsBase.USE_SHA_OPTION, true));\n@@ -61,1 +61,1 @@\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -63,1 +63,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION, true),\n+                        DigestOptionsBase.USE_SHA_OPTION, true),\n@@ -65,1 +65,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n@@ -67,1 +67,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n@@ -69,1 +69,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n@@ -77,1 +77,1 @@\n-                SHAOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n+                DigestOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n@@ -79,2 +79,2 @@\n-                        + \" disabled\", SHAOptionsBase.USE_SHA_OPTION),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                        + \" disabled\", DigestOptionsBase.USE_SHA_OPTION),\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -82,1 +82,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n@@ -84,1 +84,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n@@ -86,1 +86,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n@@ -91,1 +91,1 @@\n-                SHAOptionsBase.USE_SHA_OPTION, \"false\",\n+                DigestOptionsBase.USE_SHA_OPTION, \"false\",\n@@ -94,1 +94,1 @@\n-                        + \"to JVM\", SHAOptionsBase.USE_SHA_OPTION,\n+                        + \"to JVM\", DigestOptionsBase.USE_SHA_OPTION,\n@@ -96,2 +96,2 @@\n-                             SHAOptionsBase.USE_SHA_OPTION, true)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                             DigestOptionsBase.USE_SHA_OPTION, true)),\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -99,1 +99,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION, true),\n+                        DigestOptionsBase.USE_SHA_OPTION, true),\n@@ -101,1 +101,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, false),\n@@ -103,1 +103,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, false),\n@@ -105,1 +105,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, false));\n@@ -110,1 +110,1 @@\n-                SHAOptionsBase.USE_SHA_OPTION, \"false\",\n+                DigestOptionsBase.USE_SHA_OPTION, \"false\",\n@@ -113,1 +113,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION,\n+                        DigestOptionsBase.USE_SHA_OPTION,\n@@ -115,2 +115,2 @@\n-                            SHAOptionsBase.USE_SHA_OPTION, false)),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                            DigestOptionsBase.USE_SHA_OPTION, false)),\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -118,1 +118,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION, false),\n+                        DigestOptionsBase.USE_SHA_OPTION, false),\n@@ -120,1 +120,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n@@ -122,1 +122,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n@@ -124,1 +124,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/UseSHASpecificTestCaseForSupportedCPU.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.intrinsics.sha.cli.SHAOptionsBase;\n+import compiler.intrinsics.sha.cli.DigestOptionsBase;\n@@ -41,1 +41,1 @@\n-        extends SHAOptionsBase.TestCase {\n+        extends DigestOptionsBase.TestCase {\n@@ -43,1 +43,1 @@\n-        super(SHAOptionsBase.USE_SHA_OPTION, new NotPredicate(\n+        super(DigestOptionsBase.USE_SHA_OPTION, new NotPredicate(\n@@ -46,2 +46,2 @@\n-        Asserts.assertEQ(optionName, SHAOptionsBase.USE_SHA_OPTION,\n-                \"Test case should be used for \" + SHAOptionsBase.USE_SHA_OPTION\n+        Asserts.assertEQ(optionName, DigestOptionsBase.USE_SHA_OPTION,\n+                \"Test case should be used for \" + DigestOptionsBase.USE_SHA_OPTION\n@@ -58,1 +58,1 @@\n-                        SHAOptionsBase.getWarningForUnsupportedCPU(optionName)\n+                        DigestOptionsBase.getWarningForUnsupportedCPU(optionName)\n@@ -68,1 +68,1 @@\n-                SHAOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n+                DigestOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n@@ -71,2 +71,2 @@\n-                    SHAOptionsBase.USE_SHA_OPTION),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    DigestOptionsBase.USE_SHA_OPTION),\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -74,1 +74,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n@@ -76,1 +76,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n@@ -78,1 +78,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n@@ -83,1 +83,1 @@\n-                SHAOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n+                DigestOptionsBase.USE_SHA_OPTION, \"false\", String.format(\n@@ -87,3 +87,3 @@\n-                    SHAOptionsBase.USE_SHA_OPTION,\n-                    SHAOptionsBase.USE_SHA_OPTION),\n-                SHAOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n+                    DigestOptionsBase.USE_SHA_OPTION,\n+                    DigestOptionsBase.USE_SHA_OPTION),\n+                DigestOptionsBase.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n@@ -91,1 +91,1 @@\n-                        SHAOptionsBase.USE_SHA_OPTION, true),\n+                        DigestOptionsBase.USE_SHA_OPTION, true),\n@@ -93,1 +93,1 @@\n-                        SHAOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA1_INTRINSICS_OPTION, true),\n@@ -95,1 +95,1 @@\n-                        SHAOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n+                        DigestOptionsBase.USE_SHA256_INTRINSICS_OPTION, true),\n@@ -97,1 +97,1 @@\n-                        SHAOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n+                        DigestOptionsBase.USE_SHA512_INTRINSICS_OPTION, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/cli\/testcases\/UseSHASpecificTestCaseForUnsupportedCPU.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.sha.sanity;\n+\n+import compiler.intrinsics.sha.TestDigest;\n+import compiler.testlibrary.intrinsics.Verifier;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.function.BooleanSupplier;\n+\n+\/**\n+ * Base class for sanity tests on SHA intrinsics support.\n+ *\/\n+public class DigestSanityTestBase {\n+    protected static final String MD5_INTRINSIC_ID\n+            = \"_md5_implCompress\";\n+    protected static final String SHA1_INTRINSIC_ID\n+            = \"_sha_implCompress\";\n+    protected static final String SHA256_INTRINSIC_ID\n+            = \"_sha2_implCompress\";\n+    protected static final String SHA512_INTRINSIC_ID\n+            = \"_sha5_implCompress\";\n+    protected static final String MB_INTRINSIC_ID\n+            = \"_digestBase_implCompressMB\";\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final int MSG_SIZE = 1024;\n+    private static final int OFFSET = 0;\n+    private static final int ITERATIONS = 10000;\n+    private static final int WARMUP_ITERATIONS = 1;\n+    private static final String PROVIDER = \"SUN\";\n+\n+    private final BooleanSupplier predicate;\n+    private final String intrinsicID;\n+\n+    \/**\n+     * Construct the new test on intrinsic with ID {@code intrinsicID},\n+     * which is expected to be emitted if {@code predicate} is evaluated to\n+     * {@code true}.\n+     *\n+     * @param predicate The predicate indicating if the intrinsic is expected to\n+     *                  be used.\n+     * @param intrinsicID The ID of the intrinsic to be tested.\n+     *\/\n+    protected DigestSanityTestBase(BooleanSupplier predicate, String intrinsicID) {\n+        this.predicate = predicate;\n+        this.intrinsicID = intrinsicID;\n+    }\n+\n+    \/**\n+     * Run the test and dump properties to file.\n+     *\n+     * @throws Exception when something went wrong.\n+     *\/\n+    public final void test() throws Exception {\n+        String algorithm = Objects.requireNonNull(\n+                System.getProperty(\"algorithm\"),\n+                \"Algorithm name should be specified.\");\n+\n+        dumpProperties();\n+\n+        TestDigest.testDigest(DigestSanityTestBase.PROVIDER, algorithm,\n+                DigestSanityTestBase.MSG_SIZE, DigestSanityTestBase.OFFSET,\n+                DigestSanityTestBase.ITERATIONS,\n+                DigestSanityTestBase.WARMUP_ITERATIONS);\n+    }\n+\n+    \/**\n+     * Dump properties containing information about the tested intrinsic name\n+     * and whether or not is should be used to the file\n+     * &lt;LogFile value&gt;.verify.properties.\n+     *\n+     * @throws IOException when something went wrong during dumping to file.\n+     *\/\n+    private void dumpProperties() throws IOException {\n+        Properties properties = new Properties();\n+        properties.setProperty(Verifier.INTRINSIC_NAME_PROPERTY, intrinsicID);\n+        properties.setProperty(Verifier.INTRINSIC_IS_EXPECTED_PROPERTY,\n+                String.valueOf(predicate.getAsBoolean()));\n+\n+        String logFileName\n+                = DigestSanityTestBase.WHITE_BOX.getStringVMFlag(\"LogFile\");\n+        FileOutputStream fileOutputStream = new FileOutputStream(logFileName\n+                + Verifier.PROPERTY_FILE_SUFFIX);\n+\n+        properties.store(fileOutputStream, null);\n+        fileOutputStream.close();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/DigestSanityTestBase.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.intrinsics.sha.sanity;\n-\n-import compiler.intrinsics.sha.TestSHA;\n-import compiler.testlibrary.intrinsics.Verifier;\n-import sun.hotspot.WhiteBox;\n-\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.Objects;\n-import java.util.Properties;\n-import java.util.function.BooleanSupplier;\n-\n-\/**\n- * Base class for sanity tests on SHA intrinsics support.\n- *\/\n-public class SHASanityTestBase {\n-    protected static final String SHA1_INTRINSIC_ID\n-            = \"_sha_implCompress\";\n-    protected static final String SHA256_INTRINSIC_ID\n-            = \"_sha2_implCompress\";\n-    protected static final String SHA512_INTRINSIC_ID\n-            = \"_sha5_implCompress\";\n-    protected static final String MB_INTRINSIC_ID\n-            = \"_digestBase_implCompressMB\";\n-\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-    private static final int MSG_SIZE = 1024;\n-    private static final int OFFSET = 0;\n-    private static final int ITERATIONS = 10000;\n-    private static final int WARMUP_ITERATIONS = 1;\n-    private static final String PROVIDER = \"SUN\";\n-\n-    private final BooleanSupplier predicate;\n-    private final String intrinsicID;\n-\n-    \/**\n-     * Construct the new test on intrinsic with ID {@code intrinsicID},\n-     * which is expected to be emitted if {@code predicate} is evaluated to\n-     * {@code true}.\n-     *\n-     * @param predicate The predicate indicating if the intrinsic is expected to\n-     *                  be used.\n-     * @param intrinsicID The ID of the intrinsic to be tested.\n-     *\/\n-    protected SHASanityTestBase(BooleanSupplier predicate, String intrinsicID) {\n-        this.predicate = predicate;\n-        this.intrinsicID = intrinsicID;\n-    }\n-\n-    \/**\n-     * Run the test and dump properties to file.\n-     *\n-     * @throws Exception when something went wrong.\n-     *\/\n-    public final void test() throws Exception {\n-        String algorithm = Objects.requireNonNull(\n-                System.getProperty(\"algorithm\"),\n-                \"Algorithm name should be specified.\");\n-\n-        dumpProperties();\n-\n-        TestSHA.testSHA(SHASanityTestBase.PROVIDER, algorithm,\n-                SHASanityTestBase.MSG_SIZE, SHASanityTestBase.OFFSET,\n-                SHASanityTestBase.ITERATIONS,\n-                SHASanityTestBase.WARMUP_ITERATIONS);\n-    }\n-\n-    \/**\n-     * Dump properties containing information about the tested intrinsic name\n-     * and whether or not is should be used to the file\n-     * &lt;LogFile value&gt;.verify.properties.\n-     *\n-     * @throws IOException when something went wrong during dumping to file.\n-     *\/\n-    private void dumpProperties() throws IOException {\n-        Properties properties = new Properties();\n-        properties.setProperty(Verifier.INTRINSIC_NAME_PROPERTY, intrinsicID);\n-        properties.setProperty(Verifier.INTRINSIC_IS_EXPECTED_PROPERTY,\n-                String.valueOf(predicate.getAsBoolean()));\n-\n-        String logFileName\n-                = SHASanityTestBase.WHITE_BOX.getStringVMFlag(\"LogFile\");\n-        FileOutputStream fileOutputStream = new FileOutputStream(logFileName\n-                + Verifier.PROPERTY_FILE_SUFFIX);\n-\n-        properties.store(fileOutputStream, null);\n-        fileOutputStream.close();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/SHASanityTestBase.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8035968\n+ * @summary Verify that MD5 intrinsic is actually used.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -Xbatch -XX:CompileThreshold=500\n+ *                   -XX:Tier4InvocationThreshold=500\n+ *                   -XX:+LogCompilation -XX:LogFile=positive.log\n+ *                   -XX:CompileOnly=sun\/security\/provider\/DigestBase\n+ *                   -XX:CompileOnly=sun\/security\/provider\/MD5\n+ *                   -XX:+UseMD5Intrinsics\n+ *                   -Dalgorithm=MD5\n+ *                   compiler.intrinsics.sha.sanity.TestMD5Intrinsics\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -Xbatch -XX:CompileThreshold=500\n+ *                   -XX:Tier4InvocationThreshold=500\n+ *                   -XX:+LogCompilation -XX:LogFile=negative.log\n+ *                   -XX:CompileOnly=sun\/security\/provider\/DigestBase\n+ *                   -XX:CompileOnly=sun\/security\/provider\/MD5\n+ *                   -XX:-UseMD5Intrinsics\n+ *                   -Dalgorithm=MD5\n+ *                   compiler.intrinsics.sha.sanity.TestMD5Intrinsics\n+ * @run main\/othervm -DverificationStrategy=VERIFY_INTRINSIC_USAGE\n+ *                   compiler.testlibrary.intrinsics.Verifier positive.log negative.log\n+ *\/\n+\n+package compiler.intrinsics.sha.sanity;\n+\n+import compiler.testlibrary.sha.predicate.IntrinsicPredicates;\n+\n+public class TestMD5Intrinsics {\n+    public static void main(String args[]) throws Exception {\n+        new DigestSanityTestBase(IntrinsicPredicates.isMD5IntrinsicAvailable(),\n+                DigestSanityTestBase.MD5_INTRINSIC_ID).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestMD5Intrinsics.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8035968\n+ * @summary Verify that MD5 multi block intrinsic is actually used.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -Xbatch -XX:CompileThreshold=500\n+ *                   -XX:Tier4InvocationThreshold=500\n+ *                   -XX:+LogCompilation -XX:LogFile=positive.log\n+ *                   -XX:CompileOnly=sun\/security\/provider\/DigestBase\n+ *                   -XX:CompileOnly=sun\/security\/provider\/MD5\n+ *                   -XX:+UseMD5Intrinsics -XX:-UseSHA1Intrinsics\n+ *                   -XX:-UseSHA256Intrinsics -XX:-UseSHA512Intrinsics\n+ *                   -Dalgorithm=MD5\n+ *                   compiler.intrinsics.sha.sanity.TestMD5MultiBlockIntrinsics\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -Xbatch -XX:CompileThreshold=500\n+ *                   -XX:Tier4InvocationThreshold=500\n+ *                   -XX:+LogCompilation -XX:LogFile=positive_def.log\n+ *                   -XX:CompileOnly=sun\/security\/provider\/DigestBase\n+ *                   -XX:CompileOnly=sun\/security\/provider\/MD5\n+ *                   -XX:+UseMD5Intrinsics -Dalgorithm=MD5\n+ *                   compiler.intrinsics.sha.sanity.TestMD5MultiBlockIntrinsics\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -Xbatch -XX:CompileThreshold=500\n+ *                   -XX:Tier4InvocationThreshold=500\n+ *                   -XX:+LogCompilation -XX:LogFile=negative.log\n+ *                   -XX:CompileOnly=sun\/security\/provider\/DigestBase\n+ *                   -XX:CompileOnly=sun\/security\/provider\/MD5\n+ *                   -Dalgorithm=MD5\n+ *                   compiler.intrinsics.sha.sanity.TestMD5MultiBlockIntrinsics\n+ * @run main\/othervm -DverificationStrategy=VERIFY_INTRINSIC_USAGE\n+ *                   compiler.testlibrary.intrinsics.Verifier positive.log positive_def.log\n+ *                   negative.log\n+ *\/\n+\n+package compiler.intrinsics.sha.sanity;\n+import compiler.testlibrary.sha.predicate.IntrinsicPredicates;\n+\n+public class TestMD5MultiBlockIntrinsics {\n+    public static void main(String args[]) throws Exception {\n+        new DigestSanityTestBase(IntrinsicPredicates.isMD5IntrinsicAvailable(),\n+                DigestSanityTestBase.MB_INTRINSIC_ID).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestMD5MultiBlockIntrinsics.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -63,2 +63,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA1IntrinsicAvailable(),\n-                SHASanityTestBase.SHA1_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA1IntrinsicAvailable(),\n+                DigestSanityTestBase.SHA1_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA1Intrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n- *                   -XX:+UseSHA1Intrinsics -XX:-UseSHA256Intrinsics\n- *                   -XX:-UseSHA512Intrinsics\n+ *                   -XX:+UseSHA1Intrinsics -XX:-UseMD5Intrinsics\n+ *                   -XX:-UseSHA256Intrinsics -XX:-UseSHA512Intrinsics\n@@ -71,2 +71,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA1IntrinsicAvailable(),\n-                SHASanityTestBase.MB_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA1IntrinsicAvailable(),\n+                DigestSanityTestBase.MB_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA1MultiBlockIntrinsics.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA256IntrinsicAvailable(),\n-                SHASanityTestBase.SHA256_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA256IntrinsicAvailable(),\n+                DigestSanityTestBase.SHA256_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA256Intrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n- *                   -XX:+UseSHA256Intrinsics -XX:-UseSHA1Intrinsics\n- *                   -XX:-UseSHA512Intrinsics\n+ *                   -XX:+UseSHA256Intrinsics -XX:-UseMD5Intrinsics\n+ *                   -XX:-UseSHA1Intrinsics -XX:-UseSHA512Intrinsics\n@@ -67,2 +67,2 @@\n- *                   -XX:+UseSHA256Intrinsics -XX:-UseSHA1Intrinsics\n- *                   -XX:-UseSHA512Intrinsics\n+ *                   -XX:+UseSHA256Intrinsics -XX:-UseMD5Intrinsics\n+ *                   -XX:-UseSHA1Intrinsics -XX:-UseSHA512Intrinsics\n@@ -98,2 +98,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA256IntrinsicAvailable(),\n-                SHASanityTestBase.MB_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA256IntrinsicAvailable(),\n+                DigestSanityTestBase.MB_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA256MultiBlockIntrinsics.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA512IntrinsicAvailable(),\n-                SHASanityTestBase.SHA512_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA512IntrinsicAvailable(),\n+                DigestSanityTestBase.SHA512_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA512Intrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n- *                   -XX:+UseSHA512Intrinsics -XX:-UseSHA1Intrinsics\n- *                   -XX:-UseSHA256Intrinsics\n+ *                   -XX:+UseSHA512Intrinsics -XX:-UseMD5Intrinsics\n+ *                   -XX:-UseSHA1Intrinsics -XX:-UseSHA256Intrinsics\n@@ -67,2 +67,2 @@\n- *                   -XX:+UseSHA512Intrinsics -XX:-UseSHA1Intrinsics\n- *                   -XX:-UseSHA256Intrinsics\n+ *                   -XX:+UseSHA512Intrinsics -XX:-UseMD5Intrinsics\n+ *                   -XX:-UseSHA1Intrinsics -XX:-UseSHA256Intrinsics\n@@ -99,2 +99,2 @@\n-        new SHASanityTestBase(IntrinsicPredicates.isSHA512IntrinsicAvailable(),\n-                SHASanityTestBase.MB_INTRINSIC_ID).test();\n+        new DigestSanityTestBase(IntrinsicPredicates.isSHA512IntrinsicAvailable(),\n+                DigestSanityTestBase.MB_INTRINSIC_ID).test();\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/sha\/sanity\/TestSHA512MultiBlockIntrinsics.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+    public static final BooleanSupplier MD5_INSTRUCTION_AVAILABLE\n+            = \/\/ x86 variants\n+              new OrPredicate(new CPUSpecificPredicate(\"amd64.*\",   null, null),\n+              new OrPredicate(new CPUSpecificPredicate(\"i386.*\",    null, null),\n+                              new CPUSpecificPredicate(\"x86.*\",     null, null)));\n+\n@@ -103,0 +109,5 @@\n+    public static BooleanSupplier isMD5IntrinsicAvailable() {\n+        return new AndPredicate(IntrinsicPredicates.COMPILABLE_BY_C2,\n+                                IntrinsicPredicates.isIntrinsicAvailable(\"sun.security.provider.MD5\", \"implCompress0\"));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/sha\/predicate\/IntrinsicPredicates.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}