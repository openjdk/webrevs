{"files":[{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Panel;\n+\n+\/*\n+ *  @test\n+ *  @bug 4115139 4128213\n+ *  @summary Tests that the (rather bizarre) rules for handling selection\n+ *  in Choice components are implemented as documented in\n+ *  \"The Java Class Libraries 2nd Edition\"\n+ *  @key headful\n+ *\/\n+\n+public class ChoiceSelectTest extends Panel {\n+    final Choice c;\n+\n+    public ChoiceSelectTest() {\n+        setLayout(new FlowLayout());\n+        c = new Choice();\n+        add(c);\n+    }\n+\n+    private void test() {\n+        testAddition();\n+        testInsertion();\n+        testRemoval();\n+        testIndices();\n+    }\n+\n+    public void testAddition() {\n+        c.removeAll();\n+\n+        \/\/ check that after first item added selection is zero\n+        c.addItem(\"zero\");\n+        if (c.getSelectedIndex() != 0) {\n+            throw new SelectionException(\"selection wrong after first add\");\n+        }\n+\n+        \/\/ check that selection doesn't change for subsequent adds\n+        c.addItem(\"one\");\n+        c.select(1);\n+        c.addItem(\"two\");\n+        if (c.getSelectedIndex() != 1) {\n+            throw new SelectionException(\"selection wrong after subsequent add\");\n+        }\n+    }\n+\n+    public void testInsertion() {\n+        c.removeAll();\n+\n+        \/\/ check that after first item inserted selection is zero\n+        c.insert(\"zero\", 0);\n+        if (c.getSelectedIndex() != 0) {\n+            throw new SelectionException(\"selection wrong after first insert\");\n+        }\n+\n+        \/\/ check that if selected item shifted, selection goes to zero\n+        c.insert(\"three\", 1);\n+        c.select(1);\n+        c.insert(\"one\", 1);\n+        if (c.getSelectedIndex() != 0) {\n+            throw new SelectionException(\"selection wrong after selected item shifted\");\n+        }\n+\n+        \/\/ check that if selected item not shifted, selection stays the same\n+        c.select(1);\n+        c.insert(\"two\", 2);\n+        if (c.getSelectedIndex() != 1) {\n+            throw new SelectionException(\"selection wrong after item inserted after selection\");\n+        }\n+    }\n+\n+    public void testRemoval() {\n+        c.removeAll();\n+\n+        \/\/ check that if removing selected item, selection goes to 0\n+        c.add(\"zero\");\n+        c.add(\"one\");\n+        c.add(\"two\");\n+        c.select(2);\n+        c.remove(2);\n+        if (c.getSelectedIndex() != 0) {\n+            throw new SelectionException(\"selection wrong after removing selected item\");\n+        }\n+\n+        \/\/ check that if removing item before the selection\n+        \/\/ the selected index is updated\n+        c.add(\"two\");\n+        c.add(\"three\");\n+        c.select(3);\n+        c.remove(1);\n+        if (c.getSelectedIndex() != 2) {\n+            throw new SelectionException(\"selection wrong after removing item before it\");\n+        }\n+    }\n+\n+    public void testIndices() {\n+        c.removeAll();\n+\n+        c.addItem(\"zero\");\n+        c.addItem(\"one\");\n+        c.addItem(\"two\");\n+        c.addItem(\"three\");\n+        c.addItem(\"four\");\n+        c.addItem(\"five\");\n+\n+        \/\/ Test selection of negative index\n+        try {\n+            c.select(-1);\n+            throw new SelectionException(\"Negative Index Test FAILED\");\n+        } catch (IllegalArgumentException expected) {}\n+\n+        \/\/ Test selection of zero index\n+        try {\n+            c.select(0);\n+        } catch (IllegalArgumentException iae) {\n+            throw new SelectionException(\"Zero Index Test FAILED\", iae);\n+        }\n+\n+        \/\/ Test selection of maximum index\n+        try {\n+            c.select(5);\n+        } catch (IllegalArgumentException iae) {\n+            throw new SelectionException(\"Maximum Index Test FAILED\", iae);\n+        }\n+\n+        \/\/ Test selection of index that is too large\n+        try {\n+            c.select(6);\n+            throw new SelectionException(\"Greater than Maximum Index Test FAILED\");\n+        } catch (IllegalArgumentException expected) {}\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> new ChoiceSelectTest().test());\n+    }\n+\n+    class SelectionException extends RuntimeException {\n+        SelectionException(String msg, Throwable cause) {\n+            super(msg, cause);\n+            System.out.println(\n+                    \"Selection item is '\" + c.getSelectedItem() +\n+                            \"' at index \" + c.getSelectedIndex());\n+        }\n+\n+        SelectionException(String msg) {\n+            this(msg, null);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceSelectTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Label;\n+import java.awt.Panel;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @summary automated test for \"displayable\" property on Component\n+ *\/\n+\n+public class Displayable extends Panel {\n+    Label status = new Label(\"Displayable Test started...\");\n+\n+    public void init() {\n+        setLayout(new BorderLayout());\n+        add(\"South\", status);\n+\n+        LightDisplayable light = new LightDisplayable();\n+        shouldNotBeDisplayable(light, \"before added to container \");\n+\n+        HeavyDisplayable heavy = new HeavyDisplayable();\n+        shouldNotBeDisplayable(heavy, \"before added to container \");\n+\n+        add(\"West\", light);\n+        add(\"East\", heavy);\n+\n+        statusMessage(\"Displayable test completed successfully.\");\n+    }\n+\n+    protected void addImpl(Component child, Object constraints, int index) {\n+        super.addImpl(child, constraints, index);\n+        if (isDisplayable()) {\n+            shouldBeDisplayable(child, \"after added to displayable container \");\n+        } else {\n+            shouldNotBeDisplayable(child, \"after added to undisplayable container \");\n+        }\n+    }\n+\n+    public void remove(Component child) {\n+        super.remove(child);\n+        shouldNotBeDisplayable(child, \"after removed from displayable container \");\n+    }\n+\n+    public void statusMessage(String msg) {\n+        status.setText(msg);\n+        status.invalidate();\n+        validate();\n+    }\n+\n+    public static void shouldNotBeDisplayable(Component c, String why) {\n+        if (c.isDisplayable()) {\n+            throw new RuntimeException(\"Component is displayable \"+why+c.getName());\n+        }\n+    }\n+\n+    public static void shouldBeDisplayable(Component c, String why) {\n+        if (!c.isDisplayable()) {\n+            throw new RuntimeException(\"Component is NOT displayable \"+why+c.getName());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Frame f = new Frame();\n+            try {\n+                Displayable test = new Displayable();\n+                test.init();\n+                f.add(\"North\", test);\n+                f.pack();\n+            } finally {\n+                f.dispose();\n+            }\n+        });\n+    }\n+}\n+\n+class LightDisplayable extends Component {\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(50,50);\n+    }\n+\n+    public void paint(Graphics g) {\n+        Dimension size = getSize();\n+        g.setColor(Color.blue);\n+        g.fillRect(0, 0, size.width, size.height);\n+        super.paint(g);\n+    }\n+\n+    public void addNotify() {\n+        Displayable.shouldNotBeDisplayable(this, \"before addNotify \");\n+        super.addNotify();\n+        Displayable.shouldBeDisplayable(this, \"after addNotify \");\n+    }\n+\n+    public void removeNotify() {\n+        Displayable.shouldBeDisplayable(this, \"before removeNotify \");\n+        super.removeNotify();\n+        Displayable.shouldNotBeDisplayable(this, \"after removeNotify \");\n+    }\n+}\n+\n+class HeavyDisplayable extends Panel {\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(50, 50);\n+    }\n+\n+    public void paint(Graphics g) {\n+        Dimension size = getSize();\n+        g.setColor(Color.black);\n+        g.fillRect(0, 0, size.width, size.height);\n+        super.paint(g);\n+    }\n+\n+    public void addNotify() {\n+        Displayable.shouldNotBeDisplayable(this, \"before addNotify \");\n+        super.addNotify();\n+        Displayable.shouldBeDisplayable(this, \"after addNotify \");\n+    }\n+\n+    public void removeNotify() {\n+        Displayable.shouldBeDisplayable(this, \"before removeNotify \");\n+        super.removeNotify();\n+        Displayable.shouldNotBeDisplayable(this, \"after removeNotify \");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/Displayable.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.WindowConstants;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4749659\n+ * @summary Tests that popup menu doesn't steal focus from top-level\n+ * @key headful\n+ *\/\n+\n+public class TestWindowsLFFocus {\n+    static volatile boolean actionFired;\n+\n+    static JFrame frame;\n+    static JMenuBar bar;\n+    static JMenuItem item;\n+    static volatile Point frameLoc;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo lookAndFeel : UIManager.getInstalledLookAndFeels()) {\n+            UIManager.setLookAndFeel(lookAndFeel.getClassName());\n+            test();\n+        }\n+\n+        System.err.println(\"PASSED\");\n+    }\n+\n+    private static void test() throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                actionFired = false;\n+                frame = new JFrame();\n+                bar = new JMenuBar();\n+                frame.setJMenuBar(bar);\n+                JMenu menu = new JMenu(\"menu\");\n+                bar.add(menu);\n+                item = new JMenuItem(\"item\");\n+                menu.add(item);\n+                item.addActionListener(e -> actionFired = true);\n+\n+                frame.getContentPane().add(new JButton(\"none\"));\n+                frame.setBounds(100, 100, 100, 100);\n+                frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(50);\n+\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                Point location = frame.getLocationOnScreen();\n+                Insets insets = frame.getInsets();\n+\n+                location.translate(insets.left + 15, insets.top + bar.getHeight() \/ 2);\n+\n+                frameLoc = location;\n+            });\n+\n+            robot.mouseMove(frameLoc.x, frameLoc.y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                Point location = new Point(frameLoc);\n+                location.y += bar.getHeight() \/ 2 + item.getHeight() \/ 2;\n+\n+                frameLoc = location;\n+            });\n+\n+            robot.mouseMove(frameLoc.x, frameLoc.y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            if (!actionFired) {\n+                throw new RuntimeException(\"Menu closed without action\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/TestWindowsLFFocus.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Polygon;\n+import java.awt.Shape;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Area;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.GeneralPath;\n+import java.awt.geom.Point2D;\n+\n+\/*\n+ * @test\n+ * @bug 4210936 4214524\n+ * @summary Tests the results of the hit test methods on 3 different\n+ *          Shape objects - Polygon, Area, and GeneralPath.  Both an\n+ *          automatic test for constraint compliance and a manual\n+ *          test for correctness are included in this one class.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main PathHitTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4210936 4214524\n+ * @summary Tests the results of the hit test methods on 3 different\n+ *          Shape objects - Polygon, Area, and GeneralPath.  Both an\n+ *          automatic test for constraint compliance and a manual\n+ *          test for correctness are included in this one class.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PathHitTest manual\n+ *\/\n+\n+public class PathHitTest {\n+\n+    public static final int BOXSIZE = 5;\n+    public static final int BOXCENTER = 2;\n+    public static final int TESTSIZE = 400;\n+    public static final int NUMTESTS = (TESTSIZE + BOXSIZE - 1) \/ BOXSIZE;\n+\n+    public static Shape[] testShapes = new Shape[5];\n+    public static String[] testNames = {\n+            \"Polygon\",\n+            \"EvenOdd GeneralPath\",\n+            \"NonZero GeneralPath\",\n+            \"Area from EO GeneralPath\",\n+            \"Area from NZ GeneralPath\",\n+    };\n+\n+    static {\n+        GeneralPath gpeo = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n+        Ellipse2D ell = new Ellipse2D.Float();\n+        Point2D center = new Point2D.Float();\n+        AffineTransform at = new AffineTransform();\n+        for (int i = 0; i < 360; i += 30) {\n+            center.setLocation(100, 0);\n+            at.setToTranslation(200, 200);\n+            at.rotate(i * Math.PI \/ 180);\n+            at.transform(center, center);\n+            ell.setFrame(center.getX() - 50, center.getY() - 50, 100, 100);\n+            gpeo.append(ell, false);\n+        }\n+        GeneralPath side = new GeneralPath();\n+        side.moveTo(0, 0);\n+        side.lineTo(15, 10);\n+        side.lineTo(30, 0);\n+        side.lineTo(45, -10);\n+        side.lineTo(60, 0);\n+        append4sides(gpeo, side, 20, 20);\n+        side.reset();\n+        side.moveTo(0, 0);\n+        side.quadTo(15, 10, 30, 0);\n+        side.quadTo(45, -10, 60, 0);\n+        append4sides(gpeo, side, 320, 20);\n+        side.reset();\n+        side.moveTo(0, 0);\n+        side.curveTo(15, 10, 45, -10, 60, 0);\n+        append4sides(gpeo, side, 20, 320);\n+\n+        GeneralPath gpnz = new GeneralPath(GeneralPath.WIND_NON_ZERO);\n+        gpnz.append(gpeo, false);\n+        Polygon p = new Polygon();\n+        p.addPoint( 50,  50);\n+        p.addPoint( 60, 350);\n+        p.addPoint(250, 340);\n+        p.addPoint(260, 150);\n+        p.addPoint(140, 140);\n+        p.addPoint(150, 260);\n+        p.addPoint(340, 250);\n+        p.addPoint(350,  60);\n+        testShapes[0] = p;\n+        testShapes[1] = gpeo;\n+        testShapes[2] = gpnz;\n+        testShapes[3] = new Area(gpeo);\n+        testShapes[3].getPathIterator(null);\n+        testShapes[4] = new Area(gpnz);\n+        testShapes[4].getPathIterator(null);\n+    }\n+\n+    private static void append4sides(GeneralPath path, GeneralPath side,\n+                                     double xoff, double yoff) {\n+        AffineTransform at = new AffineTransform();\n+        at.setToTranslation(xoff, yoff);\n+        for (int i = 0; i < 4; i++) {\n+            path.append(side.getPathIterator(at), i != 0);\n+            at.rotate(Math.toRadians(90), 30, 30);\n+        }\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+        if (argv.length > 0 && argv[0].equals(\"manual\")) {\n+            PathHitTestManual.doManual();\n+        } else {\n+            int totalerrs = 0;\n+            for (int i = 0; i < testShapes.length; i++) {\n+                totalerrs += testshape(testShapes[i], testNames[i]);\n+            }\n+            if (totalerrs != 0) {\n+                throw new RuntimeException(totalerrs +\n+                        \" constraint conditions violated!\");\n+            }\n+        }\n+    }\n+\n+    public static int testshape(Shape s, String name) {\n+        int numerrs = 0;\n+        long start = System.currentTimeMillis();\n+        for (int y = 0; y < TESTSIZE; y += BOXSIZE) {\n+            for (int x = 0; x < TESTSIZE; x += BOXSIZE) {\n+                boolean rectintersects = s.intersects(x, y, BOXSIZE, BOXSIZE);\n+                boolean rectcontains = s.contains(x, y, BOXSIZE, BOXSIZE);\n+                boolean pointcontains = s.contains(x + BOXCENTER, y + BOXCENTER);\n+                if (rectcontains && !rectintersects) {\n+                    System.err.println(\"rect is contained \" +\n+                            \"but does not intersect!\");\n+                    numerrs++;\n+                }\n+                if (rectcontains && !pointcontains) {\n+                    System.err.println(\"rect is contained \" +\n+                            \"but center is not contained!\");\n+                    numerrs++;\n+                }\n+                if (pointcontains && !rectintersects) {\n+                    System.err.println(\"center is contained \" +\n+                            \"but rect does not intersect!\");\n+                    numerrs++;\n+                }\n+            }\n+        }\n+        long end = System.currentTimeMillis();\n+        System.out.println(name + \" completed in \" +\n+                (end - start) + \"ms with \" +\n+                numerrs + \" errors\");\n+        return numerrs;\n+    }\n+\n+    static class PathHitTestManual extends Panel {\n+        private static final String INSTRUCTIONS = \"\"\"\n+            This test displays the results of hit testing 5 different Shape\n+            objects one at a time.\n+\n+            You can switch between shapes using the Choice component located\n+            at the bottom of the window.\n+\n+            Each square in the test represents the\n+            return values of the hit testing operators for that square region:\n+\n+                yellow - not yet tested\n+                translucent blue overlay - the shape being tested\n+\n+                black - all outside\n+                dark gray - rectangle intersects shape\n+                light gray - rectangle intersects and center point is inside shape\n+                white - rectangle is entirely contained in shape\n+                red - some constraint was violated, including:\n+                    rectangle is contained, but center point is not\n+                    rectangle is contained, but rectangle.intersects is false\n+                    centerpoint is contained, but rectangle.intersects is false\n+\n+            Visually inspect the results to see if they match the above table.\n+            Note that it is not a violation for rectangles that are entirely\n+            inside the path to be light gray instead of white since sometimes\n+            the path is complex enough to make an exact determination expensive.\n+            You might see this on the GeneralPath NonZero example where the\n+            circles that make up the path cross over the interior of the shape\n+            and cause the hit testing methods to guess that the rectangle is\n+            not guaranteed to be contained within the shape.\n+            \"\"\";\n+\n+        PathHitTestCanvas phtc;\n+\n+        public void init() {\n+            setLayout(new BorderLayout());\n+            phtc = new PathHitTestCanvas();\n+            add(\"Center\", phtc);\n+            final Choice ch = new Choice();\n+            for (int i = 0; i < PathHitTest.testNames.length; i++) {\n+                ch.add(PathHitTest.testNames[i]);\n+            }\n+            ch.addItemListener(e -> phtc.setShape(ch.getSelectedIndex()));\n+            ch.select(0);\n+            phtc.setShape(0);\n+            add(\"South\", ch);\n+        }\n+\n+        public void start() {\n+            phtc.start();\n+        }\n+\n+        public void stop() {\n+            phtc.stop();\n+        }\n+\n+        public static class PathHitTestCanvas extends Canvas implements Runnable {\n+            public static final Color[] colors = {\n+                                        \/* contains?  point in?  intersects? *\/\n+                    Color.black,        \/*    NO         NO          NO      *\/\n+                    Color.darkGray,     \/*    NO         NO          YES     *\/\n+                    Color.red,          \/*    NO         YES         NO      *\/\n+                    Color.lightGray,    \/*    NO         YES         YES     *\/\n+                    Color.red,          \/*    YES        NO          NO      *\/\n+                    Color.red,          \/*    YES        NO          YES     *\/\n+                    Color.red,          \/*    YES        YES         NO      *\/\n+                    Color.white,        \/*    YES        YES         YES     *\/\n+                    Color.yellow,       \/*     used for untested points      *\/\n+            };\n+\n+            public Dimension getPreferredSize() {\n+                return new Dimension(TESTSIZE, TESTSIZE);\n+            }\n+\n+            public synchronized void start() {\n+                if (!testdone) {\n+                    renderer = new Thread(this);\n+                    renderer.setPriority(Thread.MIN_PRIORITY);\n+                    renderer.start();\n+                }\n+            }\n+\n+            public synchronized void stop() {\n+                renderer = null;\n+            }\n+\n+            private Thread renderer;\n+            private int shapeIndex = 0;\n+            private byte[] indices = new byte[NUMTESTS * NUMTESTS];\n+            boolean testdone = false;\n+\n+            private synchronized void setShape(int index) {\n+                shapeIndex = index;\n+                testdone = false;\n+                start();\n+            }\n+\n+            public void run() {\n+                Thread me = Thread.currentThread();\n+                Graphics2D g2d = (Graphics2D) getGraphics();\n+                byte[] indices;\n+                Shape s = testShapes[shapeIndex];\n+                synchronized (this) {\n+                    if (renderer != me) {\n+                        return;\n+                    }\n+                    this.indices = new byte[NUMTESTS * NUMTESTS];\n+                    java.util.Arrays.fill(this.indices, (byte) 8);\n+                    indices = this.indices;\n+                }\n+\n+                System.err.printf(\"%s %s\\n\", g2d, Color.yellow);\n+                g2d.setColor(Color.yellow);\n+                g2d.fillRect(0, 0, TESTSIZE, TESTSIZE);\n+                int numtests = 0;\n+                long start = System.currentTimeMillis();\n+                for (int y = 0; renderer == me && y < TESTSIZE; y += BOXSIZE) {\n+                    for (int x = 0; renderer == me && x < TESTSIZE; x += BOXSIZE) {\n+                        byte index = 0;\n+                        if (s.intersects(x, y, BOXSIZE, BOXSIZE)) {\n+                            index += 1;\n+                        }\n+                        if (s.contains(x + BOXCENTER, y + BOXCENTER)) {\n+                            index += 2;\n+                        }\n+                        if (s.contains(x, y, BOXSIZE, BOXSIZE)) {\n+                            index += 4;\n+                        }\n+                        numtests++;\n+                        int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n+                        indices[i] = index;\n+                        g2d.setColor(colors[index]);\n+                        g2d.fillRect(x, y, BOXSIZE, BOXSIZE);\n+                    }\n+                }\n+                synchronized (this) {\n+                    if (renderer != me) {\n+                        return;\n+                    }\n+                    g2d.setColor(new Color(0, 0, 1, .2f));\n+                    g2d.fill(s);\n+                    testdone = true;\n+                    long end = System.currentTimeMillis();\n+                    System.out.println(numtests + \" tests took \" + (end - start) + \"ms\");\n+                }\n+            }\n+\n+            public void paint(Graphics g) {\n+                g.setColor(Color.yellow);\n+                g.fillRect(0, 0, TESTSIZE, TESTSIZE);\n+                byte[] indices = this.indices;\n+                if (indices != null) {\n+                    for (int y = 0; y < TESTSIZE; y += BOXSIZE) {\n+                        for (int x = 0; x < TESTSIZE; x += BOXSIZE) {\n+                            int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n+                            g.setColor(colors[indices[i]]);\n+                            g.fillRect(x, y, BOXSIZE, BOXSIZE);\n+                        }\n+                    }\n+                }\n+                Graphics2D g2d = (Graphics2D) g;\n+                g2d.setColor(new Color(0, 0, 1, .2f));\n+                g2d.fill(testShapes[shapeIndex]);\n+            }\n+        }\n+\n+        static volatile PathHitTestManual pathHitTestManual;\n+\n+        private static void createAndShowGUI() {\n+            pathHitTestManual = new PathHitTestManual();\n+            Frame frame = new Frame(\"PathHitTestManual test window\");\n+\n+            frame.add(pathHitTestManual);\n+            frame.setSize(400, 450);\n+\n+            PassFailJFrame.addTestWindow(frame);\n+            PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+\n+            frame.setVisible(true);\n+\n+            pathHitTestManual.init();\n+            pathHitTestManual.start();\n+        }\n+\n+        public static void doManual() throws Exception {\n+            PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                    .title(\"PathHitTestManual Instructions\")\n+                    .instructions(INSTRUCTIONS)\n+                    .testTimeOut(5)\n+                    .rows(30)\n+                    .columns(70)\n+                    .screenCapture()\n+                    .build();\n+\n+            EventQueue.invokeAndWait(PathHitTestManual::createAndShowGUI);\n+            try {\n+                passFailJFrame.awaitAndCheck();\n+            } finally {\n+                pathHitTestManual.stop();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/HitTest\/PathHitTest.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"}]}