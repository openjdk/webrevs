{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +36,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -138,3 +141,3 @@\n-        private boolean failed;\n-        private boolean jmxConnectWorked;\n-        private boolean rmiConnectWorked;\n+        private volatile boolean failed;\n+        private volatile boolean jmxConnectWorked;\n+        private volatile boolean rmiConnectWorked;\n@@ -159,0 +162,1 @@\n+                e.printStackTrace();\n@@ -226,1 +230,4 @@\n-        private static final int WAIT_FOR_JMX_AGENT_TIMEOUT_MS = 500;\n+        private static final String EXP_TERM_MSG_REG = \"Exit: ([0-9]+)\";\n+        private static final Pattern EXIT_PATTERN = Pattern.compile(EXP_TERM_MSG_REG);\n+        private static final String COOP_EXIT = \"MainThread: Cooperative Exit\";\n+        private static final int WAIT_FOR_JMX_AGENT_TIMEOUT_MS = 20_000;\n@@ -231,1 +238,0 @@\n-        private boolean terminated = false;\n@@ -233,1 +239,1 @@\n-        private Exception excptn;\n+        private volatile Exception excptn;\n@@ -246,6 +252,9 @@\n-                \/\/ Do nothing, but wait for termination.\n-                try {\n-                    while (!terminated) {\n-                        Thread.sleep(100);\n-                    }\n-                } catch (InterruptedException e) { \/\/ ignore\n+\n+                \/\/ Wait for termination message\n+                String actualTerm = new String(System.in.readAllBytes(), StandardCharsets.UTF_8).trim();\n+                System.err.println(\"DEBUG: MainThread: actualTerm: '\" + actualTerm + \"'\");\n+                Matcher matcher = EXIT_PATTERN.matcher(actualTerm);\n+                if (matcher.matches()) {\n+                    int expExitCode = Integer.parseInt(matcher.group(1));\n+                    System.out.println(COOP_EXIT);\n+                    System.exit(expExitCode); \/\/ The main test expects this exit value\n@@ -253,1 +262,0 @@\n-                System.out.println(\"MainThread: Thread stopped.\");\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/JMXAgentInterfaceBinding.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.net.UnknownHostException;\n@@ -36,10 +37,0 @@\n- * NOTE:\n- *    This test requires at least a setup similar to the following in\n- *    \/etc\/hosts file (or the windows equivalent). I.e. it expects it to\n- *    be multi-homed and not both being the loop-back interface.\n- *    For example:\n- *    ----->8-------- \/etc\/hosts ----------->8---\n- *    127.0.0.1   localhost\n- *    192.168.0.1 localhost\n- *    ----->8-------- \/etc\/hosts ----------->8---\n- *\n@@ -49,1 +40,2 @@\n- *          interfaces to bind to (using plain sockets and SSL sockets).\n+ *          interfaces to bind to (selecting plain or SSL sockets at random\n+ * @key intermittent\n@@ -55,1 +47,1 @@\n- * @run main\/timeout=5 JMXInterfaceBindingTest\n+ * @run main\/timeout=60 JMXInterfaceBindingTest\n@@ -60,3 +52,11 @@\n-    public static final int STOP_PROCESS_EXIT_VAL = 143;\n-    public static final int JMX_PORT = 9111;\n-    public static final int RMI_PORT = 9112;\n+    public static final int STOP_PROCESS_EXIT_VAL = 10;\n+    public static final int JMX_PORT_RANGE_LOWER = 9100;\n+    public static final int JMX_PORT_RANGE_UPPER = 9200;\n+    public static final int JMX_PORT = getRandomPortInRange(JMX_PORT_RANGE_LOWER,\n+                                                            JMX_PORT_RANGE_UPPER);\n+    public static final int JMX_PORT_RANGE_LOWER_SSL = 9201; \/\/ 9200 might be RMI Port\n+    public static final int JMX_PORT_RANGE_UPPER_SSL = 9300;\n+    public static final int JMX_PORT_SSL = getRandomPortInRange(JMX_PORT_RANGE_LOWER_SSL,\n+                                                                JMX_PORT_RANGE_UPPER_SSL);\n+    public static final int RMI_PORT = JMX_PORT + 1;\n+    public static final int RMI_PORT_SSL = JMX_PORT_SSL + 1;\n@@ -92,2 +92,2 @@\n-                    JMX_PORT,\n-                    RMI_PORT);\n+                    useSSL ? JMX_PORT_SSL : JMX_PORT,\n+                    useSSL ? RMI_PORT_SSL : RMI_PORT);\n@@ -103,1 +103,1 @@\n-                pt.stopProcess();\n+                pt.sendMessage(\"Exit: \" + STOP_PROCESS_EXIT_VAL);\n@@ -105,1 +105,1 @@\n-            } catch (InterruptedException e) {\n+            } catch (Throwable e) {\n@@ -134,2 +134,2 @@\n-        args.add(\"-Dcom.sun.management.jmxremote.port=\" + JMX_PORT);\n-        args.add(\"-Dcom.sun.management.jmxremote.rmi.port=\" + RMI_PORT);\n+        args.add(\"-Dcom.sun.management.jmxremote.port=\" + (useSSL ? JMX_PORT_SSL : JMX_PORT));\n+        args.add(\"-Dcom.sun.management.jmxremote.rmi.port=\" + (useSSL ? RMI_PORT_SSL : RMI_PORT));\n@@ -138,0 +138,2 @@\n+        \/\/ This is needed for testing on loopback\n+        args.add(\"-Djava.rmi.server.hostname=\" + address);\n@@ -147,2 +149,2 @@\n-        args.add(Integer.toString(JMX_PORT));\n-        args.add(Integer.toString(RMI_PORT));\n+        args.add(Integer.toString(useSSL ? JMX_PORT_SSL : JMX_PORT));\n+        args.add(Integer.toString(useSSL ? RMI_PORT_SSL : RMI_PORT));\n@@ -178,0 +180,9 @@\n+    private static int getRandomPortInRange(int lower, int upper) {\n+        if (upper <= lower) {\n+            throw new IllegalArgumentException(\"upper <= lower\");\n+        }\n+        int range = upper - lower;\n+        int randPort = lower + (int)(Math.random() * range);\n+        return randPort;\n+    }\n+\n@@ -179,3 +190,4 @@\n-        List<InetAddress> addrs = getAddressesForLocalHost();\n-        if (addrs.size() < 2) {\n-            System.out.println(\"Ignoring manual test since no more than one IPs are configured for 'localhost'\");\n+        List<InetAddress> addrs = getNonLoopbackAddressesForLocalHost();\n+        if (addrs.isEmpty()) {\n+            System.out.println(\"Ignoring test since no non-loopback IPs are available to bind to \" +\n+                               \"in addition to the loopback interface.\");\n@@ -185,0 +197,5 @@\n+        \/\/ Add loopback interface too as we'd like to verify whether it's\n+        \/\/ possible to bind to multiple addresses on the same host. This\n+        \/\/ wasn't possible prior JDK-6425769. It used to bind to *all* local\n+        \/\/ interfaces. We add loopback here, since that eases test setup.\n+        addrs.add(InetAddress.getLoopbackAddress());\n@@ -189,2 +206,2 @@\n-    private static List<InetAddress> getAddressesForLocalHost() {\n-\n+    private static List<InetAddress> getNonLoopbackAddressesForLocalHost() {\n+        List<InetAddress> addrs = new ArrayList<>();\n@@ -192,5 +209,6 @@\n-            return NetworkInterface.networkInterfaces()\n-                .flatMap(NetworkInterface::inetAddresses)\n-                .filter(JMXInterfaceBindingTest::isNonloopbackLocalhost)\n-                .collect(Collectors.toList());\n-        } catch (SocketException e) {\n+            InetAddress localHost = InetAddress.getLocalHost();\n+            if (!localHost.isLoopbackAddress()) {\n+                addrs.add(localHost);\n+            }\n+            return addrs;\n+        } catch (UnknownHostException e) {\n@@ -200,9 +218,0 @@\n-\n-    \/\/ we need 'real' localhost addresses only (eg. not loopback ones)\n-    \/\/ so we can bind the remote JMX connector to them\n-    private static boolean isNonloopbackLocalhost(InetAddress i) {\n-        if (!i.isLoopbackAddress()) {\n-            return i.getHostName().toLowerCase().equals(\"localhost\");\n-        }\n-        return false;\n-    }\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/JMXInterfaceBindingTest.java","additions":51,"deletions":42,"binary":false,"changes":93,"status":"modified"}]}