{"files":[{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import javax.swing.JFileChooser;\n+\n+\/*\n+ * @test\n+ * @bug 8323670 8307091 8240690\n+ * @requires os.family == \"mac\" | os.family == \"linux\"\n+ * @summary Verifies thread-safety of BasicDirectoryModel (JFileChooser)\n+ * @run main\/othervm -Djava.awt.headless=true ConcurrentModification\n+ *\/\n+public final class ConcurrentModification extends ThreadGroup {\n+    \/** Initial number of files. *\/\n+    private static final long NUMBER_OF_FILES = 50;\n+    \/** Maximum number of files created on a timer tick. *\/\n+    private static final long LIMIT_FILES = 10;\n+\n+    \/** Timer period (delay) for creating new files. *\/\n+    private static final long TIMER_PERIOD = 250;\n+\n+    \/**\n+     * Number of threads running {@code fileChooser.rescanCurrentDirectory()}.\n+     *\/\n+    private static final int NUMBER_OF_THREADS = 5;\n+    \/** Number of repeated calls to {@code rescanCurrentDirectory}. *\/\n+    private static final int NUMBER_OF_REPEATS = 2_000;\n+    \/** Maximum amount a thread waits before initiating rescan. *\/\n+    private static final long LIMIT_SLEEP = 100;\n+\n+\n+    \/** The barrier to start all the scanner threads simultaneously. *\/\n+    private static final CyclicBarrier start = new CyclicBarrier(NUMBER_OF_THREADS);\n+    \/** The barrier to wait for all the scanner threads to complete, plus main thread. *\/\n+    private static final CyclicBarrier end = new CyclicBarrier(NUMBER_OF_THREADS + 1);\n+\n+    \/** List of scanner threads. *\/\n+    private static final List<Thread> threads = new ArrayList<>(NUMBER_OF_THREADS);\n+\n+    \/**\n+     * Stores an exception caught by any of the threads.\n+     * If more exceptions are caught, they're added as suppressed exceptions.\n+     *\/\n+    private static final AtomicReference<Throwable> exception =\n+            new AtomicReference<>();\n+\n+    \/**\n+     * Stores an {@code IOException} thrown while removing the files.\n+     *\/\n+    private static final AtomicReference<IOException> ioException =\n+            new AtomicReference<>();\n+\n+\n+    public static void main(String[] args) throws Throwable {\n+        try {\n+            \/\/ Start the test in its own thread group to catch and handle\n+            \/\/ all thrown exceptions, in particular in\n+            \/\/ BasicDirectoryModel.FilesLoader which is created by Swing.\n+            ThreadGroup threadGroup = new ConcurrentModification();\n+            Thread runner = new Thread(threadGroup,\n+                                       ConcurrentModification::wrapper,\n+                                       \"Test Runner\");\n+            runner.start();\n+            runner.join();\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        }\n+\n+        if (ioException.get() != null) {\n+            System.err.println(\"An error occurred while removing files:\");\n+            ioException.get().printStackTrace();\n+        }\n+\n+        if (exception.get() != null) {\n+            throw exception.get();\n+        }\n+    }\n+\n+    private static void wrapper() {\n+        final long timeStart = System.currentTimeMillis();\n+        try {\n+            runTest(timeStart);\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        } finally {\n+            System.out.printf(\"Duration: %,d\\n\",\n+                              (System.currentTimeMillis() - timeStart));\n+        }\n+    }\n+\n+    private static void runTest(final long timeStart) throws Throwable {\n+        final Path temp = Files.createDirectory(Paths.get(\"fileChooser-concurrency-\" + timeStart));\n+\n+        final Timer timer = new Timer(\"File creator\");\n+\n+        try {\n+            createFiles(temp);\n+\n+            final JFileChooser fc = new JFileChooser(temp.toFile());\n+\n+            IntStream.range(0, NUMBER_OF_THREADS)\n+                     .forEach(i -> {\n+                         Thread thread = new Thread(new Scanner(fc));\n+                         threads.add(thread);\n+                         thread.start();\n+                     });\n+\n+            timer.scheduleAtFixedRate(new CreateFilesTimerTask(temp),\n+                                      0, TIMER_PERIOD);\n+\n+            end.await();\n+        } catch (Throwable e) {\n+            threads.forEach(Thread::interrupt);\n+            throw e;\n+        } finally {\n+            timer.cancel();\n+\n+            deleteFiles(temp);\n+            deleteFile(temp);\n+        }\n+    }\n+\n+\n+    private ConcurrentModification() {\n+        super(\"bdmConcurrency\");\n+    }\n+\n+    @Override\n+    public void uncaughtException(Thread t, Throwable e) {\n+        handleException(t, e);\n+    }\n+\n+    private static void handleException(Throwable throwable) {\n+        handleException(Thread.currentThread(), throwable);\n+    }\n+\n+    private static void handleException(final Thread thread,\n+                                        final Throwable throwable) {\n+        System.err.println(\"Exception in \" + thread.getName() + \": \"\n+                           + throwable.getClass()\n+                           + (throwable.getMessage() != null\n+                              ? \": \" + throwable.getMessage()\n+                              : \"\"));\n+        if (!exception.compareAndSet(null, throwable)) {\n+            exception.get().addSuppressed(throwable);\n+        }\n+        threads.stream()\n+               .filter(t -> t != thread)\n+               .forEach(Thread::interrupt);\n+    }\n+\n+\n+    private record Scanner(JFileChooser fileChooser)\n+            implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                start.await();\n+\n+                int counter = 0;\n+                try {\n+                    do {\n+                        fileChooser.rescanCurrentDirectory();\n+                        Thread.sleep((long) (Math.random() * LIMIT_SLEEP));\n+                    } while (++counter < NUMBER_OF_REPEATS\n+                             && !Thread.interrupted());\n+                } catch (InterruptedException e) {\n+                    \/\/ Just exit the loop\n+                }\n+            } catch (Throwable throwable) {\n+                handleException(throwable);\n+            } finally {\n+                try {\n+                    end.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    handleException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createFiles(final Path parent) {\n+        createFiles(parent, 0, NUMBER_OF_FILES);\n+    }\n+\n+    private static void createFiles(final Path parent,\n+                                    final long start,\n+                                    final long end) {\n+        LongStream.range(start, end)\n+                  .forEach(n -> createFile(parent.resolve(n + \".file\")));\n+    }\n+\n+    private static void createFile(final Path file) {\n+        try {\n+            Files.createFile(file);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void deleteFiles(final Path parent) throws IOException {\n+        try (var stream = Files.walk(parent)) {\n+            stream.filter(p -> p != parent)\n+                  .forEach(ConcurrentModification::deleteFile);\n+        }\n+    }\n+\n+    private static void deleteFile(final Path file) {\n+        try {\n+            Files.delete(file);\n+        } catch (IOException e) {\n+            if (!ioException.compareAndSet(null, e)) {\n+                ioException.get().addSuppressed(e);\n+            }\n+        }\n+    }\n+\n+    private static final class CreateFilesTimerTask extends TimerTask {\n+        private final Path temp;\n+        private long no;\n+\n+        public CreateFilesTimerTask(Path temp) {\n+            this.temp = temp;\n+            no = NUMBER_OF_FILES;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                long count = (long) (Math.random() * LIMIT_FILES);\n+                createFiles(temp, no, no + count);\n+                no += count;\n+            } catch (Throwable t) {\n+                handleException(t);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/ConcurrentModification.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"}]}