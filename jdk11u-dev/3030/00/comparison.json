{"files":[{"patch":"@@ -44,0 +44,1 @@\n+\n@@ -155,2 +156,3 @@\n-                                                            HttpRequestImpl other) {\n-        return new HttpRequestImpl(uri, method, other);\n+                                                            HttpRequestImpl other,\n+                                                            boolean mayHaveBody) {\n+        return new HttpRequestImpl(uri, method, other, mayHaveBody);\n@@ -161,1 +163,1 @@\n-        HttpRequestImpl request = new HttpRequestImpl(other.uri(), other.method(), other);\n+        HttpRequestImpl request = new HttpRequestImpl(other.uri(), other.method(), other, true);\n@@ -174,1 +176,2 @@\n-                            HttpRequestImpl other) {\n+                            HttpRequestImpl other,\n+                            boolean mayHaveBody) {\n@@ -187,1 +190,1 @@\n-        this.requestPublisher = other.requestPublisher;  \/\/ may be null\n+        this.requestPublisher = mayHaveBody ? publisher(other) : null; \/\/ may be null\n@@ -194,0 +197,8 @@\n+    private BodyPublisher publisher(HttpRequestImpl other) {\n+        BodyPublisher res = other.requestPublisher;\n+        if (!Objects.equals(method, other.method)) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,25 @@\n+    private static boolean isRedirecting(int statusCode) {\n+        \/\/ < 300: not a redirect codes\n+        if (statusCode < 300) return false;\n+        \/\/ 309-399 Unassigned => don't follow\n+        \/\/ > 399: not a redirect code\n+        if (statusCode > 308) return false;\n+        switch (statusCode) {\n+            \/\/ 300: MultipleChoice => don't follow\n+            case 300:\n+                return false;\n+            \/\/ 304: Not Modified => don't follow\n+            case 304:\n+                return false;\n+            \/\/ 305: Proxy Redirect => don't follow.\n+            case 305:\n+                return false;\n+            \/\/ 306: Unused => don't follow\n+            case 306:\n+                return false;\n+            \/\/ 301, 302, 303, 307, 308: OK to follow.\n+            default:\n+                return true;\n+        }\n+    }\n+\n@@ -105,1 +130,1 @@\n-        if (rcode >= 300 && rcode <= 399) {\n+        if (isRedirecting(rcode)) {\n@@ -111,1 +136,1 @@\n-                return HttpRequestImpl.newInstanceForRedirection(redir, newMethod, request);\n+                return HttpRequestImpl.newInstanceForRedirection(redir, newMethod, request, rcode != 303);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RedirectFilter.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.SocketAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\/**\n+ * @test\n+ * @bug 8232625\n+ * @summary This test verifies that the HttpClient works correctly when redirecting a post request.\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters DigestEchoServer HttpRedirectTest\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ * @run testng\/othervm -Dtest.requiresHost=true\n+ *                   -Djdk.httpclient.HttpClient.log=headers\n+ *                   -Djdk.internal.httpclient.debug=false\n+ *                   HttpRedirectTest\n+ *\n+ *\/\n+public class HttpRedirectTest implements HttpServerAdapters {\n+    static final String GET_RESPONSE_BODY = \"Lorem ipsum dolor sit amet\";\n+    static final String REQUEST_BODY = \"Here it goes\";\n+    static final SSLContext context;\n+    static {\n+        try {\n+            context = new SimpleSSLContext().get();\n+            SSLContext.setDefault(context);\n+        } catch (Exception x) {\n+            throw new ExceptionInInitializerError(x);\n+        }\n+    }\n+\n+    final AtomicLong requestCounter = new AtomicLong();\n+    final AtomicLong responseCounter = new AtomicLong();\n+    HttpTestServer http1Server;\n+    HttpTestServer http2Server;\n+    HttpTestServer https1Server;\n+    HttpTestServer https2Server;\n+    DigestEchoServer.TunnelingProxy proxy;\n+\n+    URI http1URI;\n+    URI https1URI;\n+    URI http2URI;\n+    URI https2URI;\n+    InetSocketAddress proxyAddress;\n+    ProxySelector proxySelector;\n+    HttpClient client;\n+    List<CompletableFuture<?>>  futures = new CopyOnWriteArrayList<>();\n+    Set<URI> pending = new CopyOnWriteArraySet<>();\n+\n+    final ExecutorService executor = new ThreadPoolExecutor(12, 60, 10,\n+            TimeUnit.SECONDS, new LinkedBlockingQueue<>()); \/\/ Shared by HTTP\/1.1 servers\n+    final ExecutorService clientexec = new ThreadPoolExecutor(6, 12, 1,\n+            TimeUnit.SECONDS, new LinkedBlockingQueue<>()); \/\/ Used by the client\n+\n+    public HttpClient newHttpClient(ProxySelector ps) {\n+        HttpClient.Builder builder = HttpClient\n+                .newBuilder()\n+                .sslContext(context)\n+                .executor(clientexec)\n+                .followRedirects(HttpClient.Redirect.ALWAYS)\n+                .proxy(ps);\n+        return builder.build();\n+    }\n+\n+    @DataProvider(name=\"uris\")\n+    Object[][] testURIs() throws URISyntaxException {\n+        List<URI> uris = List.of(\n+                http1URI.resolve(\"direct\/orig\/\"),\n+                https1URI.resolve(\"direct\/orig\/\"),\n+                https1URI.resolve(\"proxy\/orig\/\"),\n+                http2URI.resolve(\"direct\/orig\/\"),\n+                https2URI.resolve(\"direct\/orig\/\"),\n+                https2URI.resolve(\"proxy\/orig\/\"));\n+        List<Map.Entry<Integer, String>> redirects = List.of(\n+                Map.entry(301, \"GET\"),\n+                Map.entry(308, \"POST\"),\n+                Map.entry(302, \"GET\"),\n+                Map.entry(303, \"GET\"),\n+                Map.entry(307, \"POST\"),\n+                Map.entry(300, \"DO_NOT_FOLLOW\"),\n+                Map.entry(304, \"DO_NOT_FOLLOW\"),\n+                Map.entry(305, \"DO_NOT_FOLLOW\"),\n+                Map.entry(306, \"DO_NOT_FOLLOW\"),\n+                Map.entry(309, \"DO_NOT_FOLLOW\"),\n+                Map.entry(new Random().nextInt(90) + 310, \"DO_NOT_FOLLOW\")\n+        );\n+        Object[][] tests = new Object[redirects.size() * uris.size()][3];\n+        int count = 0;\n+        for (int i=0; i < uris.size(); i++) {\n+            URI u = uris.get(i);\n+            for (int j=0; j < redirects.size() ; j++) {\n+                int code = redirects.get(j).getKey();\n+                String m = redirects.get(j).getValue();\n+                tests[count][0] = u.resolve(code +\"\/\");\n+                tests[count][1] = code;\n+                tests[count][2] = m;\n+                count++;\n+            }\n+        }\n+        return tests;\n+    }\n+\n+    @BeforeClass\n+    public void setUp() throws Exception {\n+        try {\n+            InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+            \/\/ HTTP\/1.1\n+            HttpServer server1 = HttpServer.create(sa, 0);\n+            server1.setExecutor(executor);\n+            http1Server = HttpTestServer.of(server1);\n+            http1Server.addHandler(new HttpTestRedirectHandler(\"http\", http1Server),\n+                    \"\/HttpRedirectTest\/http1\/\");\n+            http1Server.start();\n+            http1URI = new URI(\"http:\/\/\" + http1Server.serverAuthority() + \"\/HttpRedirectTest\/http1\/\");\n+\n+\n+            \/\/ HTTPS\/1.1\n+            HttpsServer sserver1 = HttpsServer.create(sa, 100);\n+            sserver1.setExecutor(executor);\n+            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            https1Server = HttpTestServer.of(sserver1);\n+            https1Server.addHandler(new HttpTestRedirectHandler(\"https\", https1Server),\n+                    \"\/HttpRedirectTest\/https1\/\");\n+            https1Server.start();\n+            https1URI = new URI(\"https:\/\/\" + https1Server.serverAuthority() + \"\/HttpRedirectTest\/https1\/\");\n+\n+            \/\/ HTTP\/2.0\n+            http2Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server.addHandler(new HttpTestRedirectHandler(\"http\", http2Server),\n+                    \"\/HttpRedirectTest\/http2\/\");\n+            http2Server.start();\n+            http2URI = new URI(\"http:\/\/\" + http2Server.serverAuthority() + \"\/HttpRedirectTest\/http2\/\");\n+\n+            \/\/ HTTPS\/2.0\n+            https2Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server.addHandler(new HttpTestRedirectHandler(\"https\", https2Server),\n+                    \"\/HttpRedirectTest\/https2\/\");\n+            https2Server.start();\n+            https2URI = new URI(\"https:\/\/\" + https2Server.serverAuthority() + \"\/HttpRedirectTest\/https2\/\");\n+\n+            proxy = DigestEchoServer.createHttpsProxyTunnel(\n+                    DigestEchoServer.HttpAuthSchemeType.NONE);\n+            proxyAddress = proxy.getProxyAddress();\n+            proxySelector = new HttpProxySelector(proxyAddress);\n+            client = newHttpClient(proxySelector);\n+            System.out.println(\"Setup: done\");\n+        } catch (Exception x) {\n+            tearDown(); throw x;\n+        } catch (Error e) {\n+            tearDown(); throw e;\n+        }\n+    }\n+\n+    private void testNonIdempotent(URI u, HttpRequest request,\n+                                   int code, String method) throws Exception {\n+        System.out.println(\"Testing with \" + u);\n+        CompletableFuture<HttpResponse<String>> respCf =\n+                client.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n+        HttpResponse<String> resp = respCf.join();\n+        if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertEquals(resp.statusCode(), code, u + \": status code\");\n+        } else {\n+            assertEquals(resp.statusCode(), 200, u + \": status code\");\n+        }\n+        if (method.equals(\"POST\")) {\n+            assertEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        } else if (code == 304) {\n+            assertEquals(resp.body(), \"\", u + \": body\");\n+        } else if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertNotEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+            assertNotEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        } else {\n+            assertEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+        }\n+    }\n+\n+    public void testIdempotent(URI u, HttpRequest request,\n+                               int code, String method) throws Exception {\n+        CompletableFuture<HttpResponse<String>> respCf =\n+                client.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n+        HttpResponse<String> resp = respCf.join();\n+        if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertEquals(resp.statusCode(), code, u + \": status code\");\n+        } else {\n+            assertEquals(resp.statusCode(), 200, u + \": status code\");\n+        }\n+        if (method.equals(\"POST\")) {\n+            assertEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        } else if (code == 304) {\n+            assertEquals(resp.body(), \"\", u + \": body\");\n+        } else if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertNotEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+            assertNotEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        } else if (code == 303) {\n+            assertEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+        } else {\n+            assertEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void testPOST(URI uri, int code, String method) throws Exception {\n+        URI u = uri.resolve(\"foo?n=\" + requestCounter.incrementAndGet());\n+        HttpRequest request = HttpRequest.newBuilder(u)\n+                .POST(HttpRequest.BodyPublishers.ofString(REQUEST_BODY)).build();\n+        \/\/ POST is not considered idempotent.\n+        testNonIdempotent(u, request, code, method);\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void testPUT(URI uri, int code, String method) throws Exception {\n+        URI u = uri.resolve(\"foo?n=\" + requestCounter.incrementAndGet());\n+        System.out.println(\"Testing with \" + u);\n+        HttpRequest request = HttpRequest.newBuilder(u)\n+                .PUT(HttpRequest.BodyPublishers.ofString(REQUEST_BODY)).build();\n+        \/\/ PUT is considered idempotent.\n+        testIdempotent(u, request, code, method);\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void testFoo(URI uri, int code, String method) throws Exception {\n+        URI u = uri.resolve(\"foo?n=\" + requestCounter.incrementAndGet());\n+        System.out.println(\"Testing with \" + u);\n+        HttpRequest request = HttpRequest.newBuilder(u)\n+                .method(\"FOO\",\n+                        HttpRequest.BodyPublishers.ofString(REQUEST_BODY)).build();\n+        \/\/ FOO is considered idempotent.\n+        testIdempotent(u, request, code, method);\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void testGet(URI uri, int code, String method) throws Exception {\n+        URI u = uri.resolve(\"foo?n=\" + requestCounter.incrementAndGet());\n+        System.out.println(\"Testing with \" + u);\n+        HttpRequest request = HttpRequest.newBuilder(u)\n+                .method(\"GET\",\n+                        HttpRequest.BodyPublishers.ofString(REQUEST_BODY)).build();\n+        CompletableFuture<HttpResponse<String>> respCf =\n+                client.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n+        HttpResponse<String> resp = respCf.join();\n+        \/\/ body will be preserved except for 304 and 303: this is a GET.\n+        if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertEquals(resp.statusCode(), code, u + \": status code\");\n+        } else {\n+            assertEquals(resp.statusCode(), 200, u + \": status code\");\n+        }\n+        if (code == 304) {\n+            assertEquals(resp.body(), \"\", u + \": body\");\n+        } else if (method.equals(\"DO_NOT_FOLLOW\")) {\n+            assertNotEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+            assertNotEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        } else if (code == 303) {\n+            assertEquals(resp.body(), GET_RESPONSE_BODY, u + \": body\");\n+        } else {\n+            assertEquals(resp.body(), REQUEST_BODY, u + \": body\");\n+        }\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        proxy = stop(proxy, DigestEchoServer.TunnelingProxy::stop);\n+        http1Server = stop(http1Server, HttpTestServer::stop);\n+        https1Server = stop(https1Server, HttpTestServer::stop);\n+        http2Server = stop(http2Server, HttpTestServer::stop);\n+        https2Server = stop(https2Server, HttpTestServer::stop);\n+        client = null;\n+        try {\n+            executor.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        } catch (Throwable x) {\n+        } finally {\n+            executor.shutdownNow();\n+        }\n+        try {\n+            clientexec.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        } catch (Throwable x) {\n+        } finally {\n+            clientexec.shutdownNow();\n+        }\n+        System.out.println(\"Teardown: done\");\n+    }\n+\n+    private interface Stoppable<T> { public void stop(T service) throws Exception; }\n+\n+    static <T>  T stop(T service, Stoppable<T> stop) {\n+        try { if (service != null) stop.stop(service); } catch (Throwable x) { };\n+        return null;\n+    }\n+\n+    static class HttpProxySelector extends ProxySelector {\n+        private static final List<Proxy> NO_PROXY = List.of(Proxy.NO_PROXY);\n+        private final List<Proxy> proxyList;\n+        HttpProxySelector(InetSocketAddress proxyAddress) {\n+            proxyList = List.of(new Proxy(Proxy.Type.HTTP, proxyAddress));\n+        }\n+\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+            \/\/ our proxy only supports tunneling\n+            if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n+                if (uri.getPath().contains(\"\/proxy\/\")) {\n+                    return proxyList;\n+                }\n+            }\n+            return NO_PROXY;\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n+            System.err.println(\"Connection to proxy failed: \" + ioe);\n+            System.err.println(\"Proxy: \" + sa);\n+            System.err.println(\"\\tURI: \" + uri);\n+            ioe.printStackTrace();\n+        }\n+    }\n+\n+    public static class HttpTestRedirectHandler implements HttpTestHandler {\n+        static final AtomicLong respCounter = new AtomicLong();\n+        final String scheme;\n+        final HttpTestServer server;\n+        HttpTestRedirectHandler(String scheme, HttpTestServer server) {\n+            this.scheme = scheme;\n+            this.server = server;\n+        }\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (InputStream is = t.getRequestBody()) {\n+                byte[] bytes = is.readAllBytes();\n+                URI u = t.getRequestURI();\n+                long responseID = Long.parseLong(u.getQuery().substring(2));\n+                String path = u.getPath();\n+                int i = path.lastIndexOf('\/');\n+                String file = path.substring(i+1);\n+                String parent =  path.substring(0, i);\n+                int code = 200;\n+                if (file.equals(\"foo\")) {\n+                    i = parent.lastIndexOf(\"\/\");\n+                    code = Integer.parseInt(parent.substring(i+1));\n+                }\n+                String response;\n+                if (code == 200) {\n+                    if (t.getRequestMethod().equals(\"GET\")) {\n+                        if (bytes.length == 0) {\n+                            response = GET_RESPONSE_BODY;\n+                        } else {\n+                            response = new String(bytes, StandardCharsets.UTF_8);\n+                        }\n+                    } else if (t.getRequestMethod().equals(\"POST\")) {\n+                        response = new String(bytes, StandardCharsets.UTF_8);\n+                    } else {\n+                        response = new String(bytes, StandardCharsets.UTF_8);\n+                    }\n+                } else if (code < 300 || code > 399) {\n+                    response = \"Unexpected code: \" + code;\n+                    code = 400;\n+                } else {\n+                    try {\n+                        URI reloc = new URI(scheme, server.serverAuthority(), parent + \"\/bar\", u.getQuery(), null);\n+                        t.getResponseHeaders().addHeader(\"Location\", reloc.toASCIIString());\n+                        if (code != 304) {\n+                            response = \"Code: \" + code;\n+                        } else response = null;\n+                    } catch (URISyntaxException x) {\n+                        x.printStackTrace();\n+                        x.printStackTrace(System.out);\n+                        code = 400;\n+                        response = x.toString();\n+                    }\n+                }\n+\n+                System.out.println(\"Server \" + t.getRequestURI() + \" sending response \" + responseID);\n+                System.out.println(\"code: \" + code + \" body: \" + response);\n+                t.sendResponseHeaders(code, code == 304 ? 0: -1);\n+                if (code != 304) {\n+                    try (OutputStream os = t.getResponseBody()) {\n+                        bytes = response.getBytes(StandardCharsets.UTF_8);\n+                        os.write(bytes);\n+                        os.flush();\n+                    }\n+                } else {\n+                    bytes = new byte[0];\n+                }\n+\n+                System.out.println(\"\\tresp:\" + responseID + \": wrote \" + bytes.length + \" bytes\");\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                e.printStackTrace(System.out);\n+                throw e;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRedirectTest.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,5 @@\n+        @Override\n+        protected int redirectCode() {\n+            return 308; \/\/ we need to use a code that preserves the body\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/RedirectTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-                t.getRequestURI().toString(), t.getRemoteAddress().toString());\n+                    t.getRequestURI().toString(), t.getRemoteAddress().toString());\n@@ -49,1 +49,1 @@\n-            t.sendResponseHeaders(301, 1024);\n+            t.sendResponseHeaders(redirectCode(), 1024);\n@@ -58,0 +58,4 @@\n+    protected int redirectCode() {\n+        return 301;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2RedirectHandler.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}