{"files":[{"patch":"@@ -0,0 +1,421 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+CgroupSubsystem* CgroupSubsystemFactory::create() {\n+  CgroupV1MemoryController* memory = NULL;\n+  CgroupV1Controller* cpuset = NULL;\n+  CgroupV1Controller* cpu = NULL;\n+  CgroupV1Controller* cpuacct = NULL;\n+  FILE *mntinfo = NULL;\n+  FILE *cgroups = NULL;\n+  FILE *cgroup = NULL;\n+  char buf[MAXPATHLEN+1];\n+  char tmproot[MAXPATHLEN+1];\n+  char tmpmount[MAXPATHLEN+1];\n+  char *p;\n+  bool is_cgroupsV2;\n+  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ at the kernel level.\n+  bool all_controllers_enabled;\n+\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  int cpuset_idx  = 0;\n+  int cpu_idx     = 1;\n+  int cpuacct_idx = 2;\n+  int memory_idx  = 3;\n+\n+  \/*\n+   * Read \/proc\/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.\n+   *\n+   * For cgroups v1 unified hierarchy, cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field.\n+   *\/\n+  cgroups = fopen(\"\/proc\/cgroups\", \"r\");\n+  if (cgroups == NULL) {\n+      log_debug(os, container)(\"Can't open \/proc\/cgroups, %s\",\n+                               os::strerror(errno));\n+      return NULL;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {\n+    char name[MAXPATHLEN+1];\n+    int  hierarchy_id;\n+    int  enabled;\n+\n+    \/\/ Format of \/proc\/cgroups documented via man 7 cgroups\n+    if (sscanf(p, \"%s %d %*d %d\", name, &hierarchy_id, &enabled) != 3) {\n+      continue;\n+    }\n+    if (strcmp(name, \"memory\") == 0) {\n+      cg_infos[memory_idx]._name = os::strdup(name);\n+      cg_infos[memory_idx]._hierarchy_id = hierarchy_id;\n+      cg_infos[memory_idx]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuset\") == 0) {\n+      cg_infos[cpuset_idx]._name = os::strdup(name);\n+      cg_infos[cpuset_idx]._hierarchy_id = hierarchy_id;\n+      cg_infos[cpuset_idx]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpu\") == 0) {\n+      cg_infos[cpu_idx]._name = os::strdup(name);\n+      cg_infos[cpu_idx]._hierarchy_id = hierarchy_id;\n+      cg_infos[cpu_idx]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuacct\") == 0) {\n+      cg_infos[cpuacct_idx]._name = os::strdup(name);\n+      cg_infos[cpuacct_idx]._hierarchy_id = hierarchy_id;\n+      cg_infos[cpuacct_idx]._enabled = (enabled == 1);\n+    }\n+  }\n+  fclose(cgroups);\n+\n+  is_cgroupsV2 = true;\n+  all_controllers_enabled = true;\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+  }\n+\n+  if (!all_controllers_enabled) {\n+    \/\/ one or more controllers disabled, disable container support\n+    log_debug(os, container)(\"One or more required controllers disabled at kernel level.\");\n+    return NULL;\n+  }\n+\n+  \/*\n+   * Read \/proc\/self\/cgroup and determine:\n+   *  - the cgroup path for cgroups v2 or\n+   *  - on a cgroups v1 system, collect info for mapping\n+   *    the host mount point to the local one via \/proc\/self\/mountinfo below.\n+   *\/\n+  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n+  if (cgroup == NULL) {\n+    log_debug(os, container)(\"Can't open \/proc\/self\/cgroup, %s\",\n+                             os::strerror(errno));\n+    return NULL;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n+    char *controllers;\n+    char *token;\n+    char *hierarchy_id_str;\n+    int  hierarchy_id;\n+    char *cgroup_path;\n+\n+    hierarchy_id_str = strsep(&p, \":\");\n+    hierarchy_id = atoi(hierarchy_id_str);\n+    \/* Get controllers and base *\/\n+    controllers = strsep(&p, \":\");\n+    cgroup_path = strsep(&p, \"\\n\");\n+\n+    if (controllers == NULL) {\n+      continue;\n+    }\n+\n+    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != NULL) {\n+      if (strcmp(token, \"memory\") == 0) {\n+        assert(hierarchy_id == cg_infos[memory_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[memory_idx]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuset\") == 0) {\n+        assert(hierarchy_id == cg_infos[cpuset_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[cpuset_idx]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpu\") == 0) {\n+        assert(hierarchy_id == cg_infos[cpu_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[cpu_idx]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuacct\") == 0) {\n+        assert(hierarchy_id == cg_infos[cpuacct_idx]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[cpuacct_idx]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+    if (is_cgroupsV2) {\n+      for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+        cg_infos[i]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+  }\n+  fclose(cgroup);\n+\n+  if (is_cgroupsV2) {\n+    \/\/ Find the cgroup2 mount point by reading \/proc\/self\/mountinfo\n+    mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n+    if (mntinfo == NULL) {\n+        log_debug(os, container)(\"Can't open \/proc\/self\/mountinfo, %s\",\n+                                 os::strerror(errno));\n+        return NULL;\n+    }\n+\n+    char cgroupv2_mount[MAXPATHLEN+1];\n+    char fstype[MAXPATHLEN+1];\n+    bool mount_point_found = false;\n+    while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+      char *tmp_mount_point = cgroupv2_mount;\n+      char *tmp_fs_type = fstype;\n+\n+      \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+      if (sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+        \/\/ we likely have an early match return, be sure we have cgroup2 as fstype\n+        if (strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+          mount_point_found = true;\n+          break;\n+        }\n+      }\n+    }\n+    fclose(mntinfo);\n+    if (!mount_point_found) {\n+      log_trace(os, container)(\"Mount point for cgroupv2 not found in \/proc\/self\/mountinfo\");\n+      return NULL;\n+    }\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cgroupv2_mount, cg_infos[memory_idx]._cgroup_path);\n+    for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+      os::free(cg_infos[i]._name);\n+      os::free(cg_infos[i]._cgroup_path);\n+    }\n+    log_debug(os, container)(\"Detected cgroups v2 unified hierarchy\");\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/\/ What follows is cgroups v1\n+  log_debug(os, container)(\"Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers\");\n+\n+  \/*\n+   * Find the cgroup mount point for memory and cpuset\n+   * by reading \/proc\/self\/mountinfo\n+   *\n+   * Example for docker:\n+   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+   *\n+   * Example for host:\n+   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+   *\/\n+  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n+  if (mntinfo == NULL) {\n+      log_debug(os, container)(\"Can't open \/proc\/self\/mountinfo, %s\",\n+                               os::strerror(errno));\n+      return NULL;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n+      continue;\n+    }\n+    while ((token = strsep(&cptr, \",\")) != NULL) {\n+      if (strcmp(token, \"memory\") == 0) {\n+        memory = new CgroupV1MemoryController(tmproot, tmpmount);\n+      } else if (strcmp(token, \"cpuset\") == 0) {\n+        cpuset = new CgroupV1Controller(tmproot, tmpmount);\n+      } else if (strcmp(token, \"cpu\") == 0) {\n+        cpu = new CgroupV1Controller(tmproot, tmpmount);\n+      } else if (strcmp(token, \"cpuacct\") == 0) {\n+        cpuacct= new CgroupV1Controller(tmproot, tmpmount);\n+      }\n+    }\n+  }\n+\n+  fclose(mntinfo);\n+\n+  if (memory == NULL) {\n+    log_debug(os, container)(\"Required cgroup v1 memory subsystem not found\");\n+    return NULL;\n+  }\n+  if (cpuset == NULL) {\n+    log_debug(os, container)(\"Required cgroup v1 cpuset subsystem not found\");\n+    return NULL;\n+  }\n+  if (cpu == NULL) {\n+    log_debug(os, container)(\"Required cgroup v1 cpu subsystem not found\");\n+    return NULL;\n+  }\n+  if (cpuacct == NULL) {\n+    log_debug(os, container)(\"Required cgroup v1 cpuacct subsystem not found\");\n+    return NULL;\n+  }\n+\n+  \/*\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+\/* active_processor_count\n+ *\n+ * Calculate an appropriate number of active processors for the\n+ * VM to use based on these three inputs.\n+ *\n+ * cpu affinity\n+ * cgroup cpu quota & cpu period\n+ * cgroup cpu shares\n+ *\n+ * Algorithm:\n+ *\n+ * Determine the number of available CPUs from sched_getaffinity\n+ *\n+ * If user specified a quota (quota != -1), calculate the number of\n+ * required CPUs by dividing quota by period.\n+ *\n+ * If shares are in effect (shares != -1), calculate the number\n+ * of CPUs required for the shares by dividing the share value\n+ * by PER_CPU_SHARES.\n+ *\n+ * All results of division are rounded up to the next whole number.\n+ *\n+ * If neither shares or quotas have been specified, return the\n+ * number of active processors in the system.\n+ *\n+ * If both shares and quotas have been specified, the results are\n+ * based on the flag PreferContainerQuotaForCPUCount.  If true,\n+ * return the quota value.  If false return the smallest value\n+ * between shares or quotas.\n+ *\n+ * If shares and\/or quotas have been specified, the resulting number\n+ * returned will never exceed the number of active processors.\n+ *\n+ * return:\n+ *    number of CPUs\n+ *\/\n+int CgroupSubsystem::active_processor_count() {\n+  int quota_count = 0, share_count = 0;\n+  int cpu_count, limit_count;\n+  int result;\n+\n+  \/\/ We use a cache with a timeout to avoid performing expensive\n+  \/\/ computations in the event this function is called frequently.\n+  \/\/ [See 8227006].\n+  CachingCgroupController* contrl = cpu_controller();\n+  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  if (!cpu_limit->should_check_metric()) {\n+    int val = (int)cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n+    return val;\n+  }\n+\n+  cpu_count = limit_count = os::Linux::active_processor_count();\n+  int quota  = cpu_quota();\n+  int period = cpu_period();\n+  int share  = cpu_shares();\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+  if (share > -1) {\n+    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n+    log_trace(os, container)(\"CPU Share count based on shares: %d\", share_count);\n+  }\n+\n+  \/\/ If both shares and quotas are setup results depend\n+  \/\/ on flag PreferContainerQuotaForCPUCount.\n+  \/\/ If true, limit CPU count to quota\n+  \/\/ If false, use minimum of shares and quotas\n+  if (quota_count !=0 && share_count != 0) {\n+    if (PreferContainerQuotaForCPUCount) {\n+      limit_count = quota_count;\n+    } else {\n+      limit_count = MIN2(quota_count, share_count);\n+    }\n+  } else if (quota_count != 0) {\n+    limit_count = quota_count;\n+  } else if (share_count != 0) {\n+    limit_count = share_count;\n+  }\n+\n+  result = MIN2(cpu_count, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  cpu_limit->set_value(result, OSCONTAINER_CACHE_TIMEOUT);\n+\n+  return result;\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupSubsystem::memory_limit_in_bytes() {\n+  CachingCgroupController* contrl = memory_controller();\n+  CachedMetric* memory_limit = contrl->metrics_cache();\n+  if (!memory_limit->should_check_metric()) {\n+    return memory_limit->value();\n+  }\n+  jlong mem_limit = read_memory_limit_in_bytes();\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  memory_limit->set_value(mem_limit, OSCONTAINER_CACHE_TIMEOUT);\n+  return mem_limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":421,"deletions":0,"binary":false,"changes":421,"status":"added"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_SUBSYSTEM_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"osContainer_linux.hpp\"\n+\n+\/\/ Shared cgroups code (used by cgroup version 1 and version 2)\n+\n+\/*\n+ * PER_CPU_SHARES has been set to 1024 because CPU shares' quota\n+ * is commonly used in cloud frameworks like Kubernetes[1],\n+ * AWS[2] and Mesos[3] in a similar way. They spawn containers with\n+ * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do\n+ * the inverse for determining the number of possible available\n+ * CPUs to the JVM inside a container. See JDK-8216366.\n+ *\n+ * [1] https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-compute-resources-container\/#meaning-of-cpu\n+ *     In particular:\n+ *        When using Docker:\n+ *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially\n+ *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the\n+ *          --cpu-shares flag in the docker run command.\n+ * [2] https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/APIReference\/API_ContainerDefinition.html\n+ * [3] https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/docker\/docker.cpp#L648\n+ *     https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/slave\/containerizer\/mesos\/isolators\/cgroups\/constants.hpp#L30\n+ *\/\n+#define PER_CPU_SHARES 1024\n+\n+typedef char * cptr;\n+\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path();\n+};\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int subsystem_file_line_contents(CgroupController* c,\n+                                              const char *filename,\n+                                              const char *matchline,\n+                                              const char *scan_fmt,\n+                                              T returnval) {\n+  FILE *fp = NULL;\n+  char *p;\n+  char file[MAXPATHLEN+1];\n+  char buf[MAXPATHLEN+1];\n+  char discard[MAXPATHLEN+1];\n+  bool found_match = false;\n+\n+  if (c == NULL) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == NULL) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n+  file[MAXPATHLEN-1] = '\\0';\n+  int filelen = strlen(file);\n+  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n+    return OSCONTAINER_ERROR;\n+  }\n+  strncat(file, filename, MAXPATHLEN-filelen);\n+  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n+  fp = fopen(file, \"r\");\n+  if (fp != NULL) {\n+    int err = 0;\n+    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n+      found_match = false;\n+      if (matchline == NULL) {\n+        \/\/ single-line file case\n+        int matched = sscanf(p, scan_fmt, returnval);\n+        found_match = (matched == 1);\n+      } else {\n+        \/\/ multi-line file case\n+        if (strstr(p, matchline) != NULL) {\n+          \/\/ discard matchline string prefix\n+          int matched = sscanf(p, scan_fmt, discard, returnval);\n+          found_match = (matched == 2);\n+        } else {\n+          continue; \/\/ substring not found\n+        }\n+      }\n+      if (found_match) {\n+        fclose(fp);\n+        return 0;\n+      } else {\n+        err = 1;\n+        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n+      }\n+    }\n+    if (err == 0) {\n+      log_debug(os, container)(\"Empty file %s\", file);\n+    }\n+  } else {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n+  }\n+  if (fp != NULL)\n+    fclose(fp);\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n+                           logstring, scan_fmt, variable)                 \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     &variable);                          \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n+                               logstring, scan_fmt, variable, bufsize)    \\\n+  char variable[bufsize];                                                 \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     variable);                           \\\n+  if (err != 0)                                                           \\\n+    return (return_type) NULL;                                            \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n+                           matchline, logstring, scan_fmt, variable)      \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(controller,                          \\\n+                                filename,                                 \\\n+                                matchline,                                \\\n+                                scan_fmt,                                 \\\n+                                &variable);                               \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+\n+class CachedMetric : public CHeapObj<mtInternal>{\n+  private:\n+    volatile jlong _metric;\n+    volatile jlong _next_check_counter;\n+  public:\n+    CachedMetric() {\n+      _metric = -1;\n+      _next_check_counter = min_jlong;\n+    }\n+    bool should_check_metric() {\n+      return os::elapsed_counter() > _next_check_counter;\n+    }\n+    jlong value() { return _metric; }\n+    void set_value(jlong value, jlong timeout) {\n+      _metric = value;\n+      \/\/ Metric is unlikely to change, but we want to remain\n+      \/\/ responsive to configuration changes. A very short grace time\n+      \/\/ between re-read avoids excessive overhead during startup without\n+      \/\/ significantly reducing the VMs ability to promptly react to changed\n+      \/\/ metric config\n+      _next_check_counter = os::elapsed_counter() + timeout;\n+    }\n+};\n+\n+class CachingCgroupController : public CHeapObj<mtInternal> {\n+  private:\n+    CgroupController* _controller;\n+    CachedMetric* _metrics_cache;\n+\n+  public:\n+    CachingCgroupController(CgroupController* cont) {\n+      _controller = cont;\n+      _metrics_cache = new CachedMetric();\n+    }\n+\n+    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CgroupController* controller() { return _controller; }\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual int cpu_quota();\n+    virtual int cpu_period();\n+    virtual int cpu_shares();\n+    virtual jlong memory_usage_in_bytes();\n+    virtual jlong memory_and_swap_limit_in_bytes();\n+    virtual jlong memory_soft_limit_in_bytes();\n+    virtual jlong memory_max_usage_in_bytes();\n+    virtual char * cpu_cpuset_cpus();\n+    virtual char * cpu_cpuset_memory_nodes();\n+    virtual jlong read_memory_limit_in_bytes();\n+    virtual const char * container_type();\n+    virtual CachingCgroupController* memory_controller();\n+    virtual CachingCgroupController* cpu_controller();\n+};\n+\n+class CgroupSubsystemFactory: AllStatic {\n+  public:\n+    static CgroupSubsystem* create();\n+};\n+\n+\/\/ Class representing info in \/proc\/self\/cgroup.\n+\/\/ See man 7 cgroups\n+class CgroupInfo : public StackObj {\n+  friend class CgroupSubsystemFactory;\n+\n+  private:\n+  char* _name;\n+  int _hierarchy_id;\n+  bool _enabled;\n+  char* _cgroup_path;\n+\n+};\n+\n+\n+#endif \/\/ CGROUP_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  if (_root != NULL && cgroup_path != NULL) {\n+    if (strcmp(_root, \"\/\") == 0) {\n+      int buflen;\n+      strncpy(buf, _mount_point, MAXPATHLEN);\n+      buf[MAXPATHLEN-1] = '\\0';\n+      if (strcmp(cgroup_path,\"\/\") != 0) {\n+        buflen = strlen(buf);\n+        if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n+          return;\n+        }\n+        strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+        buf[MAXPATHLEN-1] = '\\0';\n+      }\n+      _path = os::strdup(buf);\n+    } else {\n+      if (strcmp(_root, cgroup_path) == 0) {\n+        strncpy(buf, _mount_point, MAXPATHLEN);\n+        buf[MAXPATHLEN-1] = '\\0';\n+        _path = os::strdup(buf);\n+      } else {\n+        char *p = strstr(cgroup_path, _root);\n+        if (p != NULL && p == _root) {\n+          if (strlen(cgroup_path) > strlen(_root)) {\n+            int buflen;\n+            strncpy(buf, _mount_point, MAXPATHLEN);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            buflen = strlen(buf);\n+            if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n+              return;\n+            }\n+            strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            _path = os::strdup(buf);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/* uses_mem_hierarchy\n+ *\n+ * Return whether or not hierarchical cgroup accounting is being\n+ * done.\n+ *\n+ * return:\n+ *    A number > 0 if true, or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n+  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n+                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n+  return use_hierarchy;\n+}\n+\n+void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n+  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  jlong hierarchy = uses_mem_hierarchy();\n+  if (hierarchy > 0) {\n+    set_hierarchical(true);\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n+                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n+\n+  if (memlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memory_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  }\n+  else {\n+    return (jlong)memlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n+                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  if (memswlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memsw_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memswlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  if (memsoftlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Memory Soft Limit is: Unlimited\");\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memsoftlimit;\n+  }\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory for this process.\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+\/* memory_max_usage_in_bytes\n+ *\n+ * Return the maximum amount of used memory for this process.\n+ *\n+ * return:\n+ *    max memory usage in bytes or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n+                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+  return memmaxusage;\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  return os::strdup(cpus);\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  return os::strdup(mems);\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_quota() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n+                     \"CPU Quota is: %d\", \"%d\", quota);\n+  return quota;\n+}\n+\n+int CgroupV1Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n+                     \"CPU Period is: %d\", \"%d\", period);\n+  return period;\n+}\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n+                     \"CPU Shares is: %d\", \"%d\", shares);\n+  \/\/ Convert 1024 to no shares setup\n+  if (shares == 1024) return -1;\n+\n+  return shares;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+\/\/ Cgroups version 1 specific implementation\n+\n+class CgroupV1Controller: public CgroupController {\n+  private:\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path;\n+\n+  public:\n+    CgroupV1Controller(char *root, char *mountpoint) {\n+      _root = os::strdup(root);\n+      _mount_point = os::strdup(mountpoint);\n+      _path = NULL;\n+    }\n+\n+    virtual void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV1MemoryController: public CgroupV1Controller {\n+\n+  public:\n+    bool is_hierarchical() { return _uses_mem_hierarchy; }\n+    void set_subsystem_path(char *cgroup_path);\n+  private:\n+    \/* Some container runtimes set limits via cgroup\n+     * hierarchy. If set to true consider also memory.stat\n+     * file if everything else seems unlimited *\/\n+    bool _uses_mem_hierarchy;\n+    jlong uses_mem_hierarchy();\n+    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+\n+  public:\n+    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+      _uses_mem_hierarchy = false;\n+    }\n+\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n+\n+  public:\n+    jlong read_memory_limit_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+\n+    int cpu_quota();\n+    int cpu_period();\n+\n+    int cpu_shares();\n+\n+    const char * container_type() {\n+      return \"cgroupv1\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+\n+  private:\n+    julong _unlimited_memory;\n+\n+    \/* controllers *\/\n+    CachingCgroupController* _memory = NULL;\n+    CgroupV1Controller* _cpuset = NULL;\n+    CachingCgroupController* _cpu = NULL;\n+    CgroupV1Controller* _cpuacct = NULL;\n+\n+  public:\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1Controller* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1MemoryController* memory) {\n+      _cpuset = cpuset;\n+      _cpu = new CachingCgroupController(cpu);\n+      _cpuacct = cpuacct;\n+      _memory = new CachingCgroupController(memory);\n+      _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n+    }\n+};\n+\n+#endif \/\/ CGROUP_V1_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n+                     \"Raw value for CPU shares is: %d\", \"%d\", shares);\n+  \/\/ Convert default value of 100 to no shares setup\n+  if (shares == 100) {\n+    log_debug(os, container)(\"CPU Shares is: %d\", -1);\n+    return -1;\n+  }\n+\n+  \/\/ CPU shares (OCI) value needs to get translated into\n+  \/\/ a proper Cgroups v2 value. See:\n+  \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+  \/\/\n+  \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+  \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+  \/\/\n+  int x = 262142 * shares - 1;\n+  double frac = x\/9999.0;\n+  x = ((int)frac) + 2;\n+  log_trace(os, container)(\"Scaled CPU shares value is: %d\", x);\n+  \/\/ Since the scaled value is not precise, return the closest\n+  \/\/ multiple of PER_CPU_SHARES for a more conservative mapping\n+  if ( x <= PER_CPU_SHARES ) {\n+     \/\/ will always map to 1 CPU\n+     log_debug(os, container)(\"CPU Shares is: %d\", x);\n+     return x;\n+  }\n+  int f = x\/PER_CPU_SHARES;\n+  int lower_multiple = f * PER_CPU_SHARES;\n+  int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+  int distance_lower = MAX2(lower_multiple, x) - MIN2(lower_multiple, x);\n+  int distance_upper = MAX2(upper_multiple, x) - MIN2(upper_multiple, x);\n+  x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+  log_trace(os, container)(\"Closest multiple of %d of the CPU Shares value is: %d\", PER_CPU_SHARES, x);\n+  log_debug(os, container)(\"CPU Shares is: %d\", x);\n+  return x;\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val();\n+  int limit = (int)limit_from_str(cpu_quota_str);\n+  log_trace(os, container)(\"CPU Quota is: %d\", limit);\n+  return limit;\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  if (cpus == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(cpus);\n+}\n+\n+char* CgroupV2Subsystem::cpu_quota_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n+                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n+  if (quota == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(quota);\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  if (mems == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mems);\n+}\n+\n+int CgroupV2Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n+                     \"CPU Period is: %d\", \"%*s %d\", period);\n+  return period;\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory used by this cgroup and decendents\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+  char* mem_soft_limit_str = mem_soft_limit_val();\n+  return limit_from_str(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+  \/\/ Log this string at trace level so as to make tests happy.\n+  log_trace(os, container)(\"Maximum Memory Usage is not supported.\");\n+  return OSCONTAINER_ERROR; \/\/ not supported\n+}\n+\n+char* CgroupV2Subsystem::mem_soft_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.high\",\n+                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n+  if (mem_soft_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+  char* mem_swp_limit_str = mem_swp_limit_val();\n+  return limit_from_str(mem_swp_limit_str);\n+}\n+\n+char* CgroupV2Subsystem::mem_swp_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n+  if (mem_swp_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_swp_limit_str);\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *\/\n+jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n+  char * mem_limit_str = mem_limit_val();\n+  jlong limit = limit_from_str(mem_limit_str);\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  return limit;\n+}\n+\n+jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n+\n+char* CgroupV2Subsystem::mem_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n+  if (mem_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_limit_str);\n+}\n+\n+char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  int buflen;\n+  strncpy(buf, mount_path, MAXPATHLEN);\n+  buf[MAXPATHLEN] = '\\0';\n+  buflen = strlen(buf);\n+  if ((buflen + strlen(cgroup_path)) > MAXPATHLEN) {\n+    return NULL;\n+  }\n+  strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+  buf[MAXPATHLEN] = '\\0';\n+  return os::strdup(buf);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupV2Controller: public CgroupController {\n+  private:\n+    \/* the mount path of the cgroup v2 hierarchy *\/\n+    char *_mount_path;\n+    \/* The cgroup path for the controller *\/\n+    char *_cgroup_path;\n+\n+    \/* Constructed full path to the subsystem directory *\/\n+    char *_path;\n+    static char* construct_path(char* mount_path, char *cgroup_path);\n+\n+  public:\n+    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n+      _mount_path = mount_path;\n+      _cgroup_path = os::strdup(cgroup_path);\n+      _path = construct_path(mount_path, cgroup_path);\n+    }\n+\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV2Subsystem: public CgroupSubsystem {\n+  private:\n+    \/* One unified controller *\/\n+    CgroupController* _unified = NULL;\n+    \/* Caching wrappers for cpu\/memory metrics *\/\n+    CachingCgroupController* _memory = NULL;\n+    CachingCgroupController* _cpu = NULL;\n+\n+    char *mem_limit_val();\n+    char *mem_swp_limit_val();\n+    char *mem_soft_limit_val();\n+    char *cpu_quota_val();\n+    jlong limit_from_str(char* limit_str);\n+\n+  public:\n+    CgroupV2Subsystem(CgroupController * unified) {\n+      _unified = unified;\n+      _memory = new CachingCgroupController(unified);\n+      _cpu = new CachingCgroupController(unified);\n+    }\n+\n+    jlong read_memory_limit_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+    const char * container_type() {\n+      return \"cgroupv2\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+};\n+\n+#endif \/\/ CGROUP_V2_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -34,1 +34,0 @@\n-#define PER_CPU_SHARES 1024\n@@ -38,240 +37,1 @@\n-int   OSContainer::_active_processor_count = 1;\n-julong _unlimited_memory;\n-\n-class CgroupSubsystem: CHeapObj<mtInternal> {\n- friend class OSContainer;\n-\n-\n- private:\n-    volatile jlong _next_check_counter;\n-\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n- public:\n-    CgroupSubsystem(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = NULL;\n-      _next_check_counter = min_jlong;\n-    }\n-\n-    \/*\n-     * Set directory to subsystem specific files based\n-     * on the contents of the mountinfo and cgroup files.\n-     *\/\n-    void set_subsystem_path(char *cgroup_path) {\n-      char buf[MAXPATHLEN+1];\n-      if (_root != NULL && cgroup_path != NULL) {\n-        if (strcmp(_root, \"\/\") == 0) {\n-          int buflen;\n-          strncpy(buf, _mount_point, MAXPATHLEN);\n-          buf[MAXPATHLEN-1] = '\\0';\n-          if (strcmp(cgroup_path,\"\/\") != 0) {\n-            buflen = strlen(buf);\n-            if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n-              return;\n-            }\n-            strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n-            buf[MAXPATHLEN-1] = '\\0';\n-          }\n-          _path = os::strdup(buf);\n-        } else {\n-          if (strcmp(_root, cgroup_path) == 0) {\n-            strncpy(buf, _mount_point, MAXPATHLEN);\n-            buf[MAXPATHLEN-1] = '\\0';\n-            _path = os::strdup(buf);\n-          } else {\n-            char *p = strstr(cgroup_path, _root);\n-            if (p != NULL && p == _root) {\n-              if (strlen(cgroup_path) > strlen(_root)) {\n-                int buflen;\n-                strncpy(buf, _mount_point, MAXPATHLEN);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                buflen = strlen(buf);\n-                if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n-                  return;\n-                }\n-                strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                _path = os::strdup(buf);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    char *subsystem_path() { return _path; }\n-\n-    bool cache_has_expired() {\n-      return os::elapsed_counter() > _next_check_counter;\n-    }\n-\n-    void set_cache_expiry_time(jlong timeout) {\n-      _next_check_counter = os::elapsed_counter() + timeout;\n-    }\n-};\n-\n-class CgroupMemorySubsystem: CgroupSubsystem {\n- friend class OSContainer;\n-\n- private:\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    volatile jlong _memory_limit_in_bytes;\n-\n- public:\n-    CgroupMemorySubsystem(char *root, char *mountpoint) : CgroupSubsystem::CgroupSubsystem(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-      _memory_limit_in_bytes = -1;\n-\n-    }\n-\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n-\n-    jlong memory_limit_in_bytes() { return _memory_limit_in_bytes; }\n-    void set_memory_limit_in_bytes(jlong value) {\n-      _memory_limit_in_bytes = value;\n-      \/\/ max memory limit is unlikely to change, but we want to remain\n-      \/\/ responsive to configuration changes. A very short grace time\n-      \/\/ between re-read avoids excessive overhead during startup without\n-      \/\/ significantly reducing the VMs ability to promptly react to reduced\n-      \/\/ memory availability\n-      set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-    }\n-\n-};\n-\n-CgroupMemorySubsystem* memory = NULL;\n-CgroupSubsystem* cpuset = NULL;\n-CgroupSubsystem* cpu = NULL;\n-CgroupSubsystem* cpuacct = NULL;\n-\n-typedef char * cptr;\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int subsystem_file_line_contents(CgroupSubsystem* c,\n-                                              const char *filename,\n-                                              const char *matchline,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n-\n-  if (c == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupSubsytem* is NULL\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n-  fp = fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n-        }\n-      }\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n-      }\n-    }\n-    if (err == 0) {\n-      log_debug(os, container)(\"Empty file %s\", file);\n-    }\n-  } else {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n-  }\n-  if (fp != NULL)\n-    fclose(fp);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, scan_fmt, variable)                 \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n-\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) NULL;                                            \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n-\n-#define GET_CONTAINER_INFO_LINE(return_type, subsystem, filename,         \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+CgroupSubsystem* cgroup_subsystem;\n@@ -285,6 +45,0 @@\n-  FILE *mntinfo = NULL;\n-  FILE *cgroup = NULL;\n-  char buf[MAXPATHLEN+1];\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n-  char *p;\n@@ -298,2 +52,0 @@\n-  _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n-\n@@ -306,118 +58,3 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      log_debug(os, container)(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                               os::strerror(errno));\n-      return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupMemorySubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupSubsystem(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n-    log_debug(os, container)(\"Required cgroup memory subsystem not found\");\n-    return;\n-  }\n-  if (cpuset == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpuset subsystem not found\");\n-    return;\n-  }\n-  if (cpu == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpu subsystem not found\");\n-    return;\n-  }\n-  if (cpuacct == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpuacct subsystem not found\");\n-    return;\n-  }\n-\n-  \/*\n-   * Read \/proc\/self\/cgroup and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n-  if (cgroup == NULL) {\n-    log_debug(os, container)(\"Can't open \/proc\/self\/cgroup, %s\",\n-                             os::strerror(errno));\n-    return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n-    char *controllers;\n-    char *token;\n-    char *base;\n-\n-    \/* Skip cgroup number *\/\n-    strsep(&p, \":\");\n-    \/* Get controllers and base *\/\n-    controllers = strsep(&p, \":\");\n-    base = strsep(&p, \"\\n\");\n-\n-    if (controllers == NULL) {\n-      continue;\n-    }\n-\n-    while ((token = strsep(&controllers, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory->set_subsystem_path(base);\n-        jlong hierarchy = uses_mem_hierarchy();\n-        if (hierarchy > 0) {\n-          memory->set_hierarchical(true);\n-        }\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct->set_subsystem_path(base);\n-      }\n-    }\n+  cgroup_subsystem = CgroupSubsystemFactory::create();\n+  if (cgroup_subsystem == NULL) {\n+    return; \/\/ Required subsystem files not found or other error\n@@ -425,3 +62,0 @@\n-\n-  fclose(cgroup);\n-\n@@ -429,2 +63,2 @@\n-  \/\/ command line arguments have been processed.\n-  if ((mem_limit = memory_limit_in_bytes()) > 0) {\n+  \/\/ cgroup subsystem files have been processed.\n+  if ((mem_limit = cgroup_subsystem->memory_limit_in_bytes()) > 0) {\n@@ -440,5 +74,2 @@\n-  if (is_containerized()) {\n-    return \"cgroupv1\";\n-  } else {\n-    return NULL;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->container_type();\n@@ -447,25 +78,0 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong OSContainer::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n-}\n-\n-\n-\/* memory_limit_in_bytes\n- *\n- * Return the limit of available memory for this process.\n- *\n- * return:\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -473,31 +79,2 @@\n-  if (!memory->cache_has_expired()) {\n-    return memory->memory_limit_in_bytes();\n-  }\n-  jlong memory_limit = read_memory_limit_in_bytes();\n-  \/\/ Update CgroupMemorySubsystem to avoid re-reading container settings too often\n-  memory->set_memory_limit_in_bytes(memory_limit);\n-  return memory_limit;\n-}\n-\n-jlong OSContainer::read_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  }\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_limit_in_bytes();\n@@ -507,19 +84,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  if (memswlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n@@ -529,8 +89,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Memory Soft Limit is: Unlimited\");\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memsoftlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_soft_limit_in_bytes();\n@@ -549,3 +103,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_usage_in_bytes();\n@@ -554,8 +107,0 @@\n-\/* memory_max_usage_in_bytes\n- *\n- * Return the maximum amount of used memory for this process.\n- *\n- * return:\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -563,92 +108,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n-}\n-\n-\/* active_processor_count\n- *\n- * Calculate an appropriate number of active processors for the\n- * VM to use based on these three inputs.\n- *\n- * cpu affinity\n- * cgroup cpu quota & cpu period\n- * cgroup cpu shares\n- *\n- * Algorithm:\n- *\n- * Determine the number of available CPUs from sched_getaffinity\n- *\n- * If user specified a quota (quota != -1), calculate the number of\n- * required CPUs by dividing quota by period.\n- *\n- * If shares are in effect (shares != -1), calculate the number\n- * of CPUs required for the shares by dividing the share value\n- * by PER_CPU_SHARES.\n- *\n- * All results of division are rounded up to the next whole number.\n- *\n- * If neither shares or quotas have been specified, return the\n- * number of active processors in the system.\n- *\n- * If both shares and quotas have been specified, the results are\n- * based on the flag PreferContainerQuotaForCPUCount.  If true,\n- * return the quota value.  If false return the smallest value\n- * between shares or quotas.\n- *\n- * If shares and\/or quotas have been specified, the resulting number\n- * returned will never exceed the number of active processors.\n- *\n- * return:\n- *    number of CPUs\n- *\/\n-int OSContainer::active_processor_count() {\n-  int quota_count = 0, share_count = 0;\n-  int cpu_count, limit_count;\n-  int result;\n-\n-  \/\/ We use a cache with a timeout to avoid performing expensive\n-  \/\/ computations in the event this function is called frequently.\n-  \/\/ [See 8227006].\n-  if (!cpu->cache_has_expired()) {\n-    log_trace(os, container)(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n-    return OSContainer::_active_processor_count;\n-  }\n-\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-  int share  = cpu_shares();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-  if (share > -1) {\n-    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n-    log_trace(os, container)(\"CPU Share count based on shares: %d\", share_count);\n-  }\n-\n-  \/\/ If both shares and quotas are setup results depend\n-  \/\/ on flag PreferContainerQuotaForCPUCount.\n-  \/\/ If true, limit CPU count to quota\n-  \/\/ If false, use minimum of shares and quotas\n-  if (quota_count !=0 && share_count != 0) {\n-    if (PreferContainerQuotaForCPUCount) {\n-      limit_count = quota_count;\n-    } else {\n-      limit_count = MIN2(quota_count, share_count);\n-    }\n-  } else if (quota_count != 0) {\n-    limit_count = quota_count;\n-  } else if (share_count != 0) {\n-    limit_count = share_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n-  \/\/ Update the value and reset the cache timeout\n-  OSContainer::_active_processor_count = result;\n-  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-\n-  return result;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_max_usage_in_bytes();\n@@ -658,3 +113,2 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_cpus();\n@@ -664,3 +118,7 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_memory_nodes();\n+}\n+\n+int OSContainer::active_processor_count() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->active_processor_count();\n@@ -669,10 +127,0 @@\n-\/* cpu_quota\n- *\n- * Return the number of milliseconds per period\n- * process is guaranteed to run.\n- *\n- * return:\n- *    quota time in milliseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -680,3 +128,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: %d\", \"%d\", quota);\n-  return quota;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_quota();\n@@ -686,3 +133,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: %d\", \"%d\", period);\n-  return period;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_period();\n@@ -691,10 +137,0 @@\n-\/* cpu_shares\n- *\n- * Return the amount of cpu shares available to the process\n- *\n- * return:\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -702,6 +138,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.shares\",\n-                     \"CPU Shares is: %d\", \"%d\", shares);\n-  \/\/ Convert 1024 to no shares setup\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_shares();\n@@ -709,1 +141,0 @@\n-\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":36,"deletions":605,"binary":false,"changes":641,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-  static jlong uses_mem_hierarchy();\n@@ -71,1 +70,0 @@\n-  assert(_is_initialized, \"OSContainer not initialized\");\n@@ -75,1 +73,1 @@\n-#endif \/\/ OS_LINUX_VM_OSCONTAINER_LINUX_HPP\n+#endif \/\/ OS_LINUX_OSCONTAINER_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+  friend class CgroupSubsystem;\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -216,3 +217,15 @@\n-        Common.run(opts)\n-            .shouldMatch(\"CPU Shares is.*\" + shares)\n-            .shouldMatch(\"active_processor_count.*\" + expectedAPC);\n+        OutputAnalyzer out = Common.run(opts);\n+        \/\/ Cgroups v2 needs to do some scaling of raw shares values. Hence,\n+        \/\/ 256 CPU shares come back as 264. Raw value written to cpu.weight\n+        \/\/ is 10. The reason this works for >= 1024 shares value is because\n+        \/\/ post-scaling the closest multiple of 1024 is found and returned.\n+        \/\/\n+        \/\/ For values < 1024, this doesn't happen so loosen the match to a\n+        \/\/ 3-digit number and ensure the active_processor_count is as\n+        \/\/ expected.\n+        if (shares < 1024) {\n+            out.shouldMatch(\"CPU Shares is.*\\\\d{3}\");\n+        } else {\n+            out.shouldMatch(\"CPU Shares is.*\" + shares);\n+        }\n+        out.shouldMatch(\"active_processor_count.*\" + expectedAPC);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"}]}