{"files":[{"patch":"@@ -0,0 +1,499 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+CgroupSubsystem* CgroupSubsystemFactory::create() {\n+  CgroupV1MemoryController* memory = NULL;\n+  CgroupV1Controller* cpuset = NULL;\n+  CgroupV1Controller* cpu = NULL;\n+  CgroupV1Controller* cpuacct = NULL;\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  u1 cg_type_flags = INVALID_CGROUPS_GENERIC;\n+  const char* proc_cgroups = \"\/proc\/cgroups\";\n+  const char* proc_self_cgroup = \"\/proc\/self\/cgroup\";\n+  const char* proc_self_mountinfo = \"\/proc\/self\/mountinfo\";\n+\n+  bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &cg_type_flags);\n+\n+  if (!valid_cgroup) {\n+    \/\/ Could not detect cgroup type\n+    return NULL;\n+  }\n+  assert(is_valid_cgroup(&cg_type_flags), \"Expected valid cgroup type\");\n+\n+  if (is_cgroup_v2(&cg_type_flags)) {\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    log_debug(os, container)(\"Detected cgroups v2 unified hierarchy\");\n+    cleanup(cg_infos);\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/*\n+   * Cgroup v1 case:\n+   *\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  assert(is_cgroup_v1(&cg_type_flags), \"Cgroup v1 expected\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  cleanup(cg_infos);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,\n+                                            const char* proc_cgroups,\n+                                            const char* proc_self_cgroup,\n+                                            const char* proc_self_mountinfo,\n+                                            u1* flags) {\n+  FILE *mntinfo = NULL;\n+  FILE *cgroups = NULL;\n+  FILE *cgroup = NULL;\n+  char buf[MAXPATHLEN+1];\n+  char *p;\n+  bool is_cgroupsV2;\n+  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ at the kernel level.\n+  bool all_controllers_enabled;\n+\n+  \/*\n+   * Read \/proc\/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.\n+   *\n+   * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field and relevant controllers mounted.\n+   * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory\n+   * controllers must have hierarchy ID 0 and the unified controller mounted.\n+   *\/\n+  cgroups = fopen(proc_cgroups, \"r\");\n+  if (cgroups == NULL) {\n+      log_debug(os, container)(\"Can't open %s, %s\",\n+                               proc_cgroups, os::strerror(errno));\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {\n+    char name[MAXPATHLEN+1];\n+    int  hierarchy_id;\n+    int  enabled;\n+\n+    \/\/ Format of \/proc\/cgroups documented via man 7 cgroups\n+    if (sscanf(p, \"%s %d %*d %d\", name, &hierarchy_id, &enabled) != 3) {\n+      continue;\n+    }\n+    if (strcmp(name, \"memory\") == 0) {\n+      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n+      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuset\") == 0) {\n+      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n+      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpu\") == 0) {\n+      cg_infos[CPU_IDX]._name = os::strdup(name);\n+      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuacct\") == 0) {\n+      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n+      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n+    }\n+  }\n+  fclose(cgroups);\n+\n+  is_cgroupsV2 = true;\n+  all_controllers_enabled = true;\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+  }\n+\n+  if (!all_controllers_enabled) {\n+    \/\/ one or more controllers disabled, disable container support\n+    log_debug(os, container)(\"One or more required controllers disabled at kernel level.\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  \/*\n+   * Read \/proc\/self\/cgroup and determine:\n+   *  - the cgroup path for cgroups v2 or\n+   *  - on a cgroups v1 system, collect info for mapping\n+   *    the host mount point to the local one via \/proc\/self\/mountinfo below.\n+   *\/\n+  cgroup = fopen(proc_self_cgroup, \"r\");\n+  if (cgroup == NULL) {\n+    log_debug(os, container)(\"Can't open %s, %s\",\n+                             proc_self_cgroup, os::strerror(errno));\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n+    char *controllers;\n+    char *token;\n+    char *hierarchy_id_str;\n+    int  hierarchy_id;\n+    char *cgroup_path;\n+\n+    hierarchy_id_str = strsep(&p, \":\");\n+    hierarchy_id = atoi(hierarchy_id_str);\n+    \/* Get controllers and base *\/\n+    controllers = strsep(&p, \":\");\n+    cgroup_path = strsep(&p, \"\\n\");\n+\n+    if (controllers == NULL) {\n+      continue;\n+    }\n+\n+    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != NULL) {\n+      if (strcmp(token, \"memory\") == 0) {\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuset\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpu\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuacct\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+    if (is_cgroupsV2) {\n+      for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+        cg_infos[i]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+  }\n+  fclose(cgroup);\n+\n+  \/\/ Find various mount points by reading \/proc\/self\/mountinfo\n+  \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+  mntinfo = fopen(proc_self_mountinfo, \"r\");\n+  if (mntinfo == NULL) {\n+      log_debug(os, container)(\"Can't open %s, %s\",\n+                               proc_self_mountinfo, os::strerror(errno));\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  bool cgroupv2_mount_point_found = false;\n+  bool any_cgroup_mounts_found = false;\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmp_mount_point[MAXPATHLEN+1];\n+    char tmp_fs_type[MAXPATHLEN+1];\n+    char tmproot[MAXPATHLEN+1];\n+    char tmpmount[MAXPATHLEN+1];\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+    \/\/ block in the hybrid case.\n+    \/\/\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+      \/\/ we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype\n+      if (!cgroupv2_mount_point_found && strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+        cgroupv2_mount_point_found = true;\n+        any_cgroup_mounts_found = true;\n+        for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+          assert(cg_infos[i]._mount_path == NULL, \"_mount_path memory stomping\");\n+          cg_infos[i]._mount_path = os::strdup(tmp_mount_point);\n+        }\n+      }\n+    }\n+\n+    \/* Cgroup v1 relevant info\n+     *\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     *\n+     * Example for docker:\n+     * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+     *\n+     * Example for host:\n+     * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+     *\/\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s cgroup %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+      if (strcmp(\"cgroup\", tmp_fs_type) != 0) {\n+        \/\/ Skip cgroup2 fs lines on hybrid or unified hierarchy.\n+        continue;\n+      }\n+      any_cgroup_mounts_found = true;\n+      while ((token = strsep(&cptr, \",\")) != NULL) {\n+        if (strcmp(token, \"memory\") == 0) {\n+          assert(cg_infos[MEMORY_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[MEMORY_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuset\") == 0) {\n+          assert(cg_infos[CPUSET_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUSET_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpu\") == 0) {\n+          assert(cg_infos[CPU_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPU_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuacct\") == 0) {\n+          assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUACCT_IDX]._data_complete = true;\n+        }\n+      }\n+    }\n+  }\n+  fclose(mntinfo);\n+\n+  \/\/ Neither cgroup2 nor cgroup filesystems mounted via \/proc\/self\/mountinfo\n+  \/\/ No point in continuing.\n+  if (!any_cgroup_mounts_found) {\n+    log_trace(os, container)(\"No cgroup controllers mounted.\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_NO_MOUNT;\n+    return false;\n+  }\n+\n+  if (is_cgroupsV2) {\n+    if (!cgroupv2_mount_point_found) {\n+      log_trace(os, container)(\"Mount point for cgroupv2 not found in \/proc\/self\/mountinfo\");\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_V2;\n+      return false;\n+    }\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    *flags = CGROUPS_V2;\n+    return true;\n+  }\n+\n+  \/\/ What follows is cgroups v1\n+  log_debug(os, container)(\"Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers\");\n+\n+  if (!cg_infos[MEMORY_IDX]._data_complete) {\n+    log_debug(os, container)(\"Required cgroup v1 memory subsystem not found\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUSET_IDX]._data_complete) {\n+    log_debug(os, container)(\"Required cgroup v1 cpuset subsystem not found\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPU_IDX]._data_complete) {\n+    log_debug(os, container)(\"Required cgroup v1 cpu subsystem not found\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n+    log_debug(os, container)(\"Required cgroup v1 cpuacct subsystem not found\");\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  \/\/ Cgroups v1 case, we have all the info we need.\n+  *flags = CGROUPS_V1;\n+  return true;\n+\n+};\n+\n+void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n+  assert(cg_infos != NULL, \"Invariant\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    os::free(cg_infos[i]._name);\n+    os::free(cg_infos[i]._cgroup_path);\n+    os::free(cg_infos[i]._root_mount_path);\n+    os::free(cg_infos[i]._mount_path);\n+  }\n+}\n+\n+\/* active_processor_count\n+ *\n+ * Calculate an appropriate number of active processors for the\n+ * VM to use based on these three inputs.\n+ *\n+ * cpu affinity\n+ * cgroup cpu quota & cpu period\n+ * cgroup cpu shares\n+ *\n+ * Algorithm:\n+ *\n+ * Determine the number of available CPUs from sched_getaffinity\n+ *\n+ * If user specified a quota (quota != -1), calculate the number of\n+ * required CPUs by dividing quota by period.\n+ *\n+ * If shares are in effect (shares != -1), calculate the number\n+ * of CPUs required for the shares by dividing the share value\n+ * by PER_CPU_SHARES.\n+ *\n+ * All results of division are rounded up to the next whole number.\n+ *\n+ * If neither shares or quotas have been specified, return the\n+ * number of active processors in the system.\n+ *\n+ * If both shares and quotas have been specified, the results are\n+ * based on the flag PreferContainerQuotaForCPUCount.  If true,\n+ * return the quota value.  If false return the smallest value\n+ * between shares or quotas.\n+ *\n+ * If shares and\/or quotas have been specified, the resulting number\n+ * returned will never exceed the number of active processors.\n+ *\n+ * return:\n+ *    number of CPUs\n+ *\/\n+int CgroupSubsystem::active_processor_count() {\n+  int quota_count = 0, share_count = 0;\n+  int cpu_count, limit_count;\n+  int result;\n+\n+  \/\/ We use a cache with a timeout to avoid performing expensive\n+  \/\/ computations in the event this function is called frequently.\n+  \/\/ [See 8227006].\n+  CachingCgroupController* contrl = cpu_controller();\n+  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  if (!cpu_limit->should_check_metric()) {\n+    int val = (int)cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n+    return val;\n+  }\n+\n+  cpu_count = limit_count = os::Linux::active_processor_count();\n+  int quota  = cpu_quota();\n+  int period = cpu_period();\n+  int share  = cpu_shares();\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+  if (share > -1) {\n+    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n+    log_trace(os, container)(\"CPU Share count based on shares: %d\", share_count);\n+  }\n+\n+  \/\/ If both shares and quotas are setup results depend\n+  \/\/ on flag PreferContainerQuotaForCPUCount.\n+  \/\/ If true, limit CPU count to quota\n+  \/\/ If false, use minimum of shares and quotas\n+  if (quota_count !=0 && share_count != 0) {\n+    if (PreferContainerQuotaForCPUCount) {\n+      limit_count = quota_count;\n+    } else {\n+      limit_count = MIN2(quota_count, share_count);\n+    }\n+  } else if (quota_count != 0) {\n+    limit_count = quota_count;\n+  } else if (share_count != 0) {\n+    limit_count = share_count;\n+  }\n+\n+  result = MIN2(cpu_count, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  cpu_limit->set_value(result, OSCONTAINER_CACHE_TIMEOUT);\n+\n+  return result;\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupSubsystem::memory_limit_in_bytes() {\n+  CachingCgroupController* contrl = memory_controller();\n+  CachedMetric* memory_limit = contrl->metrics_cache();\n+  if (!memory_limit->should_check_metric()) {\n+    return memory_limit->value();\n+  }\n+  jlong mem_limit = read_memory_limit_in_bytes();\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  memory_limit->set_value(mem_limit, OSCONTAINER_CACHE_TIMEOUT);\n+  return mem_limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":499,"deletions":0,"binary":false,"changes":499,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_SUBSYSTEM_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"osContainer_linux.hpp\"\n+\n+\/\/ Shared cgroups code (used by cgroup version 1 and version 2)\n+\n+\/*\n+ * PER_CPU_SHARES has been set to 1024 because CPU shares' quota\n+ * is commonly used in cloud frameworks like Kubernetes[1],\n+ * AWS[2] and Mesos[3] in a similar way. They spawn containers with\n+ * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do\n+ * the inverse for determining the number of possible available\n+ * CPUs to the JVM inside a container. See JDK-8216366.\n+ *\n+ * [1] https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-compute-resources-container\/#meaning-of-cpu\n+ *     In particular:\n+ *        When using Docker:\n+ *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially\n+ *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the\n+ *          --cpu-shares flag in the docker run command.\n+ * [2] https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/APIReference\/API_ContainerDefinition.html\n+ * [3] https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/docker\/docker.cpp#L648\n+ *     https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/slave\/containerizer\/mesos\/isolators\/cgroups\/constants.hpp#L30\n+ *\/\n+#define PER_CPU_SHARES 1024\n+\n+#define CGROUPS_V1               1\n+#define CGROUPS_V2               2\n+#define INVALID_CGROUPS_V2       3\n+#define INVALID_CGROUPS_V1       4\n+#define INVALID_CGROUPS_NO_MOUNT 5\n+#define INVALID_CGROUPS_GENERIC  6\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+#define CPUSET_IDX     0\n+#define CPU_IDX        1\n+#define CPUACCT_IDX    2\n+#define MEMORY_IDX     3\n+\n+typedef char * cptr;\n+\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path();\n+};\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int subsystem_file_line_contents(CgroupController* c,\n+                                              const char *filename,\n+                                              const char *matchline,\n+                                              const char *scan_fmt,\n+                                              T returnval) {\n+  FILE *fp = NULL;\n+  char *p;\n+  char file[MAXPATHLEN+1];\n+  char buf[MAXPATHLEN+1];\n+  char discard[MAXPATHLEN+1];\n+  bool found_match = false;\n+\n+  if (c == NULL) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == NULL) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n+  file[MAXPATHLEN-1] = '\\0';\n+  int filelen = strlen(file);\n+  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n+    return OSCONTAINER_ERROR;\n+  }\n+  strncat(file, filename, MAXPATHLEN-filelen);\n+  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n+  fp = fopen(file, \"r\");\n+  if (fp != NULL) {\n+    int err = 0;\n+    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n+      found_match = false;\n+      if (matchline == NULL) {\n+        \/\/ single-line file case\n+        int matched = sscanf(p, scan_fmt, returnval);\n+        found_match = (matched == 1);\n+      } else {\n+        \/\/ multi-line file case\n+        if (strstr(p, matchline) != NULL) {\n+          \/\/ discard matchline string prefix\n+          int matched = sscanf(p, scan_fmt, discard, returnval);\n+          found_match = (matched == 2);\n+        } else {\n+          continue; \/\/ substring not found\n+        }\n+      }\n+      if (found_match) {\n+        fclose(fp);\n+        return 0;\n+      } else {\n+        err = 1;\n+        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n+      }\n+    }\n+    if (err == 0) {\n+      log_debug(os, container)(\"Empty file %s\", file);\n+    }\n+  } else {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n+  }\n+  if (fp != NULL)\n+    fclose(fp);\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n+                           logstring, scan_fmt, variable)                 \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     &variable);                          \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n+                               logstring, scan_fmt, variable, bufsize)    \\\n+  char variable[bufsize];                                                 \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     variable);                           \\\n+  if (err != 0)                                                           \\\n+    return (return_type) NULL;                                            \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n+                           matchline, logstring, scan_fmt, variable)      \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(controller,                          \\\n+                                filename,                                 \\\n+                                matchline,                                \\\n+                                scan_fmt,                                 \\\n+                                &variable);                               \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  log_trace(os, container)(logstring, variable);                          \\\n+}\n+\n+\n+class CachedMetric : public CHeapObj<mtInternal>{\n+  private:\n+    volatile jlong _metric;\n+    volatile jlong _next_check_counter;\n+  public:\n+    CachedMetric() {\n+      _metric = -1;\n+      _next_check_counter = min_jlong;\n+    }\n+    bool should_check_metric() {\n+      return os::elapsed_counter() > _next_check_counter;\n+    }\n+    jlong value() { return _metric; }\n+    void set_value(jlong value, jlong timeout) {\n+      _metric = value;\n+      \/\/ Metric is unlikely to change, but we want to remain\n+      \/\/ responsive to configuration changes. A very short grace time\n+      \/\/ between re-read avoids excessive overhead during startup without\n+      \/\/ significantly reducing the VMs ability to promptly react to changed\n+      \/\/ metric config\n+      _next_check_counter = os::elapsed_counter() + timeout;\n+    }\n+};\n+\n+class CachingCgroupController : public CHeapObj<mtInternal> {\n+  private:\n+    CgroupController* _controller;\n+    CachedMetric* _metrics_cache;\n+\n+  public:\n+    CachingCgroupController(CgroupController* cont) {\n+      _controller = cont;\n+      _metrics_cache = new CachedMetric();\n+    }\n+\n+    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CgroupController* controller() { return _controller; }\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual int cpu_quota();\n+    virtual int cpu_period();\n+    virtual int cpu_shares();\n+    virtual jlong memory_usage_in_bytes();\n+    virtual jlong memory_and_swap_limit_in_bytes();\n+    virtual jlong memory_soft_limit_in_bytes();\n+    virtual jlong memory_max_usage_in_bytes();\n+    virtual char * cpu_cpuset_cpus();\n+    virtual char * cpu_cpuset_memory_nodes();\n+    virtual jlong read_memory_limit_in_bytes();\n+    virtual const char * container_type();\n+    virtual CachingCgroupController* memory_controller();\n+    virtual CachingCgroupController* cpu_controller();\n+};\n+\n+\/\/ Utility class for storing info retrieved from \/proc\/cgroups,\n+\/\/ \/proc\/self\/cgroup and \/proc\/self\/mountinfo\n+\/\/ For reference see man 7 cgroups and CgroupSubsystemFactory\n+class CgroupInfo : public StackObj {\n+  friend class CgroupSubsystemFactory;\n+  friend class WhiteBox;\n+\n+  private:\n+    char* _name;\n+    int _hierarchy_id;\n+    bool _enabled;\n+    bool _data_complete;    \/\/ indicating cgroup v1 data is complete for this controller\n+    char* _cgroup_path;     \/\/ cgroup controller path from \/proc\/self\/cgroup\n+    char* _root_mount_path; \/\/ root mount path from \/proc\/self\/mountinfo. Unused for cgroup v2\n+    char* _mount_path;      \/\/ mount path from \/proc\/self\/mountinfo.\n+\n+  public:\n+    CgroupInfo() {\n+      _name = NULL;\n+      _hierarchy_id = -1;\n+      _enabled = false;\n+      _data_complete = false;\n+      _cgroup_path = NULL;\n+      _root_mount_path = NULL;\n+      _mount_path = NULL;\n+    }\n+\n+};\n+\n+class CgroupSubsystemFactory: AllStatic {\n+  friend class WhiteBox;\n+\n+  public:\n+    static CgroupSubsystem* create();\n+  private:\n+    static inline bool is_cgroup_v2(u1* flags) {\n+       return *flags == CGROUPS_V2;\n+    }\n+\n+#ifdef ASSERT\n+    static inline bool is_valid_cgroup(u1* flags) {\n+       return *flags == CGROUPS_V1 || *flags == CGROUPS_V2;\n+    }\n+    static inline bool is_cgroup_v1(u1* flags) {\n+       return *flags == CGROUPS_V1;\n+    }\n+#endif\n+\n+    \/\/ Determine the cgroup type (version 1 or version 2), given\n+    \/\/ relevant paths to files. Sets 'flags' accordingly.\n+    static bool determine_type(CgroupInfo* cg_infos,\n+                               const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* flags);\n+    static void cleanup(CgroupInfo* cg_infos);\n+};\n+\n+#endif \/\/ CGROUP_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  if (_root != NULL && cgroup_path != NULL) {\n+    if (strcmp(_root, \"\/\") == 0) {\n+      int buflen;\n+      strncpy(buf, _mount_point, MAXPATHLEN);\n+      buf[MAXPATHLEN-1] = '\\0';\n+      if (strcmp(cgroup_path,\"\/\") != 0) {\n+        buflen = strlen(buf);\n+        if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n+          return;\n+        }\n+        strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+        buf[MAXPATHLEN-1] = '\\0';\n+      }\n+      _path = os::strdup(buf);\n+    } else {\n+      if (strcmp(_root, cgroup_path) == 0) {\n+        strncpy(buf, _mount_point, MAXPATHLEN);\n+        buf[MAXPATHLEN-1] = '\\0';\n+        _path = os::strdup(buf);\n+      } else {\n+        char *p = strstr(cgroup_path, _root);\n+        if (p != NULL && p == _root) {\n+          if (strlen(cgroup_path) > strlen(_root)) {\n+            int buflen;\n+            strncpy(buf, _mount_point, MAXPATHLEN);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            buflen = strlen(buf);\n+            if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n+              return;\n+            }\n+            strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            _path = os::strdup(buf);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/* uses_mem_hierarchy\n+ *\n+ * Return whether or not hierarchical cgroup accounting is being\n+ * done.\n+ *\n+ * return:\n+ *    A number > 0 if true, or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n+  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n+                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n+  return use_hierarchy;\n+}\n+\n+void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n+  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  jlong hierarchy = uses_mem_hierarchy();\n+  if (hierarchy > 0) {\n+    set_hierarchical(true);\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n+                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n+\n+  if (memlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memory_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  }\n+  else {\n+    return (jlong)memlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n+                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  if (memswlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memsw_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memswlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  if (memsoftlimit >= _unlimited_memory) {\n+    log_trace(os, container)(\"Memory Soft Limit is: Unlimited\");\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memsoftlimit;\n+  }\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory for this process.\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+\/* memory_max_usage_in_bytes\n+ *\n+ * Return the maximum amount of used memory for this process.\n+ *\n+ * return:\n+ *    max memory usage in bytes or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n+                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+  return memmaxusage;\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  return os::strdup(cpus);\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  return os::strdup(mems);\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_quota() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n+                     \"CPU Quota is: %d\", \"%d\", quota);\n+  return quota;\n+}\n+\n+int CgroupV1Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n+                     \"CPU Period is: %d\", \"%d\", period);\n+  return period;\n+}\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n+                     \"CPU Shares is: %d\", \"%d\", shares);\n+  \/\/ Convert 1024 to no shares setup\n+  if (shares == 1024) return -1;\n+\n+  return shares;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+\/\/ Cgroups version 1 specific implementation\n+\n+class CgroupV1Controller: public CgroupController {\n+  private:\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path;\n+\n+  public:\n+    CgroupV1Controller(char *root, char *mountpoint) {\n+      _root = os::strdup(root);\n+      _mount_point = os::strdup(mountpoint);\n+      _path = NULL;\n+    }\n+\n+    virtual void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV1MemoryController: public CgroupV1Controller {\n+\n+  public:\n+    bool is_hierarchical() { return _uses_mem_hierarchy; }\n+    void set_subsystem_path(char *cgroup_path);\n+  private:\n+    \/* Some container runtimes set limits via cgroup\n+     * hierarchy. If set to true consider also memory.stat\n+     * file if everything else seems unlimited *\/\n+    bool _uses_mem_hierarchy;\n+    jlong uses_mem_hierarchy();\n+    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+\n+  public:\n+    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+      _uses_mem_hierarchy = false;\n+    }\n+\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n+\n+  public:\n+    jlong read_memory_limit_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+\n+    int cpu_quota();\n+    int cpu_period();\n+\n+    int cpu_shares();\n+\n+    const char * container_type() {\n+      return \"cgroupv1\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+\n+  private:\n+    julong _unlimited_memory;\n+\n+    \/* controllers *\/\n+    CachingCgroupController* _memory = NULL;\n+    CgroupV1Controller* _cpuset = NULL;\n+    CachingCgroupController* _cpu = NULL;\n+    CgroupV1Controller* _cpuacct = NULL;\n+\n+  public:\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1Controller* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1MemoryController* memory) {\n+      _cpuset = cpuset;\n+      _cpu = new CachingCgroupController(cpu);\n+      _cpuacct = cpuacct;\n+      _memory = new CachingCgroupController(memory);\n+      _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n+    }\n+};\n+\n+#endif \/\/ CGROUP_V1_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n+                     \"Raw value for CPU shares is: %d\", \"%d\", shares);\n+  \/\/ Convert default value of 100 to no shares setup\n+  if (shares == 100) {\n+    log_debug(os, container)(\"CPU Shares is: %d\", -1);\n+    return -1;\n+  }\n+\n+  \/\/ CPU shares (OCI) value needs to get translated into\n+  \/\/ a proper Cgroups v2 value. See:\n+  \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+  \/\/\n+  \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+  \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+  \/\/\n+  int x = 262142 * shares - 1;\n+  double frac = x\/9999.0;\n+  x = ((int)frac) + 2;\n+  log_trace(os, container)(\"Scaled CPU shares value is: %d\", x);\n+  \/\/ Since the scaled value is not precise, return the closest\n+  \/\/ multiple of PER_CPU_SHARES for a more conservative mapping\n+  if ( x <= PER_CPU_SHARES ) {\n+     \/\/ will always map to 1 CPU\n+     log_debug(os, container)(\"CPU Shares is: %d\", x);\n+     return x;\n+  }\n+  int f = x\/PER_CPU_SHARES;\n+  int lower_multiple = f * PER_CPU_SHARES;\n+  int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+  int distance_lower = MAX2(lower_multiple, x) - MIN2(lower_multiple, x);\n+  int distance_upper = MAX2(upper_multiple, x) - MIN2(upper_multiple, x);\n+  x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+  log_trace(os, container)(\"Closest multiple of %d of the CPU Shares value is: %d\", PER_CPU_SHARES, x);\n+  log_debug(os, container)(\"CPU Shares is: %d\", x);\n+  return x;\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val();\n+  int limit = (int)limit_from_str(cpu_quota_str);\n+  log_trace(os, container)(\"CPU Quota is: %d\", limit);\n+  return limit;\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  if (cpus == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(cpus);\n+}\n+\n+char* CgroupV2Subsystem::cpu_quota_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n+                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n+  if (quota == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(quota);\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  if (mems == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mems);\n+}\n+\n+int CgroupV2Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n+                     \"CPU Period is: %d\", \"%*s %d\", period);\n+  return period;\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory used by this cgroup and decendents\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+  char* mem_soft_limit_str = mem_soft_limit_val();\n+  return limit_from_str(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+  \/\/ Log this string at trace level so as to make tests happy.\n+  log_trace(os, container)(\"Maximum Memory Usage is not supported.\");\n+  return OSCONTAINER_ERROR; \/\/ not supported\n+}\n+\n+char* CgroupV2Subsystem::mem_soft_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n+                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n+  if (mem_soft_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+  char* mem_swp_limit_str = mem_swp_limit_val();\n+  return limit_from_str(mem_swp_limit_str);\n+}\n+\n+char* CgroupV2Subsystem::mem_swp_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n+  if (mem_swp_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_swp_limit_str);\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *\/\n+jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n+  char * mem_limit_str = mem_limit_val();\n+  jlong limit = limit_from_str(mem_limit_str);\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  return limit;\n+}\n+\n+jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n+\n+char* CgroupV2Subsystem::mem_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n+  if (mem_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_limit_str);\n+}\n+\n+char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  int buflen;\n+  strncpy(buf, mount_path, MAXPATHLEN);\n+  buf[MAXPATHLEN] = '\\0';\n+  buflen = strlen(buf);\n+  if ((buflen + strlen(cgroup_path)) > MAXPATHLEN) {\n+    return NULL;\n+  }\n+  strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+  buf[MAXPATHLEN] = '\\0';\n+  return os::strdup(buf);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupV2Controller: public CgroupController {\n+  private:\n+    \/* the mount path of the cgroup v2 hierarchy *\/\n+    char *_mount_path;\n+    \/* The cgroup path for the controller *\/\n+    char *_cgroup_path;\n+\n+    \/* Constructed full path to the subsystem directory *\/\n+    char *_path;\n+    static char* construct_path(char* mount_path, char *cgroup_path);\n+\n+  public:\n+    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n+      _mount_path = mount_path;\n+      _cgroup_path = os::strdup(cgroup_path);\n+      _path = construct_path(mount_path, cgroup_path);\n+    }\n+\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV2Subsystem: public CgroupSubsystem {\n+  private:\n+    \/* One unified controller *\/\n+    CgroupController* _unified = NULL;\n+    \/* Caching wrappers for cpu\/memory metrics *\/\n+    CachingCgroupController* _memory = NULL;\n+    CachingCgroupController* _cpu = NULL;\n+\n+    char *mem_limit_val();\n+    char *mem_swp_limit_val();\n+    char *mem_soft_limit_val();\n+    char *cpu_quota_val();\n+    jlong limit_from_str(char* limit_str);\n+\n+  public:\n+    CgroupV2Subsystem(CgroupController * unified) {\n+      _unified = unified;\n+      _memory = new CachingCgroupController(unified);\n+      _cpu = new CachingCgroupController(unified);\n+    }\n+\n+    jlong read_memory_limit_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+    const char * container_type() {\n+      return \"cgroupv2\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+};\n+\n+#endif \/\/ CGROUP_V2_SUBSYSTEM_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -34,1 +34,0 @@\n-#define PER_CPU_SHARES 1024\n@@ -38,240 +37,1 @@\n-int   OSContainer::_active_processor_count = 1;\n-julong _unlimited_memory;\n-\n-class CgroupSubsystem: CHeapObj<mtInternal> {\n- friend class OSContainer;\n-\n-\n- private:\n-    volatile jlong _next_check_counter;\n-\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n- public:\n-    CgroupSubsystem(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = NULL;\n-      _next_check_counter = min_jlong;\n-    }\n-\n-    \/*\n-     * Set directory to subsystem specific files based\n-     * on the contents of the mountinfo and cgroup files.\n-     *\/\n-    void set_subsystem_path(char *cgroup_path) {\n-      char buf[MAXPATHLEN+1];\n-      if (_root != NULL && cgroup_path != NULL) {\n-        if (strcmp(_root, \"\/\") == 0) {\n-          int buflen;\n-          strncpy(buf, _mount_point, MAXPATHLEN);\n-          buf[MAXPATHLEN-1] = '\\0';\n-          if (strcmp(cgroup_path,\"\/\") != 0) {\n-            buflen = strlen(buf);\n-            if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n-              return;\n-            }\n-            strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n-            buf[MAXPATHLEN-1] = '\\0';\n-          }\n-          _path = os::strdup(buf);\n-        } else {\n-          if (strcmp(_root, cgroup_path) == 0) {\n-            strncpy(buf, _mount_point, MAXPATHLEN);\n-            buf[MAXPATHLEN-1] = '\\0';\n-            _path = os::strdup(buf);\n-          } else {\n-            char *p = strstr(cgroup_path, _root);\n-            if (p != NULL && p == _root) {\n-              if (strlen(cgroup_path) > strlen(_root)) {\n-                int buflen;\n-                strncpy(buf, _mount_point, MAXPATHLEN);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                buflen = strlen(buf);\n-                if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n-                  return;\n-                }\n-                strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                _path = os::strdup(buf);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    char *subsystem_path() { return _path; }\n-\n-    bool cache_has_expired() {\n-      return os::elapsed_counter() > _next_check_counter;\n-    }\n-\n-    void set_cache_expiry_time(jlong timeout) {\n-      _next_check_counter = os::elapsed_counter() + timeout;\n-    }\n-};\n-\n-class CgroupMemorySubsystem: CgroupSubsystem {\n- friend class OSContainer;\n-\n- private:\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    volatile jlong _memory_limit_in_bytes;\n-\n- public:\n-    CgroupMemorySubsystem(char *root, char *mountpoint) : CgroupSubsystem::CgroupSubsystem(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-      _memory_limit_in_bytes = -1;\n-\n-    }\n-\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n-\n-    jlong memory_limit_in_bytes() { return _memory_limit_in_bytes; }\n-    void set_memory_limit_in_bytes(jlong value) {\n-      _memory_limit_in_bytes = value;\n-      \/\/ max memory limit is unlikely to change, but we want to remain\n-      \/\/ responsive to configuration changes. A very short grace time\n-      \/\/ between re-read avoids excessive overhead during startup without\n-      \/\/ significantly reducing the VMs ability to promptly react to reduced\n-      \/\/ memory availability\n-      set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-    }\n-\n-};\n-\n-CgroupMemorySubsystem* memory = NULL;\n-CgroupSubsystem* cpuset = NULL;\n-CgroupSubsystem* cpu = NULL;\n-CgroupSubsystem* cpuacct = NULL;\n-\n-typedef char * cptr;\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int subsystem_file_line_contents(CgroupSubsystem* c,\n-                                              const char *filename,\n-                                              const char *matchline,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n-\n-  if (c == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupSubsytem* is NULL\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n-  fp = fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n-        }\n-      }\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n-      }\n-    }\n-    if (err == 0) {\n-      log_debug(os, container)(\"Empty file %s\", file);\n-    }\n-  } else {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n-  }\n-  if (fp != NULL)\n-    fclose(fp);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, scan_fmt, variable)                 \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n-\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) NULL;                                            \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n-\n-#define GET_CONTAINER_INFO_LINE(return_type, subsystem, filename,         \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+CgroupSubsystem* cgroup_subsystem;\n@@ -285,6 +45,0 @@\n-  FILE *mntinfo = NULL;\n-  FILE *cgroup = NULL;\n-  char buf[MAXPATHLEN+1];\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n-  char *p;\n@@ -298,2 +52,0 @@\n-  _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n-\n@@ -306,118 +58,3 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      log_debug(os, container)(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                               os::strerror(errno));\n-      return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupMemorySubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupSubsystem(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n-    log_debug(os, container)(\"Required cgroup memory subsystem not found\");\n-    return;\n-  }\n-  if (cpuset == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpuset subsystem not found\");\n-    return;\n-  }\n-  if (cpu == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpu subsystem not found\");\n-    return;\n-  }\n-  if (cpuacct == NULL) {\n-    log_debug(os, container)(\"Required cgroup cpuacct subsystem not found\");\n-    return;\n-  }\n-\n-  \/*\n-   * Read \/proc\/self\/cgroup and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n-  if (cgroup == NULL) {\n-    log_debug(os, container)(\"Can't open \/proc\/self\/cgroup, %s\",\n-                             os::strerror(errno));\n-    return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n-    char *controllers;\n-    char *token;\n-    char *base;\n-\n-    \/* Skip cgroup number *\/\n-    strsep(&p, \":\");\n-    \/* Get controllers and base *\/\n-    controllers = strsep(&p, \":\");\n-    base = strsep(&p, \"\\n\");\n-\n-    if (controllers == NULL) {\n-      continue;\n-    }\n-\n-    while ((token = strsep(&controllers, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory->set_subsystem_path(base);\n-        jlong hierarchy = uses_mem_hierarchy();\n-        if (hierarchy > 0) {\n-          memory->set_hierarchical(true);\n-        }\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct->set_subsystem_path(base);\n-      }\n-    }\n+  cgroup_subsystem = CgroupSubsystemFactory::create();\n+  if (cgroup_subsystem == NULL) {\n+    return; \/\/ Required subsystem files not found or other error\n@@ -425,3 +62,0 @@\n-\n-  fclose(cgroup);\n-\n@@ -429,2 +63,2 @@\n-  \/\/ command line arguments have been processed.\n-  if ((mem_limit = memory_limit_in_bytes()) > 0) {\n+  \/\/ cgroup subsystem files have been processed.\n+  if ((mem_limit = cgroup_subsystem->memory_limit_in_bytes()) > 0) {\n@@ -440,5 +74,2 @@\n-  if (is_containerized()) {\n-    return \"cgroupv1\";\n-  } else {\n-    return NULL;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->container_type();\n@@ -447,25 +78,0 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong OSContainer::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n-}\n-\n-\n-\/* memory_limit_in_bytes\n- *\n- * Return the limit of available memory for this process.\n- *\n- * return:\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -473,31 +79,2 @@\n-  if (!memory->cache_has_expired()) {\n-    return memory->memory_limit_in_bytes();\n-  }\n-  jlong memory_limit = read_memory_limit_in_bytes();\n-  \/\/ Update CgroupMemorySubsystem to avoid re-reading container settings too often\n-  memory->set_memory_limit_in_bytes(memory_limit);\n-  return memory_limit;\n-}\n-\n-jlong OSContainer::read_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  }\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_limit_in_bytes();\n@@ -507,19 +84,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  if (memswlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n@@ -529,8 +89,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= _unlimited_memory) {\n-    log_trace(os, container)(\"Memory Soft Limit is: Unlimited\");\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memsoftlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_soft_limit_in_bytes();\n@@ -549,3 +103,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_usage_in_bytes();\n@@ -554,8 +107,0 @@\n-\/* memory_max_usage_in_bytes\n- *\n- * Return the maximum amount of used memory for this process.\n- *\n- * return:\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -563,92 +108,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n-}\n-\n-\/* active_processor_count\n- *\n- * Calculate an appropriate number of active processors for the\n- * VM to use based on these three inputs.\n- *\n- * cpu affinity\n- * cgroup cpu quota & cpu period\n- * cgroup cpu shares\n- *\n- * Algorithm:\n- *\n- * Determine the number of available CPUs from sched_getaffinity\n- *\n- * If user specified a quota (quota != -1), calculate the number of\n- * required CPUs by dividing quota by period.\n- *\n- * If shares are in effect (shares != -1), calculate the number\n- * of CPUs required for the shares by dividing the share value\n- * by PER_CPU_SHARES.\n- *\n- * All results of division are rounded up to the next whole number.\n- *\n- * If neither shares or quotas have been specified, return the\n- * number of active processors in the system.\n- *\n- * If both shares and quotas have been specified, the results are\n- * based on the flag PreferContainerQuotaForCPUCount.  If true,\n- * return the quota value.  If false return the smallest value\n- * between shares or quotas.\n- *\n- * If shares and\/or quotas have been specified, the resulting number\n- * returned will never exceed the number of active processors.\n- *\n- * return:\n- *    number of CPUs\n- *\/\n-int OSContainer::active_processor_count() {\n-  int quota_count = 0, share_count = 0;\n-  int cpu_count, limit_count;\n-  int result;\n-\n-  \/\/ We use a cache with a timeout to avoid performing expensive\n-  \/\/ computations in the event this function is called frequently.\n-  \/\/ [See 8227006].\n-  if (!cpu->cache_has_expired()) {\n-    log_trace(os, container)(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n-    return OSContainer::_active_processor_count;\n-  }\n-\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-  int share  = cpu_shares();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-  if (share > -1) {\n-    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n-    log_trace(os, container)(\"CPU Share count based on shares: %d\", share_count);\n-  }\n-\n-  \/\/ If both shares and quotas are setup results depend\n-  \/\/ on flag PreferContainerQuotaForCPUCount.\n-  \/\/ If true, limit CPU count to quota\n-  \/\/ If false, use minimum of shares and quotas\n-  if (quota_count !=0 && share_count != 0) {\n-    if (PreferContainerQuotaForCPUCount) {\n-      limit_count = quota_count;\n-    } else {\n-      limit_count = MIN2(quota_count, share_count);\n-    }\n-  } else if (quota_count != 0) {\n-    limit_count = quota_count;\n-  } else if (share_count != 0) {\n-    limit_count = share_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n-  \/\/ Update the value and reset the cache timeout\n-  OSContainer::_active_processor_count = result;\n-  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-\n-  return result;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_max_usage_in_bytes();\n@@ -658,3 +113,2 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_cpus();\n@@ -664,3 +118,7 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_memory_nodes();\n+}\n+\n+int OSContainer::active_processor_count() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->active_processor_count();\n@@ -669,10 +127,0 @@\n-\/* cpu_quota\n- *\n- * Return the number of milliseconds per period\n- * process is guaranteed to run.\n- *\n- * return:\n- *    quota time in milliseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -680,3 +128,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: %d\", \"%d\", quota);\n-  return quota;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_quota();\n@@ -686,3 +133,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: %d\", \"%d\", period);\n-  return period;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_period();\n@@ -691,10 +137,0 @@\n-\/* cpu_shares\n- *\n- * Return the amount of cpu shares available to the process\n- *\n- * return:\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -702,6 +138,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.shares\",\n-                     \"CPU Shares is: %d\", \"%d\", shares);\n-  \/\/ Convert 1024 to no shares setup\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_shares();\n@@ -709,1 +141,0 @@\n-\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":36,"deletions":605,"binary":false,"changes":641,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-  static jlong uses_mem_hierarchy();\n@@ -71,1 +70,0 @@\n-  assert(_is_initialized, \"OSContainer not initialized\");\n@@ -75,1 +73,1 @@\n-#endif \/\/ OS_LINUX_VM_OSCONTAINER_LINUX_HPP\n+#endif \/\/ OS_LINUX_OSCONTAINER_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+  friend class CgroupSubsystem;\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -888,0 +889,12 @@\n+#ifdef LINUX\n+bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* cg_flags) {\n+  CgroupInfo cg_infos[4];\n+  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+                                                    proc_self_cgroup,\n+                                                    proc_self_mountinfo, cg_flags);\n+}\n+#endif\n+\n@@ -2012,0 +2025,25 @@\n+WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,\n+                                    jobject o,\n+                                    jstring proc_cgroups,\n+                                    jstring proc_self_cgroup,\n+                                    jstring proc_self_mountinfo))\n+  jint ret = 0;\n+#ifdef LINUX\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  u1 cg_type_flags = 0;\n+  \/\/ This sets cg_type_flags\n+  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  ret = (jint)cg_type_flags;\n+  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);\n+  env->ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);\n+#endif\n+  return ret;\n+WB_END\n+\n@@ -2256,0 +2294,3 @@\n+  {CC\"validateCgroup\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_ValidateCgroup },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+#ifdef LINUX\n+  static bool validate_cgroup(const char* proc_cgroups, const char* proc_self_cgroup, const char* proc_self_mountinfo, u1* cg_flags);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/whitebox.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Data structure to hold info from \/proc\/self\/cgroup\n+ *\n+ * man 7 cgroups\n+ *\n+ * @see CgroupSubsystemFactory\n+ *\/\n+class CgroupInfo {\n+\n+    private final String name;\n+    private final int hierarchyId;\n+    private final boolean enabled;\n+\n+    private CgroupInfo(String name, int hierarchyId, boolean enabled) {\n+        this.name = name;\n+        this.hierarchyId = hierarchyId;\n+        this.enabled = enabled;\n+    }\n+\n+    String getName() {\n+        return name;\n+    }\n+\n+    int getHierarchyId() {\n+        return hierarchyId;\n+    }\n+\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    static CgroupInfo fromCgroupsLine(String line) {\n+        String[] tokens = line.split(\"\\\\s+\");\n+        if (tokens.length != 4) {\n+            return null;\n+        }\n+        \/\/ discard 3'rd field, num_cgroups\n+        return new CgroupInfo(tokens[0] \/* name *\/,\n+                              Integer.parseInt(tokens[1]) \/* hierarchyId *\/,\n+                              (Integer.parseInt(tokens[3]) == 1) \/* enabled *\/);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.util.Objects;\n+\n+public class CgroupMetrics implements Metrics {\n+\n+    private final CgroupSubsystem subsystem;\n+\n+    CgroupMetrics(CgroupSubsystem subsystem) {\n+        this.subsystem = Objects.requireNonNull(subsystem);\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return subsystem.getProvider();\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        return subsystem.getCpuUsage();\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return subsystem.getPerCpuUsage();\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        return subsystem.getCpuUserUsage();\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        return subsystem.getCpuSystemUsage();\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return subsystem.getCpuPeriod();\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return subsystem.getCpuQuota();\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        return subsystem.getCpuShares();\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return subsystem.getCpuNumPeriods();\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return subsystem.getCpuNumThrottled();\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return subsystem.getCpuThrottledTime();\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return subsystem.getEffectiveCpuCount();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        return subsystem.getCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        return subsystem.getEffectiveCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        return subsystem.getCpuSetMems();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        return subsystem.getEffectiveCpuSetMems();\n+    }\n+\n+    public long getMemoryFailCount() {\n+        return subsystem.getMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        return subsystem.getMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return subsystem.getMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return subsystem.getTcpMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        return subsystem.getMemoryAndSwapLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return subsystem.getMemoryAndSwapUsage();\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        return subsystem.getMemorySoftLimit();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return subsystem.getBlkIOServiceCount();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return subsystem.getBlkIOServiced();\n+    }\n+\n+    public static Metrics getInstance() {\n+        if (!isUseContainerSupport()) {\n+            \/\/ Return null on -XX:-UseContainerSupport\n+            return null;\n+        }\n+        return CgroupSubsystemFactory.create();\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Marker interface for cgroup-based metrics\n+ *\n+ *\/\n+public interface CgroupSubsystem extends Metrics {\n+\n+    \/**\n+     * Returned for metrics of type long if the underlying implementation\n+     * has determined that no limit is being imposed.\n+     *\/\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Cgroup version agnostic controller logic\n+ *\n+ *\/\n+public interface CgroupSubsystemController {\n+\n+    public static final String EMPTY_STR = \"\";\n+\n+    public String path();\n+\n+    \/**\n+     * getStringValue\n+     *\n+     * Return the first line of the file \"param\" argument from the controller.\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @return Returns the contents of the file specified by param or null if\n+     *         an error occurs.\n+     *\/\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        if (controller == null) return null;\n+\n+        try {\n+            return CgroupUtil.readStringValue(controller, param);\n+        }\n+        catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Get an entry from file \"param\" within the \"controller\" directory path\n+     * which matches string \"match\". Applies \"conversion\" to the matching line.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param match\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The long value as derived by applying \"conversion\" to the matching\n+     *         line or \"defaultRetval\" if there was an error or no match found.\n+     *\/\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                     String param,\n+                                                     String match,\n+                                                     Function<String, Long> conversion,\n+                                                     long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (controller == null) {\n+            return retval;\n+        }\n+        try {\n+            Path filePath = Paths.get(controller.path(), param);\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            for (String line : lines) {\n+                if (line.startsWith(match)) {\n+                    retval = conversion.apply(line);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore. Default is unlimited.\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * Get a long value from directory \"controller\" and file \"param\", by\n+     * applying \"conversion\" to the string value within the file.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The converted long value or \"defaultRetval\" if there was an\n+     *         error.\n+     *\/\n+    public static long getLongValue(CgroupSubsystemController controller,\n+                                    String param,\n+                                    Function<String, Long> conversion,\n+                                    long defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+        if (strval == null) return defaultRetval;\n+        return conversion.apply(strval);\n+    }\n+\n+    \/**\n+     * Get a double value from file \"param\" within \"controller\".\n+     *\n+     * @param controller\n+     * @param param\n+     * @param defaultRetval\n+     * @return The double value or \"defaultRetval\" if there was an error.\n+     *\/\n+    public static double getDoubleValue(CgroupSubsystemController controller, String param, double defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+\n+        if (strval == null) return defaultRetval;\n+\n+        double retval = Double.parseDouble(strval);\n+\n+        return retval;\n+    }\n+\n+    \/**\n+     * getLongEntry\n+     *\n+     * Return the long value from the line containing the string \"entryname\"\n+     * within file \"param\" in the \"controller\".\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param entryname\n+     * @return long value or \"defaultRetval\" if there was an error or no match\n+     *         was found.\n+     *\/\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname, long defaultRetval) {\n+        if (controller == null) return defaultRetval;\n+\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+\n+            Optional<String> result = lines.map(line -> line.split(\" \"))\n+                                           .filter(line -> (line.length == 2 &&\n+                                                   line[0].equals(entryname)))\n+                                           .map(line -> line[1])\n+                                           .findFirst();\n+\n+            return result.isPresent() ? Long.parseLong(result.get()) : defaultRetval;\n+        }\n+        catch (IOException e) {\n+            return defaultRetval;\n+        }\n+    }\n+\n+    \/**\n+     * stringRangeToIntArray\n+     *\n+     * Convert a string in the form of  1,3-4,6 to an array of\n+     * integers containing all the numbers in the range.\n+     *\n+     * @param range\n+     * @return int[] containing a sorted list of numbers as represented by\n+     *         the string range. Returns null if there was an error or the input\n+     *         was an empty string.\n+     *\/\n+    public static int[] stringRangeToIntArray(String range) {\n+        if (range == null || EMPTY_STR.equals(range)) return null;\n+\n+        ArrayList<Integer> results = new ArrayList<>();\n+        String strs[] = range.split(\",\");\n+        for (String str : strs) {\n+            if (str.contains(\"-\")) {\n+                String lohi[] = str.split(\"-\");\n+                \/\/ validate format\n+                if (lohi.length != 2) {\n+                    continue;\n+                }\n+                int lo = Integer.parseInt(lohi[0]);\n+                int hi = Integer.parseInt(lohi[1]);\n+                for (int i = lo; i <= hi; i++) {\n+                    results.add(i);\n+                }\n+            }\n+            else {\n+                results.add(Integer.parseInt(str));\n+            }\n+        }\n+\n+        \/\/ sort results\n+        results.sort(null);\n+\n+        \/\/ convert ArrayList to primitive int array\n+        int[] ints = new int[results.size()];\n+        int i = 0;\n+        for (Integer n : results) {\n+            ints[i++] = n;\n+        }\n+\n+        return ints;\n+    }\n+\n+    \/**\n+     * Convert a number from its string representation to a long.\n+     *\n+     * @param strval\n+     * @param overflowRetval\n+     * @param defaultRetval\n+     * @return The converted long value. \"overflowRetval\" is returned if the\n+     *         string representation exceeds the range of type long.\n+     *         \"defaultRetval\" is returned if another type of error occurred\n+     *         during conversion.\n+     *\/\n+    public static long convertStringToLong(String strval, long overflowRetval, long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes, cgroups v1) we may overflow\n+            \/\/ the range of signed long. In this case, return overflowRetval\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.lang.System.Logger;\n+import java.lang.System.Logger.Level;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.cgroupv2.CgroupV2Subsystem;\n+\n+class CgroupSubsystemFactory {\n+\n+    private static final String CPU_CTRL = \"cpu\";\n+    private static final String CPUACCT_CTRL = \"cpuacct\";\n+    private static final String CPUSET_CTRL = \"cpuset\";\n+    private static final String BLKIO_CTRL = \"blkio\";\n+    private static final String MEMORY_CTRL = \"memory\";\n+\n+    static CgroupMetrics create() {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n+            for (String line : lines) {\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                }\n+                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+                switch (info.getName()) {\n+                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If no controller is enabled, return no metrics.\n+        if (!anyControllersEnabled) {\n+            return null;\n+        }\n+        \/\/ Warn about mixed cgroups v1 and cgroups v2 controllers. The code is\n+        \/\/ not ready to deal with that on a per-controller basis. Return no metrics\n+        \/\/ in that case\n+        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+            Logger logger = System.getLogger(\"jdk.internal.platform\");\n+            logger.log(Level.DEBUG, \"Mixed cgroupv1 and cgroupv2 not supported. Metrics disabled.\");\n+            return null;\n+        }\n+\n+        if (isCgroupsV2) {\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            return subsystem != null ? new CgroupMetrics(subsystem) : null;\n+        } else {\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            return subsystem != null ? new CgroupV1MetricsImpl(subsystem) : null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public final class CgroupUtil {\n+\n+    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n+\n+    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(controller.path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n+    }\n+\n+    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ *\n+ * Cgroup v1 extensions to the Metrics interface. Linux, only.\n+ *\n+ *\/\n+public interface CgroupV1Metrics extends Metrics {\n+\n+    \/**\n+     * Returns the largest amount of physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available. Returns -2 if this metric is not\n+     *         supported.\n+     *\n+     *\/\n+    public long getMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that kernel memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of kernel physical memory, in bytes, that\n+     * can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set.\n+     *\n+     *\/\n+    public long getKernelMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of kernel physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the amount of kernel physical memory, in bytes, that\n+     * is currently allocated in the current Isolation Group.\n+     *\n+     * @return The amount of memory in bytes allocated or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryUsage();\n+\n+    \/**\n+     * Returns the number of times that networking memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of networking physical memory, in bytes,\n+     * that can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit.\n+     *\n+     *\/\n+    public long getTcpMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of networking physical memory, in bytes,\n+     * that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that user memory requests in the\n+     * Isolation Group have exceeded the memory + swap limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapFailCount();\n+\n+    \/**\n+     * Returns the largest amount of physical memory and swap space,\n+     * in bytes, that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapMaxUsage();\n+\n+    \/**\n+     * Returns the state of the Operating System Out of Memory termination\n+     * policy.\n+     *\n+     * @return Returns true if operating system will terminate processes\n+     *         in the Isolation Group that exceed the amount of available\n+     *         memory, otherwise false. null will be returned if this\n+     *         capability is not available on the current operating system.\n+     *\n+     *\/\n+    public Boolean isMemoryOOMKillEnabled();\n+\n+    \/**\n+     * Returns the (attempts per second * 1000), if enabled, that the\n+     * operating system tries to satisfy a memory request for any\n+     * process in the current Isolation Group when no free memory is\n+     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n+     * determine if this support is enabled.\n+     *\n+     * @return Memory pressure or 0 if not enabled or -1 if metric is not\n+     *         available.\n+     *\n+     *\/\n+    public double getCpuSetMemoryPressure();\n+\n+    \/**\n+     * Returns the state of the memory pressure detection support.\n+     *\n+     * @return true if support is available and enabled. false otherwise.\n+     *\n+     *\/\n+    public Boolean isCpuSetMemoryPressureEnabled();\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1Metrics.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Cgroup v1 Metrics extensions\n+ *\n+ *\/\n+public class CgroupV1MetricsImpl extends CgroupMetrics implements CgroupV1Metrics {\n+\n+    private final CgroupV1Metrics metrics;\n+\n+    CgroupV1MetricsImpl(CgroupV1Metrics metrics) {\n+        super((CgroupSubsystem)metrics);\n+        this.metrics = metrics;\n+    }\n+\n+    @Override\n+    public long getMemoryMaxUsage() {\n+        return metrics.getMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return metrics.getKernelMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryLimit() {\n+        return metrics.getKernelMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return metrics.getKernelMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return metrics.getKernelMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return metrics.getTcpMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryLimit() {\n+        return metrics.getTcpMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return metrics.getTcpMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return metrics.getMemoryAndSwapFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return metrics.getMemoryAndSwapMaxUsage();\n+    }\n+\n+    @Override\n+    public Boolean isMemoryOOMKillEnabled() {\n+        return metrics.isMemoryOOMKillEnabled();\n+    }\n+\n+    @Override\n+    public double getCpuSetMemoryPressure() {\n+        return metrics.getCpuSetMemoryPressure();\n+    }\n+\n+    @Override\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        return metrics.isCpuSetMemoryPressureEnabled();\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1MetricsImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+\n+    private boolean hierarchical;\n+\n+    public CgroupV1MemorySubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,490 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class CgroupV1Subsystem implements CgroupSubsystem, CgroupV1Metrics {\n+    private CgroupV1MemorySubSystemController memory;\n+    private CgroupV1SubsystemController cpu;\n+    private CgroupV1SubsystemController cpuacct;\n+    private CgroupV1SubsystemController cpuset;\n+    private CgroupV1SubsystemController blkio;\n+    private boolean activeSubSystems;\n+\n+    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+\n+    private static final String PROVIDER_NAME = \"cgroupv1\";\n+\n+    private CgroupV1Subsystem() {\n+        activeSubSystems = false;\n+    }\n+\n+    public static CgroupV1Subsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private static CgroupV1Subsystem initSubSystem() {\n+        CgroupV1Subsystem subsystem = new CgroupV1Subsystem();\n+\n+        \/**\n+         * Find the cgroup mount points for subsystems\n+         * by reading \/proc\/self\/mountinfo\n+         *\n+         * Example for docker MemorySubSystem subsystem:\n+         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n+         *\n+         * Example for host:\n+         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            lines.filter(line -> line.contains(\" - cgroup \"))\n+                 .map(line -> line.split(\" \"))\n+                 .forEach(entry -> createSubSystemController(subsystem, entry));\n+\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/**\n+         * Read \/proc\/self\/cgroup and map host mount point to\n+         * local one via \/proc\/self\/mountinfo content above\n+         *\n+         * Docker example:\n+         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+         *\n+         * Host example:\n+         * 5:memory:\/user.slice\n+         *\n+         * Construct a path to the process specific memory and cpuset\n+         * cgroup directory.\n+         *\n+         * For a container running under Docker from memory example above\n+         * the paths would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\n+         *\n+         * For a Host from memory example above the path would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\/user.slice\n+         *\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+\n+            lines.map(line -> line.split(\":\"))\n+                 .filter(line -> (line.length >= 3))\n+                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n+\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ Return Metrics object if we found any subsystems.\n+        if (subsystem.activeSubSystems()) {\n+            return subsystem;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * createSubSystem objects and initialize mount points\n+     *\/\n+    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n+        if (mountentry.length < 5) return;\n+\n+        Path p = Paths.get(mountentry[4]);\n+        String[] subsystemNames = p.getFileName().toString().split(\",\");\n+\n+        for (String subsystemName: subsystemNames) {\n+            switch (subsystemName) {\n+                case \"memory\":\n+                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuset\":\n+                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuacct\":\n+                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpu\":\n+                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"blkio\":\n+                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                default:\n+                    \/\/ Ignore subsystems that we don't support\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n+     *\/\n+    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n+        String controllerName;\n+        String base;\n+        CgroupV1SubsystemController controller = null;\n+        CgroupV1SubsystemController controller2 = null;\n+\n+        controllerName = entry[1];\n+        base = entry[2];\n+        if (controllerName != null && base != null) {\n+            switch (controllerName) {\n+                case \"memory\":\n+                    controller = subsystem.memoryController();\n+                    break;\n+                case \"cpuset\":\n+                    controller = subsystem.cpuSetController();\n+                    break;\n+                case \"cpu,cpuacct\":\n+                case \"cpuacct,cpu\":\n+                    controller = subsystem.cpuController();\n+                    controller2 = subsystem.cpuAcctController();\n+                    break;\n+                case \"cpuacct\":\n+                    controller = subsystem.cpuAcctController();\n+                    break;\n+                case \"cpu\":\n+                    controller = subsystem.cpuController();\n+                    break;\n+                case \"blkio\":\n+                    controller = subsystem.blkIOController();\n+                    break;\n+                \/\/ Ignore subsystems that we don't support\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        if (controller != null) {\n+            controller.setPath(base);\n+            if (controller instanceof CgroupV1MemorySubSystemController) {\n+                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n+                boolean isHierarchial = getHierarchical(memorySubSystem);\n+                memorySubSystem.setHierarchical(isHierarchial);\n+            }\n+            subsystem.setActiveSubSystems();\n+        }\n+        if (controller2 != null) {\n+            controller2.setPath(base);\n+        }\n+    }\n+\n+\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n+    private void setActiveSubSystems() {\n+        activeSubSystems = true;\n+    }\n+\n+    private boolean activeSubSystems() {\n+        return activeSubSystems;\n+    }\n+\n+    private void setMemorySubSystem(CgroupV1MemorySubSystemController memory) {\n+        this.memory = memory;\n+    }\n+\n+    private void setCpuController(CgroupV1SubsystemController cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    private void setCpuAcctController(CgroupV1SubsystemController cpuacct) {\n+        this.cpuacct = cpuacct;\n+    }\n+\n+    private void setCpuSetController(CgroupV1SubsystemController cpuset) {\n+        this.cpuset = cpuset;\n+    }\n+\n+    private void setBlkIOController(CgroupV1SubsystemController blkio) {\n+        this.blkio = blkio;\n+    }\n+\n+    private CgroupV1SubsystemController memoryController() {\n+        return memory;\n+    }\n+\n+    private CgroupV1SubsystemController cpuController() {\n+        return cpu;\n+    }\n+\n+    private CgroupV1SubsystemController cpuAcctController() {\n+        return cpuacct;\n+    }\n+\n+    private CgroupV1SubsystemController cpuSetController() {\n+        return cpuset;\n+    }\n+\n+    private CgroupV1SubsystemController blkIOController() {\n+        return blkio;\n+    }\n+\n+    private static long getLongValue(CgroupSubsystemController controller,\n+                              String parm) {\n+        return CgroupSubsystemController.getLongValue(controller,\n+                                                      parm,\n+                                                      CgroupV1SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    \/*****************************************************************\n+     * CPU Accounting Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuUsage() {\n+        return getLongValue(cpuacct, \"cpuacct.usage\");\n+    }\n+\n+    public long[] getPerCpuUsage() {\n+        String usagelist = CgroupSubsystemController.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n+        if (usagelist == null) {\n+            return null;\n+        }\n+\n+        String list[] = usagelist.split(\" \");\n+        long percpu[] = new long[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            percpu[i] = Long.parseLong(list[i]);\n+        }\n+        return percpu;\n+    }\n+\n+    public long getCpuUserUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPU Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuPeriod() {\n+        return getLongValue(cpu, \"cpu.cfs_period_us\");\n+    }\n+\n+    public long getCpuQuota() {\n+        return getLongValue(cpu, \"cpu.cfs_quota_us\");\n+    }\n+\n+    public long getCpuShares() {\n+        long retval = getLongValue(cpu, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024)\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        else\n+            return retval;\n+    }\n+\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPUSet Subsystem\n+     ****************************************************************\/\n+\n+    public int[] getCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.cpus\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n+    }\n+\n+    public int[] getCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.mems\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_mems\"));\n+    }\n+\n+    public double getCpuSetMemoryPressure() {\n+        return CgroupV1SubsystemController.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n+    }\n+\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        long val = getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n+        return (val == 1);\n+    }\n+\n+\n+    \/*****************************************************************\n+     * Memory Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getMemoryFailCount() {\n+        return getLongValue(memory, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryLimit() {\n+        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryUsage() {\n+        return getLongValue(memory, \"memory.usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.limit_in_bytes\"));\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\"));\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getMemoryAndSwapLimit() {\n+        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapUsage() {\n+        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n+    }\n+\n+    public long getMemorySoftLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+    }\n+\n+\n+    \/*****************************************************************\n+     * BlKIO Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getBlkIOServiceCount() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n+    }\n+\n+    public long getBlkIOServiced() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":490,"deletions":0,"binary":false,"changes":490,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n+\n+    public CgroupV1SubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static double getDoubleValue(CgroupSubsystemController controller, String parm) {\n+        return CgroupSubsystemController.getDoubleValue(controller,\n+                                                        parm,\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             Long.MAX_VALUE \/* overflow value *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long longValOrUnlimited(long value) {\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+    }\n+\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                String param,\n+                                                String match) {\n+        return CgroupSubsystemController.getLongValueMatchingLine(controller,\n+                                                                  param,\n+                                                                  match,\n+                                                                  CgroupV1SubsystemController::convertHierachicalLimitLine,\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public static long convertHierachicalLimitLine(String line) {\n+        String[] tokens = line.split(\"\\\\s\");\n+        if (tokens.length == 2) {\n+            String strVal = tokens[1];\n+            return CgroupV1SubsystemController.convertStringToLong(strVal);\n+        }\n+        return CgroupV1SubsystemController.UNLIMITED_MIN + 1; \/\/ unlimited\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,545 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.platform.cgroupv1.SubSystem.MemorySubSystem;\n-\n-public class Metrics implements jdk.internal.platform.Metrics {\n-    private MemorySubSystem memory;\n-    private SubSystem cpu;\n-    private SubSystem cpuacct;\n-    private SubSystem cpuset;\n-    private SubSystem blkio;\n-    private boolean activeSubSystems;\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-\n-    private static final Metrics INSTANCE = initContainerSubSystems();\n-\n-    private static final String PROVIDER_NAME = \"cgroupv1\";\n-\n-    private Metrics() {\n-        activeSubSystems = false;\n-    }\n-\n-    public static Metrics getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private static Metrics initContainerSubSystems() {\n-        if (!isUseContainerSupport()) {\n-            return null;\n-        }\n-        Metrics metrics = new Metrics();\n-\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystem(metrics, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemPath(metrics, line));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/\/ Return Metrics object if we found any subsystems.\n-        if (metrics.activeSubSystems()) {\n-            return metrics;\n-        }\n-\n-        return null;\n-    }\n-\n-    static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystem(Metrics metric, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    metric.setMemorySubSystem(new MemorySubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    metric.setCpuSetSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    metric.setCpuAcctSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    metric.setCpuSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    metric.setBlkIOSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemPath(Metrics metric, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(metric, metric.MemorySubSystem(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(metric, metric.CpuSetSubSystem(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(metric, metric.CpuAcctSubSystem(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(metric, metric.CpuSubSystem(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(metric, metric.BlkIOSubSystem(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(Metrics metric, SubSystem subsystem, String base) {\n-        if (subsystem != null) {\n-            subsystem.setPath(base);\n-            if (subsystem instanceof MemorySubSystem) {\n-                MemorySubSystem memorySubSystem = (MemorySubSystem)subsystem;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            metric.setActiveSubSystems();\n-        }\n-    }\n-\n-\n-    private static boolean getHierarchical(MemorySubSystem subsystem) {\n-        long hierarchical = SubSystem.getLongValue(subsystem, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n-    private static boolean getSwapEnabled(MemorySubSystem subsystem) {\n-        long retval = SubSystem.getLongValue(subsystem, \"memory.memsw.limit_in_bytes\");\n-        return retval > 0;\n-    }\n-\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n-    private void setMemorySubSystem(MemorySubSystem memory) {\n-        this.memory = memory;\n-    }\n-\n-    private void setCpuSubSystem(SubSystem cpu) {\n-        this.cpu = cpu;\n-    }\n-\n-    private void setCpuAcctSubSystem(SubSystem cpuacct) {\n-        this.cpuacct = cpuacct;\n-    }\n-\n-    private void setCpuSetSubSystem(SubSystem cpuset) {\n-        this.cpuset = cpuset;\n-    }\n-\n-    private void setBlkIOSubSystem(SubSystem blkio) {\n-        this.blkio = blkio;\n-    }\n-\n-    private SubSystem MemorySubSystem() {\n-        return memory;\n-    }\n-\n-    private SubSystem CpuSubSystem() {\n-        return cpu;\n-    }\n-\n-    private SubSystem CpuAcctSubSystem() {\n-        return cpuacct;\n-    }\n-\n-    private SubSystem CpuSetSubSystem() {\n-        return cpuset;\n-    }\n-\n-    private SubSystem BlkIOSubSystem() {\n-        return blkio;\n-    }\n-\n-    public String getProvider() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    \/*****************************************************************\n-     * CPU Accounting Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuUsage() {\n-        return SubSystem.getLongValue(cpuacct, \"cpuacct.usage\");\n-    }\n-\n-    public long[] getPerCpuUsage() {\n-        String usagelist = SubSystem.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n-        if (usagelist == null) {\n-            return new long[0];\n-        }\n-\n-        String list[] = usagelist.split(\" \");\n-        long percpu[] = new long[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            percpu[i] = Long.parseLong(list[i]);\n-        }\n-        return percpu;\n-    }\n-\n-    public long getCpuUserUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n-    }\n-\n-    public long getCpuSystemUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPU Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuPeriod() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_period_us\");\n-    }\n-\n-    public long getCpuQuota() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_quota_us\");\n-    }\n-\n-    public long getCpuShares() {\n-        long retval = SubSystem.getLongValue(cpu, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return -1;\n-        else\n-            return retval;\n-    }\n-\n-    public long getCpuNumPeriods() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n-    }\n-\n-    public long getCpuNumThrottled() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n-    }\n-\n-    public long getCpuThrottledTime() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n-    }\n-\n-    public long getEffectiveCpuCount() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPUSet Subsystem\n-     ****************************************************************\/\n-\n-    public int[] getCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.cpus\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n-    }\n-\n-    public int[] getCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.mems\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_mems\"));\n-    }\n-\n-    public double getCpuSetMemoryPressure() {\n-        return SubSystem.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n-    }\n-\n-    public boolean isCpuSetMemoryPressureEnabled() {\n-        long val = SubSystem.getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n-        return (val == 1);\n-    }\n-\n-\n-    \/*****************************************************************\n-     * Memory Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.failcnt\");\n-    }\n-\n-    public long getMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public static long convertHierachicalLimitLine(String line) {\n-        String[] tokens = line.split(\"\\\\s\");\n-        if (tokens.length == 2) {\n-            String strVal = tokens[1];\n-            return SubSystem.convertStringToLong(strVal);\n-        }\n-        return unlimited_minimum + 1; \/\/ unlimited\n-    }\n-\n-    public long getMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.failcnt\");\n-    }\n-\n-    public long getKernelMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.kmem.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getKernelMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n-    }\n-\n-    public long getTcpMemoryLimit() {\n-        long retval =  SubSystem.getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getTcpMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.failcnt\");\n-    }\n-\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = SubSystem.getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n-    }\n-\n-    public boolean isMemoryOOMKillEnabled() {\n-        long val = SubSystem.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n-    }\n-\n-    public long getMemorySoftLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.soft_limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-\n-    \/*****************************************************************\n-     * BlKIO Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getBlkIOServiceCount() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n-    }\n-\n-    public long getBlkIOServiced() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n-    }\n-\n-    private static native boolean isUseContainerSupport();\n-\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":0,"deletions":545,"binary":false,"changes":545,"status":"deleted"},{"patch":"@@ -1,298 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class SubSystem {\n-    String root;\n-    String mountPoint;\n-    String path;\n-\n-    public SubSystem(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    \/**\n-     * getSubSystemStringValue\n-     *\n-     * Return the first line of the file \"parm\" argument from the subsystem.\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @return Returns the contents of the file specified by param.\n-     *\/\n-    public static String getStringValue(SubSystem subsystem, String parm) {\n-        if (subsystem == null) return null;\n-\n-        try {\n-            return subsystem.readStringValue(parm);\n-        } catch (IOException e) {\n-            return null;\n-        }\n-    }\n-\n-    private String readStringValue(String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(path(), param));\n-        try (BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValueMatchingLine(SubSystem subsystem,\n-                                                     String param,\n-                                                     String match,\n-                                                     Function<String, Long> conversion) {\n-        long retval = Metrics.unlimited_minimum + 1; \/\/ default unlimited\n-        try {\n-            List<String> lines = subsystem.readMatchingLines(param);\n-            for (String line: lines) {\n-                if (line.startsWith(match)) {\n-                    retval = conversion.apply(line);\n-                    break;\n-                }\n-            }\n-        } catch (IOException e) {\n-            \/\/ Ignore. Default is unlimited.\n-        }\n-        return retval;\n-    }\n-\n-    private List<String> readMatchingLines(String param) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () ->\n-                    Files.readAllLines(Paths.get(path(), param));\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-        return convertStringToLong(strval);\n-    }\n-\n-    public static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    public static double getDoubleValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-\n-        if (strval == null) return 0L;\n-\n-        double retval = Double.parseDouble(strval);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * getSubSystemlongEntry\n-     *\n-     * Return the long value from the line containing the string \"entryname\"\n-     * within file \"parm\" in the \"subsystem\".\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @param entryname\n-     * @return long value\n-     *\/\n-    public static long getLongEntry(SubSystem subsystem, String parm, String entryname) {\n-        String val = null;\n-\n-        if (subsystem == null) return 0L;\n-\n-        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n-\n-            Optional<String> result = lines.map(line -> line.split(\" \"))\n-                                           .filter(line -> (line.length == 2 &&\n-                                                   line[0].equals(entryname)))\n-                                           .map(line -> line[1])\n-                                           .findFirst();\n-\n-            return result.isPresent() ? Long.parseLong(result.get()) : 0L;\n-        } catch (IOException e) {\n-            return 0L;\n-        } catch (UncheckedIOException e) {\n-            return 0L;\n-        }\n-    }\n-\n-    public static int getIntValue(SubSystem subsystem, String parm) {\n-        String val = getStringValue(subsystem, parm);\n-\n-        if (val == null) return 0;\n-\n-        return Integer.parseInt(val);\n-    }\n-\n-    \/**\n-     * StringRangeToIntArray\n-     *\n-     * Convert a string in the form of  1,3-4,6 to an array of\n-     * integers containing all the numbers in the range.\n-     *\n-     * @param range\n-     * @return int[] containing a sorted list of processors or memory nodes\n-     *\/\n-    public static int[] StringRangeToIntArray(String range) {\n-        int[] ints = new int[0];\n-\n-        if (range == null) return ints;\n-\n-        ArrayList<Integer> results = new ArrayList<>();\n-        String strs[] = range.split(\",\");\n-        for (String str : strs) {\n-            if (str.contains(\"-\")) {\n-                String lohi[] = str.split(\"-\");\n-                \/\/ validate format\n-                if (lohi.length != 2) {\n-                    continue;\n-                }\n-                int lo = Integer.parseInt(lohi[0]);\n-                int hi = Integer.parseInt(lohi[1]);\n-                for (int i = lo; i <= hi; i++) {\n-                    results.add(i);\n-                }\n-            }\n-            else {\n-                results.add(Integer.parseInt(str));\n-            }\n-        }\n-\n-        \/\/ sort results\n-        results.sort(null);\n-\n-        \/\/ convert ArrayList to primitive int array\n-        ints = new int[results.size()];\n-        int i = 0;\n-        for (Integer n : results) {\n-            ints[i++] = n;\n-        }\n-\n-        return ints;\n-    }\n-\n-    public static class MemorySubSystem extends SubSystem {\n-\n-        private boolean hierarchical;\n-        private boolean swapenabled;\n-\n-        public MemorySubSystem(String root, String mountPoint) {\n-            super(root, mountPoint);\n-        }\n-\n-        boolean isHierarchical() {\n-            return hierarchical;\n-        }\n-\n-        void setHierarchical(boolean hierarchical) {\n-            this.hierarchical = hierarchical;\n-        }\n-\n-        boolean isSwapEnabled() {\n-            return swapenabled;\n-        }\n-\n-        void setSwapEnabled(boolean swapenabled) {\n-            this.swapenabled = swapenabled;\n-        }\n-\n-    }\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":0,"deletions":298,"binary":false,"changes":298,"status":"deleted"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupV2Subsystem implements CgroupSubsystem {\n+\n+    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static final long[] LONG_ARRAY_NOT_SUPPORTED = null;\n+    private static final int[] INT_ARRAY_UNAVAILABLE = null;\n+    private final CgroupSubsystemController unified;\n+    private static final String PROVIDER_NAME = \"cgroupv2\";\n+    private static final int PER_CPU_SHARES = 1024;\n+    private static final String MAX_VAL = \"max\";\n+    private static final Object EMPTY_STR = \"\";\n+\n+    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+        this.unified = unified;\n+    }\n+\n+    private long getLongVal(String file) {\n+        return CgroupSubsystemController.getLongValue(unified,\n+                                                      file,\n+                                                      CgroupV2SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    private static CgroupV2Subsystem initSubsystem() {\n+        \/\/ read mountinfo so as to determine root mount path\n+        String mountPath = null;\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n+                            .collect(Collectors.joining());\n+            String[] tokens = l.split(\" \");\n+            mountPath = tokens[4];\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        String cgroupPath = null;\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n+            for (String line: lines) {\n+                String[] tokens = line.split(\":\");\n+                if (tokens.length != 3) {\n+                    return null; \/\/ something is not right.\n+                }\n+                if (!\"0\".equals(tokens[0])) {\n+                    \/\/ hierarchy must be zero for cgroups v2\n+                    return null;\n+                }\n+                cgroupPath = tokens[2];\n+                break;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                mountPath,\n+                cgroupPath);\n+        return new CgroupV2Subsystem(unified);\n+    }\n+\n+    public static CgroupSubsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return LONG_ARRAY_NOT_SUPPORTED;\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return limitFromString(quota);\n+    }\n+\n+    private long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = getLongVal(\"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        String cpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus\");\n+        return getCpuSet(cpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        String effCpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus.effective\");\n+        return getCpuSet(effCpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        String cpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems\");\n+        return getCpuSet(cpuSetMems);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        String effCpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems.effective\");\n+        return getCpuSet(effCpuSetMems);\n+    }\n+\n+    private int[] getCpuSet(String cpuSetVal) {\n+        if (cpuSetVal == null || EMPTY_STR.equals(cpuSetVal)) {\n+            return INT_ARRAY_UNAVAILABLE;\n+        }\n+        return CgroupSubsystemController.stringRangeToIntArray(cpuSetVal);\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return getLongVal(\"memory.current\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return getLongVal(\"memory.swap.current\");\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.low\");\n+        return limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRandWIOs);\n+    }\n+\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRBytesAndWBytesIO);\n+    }\n+\n+    private long sumTokensIOStat(Function<String, Long> mapFunc) {\n+        try {\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+                                .map(mapFunc)\n+                                .collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+\n+    private static String[] getRWIOMatchTokenNames() {\n+        return new String[] { \"rios\", \"wios\" };\n+    }\n+\n+    private static String[] getRWBytesIOMatchTokenNames() {\n+        return new String[] { \"rbytes\", \"wbytes\" };\n+    }\n+\n+    public static Long lineToRandWIOs(String line) {\n+        String[] matchNames = getRWIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    public static Long lineToRBytesAndWBytesIO(String line) {\n+        String[] matchNames = getRWBytesIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    private static Long ioStatLineToLong(String line, String[] matchNames) {\n+        if (line == null || EMPTY_STR.equals(line)) {\n+            return Long.valueOf(0);\n+        }\n+        String[] tokens = line.split(\"\\\\s+\");\n+        long retval = 0;\n+        for (String t: tokens) {\n+            String[] valKeys = t.split(\"=\");\n+            if (valKeys.length != 2) {\n+                \/\/ ignore device ids $MAJ:$MIN\n+                continue;\n+            }\n+            for (String match: matchNames) {\n+                if (match.equals(valKeys[0])) {\n+                    retval += longOrZero(valKeys[1]);\n+                }\n+            }\n+        }\n+        return Long.valueOf(retval);\n+    }\n+\n+    private static long longOrZero(String val) {\n+        long lVal = 0;\n+        try {\n+            lVal = Long.parseLong(val);\n+        } catch (NumberFormatException e) {\n+            \/\/ keep at 0\n+        }\n+        return lVal;\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.nio.file.Paths;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_platform_CgroupMetrics.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsUseContainerSupport();\n+}\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jvm.h\"\n-\n-#include \"jdk_internal_platform_cgroupv1_Metrics.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n-{\n-    return JVM_IsUseContainerSupport();\n-}\n","filename":"src\/java.base\/linux\/native\/libjava\/Metrics.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,1 @@\n-            \/\/ We currently only support cgroupv1\n-            Class<?> c = Class.forName(\"jdk.internal.platform.cgroupv1.Metrics\");\n-            @SuppressWarnings(\"unchecked\")\n+            Class<?> c = Class.forName(\"jdk.internal.platform.CgroupMetrics\");\n@@ -77,1 +75,1 @@\n-     * The provider for Linux is cgroupsv1.\n+     * The provider for Linux is cgroups (version 1 or 2).\n@@ -93,1 +91,2 @@\n-     * @return Time in nanoseconds or 0L if metric is not available.\n+     * @return Time in nanoseconds, -1 if unknown or\n+     *         -2 if the metric is not supported.\n@@ -109,1 +108,1 @@\n-     *         this metric is not available, a zero length array will be\n+     *         this metric is not supported or not available, null will be\n@@ -119,1 +118,2 @@\n-     * @return User time in nanoseconds or 0L if metric is not available.\n+     * @return User time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -128,1 +128,2 @@\n-     * @return System time in nanoseconds or 0L if metric is not available.\n+     * @return System time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -141,1 +142,2 @@\n-     * @return time in microseconds or 0L if metric is not available.\n+     * @return time in microseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -151,1 +153,2 @@\n-     * @return time in microseconds or -1 if the quota is unlimited.\n+     * @return time in microseconds, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n@@ -170,1 +173,2 @@\n-     * @return shares value or -1 if no share set.\n+     * @return shares value, -1 if the metric is not available or\n+     *         -2 if cpu shares are not supported.\n@@ -177,2 +181,1 @@\n-     * a CPU quota has been setup for the Isolation Group; otherwise\n-     * returns 0.\n+     * a CPU quota has been setup for the Isolation Group\n@@ -180,1 +183,2 @@\n-     * @return count of elapsed periods or 0 if the quota is unlimited.\n+     * @return count of elapsed periods, -1 if the metric is not available\n+     *         or -2 if the metric is not supported.\n@@ -190,1 +194,2 @@\n-     * @return count of throttled periods or 0 if the quota is unlimited.\n+     * @return count of throttled periods, -1 if the metric is not available or\n+     *         -2 if it is not supported.\n@@ -200,1 +205,2 @@\n-     * @return Throttled time in nanoseconds or 0 if the quota is unlimited.\n+     * @return Throttled time in nanoseconds, -1 if the metric is not available\n+     *         or -2 if it is not supported.\n@@ -232,2 +238,2 @@\n-     * @return An array of available CPUs or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available CPUs. Returns null if the metric is not\n+     *         available or the metric is not supported.\n@@ -244,2 +250,2 @@\n-     * @return An array of available and online CPUs or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online CPUs. Returns null\n+     *         if the metric is not available or the metric is not supported.\n@@ -258,2 +264,2 @@\n-     * @return An array of available memory nodes or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available memory nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -270,2 +276,2 @@\n-     * @return An array of available and online nodes or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -276,21 +282,0 @@\n-    \/**\n-     * Returns the (attempts per second * 1000), if enabled, that the\n-     * operating system tries to satisfy a memory request for any\n-     * process in the current Isolation Group when no free memory is\n-     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n-     * to determine if this support is enabled.\n-     *\n-     * @return Memory pressure or 0 if not enabled or metric is not\n-     *         available.\n-     *\n-     *\/\n-    public double getCpuSetMemoryPressure();\n-\n-    \/**\n-     * Returns the state of the memory pressure detection support.\n-     *\n-     * @return true if the support is available and enabled, otherwise false.\n-     *\n-     *\/\n-    public boolean isCpuSetMemoryPressureEnabled();\n-\n@@ -305,2 +290,3 @@\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available. Returns -2 if the metric is not\n+     *         supported.\n@@ -315,2 +301,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit or -2 if this metric is not supported.\n@@ -321,10 +307,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryMaxUsage();\n-\n@@ -335,2 +311,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available or -2 if the metric is not\n+     *         supported.\n@@ -341,70 +318,0 @@\n-    \/**\n-     * Returns the number of times that kernel memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of kernel physical memory, in bytes, that\n-     * can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of kernel physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryMaxUsage();\n-\n-    \/**\n-     * Returns the amount of kernel physical memory, in bytes, that\n-     * is currently allocated in the current Isolation Group.\n-     *\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryUsage();\n-\n-    \/**\n-     * Returns the number of times that networking memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of networking physical memory, in bytes,\n-     * that can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of networking physical memory, in bytes,\n-     * that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryMaxUsage();\n-\n@@ -415,2 +322,2 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if the metric\n+     *         is not available. Returns -2 if this metric is not supported.\n@@ -421,10 +328,0 @@\n-    \/**\n-     * Returns the number of times that user memory requests in the\n-     * Isolation Group have exceeded the memory + swap limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapFailCount();\n-\n@@ -435,2 +332,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set or -2 if this metric is not supported.\n@@ -441,10 +338,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory and swap space,\n-     * in bytes, that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapMaxUsage();\n-\n@@ -455,2 +342,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available. Returns -2 if this metric is not\n+     *         supported.\n@@ -461,12 +349,0 @@\n-    \/**\n-     * Returns the state of the Operating System Out of Memory termination\n-     * policy.\n-     *\n-     * @return Returns true if operating system will terminate processes\n-     *         in the Isolation Group that exceed the amount of available\n-     *         memory, otherwise false.  Flase will be returned if this\n-     *         capability is not available on the current operating system.\n-     *\n-     *\/\n-    public boolean isMemoryOOMKillEnabled();\n-\n@@ -481,2 +357,2 @@\n-     *         conditions.  If this metric is not available, 0 will be\n-     *         returned.\n+     *         conditions.  If this metric is not available, -1 will be\n+     *         returned. Returns -2 if the metric is not supported.\n@@ -495,1 +371,2 @@\n-     * @return The count of requests or 0 if this metric is not available.\n+     * @return The count of requests or -1 if the metric is not available.\n+     *         Returns -2 if this metric is not supported.\n@@ -504,1 +381,2 @@\n-     * @return The number of bytes transferred or 0 if this metric is not available.\n+     * @return The number of bytes transferred or -1 if the metric is not\n+     *         available. Returns -2 if this metric is not supported.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":52,"deletions":174,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.lang.module.ModuleDescriptor.Requires;\n@@ -52,0 +51,1 @@\n+import java.lang.module.ModuleDescriptor.Requires;\n@@ -65,1 +65,0 @@\n-import java.text.Normalizer;\n@@ -67,0 +66,1 @@\n+import java.text.Normalizer;\n@@ -122,0 +122,1 @@\n+\n@@ -326,0 +327,2 @@\n+        final long longRetvalNotSupported = -2;\n+\n@@ -328,5 +331,3 @@\n-        ostream.println(INDENT + \"CPU Period: \" + c.getCpuPeriod() +\n-               (c.getCpuPeriod() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Quota: \" + c.getCpuQuota() +\n-               (c.getCpuQuota() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Shares: \" + c.getCpuShares());\n+        ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + \"CPU Period: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + \"CPU Quota: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuShares(), INDENT + \"CPU Shares: \", longRetvalNotSupported));\n@@ -335,2 +336,3 @@\n-        ostream.println(INDENT + \"List of Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -338,6 +340,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Processors: N\/A\");\n@@ -347,2 +352,3 @@\n-        ostream.println(INDENT + \"List of Effective Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Effective Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -350,6 +356,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Effective Processors: N\/A\");\n@@ -359,2 +368,3 @@\n-        ostream.println(INDENT + \"List of Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -362,6 +372,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Memory Nodes: N\/A\");\n@@ -371,2 +384,3 @@\n-        ostream.println(INDENT + \"List of Available Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Available Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -374,6 +388,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Available Memory Nodes: N\/A\");\n@@ -382,3 +399,0 @@\n-        ostream.println(INDENT + \"CPUSet Memory Pressure Enabled: \"\n-                + c.isCpuSetMemoryPressureEnabled());\n-\n@@ -386,2 +400,1 @@\n-        ostream.println(INDENT + \"Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Limit: \", longRetvalNotSupported));\n@@ -390,2 +403,1 @@\n-        ostream.println(INDENT + \"Memory Soft Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Soft Limit: \", longRetvalNotSupported));\n@@ -394,6 +406,1 @@\n-        ostream.println(INDENT + \"Memory & Swap Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n-\n-        limit = c.getKernelMemoryLimit();\n-        ostream.println(INDENT + \"Kernel Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory & Swap Limit: \", longRetvalNotSupported));\n@@ -401,3 +408,2 @@\n-        limit = c.getTcpMemoryLimit();\n-        ostream.println(INDENT + \"TCP Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(\"\");\n+    }\n@@ -405,2 +411,9 @@\n-        ostream.println(INDENT + \"Out Of Memory Killer Enabled: \"\n-                + c.isMemoryOOMKillEnabled());\n+    private static String formatLimitString(long limit, String prefix, long unavailable) {\n+        if (limit >= 0) {\n+            return prefix + SizePrefix.scaleValue(limit);\n+        } else if (limit == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + \"Unlimited\";\n+        }\n+    }\n@@ -408,1 +421,8 @@\n-        ostream.println(\"\");\n+    private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {\n+        if (cpuVal >= 0) {\n+            return prefix + cpuVal + \"us\";\n+        } else if (cpuVal == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + cpuVal;\n+        }\n@@ -824,1 +844,1 @@\n-                      mainClass.getName(), mainClass.getModule(),\n+                      mainClass.getName(), mainClass.getModule().getName(),\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":80,"deletions":60,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\n@@ -210,6 +211,0 @@\n-                long deltaLimit = memSwapLimit - memLimit;\n-                \/\/ Return 0 when memSwapLimit == memLimit, which means no swap space is allowed.\n-                \/\/ And the same for memSwapLimit < memLimit.\n-                if (deltaLimit <= 0) {\n-                    return 0;\n-                }\n@@ -223,6 +218,2 @@\n-                        long deltaUsage = memSwapUsage - memUsage;\n-                        if (deltaUsage >= 0) {\n-                            long freeSwap = deltaLimit - deltaUsage;\n-                            if (freeSwap >= 0) {\n-                                return freeSwap;\n-                            }\n+                        if ((memSwapUsage - memUsage) >= 0) {\n+                            return memSwapLimit - memLimit - (memSwapUsage - memUsage);\n@@ -285,2 +276,2 @@\n-        if (containerMetrics != null) {\n-            return containerMetrics.getCpuSetCpus().length == getHostOnlineCpuCount0();\n+        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n+            return containerMetrics.getCpuSetCpus().length == getHostConfiguredCpuCount0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CgroupSubsystemFactory\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * Verify hotspot's detection heuristics of CgroupSubsystemFactory::create()\n+ *\/\n+public class CgroupSubsystemFactory {\n+\n+    \/\/ Mirrored from src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp\n+    private static final int CGROUPS_V1 = 1;\n+    private static final int CGROUPS_V2 = 2;\n+    private static final int INVALID_CGROUPS_V2 = 3;\n+    private static final int INVALID_CGROUPS_V1 = 4;\n+    private static final int INVALID_CGROUPS_NO_MOUNT = 5;\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private Path cgroupV1SelfCgroup;\n+    private Path cgroupV2SelfCgroup;\n+    private Path cgroupV2MntInfoMissingCgroupv2;\n+    private Path cgroupv1MntInfoMissingMemoryController;\n+    private String procSelfCgroupHybridContent = \"11:hugetlb:\/\\n\" +\n+            \"10:devices:\/user.slice\\n\" +\n+            \"9:pids:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"8:cpu,cpuacct:\/\\n\" +\n+            \"7:perf_event:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/\\n\" +\n+            \"4:net_cls,net_prio:\/\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:memory:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\\n\" +\n+            \"0::\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\";\n+    private String procSelfCgroupV2UnifiedContent = \"0::\/user.slice\/user-1000.slice\/session-3.scope\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\";\n+    private String mntInfoHybridStub =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;\n+    private String mntInfoHybridMissingMemory = mntInfoHybridStub;\n+    private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;\n+    private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  3   1   1\\n\" +\n+            \"cpu 8   1   1\\n\" +\n+            \"cpuacct 8   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    private void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);\n+\n+            cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero_cgroupv2_last\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder);\n+\n+            cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_hybrid\");\n+            Files.writeString(cgroupV1SelfCgroup, procSelfCgroupHybridContent);\n+\n+            cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_v2\");\n+            Files.writeString(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent);\n+\n+            cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), \"mnt_info_missing_memory\");\n+            Files.writeString(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory);\n+\n+            cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), \"mnt_info_missing_cgroup2\");\n+            Files.writeString(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    private boolean isValidCgroup(int value) {\n+        return value == CGROUPS_V1 || value == CGROUPS_V2;\n+    }\n+\n+    public void testCgroupv1NoMounts(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"No cgroups mounted in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1NoMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V2, retval, \"No cgroup2 filesystem in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2NoCgroup2Fs PASSED!\");\n+    }\n+\n+    public void testCgroupv1MissingMemoryController(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V1, retval, \"Required memory controller path missing in mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MissingMemoryController PASSED!\");\n+    }\n+\n+    public void testCgroupv2(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"Expected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2 PASSED!\");\n+    }\n+\n+    public void testCgroupV1Hybrid(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1Hybrid PASSED!\");\n+    }\n+\n+    public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1HybridMntInfoOrder PASSED!\");\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        CgroupSubsystemFactory test = new CgroupSubsystemFactory();\n+        test.setup();\n+        try {\n+            test.testCgroupv1NoMounts(wb);\n+            test.testCgroupv2(wb);\n+            test.testCgroupV1Hybrid(wb);\n+            test.testCgroupV1HybridMntInfoOrder(wb);\n+            test.testCgroupv1MissingMemoryController(wb);\n+            test.testCgroupv2NoCgroup2Fs(wb);\n+        } finally {\n+            test.teardown();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -216,3 +217,15 @@\n-        Common.run(opts)\n-            .shouldMatch(\"CPU Shares is.*\" + shares)\n-            .shouldMatch(\"active_processor_count.*\" + expectedAPC);\n+        OutputAnalyzer out = Common.run(opts);\n+        \/\/ Cgroups v2 needs to do some scaling of raw shares values. Hence,\n+        \/\/ 256 CPU shares come back as 264. Raw value written to cpu.weight\n+        \/\/ is 10. The reason this works for >= 1024 shares value is because\n+        \/\/ post-scaling the closest multiple of 1024 is found and returned.\n+        \/\/\n+        \/\/ For values < 1024, this doesn't happen so loosen the match to a\n+        \/\/ 3-digit number and ensure the active_processor_count is as\n+        \/\/ expected.\n+        if (shares < 1024) {\n+            out.shouldMatch(\"CPU Shares is.*\\\\d{3}\");\n+        } else {\n+            out.shouldMatch(\"CPU Shares is.*\" + shares);\n+        }\n+        out.shouldMatch(\"active_processor_count.*\" + expectedAPC);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,8 +46,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(metrics);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @run junit\/othervm TestCgroupSubsystemController\n+ *\/\n+\n+\/**\n+ *\n+ * Basic unit test for CgroupSubsystemController\n+ *\n+ *\/\n+public class TestCgroupSubsystemController {\n+\n+    private static final double DELTA = 0.01;\n+    private Path existingDirectory;\n+    private Path existingFile;\n+    private String existingFileName = \"test-controller-file\";\n+    private String existingFileContents = \"foobar\";\n+    private String doubleValueContents = \"1.5\";\n+    private String longValueContents = \"3000000000\";\n+    private String longValueMatchingLineContents = \"testme\\n\" +\n+                                                   \"itemfoo 25\";\n+    private String longEntryContents = \"s 1\\n\" +\n+                                       \"t 2\";\n+    private String longEntryName = \"longEntry\";\n+    private String longEntryMatchingLineName = \"longMatchingLine\";\n+    private String doubleValueName = \"doubleValue\";\n+    private String longValueName = \"longValue\";\n+    private CgroupSubsystemController mockController;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemController.class.getSimpleName());\n+            existingFile = Paths.get(existingDirectory.toString(), existingFileName);\n+            Files.writeString(existingFile, existingFileContents, StandardCharsets.UTF_8);\n+            Path longFile = Paths.get(existingDirectory.toString(), longValueName);\n+            Files.writeString(longFile, longValueContents);\n+            Path doubleFile = Paths.get(existingDirectory.toString(), doubleValueName);\n+            Files.writeString(doubleFile, doubleValueContents);\n+            Path longEntryFile = Paths.get(existingDirectory.toString(), longEntryName);\n+            Files.writeString(longEntryFile, longEntryContents);\n+            Path longMatchingLine = Paths.get(existingDirectory.toString(), longEntryMatchingLineName);\n+            Files.writeString(longMatchingLine, longValueMatchingLineContents);\n+            mockController = new MockCgroupSubsystemController(existingDirectory.toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void getStringValueNullController() {\n+        String val = CgroupSubsystemController.getStringValue(null, \"ignore\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueIOException() throws IOException {\n+        String val = CgroupSubsystemController.getStringValue(mockController, \"don-t-exist.txt\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueSuccess() {\n+        String actual = CgroupSubsystemController.getStringValue(mockController, existingFileName);\n+        assertEquals(existingFileContents, actual);\n+    }\n+\n+    @Test\n+    public void convertStringToLong() {\n+        String strVal = \"1230\";\n+        long longVal = Long.parseLong(strVal);\n+        long actual = CgroupSubsystemController.convertStringToLong(strVal, -1L, 0);\n+        assertEquals(longVal, actual);\n+\n+        String overflowVal = \"9223372036854775808\"; \/\/ Long.MAX_VALUE + 1\n+        long overflowDefault = -1;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+        overflowDefault = Long.MAX_VALUE;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+    }\n+\n+    @Test\n+    public void convertStringRangeToIntArray() {\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(null));\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(\"\"));\n+        String strRange = \"2,4,6\";\n+        int[] actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        int[] expected = new int[] { 2, 4, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+        strRange = \"6,1-3\";\n+        actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        expected = new int[] { 1, 2, 3, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void getDoubleValue() {\n+        double defaultValue = -3;\n+        double actual = CgroupSubsystemController.getDoubleValue(null, null, defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+        double expected = Double.parseDouble(doubleValueContents);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, doubleValueName, defaultValue);\n+        assertEquals(expected, actual, DELTA);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, \"don't-exist\", defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+    }\n+\n+    @Test\n+    public void getLongValue() {\n+        long defaultValue = -4;\n+        long actual = CgroupSubsystemController.getLongValue(null, null, Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValue(mockController, \"dont-exist\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        long expected = Long.parseLong(longValueContents);\n+        actual = CgroupSubsystemController.getLongValue(mockController, longValueName, Long::parseLong, defaultValue);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void getLongEntry() {\n+        long defaultValue = -5;\n+        long actual = CgroupSubsystemController.getLongEntry(null, null, \"no-matter\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, \"dont-exist\", \"foo-bar\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, longEntryName, \"t\", defaultValue);\n+        assertEquals(2, actual);\n+    }\n+\n+    @Test\n+    public void getLongMatchingLine() {\n+        long defaultValue = -6;\n+        long actual = CgroupSubsystemController.getLongValueMatchingLine(null, null, \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, \"dont-exist\", \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, longEntryMatchingLineName, \"item\", TestCgroupSubsystemController::convertLong, defaultValue);\n+        assertEquals(25, actual);\n+    }\n+\n+    public static long convertLong(String line) {\n+        return Long.parseLong(line.split(\"\\\\s+\")[1]);\n+    }\n+\n+    static class MockCgroupSubsystemController implements CgroupSubsystemController {\n+\n+        private final String path;\n+\n+        public MockCgroupSubsystemController(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String path() {\n+            return path;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -146,0 +146,5 @@\n+        if (\"cgroupv2\".equals(metrics.getProvider()) && shares < 1024) {\n+            \/\/ Adjust input shares for < 1024 cpu shares as the\n+            \/\/ impl. rounds up to the next multiple of 1024\n+            shares = 1024;\n+        }\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+import jdk.internal.platform.CgroupV1Metrics;\n@@ -28,3 +30,0 @@\n-\n-    private static final long UNLIMITED = -1;\n-\n@@ -67,20 +66,12 @@\n-        long memAndSwapLimit = Metrics.systemMetrics().getMemoryAndSwapLimit();\n-        long memLimit = Metrics.systemMetrics().getMemoryLimit();\n-\n-        \/\/ We need swap to execute this test or will SEGV\n-        if (memAndSwapLimit <= memLimit) {\n-            System.out.println(\"No swap memory limits, test case skipped\");\n-        } else {\n-            long count = Metrics.systemMetrics().getMemoryFailCount();\n-\n-            \/\/ Allocate 512M of data\n-            byte[][] bytes = new byte[64][];\n-            for (int i = 0; i < 64; i++) {\n-                try {\n-                    bytes[i] = new byte[8 * 1024 * 1024];\n-                    \/\/ Break out as soon as we see an increase in failcount\n-                    \/\/ to avoid getting killed by the OOM killer.\n-                    if (Metrics.systemMetrics().getMemoryFailCount() > count) {\n-                        break;\n-                    }\n-                } catch (Error e) { \/\/ OOM error\n+        long count = Metrics.systemMetrics().getMemoryFailCount();\n+\n+        \/\/ Allocate 512M of data\n+        byte[][] bytes = new byte[64][];\n+        boolean atLeastOneAllocationWorked = false;\n+        for (int i = 0; i < 64; i++) {\n+            try {\n+                bytes[i] = new byte[8 * 1024 * 1024];\n+                atLeastOneAllocationWorked = true;\n+                \/\/ Break out as soon as we see an increase in failcount\n+                \/\/ to avoid getting killed by the OOM killer.\n+                if (Metrics.systemMetrics().getMemoryFailCount() > count) {\n@@ -89,0 +80,2 @@\n+            } catch (Error e) { \/\/ OOM error\n+                break;\n@@ -90,5 +83,11 @@\n-            if (Metrics.systemMetrics().getMemoryFailCount() <= count) {\n-                throw new RuntimeException(\"Memory fail count : new : [\"\n-                        + Metrics.systemMetrics().getMemoryFailCount() + \"]\"\n-                        + \", old : [\" + count + \"]\");\n-            }\n+        }\n+        if (!atLeastOneAllocationWorked) {\n+            System.out.println(\"Allocation failed immediately. Ignoring test!\");\n+            return;\n+        }\n+        \/\/ Be sure bytes allocations don't get optimized out\n+        System.out.println(\"DEBUG: Bytes allocation length 1: \" + bytes[0].length);\n+        if (Metrics.systemMetrics().getMemoryFailCount() <= count) {\n+            throw new RuntimeException(\"Memory fail count : new : [\"\n+                    + Metrics.systemMetrics().getMemoryFailCount() + \"]\"\n+                    + \", old : [\" + count + \"]\");\n@@ -113,9 +112,13 @@\n-        long limit = getMemoryValue(value);\n-        long kmemlimit = Metrics.systemMetrics().getKernelMemoryLimit();\n-        \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n-        \/\/ This feature is deprecated. Only perform the check if we get an actual\n-        \/\/ limit back.\n-        if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n-            throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n-                    + limit + \"]\" + \", got : [\"\n-                    + kmemlimit + \"]\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            System.out.println(\"TEST PASSED!!!\");\n+            long limit = getMemoryValue(value);\n+            long kmemlimit = mCgroupV1.getKernelMemoryLimit();\n+            if (kmemlimit != 0 && limit != kmemlimit) {\n+                throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n+                        + limit + \"]\" + \", got : [\"\n+                        + kmemlimit + \"]\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -123,1 +126,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n@@ -129,1 +131,0 @@\n-        long actualMemAndSwap = Metrics.systemMetrics().getMemoryAndSwapLimit();\n@@ -132,3 +133,2 @@\n-                || (expectedMemAndSwap != actualMemAndSwap\n-                && expectedMem != actualMemAndSwap)) {\n-            throw new RuntimeException(\"Memory and swap limit not equal, expected : [\"\n+                || expectedMemAndSwap != Metrics.systemMetrics().getMemoryAndSwapLimit()) {\n+            System.err.println(\"Memory and swap limit not equal, expected : [\"\n@@ -157,2 +157,11 @@\n-        if (!(oomKillFlag ^ Metrics.systemMetrics().isMemoryOOMKillEnabled())) {\n-            throw new RuntimeException(\"oomKillFlag error\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            Boolean expected = Boolean.valueOf(oomKillFlag);\n+            Boolean actual = mCgroupV1.isMemoryOOMKillEnabled();\n+            if (!(expected.equals(actual))) {\n+                throw new RuntimeException(\"oomKillFlag error\");\n+            }\n+            System.out.println(\"TEST PASSED!!!\");\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -160,1 +169,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":54,"deletions":46,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            if (cpuSetMems.length > 1) {\n+            if (cpuSetMems != null && cpuSetMems.length > 1) {\n@@ -84,1 +84,1 @@\n-            } else if (cpuSetMems.length == 1) {\n+            } else if (cpuSetMems != null && cpuSetMems.length == 1) {\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -60,4 +62,15 @@\n-            testKernelMemoryLimit(\"100m\");\n-            testKernelMemoryLimit(\"1g\");\n-\n-            testOomKillFlag(\"100m\", false);\n+            Metrics m = Metrics.systemMetrics();\n+            \/\/ kernel memory, '--kernel-memory' switch, and OOM killer,\n+            \/\/ '--oom-kill-disable' switch, tests not supported by cgroupv2\n+            \/\/ runtimes\n+            if (m != null) {\n+                if (\"cgroupv1\".equals(m.getProvider())) {\n+                    testKernelMemoryLimit(\"100m\");\n+                    testKernelMemoryLimit(\"1g\");\n+\n+                    testOomKillFlag(\"100m\", false);\n+                } else {\n+                    System.out.println(\"kernel memory tests and OOM Kill flag tests not \" +\n+                                       \"possible with cgroupv2.\");\n+                }\n+            }\n@@ -71,1 +84,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -137,1 +152,2 @@\n-        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+        OutputAnalyzer oa = DockerTestUtils.dockerRunJava(opts);\n+        oa.shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -765,0 +765,20 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@link Files#createTempDirectory(Path, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix the prefix string to be used in generating the directory's name; may be null\n+     * @param attrs an optional list of file attributes to set atomically when creating the directory\n+     * @return the path to the newly created directory\n+     * @throws IOException if an I\/O error occurs or dir does not exist\n+     *\n+     * @see Files#createTempDirectory(Path, String, FileAttribute...)\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix, attrs);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -57,2 +58,1 @@\n-        try {\n-            Stream<String> stream = Files.lines(Paths.get(path));\n+        try (Stream<String> stream = Files.lines(Paths.get(path))) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CPUSetsReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+interface CgroupMetricsTester {\n+\n+    public static final double ERROR_MARGIN = 0.1;\n+    public static final String EMPTY_STR = \"\";\n+\n+    public void testMemorySubsystem();\n+    public void testCpuAccounting();\n+    public void testCpuSchedulingMetrics();\n+    public void testCpuSets();\n+    public void testCpuConsumption() throws IOException, InterruptedException;\n+    public void testMemoryUsage() throws Exception;\n+    public void testMisc();\n+\n+    public static long convertStringToLong(String strval, long overflowRetval) {\n+        long retval = 0;\n+        if (strval == null) return 0L;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n+            \/\/ In this case, return Long.MAX_VALUE\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static boolean compareWithErrorMargin(long oldVal, long newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static boolean compareWithErrorMargin(double oldVal, double newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static void fail(String controller, String metric, long oldVal, long testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, String oldVal, String testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, double oldVal, double testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, boolean oldVal, boolean testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void warn(String controller, String metric, long oldVal, long testVal) {\n+        System.err.println(\"Warning - \" + controller + \":\" + metric\n+                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static Integer[] convertCpuSetsToArray(String cpusstr) {\n+        if (cpusstr == null || EMPTY_STR.equals(cpusstr)) {\n+            return new Integer[0];\n+        }\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] cpuSets = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n+            if (a.contains(\"-\")) {\n+                String[] range = a.split(\"-\");\n+                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n+                        Integer.parseInt(range[1])).boxed();\n+            } else {\n+                return Stream.of(Integer.parseInt(a));\n+            }\n+        }).toArray(Integer[]::new);\n+        return cpuSets;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc.\n@@ -24,0 +24,1 @@\n+\n@@ -26,17 +27,2 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n+import java.util.Objects;\n+\n@@ -45,0 +31,4 @@\n+\/**\n+ * Cgroup version agnostic metrics tester\n+ *\n+ *\/\n@@ -47,293 +37,2 @@\n-    private static final double ERROR_MARGIN = 0.1;\n-    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-    long startSysVal;\n-    long startUserVal;\n-    long startUsage;\n-    long startPerCpu[];\n-\n-    enum SubSystem {\n-        MEMORY(\"memory\"),\n-        CPUSET(\"cpuset\"),\n-        CPU(\"cpu\"),\n-        CPUACCT(\"cpuacct\"),\n-        BLKIO(\"blkio\");\n-\n-        private String value;\n-\n-        SubSystem(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private static final Set<String> allowedSubSystems =\n-            Stream.of(SubSystem.values()).map(SubSystem::value).collect(Collectors.toSet());\n-\n-    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n-\n-    private static void setPath(String[] line) {\n-        String cgroupPath = line[2];\n-        String[] subSystems = line[1].split(\",\");\n-\n-        for (String subSystem : subSystems) {\n-            if (allowedSubSystems.contains(subSystem)) {\n-                String[] paths = subSystemPaths.get(subSystem);\n-                String finalPath = \"\";\n-                String root = paths[0];\n-                String mountPoint = paths[1];\n-                if (root != null && cgroupPath != null) {\n-                    if (root.equals(\"\/\")) {\n-                        if (!cgroupPath.equals(\"\/\")) {\n-                            finalPath = mountPoint + cgroupPath;\n-                        } else {\n-                            finalPath = mountPoint;\n-                        }\n-                    } else {\n-                        if (root.equals(cgroupPath)) {\n-                            finalPath = mountPoint;\n-                        } else {\n-                            if (cgroupPath.startsWith(root)) {\n-                                if (cgroupPath.length() > root.length()) {\n-                                    String cgroupSubstr = cgroupPath.substring(root.length());\n-                                    finalPath = mountPoint + cgroupSubstr;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n-            }\n-        }\n-    }\n-\n-    private static void createSubsystems(String[] line) {\n-        if (line.length < 5) return;\n-        Path p = Paths.get(line[4]);\n-        String subsystemName = p.getFileName().toString();\n-        if (subsystemName != null) {\n-            for (String subSystem : subsystemName.split(\",\")) {\n-                if (allowedSubSystems.contains(subSystem)) {\n-                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n-                }\n-            }\n-        }\n-    }\n-\n-    public void setup() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ Initialize CPU usage metrics before we do any testing.\n-        startSysVal = metrics.getCpuSystemUsage();\n-        startUserVal = metrics.getCpuUserUsage();\n-        startUsage = metrics.getCpuUsage();\n-        startPerCpu = metrics.getPerCpuUsage();\n-\n-        try {\n-            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n-            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n-                    .map(line -> line.split(\" \"))\n-                    .forEach(MetricsTester::createSubsystems);\n-            lines.close();\n-\n-            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n-            lines.map(line -> line.split(\":\"))\n-                    .filter(line -> (line.length >= 3))\n-                    .forEach(MetricsTester::setPath);\n-            lines.close();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    private static String getFileContents(SubSystem subSystem, String fileName) {\n-        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n-        try {\n-            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n-        } catch (FileNotFoundException e) {\n-            System.err.println(\"Unable to open : \" + fname);\n-            return \"\";\n-        }\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0L : convertStringToLong(data);\n-    }\n-\n-    private static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String metric, String subMetric) {\n-        String stats = getFileContents(subSystem, metric);\n-        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n-        for (int i = 0; i < tokens.length; i++) {\n-            if (tokens[i].startsWith(subMetric)) {\n-                String strval = tokens[i].split(\"\\\\s+\")[1];\n-                return convertStringToLong(strval);\n-            }\n-        }\n-        return 0L;\n-    }\n-\n-    private static double getDoubleValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n-    }\n-\n-    private boolean compareWithErrorMargin(long oldVal, long newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private boolean compareWithErrorMargin(double oldVal, double newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private static void fail(SubSystem system, String metric, long oldVal, long testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, String oldVal, String testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, double oldVal, double testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, boolean oldVal, boolean testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void warn(SubSystem system, String metric, long oldVal, long testVal) {\n-        System.err.println(\"Warning - \" + system.value + \":\" + metric\n-                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    public void testMemorySubsystem() {\n-        Metrics metrics = Metrics.systemMetrics();\n-\n-        \/\/ User Memory\n-        long oldVal = metrics.getMemoryFailCount();\n-        long newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/ Kernel memory\n-        oldVal = metrics.getKernelMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/TCP Memory\n-        oldVal = metrics.getTcpMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/  Memory and Swap\n-        \/\/ Skip swap tests if no swap is configured.\n-        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n-            oldVal = metrics.getMemoryAndSwapFailCount();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.failcnt\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapLimit();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\");\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapMaxUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n-            }\n-        }\n+    private static final String CGROUP_V1 = \"cgroupv1\";\n+    private static final String CGROUP_V2 = \"cgroupv2\";\n@@ -341,14 +40,12 @@\n-        oldVal = metrics.getMemorySoftLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n-        boolean newOomKillEnabled = getLongValueFromFile(SubSystem.MEMORY,\n-                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n-        if (oomKillEnabled != newOomKillEnabled) {\n-            throw new RuntimeException(\"Test failed for - \" + SubSystem.MEMORY.value + \":\"\n-                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n-                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+    private static CgroupMetricsTester createInstance(Metrics m) {\n+        Objects.requireNonNull(m);\n+        if (CGROUP_V1.equals(m.getProvider())) {\n+            MetricsTesterCgroupV1 t = new MetricsTesterCgroupV1();\n+            t.setup();\n+            return t;\n+        } else if (CGROUP_V2.equals(m.getProvider())) {\n+            return new MetricsTesterCgroupV2();\n+        } else {\n+            System.err.println(\"WARNING: Metrics provider, '\" + m.getProvider()\n+                                                              + \"' is unknown!\");\n+            return null;\n@@ -358,253 +55,9 @@\n-    public void testCpuAccounting() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuUsage();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.usage\");\n-\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n-        }\n-\n-        Long[] newVals = Stream.of(getFileContents(SubSystem.CPUACCT, \"cpuacct.usage_percpu\")\n-                .split(\"\\\\s+\"))\n-                .map(Long::parseLong)\n-                .toArray(Long[]::new);\n-        Long[] oldVals = LongStream.of(metrics.getPerCpuUsage()).boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(SubSystem.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n-            }\n-        }\n-\n-        oldVal = metrics.getCpuUserUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"user\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuSystemUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"system\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSchedulingMetrics() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuPeriod();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_period_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuQuota();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_quota_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuShares();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.shares\");\n-        if (newVal == 0 || newVal == 1024) newVal = -1;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.shares\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumPeriods();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_periods\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumThrottled();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuThrottledTime();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"throttled_time\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSets() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-\n-        String cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.cpus\");\n-        \/\/ Parse range string in the format 1,2-6,7\n-        Integer[] newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n-                Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-        cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.mems\");\n-        newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n-                    Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_mems\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        double oldValue = metrics.getCpuSetMemoryPressure();\n-        double newValue = getDoubleValueFromFile(SubSystem.CPUSET, \"cpuset.memory_pressure\");\n-        if (!compareWithErrorMargin(oldValue, newValue)) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n-        }\n-\n-        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n-        boolean newV = getLongValueFromFile(SubSystem.CPUSET,\n-                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n-        if (oldV != newV) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n-        }\n-    }\n-\n-    public void testBlkIO() {\n-        Metrics metrics = Metrics.systemMetrics();\n-            long oldVal = metrics.getBlkIOServiceCount();\n-        long newVal = getLongValueFromFile(SubSystem.BLKIO,\n-                \"blkio.throttle.io_service_bytes\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n-                    oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getBlkIOServiced();\n-        newVal = getLongValueFromFile(SubSystem.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuConsumption() throws IOException, InterruptedException {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ make system call\n-        long newSysVal = metrics.getCpuSystemUsage();\n-        long newUserVal = metrics.getCpuUserUsage();\n-        long newUsage = metrics.getCpuUsage();\n-        long[] newPerCpu = metrics.getPerCpuUsage();\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newSysVal < startSysVal) {\n-            fail(SubSystem.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n-        }\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newUserVal < startUserVal) {\n-            fail(SubSystem.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n-        }\n-\n-        if (newUsage <= startUsage) {\n-            fail(SubSystem.CPU, \"getCpuUsage\", newUsage, startUsage);\n-        }\n-\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n-            }\n-        }\n-\n-        if(!success) fail(SubSystem.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n-    }\n-\n-    public void testMemoryUsage() throws Exception {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n-        long memoryUsage = metrics.getMemoryUsage();\n-        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n-\n-        \/\/ allocate memory in a loop and check more than once for new values\n-        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n-        \/\/ e.g. because the system could free up memory\n-        byte[][] bytes = new byte[32][];\n-        for (int i = 0; i < 32; i++) {\n-            bytes[i] = new byte[8*1024*1024];\n-            newMemoryUsage = metrics.getMemoryUsage();\n-            if (newMemoryUsage > memoryUsage) {\n-                break;\n-            }\n-        }\n-        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n-\n-        if (newMemoryMaxUsage < memoryMaxUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n-                    newMemoryMaxUsage);\n-        }\n-\n-        if (newMemoryUsage < memoryUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n-        }\n+    public void testAll(Metrics m) throws Exception {\n+        CgroupMetricsTester tester =  createInstance(m);\n+        tester.testCpuAccounting();\n+        tester.testCpuConsumption();\n+        tester.testCpuSchedulingMetrics();\n+        tester.testCpuSets();\n+        tester.testMemorySubsystem();\n+        tester.testMemoryUsage();\n+        tester.testMisc();\n@@ -614,0 +67,1 @@\n+        Metrics m = Metrics.systemMetrics();\n@@ -615,2 +69,1 @@\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n+        if (m == null) {\n@@ -622,8 +75,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(m);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":34,"deletions":588,"binary":false,"changes":622,"status":"modified"},{"patch":"@@ -0,0 +1,566 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class MetricsTesterCgroupV1 implements CgroupMetricsTester {\n+\n+    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n+    long startSysVal;\n+    long startUserVal;\n+    long startUsage;\n+    long startPerCpu[];\n+\n+    enum Controller {\n+        MEMORY(\"memory\"),\n+        CPUSET(\"cpuset\"),\n+        CPU(\"cpu\"),\n+        CPUACCT(\"cpuacct\"),\n+        BLKIO(\"blkio\");\n+\n+        private String value;\n+\n+        Controller(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private static final Set<String> allowedSubSystems =\n+            Stream.of(Controller.values()).map(Controller::value).collect(Collectors.toSet());\n+\n+    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n+\n+    private static void setPath(String[] line) {\n+        String cgroupPath = line[2];\n+        String[] subSystems = line[1].split(\",\");\n+\n+        for (String subSystem : subSystems) {\n+            if (allowedSubSystems.contains(subSystem)) {\n+                String[] paths = subSystemPaths.get(subSystem);\n+                String finalPath = \"\";\n+                String root = paths[0];\n+                String mountPoint = paths[1];\n+                if (root != null && cgroupPath != null) {\n+                    if (root.equals(\"\/\")) {\n+                        if (!cgroupPath.equals(\"\/\")) {\n+                            finalPath = mountPoint + cgroupPath;\n+                        } else {\n+                            finalPath = mountPoint;\n+                        }\n+                    } else {\n+                        if (root.equals(cgroupPath)) {\n+                            finalPath = mountPoint;\n+                        } else {\n+                            if (cgroupPath.startsWith(root)) {\n+                                if (cgroupPath.length() > root.length()) {\n+                                    String cgroupSubstr = cgroupPath.substring(root.length());\n+                                    finalPath = mountPoint + cgroupSubstr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n+            }\n+        }\n+    }\n+\n+    private static void createSubsystems(String[] line) {\n+        if (line.length < 5) return;\n+        Path p = Paths.get(line[4]);\n+        String subsystemName = p.getFileName().toString();\n+        if (subsystemName != null) {\n+            for (String subSystem : subsystemName.split(\",\")) {\n+                if (allowedSubSystems.contains(subSystem)) {\n+                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setup() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+        startPerCpu = metrics.getPerCpuUsage();\n+        if (startPerCpu == null) {\n+            startPerCpu = new long[0];\n+        }\n+\n+        try {\n+            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n+            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n+                    .map(line -> line.split(\" \"))\n+                    .forEach(MetricsTesterCgroupV1::createSubsystems);\n+            lines.close();\n+\n+            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n+            lines.map(line -> line.split(\":\"))\n+                    .filter(line -> (line.length >= 3))\n+                    .forEach(MetricsTesterCgroupV1::setPath);\n+            lines.close();\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private static String getFileContents(Controller subSystem, String fileName) {\n+        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n+        try {\n+            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n+        } catch (FileNotFoundException e) {\n+            System.err.println(\"Unable to open : \" + fname);\n+            return null;\n+        }\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return (data == null || data.isEmpty()) ? 0L : convertStringToLong(data);\n+    }\n+\n+    private static long convertStringToLong(String strval) {\n+        return CgroupMetricsTester.convertStringToLong(strval, Long.MAX_VALUE);\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String metric, String subMetric) {\n+        String stats = getFileContents(subSystem, metric);\n+        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n+        for (int i = 0; i < tokens.length; i++) {\n+            if (tokens[i].startsWith(subMetric)) {\n+                String strval = tokens[i].split(\"\\\\s+\")[1];\n+                return convertStringToLong(strval);\n+            }\n+        }\n+        return 0L;\n+    }\n+\n+    private static double getDoubleValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n+    }\n+\n+    private static void fail(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, String oldVal, String testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, double oldVal, double testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, boolean oldVal, boolean testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void warn(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.warn(system.value, metric, oldVal, testVal);\n+    }\n+\n+    public void testMemorySubsystem() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueFromFile(Controller.MEMORY, \"memory.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/ Kernel memory\n+        oldVal = metrics.getKernelMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/TCP Memory\n+        oldVal = metrics.getTcpMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/  Memory and Swap\n+        oldVal = metrics.getMemoryAndSwapFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.soft_limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n+        boolean newOomKillEnabled = getLongValueFromFile(Controller.MEMORY,\n+                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n+        if (oomKillEnabled != newOomKillEnabled) {\n+            throw new RuntimeException(\"Test failed for - \" + Controller.MEMORY.value + \":\"\n+                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n+                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+        }\n+    }\n+\n+    public void testCpuAccounting() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.usage\");\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n+        }\n+\n+        String newValsStr = getFileContents(Controller.CPUACCT, \"cpuacct.usage_percpu\");\n+        Long[] newVals = new Long[0];\n+        if (newValsStr != null) {\n+            newVals = Stream.of(newValsStr\n+                .split(\"\\\\s+\"))\n+                .map(Long::parseLong)\n+                .toArray(Long[]::new);\n+        }\n+        long[] oldValsPrim = metrics.getPerCpuUsage();\n+        Long[] oldVals = LongStream.of(oldValsPrim == null ? new long[0] : oldValsPrim)\n+                                    .boxed().toArray(Long[]::new);\n+        for (int i = 0; i < oldVals.length; i++) {\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+            }\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"user\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"system\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSchedulingMetrics() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_period_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_quota_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.shares\");\n+        if (newVal == 0 || newVal == 1024) newVal = -1;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.shares\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"throttled_time\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSets() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getFileContents(Controller.CPUSET, \"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n+                Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSets.length != 0) {\n+            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSetMems.length != 0) {\n+            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        double oldValue = metrics.getCpuSetMemoryPressure();\n+        double newValue = getDoubleValueFromFile(Controller.CPUSET, \"cpuset.memory_pressure\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldValue, newValue)) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n+        }\n+\n+        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n+        boolean newV = getLongValueFromFile(Controller.CPUSET,\n+                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n+        if (oldV != newV) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n+        }\n+    }\n+\n+    private void testBlkIO() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+            long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getLongValueFromFile(Controller.BLKIO,\n+                \"blkio.throttle.io_service_bytes\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n+                    oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getLongValueFromFile(Controller.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuConsumption() throws IOException, InterruptedException {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+        long[] newPerCpu = metrics.getPerCpuUsage();\n+        if (newPerCpu == null) {\n+            newPerCpu = new long[0];\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(Controller.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(Controller.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(Controller.CPU, \"getCpuUsage\", newUsage, startUsage);\n+        }\n+\n+        boolean success = false;\n+        for (int i = 0; i < startPerCpu.length; i++) {\n+            if (newPerCpu[i] > startPerCpu[i]) {\n+                success = true;\n+                break;\n+            }\n+        }\n+\n+        if(!success) fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                Arrays.toString(startPerCpu));\n+    }\n+\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testBlkIO();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":566,"deletions":0,"binary":false,"changes":566,"status":"added"},{"patch":"@@ -0,0 +1,468 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.Metrics;\n+\n+public class MetricsTesterCgroupV2 implements CgroupMetricsTester {\n+\n+    private static final long UNLIMITED = -1;\n+    private static final UnifiedController UNIFIED = new UnifiedController();\n+    private static final String MAX = \"max\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    private final long startSysVal;\n+    private final long startUserVal;\n+    private final long startUsage;\n+\n+    static class UnifiedController {\n+\n+        private static final String NAME = \"unified\";\n+        private final String path;\n+\n+        UnifiedController() {\n+            path = constructPath();\n+        }\n+\n+        String getPath() {\n+            return path;\n+        }\n+\n+        private static String constructPath() {\n+            String mountPath;\n+            String cgroupPath;\n+            try {\n+                List<String> fifthTokens = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))\n+                        .filter( l -> l.contains(\"- cgroup2\"))\n+                        .map(UnifiedController::splitAndMountPath)\n+                        .collect(Collectors.toList());\n+                if (fifthTokens.size() != 1) {\n+                    throw new AssertionError(\"Expected only one cgroup2 line\");\n+                }\n+                mountPath = fifthTokens.get(0);\n+\n+                List<String> cgroupPaths = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))\n+                        .filter( l -> l.startsWith(\"0:\"))\n+                        .map(UnifiedController::splitAndCgroupPath)\n+                        .collect(Collectors.toList());\n+                if (cgroupPaths.size() != 1) {\n+                    throw new AssertionError(\"Expected only one unified controller line\");\n+                }\n+                cgroupPath = cgroupPaths.get(0);\n+                return Paths.get(mountPath, cgroupPath).toString();\n+            } catch (IOException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static String splitAndMountPath(String input) {\n+            String[] tokens = input.split(\"\\\\s+\");\n+            return tokens[4]; \/\/ fifth entry is the mount path\n+        }\n+\n+        public static String splitAndCgroupPath(String input) {\n+            String[] tokens = input.split(\":\");\n+            return tokens[2];\n+        }\n+    }\n+\n+    private long getLongLimitValueFromFile(String file) {\n+        String strVal = getStringVal(file);\n+        if (MAX.equals(strVal)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(strVal);\n+    }\n+\n+    public MetricsTesterCgroupV2() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+    }\n+\n+    private long getLongValueFromFile(String file) {\n+        return convertStringToLong(getStringVal(file));\n+    }\n+\n+    private long getLongValueEntryFromFile(String file, String metric) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            String strVal = Files.lines(filePath).filter(l -> l.startsWith(metric)).collect(Collectors.joining());\n+            String[] keyValues = strVal.split(\"\\\\s+\");\n+            String value = keyValues[1];\n+            return convertStringToLong(value);\n+        } catch (IOException e) {\n+            return 0;\n+        }\n+    }\n+\n+    private String getStringVal(String file) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            return Files.lines(filePath).collect(Collectors.joining());\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private void fail(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void fail(String metric, String oldVal, String newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void warn(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.warn(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private long getCpuShares(String file) {\n+        long rawVal = getLongValueFromFile(file);\n+        if (rawVal == 0 || rawVal == 100) {\n+            return UNLIMITED;\n+        }\n+        int shares = (int)rawVal;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    private long getCpuMaxValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 0 \/* $MAX index *\/);\n+    }\n+\n+    private long getCpuPeriodValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 1 \/* $PERIOD index *\/);\n+    }\n+\n+    private long getCpuValueFromFile(String file, int index) {\n+        String maxPeriod = getStringVal(file);\n+        if (maxPeriod == null) {\n+            return UNLIMITED;\n+        }\n+        String[] tokens = maxPeriod.split(\"\\\\s+\");\n+        String val = tokens[index];\n+        if (MAX.equals(val)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(val);\n+    }\n+\n+    private long convertStringToLong(String val) {\n+        return CgroupMetricsTester.convertStringToLong(val, UNLIMITED);\n+    }\n+\n+    @Override\n+    public void testMemorySubsystem() {\n+        Metrics metrics = Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueEntryFromFile(\"memory.events\", \"max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.events[max]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(\"memory.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueEntryFromFile(\"memory.stat\", \"sock\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.stat[sock]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.swap.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapUsage();\n+        newVal = getLongValueFromFile(\"memory.swap.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.low\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.low\", oldVal, newVal);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testCpuAccounting() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[usage_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[user_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[system_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSchedulingMetrics() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getCpuPeriodValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$PERIOD]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getCpuMaxValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$MAX]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getCpuShares(\"cpu.weight\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.weight\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_periods]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_throttled]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[throttled_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSets() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        int[] cpus = mapNullToEmpty(metrics.getCpuSetCpus());\n+        Integer[] oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getStringVal(\"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetCpus());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.cpus.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+    }\n+\n+    private int[] mapNullToEmpty(int[] cpus) {\n+        if (cpus == null) {\n+            \/\/ Not available. For sake of testing continue with an\n+            \/\/ empty array.\n+            cpus = new int[0];\n+        }\n+        return cpus;\n+    }\n+\n+    @Override\n+    public void testCpuConsumption() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(\"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(\"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(\"getCpuUsage\", newUsage, startUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testIOStat();\n+    }\n+\n+    private void testIOStat() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getIoStatAccumulate(new String[] { \"rios\", \"wios\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rios\/wios: \", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getIoStatAccumulate(new String[] { \"rbytes\", \"wbytes\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rbytes\/wbytes: \", oldVal, newVal);\n+        }\n+    }\n+\n+    private long getIoStatAccumulate(String[] matchNames) {\n+        try {\n+            return Files.lines(Paths.get(UNIFIED.getPath(), \"io.stat\"))\n+                    .map(line -> {\n+                        long accumulator = 0;\n+                        String[] tokens = line.split(\"\\\\s+\");\n+                        for (String t: tokens) {\n+                            String[] keyVal = t.split(\"=\");\n+                            if (keyVal.length != 2) {\n+                                continue;\n+                            }\n+                            for (String match: matchNames) {\n+                                if (match.equals(keyVal[0])) {\n+                                    accumulator += Long.parseLong(keyVal[1]);\n+                                }\n+                            }\n+                        }\n+                        return accumulator;\n+                    }).collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":468,"deletions":0,"binary":false,"changes":468,"status":"added"},{"patch":"@@ -541,0 +541,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}