{"files":[{"patch":"@@ -30,0 +30,3 @@\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -43,0 +46,2 @@\n+    private boolean printDateTime;\n+    private boolean printThreadDetails;\n@@ -45,0 +50,4 @@\n+    private static boolean threadInfoAll;\n+    private static boolean timeStampInfoAll;\n+    private static final String TIMESTAMP_OPTION = \"+timestamp\";\n+    private static final String THREAD_OPTION = \"+thread\";\n@@ -63,0 +72,10 @@\n+            } else if (args.contains(\"all\")) {\n+                \/\/ \"all\" option has special handling for decorator options\n+                \/\/ If the thread or timestamp decorator option is detected\n+                \/\/ with the \"all\" option, then it impacts decorator options\n+                \/\/ for other categories\n+                int beginIndex = args.lastIndexOf(\"all\") + \"all\".length();\n+                int commaIndex = args.indexOf(',', beginIndex);\n+                if (commaIndex == -1) commaIndex = args.length();\n+                threadInfoAll = args.substring(beginIndex, commaIndex).contains(THREAD_OPTION);\n+                timeStampInfoAll = args.substring(beginIndex, commaIndex).contains(TIMESTAMP_OPTION);\n@@ -67,2 +86,1 @@\n-    public static void Help()\n-    {\n+    public static void Help() {\n@@ -94,0 +112,5 @@\n+        System.err.println(\"+timestamp can be appended to any of above options to print\");\n+        System.err.println(\"              a timestamp for that debug option\");\n+        System.err.println(\"+thread can be appended to any of above options to print\");\n+        System.err.println(\"              thread and caller information for that debug option\");\n+        System.err.println();\n@@ -134,2 +157,1 @@\n-    public static Debug getInstance(String option)\n-    {\n+    public static Debug getInstance(String option) {\n@@ -143,2 +165,1 @@\n-    public static Debug getInstance(String option, String prefix)\n-    {\n+    public static Debug getInstance(String option, String prefix) {\n@@ -148,0 +169,1 @@\n+            d.configureExtras(option);\n@@ -154,0 +176,35 @@\n+    private static String formatCaller() {\n+        return StackWalker.getInstance().walk(s ->\n+                s.dropWhile(f ->\n+                    f.getClassName().startsWith(\"sun.security.util.Debug\"))\n+                        .map(f -> f.getFileName() + \":\" + f.getLineNumber())\n+                        .findFirst().orElse(\"unknown caller\"));\n+    }\n+\n+    \/\/ parse an option string to determine if extra details,\n+    \/\/ like thread and timestamp, should be printed\n+    private void configureExtras(String option) {\n+        \/\/ treat \"all\" as special case, only used for java.security.debug property\n+        this.printDateTime = timeStampInfoAll;\n+        this.printThreadDetails = threadInfoAll;\n+\n+        if (printDateTime && printThreadDetails) {\n+            \/\/ nothing left to configure\n+            return;\n+        }\n+\n+        \/\/ args is converted to lower case for the most part via marshal method\n+        int optionIndex = args.lastIndexOf(option);\n+        if (optionIndex == -1) {\n+            \/\/ option not in args list. Only here since \"all\" was present\n+            \/\/ in debug property argument. \"all\" option already parsed\n+            return;\n+        }\n+        int beginIndex = optionIndex + option.length();\n+        int commaIndex = args.indexOf(',', beginIndex);\n+        if (commaIndex == -1) commaIndex = args.length();\n+        String subOpt = args.substring(beginIndex, commaIndex);\n+        printDateTime = printDateTime || subOpt.contains(TIMESTAMP_OPTION);\n+        printThreadDetails = printThreadDetails || subOpt.contains(THREAD_OPTION);\n+    }\n+\n@@ -158,2 +215,1 @@\n-    public static boolean isOn(String option)\n-    {\n+    public static boolean isOn(String option) {\n@@ -182,3 +238,2 @@\n-    public void println(String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n@@ -191,3 +246,2 @@\n-    public void println(Object obj, String message)\n-    {\n-        System.err.println(prefix + \" [\" + obj.getClass().getSimpleName() +\n+    public void println(Object obj, String message) {\n+        System.err.println(prefix + extraInfo() + \" [\" + obj.getClass().getSimpleName() +\n@@ -201,3 +255,2 @@\n-    public void println()\n-    {\n-        System.err.println(prefix + \":\");\n+    public void println() {\n+        System.err.println(prefix + extraInfo() + \":\");\n@@ -210,3 +263,22 @@\n-    public static void println(String prefix, String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String prefix, String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n+    }\n+\n+    \/**\n+     * If thread debug option enabled, include information containing\n+     * hex value of threadId and the current thread name\n+     * If timestamp debug option enabled, include timestamp string\n+     * @return extra info if debug option enabled.\n+     *\/\n+    private String extraInfo() {\n+        String retString = \"\";\n+        if (printThreadDetails) {\n+            retString = \"0x\" + Long.toHexString(\n+                    Thread.currentThread().getId()).toUpperCase(Locale.ROOT) +\n+                    \"|\" + Thread.currentThread().getName() + \"|\" + formatCaller();\n+        }\n+        if (printDateTime) {\n+            retString += (retString.isEmpty() ? \"\" : \"|\")\n+                    + FormatHolder.DATE_TIME_FORMATTER.format(Instant.now());\n+        }\n+        return retString.isEmpty() ? \"\" : \"[\" + retString + \"]\";\n@@ -339,0 +411,7 @@\n+    \/\/ Holder class to break cyclic dependency seen during build\n+    private static class FormatHolder {\n+        private static final String PATTERN = \"yyyy-MM-dd kk:mm:ss.SSS\";\n+        private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter\n+                .ofPattern(PATTERN, Locale.ENGLISH)\n+                .withZone(ZoneId.systemDefault());\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":99,"deletions":20,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8051959\n+ * @summary Option to print extra information in java.security.debug output\n+ * @library \/test\/lib\n+ * @run junit DebugOptions\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DebugOptions {\n+\n+    static final String DATE_REGEX = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ no extra info present\n+                Arguments.of(\"properties\",\n+                        \"properties: java.security\",\n+                        \"properties\\\\[\"),\n+                \/\/ thread info only\n+                Arguments.of(\"properties+thread\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*java.*]:\",\n+                        \"properties\\\\[\" + DATE_REGEX),\n+                \/\/ timestamp info only\n+                Arguments.of(\"properties+timestamp\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"properties+timestamp+thread\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ flip the arguments of previous test\n+                Arguments.of(\"properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ comma not valid separator, ignore extra info printing request\n+                Arguments.of(\"properties,thread,timestamp\",\n+                        \"properties:\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ no extra info for keystore debug prints\n+                Arguments.of(\"properties+thread+timestamp,keystore\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ flip arguments around in last test - same outcome expected\n+                Arguments.of(\"keystore,properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ turn on thread info for both keystore and properties components\n+                Arguments.of(\"keystore+thread,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ same as above with erroneous comma at end of string. same output expected\n+                Arguments.of(\"keystore+thread,properties+thread,\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for properties and timestamp for keystore\n+                Arguments.of(\"keystore+timestamp,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties\\\\[.*\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for all components\n+                Arguments.of(\"all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info and timestamp for all components\n+                Arguments.of(\"all+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ all decorator option should override other component options\n+                Arguments.of(\"all+thread+timestamp,properties\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ thread details should only be printed for properties option\n+                Arguments.of(\"properties+thread,all\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*\\\\]:\",\n+                        \"keystore\\\\[.*\\\\|main\\\\|.*\\\\]:\"),\n+                \/\/ thread details should be printed for all statements\n+                Arguments.of(\"properties,all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*java\" +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties:\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String params, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Djava.security.debug=\" + params,\n+                \"DebugOptions\"\n+        );\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ something to trigger \"properties\" debug output\n+        Security.getProperty(\"test\");\n+        \/\/ trigger \"keystore\" debug output\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/Debug\/DebugOptions.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}