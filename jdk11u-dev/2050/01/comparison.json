{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=11.0.20\n+version=11.0.21\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,2 +168,5 @@\n-  AC_MSG_CHECKING([for dtrace tool])\n-  if test \"x$DTRACE\" != \"x\" && test -x \"$DTRACE\"; then\n+  AC_MSG_CHECKING([for dtrace tool and platform support])\n+  if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xppc\"; then\n+    AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU_ARCH])\n+    DTRACE_DEP_MISSING=true\n+  elif test \"x$DTRACE\" != \"x\" && test -x \"$DTRACE\"; then\n","filename":"make\/autoconf\/hotspot.m4","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=20\n+DEFAULT_VERSION_UPDATE=21\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2023-07-18\n+DEFAULT_VERSION_DATE=2023-10-17\n@@ -40,1 +40,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/autoconf\/version-numbers","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -562,1 +562,2 @@\n-  HARFBUZZ_DISABLED_WARNINGS_gcc := type-limits missing-field-initializers strict-aliasing\n+  HARFBUZZ_DISABLED_WARNINGS_gcc := type-limits missing-field-initializers strict-aliasing \\\n+       array-bounds\n@@ -564,0 +565,1 @@\n+  # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n@@ -565,1 +567,1 @@\n-       maybe-uninitialized class-memaccess unused-result extra noexcept-type\n+       maybe-uninitialized class-memaccess unused-result extra noexcept-type expansion-to-defined\n","filename":"make\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -211,0 +211,1 @@\n+    ls.cr();\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    st->print_cr(\"pd set count = #%d\", count);\n+    st->print(\"pd set count = #%d\", count);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+\n@@ -245,3 +246,2 @@\n-    p->set_klass(klass);\n-    p->set_next(bucket(index));\n-    set_entry(index, p);\n+    Hashtable<InstanceKlass*, mtClass>::add_entry(index, p);\n+\n@@ -481,2 +481,1 @@\n-      probe->name()->print_on(st);\n-      st->print(\" , loaders:\");\n+      st->print(\"Symbol: %s loaders:\", probe->name()->as_C_string());\n@@ -484,0 +483,2 @@\n+        st->cr();\n+        st->print(\"    \");\n@@ -485,1 +486,0 @@\n-        st->print(\", \");\n@@ -491,0 +491,2 @@\n+\n+void LoaderConstraintTable::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  void print() const;\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1347,6 +1347,0 @@\n-  \/\/ The following guarantee is meant to ensure that no loader constraints\n-  \/\/ exist yet, since the constraints table is not shared.  This becomes\n-  \/\/ more important now that we don't re-initialize vtables\/itables for\n-  \/\/ shared classes at runtime, where constraints were previously created.\n-  guarantee(SystemDictionary::constraints()->number_of_entries() == 0,\n-            \"loader constraints are not saved\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -282,0 +282,5 @@\n+  static CallStaticJavaNode* get_uncommon_trap_from_success_proj(Node* node);\n+  SafePointNode* create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const;\n+  void replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc, JVMState* saved_jvms_before_guards);\n+  void replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards);\n+  void create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call);\n@@ -283,1 +288,1 @@\n-  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,\n+  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards, int saved_reexecute_sp,\n@@ -1431,1 +1436,1 @@\n-  Node* tgt         = argument(1); \/\/ tgt is int ch\n+  Node* int_ch      = argument(1);\n@@ -1443,0 +1448,9 @@\n+\n+  \/\/ Check for int_ch >= 0\n+  Node* int_ch_cmp = _gvn.transform(new CmpINode(int_ch, intcon(0)));\n+  Node* int_ch_bol = _gvn.transform(new BoolNode(int_ch_cmp, BoolTest::ge));\n+  {\n+    BuildCutout unless(this, int_ch_bol, PROB_MAX);\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_maybe_recompile);\n+  }\n@@ -1450,1 +1464,1 @@\n-  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);\n+  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, int_ch, StrIntrinsicNode::none);\n@@ -4537,18 +4551,1 @@\n-        JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n-        uint size = alloc->req();\n-        SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n-        old_jvms->set_map(sfpt);\n-        for (uint i = 0; i < size; i++) {\n-          sfpt->init_req(i, alloc->in(i));\n-        }\n-        \/\/ re-push array length for deoptimization\n-        sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n-        old_jvms->set_sp(old_jvms->sp()+1);\n-        old_jvms->set_monoff(old_jvms->monoff()+1);\n-        old_jvms->set_scloff(old_jvms->scloff()+1);\n-        old_jvms->set_endoff(old_jvms->endoff()+1);\n-        old_jvms->set_should_reexecute(true);\n-\n-        sfpt->set_i_o(map()->i_o());\n-        sfpt->set_memory(map()->memory());\n-        sfpt->set_control(map()->control());\n+        SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n@@ -4569,0 +4566,24 @@\n+\/\/ Clone the JVMState of the array allocation and create a new safepoint with it. Re-push the array length to the stack\n+\/\/ such that uncommon traps can be emitted to re-execute the array allocation in the interpreter.\n+SafePointNode* LibraryCallKit::create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const {\n+  JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n+  uint size = alloc->req();\n+  SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n+  old_jvms->set_map(sfpt);\n+  for (uint i = 0; i < size; i++) {\n+    sfpt->init_req(i, alloc->in(i));\n+  }\n+  \/\/ re-push array length for deoptimization\n+  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n+  old_jvms->set_sp(old_jvms->sp()+1);\n+  old_jvms->set_monoff(old_jvms->monoff()+1);\n+  old_jvms->set_scloff(old_jvms->scloff()+1);\n+  old_jvms->set_endoff(old_jvms->endoff()+1);\n+  old_jvms->set_should_reexecute(true);\n+\n+  sfpt->set_i_o(map()->i_o());\n+  sfpt->set_memory(map()->memory());\n+  sfpt->set_control(map()->control());\n+  return sfpt;\n+}\n+\n@@ -4576,1 +4597,1 @@\n-void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,\n+void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards,\n@@ -4578,1 +4599,3 @@\n-  if (saved_jvms != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != NULL && !stopped()) {\n+    replace_unrelated_uncommon_traps_with_alloc_state(alloc, saved_jvms_before_guards);\n+\n@@ -4581,3 +4604,3 @@\n-    saved_jvms->map()->set_control(map()->control());\n-    assert(saved_jvms->map()->memory() == map()->memory(), \"memory state changed?\");\n-    assert(saved_jvms->map()->i_o() == map()->i_o(), \"IO state changed?\");\n+    saved_jvms_before_guards->map()->set_control(map()->control());\n+    assert(saved_jvms_before_guards->map()->memory() == map()->memory(), \"memory state changed?\");\n+    assert(saved_jvms_before_guards->map()->i_o() == map()->i_o(), \"IO state changed?\");\n@@ -4586,2 +4609,2 @@\n-    map()->replaced_nodes().apply(saved_jvms->map(), new_idx);\n-    set_jvms(saved_jvms);\n+    map()->replaced_nodes().apply(saved_jvms_before_guards->map(), new_idx);\n+    set_jvms(saved_jvms_before_guards);\n@@ -4663,0 +4686,52 @@\n+\/\/ Unrelated UCTs between the array allocation and the array copy, which are considered safe by tightly_coupled_allocation(),\n+\/\/ need to be replaced by an UCT with a state before the array allocation (including the array length). This is necessary\n+\/\/ because we could hit one of these UCTs (which are executed before the emitted array copy guards and the actual array\n+\/\/ allocation which is moved down in arraycopy_move_allocation_here()). When later resuming execution in the interpreter,\n+\/\/ we would have wrongly skipped the array allocation. To prevent this, we resume execution at the array allocation in\n+\/\/ the interpreter similar to what we are doing for the newly emitted guards for the array copy.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc,\n+                                                                       JVMState* saved_jvms_before_guards) {\n+  if (saved_jvms_before_guards->map()->control()->is_IfProj()) {\n+    \/\/ There is at least one unrelated uncommon trap which needs to be replaced.\n+    SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n+\n+    JVMState* saved_jvms = jvms();\n+    const int saved_reexecute_sp = _reexecute_sp;\n+    set_jvms(sfpt->jvms());\n+    _reexecute_sp = jvms()->sp();\n+\n+    replace_unrelated_uncommon_traps_with_alloc_state(saved_jvms_before_guards);\n+\n+    \/\/ Restore state\n+    set_jvms(saved_jvms);\n+    _reexecute_sp = saved_reexecute_sp;\n+  }\n+}\n+\n+\/\/ Replace the unrelated uncommon traps with new uncommon trap nodes by reusing the action and reason. The new uncommon\n+\/\/ traps will have the state of the array allocation. Let the old uncommon trap nodes die.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards) {\n+  Node* if_proj = saved_jvms_before_guards->map()->control(); \/\/ Start the search right before the newly emitted guards\n+  while (if_proj->is_IfProj()) {\n+    CallStaticJavaNode* uncommon_trap = get_uncommon_trap_from_success_proj(if_proj);\n+    if (uncommon_trap != NULL) {\n+      create_new_uncommon_trap(uncommon_trap);\n+    }\n+    assert(if_proj->in(0)->is_If(), \"must be If\");\n+    if_proj = if_proj->in(0)->in(0);\n+  }\n+  assert(if_proj->is_Proj() && if_proj->in(0)->is_Initialize(),\n+         \"must have reached control projection of init node\");\n+}\n+\n+void LibraryCallKit::create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call) {\n+  const int trap_request = uncommon_trap_call->uncommon_trap_request();\n+  assert(trap_request != 0, \"no valid UCT trap request\");\n+  PreserveJVMState pjvms(this);\n+  set_control(uncommon_trap_call->in(0));\n+  uncommon_trap(Deoptimization::trap_request_reason(trap_request),\n+                Deoptimization::trap_request_action(trap_request));\n+  assert(stopped(), \"Should be stopped\");\n+  _gvn.hash_delete(uncommon_trap_call);\n+  uncommon_trap_call->set_req(0, top()); \/\/ not used anymore, kill it\n+}\n@@ -4683,1 +4758,1 @@\n-  JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n+  JVMState* saved_jvms_before_guards = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n@@ -4686,3 +4761,3 @@\n-  \/\/ if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);\n+  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n+  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n@@ -4704,1 +4779,1 @@\n-  src  = saved_jvms != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src,  T_ARRAY);\n+  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -4709,1 +4784,1 @@\n-    \/\/ if saved_jvms == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n@@ -4823,1 +4898,1 @@\n-  if (saved_jvms != NULL) {\n+  if (saved_jvms_before_guards != NULL) {\n@@ -4894,0 +4969,1 @@\n+    arraycopy_move_allocation_here(alloc, dest, saved_jvms_before_guards, saved_reexecute_sp, new_idx);\n@@ -4896,2 +4972,0 @@\n-  arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);\n-\n@@ -4963,18 +5037,9 @@\n-    if ((ctl->is_IfFalse() || ctl->is_IfTrue()) && ctl->in(0)->is_If()) {\n-      IfNode* iff = ctl->in(0)->as_If();\n-      Node* not_ctl = iff->proj_out_or_null(1 - ctl->as_Proj()->_con);\n-      assert(not_ctl != NULL && not_ctl != ctl, \"found alternate\");\n-      if (slow_region != NULL && slow_region->find_edge(not_ctl) >= 1) {\n-        ctl = iff->in(0);       \/\/ This test feeds the known slow_region.\n-        continue;\n-      }\n-      \/\/ One more try:  Various low-level checks bottom out in\n-      \/\/ uncommon traps.  If the debug-info of the trap omits\n-      \/\/ any reference to the allocation, as we've already\n-      \/\/ observed, then there can be no objection to the trap.\n-      bool found_trap = false;\n-      for (DUIterator_Fast jmax, j = not_ctl->fast_outs(jmax); j < jmax; j++) {\n-        Node* obs = not_ctl->fast_out(j);\n-        if (obs->in(0) == not_ctl && obs->is_Call() &&\n-            (obs->as_Call()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n-          found_trap = true; break;\n+    \/\/ This code is removed by \"8263615: Cleanup tightly_coupled_allocation\"\n+    \/\/ I had to adapt it when backporting \"8297730: C2: Arraycopy intrinsic throws incorrect exception\"\n+    if (slow_region != NULL) {\n+      if ((ctl->is_IfFalse() || ctl->is_IfTrue()) && ctl->in(0)->is_If()) {\n+        IfNode* iff = ctl->in(0)->as_If();\n+        Node* not_ctl = iff->proj_out_or_null(1 - ctl->as_Proj()->_con);\n+        if (slow_region->find_edge(not_ctl) >= 1) {\n+          ctl = iff->in(0);       \/\/ This test feeds the known slow_region.\n+          continue;\n@@ -4983,4 +5048,0 @@\n-      if (found_trap) {\n-        ctl = iff->in(0);       \/\/ This test feeds a harmless uncommon trap.\n-        continue;\n-      }\n@@ -4988,1 +5049,9 @@\n-    return NULL;\n+    \/\/ Various low-level checks bottom out in uncommon traps. These\n+    \/\/ are considered safe since we've already checked above that\n+    \/\/ there is no unexpected observer of this allocation.\n+    if (get_uncommon_trap_from_success_proj(ctl) != NULL) {\n+      assert(ctl->in(0)->is_If(), \"must be If\");\n+      ctl = ctl->in(0)->in(0);\n+    } else {\n+      return NULL;\n+    }\n@@ -4999,0 +5068,14 @@\n+CallStaticJavaNode* LibraryCallKit::get_uncommon_trap_from_success_proj(Node* node) {\n+  if (node->is_IfProj()) {\n+    Node* other_proj = node->as_IfProj()->other_if_proj();\n+    for (DUIterator_Fast jmax, j = other_proj->fast_outs(jmax); j < jmax; j++) {\n+      Node* obs = other_proj->fast_out(j);\n+      if (obs->in(0) == other_proj && obs->is_CallStaticJava() &&\n+          (obs->as_CallStaticJava()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n+        return obs->as_CallStaticJava();\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":143,"deletions":60,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -3243,1 +3243,6 @@\n-  Node* final_iv = new SubINode(exact_limit, cl->stride());\n+\n+  \/\/ We need to pin the exact limit to prevent it from floating above the zero trip guard.\n+  Node * cast_ii = ConstraintCastNode::make_cast(Op_CastII, cl->in(LoopNode::EntryControl), exact_limit, phase->_igvn.type(exact_limit), true);\n+  phase->register_new_node(cast_ii, cl->in(LoopNode::EntryControl));\n+\n+  Node* final_iv = new SubINode(cast_ii, cl->stride());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-          register_new_node( add1, n_loop->_head->in(LoopNode::EntryControl) );\n+          register_new_node( add1, n_loop->_head->as_Loop()->skip_strip_mined(1)->in(LoopNode::EntryControl) );\n@@ -528,1 +528,1 @@\n-          register_new_node(add1, n_loop->_head->in(LoopNode::EntryControl));\n+          register_new_node(add1, n_loop->_head->as_Loop()->skip_strip_mined(1)->in(LoopNode::EntryControl));\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -613,2 +613,0 @@\n-  C->set_default_node_notes(caller_nn);\n-\n@@ -625,0 +623,4 @@\n+  \/\/ Only reset this now, to make sure that debug information emitted\n+  \/\/ for exiting control flow still refers to the inlined method.\n+  C->set_default_node_notes(caller_nn);\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -485,0 +485,8 @@\n+  GrowableArray<Node_Notes*>* old_node_note_array = C->node_note_array();\n+  if (old_node_note_array != NULL) {\n+    int new_size = (_useful.size() >> 8) + 1; \/\/ The node note array uses blocks, see C->_log2_node_notes_block_size\n+    new_size = MAX2(8, new_size);\n+    C->set_node_note_array(new (C->comp_arena()) GrowableArray<Node_Notes*> (C->comp_arena(), new_size, 0, NULL));\n+    C->grow_node_notes(C->node_note_array(), new_size);\n+  }\n+\n@@ -500,0 +508,5 @@\n+    if (old_node_note_array != NULL) {\n+      Node_Notes* nn = C->locate_node_notes(old_node_note_array, n->_idx);\n+      C->set_node_notes_at(current_idx, nn);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1835,1 +1835,1 @@\n-WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))\n+WB_ENTRY(jboolean, WB_IsCDSIncluded(JNIEnv* env))\n@@ -1854,1 +1854,1 @@\n-WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))\n+WB_ENTRY(jboolean, WB_IsJFRIncluded(JNIEnv* env))\n@@ -2285,2 +2285,2 @@\n-  {CC\"isCDSIncludedInVmBuild\",            CC\"()Z\",    (void*)&WB_IsCDSIncludedInVmBuild },\n-  {CC\"isJFRIncludedInVmBuild\",            CC\"()Z\",    (void*)&WB_IsJFRIncludedInVmBuild },\n+  {CC\"isCDSIncluded\",                     CC\"()Z\",    (void*)&WB_IsCDSIncluded },\n+  {CC\"isJFRIncluded\",                     CC\"()Z\",    (void*)&WB_IsJFRIncluded },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-     * Algorithm identifiers and corresponding OIDs for the contents of the PKCS12 bag we get from the Keychain.\n+     * Algorithm identifiers and corresponding OIDs for the contents of the\n+     * PKCS12 bag we get from the Keychain.\n@@ -113,4 +114,4 @@\n-    private static final int keyBag[]  = {1, 2, 840, 113549, 1, 12, 10, 1, 2};\n-    private static final int pbeWithSHAAnd3KeyTripleDESCBC[] =     {1, 2, 840, 113549, 1, 12, 1, 3};\n-    private static ObjectIdentifier PKCS8ShroudedKeyBag_OID;\n-    private static ObjectIdentifier pbeWithSHAAnd3KeyTripleDESCBC_OID;\n+    private static ObjectIdentifier PKCS8ShroudedKeyBag_OID =\n+            ObjectIdentifier.of(KnownOIDs.PKCS8ShroudedKeyBag);\n+    private static ObjectIdentifier pbeWithSHAAnd3KeyTripleDESCBC_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBEWithSHA1AndDESede);\n@@ -134,6 +135,0 @@\n-        try {\n-            PKCS8ShroudedKeyBag_OID = new ObjectIdentifier(keyBag);\n-            pbeWithSHAAnd3KeyTripleDESCBC_OID = new ObjectIdentifier(pbeWithSHAAnd3KeyTripleDESCBC);\n-        } catch (IOException ioe) {\n-            \/\/ should not happen\n-        }\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/KeychainStore.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,0 @@\n-    private int DH_data[] = { 1, 2, 840, 113549, 1, 3, 1 };\n-\n@@ -222,1 +220,1 @@\n-                algid.putOID(new ObjectIdentifier(DH_data));\n+                algid.putOID(DHPublicKey.DH_OID);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,3 @@\n-    private int DH_data[] = { 1, 2, 840, 113549, 1, 3, 1 };\n+    \/\/ Note: this OID is used by DHPrivateKey as well.\n+    static ObjectIdentifier DH_OID =\n+            ObjectIdentifier.of(KnownOIDs.DiffieHellman);\n@@ -205,1 +207,1 @@\n-                algid.putOID(new ObjectIdentifier(DH_data));\n+                algid.putOID(DH_OID);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -70,8 +71,0 @@\n-    \/\/ defined by SunSoft (SKI project)\n-    private static final String PBE_WITH_MD5_AND_DES3_CBC_OID\n-            = \"1.3.6.1.4.1.42.2.19.1\";\n-\n-    \/\/ JavaSoft proprietary key-protection algorithm (used to protect private\n-    \/\/ keys in the keystore implementation that comes with JDK 1.2)\n-    private static final String KEY_PROTECTOR_OID = \"1.3.6.1.4.1.42.2.17.1.1\";\n-\n@@ -157,1 +150,2 @@\n-            (new ObjectIdentifier(PBE_WITH_MD5_AND_DES3_CBC_OID), pbeParams);\n+            (ObjectIdentifier.of(KnownOIDs.JAVASOFT_JCEKeyProtector),\n+             pbeParams);\n@@ -172,2 +166,2 @@\n-            if (!encrAlg.equals(PBE_WITH_MD5_AND_DES3_CBC_OID)\n-                && !encrAlg.equals(KEY_PROTECTOR_OID)) {\n+            if (!encrAlg.equals(KnownOIDs.JAVASOFT_JCEKeyProtector.value())\n+                && !encrAlg.equals(KnownOIDs.JAVASOFT_JDKKeyProtector.value())) {\n@@ -178,1 +172,1 @@\n-            if (encrAlg.equals(KEY_PROTECTOR_OID)) {\n+            if (encrAlg.equals(KnownOIDs.JAVASOFT_JDKKeyProtector.value())) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -58,18 +58,4 @@\n-    private static ObjectIdentifier OID_MGF1;\n-    private static ObjectIdentifier OID_PSpecified;\n-\n-    static {\n-        try {\n-            OID_MGF1 = new ObjectIdentifier(new int[] {1,2,840,113549,1,1,8});\n-        } catch (IOException ioe) {\n-            \/\/ should not happen\n-            OID_MGF1 = null;\n-        }\n-        try {\n-            OID_PSpecified =\n-                new ObjectIdentifier(new int[] {1,2,840,113549,1,1,9});\n-        } catch (IOException ioe) {\n-            \/\/ should not happen\n-            OID_PSpecified = null;\n-        }\n-    }\n+    private static ObjectIdentifier OID_MGF1 =\n+            ObjectIdentifier.of(KnownOIDs.MGF1);\n+    private static ObjectIdentifier OID_PSpecified =\n+            ObjectIdentifier.of(KnownOIDs.PSpecified);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/OAEPParameters.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,0 @@\n-\n@@ -96,48 +95,10 @@\n-    private static final int pkcs5PBKDF2[] =\n-                                        {1, 2, 840, 113549, 1, 5, 12};\n-    private static final int pkcs5PBES2[] =\n-                                        {1, 2, 840, 113549, 1, 5, 13};\n-    private static final int hmacWithSHA1[] =\n-                                        {1, 2, 840, 113549, 2, 7};\n-    private static final int hmacWithSHA224[] =\n-                                        {1, 2, 840, 113549, 2, 8};\n-    private static final int hmacWithSHA256[] =\n-                                        {1, 2, 840, 113549, 2, 9};\n-    private static final int hmacWithSHA384[] =\n-                                        {1, 2, 840, 113549, 2, 10};\n-    private static final int hmacWithSHA512[] =\n-                                        {1, 2, 840, 113549, 2, 11};\n-    private static final int aes128CBC[] =\n-                                        {2, 16, 840, 1, 101, 3, 4, 1, 2};\n-    private static final int aes192CBC[] =\n-                                        {2, 16, 840, 1, 101, 3, 4, 1, 22};\n-    private static final int aes256CBC[] =\n-                                        {2, 16, 840, 1, 101, 3, 4, 1, 42};\n-\n-    private static ObjectIdentifier pkcs5PBKDF2_OID;\n-    private static ObjectIdentifier pkcs5PBES2_OID;\n-    private static ObjectIdentifier hmacWithSHA1_OID;\n-    private static ObjectIdentifier hmacWithSHA224_OID;\n-    private static ObjectIdentifier hmacWithSHA256_OID;\n-    private static ObjectIdentifier hmacWithSHA384_OID;\n-    private static ObjectIdentifier hmacWithSHA512_OID;\n-    private static ObjectIdentifier aes128CBC_OID;\n-    private static ObjectIdentifier aes192CBC_OID;\n-    private static ObjectIdentifier aes256CBC_OID;\n-\n-    static {\n-        try {\n-            pkcs5PBKDF2_OID = new ObjectIdentifier(pkcs5PBKDF2);\n-            pkcs5PBES2_OID = new ObjectIdentifier(pkcs5PBES2);\n-            hmacWithSHA1_OID = new ObjectIdentifier(hmacWithSHA1);\n-            hmacWithSHA224_OID = new ObjectIdentifier(hmacWithSHA224);\n-            hmacWithSHA256_OID = new ObjectIdentifier(hmacWithSHA256);\n-            hmacWithSHA384_OID = new ObjectIdentifier(hmacWithSHA384);\n-            hmacWithSHA512_OID = new ObjectIdentifier(hmacWithSHA512);\n-            aes128CBC_OID = new ObjectIdentifier(aes128CBC);\n-            aes192CBC_OID = new ObjectIdentifier(aes192CBC);\n-            aes256CBC_OID = new ObjectIdentifier(aes256CBC);\n-        } catch (IOException ioe) {\n-            \/\/ should not happen\n-        }\n-    }\n+    private static ObjectIdentifier pkcs5PBKDF2_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBKDF2WithHmacSHA1);\n+    private static ObjectIdentifier pkcs5PBES2_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBES2);\n+    private static ObjectIdentifier aes128CBC_OID =\n+            ObjectIdentifier.of(KnownOIDs.AES_128$CBC$NoPadding);\n+    private static ObjectIdentifier aes192CBC_OID =\n+            ObjectIdentifier.of(KnownOIDs.AES_192$CBC$NoPadding);\n+    private static ObjectIdentifier aes256CBC_OID =\n+            ObjectIdentifier.of(KnownOIDs.AES_256$CBC$NoPadding);\n@@ -158,1 +119,2 @@\n-    private ObjectIdentifier kdfAlgo_OID = hmacWithSHA1_OID;\n+    private ObjectIdentifier kdfAlgo_OID =\n+            ObjectIdentifier.of(KnownOIDs.HmacSHA1);\n@@ -203,2 +165,0 @@\n-            kdfAlgo_OID = hmacWithSHA1_OID;\n-            break;\n@@ -206,2 +166,0 @@\n-            kdfAlgo_OID = hmacWithSHA224_OID;\n-            break;\n@@ -209,2 +167,0 @@\n-            kdfAlgo_OID = hmacWithSHA256_OID;\n-            break;\n@@ -212,2 +168,0 @@\n-            kdfAlgo_OID = hmacWithSHA384_OID;\n-            break;\n@@ -215,1 +169,1 @@\n-            kdfAlgo_OID = hmacWithSHA512_OID;\n+            kdfAlgo_OID = ObjectIdentifier.of(KnownOIDs.findMatch(kdfAlgo));\n@@ -287,1 +241,1 @@\n-        pbes2AlgorithmName = new StringBuilder().append(\"PBEWith\")\n+        this.pbes2AlgorithmName = new StringBuilder().append(\"PBEWith\")\n@@ -338,11 +292,6 @@\n-            if (hmacWithSHA1_OID.equals(kdfAlgo_OID)) {\n-                kdfAlgo = \"HmacSHA1\";\n-            } else if (hmacWithSHA224_OID.equals(kdfAlgo_OID)) {\n-                kdfAlgo = \"HmacSHA224\";\n-            } else if (hmacWithSHA256_OID.equals(kdfAlgo_OID)) {\n-                kdfAlgo = \"HmacSHA256\";\n-            } else if (hmacWithSHA384_OID.equals(kdfAlgo_OID)) {\n-                kdfAlgo = \"HmacSHA384\";\n-            } else if (hmacWithSHA512_OID.equals(kdfAlgo_OID)) {\n-                kdfAlgo = \"HmacSHA512\";\n-            } else {\n+            KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());\n+            if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                !o.stdName().equals(\"HmacSHA224\") &&\n+                !o.stdName().equals(\"HmacSHA256\") &&\n+                !o.stdName().equals(\"HmacSHA384\") &&\n+                !o.stdName().equals(\"HmacSHA512\"))) {\n@@ -353,0 +302,2 @@\n+            kdfAlgo = o.stdName();\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":23,"deletions":72,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-import static sun.security.provider.SunEntries.createAliases;\n-import static sun.security.provider.SunEntries.createAliasesWithOid;\n+import static sun.security.util.SecurityProviderConstants.*;\n@@ -102,3 +101,16 @@\n-    private void ps(String type, String algo, String cn,\n-            List<String> aliases, HashMap<String, String> attrs) {\n-        putService(new Provider.Service(this, type, algo, cn, aliases, attrs));\n+    \/\/ ps: putService\n+    private void ps(String type, String algo, String cn) {\n+        putService(new Provider.Service(this, type, algo, cn, null, null));\n+    }\n+\n+    private void ps(String type, String algo, String cn, List<String> als,\n+            HashMap<String, String> attrs) {\n+        putService(new Provider.Service(this, type, algo, cn, als,\n+                   attrs));\n+    }\n+\n+    \/\/ psA: putService with default aliases\n+    private void psA(String type, String algo, String cn,\n+            HashMap<String, String> attrs) {\n+        putService(new Provider.Service(this, type, algo, cn, getAliases(algo),\n+                   attrs));\n@@ -130,51 +142,0 @@\n-        \/\/ common aliases and oids\n-        List<String> aesAliases = createAliases(\"Rijndael\");\n-        List<String> desEdeAliases = createAliases(\"TripleDES\");\n-        List<String> arcFourAliases = createAliases(\"RC4\");\n-        List<String> sunTlsMSAliases = createAliases(\n-            \"SunTls12MasterSecret\", \"SunTlsExtendedMasterSecret\"\n-        );\n-        List<String> sunTlsKMAliases = createAliases(\"SunTls12KeyMaterial\");\n-        List<String> sunTlsRsaPMSAliases = createAliases(\"SunTls12RsaPremasterSecret\");\n-\n-        String aes128Oid = \"2.16.840.1.101.3.4.1.\";\n-        String aes192Oid = \"2.16.840.1.101.3.4.1.2\";\n-        String aes256Oid = \"2.16.840.1.101.3.4.1.4\";\n-\n-        List<String> pkcs12RC4_128Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.12.1.1\");\n-\n-        List<String> pkcs12RC4_40Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.12.1.2\");\n-\n-        List<String> pkcs12DESedeAliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.12.1.3\");\n-\n-        List<String> pkcs12RC2_128Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.12.1.5\");\n-\n-        List<String> pkcs12RC2_40Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.12.1.6\");\n-\n-        List<String> pkcs5MD5_DESAliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.5.3\", \"PBE\");\n-\n-        List<String> pkcs5PBKDF2Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.5.12\");\n-\n-        List<String> pkcs5PBES2Aliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.5.13\");\n-\n-        List<String> diffieHellmanAliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.3.1\", \"DH\");\n-\n-        List<String> chachaPolyAliases =\n-            createAliasesWithOid(\"1.2.840.113549.1.9.16.3.18\");\n-\n-        String macOidBase = \"1.2.840.113549.2.\";\n-        List<String> macSHA1Aliases = createAliasesWithOid(macOidBase + \"7\");\n-        List<String> macSHA224Aliases = createAliasesWithOid(macOidBase + \"8\");\n-        List<String> macSHA256Aliases = createAliasesWithOid(macOidBase + \"9\");\n-        List<String> macSHA384Aliases = createAliasesWithOid(macOidBase + \"10\");\n-        List<String> macSHA512Aliases = createAliasesWithOid(macOidBase + \"11\");\n-\n@@ -215,2 +176,2 @@\n-        ps(\"Cipher\", \"DESede\", \"com.sun.crypto.provider.DESedeCipher\",\n-                desEdeAliases, attrs);\n+        psA(\"Cipher\", \"DESede\", \"com.sun.crypto.provider.DESedeCipher\",\n+                attrs);\n@@ -227,2 +188,2 @@\n-        ps(\"Cipher\", \"AES\", \"com.sun.crypto.provider.AESCipher$General\",\n-                aesAliases, attrs);\n+        psA(\"Cipher\", \"AES\",\n+                \"com.sun.crypto.provider.AESCipher$General\", attrs);\n@@ -232,1 +193,1 @@\n-        ps(\"Cipher\", \"AES_128\/ECB\/NoPadding\",\n+        psA(\"Cipher\", \"AES_128\/ECB\/NoPadding\",\n@@ -234,2 +195,2 @@\n-                createAliasesWithOid(aes128Oid+\"1\"), attrs);\n-        ps(\"Cipher\", \"AES_128\/CBC\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_128\/CBC\/NoPadding\",\n@@ -237,2 +198,2 @@\n-                createAliasesWithOid(aes128Oid+\"2\"), attrs);\n-        ps(\"Cipher\", \"AES_128\/OFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_128\/OFB\/NoPadding\",\n@@ -240,2 +201,2 @@\n-                createAliasesWithOid(aes128Oid+\"3\"), attrs);\n-        ps(\"Cipher\", \"AES_128\/CFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_128\/CFB\/NoPadding\",\n@@ -243,2 +204,2 @@\n-                createAliasesWithOid(aes128Oid+\"4\"), attrs);\n-        ps(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n@@ -246,1 +207,1 @@\n-                createAliasesWithOid(aes128Oid+\"6\"), attrs);\n+                attrs);\n@@ -248,1 +209,1 @@\n-        ps(\"Cipher\", \"AES_192\/ECB\/NoPadding\",\n+        psA(\"Cipher\", \"AES_192\/ECB\/NoPadding\",\n@@ -250,2 +211,2 @@\n-                createAliasesWithOid(aes192Oid+\"1\"), attrs);\n-        ps(\"Cipher\", \"AES_192\/CBC\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_192\/CBC\/NoPadding\",\n@@ -253,2 +214,2 @@\n-                createAliasesWithOid(aes192Oid+\"2\"), attrs);\n-        ps(\"Cipher\", \"AES_192\/OFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_192\/OFB\/NoPadding\",\n@@ -256,2 +217,2 @@\n-                createAliasesWithOid(aes192Oid+\"3\"), attrs);\n-        ps(\"Cipher\", \"AES_192\/CFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_192\/CFB\/NoPadding\",\n@@ -259,2 +220,2 @@\n-                createAliasesWithOid(aes192Oid+\"4\"), attrs);\n-        ps(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n@@ -262,1 +223,1 @@\n-                createAliasesWithOid(aes192Oid+\"6\"), attrs);\n+                attrs);\n@@ -264,1 +225,1 @@\n-        ps(\"Cipher\", \"AES_256\/ECB\/NoPadding\",\n+        psA(\"Cipher\", \"AES_256\/ECB\/NoPadding\",\n@@ -266,2 +227,2 @@\n-                createAliasesWithOid(aes256Oid+\"1\"), attrs);\n-        ps(\"Cipher\", \"AES_256\/CBC\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_256\/CBC\/NoPadding\",\n@@ -269,2 +230,2 @@\n-                createAliasesWithOid(aes256Oid+\"2\"), attrs);\n-        ps(\"Cipher\", \"AES_256\/OFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_256\/OFB\/NoPadding\",\n@@ -272,2 +233,2 @@\n-                createAliasesWithOid(aes256Oid+\"3\"), attrs);\n-        ps(\"Cipher\", \"AES_256\/CFB\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_256\/CFB\/NoPadding\",\n@@ -275,2 +236,2 @@\n-                createAliasesWithOid(aes256Oid+\"4\"), attrs);\n-        ps(\"Cipher\", \"AES_256\/GCM\/NoPadding\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_256\/GCM\/NoPadding\",\n@@ -278,1 +239,1 @@\n-                createAliasesWithOid(aes256Oid+\"6\"), attrs);\n+                attrs);\n@@ -291,2 +252,2 @@\n-        ps(\"Cipher\", \"ARCFOUR\", \"com.sun.crypto.provider.ARCFOURCipher\",\n-                arcFourAliases, attrs);\n+        psA(\"Cipher\", \"ARCFOUR\",\n+                \"com.sun.crypto.provider.ARCFOURCipher\", attrs);\n@@ -295,1 +256,1 @@\n-        ps(\"Cipher\", \"AESWrap_128\",\n+        psA(\"Cipher\", \"AESWrap_128\",\n@@ -297,2 +258,2 @@\n-                createAliasesWithOid(aes128Oid+\"5\"), attrs);\n-        ps(\"Cipher\", \"AESWrap_192\",\n+                attrs);\n+        psA(\"Cipher\", \"AESWrap_192\",\n@@ -300,2 +261,2 @@\n-                createAliasesWithOid(aes192Oid+\"5\"), attrs);\n-        ps(\"Cipher\", \"AESWrap_256\",\n+                attrs);\n+        psA(\"Cipher\", \"AESWrap_256\",\n@@ -303,1 +264,1 @@\n-                createAliasesWithOid(aes256Oid+\"5\"), attrs);\n+                attrs);\n@@ -310,1 +271,1 @@\n-        ps(\"Cipher\",  \"ChaCha20-Poly1305\",\n+        psA(\"Cipher\",  \"ChaCha20-Poly1305\",\n@@ -312,1 +273,1 @@\n-                chachaPolyAliases, attrs);\n+                attrs);\n@@ -315,1 +276,1 @@\n-        ps(\"Cipher\", \"PBEWithMD5AndDES\",\n+        psA(\"Cipher\", \"PBEWithMD5AndDES\",\n@@ -317,1 +278,1 @@\n-                pkcs5MD5_DESAliases, null);\n+                null);\n@@ -319,3 +280,2 @@\n-                \"com.sun.crypto.provider.PBEWithMD5AndTripleDESCipher\",\n-                null, null);\n-        ps(\"Cipher\", \"PBEWithSHA1AndDESede\",\n+                \"com.sun.crypto.provider.PBEWithMD5AndTripleDESCipher\");\n+        psA(\"Cipher\", \"PBEWithSHA1AndDESede\",\n@@ -323,2 +283,2 @@\n-                pkcs12DESedeAliases, null);\n-        ps(\"Cipher\", \"PBEWithSHA1AndRC2_40\",\n+                null);\n+        psA(\"Cipher\", \"PBEWithSHA1AndRC2_40\",\n@@ -326,2 +286,2 @@\n-                pkcs12RC2_40Aliases, null);\n-        ps(\"Cipher\", \"PBEWithSHA1AndRC2_128\",\n+                null);\n+        psA(\"Cipher\", \"PBEWithSHA1AndRC2_128\",\n@@ -329,2 +289,2 @@\n-                pkcs12RC2_128Aliases, null);\n-        ps(\"Cipher\", \"PBEWithSHA1AndRC4_40\",\n+                null);\n+        psA(\"Cipher\", \"PBEWithSHA1AndRC4_40\",\n@@ -332,1 +292,1 @@\n-                pkcs12RC4_40Aliases, null);\n+                null);\n@@ -334,1 +294,1 @@\n-        ps(\"Cipher\", \"PBEWithSHA1AndRC4_128\",\n+        psA(\"Cipher\", \"PBEWithSHA1AndRC4_128\",\n@@ -336,1 +296,1 @@\n-                pkcs12RC4_128Aliases, null);\n+                null);\n@@ -340,2 +300,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA1AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA1AndAES_128\");\n@@ -344,2 +303,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA224AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA224AndAES_128\");\n@@ -348,2 +306,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA256AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA256AndAES_128\");\n@@ -352,2 +309,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA384AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA384AndAES_128\");\n@@ -356,2 +312,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA512AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA512AndAES_128\");\n@@ -360,2 +315,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA1AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA1AndAES_256\");\n@@ -364,2 +318,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA224AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA224AndAES_256\");\n@@ -368,2 +321,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA256AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA256AndAES_256\");\n@@ -372,2 +324,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA384AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA384AndAES_256\");\n@@ -376,2 +327,1 @@\n-                \"com.sun.crypto.provider.PBES2Core$HmacSHA512AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Core$HmacSHA512AndAES_256\");\n@@ -383,3 +333,2 @@\n-                \"com.sun.crypto.provider.DESKeyGenerator\",\n-                null, null);\n-        ps(\"KeyGenerator\", \"DESede\",\n+                \"com.sun.crypto.provider.DESKeyGenerator\");\n+        psA(\"KeyGenerator\", \"DESede\",\n@@ -387,1 +336,1 @@\n-                desEdeAliases, null);\n+                null);\n@@ -389,3 +338,2 @@\n-                \"com.sun.crypto.provider.BlowfishKeyGenerator\",\n-                null, null);\n-        ps(\"KeyGenerator\", \"AES\",\n+                \"com.sun.crypto.provider.BlowfishKeyGenerator\");\n+        psA(\"KeyGenerator\", \"AES\",\n@@ -393,1 +341,1 @@\n-                aesAliases, null);\n+                null);\n@@ -395,3 +343,2 @@\n-                \"com.sun.crypto.provider.KeyGeneratorCore$RC2KeyGenerator\",\n-                null, null);\n-        ps(\"KeyGenerator\", \"ARCFOUR\",\n+                \"com.sun.crypto.provider.KeyGeneratorCore$RC2KeyGenerator\");\n+        psA(\"KeyGenerator\", \"ARCFOUR\",\n@@ -399,1 +346,1 @@\n-                arcFourAliases, null);\n+                null);\n@@ -401,2 +348,1 @@\n-                \"com.sun.crypto.provider.KeyGeneratorCore$ChaCha20KeyGenerator\",\n-                null, null);\n+                \"com.sun.crypto.provider.KeyGeneratorCore$ChaCha20KeyGenerator\");\n@@ -404,2 +350,1 @@\n-                \"com.sun.crypto.provider.HmacMD5KeyGenerator\",\n-                null, null);\n+                \"com.sun.crypto.provider.HmacMD5KeyGenerator\");\n@@ -407,4 +352,3 @@\n-        ps(\"KeyGenerator\", \"HmacSHA1\",\n-                \"com.sun.crypto.provider.HmacSHA1KeyGenerator\",\n-                macSHA1Aliases, null);\n-        ps(\"KeyGenerator\", \"HmacSHA224\",\n+        psA(\"KeyGenerator\", \"HmacSHA1\",\n+                \"com.sun.crypto.provider.HmacSHA1KeyGenerator\", null);\n+        psA(\"KeyGenerator\", \"HmacSHA224\",\n@@ -412,2 +356,2 @@\n-                macSHA224Aliases, null);\n-        ps(\"KeyGenerator\", \"HmacSHA256\",\n+                null);\n+        psA(\"KeyGenerator\", \"HmacSHA256\",\n@@ -415,2 +359,2 @@\n-                macSHA256Aliases, null);\n-        ps(\"KeyGenerator\", \"HmacSHA384\",\n+                null);\n+        psA(\"KeyGenerator\", \"HmacSHA384\",\n@@ -418,2 +362,2 @@\n-                macSHA384Aliases, null);\n-        ps(\"KeyGenerator\", \"HmacSHA512\",\n+                null);\n+        psA(\"KeyGenerator\", \"HmacSHA512\",\n@@ -421,1 +365,1 @@\n-                macSHA512Aliases, null);\n+                null);\n@@ -423,1 +367,1 @@\n-        ps(\"KeyPairGenerator\", \"DiffieHellman\",\n+        psA(\"KeyPairGenerator\", \"DiffieHellman\",\n@@ -425,1 +369,1 @@\n-                diffieHellmanAliases, null);\n+                null);\n@@ -430,1 +374,1 @@\n-        ps(\"AlgorithmParameterGenerator\",\n+        psA(\"AlgorithmParameterGenerator\",\n@@ -432,1 +376,1 @@\n-                diffieHellmanAliases, null);\n+                null);\n@@ -440,1 +384,1 @@\n-        ps(\"KeyAgreement\", \"DiffieHellman\",\n+        psA(\"KeyAgreement\", \"DiffieHellman\",\n@@ -442,1 +386,1 @@\n-                diffieHellmanAliases, attrs);\n+                attrs);\n@@ -447,3 +391,2 @@\n-        ps(\"AlgorithmParameters\", \"DiffieHellman\",\n-                \"com.sun.crypto.provider.DHParameters\",\n-                diffieHellmanAliases, null);\n+        psA(\"AlgorithmParameters\", \"DiffieHellman\",\n+                \"com.sun.crypto.provider.DHParameters\", null);\n@@ -452,2 +395,1 @@\n-                \"com.sun.crypto.provider.DESParameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.DESParameters\");\n@@ -455,3 +397,2 @@\n-        ps(\"AlgorithmParameters\", \"DESede\",\n-                \"com.sun.crypto.provider.DESedeParameters\",\n-                desEdeAliases, null);\n+        psA(\"AlgorithmParameters\", \"DESede\",\n+                \"com.sun.crypto.provider.DESedeParameters\", null);\n@@ -459,1 +400,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithMD5AndDES\",\n+        psA(\"AlgorithmParameters\", \"PBEWithMD5AndDES\",\n@@ -461,1 +402,1 @@\n-                pkcs5MD5_DESAliases, null);\n+                null);\n@@ -464,2 +405,1 @@\n-                \"com.sun.crypto.provider.PBEParameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEParameters\");\n@@ -467,1 +407,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithSHA1AndDESede\",\n+        psA(\"AlgorithmParameters\", \"PBEWithSHA1AndDESede\",\n@@ -469,1 +409,1 @@\n-                pkcs12DESedeAliases, null);\n+                null);\n@@ -471,1 +411,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithSHA1AndRC2_40\",\n+        psA(\"AlgorithmParameters\", \"PBEWithSHA1AndRC2_40\",\n@@ -473,1 +413,1 @@\n-                pkcs12RC2_40Aliases, null);\n+                null);\n@@ -475,1 +415,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithSHA1AndRC2_128\",\n+        psA(\"AlgorithmParameters\", \"PBEWithSHA1AndRC2_128\",\n@@ -477,1 +417,1 @@\n-                pkcs12RC2_128Aliases, null);\n+                null);\n@@ -479,1 +419,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithSHA1AndRC4_40\",\n+        psA(\"AlgorithmParameters\", \"PBEWithSHA1AndRC4_40\",\n@@ -481,1 +421,1 @@\n-                pkcs12RC4_40Aliases, null);\n+                null);\n@@ -483,1 +423,1 @@\n-        ps(\"AlgorithmParameters\", \"PBEWithSHA1AndRC4_128\",\n+        psA(\"AlgorithmParameters\", \"PBEWithSHA1AndRC4_128\",\n@@ -485,1 +425,1 @@\n-                pkcs12RC4_128Aliases, null);\n+                null);\n@@ -487,1 +427,1 @@\n-        ps(\"AlgorithmParameters\", \"PBES2\",\n+        psA(\"AlgorithmParameters\", \"PBES2\",\n@@ -489,1 +429,1 @@\n-                pkcs5PBES2Aliases, null);\n+                null);\n@@ -492,2 +432,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA1AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA1AndAES_128\");\n@@ -496,2 +435,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA224AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA224AndAES_128\");\n@@ -500,2 +438,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA256AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA256AndAES_128\");\n@@ -504,2 +441,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA384AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA384AndAES_128\");\n@@ -508,2 +444,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA512AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA512AndAES_128\");\n@@ -512,2 +447,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA1AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA1AndAES_256\");\n@@ -516,2 +450,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA224AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA224AndAES_256\");\n@@ -520,2 +453,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA256AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA256AndAES_256\");\n@@ -524,2 +456,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA384AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA384AndAES_256\");\n@@ -528,2 +459,1 @@\n-                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA512AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBES2Parameters$HmacSHA512AndAES_256\");\n@@ -532,2 +462,1 @@\n-                \"com.sun.crypto.provider.BlowfishParameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.BlowfishParameters\");\n@@ -535,3 +464,2 @@\n-        ps(\"AlgorithmParameters\", \"AES\",\n-                \"com.sun.crypto.provider.AESParameters\",\n-                aesAliases, null);\n+        psA(\"AlgorithmParameters\", \"AES\",\n+                \"com.sun.crypto.provider.AESParameters\", null);\n@@ -540,2 +468,1 @@\n-                \"com.sun.crypto.provider.GCMParameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.GCMParameters\");\n@@ -544,2 +471,1 @@\n-                \"com.sun.crypto.provider.RC2Parameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.RC2Parameters\");\n@@ -548,2 +474,1 @@\n-                \"com.sun.crypto.provider.OAEPParameters\",\n-                null, null);\n+                \"com.sun.crypto.provider.OAEPParameters\");\n@@ -551,3 +476,2 @@\n-        ps(\"AlgorithmParameters\", \"ChaCha20-Poly1305\",\n-                \"com.sun.crypto.provider.ChaCha20Poly1305Parameters\",\n-                chachaPolyAliases, null);\n+        psA(\"AlgorithmParameters\", \"ChaCha20-Poly1305\",\n+                \"com.sun.crypto.provider.ChaCha20Poly1305Parameters\", null);\n@@ -558,1 +482,1 @@\n-        ps(\"KeyFactory\", \"DiffieHellman\",\n+        psA(\"KeyFactory\", \"DiffieHellman\",\n@@ -560,1 +484,1 @@\n-                diffieHellmanAliases, null);\n+                null);\n@@ -566,2 +490,1 @@\n-                \"com.sun.crypto.provider.DESKeyFactory\",\n-                null, null);\n+                \"com.sun.crypto.provider.DESKeyFactory\");\n@@ -569,3 +492,2 @@\n-        ps(\"SecretKeyFactory\", \"DESede\",\n-                \"com.sun.crypto.provider.DESedeKeyFactory\",\n-                desEdeAliases, null);\n+        psA(\"SecretKeyFactory\", \"DESede\",\n+                \"com.sun.crypto.provider.DESedeKeyFactory\", null);\n@@ -573,1 +495,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithMD5AndDES\",\n+        psA(\"SecretKeyFactory\", \"PBEWithMD5AndDES\",\n@@ -575,1 +497,1 @@\n-                pkcs5MD5_DESAliases, null);\n+                null);\n@@ -584,2 +506,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithMD5AndTripleDES\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithMD5AndTripleDES\");\n@@ -587,1 +508,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithSHA1AndDESede\",\n+        psA(\"SecretKeyFactory\", \"PBEWithSHA1AndDESede\",\n@@ -589,1 +510,1 @@\n-                pkcs12DESedeAliases, null);\n+                null);\n@@ -591,1 +512,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithSHA1AndRC2_40\",\n+        psA(\"SecretKeyFactory\", \"PBEWithSHA1AndRC2_40\",\n@@ -593,1 +514,1 @@\n-                pkcs12RC2_40Aliases, null);\n+                null);\n@@ -595,1 +516,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithSHA1AndRC2_128\",\n+        psA(\"SecretKeyFactory\", \"PBEWithSHA1AndRC2_128\",\n@@ -597,1 +518,1 @@\n-                pkcs12RC2_128Aliases, null);\n+                null);\n@@ -599,1 +520,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithSHA1AndRC4_40\",\n+        psA(\"SecretKeyFactory\", \"PBEWithSHA1AndRC4_40\",\n@@ -601,1 +522,1 @@\n-                pkcs12RC4_40Aliases,null);\n+                null);\n@@ -603,1 +524,1 @@\n-        ps(\"SecretKeyFactory\", \"PBEWithSHA1AndRC4_128\",\n+        psA(\"SecretKeyFactory\", \"PBEWithSHA1AndRC4_128\",\n@@ -605,1 +526,1 @@\n-                pkcs12RC4_128Aliases, null);\n+                null);\n@@ -608,2 +529,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA1AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA1AndAES_128\");\n@@ -612,2 +532,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA224AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA224AndAES_128\");\n@@ -616,2 +535,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA256AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA256AndAES_128\");\n@@ -620,2 +538,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA384AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA384AndAES_128\");\n@@ -624,2 +541,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA512AndAES_128\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA512AndAES_128\");\n@@ -628,2 +544,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA1AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA1AndAES_256\");\n@@ -632,2 +547,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA224AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA224AndAES_256\");\n@@ -636,2 +550,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA256AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA256AndAES_256\");\n@@ -640,2 +553,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA384AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA384AndAES_256\");\n@@ -644,2 +556,1 @@\n-                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA512AndAES_256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBEKeyFactory$PBEWithHmacSHA512AndAES_256\");\n@@ -648,1 +559,1 @@\n-        ps(\"SecretKeyFactory\", \"PBKDF2WithHmacSHA1\",\n+        psA(\"SecretKeyFactory\", \"PBKDF2WithHmacSHA1\",\n@@ -650,1 +561,1 @@\n-                pkcs5PBKDF2Aliases, null);\n+                null);\n@@ -652,2 +563,1 @@\n-                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA224\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA224\");\n@@ -655,2 +565,1 @@\n-                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA256\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA256\");\n@@ -658,2 +567,1 @@\n-                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA384\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA384\");\n@@ -661,2 +569,1 @@\n-                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA512\",\n-                null, null);\n+                \"com.sun.crypto.provider.PBKDF2Core$HmacSHA512\");\n@@ -670,17 +577,14 @@\n-        ps(\"Mac\", \"HmacSHA1\", \"com.sun.crypto.provider.HmacSHA1\",\n-                macSHA1Aliases, attrs);\n-        ps(\"Mac\", \"HmacSHA224\", \"com.sun.crypto.provider.HmacCore$HmacSHA224\",\n-                macSHA224Aliases, attrs);\n-        ps(\"Mac\", \"HmacSHA256\", \"com.sun.crypto.provider.HmacCore$HmacSHA256\",\n-                macSHA256Aliases, attrs);\n-        ps(\"Mac\", \"HmacSHA384\", \"com.sun.crypto.provider.HmacCore$HmacSHA384\",\n-                macSHA384Aliases, attrs);\n-        ps(\"Mac\", \"HmacSHA512\", \"com.sun.crypto.provider.HmacCore$HmacSHA512\",\n-                macSHA512Aliases, attrs);\n-        \/\/ TODO: aliases with OIDs\n-        ps(\"Mac\", \"HmacSHA512\/224\",\n-                \"com.sun.crypto.provider.HmacCore$HmacSHA512_224\",\n-                null, attrs);\n-        ps(\"Mac\", \"HmacSHA512\/256\",\n-                \"com.sun.crypto.provider.HmacCore$HmacSHA512_256\",\n-                null, attrs);\n+        psA(\"Mac\", \"HmacSHA1\", \"com.sun.crypto.provider.HmacSHA1\",\n+                attrs);\n+        psA(\"Mac\", \"HmacSHA224\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA224\", attrs);\n+        psA(\"Mac\", \"HmacSHA256\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA256\", attrs);\n+        psA(\"Mac\", \"HmacSHA384\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA384\", attrs);\n+        psA(\"Mac\", \"HmacSHA512\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA512\", attrs);\n+        psA(\"Mac\", \"HmacSHA512\/224\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA512_224\", attrs);\n+        psA(\"Mac\", \"HmacSHA512\/256\",\n+                \"com.sun.crypto.provider.HmacCore$HmacSHA512_256\", attrs);\n@@ -730,2 +634,1 @@\n-                \"com.sun.crypto.provider.JceKeyStore\",\n-                null, null);\n+                \"com.sun.crypto.provider.JceKeyStore\");\n@@ -742,2 +645,1 @@\n-                \"com.sun.crypto.provider.TlsPrfGenerator$V10\",\n-                null, null);\n+                \"com.sun.crypto.provider.TlsPrfGenerator$V10\");\n@@ -745,2 +647,1 @@\n-                \"com.sun.crypto.provider.TlsPrfGenerator$V12\",\n-                null, null);\n+                \"com.sun.crypto.provider.TlsPrfGenerator$V12\");\n@@ -750,2 +651,2 @@\n-                createAliases(\"SunTls12MasterSecret\",\n-                    \"SunTlsExtendedMasterSecret\"), null);\n+                List.of(\"SunTls12MasterSecret\", \"SunTlsExtendedMasterSecret\"),\n+                null);\n@@ -755,1 +656,1 @@\n-                createAliases(\"SunTls12KeyMaterial\"), null);\n+                List.of(\"SunTls12KeyMaterial\"), null);\n@@ -759,1 +660,1 @@\n-                createAliases(\"SunTls12RsaPremasterSecret\"), null);\n+                List.of(\"SunTls12RsaPremasterSecret\"), null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":204,"deletions":303,"binary":false,"changes":507,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-        paramGenSpi.engineInit(size, JCAUtil.getSecureRandom());\n+        paramGenSpi.engineInit(size, JCAUtil.getDefSecureRandom());\n@@ -343,1 +343,1 @@\n-            paramGenSpi.engineInit(genParamSpec, JCAUtil.getSecureRandom());\n+            paramGenSpi.engineInit(genParamSpec, JCAUtil.getDefSecureRandom());\n","filename":"src\/java.base\/share\/classes\/java\/security\/AlgorithmParameterGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,1 +376,1 @@\n-        initialize(keysize, JCAUtil.getSecureRandom());\n+        initialize(keysize, JCAUtil.getDefSecureRandom());\n@@ -436,1 +436,1 @@\n-        initialize(params, JCAUtil.getSecureRandom());\n+        initialize(params, JCAUtil.getDefSecureRandom());\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPairGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            type = new ObjectIdentifier(name);\n+            type = ObjectIdentifier.of(name);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PKCS12Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+ * @implNote If the properties file fails to load, the JDK implementation will\n+ * throw an unspecified error when initializing the {@code Security} class.\n+ *\n@@ -188,5 +191,1 @@\n-            initializeStatic();\n-            if (sdebug != null) {\n-                sdebug.println(\"unable to load security properties \" +\n-                        \"-- using defaults\");\n-            }\n+            throw new InternalError(\"java.security file missing\");\n@@ -197,13 +196,0 @@\n-    \/*\n-     * Initialize to default values, if <java.home>\/lib\/java.security\n-     * is not found.\n-     *\/\n-    private static void initializeStatic() {\n-        props.put(\"security.provider.1\", \"sun.security.provider.Sun\");\n-        props.put(\"security.provider.2\", \"sun.security.rsa.SunRsaSign\");\n-        props.put(\"security.provider.3\", \"com.sun.net.ssl.internal.ssl.Provider\");\n-        props.put(\"security.provider.4\", \"com.sun.crypto.provider.SunJCE\");\n-        props.put(\"security.provider.5\", \"sun.security.jgss.SunProvider\");\n-        props.put(\"security.provider.6\", \"com.sun.security.sasl.Provider\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n@@ -37,0 +33,4 @@\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n@@ -355,1 +355,3 @@\n-        return certFacSpi.engineGenerateCertificate(inStream);\n+        Certificate c = certFacSpi.engineGenerateCertificate(inStream);\n+        JCAUtil.tryCommitCertEvent(c);\n+        return c;\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateFactory.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-                (new ObjectIdentifier(oid), critical, extVal);\n+                (ObjectIdentifier.of(oid), critical, extVal);\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateRevokedException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,1 @@\n-import sun.security.util.HexDumpEncoder;\n-import sun.security.util.Debug;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -91,1 +87,1 @@\n-        ObjectIdentifier.newInternal(new int[] {2, 5, 29, 37, 0});\n+        ObjectIdentifier.of(KnownOIDs.anyExtendedKeyUsage);\n@@ -509,1 +505,1 @@\n-            subjectPublicKeyAlgID = new ObjectIdentifier(oid);\n+            subjectPublicKeyAlgID = ObjectIdentifier.of(oid);\n@@ -625,1 +621,1 @@\n-                keyPurposeOIDSet.add(new ObjectIdentifier(s));\n+                keyPurposeOIDSet.add(ObjectIdentifier.of(s));\n@@ -1108,2 +1104,2 @@\n-                polIdVector.add(new CertificatePolicyId(new ObjectIdentifier(\n-                  (String)o)));\n+                polIdVector.add(new CertificatePolicyId\n+                        (ObjectIdentifier.of((String)o)));\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1810,0 +1810,2 @@\n+        if (interruptible && Thread.interrupted())\n+            return null;\n@@ -1821,0 +1823,5 @@\n+            else if (interruptible && q.interrupted) {\n+                q.thread = null;\n+                cleanStack();\n+                return null;\n+            }\n@@ -1827,2 +1834,0 @@\n-                if (q.interrupted && interruptible)\n-                    break;\n@@ -1831,1 +1836,1 @@\n-        if (q != null && queued) {\n+        if (q != null) {\n@@ -1833,1 +1838,1 @@\n-            if (!interruptible && q.interrupted)\n+            if (q.interrupted)\n@@ -1835,2 +1840,0 @@\n-            if (r == null)\n-                cleanStack();\n@@ -1838,2 +1841,1 @@\n-        if (r != null || (r = result) != null)\n-            postComplete();\n+        postComplete();\n@@ -1848,27 +1850,16 @@\n-        if (Thread.interrupted())\n-            return null;\n-        if (nanos > 0L) {\n-            long d = System.nanoTime() + nanos;\n-            long deadline = (d == 0L) ? 1L : d; \/\/ avoid 0\n-            Signaller q = null;\n-            boolean queued = false;\n-            Object r;\n-            while ((r = result) == null) { \/\/ similar to untimed\n-                if (q == null) {\n-                    q = new Signaller(true, nanos, deadline);\n-                    if (Thread.currentThread() instanceof ForkJoinWorkerThread)\n-                        ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);\n-                }\n-                else if (!queued)\n-                    queued = tryPushStack(q);\n-                else if (q.nanos <= 0L)\n-                    break;\n-                else {\n-                    try {\n-                        ForkJoinPool.managedBlock(q);\n-                    } catch (InterruptedException ie) {\n-                        q.interrupted = true;\n-                    }\n-                    if (q.interrupted)\n-                        break;\n-                }\n+        long d = System.nanoTime() + nanos;\n+        long deadline = (d == 0L) ? 1L : d; \/\/ avoid 0\n+        boolean interrupted = false, queued = false;\n+        Signaller q = null;\n+        Object r = null;\n+        for (;;) { \/\/ order of checking interrupt, result, timeout matters\n+            if (interrupted || (interrupted = Thread.interrupted()))\n+                break;\n+            else if ((r = result) != null)\n+                break;\n+            else if (nanos <= 0L)\n+                break;\n+            else if (q == null) {\n+                q = new Signaller(true, nanos, deadline);\n+                if (Thread.currentThread() instanceof ForkJoinWorkerThread)\n+                    ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);\n@@ -1876,4 +1867,10 @@\n-            if (q != null && queued) {\n-                q.thread = null;\n-                if (r == null)\n-                    cleanStack();\n+            else if (!queued)\n+                queued = tryPushStack(q);\n+            else {\n+                try {\n+                    ForkJoinPool.managedBlock(q);\n+                    interrupted = q.interrupted;\n+                    nanos = q.nanos;\n+                } catch (InterruptedException ie) {\n+                    interrupted = true;\n+                }\n@@ -1881,4 +1878,0 @@\n-            if (r != null || (r = result) != null)\n-                postComplete();\n-            if (r != null || (q != null && q.interrupted))\n-                return r;\n@@ -1886,1 +1879,14 @@\n-        throw new TimeoutException();\n+        if (q != null) {\n+            q.thread = null;\n+            if (r == null)\n+                cleanStack();\n+        }\n+        if (r != null) {\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+            postComplete();\n+            return r;\n+        } else if (interrupted)\n+            return null;\n+        else\n+            throw new TimeoutException();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":50,"deletions":44,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1223,1 +1223,1 @@\n-        init(opmode, key, JCAUtil.getSecureRandom());\n+        init(opmode, key, JCAUtil.getDefSecureRandom());\n@@ -1364,1 +1364,1 @@\n-        init(opmode, key, params, JCAUtil.getSecureRandom());\n+        init(opmode, key, params, JCAUtil.getDefSecureRandom());\n@@ -1507,1 +1507,1 @@\n-        init(opmode, key, params, JCAUtil.getSecureRandom());\n+        init(opmode, key, params, JCAUtil.getDefSecureRandom());\n@@ -1655,1 +1655,1 @@\n-        init(opmode, certificate, JCAUtil.getSecureRandom());\n+        init(opmode, certificate, JCAUtil.getDefSecureRandom());\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-        init(key, JCAUtil.getSecureRandom());\n+        init(key, JCAUtil.getDefSecureRandom());\n@@ -517,1 +517,1 @@\n-        init(key, params, JCAUtil.getSecureRandom());\n+        init(key, params, JCAUtil.getDefSecureRandom());\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyAgreement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -453,1 +453,1 @@\n-        init(params, JCAUtil.getSecureRandom());\n+        init(params, JCAUtil.getDefSecureRandom());\n@@ -517,1 +517,1 @@\n-        init(keysize, JCAUtil.getSecureRandom());\n+        init(keysize, JCAUtil.getDefSecureRandom());\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-        SSLParameters params = new SSLParameters();\n+        SSLParameters params = socket.getSSLParameters();\n@@ -218,1 +218,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLContextSpi.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,9 @@\n+    private static final X509CertificateEvent EVENT = new X509CertificateEvent();\n+\n+    \/**\n+     * Returns {@code true} if event is enabled, {@code false} otherwise.\n+     *\/\n+    public static boolean isTurnedOn() {\n+        return EVENT.isEnabled();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/X509CertificateEvent.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,23 +116,12 @@\n-    public synchronized void put(final URL url, Object obj, HttpClient http) {\n-        boolean startThread = (keepAliveTimer == null);\n-        if (!startThread) {\n-            if (!keepAliveTimer.isAlive()) {\n-                startThread = true;\n-            }\n-        }\n-        if (startThread) {\n-            clear();\n-            \/* Unfortunately, we can't always believe the keep-alive timeout we got\n-             * back from the server.  If I'm connected through a Netscape proxy\n-             * to a server that sent me a keep-alive\n-             * time of 15 sec, the proxy unilaterally terminates my connection\n-             * The robustness to get around this is in HttpClient.parseHTTP()\n-             *\/\n-            final KeepAliveCache cache = this;\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Void run() {\n-                    keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n-                    keepAliveTimer.setDaemon(true);\n-                    keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n-                    keepAliveTimer.start();\n-                    return null;\n+    public void put(final URL url, Object obj, HttpClient http) {\n+        \/\/ this method may need to close an HttpClient, either because\n+        \/\/ it is not cacheable, or because the cache is at its capacity.\n+        \/\/ In the latter case, we close the least recently used client.\n+        \/\/ The client to close is stored in oldClient, and is closed\n+        \/\/ after cacheLock is released.\n+        HttpClient oldClient = null;\n+        synchronized (this) {\n+            boolean startThread = (keepAliveTimer == null);\n+            if (!startThread) {\n+                if (!keepAliveTimer.isAlive()) {\n+                    startThread = true;\n@@ -140,2 +129,20 @@\n-            });\n-        }\n+            }\n+            if (startThread) {\n+                clear();\n+                \/* Unfortunately, we can't always believe the keep-alive timeout we got\n+                * back from the server.  If I'm connected through a Netscape proxy\n+                * to a server that sent me a keep-alive\n+                * time of 15 sec, the proxy unilaterally terminates my connection\n+                * The robustness to get around this is in HttpClient.parseHTTP()\n+                *\/\n+                final KeepAliveCache cache = this;\n+                AccessController.doPrivileged(new PrivilegedAction<>() {\n+                    public Void run() {\n+                        keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n+                        keepAliveTimer.setDaemon(true);\n+                        keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n+                        keepAliveTimer.start();\n+                        return null;\n+                    }\n+                 });\n+            }\n@@ -143,2 +150,2 @@\n-        KeepAliveKey key = new KeepAliveKey(url, obj);\n-        ClientVector v = super.get(key);\n+            KeepAliveKey key = new KeepAliveKey(url, obj);\n+            ClientVector v = super.get(key);\n@@ -146,2 +153,2 @@\n-        if (v == null) {\n-            int keepAliveTimeout = http.getKeepAliveTimeout();\n+            if (v == null) {\n+                int keepAliveTimeout = http.getKeepAliveTimeout();\n@@ -167,1 +174,1 @@\n-                    http.closeServer();\n+                    oldClient = http;\n@@ -173,2 +180,7 @@\n-        } else {\n-            v.put(http);\n+            } else {\n+                oldClient = v.put(http);\n+            }\n+        }\n+        \/\/ close after releasing locks\n+        if (oldClient != null) {\n+            oldClient.closeServer();\n@@ -224,0 +236,1 @@\n+            List<HttpClient> closeList = null;\n@@ -233,1 +246,1 @@\n-                        KeepAliveEntry e = v.peek();\n+                        KeepAliveEntry e = v.peekLast();\n@@ -236,2 +249,5 @@\n-                                v.poll();\n-                                e.hc.closeServer();\n+                                v.pollLast();\n+                                if (closeList == null) {\n+                                    closeList = new ArrayList<>();\n+                                }\n+                                closeList.add(e.hc);\n@@ -241,1 +257,1 @@\n-                            e = v.peek();\n+                            e = v.peekLast();\n@@ -254,0 +270,6 @@\n+            \/\/ close connections outside cacheLock\n+            if (closeList != null) {\n+                 for (HttpClient hc : closeList) {\n+                     hc.closeServer();\n+               }\n+          }\n@@ -271,2 +293,2 @@\n-\/* FILO order for recycling HttpClients, should run in a thread\n- * to time them out.  If > maxConns are in use, block.\n+\/* LIFO order for reusing HttpClients. Most recent entries at the front.\n+ * If > maxConns are in use, discard oldest.\n@@ -285,1 +307,3 @@\n-        if (isEmpty()) {\n+        \/\/ check the most recent connection, use if still valid\n+        KeepAliveEntry e = peekFirst();\n+        if (e == null) {\n@@ -289,2 +313,0 @@\n-        \/\/ Loop until we find a connection that has not timed out\n-        HttpClient hc = null;\n@@ -292,8 +314,6 @@\n-        do {\n-            KeepAliveEntry e = pop();\n-            if ((currentTime - e.idleStartTime) > nap) {\n-                e.hc.closeServer();\n-            } else {\n-                hc = e.hc;\n-                if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n-                    String msg = \"cached HttpClient was idle for \"\n+        if ((currentTime - e.idleStartTime) > nap) {\n+            return null; \/\/ all connections stale - will be cleaned up later\n+        } else {\n+            pollFirst();\n+            if (KeepAliveCache.logger.isLoggable(PlatformLogger.Level.FINEST)) {\n+                String msg = \"cached HttpClient was idle for \"\n@@ -301,2 +321,1 @@\n-                    KeepAliveCache.logger.finest(msg);\n-                }\n+                KeepAliveCache.logger.finest(msg);\n@@ -304,2 +323,2 @@\n-        } while ((hc == null) && (!isEmpty()));\n-        return hc;\n+            return e.hc;\n+        }\n@@ -309,1 +328,3 @@\n-    synchronized void put(HttpClient h) {\n+    synchronized HttpClient put(HttpClient h) {\n+        HttpClient staleClient = null;\n+        assert KeepAliveCache.getMaxConnections() > 0;\n@@ -311,3 +332,2 @@\n-            h.closeServer(); \/\/ otherwise the connection remains in limbo\n-        } else {\n-            push(new KeepAliveEntry(h, System.currentTimeMillis()));\n+           \/\/ remove oldest connection\n+           staleClient = removeLast().hc;\n@@ -315,0 +335,3 @@\n+        addFirst(new KeepAliveEntry(h, System.currentTimeMillis()));\n+        \/\/ close after releasing the locks\n+        return staleClient;\n@@ -342,4 +365,4 @@\n-    private String      protocol = null;\n-    private String      host = null;\n-    private int         port = 0;\n-    private Object      obj = null; \/\/ additional key, such as socketfactory\n+    private final String      protocol;\n+    private final String      host;\n+    private final int         port;\n+    private final Object      obj; \/\/ additional key, such as socketfactory\n@@ -386,2 +409,2 @@\n-    HttpClient hc;\n-    long idleStartTime;\n+    final HttpClient hc;\n+    final long idleStartTime;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":86,"deletions":63,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -520,0 +520,9 @@\n+\n+    \/**\n+     * Releases any system or cryptographic resources.\n+     * It is up to implementors to override disposeContext()\n+     * to take necessary action.\n+     *\/\n+    public void disposeContext() {\n+        \/\/ do nothing\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1956,0 +1956,6 @@\n+            if (proxyAuthentication != null) {\n+                proxyAuthentication.disposeContext();\n+            }\n+            if (serverAuthentication != null) {\n+                serverAuthentication.disposeContext();\n+            }\n@@ -2185,0 +2191,3 @@\n+            if (proxyAuthentication != null) {\n+                proxyAuthentication.disposeContext();\n+            }\n@@ -2431,0 +2440,1 @@\n+                    ret.disposeContext();\n@@ -2599,0 +2609,1 @@\n+                    ret.disposeContext();\n@@ -2625,0 +2636,1 @@\n+                    currentProxyCredentials.disposeContext();\n@@ -2635,0 +2647,1 @@\n+                    currentServerCredentials.disposeContext();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -228,0 +228,16 @@\n+    \/**\n+     * Releases any system resources and cryptographic information stored in\n+     * the context object and invalidates the context.\n+     *\/\n+    @Override\n+    public void disposeContext() {\n+        if (negotiator != null) {\n+            try {\n+                negotiator.disposeContext();\n+            } catch (IOException ioEx) {\n+                \/\/do not rethrow IOException\n+            }\n+            negotiator = null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+\n+    public void disposeContext() throws IOException { };\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/Negotiator.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -431,0 +431,8 @@\n+    @Override\n+    public void closeServer() {\n+        try {\n+            \/\/ SSLSocket.close may block up to timeout. Make sure it's short.\n+            serverSocket.setSoTimeout(1);\n+        } catch (Exception e) {}\n+        super.closeServer();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-\n@@ -31,0 +30,7 @@\n+import java.security.PublicKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+\n+import jdk.internal.event.EventHelper;\n+import jdk.internal.event.X509CertificateEvent;\n+import sun.security.util.KeyUtil;\n@@ -62,0 +68,2 @@\n+    private static volatile SecureRandom def = null;\n+\n@@ -72,0 +80,65 @@\n+    \/\/ called by sun.security.jca.Providers class when provider list is changed\n+    static void clearDefSecureRandom() {\n+        def = null;\n+    }\n+\n+    \/**\n+     * Get the default SecureRandom instance. This method is the\n+     * optimized version of \"new SecureRandom()\" which re-uses the default\n+     * SecureRandom impl if the provider table is the same.\n+     *\/\n+    public static SecureRandom getDefSecureRandom() {\n+        SecureRandom result = def;\n+        if (result == null) {\n+            synchronized (JCAUtil.class) {\n+                result = def;\n+                if (result == null) {\n+                    def = result = new SecureRandom();\n+                }\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    public static void tryCommitCertEvent(Certificate cert) {\n+        if ((X509CertificateEvent.isTurnedOn() || EventHelper.isLoggingSecurity())) {\n+            if (cert instanceof X509Certificate) {\n+                X509Certificate x509 = (X509Certificate) cert;\n+            PublicKey pKey = x509.getPublicKey();\n+            String algId = x509.getSigAlgName();\n+            String serNum = x509.getSerialNumber().toString(16);\n+            String subject = x509.getSubjectX500Principal().toString();\n+            String issuer = x509.getIssuerX500Principal().toString();\n+            String keyType = pKey.getAlgorithm();\n+            int length = KeyUtil.getKeySize(pKey);\n+            int hashCode = x509.hashCode();\n+            long beginDate = x509.getNotBefore().getTime();\n+            long endDate = x509.getNotAfter().getTime();\n+            if (X509CertificateEvent.isTurnedOn()) {\n+                X509CertificateEvent xce = new X509CertificateEvent();\n+                xce.algorithm = algId;\n+                xce.serialNumber = serNum;\n+                xce.subject = subject;\n+                xce.issuer = issuer;\n+                xce.keyType = keyType;\n+                xce.keyLength = length;\n+                xce.certificateId = hashCode;\n+                xce.validFrom = beginDate;\n+                xce.validUntil = endDate;\n+                xce.commit();\n+            }\n+            if (EventHelper.isLoggingSecurity()) {\n+                EventHelper.logX509CertificateEvent(algId,\n+                        serNum,\n+                        subject,\n+                        issuer,\n+                        keyType,\n+                        length,\n+                        hashCode,\n+                        beginDate,\n+                        endDate);\n+            }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/JCAUtil.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,1 @@\n+        JCAUtil.clearDefSecureRandom();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/Providers.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,10 +41,15 @@\n-    private static int[]  pkcs7 = {1, 2, 840, 113549, 1, 7};\n-    private static int[]   data = {1, 2, 840, 113549, 1, 7, 1};\n-    private static int[]  sdata = {1, 2, 840, 113549, 1, 7, 2};\n-    private static int[]  edata = {1, 2, 840, 113549, 1, 7, 3};\n-    private static int[] sedata = {1, 2, 840, 113549, 1, 7, 4};\n-    private static int[]  ddata = {1, 2, 840, 113549, 1, 7, 5};\n-    private static int[] crdata = {1, 2, 840, 113549, 1, 7, 6};\n-    private static int[] nsdata = {2, 16, 840, 1, 113730, 2, 5};\n-    \/\/ timestamp token (id-ct-TSTInfo) from RFC 3161\n-    private static int[] tstInfo = {1, 2, 840, 113549, 1, 9, 16, 1, 4};\n+    public static ObjectIdentifier PKCS7_OID =\n+            ObjectIdentifier.of(KnownOIDs.PKCS7);\n+    public static ObjectIdentifier DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.Data);\n+    public static ObjectIdentifier SIGNED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.SignedData);\n+    public static ObjectIdentifier ENVELOPED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.EnvelopedData);\n+    public static ObjectIdentifier SIGNED_AND_ENVELOPED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.SignedAndEnvelopedData);\n+    public static ObjectIdentifier DIGESTED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.DigestedData);\n+    public static ObjectIdentifier ENCRYPTED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.EncryptedData);\n+\n@@ -52,13 +57,4 @@\n-    private static final int[] OLD_SDATA = {1, 2, 840, 1113549, 1, 7, 2};\n-    private static final int[] OLD_DATA = {1, 2, 840, 1113549, 1, 7, 1};\n-    public static ObjectIdentifier PKCS7_OID;\n-    public static ObjectIdentifier DATA_OID;\n-    public static ObjectIdentifier SIGNED_DATA_OID;\n-    public static ObjectIdentifier ENVELOPED_DATA_OID;\n-    public static ObjectIdentifier SIGNED_AND_ENVELOPED_DATA_OID;\n-    public static ObjectIdentifier DIGESTED_DATA_OID;\n-    public static ObjectIdentifier ENCRYPTED_DATA_OID;\n-    public static ObjectIdentifier OLD_SIGNED_DATA_OID;\n-    public static ObjectIdentifier OLD_DATA_OID;\n-    public static ObjectIdentifier NETSCAPE_CERT_SEQUENCE_OID;\n-    public static ObjectIdentifier TIMESTAMP_TOKEN_INFO_OID;\n+    public static ObjectIdentifier OLD_SIGNED_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.JDK_OLD_SignedData);\n+    public static ObjectIdentifier OLD_DATA_OID =\n+            ObjectIdentifier.of(KnownOIDs.JDK_OLD_Data);\n@@ -66,19 +62,9 @@\n-    static {\n-        PKCS7_OID =  ObjectIdentifier.newInternal(pkcs7);\n-        DATA_OID = ObjectIdentifier.newInternal(data);\n-        SIGNED_DATA_OID = ObjectIdentifier.newInternal(sdata);\n-        ENVELOPED_DATA_OID = ObjectIdentifier.newInternal(edata);\n-        SIGNED_AND_ENVELOPED_DATA_OID = ObjectIdentifier.newInternal(sedata);\n-        DIGESTED_DATA_OID = ObjectIdentifier.newInternal(ddata);\n-        ENCRYPTED_DATA_OID = ObjectIdentifier.newInternal(crdata);\n-        OLD_SIGNED_DATA_OID = ObjectIdentifier.newInternal(OLD_SDATA);\n-        OLD_DATA_OID = ObjectIdentifier.newInternal(OLD_DATA);\n-        \/**\n-         * The ASN.1 systax for the Netscape Certificate Sequence\n-         * data type is defined\n-         * <a href=http:\/\/wp.netscape.com\/eng\/security\/comm4-cert-download.html>\n-         * here.<\/a>\n-         *\/\n-        NETSCAPE_CERT_SEQUENCE_OID = ObjectIdentifier.newInternal(nsdata);\n-        TIMESTAMP_TOKEN_INFO_OID = ObjectIdentifier.newInternal(tstInfo);\n-    }\n+    \/\/ The ASN.1 systax for the Netscape Certificate Sequence data type is\n+    \/\/ defined at:\n+    \/\/      http:\/\/wp.netscape.com\/eng\/security\/comm4-cert-download.html\n+    public static ObjectIdentifier NETSCAPE_CERT_SEQUENCE_OID =\n+            ObjectIdentifier.of(KnownOIDs.NETSCAPE_CertSequence);\n+\n+    \/\/ timestamp token (id-ct-TSTInfo) from RFC 3161\n+    public static ObjectIdentifier TIMESTAMP_TOKEN_INFO_OID =\n+            ObjectIdentifier.of(KnownOIDs.TimeStampTokenInfo);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/ContentInfo.java","additions":28,"deletions":42,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -72,17 +73,0 @@\n-    \/*\n-     * Random number generator for creating nonce values\n-     * (Lazy initialization)\n-     *\/\n-    private static class SecureRandomHolder {\n-        static final SecureRandom RANDOM;\n-        static {\n-            SecureRandom tmp = null;\n-            try {\n-                tmp = SecureRandom.getInstance(\"SHA1PRNG\");\n-            } catch (NoSuchAlgorithmException e) {\n-                \/\/ should not happen\n-            }\n-            RANDOM = tmp;\n-        }\n-    }\n-\n@@ -888,5 +872,3 @@\n-        BigInteger nonce = null;\n-        if (SecureRandomHolder.RANDOM != null) {\n-            nonce = new BigInteger(64, SecureRandomHolder.RANDOM);\n-            tsQuery.setNonce(nonce);\n-        }\n+        BigInteger nonce = new BigInteger(64, JCAUtil.getDefSecureRandom());\n+        tsQuery.setNonce(nonce);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.Locale;\n@@ -33,1 +32,0 @@\n-import java.util.Hashtable;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attribute.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,5 +67,1 @@\n-import sun.security.util.Debug;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -73,1 +69,0 @@\n-import sun.security.util.SecurityProperties;\n@@ -77,1 +72,0 @@\n-import sun.security.util.KeyStoreDelegator;\n@@ -136,5 +130,4 @@\n-    \/\/ friendlyName, localKeyId, trustedKeyUsage\n-    private static final String[] CORE_ATTRIBUTES = {\n-        \"1.2.840.113549.1.9.20\",\n-        \"1.2.840.113549.1.9.21\",\n-        \"2.16.840.1.113894.746875.1.1\"\n+    private static final KnownOIDs[] CORE_ATTRIBUTES = {\n+        KnownOIDs.FriendlyName,\n+        KnownOIDs.LocalKeyID,\n+        KnownOIDs.ORACLE_TrustedKeyUsage\n@@ -145,3 +138,15 @@\n-    private static final int[] keyBag  = {1, 2, 840, 113549, 1, 12, 10, 1, 2};\n-    private static final int[] certBag = {1, 2, 840, 113549, 1, 12, 10, 1, 3};\n-    private static final int[] secretBag = {1, 2, 840, 113549, 1, 12, 10, 1, 5};\n+    private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID =\n+            ObjectIdentifier.of(KnownOIDs.PKCS8ShroudedKeyBag);\n+    private static final ObjectIdentifier CertBag_OID =\n+            ObjectIdentifier.of(KnownOIDs.CertBag);\n+    private static final ObjectIdentifier SecretBag_OID =\n+            ObjectIdentifier.of(KnownOIDs.SecretBag);\n+\n+    private static final ObjectIdentifier PKCS9FriendlyName_OID =\n+            ObjectIdentifier.of(KnownOIDs.FriendlyName);\n+    private static final ObjectIdentifier PKCS9LocalKeyId_OID =\n+            ObjectIdentifier.of(KnownOIDs.LocalKeyID);\n+    private static final ObjectIdentifier PKCS9CertType_OID =\n+            ObjectIdentifier.of(KnownOIDs.CertTypeX509);\n+    private static final ObjectIdentifier pbes2_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBES2);\n@@ -149,7 +154,0 @@\n-    private static final int[] pkcs9Name  = {1, 2, 840, 113549, 1, 9, 20};\n-    private static final int[] pkcs9KeyId = {1, 2, 840, 113549, 1, 9, 21};\n-\n-    private static final int[] pkcs9certType = {1, 2, 840, 113549, 1, 9, 22, 1};\n-\n-    private static final int[] pbes2 = {1, 2, 840, 113549, 1, 5, 13};\n-    \/\/ TODO: temporary Oracle OID\n@@ -157,2 +155,4 @@\n-     * { joint-iso-itu-t(2) country(16) us(840) organization(1) oracle(113894)\n-     *   jdk(746875) crypto(1) id-at-trustedKeyUsage(1) }\n+     * Temporary Oracle OID\n+     *\n+     * {joint-iso-itu-t(2) country(16) us(840) organization(1)\n+     *  oracle(113894) jdk(746875) crypto(1) id-at-trustedKeyUsage(1)}\n@@ -160,13 +160,6 @@\n-    private static final int[] TrustedKeyUsage =\n-                                        {2, 16, 840, 1, 113894, 746875, 1, 1};\n-    private static final int[] AnyExtendedKeyUsage = {2, 5, 29, 37, 0};\n-\n-    private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID;\n-    private static final ObjectIdentifier CertBag_OID;\n-    private static final ObjectIdentifier SecretBag_OID;\n-    private static final ObjectIdentifier PKCS9FriendlyName_OID;\n-    private static final ObjectIdentifier PKCS9LocalKeyId_OID;\n-    private static final ObjectIdentifier PKCS9CertType_OID;\n-    private static final ObjectIdentifier pbes2_OID;\n-    private static final ObjectIdentifier TrustedKeyUsage_OID;\n-    private static final ObjectIdentifier[] AnyUsage;\n+    private static final ObjectIdentifier TrustedKeyUsage_OID =\n+            ObjectIdentifier.of(KnownOIDs.ORACLE_TrustedKeyUsage);\n+\n+    private static final ObjectIdentifier[] AnyUsage = new ObjectIdentifier[] {\n+                ObjectIdentifier.of(KnownOIDs.anyExtendedKeyUsage)\n+            };\n@@ -201,17 +194,0 @@\n-    static {\n-        try {\n-            PKCS8ShroudedKeyBag_OID = new ObjectIdentifier(keyBag);\n-            CertBag_OID = new ObjectIdentifier(certBag);\n-            SecretBag_OID = new ObjectIdentifier(secretBag);\n-            PKCS9FriendlyName_OID = new ObjectIdentifier(pkcs9Name);\n-            PKCS9LocalKeyId_OID = new ObjectIdentifier(pkcs9KeyId);\n-            PKCS9CertType_OID = new ObjectIdentifier(pkcs9certType);\n-            pbes2_OID = new ObjectIdentifier(pbes2);\n-            TrustedKeyUsage_OID = new ObjectIdentifier(TrustedKeyUsage);\n-            AnyUsage = new ObjectIdentifier[]{\n-                new ObjectIdentifier(AnyExtendedKeyUsage)};\n-        } catch (IOException ioe) {\n-            throw new AssertionError(\"OID not initialized\", ioe);\n-        }\n-    }\n-\n@@ -1658,3 +1634,3 @@\n-                if (CORE_ATTRIBUTES[0].equals(attributeName) ||\n-                    CORE_ATTRIBUTES[1].equals(attributeName) ||\n-                    CORE_ATTRIBUTES[2].equals(attributeName)) {\n+                if (CORE_ATTRIBUTES[0].value().equals(attributeName) ||\n+                    CORE_ATTRIBUTES[1].value().equals(attributeName) ||\n+                    CORE_ATTRIBUTES[2].value().equals(attributeName)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":33,"deletions":57,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -109,3 +110,0 @@\n-    \/\/ defined by JavaSoft\n-    private static final String KEY_PROTECTOR_OID = \"1.3.6.1.4.1.42.2.17.1.1\";\n-\n@@ -217,1 +215,2 @@\n-            encrAlg = new AlgorithmId(new ObjectIdentifier(KEY_PROTECTOR_OID));\n+            encrAlg = new AlgorithmId(ObjectIdentifier.of\n+                    (KnownOIDs.JAVASOFT_JDKKeyProtector));\n@@ -239,1 +238,2 @@\n-        if (!(encrAlg.getOID().toString().equals(KEY_PROTECTOR_OID))) {\n+        if (!(encrAlg.getOID().toString().equals\n+                (KnownOIDs.JAVASOFT_JDKKeyProtector.value()))) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import sun.security.util.SecurityProviderConstants;\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n@@ -83,12 +85,0 @@\n-    \/\/ create an aliases List from the specified aliases\n-    public static List<String> createAliases(String ... aliases) {\n-        return Arrays.asList(aliases);\n-    }\n-\n-    \/\/ create an aliases List from the specified oid followed by other aliases\n-    public static List<String> createAliasesWithOid(String ... oids) {\n-        String[] result = Arrays.copyOf(oids, oids.length + 1);\n-        result[result.length - 1] = \"OID.\" + oids[0];\n-        return Arrays.asList(result);\n-    }\n-\n@@ -109,2 +99,1 @@\n-                    \"sun.security.provider.NativePRNG\",\n-                    null, attrs);\n+                    \"sun.security.provider.NativePRNG\", attrs);\n@@ -114,1 +103,1 @@\n-                    \"sun.security.provider.NativePRNG$Blocking\", null, attrs);\n+                    \"sun.security.provider.NativePRNG$Blocking\", attrs);\n@@ -118,1 +107,1 @@\n-                    \"sun.security.provider.NativePRNG$NonBlocking\", null, attrs);\n+                    \"sun.security.provider.NativePRNG$NonBlocking\", attrs);\n@@ -121,2 +110,1 @@\n-        add(p, \"SecureRandom\", \"DRBG\", \"sun.security.provider.DRBG\",\n-               null, attrs);\n+        add(p, \"SecureRandom\", \"DRBG\", \"sun.security.provider.DRBG\", attrs);\n@@ -124,1 +112,1 @@\n-                \"sun.security.provider.SecureRandom\", null, attrs);\n+                \"sun.security.provider.SecureRandom\", attrs);\n@@ -137,7 +125,4 @@\n-        add(p, \"Signature\", \"SHA1withDSA\",\n-                \"sun.security.provider.DSA$SHA1withDSA\",\n-                createAliasesWithOid(\"1.2.840.10040.4.3\", \"DSA\", \"DSS\",\n-                    \"SHA\/DSA\", \"SHA-1\/DSA\", \"SHA1\/DSA\", \"SHAwithDSA\",\n-                    \"DSAWithSHA1\", \"1.3.14.3.2.13\", \"1.3.14.3.2.27\"), attrs);\n-        add(p, \"Signature\", \"NONEwithDSA\", \"sun.security.provider.DSA$RawDSA\",\n-                createAliases(\"RawDSA\"), attrs);\n+        addWithAlias(p, \"Signature\", \"SHA1withDSA\",\n+                \"sun.security.provider.DSA$SHA1withDSA\", attrs);\n+        addWithAlias(p, \"Signature\", \"NONEwithDSA\",\n+                \"sun.security.provider.DSA$RawDSA\", attrs);\n@@ -147,6 +132,4 @@\n-        add(p, \"Signature\", \"SHA224withDSA\",\n-                \"sun.security.provider.DSA$SHA224withDSA\",\n-                createAliasesWithOid(\"2.16.840.1.101.3.4.3.1\"), attrs);\n-        add(p, \"Signature\", \"SHA256withDSA\",\n-                \"sun.security.provider.DSA$SHA256withDSA\",\n-                createAliasesWithOid(\"2.16.840.1.101.3.4.3.2\"), attrs);\n+        addWithAlias(p, \"Signature\", \"SHA224withDSA\",\n+                \"sun.security.provider.DSA$SHA224withDSA\", attrs);\n+        addWithAlias(p, \"Signature\", \"SHA256withDSA\",\n+                \"sun.security.provider.DSA$SHA256withDSA\", attrs);\n@@ -157,2 +140,1 @@\n-                \"sun.security.provider.DSA$SHA1withDSAinP1363Format\",\n-                null, null);\n+                \"sun.security.provider.DSA$SHA1withDSAinP1363Format\");\n@@ -160,2 +142,1 @@\n-                \"sun.security.provider.DSA$RawDSAinP1363Format\",\n-                null, null);\n+                \"sun.security.provider.DSA$RawDSAinP1363Format\");\n@@ -163,2 +144,1 @@\n-                \"sun.security.provider.DSA$SHA224withDSAinP1363Format\",\n-                null, null);\n+                \"sun.security.provider.DSA$SHA224withDSAinP1363Format\");\n@@ -166,2 +146,1 @@\n-                \"sun.security.provider.DSA$SHA256withDSAinP1363Format\",\n-                null, null);\n+                \"sun.security.provider.DSA$SHA256withDSAinP1363Format\");\n@@ -176,2 +155,0 @@\n-        String dsaOid = \"1.2.840.10040.4.1\";\n-        List<String> dsaAliases = createAliasesWithOid(dsaOid, \"1.3.14.3.2.12\");\n@@ -180,1 +157,1 @@\n-        add(p, \"KeyPairGenerator\", \"DSA\", dsaKPGImplClass, dsaAliases, attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"DSA\", dsaKPGImplClass, attrs);\n@@ -185,3 +162,2 @@\n-        add(p, \"AlgorithmParameterGenerator\", \"DSA\",\n-                \"sun.security.provider.DSAParameterGenerator\", dsaAliases,\n-                attrs);\n+        addWithAlias(p, \"AlgorithmParameterGenerator\", \"DSA\",\n+                \"sun.security.provider.DSAParameterGenerator\", attrs);\n@@ -193,2 +169,2 @@\n-        add(p, \"AlgorithmParameters\", \"DSA\",\n-                \"sun.security.provider.DSAParameters\", dsaAliases, attrs);\n+        addWithAlias(p, \"AlgorithmParameters\", \"DSA\",\n+                \"sun.security.provider.DSAParameters\", attrs);\n@@ -199,2 +175,2 @@\n-        add(p, \"KeyFactory\", \"DSA\", \"sun.security.provider.DSAKeyFactory\",\n-                dsaAliases, attrs);\n+        addWithAlias(p, \"KeyFactory\", \"DSA\",\n+                \"sun.security.provider.DSAKeyFactory\", attrs);\n@@ -205,28 +181,25 @@\n-        add(p, \"MessageDigest\", \"MD2\", \"sun.security.provider.MD2\", null, attrs);\n-        add(p, \"MessageDigest\", \"MD5\", \"sun.security.provider.MD5\", null, attrs);\n-        add(p, \"MessageDigest\", \"SHA\", \"sun.security.provider.SHA\",\n-                createAliasesWithOid(\"1.3.14.3.2.26\", \"SHA-1\", \"SHA1\"), attrs);\n-\n-        String sha2BaseOid = \"2.16.840.1.101.3.4.2\";\n-        add(p, \"MessageDigest\", \"SHA-224\", \"sun.security.provider.SHA2$SHA224\",\n-                createAliasesWithOid(sha2BaseOid + \".4\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA-256\", \"sun.security.provider.SHA2$SHA256\",\n-                createAliasesWithOid(sha2BaseOid + \".1\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA-384\", \"sun.security.provider.SHA5$SHA384\",\n-                createAliasesWithOid(sha2BaseOid + \".2\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA-512\", \"sun.security.provider.SHA5$SHA512\",\n-                createAliasesWithOid(sha2BaseOid + \".3\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA-512\/224\",\n-                \"sun.security.provider.SHA5$SHA512_224\",\n-                createAliasesWithOid(sha2BaseOid + \".5\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA-512\/256\",\n-                \"sun.security.provider.SHA5$SHA512_256\",\n-                createAliasesWithOid(sha2BaseOid + \".6\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA3-224\", \"sun.security.provider.SHA3$SHA224\",\n-                createAliasesWithOid(sha2BaseOid + \".7\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA3-256\", \"sun.security.provider.SHA3$SHA256\",\n-                createAliasesWithOid(sha2BaseOid + \".8\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA3-384\", \"sun.security.provider.SHA3$SHA384\",\n-                createAliasesWithOid(sha2BaseOid + \".9\"), attrs);\n-        add(p, \"MessageDigest\", \"SHA3-512\", \"sun.security.provider.SHA3$SHA512\",\n-                createAliasesWithOid(sha2BaseOid + \".10\"), attrs);\n+        add(p, \"MessageDigest\", \"MD2\", \"sun.security.provider.MD2\", attrs);\n+        add(p, \"MessageDigest\", \"MD5\", \"sun.security.provider.MD5\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-1\", \"sun.security.provider.SHA\",\n+                attrs);\n+\n+        addWithAlias(p, \"MessageDigest\", \"SHA-224\",\n+                \"sun.security.provider.SHA2$SHA224\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-256\",\n+                \"sun.security.provider.SHA2$SHA256\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-384\",\n+                \"sun.security.provider.SHA5$SHA384\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-512\",\n+                \"sun.security.provider.SHA5$SHA512\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-512\/224\",\n+                \"sun.security.provider.SHA5$SHA512_224\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA-512\/256\",\n+                \"sun.security.provider.SHA5$SHA512_256\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA3-224\",\n+                \"sun.security.provider.SHA3$SHA224\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA3-256\",\n+                \"sun.security.provider.SHA3$SHA256\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA3-384\",\n+                \"sun.security.provider.SHA3$SHA384\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"SHA3-512\",\n+                \"sun.security.provider.SHA3$SHA512\", attrs);\n@@ -237,3 +210,2 @@\n-        add(p, \"CertificateFactory\", \"X.509\",\n-                \"sun.security.provider.X509Factory\",\n-                createAliases(\"X509\"), attrs);\n+        addWithAlias(p, \"CertificateFactory\", \"X.509\",\n+                \"sun.security.provider.X509Factory\", attrs);\n@@ -245,2 +217,1 @@\n-                \"sun.security.pkcs12.PKCS12KeyStore$DualFormatPKCS12\",\n-                null, null);\n+                \"sun.security.pkcs12.PKCS12KeyStore$DualFormatPKCS12\");\n@@ -248,2 +219,1 @@\n-                \"sun.security.provider.JavaKeyStore$DualFormatJKS\",\n-                null, attrs);\n+                \"sun.security.provider.JavaKeyStore$DualFormatJKS\", attrs);\n@@ -251,2 +221,1 @@\n-                \"sun.security.provider.JavaKeyStore$CaseExactJKS\",\n-                null, attrs);\n+                \"sun.security.provider.JavaKeyStore$CaseExactJKS\", attrs);\n@@ -254,1 +223,1 @@\n-                null, attrs);\n+                attrs);\n@@ -262,1 +231,1 @@\n-                null, attrs);\n+                attrs);\n@@ -265,1 +234,1 @@\n-                null, attrs);\n+                attrs);\n@@ -270,2 +239,1 @@\n-        add(p, \"Policy\", \"JavaPolicy\", \"sun.security.provider.PolicySpiFile\",\n-                null, null);\n+        add(p, \"Policy\", \"JavaPolicy\", \"sun.security.provider.PolicySpiFile\");\n@@ -277,1 +245,1 @@\n-                \"sun.security.provider.ConfigFile$Spi\", null, null);\n+                \"sun.security.provider.ConfigFile$Spi\");\n@@ -288,1 +256,1 @@\n-                null, attrs);\n+                attrs);\n@@ -291,1 +259,1 @@\n-                null, attrs);\n+                attrs);\n@@ -298,0 +266,4 @@\n+    private void add(Provider p, String type, String algo, String cn) {\n+        services.add(new Provider.Service(p, type, algo, cn, null, null));\n+    }\n+\n@@ -299,2 +271,8 @@\n-            List<String> aliases, HashMap<String, String> attrs) {\n-        services.add(new Provider.Service(p, type, algo, cn, aliases, attrs));\n+            HashMap<String, String> attrs) {\n+        services.add(new Provider.Service(p, type, algo, cn, null, attrs));\n+    }\n+\n+    private void addWithAlias(Provider p, String type, String algo, String cn,\n+            HashMap<String, String> attrs) {\n+        services.add(new Provider.Service(p, type, algo, cn,\n+            getAliases(algo), attrs));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":75,"deletions":97,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.PublicKey;\n@@ -33,2 +32,0 @@\n-import jdk.internal.event.EventHelper;\n-import jdk.internal.event.X509CertificateEvent;\n@@ -107,2 +104,0 @@\n-                \/\/ record cert details if necessary\n-                commitEvent(cert);\n@@ -476,1 +471,1 @@\n-                coll.add(new X509CertImpl(data));\n+                coll.add(X509CertImpl.newX509CertImpl(data));\n@@ -769,39 +764,0 @@\n-\n-    private void commitEvent(X509CertImpl info) {\n-        X509CertificateEvent xce = new X509CertificateEvent();\n-        if (xce.shouldCommit() || EventHelper.isLoggingSecurity()) {\n-            PublicKey pKey = info.getPublicKey();\n-            String algId = info.getSigAlgName();\n-            String serNum = info.getSerialNumber().toString(16);\n-            String subject = info.getSubjectDN().getName();\n-            String issuer = info.getIssuerDN().getName();\n-            String keyType = pKey.getAlgorithm();\n-            int length = KeyUtil.getKeySize(pKey);\n-            int hashCode = info.hashCode();\n-            long beginDate = info.getNotBefore().getTime();\n-            long endDate = info.getNotAfter().getTime();\n-            if (xce.shouldCommit()) {\n-                xce.algorithm = algId;\n-                xce.serialNumber = serNum;\n-                xce.subject = subject;\n-                xce.issuer = issuer;\n-                xce.keyType = keyType;\n-                xce.keyLength = length;\n-                xce.certificateId = hashCode;\n-                xce.validFrom = beginDate;\n-                xce.validUntil = endDate;\n-                xce.commit();\n-            }\n-            if (EventHelper.isLoggingSecurity()) {\n-                EventHelper.logX509CertificateEvent(algId,\n-                        serNum,\n-                        subject,\n-                        issuer,\n-                        keyType,\n-                        length,\n-                        hashCode,\n-                        beginDate,\n-                        endDate);\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        ObjectIdentifier.newInternal(new int[] { 1, 3, 6, 1, 5, 5, 7, 48, 1, 1});\n+        ObjectIdentifier.of(KnownOIDs.OCSPBasicResponse);\n@@ -147,3 +147,0 @@\n-    \/\/ Object identifier for the OCSPSigning key purpose\n-    private static final String KP_OCSP_SIGNING_OID = \"1.3.6.1.5.5.7.3.9\";\n-\n@@ -360,1 +357,1 @@\n-                        new X509CertImpl(derCerts[i].toByteArray());\n+                        X509CertImpl.newX509CertImpl(derCerts[i].toByteArray());\n@@ -498,1 +495,1 @@\n-                        !keyPurposes.contains(KP_OCSP_SIGNING_OID)) {\n+                        !keyPurposes.contains(KnownOIDs.OCSPSigning.value())) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-                    .mapToInt(x -> x.hashCode())\n+                    .mapToInt(Certificate::hashCode)\n@@ -233,2 +233,2 @@\n-            int anchorCertId =\n-                    anchor.getTrustedCert().hashCode();\n+            int anchorCertId = (anchorCert != null) ?\n+                anchorCert.hashCode() : anchor.getCAPublicKey().hashCode();\n@@ -237,1 +237,1 @@\n-                int certificatePos = 1; \/\/anchor cert\n+                int certificatePos = 1; \/\/ most trusted CA\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/PKIXCertPathValidator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -726,1 +727,1 @@\n-                    if (ext.getId().equals(\"1.3.6.1.5.5.7.48.1.2\")) {\n+                    if (ext.getId().equals(KnownOIDs.OCSPNonceExt.value())) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/RevocationChecker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,1 +243,1 @@\n-                                        (new X509CertImpl(opt.toByteArray()));\n+                                        (X509CertImpl.newX509CertImpl(opt.toByteArray()));\n@@ -254,1 +254,1 @@\n-                                        (new X509CertImpl(opt.toByteArray()));\n+                                        (X509CertImpl.newX509CertImpl(opt.toByteArray()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/X509CertificatePair.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                if (!val.getOID().equals(AlgorithmId.mgf1_oid)) {\n+                if (!val.getOID().equals(AlgorithmId.MGF1_oid)) {\n@@ -250,1 +250,1 @@\n-            tmp2.putOID(AlgorithmId.mgf1_oid);\n+            tmp2.putOID(AlgorithmId.MGF1_oid);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/PSSParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,1 @@\n-import sun.security.x509.AlgorithmId;\n-import static sun.security.rsa.RSAUtil.KeyType;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -47,1 +46,2 @@\n- *  . PublicKey with an X.509 encoding\n+ *  . RSA PublicKey with an X.509 encoding\n+ *  . RSA PublicKey with an PKCS#1 encoding\n@@ -53,1 +53,2 @@\n- *  . PrivateKey with a PKCS#8 encoding\n+ *  . RSA PrivateKey with a PKCS#8 encoding\n+ *  . RSA PrivateKey with a PKCS#1 encoding\n@@ -99,2 +100,2 @@\n-    \/\/ Internal utility method for checking key algorithm\n-    private static void checkKeyAlgo(Key key, String expectedAlg)\n+    \/\/ pkg-private utility method for checking key algorithm\n+    static void checkKeyAlgo(Key key, String expectedAlg)\n@@ -214,1 +215,1 @@\n-        checkKeyAlgo(key, type.keyAlgo());\n+        checkKeyAlgo(key, type.keyAlgo);\n@@ -262,1 +263,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaKey.getParams()),\n+                    type, rsaKey.getParams(),\n@@ -269,5 +270,0 @@\n-        } else if (\"X.509\".equals(key.getFormat())) {\n-            RSAPublicKey translated = new RSAPublicKeyImpl(key.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(translated, type.keyAlgo());\n-            return translated;\n@@ -275,2 +271,3 @@\n-            throw new InvalidKeyException(\"Public keys must be instance \"\n-                + \"of RSAPublicKey or have X.509 encoding\");\n+            \/\/ create new key based on the format and encoding of current 'key'\n+            return RSAPublicKeyImpl.newKey(type, key.getFormat(),\n+                key.getEncoded());\n@@ -287,1 +284,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaKey.getParams()),\n+                    type, rsaKey.getParams(),\n@@ -305,1 +302,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaKey.getParams()),\n+                    type, rsaKey.getParams(),\n@@ -313,6 +310,0 @@\n-        } else if (\"PKCS#8\".equals(key.getFormat())) {\n-            RSAPrivateKey translated =\n-                RSAPrivateCrtKeyImpl.newKey(key.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(translated, type.keyAlgo());\n-            return translated;\n@@ -320,2 +311,2 @@\n-            throw new InvalidKeyException(\"Private keys must be instance \"\n-                + \"of RSAPrivate(Crt)Key or have PKCS#8 encoding\");\n+            return RSAPrivateCrtKeyImpl.newKey(type, key.getFormat(),\n+                    key.getEncoded());\n@@ -329,5 +320,2 @@\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            RSAPublicKey generated = new RSAPublicKeyImpl(x509Spec.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(generated, type.keyAlgo());\n-            return generated;\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                    ((X509EncodedKeySpec)keySpec).getEncoded());\n@@ -338,1 +326,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaSpec.getParams()),\n+                    type, rsaSpec.getParams(),\n@@ -355,5 +343,2 @@\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            RSAPrivateKey generated = RSAPrivateCrtKeyImpl.newKey(pkcsSpec.getEncoded());\n-            \/\/ ensure the key algorithm matches the current KeyFactory instance\n-            checkKeyAlgo(generated, type.keyAlgo());\n-            return generated;\n+            return RSAPrivateCrtKeyImpl.newKey(type, \"PKCS#8\",\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n@@ -364,1 +349,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaSpec.getParams()),\n+                    type, rsaSpec.getParams(),\n@@ -381,1 +366,1 @@\n-                    RSAUtil.createAlgorithmId(type, rsaSpec.getParams()),\n+                    type, rsaSpec.getParams(),\n@@ -399,1 +384,2 @@\n-            \/\/ that the encoding is X.509\/PKCS#8 for public\/private keys\n+            \/\/ that the encoding is X.509\/PKCS#8 or PKCS#1 for public\/private\n+            \/\/ keys\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":26,"deletions":40,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import sun.security.rsa.RSAUtil.KeyType;\n+\n@@ -37,2 +39,0 @@\n-import sun.security.x509.AlgorithmId;\n-import static sun.security.rsa.RSAUtil.KeyType;\n@@ -58,1 +58,1 @@\n-    private AlgorithmId rsaId;\n+    private AlgorithmParameterSpec keyParams;\n@@ -119,1 +119,1 @@\n-            this.rsaId = RSAUtil.createAlgorithmId(type, tmpParams);\n+            this.keyParams = RSAUtil.checkParamsAgainstType(type, tmpParams);\n@@ -180,3 +180,4 @@\n-                PublicKey publicKey = new RSAPublicKeyImpl(rsaId, n, e);\n-                PrivateKey privateKey = new RSAPrivateCrtKeyImpl(\n-                    rsaId, n, e, d, p, q, pe, qe, coeff);\n+                PublicKey publicKey = new RSAPublicKeyImpl(type, keyParams,\n+                        n, e);\n+                PrivateKey privateKey = new RSAPrivateCrtKeyImpl(type,\n+                        keyParams, n, e, d, p, q, pe, qe, coeff);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyPairGenerator.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -40,1 +39,1 @@\n-import static sun.security.rsa.RSAUtil.KeyType;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -69,0 +68,2 @@\n+    private transient KeyType type;\n+\n@@ -72,1 +73,1 @@\n-    private AlgorithmParameterSpec keyParams;\n+    private transient AlgorithmParameterSpec keyParams;\n@@ -75,2 +76,4 @@\n-     * Generate a new key from its encoding. Returns a CRT key if possible\n-     * and a non-CRT key otherwise. Used by RSAKeyFactory.\n+     * Generate a new RSAPrivate(Crt)Key from the specified type,\n+     * format and encoding. Returns a CRT key if possible and a non-CRT\n+     * key otherwise.\n+     * Also used by SunPKCS11 provider.\n@@ -78,12 +81,33 @@\n-    public static RSAPrivateKey newKey(byte[] encoded)\n-            throws InvalidKeyException {\n-        RSAPrivateCrtKeyImpl key = new RSAPrivateCrtKeyImpl(encoded);\n-        \/\/ check all CRT-specific components are available, if any one\n-        \/\/ missing, return a non-CRT key instead\n-        if (checkComponents(key)) {\n-            return key;\n-        } else {\n-            return new RSAPrivateKeyImpl(\n-                key.algid,\n-                key.getModulus(),\n-                key.getPrivateExponent());\n+    public static RSAPrivateKey newKey(KeyType type, String format,\n+            byte[] encoded) throws InvalidKeyException {\n+        switch (format) {\n+        case \"PKCS#8\":\n+            RSAPrivateCrtKeyImpl key = new RSAPrivateCrtKeyImpl(encoded);\n+            RSAKeyFactory.checkKeyAlgo(key, type.keyAlgo);\n+            \/\/ check all CRT-specific components are available, if any one\n+            \/\/ missing, return a non-CRT key instead\n+            if (checkComponents(key)) {\n+                return key;\n+            } else {\n+                return new RSAPrivateKeyImpl(key.type, key.keyParams,\n+                    key.getModulus(), key.getPrivateExponent());\n+            }\n+        case \"PKCS#1\":\n+            try {\n+                BigInteger[] comps = parseASN1(encoded);\n+                if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                    (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                    (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                    return new RSAPrivateKeyImpl(type, null, comps[0],\n+                            comps[2]);\n+                } else {\n+                    return new RSAPrivateCrtKeyImpl(type, null, comps[0],\n+                            comps[1], comps[2], comps[3], comps[4], comps[5],\n+                            comps[6], comps[7]);\n+                }\n+            } catch (IOException ioe) {\n+                throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+            }\n+        default:\n+            throw new InvalidKeyException(\"Unsupported RSA Private(Crt)Key \"\n+                    + \"format: \" + format);\n@@ -116,1 +140,0 @@\n-        AlgorithmId rsaId = RSAUtil.createAlgorithmId(type, params);\n@@ -121,1 +144,1 @@\n-            return new RSAPrivateKeyImpl(rsaId, n, d);\n+            return new RSAPrivateKeyImpl(type, params, n, d);\n@@ -123,1 +146,1 @@\n-            return new RSAPrivateCrtKeyImpl(rsaId, n, e, d,\n+            return new RSAPrivateCrtKeyImpl(type, params, n, e, d,\n@@ -131,1 +154,1 @@\n-    RSAPrivateCrtKeyImpl(byte[] encoded) throws InvalidKeyException {\n+    private RSAPrivateCrtKeyImpl(byte[] encoded) throws InvalidKeyException {\n@@ -139,2 +162,4 @@\n-            \/\/ this will check the validity of params\n-            this.keyParams = RSAUtil.getParamSpec(algid);\n+            \/\/ check the validity of oid and params\n+            Object[] o = RSAUtil.getTypeAndParamSpec(algid);\n+            this.type = (KeyType) o[0];\n+            this.keyParams = (AlgorithmParameterSpec) o[1];\n@@ -150,1 +175,1 @@\n-    RSAPrivateCrtKeyImpl(AlgorithmId rsaId,\n+    RSAPrivateCrtKeyImpl(KeyType type, AlgorithmParameterSpec keyParams,\n@@ -164,1 +189,0 @@\n-        this.keyParams = RSAUtil.getParamSpec(rsaId);\n@@ -166,2 +190,0 @@\n-        \/\/ generate the encoding\n-        algid = rsaId;\n@@ -169,0 +191,11 @@\n+            \/\/ validate and generate the algid encoding\n+            algid = RSAUtil.createAlgorithmId(type, keyParams);\n+        } catch (ProviderException exc) {\n+            throw new InvalidKeyException(exc);\n+        }\n+\n+        this.type = type;\n+        this.keyParams = keyParams;\n+\n+        try {\n+            \/\/ generate the key encoding\n@@ -191,1 +224,1 @@\n-        return algid.getName();\n+        return type.keyAlgo;\n@@ -251,3 +284,33 @@\n-        return \"SunRsaSign \" + getAlgorithm() + \" private CRT key, \" + n.bitLength()\n-               + \" bits\" + \"\\n  params: \" + keyParams + \"\\n  modulus: \" + n\n-               + \"\\n  private exponent: \" + d;\n+        return \"SunRsaSign \" + type.keyAlgo + \" private CRT key, \"\n+               + n.bitLength() + \" bits\" + \"\\n  params: \" + keyParams\n+               + \"\\n  modulus: \" + n + \"\\n  private exponent: \" + d;\n+    }\n+\n+    \/\/ utility method for parsing DER encoding of RSA private keys in PKCS#1\n+    \/\/ format as defined in RFC 8017 Appendix A.1.2, i.e. SEQ of version, n,\n+    \/\/ e, d, p, q, pe, qe, and coeff, and return the parsed components.\n+    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+        DerValue derValue = new DerValue(raw);\n+        if (derValue.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Not a SEQUENCE\");\n+        }\n+        int version = derValue.data.getInteger();\n+        if (version != 0) {\n+            throw new IOException(\"Version must be 0\");\n+        }\n+\n+        BigInteger[] result = new BigInteger[8]; \/\/ n, e, d, p, q, pe, qe, coeff\n+        \/*\n+         * Some implementations do not correctly encode ASN.1 INTEGER values\n+         * in 2's complement format, resulting in a negative integer when\n+         * decoded. Correct the error by converting it to a positive integer.\n+         *\n+         * See CR 6255949\n+         *\/\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = derValue.data.getPositiveBigInteger();\n+        }\n+        if (derValue.data.available() != 0) {\n+            throw new IOException(\"Extra data available\");\n+        }\n+        return result;\n@@ -261,29 +324,9 @@\n-            DerInputStream in = new DerInputStream(key);\n-            DerValue derValue = in.getDerValue();\n-            if (derValue.tag != DerValue.tag_Sequence) {\n-                throw new IOException(\"Not a SEQUENCE\");\n-            }\n-            DerInputStream data = derValue.data;\n-            int version = data.getInteger();\n-            if (version != 0) {\n-                throw new IOException(\"Version must be 0\");\n-            }\n-\n-            \/*\n-             * Some implementations do not correctly encode ASN.1 INTEGER values\n-             * in 2's complement format, resulting in a negative integer when\n-             * decoded. Correct the error by converting it to a positive integer.\n-             *\n-             * See CR 6255949\n-             *\/\n-            n = data.getPositiveBigInteger();\n-            e = data.getPositiveBigInteger();\n-            d = data.getPositiveBigInteger();\n-            p = data.getPositiveBigInteger();\n-            q = data.getPositiveBigInteger();\n-            pe = data.getPositiveBigInteger();\n-            qe = data.getPositiveBigInteger();\n-            coeff = data.getPositiveBigInteger();\n-            if (derValue.data.available() != 0) {\n-                throw new IOException(\"Extra data available\");\n-            }\n+            BigInteger[] comps = parseASN1(key);\n+            n = comps[0];\n+            e = comps[1];\n+            d = comps[2];\n+            p = comps[3];\n+            q = comps[4];\n+            pe = comps[5];\n+            qe = comps[6];\n+            coeff = comps[7];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":104,"deletions":61,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -39,0 +38,2 @@\n+import sun.security.rsa.RSAUtil.KeyType;\n+\n@@ -60,0 +61,2 @@\n+    private transient final KeyType type;\n+\n@@ -63,1 +66,1 @@\n-    private final AlgorithmParameterSpec keyParams;\n+    private transient final AlgorithmParameterSpec keyParams;\n@@ -69,2 +72,3 @@\n-    RSAPrivateKeyImpl(AlgorithmId rsaId, BigInteger n, BigInteger d)\n-            throws InvalidKeyException {\n+    RSAPrivateKeyImpl(KeyType type, AlgorithmParameterSpec keyParams,\n+            BigInteger n, BigInteger d) throws InvalidKeyException {\n+\n@@ -75,1 +79,0 @@\n-        this.keyParams = RSAUtil.getParamSpec(rsaId);\n@@ -77,2 +80,0 @@\n-        \/\/ generate the encoding\n-        algid = rsaId;\n@@ -80,0 +81,11 @@\n+            \/\/ validate and generate the algid encoding\n+            algid = RSAUtil.createAlgorithmId(type, keyParams);\n+        } catch (ProviderException pe) {\n+            throw new InvalidKeyException(pe);\n+        }\n+\n+        this.type = type;\n+        this.keyParams = keyParams;\n+\n+        try {\n+            \/\/ generate the key encoding\n@@ -102,1 +114,1 @@\n-        return algid.getName();\n+        return type.keyAlgo;\n@@ -126,1 +138,1 @@\n-        return \"Sun \" + getAlgorithm() + \" private key, \" + n.bitLength()\n+        return \"Sun \" + type.keyAlgo + \" private key, \" + n.bitLength()\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -39,1 +38,1 @@\n-import static sun.security.rsa.RSAUtil.KeyType;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -61,0 +60,2 @@\n+    private transient KeyType type;\n+\n@@ -64,1 +65,1 @@\n-    private AlgorithmParameterSpec keyParams;\n+    private transient AlgorithmParameterSpec keyParams;\n@@ -67,2 +68,3 @@\n-     * Generate a new RSAPublicKey from the specified encoding.\n-     * Used by SunPKCS11 provider.\n+     * Generate a new RSAPublicKey from the specified type, format, and\n+     * encoding.\n+     * Also used by SunPKCS11 provider.\n@@ -70,3 +72,21 @@\n-    public static RSAPublicKey newKey(byte[] encoded)\n-            throws InvalidKeyException {\n-        return new RSAPublicKeyImpl(encoded);\n+    public static RSAPublicKey newKey(KeyType type, String format,\n+            byte[] encoded) throws InvalidKeyException {\n+        RSAPublicKey key;\n+        switch (format) {\n+        case \"X.509\":\n+            key = new RSAPublicKeyImpl(encoded);\n+            RSAKeyFactory.checkKeyAlgo(key, type.keyAlgo);\n+            break;\n+        case \"PKCS#1\":\n+            try {\n+                BigInteger[] comps = parseASN1(encoded);\n+                key = new RSAPublicKeyImpl(type, null, comps[0], comps[1]);\n+            } catch (IOException ioe) {\n+                throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+            }\n+            break;\n+        default:\n+            throw new InvalidKeyException(\"Unsupported RSA PublicKey format: \" +\n+                    format);\n+        }\n+        return key;\n@@ -77,1 +97,1 @@\n-     * Used by SunPKCS11 provider.\n+     * Also used by SunPKCS11 provider.\n@@ -82,2 +102,1 @@\n-        AlgorithmId rsaId = RSAUtil.createAlgorithmId(type, params);\n-        return new RSAPublicKeyImpl(rsaId, n, e);\n+        return new RSAPublicKeyImpl(type, params, n, e);\n@@ -87,1 +106,1 @@\n-     * Construct a RSA key from AlgorithmId and its components. Used by\n+     * Construct a RSA key from the specified type and components. Used by\n@@ -90,2 +109,3 @@\n-    RSAPublicKeyImpl(AlgorithmId rsaId, BigInteger n, BigInteger e)\n-            throws InvalidKeyException {\n+    RSAPublicKeyImpl(KeyType type, AlgorithmParameterSpec keyParams,\n+            BigInteger n, BigInteger e) throws InvalidKeyException {\n+\n@@ -97,1 +117,0 @@\n-        this.keyParams = RSAUtil.getParamSpec(rsaId);\n@@ -99,2 +118,0 @@\n-        \/\/ generate the encoding\n-        algid = rsaId;\n@@ -102,0 +119,11 @@\n+            \/\/ validate and generate algid encoding\n+            algid = RSAUtil.createAlgorithmId(type, keyParams);\n+        } catch (ProviderException pe) {\n+            throw new InvalidKeyException(pe);\n+        }\n+\n+        this.type = type;\n+        this.keyParams = keyParams;\n+\n+        try {\n+            \/\/ generate the key encoding\n@@ -116,1 +144,1 @@\n-     * Construct a key from its encoding. Used by RSAKeyFactory.\n+     * Construct a key from its encoding.\n@@ -118,1 +146,1 @@\n-    RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n+    private RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n@@ -127,2 +155,4 @@\n-            \/\/ this will check the validity of params\n-            this.keyParams = RSAUtil.getParamSpec(algid);\n+            \/\/ check the validity of oid and params\n+            Object[] o = RSAUtil.getTypeAndParamSpec(algid);\n+            this.type = (KeyType) o[0];\n+            this.keyParams = (AlgorithmParameterSpec) o[1];\n@@ -151,1 +181,1 @@\n-        return algid.getName();\n+        return type.keyAlgo;\n@@ -172,0 +202,16 @@\n+    \/\/ utility method for parsing DER encoding of RSA public keys in PKCS#1\n+    \/\/ format as defined in RFC 8017 Appendix A.1.1, i.e. SEQ of n and e.\n+    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+        DerValue derValue = new DerValue(raw);\n+        if (derValue.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Not a SEQUENCE\");\n+        }\n+        BigInteger[] result = new BigInteger[2]; \/\/ n, e\n+        result[0] = derValue.data.getPositiveBigInteger();\n+        result[1] = derValue.data.getPositiveBigInteger();\n+        if (derValue.data.available() != 0) {\n+            throw new IOException(\"Extra data available\");\n+        }\n+        return result;\n+    }\n+\n@@ -177,11 +223,3 @@\n-            DerInputStream in = new DerInputStream(getKey().toByteArray());\n-            DerValue derValue = in.getDerValue();\n-            if (derValue.tag != DerValue.tag_Sequence) {\n-                throw new IOException(\"Not a SEQUENCE\");\n-            }\n-            DerInputStream data = derValue.data;\n-            n = data.getPositiveBigInteger();\n-            e = data.getPositiveBigInteger();\n-            if (derValue.data.available() != 0) {\n-                throw new IOException(\"Extra data available\");\n-            }\n+            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            n = comps[0];\n+            e = comps[1];\n@@ -196,1 +234,1 @@\n-        return \"Sun \" + getAlgorithm() + \" public key, \" + n.bitLength()\n+        return \"Sun \" + type.keyAlgo + \" public key, \" + n.bitLength()\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":73,"deletions":35,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,2 @@\n-        RSA (\"RSA\"),\n-        PSS (\"RSASSA-PSS\")\n+        RSA (\"RSA\", AlgorithmId.RSAEncryption_oid, null),\n+        PSS (\"RSASSA-PSS\", AlgorithmId.RSASSA_PSS_oid, PSSParameterSpec.class)\n@@ -47,1 +47,3 @@\n-        private final String algo;\n+        final String keyAlgo;\n+        final ObjectIdentifier oid;\n+        final Class<? extends AlgorithmParameterSpec> paramSpecCls;\n@@ -49,2 +51,5 @@\n-        KeyType(String keyAlgo) {\n-            this.algo = keyAlgo;\n+        KeyType(String keyAlgo, ObjectIdentifier oid,\n+                Class<? extends AlgorithmParameterSpec> paramSpecCls) {\n+            this.keyAlgo = keyAlgo;\n+            this.oid = oid;\n+            this.paramSpecCls = paramSpecCls;\n@@ -52,12 +57,13 @@\n-        public String keyAlgo() {\n-            return algo;\n-        }\n-        public static KeyType lookup(String name)\n-                throws InvalidKeyException, ProviderException {\n-            if (name == null) {\n-                throw new InvalidKeyException(\"Null key algorithm\");\n-            }\n-            for (KeyType kt : KeyType.values()) {\n-                if (kt.keyAlgo().equalsIgnoreCase(name)) {\n-                    return kt;\n-                }\n+\n+        public static KeyType lookup(String name) throws ProviderException {\n+\n+            requireNonNull(name, \"Key algorithm should not be null\");\n+\n+            \/\/ match loosely in order to work with 3rd party providers which\n+            \/\/ may not follow the standard names\n+            if (name.indexOf(\"PSS\") != -1) {\n+                return PSS;\n+            } else if (name.indexOf(\"RSA\") != -1) {\n+                return RSA;\n+            } else { \/\/ no match\n+                throw new ProviderException(\"Unsupported algorithm \" + name);\n@@ -65,2 +71,0 @@\n-            \/\/ no match\n-            throw new ProviderException(\"Unsupported algorithm \" + name);\n@@ -70,1 +74,5 @@\n-    public static void checkParamsAgainstType(KeyType type,\n+    private static void requireNonNull(Object obj, String msg) {\n+        if (obj == null) throw new ProviderException(msg);\n+    }\n+\n+    public static AlgorithmParameterSpec checkParamsAgainstType(KeyType type,\n@@ -72,17 +80,28 @@\n-        switch (type) {\n-            case RSA:\n-                if (paramSpec != null) {\n-                    throw new ProviderException(\"null params expected for \" +\n-                        type.keyAlgo());\n-                }\n-                break;\n-            case PSS:\n-                if ((paramSpec != null) &&\n-                    !(paramSpec instanceof PSSParameterSpec)) {\n-                    throw new ProviderException\n-                        (\"PSSParmeterSpec expected for \" + type.keyAlgo());\n-                }\n-                break;\n-            default:\n-                throw new ProviderException\n-                    (\"Unsupported RSA algorithm \" + type);\n+\n+        \/\/ currently no check for null parameter spec\n+        \/\/ assumption is parameter spec is optional and can be null\n+        if (paramSpec == null) return null;\n+\n+        Class<? extends AlgorithmParameterSpec> expCls = type.paramSpecCls;\n+        if (expCls == null) {\n+            throw new ProviderException(\"null params expected for \" +\n+                    type.keyAlgo);\n+        } else if (!expCls.isInstance(paramSpec)) {\n+            throw new ProviderException\n+                    (expCls + \" expected for \" + type.keyAlgo);\n+        }\n+        return paramSpec;\n+    }\n+\n+    public static AlgorithmParameters getParams(KeyType type,\n+            AlgorithmParameterSpec spec) throws ProviderException {\n+\n+        if (spec == null) return null;\n+\n+        try {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(type.keyAlgo);\n+            params.init(spec);\n+            return params;\n+        } catch (NoSuchAlgorithmException | InvalidParameterSpecException ex) {\n+            throw new ProviderException(ex);\n@@ -97,29 +116,3 @@\n-        ObjectIdentifier oid = null;\n-        AlgorithmParameters params = null;\n-        try {\n-            switch (type) {\n-                case RSA:\n-                    oid = AlgorithmId.RSAEncryption_oid;\n-                    break;\n-                case PSS:\n-                    if (paramSpec != null) {\n-                        params = AlgorithmParameters.getInstance(type.keyAlgo());\n-                        params.init(paramSpec);\n-                    }\n-                    oid = AlgorithmId.RSASSA_PSS_oid;\n-                    break;\n-                default:\n-                    throw new ProviderException\n-                        (\"Unsupported RSA algorithm \"  + type);\n-            }\n-            AlgorithmId result;\n-            if (params == null) {\n-                result = new AlgorithmId(oid);\n-            } else {\n-                result = new AlgorithmId(oid, params);\n-            }\n-            return result;\n-        } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {\n-            \/\/ should not happen\n-            throw new ProviderException(e);\n-        }\n+        ObjectIdentifier oid = type.oid;\n+        AlgorithmParameters params = getParams(type, paramSpec);\n+        return new AlgorithmId(oid, params);\n@@ -128,4 +121,17 @@\n-    public static AlgorithmParameterSpec getParamSpec(AlgorithmId algid)\n-            throws ProviderException {\n-        if (algid == null) {\n-            throw new ProviderException(\"AlgorithmId should not be null\");\n+    public static AlgorithmParameterSpec getParamSpec(\n+            AlgorithmParameters params) throws ProviderException {\n+\n+        if (params == null) return null;\n+\n+        String algName = params.getAlgorithm();\n+\n+        KeyType type = KeyType.lookup(algName);\n+        Class<? extends AlgorithmParameterSpec> specCls = type.paramSpecCls;\n+        if (specCls == null) {\n+            throw new ProviderException(\"No params accepted for \" +\n+                    type.keyAlgo);\n+        }\n+        try {\n+            return params.getParameterSpec(specCls);\n+        } catch (InvalidParameterSpecException ex) {\n+            throw new ProviderException(ex);\n@@ -133,1 +139,0 @@\n-        return getParamSpec(algid.getParameters());\n@@ -136,1 +141,1 @@\n-    public static AlgorithmParameterSpec getParamSpec(AlgorithmParameters params)\n+    public static Object[] getTypeAndParamSpec(AlgorithmId algid)\n@@ -138,1 +143,0 @@\n-        if (params == null) return null;\n@@ -140,0 +144,5 @@\n+        requireNonNull(algid, \"AlgorithmId should not be null\");\n+\n+        Object[] result = new Object[2];\n+\n+        String algName = algid.getName();\n@@ -141,14 +150,1 @@\n-            String algName = params.getAlgorithm();\n-            KeyType type = KeyType.lookup(algName);\n-            Class<? extends AlgorithmParameterSpec> specCls;\n-            switch (type) {\n-                case RSA:\n-                    throw new ProviderException(\"No params accepted for \" +\n-                        type.keyAlgo());\n-                case PSS:\n-                    specCls = PSSParameterSpec.class;\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported RSA algorithm: \" + algName);\n-            }\n-            return params.getParameterSpec(specCls);\n+            result[0] = KeyType.lookup(algName);\n@@ -156,4 +152,8 @@\n-            \/\/ pass it up\n-            throw pe;\n-        } catch (Exception e) {\n-            throw new ProviderException(e);\n+            \/\/ accommodate RSA keys encoded with various RSA signature oids\n+            \/\/ for backward compatibility\n+            if (algName.indexOf(\"RSA\") != -1) {\n+                result[0] = KeyType.RSA;\n+            } else {\n+                \/\/ pass it up\n+                throw pe;\n+            }\n@@ -161,0 +161,3 @@\n+\n+        result[1] = getParamSpec(algid.getParameters());\n+        return result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAUtil.java","additions":95,"deletions":92,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import static sun.security.provider.SunEntries.createAliasesWithOid;\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n@@ -41,1 +41,8 @@\n-         services.add(new Provider.Service(p, type, algo, cn, aliases, attrs));\n+         services.add(new Provider.Service(p, type, algo, cn,\n+             aliases, attrs));\n+    }\n+\n+    private void addA(Provider p, String type, String algo, String cn,\n+             HashMap<String, String> attrs) {\n+         services.add(new Provider.Service(p, type, algo, cn,\n+             getAliases(algo), attrs));\n@@ -50,7 +57,0 @@\n-\n-        \/\/ common oids\n-        String rsaOid = \"1.2.840.113549.1.1\";\n-        List<String> rsaAliases = createAliasesWithOid(rsaOid);\n-        List<String> rsapssAliases = createAliasesWithOid(rsaOid + \".10\");\n-        String sha1withRSAOid2 = \"1.3.14.3.2.29\";\n-\n@@ -65,1 +65,1 @@\n-                rsaAliases, null);\n+                getAliases(\"PKCS1\"), null);\n@@ -68,28 +68,19 @@\n-                rsaAliases, null);\n-        add(p, \"Signature\", \"MD2withRSA\",\n-                \"sun.security.rsa.RSASignature$MD2withRSA\",\n-                createAliasesWithOid(rsaOid + \".2\"), attrs);\n-        add(p, \"Signature\", \"MD5withRSA\",\n-                \"sun.security.rsa.RSASignature$MD5withRSA\",\n-                createAliasesWithOid(rsaOid + \".4\"), attrs);\n-        add(p, \"Signature\", \"SHA1withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA1withRSA\",\n-                createAliasesWithOid(rsaOid + \".5\", sha1withRSAOid2), attrs);\n-        add(p, \"Signature\", \"SHA224withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA224withRSA\",\n-                createAliasesWithOid(rsaOid + \".14\"), attrs);\n-        add(p, \"Signature\", \"SHA256withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA256withRSA\",\n-                createAliasesWithOid(rsaOid + \".11\"), attrs);\n-        add(p, \"Signature\", \"SHA384withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA384withRSA\",\n-                createAliasesWithOid(rsaOid + \".12\"), attrs);\n-        add(p, \"Signature\", \"SHA512withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA512withRSA\",\n-                createAliasesWithOid(rsaOid + \".13\"), attrs);\n-        add(p, \"Signature\", \"SHA512\/224withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA512_224withRSA\",\n-                createAliasesWithOid(rsaOid + \".15\"), attrs);\n-        add(p, \"Signature\", \"SHA512\/256withRSA\",\n-                \"sun.security.rsa.RSASignature$SHA512_256withRSA\",\n-                createAliasesWithOid(rsaOid + \".16\"), attrs);\n+                getAliases(\"PKCS1\"), null);\n+        addA(p, \"Signature\", \"MD2withRSA\",\n+                \"sun.security.rsa.RSASignature$MD2withRSA\", attrs);\n+        addA(p, \"Signature\", \"MD5withRSA\",\n+                \"sun.security.rsa.RSASignature$MD5withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA1withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA1withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA224withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA224withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA256withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA256withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA384withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA384withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA512withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA512withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA512\/224withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA512_224withRSA\", attrs);\n+        addA(p, \"Signature\", \"SHA512\/256withRSA\",\n+                \"sun.security.rsa.RSASignature$SHA512_256withRSA\", attrs);\n@@ -97,12 +88,8 @@\n-        add(p, \"KeyFactory\", \"RSASSA-PSS\",\n-                \"sun.security.rsa.RSAKeyFactory$PSS\",\n-                rsapssAliases, null);\n-        add(p, \"KeyPairGenerator\", \"RSASSA-PSS\",\n-                \"sun.security.rsa.RSAKeyPairGenerator$PSS\",\n-                rsapssAliases, null);\n-        add(p, \"Signature\", \"RSASSA-PSS\",\n-                \"sun.security.rsa.RSAPSSSignature\",\n-                rsapssAliases, attrs);\n-        add(p, \"AlgorithmParameters\", \"RSASSA-PSS\",\n-                \"sun.security.rsa.PSSParameters\",\n-                rsapssAliases, null);\n+        addA(p, \"KeyFactory\", \"RSASSA-PSS\",\n+                \"sun.security.rsa.RSAKeyFactory$PSS\", attrs);\n+        addA(p, \"KeyPairGenerator\", \"RSASSA-PSS\",\n+                \"sun.security.rsa.RSAKeyPairGenerator$PSS\", attrs);\n+        addA(p, \"Signature\", \"RSASSA-PSS\",\n+                \"sun.security.rsa.RSAPSSSignature\", attrs);\n+        addA(p, \"AlgorithmParameters\", \"RSASSA-PSS\",\n+                \"sun.security.rsa.PSSParameters\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/SunRsaSignEntries.java","additions":38,"deletions":51,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-        this.preferLocalCipherSuites = false;\n+        this.preferLocalCipherSuites = true;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import static sun.security.provider.SunEntries.createAliases;\n+import static sun.security.util.SecurityProviderConstants.*;\n@@ -164,2 +164,2 @@\n-            List<String> aliases, HashMap<String, String> attrs) {\n-        putService(new Provider.Service(this, type, algo, cn, aliases, attrs));\n+            List<String> a, HashMap<String, String> attrs) {\n+        putService(new Provider.Service(this, type, algo, cn, a, attrs));\n@@ -183,1 +183,1 @@\n-            createAliases(\"PKIX\"), null);\n+            List.of(\"PKIX\"), null);\n@@ -189,1 +189,1 @@\n-            createAliases(\"SunPKIX\", \"X509\", \"X.509\"), null);\n+           List.of(\"SunPKIX\", \"X509\", \"X.509\"), null);\n@@ -193,1 +193,1 @@\n-            (isfips? null : createAliases(\"SSLv3\")), null);\n+            (isfips? null : List.of(\"SSLv3\")), null);\n@@ -202,1 +202,1 @@\n-            (isfips? null : createAliases(\"SSL\")), null);\n+            (isfips? null : List.of(\"SSL\")), null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SunJSSE.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -524,2 +525,4 @@\n-        CLIENT(new HashSet<String>(Arrays.asList(new String[] {\n-            \"2.5.29.37.0\", \"1.3.6.1.5.5.7.3.2\" }))),\n+        CLIENT(new HashSet<String>(List.of(\n+            KnownOIDs.anyExtendedKeyUsage.value(),\n+            KnownOIDs.clientAuth.value()\n+        ))),\n@@ -529,3 +532,6 @@\n-        SERVER(new HashSet<String>(Arrays.asList(new String[] {\n-            \"2.5.29.37.0\", \"1.3.6.1.5.5.7.3.1\", \"2.16.840.1.113730.4.1\",\n-            \"1.3.6.1.4.1.311.10.3.3\" })));\n+        SERVER(new HashSet<String>(List.of(\n+            KnownOIDs.anyExtendedKeyUsage.value(),\n+            KnownOIDs.serverAuth.value(),\n+            KnownOIDs.NETSCAPE_ExportApproved.value(),\n+            KnownOIDs.MICROSOFT_ExportApproved.value()\n+        )));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-            request.putOID(new ObjectIdentifier(policyId));\n+            request.putOID(ObjectIdentifier.of(policyId));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/timestamp\/TSRequest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4280,0 +4280,17 @@\n+    \/**\n+     * Match a command with a command set. The match can be exact, or\n+     * partial, or case-insensitive.\n+     *\n+     * @param s the command provided by user\n+     * @param list the legal command set represented by KnownOIDs enums.\n+     * @return the position of a single match, or -1 if none matched\n+     * @throws Exception if s is ambiguous\n+     *\/\n+    private static int oneOf(String s, KnownOIDs... list) throws Exception {\n+        String[] convertedList = new String[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            convertedList[i] = list[i].stdName();\n+        }\n+        return oneOf(s, convertedList);\n+    }\n+\n@@ -4398,1 +4415,1 @@\n-            default: return new ObjectIdentifier(type);\n+            default: return ObjectIdentifier.of(type);\n@@ -4619,0 +4636,9 @@\n+                            KnownOIDs[] choices = {\n+                                    KnownOIDs.anyExtendedKeyUsage,\n+                                    KnownOIDs.serverAuth,\n+                                    KnownOIDs.clientAuth,\n+                                    KnownOIDs.codeSigning,\n+                                    KnownOIDs.emailProtection,\n+                                    KnownOIDs.KP_TimeStamping,\n+                                    KnownOIDs.OCSPSigning\n+                            };\n@@ -4620,23 +4646,10 @@\n-                                int p = oneOf(s,\n-                                        \"anyExtendedKeyUsage\",\n-                                        \"serverAuth\",       \/\/1\n-                                        \"clientAuth\",       \/\/2\n-                                        \"codeSigning\",      \/\/3\n-                                        \"emailProtection\",  \/\/4\n-                                        \"\",                 \/\/5\n-                                        \"\",                 \/\/6\n-                                        \"\",                 \/\/7\n-                                        \"timeStamping\",     \/\/8\n-                                        \"OCSPSigning\"       \/\/9\n-                                       );\n-                                if (p < 0) {\n-                                    try {\n-                                        v.add(new ObjectIdentifier(s));\n-                                    } catch (Exception e) {\n-                                        throw new Exception(rb.getString(\n-                                                \"Unknown.extendedkeyUsage.type.\") + s);\n-                                    }\n-                                } else if (p == 0) {\n-                                    v.add(new ObjectIdentifier(\"2.5.29.37.0\"));\n-                                } else {\n-                                    v.add(new ObjectIdentifier(\"1.3.6.1.5.5.7.3.\" + p));\n+                                int p = oneOf(s, choices);\n+                                String o = s;\n+                                if (p >= 0) {\n+                                    o = choices[p].value();\n+                                }\n+                                try {\n+                                    v.add(ObjectIdentifier.of(o));\n+                                } catch (Exception e) {\n+                                    throw new Exception(rb.getString(\n+                                            \"Unknown.extendedkeyUsage.type.\") + s);\n@@ -4697,8 +4710,7 @@\n-                                int p = oneOf(m,\n-                                        \"\",\n-                                        \"ocsp\",         \/\/1\n-                                        \"caIssuers\",    \/\/2\n-                                        \"timeStamping\", \/\/3\n-                                        \"\",\n-                                        \"caRepository\"  \/\/5\n-                                        );\n+                                KnownOIDs[] choices = {\n+                                    KnownOIDs.OCSP,\n+                                    KnownOIDs.caIssuers,\n+                                    KnownOIDs.AD_TimeStamping,\n+                                    KnownOIDs.caRepository\n+                                };\n+                                int p = oneOf(m, choices);\n@@ -4706,1 +4718,3 @@\n-                                if (p < 0) {\n+                                if (p >= 0) {\n+                                    oid = ObjectIdentifier.of(choices[p]);\n+                                } else {\n@@ -4708,1 +4722,1 @@\n-                                        oid = new ObjectIdentifier(m);\n+                                        oid = ObjectIdentifier.of(m);\n@@ -4713,2 +4727,0 @@\n-                                } else {\n-                                    oid = new ObjectIdentifier(\"1.3.6.1.5.5.7.48.\" + p);\n@@ -4751,1 +4763,1 @@\n-                        ObjectIdentifier oid = new ObjectIdentifier(name);\n+                        ObjectIdentifier oid = ObjectIdentifier.of(name);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":49,"deletions":37,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ConstraintsParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.regex.Pattern;\n@@ -57,2 +56,0 @@\n-    public static final String SPLIT_PATTERN = \",|\\\\[|\\\\]\";\n-\n@@ -120,3 +117,2 @@\n-    private static void add(String name, String soid, int type, String sfield,\n-            String a, String b, String x, String y, String n, int h,\n-            Pattern nameSplitPattern) {\n+    private static void add(KnownOIDs o, int type, String sfield,\n+            String a, String b, String x, String y, String n, int h) {\n@@ -136,3 +132,4 @@\n-        NamedCurve params = new NamedCurve(name, soid, curve, g, bi(n), h);\n-        if (oidMap.put(soid, params) != null) {\n-            throw new RuntimeException(\"Duplication oid: \" + soid);\n+        String oid = o.value();\n+        NamedCurve params = new NamedCurve(o, curve, g, bi(n), h);\n+        if (oidMap.put(oid, params) != null) {\n+            throw new RuntimeException(\"Duplication oid: \" + oid);\n@@ -141,4 +138,4 @@\n-        String[] commonNames = nameSplitPattern.split(name);\n-        for (String commonName : commonNames) {\n-            if (nameMap.put(commonName.trim(), params) != null) {\n-                throw new RuntimeException(\"Duplication name: \" + commonName);\n+        for (String cn : params.getNameAndAliases()) {\n+            if (nameMap.put(cn,\n+                        params) != null) {\n+                throw new RuntimeException(\"Duplication name: \" + cn);\n@@ -156,19 +153,0 @@\n-    private static class Holder {\n-        private static final Pattern nameSplitPattern = Pattern.compile(\n-                SPLIT_PATTERN);\n-    }\n-\n-    \/\/ Return all the names the EC curve could be using.\n-    static String[] getNamesByOID(String oid) {\n-        NamedCurve nc = oidMap.get(oid);\n-        if (nc == null) {\n-            return new String[0];\n-        }\n-        String[] list = Holder.nameSplitPattern.split(nc.getName());\n-        int i = 0;\n-        do {\n-            list[i] = list[i].trim();\n-        } while (++i < list.length);\n-        return list;\n-    }\n-\n@@ -176,2 +154,0 @@\n-        Pattern nameSplitPattern = Holder.nameSplitPattern;\n-\n@@ -179,1 +155,1 @@\n-        add(\"secp112r1\", \"1.3.132.0.6\", P,\n+        add(KnownOIDs.secp112r1, P,\n@@ -186,1 +162,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -188,1 +164,1 @@\n-        add(\"secp112r2\", \"1.3.132.0.7\", P,\n+        add(KnownOIDs.secp112r2, P,\n@@ -195,1 +171,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -197,1 +173,1 @@\n-        add(\"secp128r1\", \"1.3.132.0.28\", P,\n+        add(KnownOIDs.secp128r1, P,\n@@ -204,1 +180,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -206,1 +182,1 @@\n-        add(\"secp128r2\", \"1.3.132.0.29\", P,\n+        add(KnownOIDs.secp128r2, P,\n@@ -213,1 +189,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -215,1 +191,1 @@\n-        add(\"secp160k1\", \"1.3.132.0.9\", P,\n+        add(KnownOIDs.secp160k1, P,\n@@ -222,1 +198,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -224,1 +200,1 @@\n-        add(\"secp160r1\", \"1.3.132.0.8\", P,\n+        add(KnownOIDs.secp160r1, P,\n@@ -231,1 +207,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -233,1 +209,1 @@\n-        add(\"secp160r2\", \"1.3.132.0.30\", P,\n+        add(KnownOIDs.secp160r2, P,\n@@ -240,1 +216,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -242,1 +218,1 @@\n-        add(\"secp192k1\", \"1.3.132.0.31\", P,\n+        add(KnownOIDs.secp192k1, P,\n@@ -249,1 +225,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -251,1 +227,1 @@\n-        add(\"secp192r1 [NIST P-192, X9.62 prime192v1]\", \"1.2.840.10045.3.1.1\", PD,\n+        add(KnownOIDs.secp192r1, PD,\n@@ -258,1 +234,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -260,1 +236,1 @@\n-        add(\"secp224k1\", \"1.3.132.0.32\", P,\n+        add(KnownOIDs.secp224k1, P,\n@@ -267,1 +243,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -269,1 +245,1 @@\n-        add(\"secp224r1 [NIST P-224]\", \"1.3.132.0.33\", PD,\n+        add(KnownOIDs.secp224r1, PD,\n@@ -276,1 +252,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -278,1 +254,1 @@\n-        add(\"secp256k1\", \"1.3.132.0.10\", P,\n+        add(KnownOIDs.secp256k1, P,\n@@ -285,1 +261,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -287,1 +263,1 @@\n-        add(\"secp256r1 [NIST P-256, X9.62 prime256v1]\", \"1.2.840.10045.3.1.7\", PD,\n+        add(KnownOIDs.secp256r1, PD,\n@@ -294,1 +270,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -296,1 +272,1 @@\n-        add(\"secp384r1 [NIST P-384]\", \"1.3.132.0.34\", PD,\n+        add(KnownOIDs.secp384r1, PD,\n@@ -303,1 +279,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -305,1 +281,1 @@\n-        add(\"secp521r1 [NIST P-521]\", \"1.3.132.0.35\", PD,\n+        add(KnownOIDs.secp521r1, PD,\n@@ -312,1 +288,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -315,1 +291,1 @@\n-        add(\"X9.62 prime192v2\", \"1.2.840.10045.3.1.2\", P,\n+        add(KnownOIDs.prime192v2, P,\n@@ -322,1 +298,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -324,1 +300,1 @@\n-        add(\"X9.62 prime192v3\", \"1.2.840.10045.3.1.3\", P,\n+        add(KnownOIDs.prime192v3, P,\n@@ -331,1 +307,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -333,1 +309,1 @@\n-        add(\"X9.62 prime239v1\", \"1.2.840.10045.3.1.4\", P,\n+        add(KnownOIDs.prime239v1, P,\n@@ -340,1 +316,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -342,1 +318,1 @@\n-        add(\"X9.62 prime239v2\", \"1.2.840.10045.3.1.5\", P,\n+        add(KnownOIDs.prime239v2, P,\n@@ -349,1 +325,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -351,1 +327,1 @@\n-        add(\"X9.62 prime239v3\", \"1.2.840.10045.3.1.6\", P,\n+        add(KnownOIDs.prime239v3, P,\n@@ -358,1 +334,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -361,1 +337,1 @@\n-        add(\"sect113r1\", \"1.3.132.0.4\", B,\n+        add(KnownOIDs.sect113r1, B,\n@@ -368,1 +344,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -370,1 +346,1 @@\n-        add(\"sect113r2\", \"1.3.132.0.5\", B,\n+        add(KnownOIDs.sect113r2, B,\n@@ -377,1 +353,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -379,1 +355,1 @@\n-        add(\"sect131r1\", \"1.3.132.0.22\", B,\n+        add(KnownOIDs.sect131r1, B,\n@@ -386,1 +362,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -388,1 +364,1 @@\n-        add(\"sect131r2\", \"1.3.132.0.23\", B,\n+        add(KnownOIDs.sect131r2, B,\n@@ -395,1 +371,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -397,1 +373,1 @@\n-        add(\"sect163k1 [NIST K-163]\", \"1.3.132.0.1\", BD,\n+        add(KnownOIDs.sect163k1, BD,\n@@ -404,1 +380,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -406,1 +382,1 @@\n-        add(\"sect163r1\", \"1.3.132.0.2\", B,\n+        add(KnownOIDs.sect163r1, B,\n@@ -413,1 +389,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -415,1 +391,1 @@\n-        add(\"sect163r2 [NIST B-163]\", \"1.3.132.0.15\", BD,\n+        add(KnownOIDs.sect163r2, BD,\n@@ -422,1 +398,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -424,1 +400,1 @@\n-        add(\"sect193r1\", \"1.3.132.0.24\", B,\n+        add(KnownOIDs.sect193r1, B,\n@@ -431,1 +407,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -433,1 +409,1 @@\n-        add(\"sect193r2\", \"1.3.132.0.25\", B,\n+        add(KnownOIDs.sect193r2, B,\n@@ -440,1 +416,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -442,1 +418,1 @@\n-        add(\"sect233k1 [NIST K-233]\", \"1.3.132.0.26\", BD,\n+        add(KnownOIDs.sect233k1, BD,\n@@ -449,1 +425,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -451,1 +427,1 @@\n-        add(\"sect233r1 [NIST B-233]\", \"1.3.132.0.27\", B,\n+        add(KnownOIDs.sect233r1, B,\n@@ -458,1 +434,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -460,1 +436,1 @@\n-        add(\"sect239k1\", \"1.3.132.0.3\", B,\n+        add(KnownOIDs.sect239k1, B,\n@@ -467,1 +443,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -469,1 +445,1 @@\n-        add(\"sect283k1 [NIST K-283]\", \"1.3.132.0.16\", BD,\n+        add(KnownOIDs.sect283k1, BD,\n@@ -476,1 +452,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -478,1 +454,1 @@\n-        add(\"sect283r1 [NIST B-283]\", \"1.3.132.0.17\", B,\n+        add(KnownOIDs.sect283r1, B,\n@@ -485,1 +461,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -487,1 +463,1 @@\n-        add(\"sect409k1 [NIST K-409]\", \"1.3.132.0.36\", BD,\n+        add(KnownOIDs.sect409k1, BD,\n@@ -494,1 +470,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -496,1 +472,1 @@\n-        add(\"sect409r1 [NIST B-409]\", \"1.3.132.0.37\", B,\n+        add(KnownOIDs.sect409r1, B,\n@@ -503,1 +479,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -505,1 +481,1 @@\n-        add(\"sect571k1 [NIST K-571]\", \"1.3.132.0.38\", BD,\n+        add(KnownOIDs.sect571k1, BD,\n@@ -512,1 +488,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -514,1 +490,1 @@\n-        add(\"sect571r1 [NIST B-571]\", \"1.3.132.0.39\", B,\n+        add(KnownOIDs.sect571r1, B,\n@@ -521,1 +497,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -524,1 +500,1 @@\n-        add(\"X9.62 c2tnb191v1\", \"1.2.840.10045.3.0.5\", B,\n+        add(KnownOIDs.c2tnb191v1, B,\n@@ -531,1 +507,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -533,1 +509,1 @@\n-        add(\"X9.62 c2tnb191v2\", \"1.2.840.10045.3.0.6\", B,\n+        add(KnownOIDs.c2tnb191v2, B,\n@@ -540,1 +516,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -542,1 +518,1 @@\n-        add(\"X9.62 c2tnb191v3\", \"1.2.840.10045.3.0.7\", B,\n+        add(KnownOIDs.c2tnb191v3, B,\n@@ -549,1 +525,1 @@\n-            6, nameSplitPattern);\n+            6);\n@@ -551,1 +527,1 @@\n-        add(\"X9.62 c2tnb239v1\", \"1.2.840.10045.3.0.11\", B,\n+        add(KnownOIDs.c2tnb239v1, B,\n@@ -558,1 +534,1 @@\n-            4, nameSplitPattern);\n+            4);\n@@ -560,1 +536,1 @@\n-        add(\"X9.62 c2tnb239v2\", \"1.2.840.10045.3.0.12\", B,\n+        add(KnownOIDs.c2tnb239v2, B,\n@@ -567,1 +543,1 @@\n-            6, nameSplitPattern);\n+            6);\n@@ -569,1 +545,1 @@\n-        add(\"X9.62 c2tnb239v3\", \"1.2.840.10045.3.0.13\", B,\n+        add(KnownOIDs.c2tnb239v3, B,\n@@ -576,1 +552,1 @@\n-            0xA, nameSplitPattern);\n+            0xA);\n@@ -578,1 +554,1 @@\n-        add(\"X9.62 c2tnb359v1\", \"1.2.840.10045.3.0.18\", B,\n+        add(KnownOIDs.c2tnb359v1, B,\n@@ -585,1 +561,1 @@\n-            0x4C, nameSplitPattern);\n+            0x4C);\n@@ -587,1 +563,1 @@\n-        add(\"X9.62 c2tnb431r1\", \"1.2.840.10045.3.0.20\", B,\n+        add(KnownOIDs.c2tnb431r1, B,\n@@ -594,1 +570,1 @@\n-            0x2760, nameSplitPattern);\n+            0x2760);\n@@ -602,1 +578,1 @@\n-        add(\"X9.62 c2pnb163v1\", \"1.2.840.10045.3.0.1\", B,\n+        add(KnownOIDs.c2pnb163v1, B,\n@@ -609,1 +585,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -611,1 +587,1 @@\n-        add(\"X9.62 c2pnb163v2\", \"1.2.840.10045.3.0.2\", B,\n+        add(KnownOIDs.c2pnb163v2, B,\n@@ -618,1 +594,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -620,1 +596,1 @@\n-        add(\"X9.62 c2pnb163v3\", \"1.2.840.10045.3.0.3\", B,\n+        add(KnownOIDs.c2pnb163v3, B,\n@@ -627,1 +603,1 @@\n-            2, nameSplitPattern);\n+            2);\n@@ -629,1 +605,1 @@\n-        add(\"X9.62 c2pnb176w1\", \"1.2.840.10045.3.0.4\", B,\n+        add(KnownOIDs.c2pnb176w1, B,\n@@ -636,1 +612,1 @@\n-            0xFF6E, nameSplitPattern);\n+            0xFF6E);\n@@ -638,1 +614,1 @@\n-        add(\"X9.62 c2pnb208w1\", \"1.2.840.10045.3.0.10\", B,\n+        add(KnownOIDs.c2pnb208w1, B,\n@@ -645,1 +621,1 @@\n-            0xFE48, nameSplitPattern);\n+            0xFE48);\n@@ -647,1 +623,1 @@\n-        add(\"X9.62 c2pnb272w1\", \"1.2.840.10045.3.0.16\", B,\n+        add(KnownOIDs.c2pnb272w1, B,\n@@ -654,1 +630,1 @@\n-            0xFF06, nameSplitPattern);\n+            0xFF06);\n@@ -656,1 +632,1 @@\n-        add(\"X9.62 c2pnb304w1\", \"1.2.840.10045.3.0.17\", B,\n+        add(KnownOIDs.c2pnb304w1, B,\n@@ -663,1 +639,1 @@\n-            0xFE2E, nameSplitPattern);\n+            0xFE2E);\n@@ -665,1 +641,1 @@\n-        add(\"X9.62 c2pnb368w1\", \"1.2.840.10045.3.0.19\", B,\n+        add(KnownOIDs.c2pnb368w1, B,\n@@ -672,1 +648,1 @@\n-            0xFF70, nameSplitPattern);\n+            0xFF70);\n@@ -680,1 +656,1 @@\n-        add(\"brainpoolP160r1\", \"1.3.36.3.3.2.8.1.1.1\", P,\n+        add(KnownOIDs.brainpoolP160r1, P,\n@@ -687,1 +663,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -689,1 +665,1 @@\n-        add(\"brainpoolP192r1\", \"1.3.36.3.3.2.8.1.1.3\", P,\n+        add(KnownOIDs.brainpoolP192r1, P,\n@@ -696,1 +672,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -698,1 +674,1 @@\n-        add(\"brainpoolP224r1\", \"1.3.36.3.3.2.8.1.1.5\", P,\n+        add(KnownOIDs.brainpoolP224r1, P,\n@@ -705,1 +681,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -707,1 +683,1 @@\n-        add(\"brainpoolP256r1\", \"1.3.36.3.3.2.8.1.1.7\", P,\n+        add(KnownOIDs.brainpoolP256r1, P,\n@@ -714,1 +690,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -716,1 +692,1 @@\n-        add(\"brainpoolP320r1\", \"1.3.36.3.3.2.8.1.1.9\", P,\n+        add(KnownOIDs.brainpoolP320r1, P,\n@@ -723,1 +699,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -725,1 +701,1 @@\n-        add(\"brainpoolP384r1\", \"1.3.36.3.3.2.8.1.1.11\", P,\n+        add(KnownOIDs.brainpoolP384r1, P,\n@@ -732,1 +708,1 @@\n-            1, nameSplitPattern);\n+            1);\n@@ -734,1 +710,1 @@\n-        add(\"brainpoolP512r1\", \"1.3.36.3.3.2.8.1.1.13\", P,\n+        add(KnownOIDs.brainpoolP512r1, P,\n@@ -741,1 +717,1 @@\n-            1, nameSplitPattern);\n+            1);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CurveDB.java","additions":133,"deletions":157,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-                               : Arrays.asList(CurveDB.getNamesByOID(nc.getObjectId())));\n+                               : Arrays.asList(nc.getNameAndAliases()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -359,0 +359,5 @@\n+    OIW_SHA1withRSA_Odd(\"1.3.14.3.2.15\", \"SHA1withRSA\") {\n+        @Override\n+        boolean registerNames() { return false; }\n+    },\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-\n+import java.util.Arrays;\n@@ -42,2 +42,2 @@\n-    \/\/ friendly name for toString() output\n-    private final String name;\n+    \/\/ friendly names with stdName followed by aliases\n+    private final String[] nameAndAliases;\n@@ -51,1 +51,1 @@\n-    NamedCurve(String name, String oid, EllipticCurve curve,\n+    NamedCurve(KnownOIDs ko, EllipticCurve curve,\n@@ -54,2 +54,4 @@\n-        this.name = name;\n-        this.oid = oid;\n+        String[] aliases = ko.aliases();\n+        this.nameAndAliases = new String[aliases.length + 1];\n+        nameAndAliases[0] = ko.stdName();\n+        System.arraycopy(aliases, 0, nameAndAliases, 1, aliases.length);\n@@ -57,1 +59,1 @@\n-        DerOutputStream out = new DerOutputStream();\n+        this.oid = ko.value();\n@@ -59,0 +61,1 @@\n+        DerOutputStream out = new DerOutputStream();\n@@ -60,1 +63,1 @@\n-            out.putOID(new ObjectIdentifier(oid));\n+            out.putOID(ObjectIdentifier.of(ko));\n@@ -64,1 +67,0 @@\n-\n@@ -68,2 +70,3 @@\n-    public String getName() {\n-        return name;\n+    \/\/ returns the curve's standard name followed by its aliases\n+    public String[] getNameAndAliases() {\n+        return nameAndAliases;\n@@ -81,1 +84,12 @@\n-        return name + \" (\" + oid + \")\";\n+        StringBuilder sb = new StringBuilder(nameAndAliases[0]);\n+        if (nameAndAliases.length > 1) {\n+            sb.append(\" [\");\n+            int j = 1;\n+            while (j < nameAndAliases.length - 1) {\n+                sb.append(nameAndAliases[j++]);\n+                sb.append(',');\n+            }\n+            sb.append(nameAndAliases[j] + \"]\");\n+        }\n+        sb.append(\" (\" + oid + \")\");\n+        return sb.toString();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/NamedCurve.java","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -54,3 +54,1 @@\n-public final\n-class ObjectIdentifier implements Serializable\n-{\n+public final class ObjectIdentifier implements Serializable {\n@@ -76,1 +74,0 @@\n-\n@@ -122,0 +119,1 @@\n+\n@@ -166,1 +164,2 @@\n-        static HugeOidNotSupportedByOldJDK theOne = new HugeOidNotSupportedByOldJDK();\n+        static HugeOidNotSupportedByOldJDK theOne =\n+                new HugeOidNotSupportedByOldJDK();\n@@ -173,2 +172,1 @@\n-    public ObjectIdentifier (String oid) throws IOException\n-    {\n+    private ObjectIdentifier(String oid) throws IOException {\n@@ -270,2 +268,1 @@\n-    public ObjectIdentifier (DerInputStream in) throws IOException\n-    {\n+    public ObjectIdentifier(DerInputStream in) throws IOException {\n@@ -284,1 +281,1 @@\n-        type_id = (byte) in.getByte ();\n+        type_id = (byte)in.getByte();\n@@ -309,2 +306,1 @@\n-    ObjectIdentifier (DerInputBuffer buf) throws IOException\n-    {\n+    ObjectIdentifier(DerInputBuffer buf) throws IOException {\n@@ -364,0 +360,5 @@\n+    \/**\n+     * Returns an ObjectIdentifier instance for the specific String.\n+     *\n+     * If the String is not a valid OID string, an IOException is thrown.\n+     *\/\n@@ -396,2 +397,1 @@\n-    void encode (DerOutputStream out) throws IOException\n-    {\n+    void encode(DerOutputStream out) throws IOException {\n@@ -438,1 +438,2 @@\n-                    BigInteger big = new BigInteger(1, pack(encoding, fromPos, i-fromPos+1, 7, 8));\n+                    BigInteger big = new BigInteger(1, pack(encoding,\n+                            fromPos, i-fromPos+1, 7, 8));\n@@ -441,2 +442,4 @@\n-                        BigInteger second = big.subtract(BigInteger.valueOf(80));\n-                        if (second.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\n+                        BigInteger second =\n+                                big.subtract(BigInteger.valueOf(80));\n+                        if (second.compareTo(\n+                                BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\n@@ -448,1 +451,2 @@\n-                        if (big.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\n+                        if (big.compareTo(\n+                                BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\n@@ -503,1 +507,2 @@\n-                        BigInteger big = new BigInteger(1, pack(encoding, fromPos, i-fromPos+1, 7, 8));\n+                        BigInteger big = new BigInteger(\n+                                1, pack(encoding, fromPos, i-fromPos+1, 7, 8));\n@@ -544,1 +549,1 @@\n-     * number is defined as the number of useful bits (NUB) for the array. All the\n+     * number is defined as the number of useful bits (NUB) for the array. All\n@@ -566,1 +571,2 @@\n-    private static byte[] pack(byte[] in, int ioffset, int ilength, int iw, int ow) {\n+    private static byte[] pack(byte[] in,\n+            int ioffset, int ilength, int iw, int ow) {\n@@ -588,0 +594,1 @@\n+\n@@ -589,5 +596,5 @@\n-            out[opos\/ow] |=                         \/\/ paste!\n-                (((in[ioffset+ipos\/iw]+256)         \/\/ locate the byte (+256 so that it's never negative)\n-                    >> (iw-ipos%iw-count))          \/\/ move to the end of a byte\n-                        & ((1 << (count))-1))       \/\/ zero out all other bits\n-                            << (ow-opos%ow-count);  \/\/ move to the output position\n+            out[opos\/ow] |=                     \/\/ paste!\n+                (((in[ioffset+ipos\/iw]+256)     \/\/ locate the byte (+256 so that it's never negative)\n+                    >> (iw-ipos%iw-count)) &    \/\/ move to the end of a byte\n+                  ((1 << (count))-1))           \/\/ zero out all other bits\n+                        << (ow-opos%ow-count);  \/\/ move to the output position\n@@ -609,1 +616,2 @@\n-    private static int pack7Oid(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {\n+    private static int pack7Oid(byte[] in,\n+            int ioffset, int ilength, byte[] out, int ooffset) {\n@@ -618,1 +626,2 @@\n-        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);\n+        System.arraycopy(pack, firstNonZero,\n+                out, ooffset, pack.length-firstNonZero);\n@@ -629,1 +638,2 @@\n-    private static int pack8(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {\n+    private static int pack8(byte[] in,\n+            int ioffset, int ilength, byte[] out, int ooffset) {\n@@ -637,1 +647,2 @@\n-        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);\n+        System.arraycopy(pack, firstNonZero,\n+                out, ooffset, pack.length-firstNonZero);\n@@ -689,0 +700,1 @@\n+\n@@ -695,0 +707,1 @@\n+\n@@ -701,1 +714,3 @@\n-    private static void checkFirstComponent(BigInteger first) throws IOException {\n+\n+    private static void checkFirstComponent(\n+            BigInteger first) throws IOException {\n@@ -707,1 +722,3 @@\n-    private static void checkSecondComponent(int first, int second) throws IOException {\n+\n+    private static void checkSecondComponent(\n+            int first, int second) throws IOException {\n@@ -713,1 +730,3 @@\n-    private static void checkSecondComponent(int first, BigInteger second) throws IOException {\n+\n+    private static void checkSecondComponent(\n+            int first, BigInteger second) throws IOException {\n@@ -721,0 +740,1 @@\n+\n@@ -727,1 +747,3 @@\n-    private static void checkOtherComponent(int i, BigInteger num) throws IOException {\n+\n+    private static void checkOtherComponent(\n+            int i, BigInteger num) throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ObjectIdentifier.java","additions":56,"deletions":34,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -30,0 +32,1 @@\n+import java.security.ProviderException;\n@@ -38,0 +41,3 @@\n+    \/\/ Cannot create one of these\n+    private SecurityProviderConstants () {}\n+\n@@ -41,2 +47,47 @@\n-    \/\/ Cannot create one of these\n-    private SecurityProviderConstants () {\n+    \/\/ cache for provider aliases; key is the standard algorithm name\n+    \/\/ value is the associated aliases List\n+    private static final ConcurrentHashMap<String, List<String>> aliasesMap;\n+\n+    \/\/ utility method for generating aliases list using the supplied\n+    \/\/ 'oid' and 'extraAliases', then store into \"aliasesMap\" cache under the\n+    \/\/ key 'stdName'\n+    private static List<String> store(String stdName, KnownOIDs oid,\n+            String ... extraAliases) {\n+        List<String> value;\n+        if (oid == null && extraAliases.length != 0) {\n+            value = List.of(extraAliases);\n+        } else {\n+            value = new ArrayList<>();\n+            if (oid != null) {\n+                value.add(\"OID.\" + oid.value());\n+                value.add(oid.value());\n+                String[] knownAliases = oid.aliases();\n+                if (knownAliases != null) {\n+                    for (String ka : knownAliases) {\n+                        value.add(ka);\n+                    }\n+                }\n+            }\n+            for (String ea : extraAliases) {\n+                value.add(ea);\n+            }\n+        }\n+        aliasesMap.put(stdName, value);\n+        return value;\n+    }\n+\n+    \/\/ returns an aliases List for the specified algorithm name o\n+    \/\/ NOTE: exception is thrown if no aliases nor oid found, so\n+    \/\/ only call this method if aliases are expected\n+    public static List<String> getAliases(String o) {\n+        List<String> res = aliasesMap.get(o);\n+        if (res == null) {\n+            KnownOIDs e = KnownOIDs.findMatch(o);\n+            if (e != null) {\n+                return store(o, e);\n+            }\n+            ProviderException pe =\n+                    new ProviderException(\"Cannot find aliases for \" + o);\n+            throw pe;\n+        }\n+        return res;\n@@ -102,0 +153,1 @@\n+\n@@ -172,0 +224,34 @@\n+\n+        \/\/ Set up aliases with default mappings\n+        \/\/ This is needed when the mapping contains non-oid\n+        \/\/ aliases\n+        aliasesMap = new ConcurrentHashMap<>();\n+\n+        store(\"SHA1withDSA\", KnownOIDs.SHA1withDSA,\n+                KnownOIDs.OIW_JDK_SHA1withDSA.value(),\n+                KnownOIDs.OIW_SHA1withDSA.value(),\n+                \"DSA\", \"SHA\/DSA\", \"SHA-1\/DSA\",\n+                \"SHA1\/DSA\", \"SHAwithDSA\", \"DSAWithSHA1\");\n+\n+        store(\"DSA\", KnownOIDs.DSA, KnownOIDs.OIW_DSA.value());\n+\n+        store(\"SHA1withRSA\", KnownOIDs.SHA1withRSA,\n+                KnownOIDs.OIW_SHA1withRSA.value());\n+\n+        store(\"SHA-1\", KnownOIDs.SHA_1);\n+\n+        store(\"PBEWithMD5AndDES\", KnownOIDs.PBEWithMD5AndDES, \"PBE\");\n+\n+        store(\"DiffieHellman\", KnownOIDs.DiffieHellman);\n+\n+        store(\"AES\", KnownOIDs.AES, \"Rijndael\");\n+\n+        store(\"EC\", KnownOIDs.EC, \"EllipticCurve\");\n+\n+        store(\"X.509\", null, \"X509\");\n+        store(\"NONEwithDSA\", null, \"RawDSA\");\n+        store(\"DESede\", null, \"TripleDES\");\n+        store(\"ARCFOUR\", KnownOIDs.ARCFOUR);\n+        \/\/ For backward compatility, refer to PKCS1 mapping for RSA\n+        \/\/ KeyPairGenerator and KeyFactory\n+        store(\"PKCS1\", KnownOIDs.PKCS1, KnownOIDs.RSA.value());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":88,"deletions":2,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-\n+import sun.security.util.KnownOIDs;\n@@ -74,1 +74,2 @@\n-    private static final String OID_EKU_TLS_SERVER = \"1.3.6.1.5.5.7.3.1\";\n+    private static final String OID_EKU_TLS_SERVER =\n+            KnownOIDs.serverAuth.value();\n@@ -76,1 +77,2 @@\n-    private static final String OID_EKU_TLS_CLIENT = \"1.3.6.1.5.5.7.3.2\";\n+    private static final String OID_EKU_TLS_CLIENT =\n+            KnownOIDs.clientAuth.value();\n@@ -78,1 +80,2 @@\n-    private static final String OID_EKU_CODE_SIGNING = \"1.3.6.1.5.5.7.3.3\";\n+    private static final String OID_EKU_CODE_SIGNING =\n+            KnownOIDs.codeSigning.value();\n@@ -80,1 +83,2 @@\n-    private static final String OID_EKU_TIME_STAMPING = \"1.3.6.1.5.5.7.3.8\";\n+    private static final String OID_EKU_TIME_STAMPING =\n+            KnownOIDs.KP_TimeStamping.value();\n@@ -82,1 +86,2 @@\n-    private static final String OID_EKU_ANY_USAGE = \"2.5.29.37.0\";\n+    private static final String OID_EKU_ANY_USAGE =\n+            KnownOIDs.anyExtendedKeyUsage.value();\n@@ -85,1 +90,2 @@\n-    private static final String OID_EKU_NS_SGC = \"2.16.840.1.113730.4.1\";\n+    private static final String OID_EKU_NS_SGC =\n+            KnownOIDs.NETSCAPE_ExportApproved.value();\n@@ -88,1 +94,2 @@\n-    private static final String OID_EKU_MS_SGC = \"1.3.6.1.4.1.311.10.3.3\";\n+    private static final String OID_EKU_MS_SGC =\n+            KnownOIDs.MICROSOFT_ExportApproved.value();\n@@ -91,1 +98,2 @@\n-    private static final String OID_SUBJECT_ALT_NAME = \"2.5.29.17\";\n+    private static final String OID_SUBJECT_ALT_NAME =\n+            KnownOIDs.SubjectAlternativeName.value();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/EndEntityChecker.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -63,1 +64,2 @@\n-    static final String OID_BASIC_CONSTRAINTS = \"2.5.29.19\";\n+    static final String OID_BASIC_CONSTRAINTS =\n+            KnownOIDs.BasicConstraints.value();\n@@ -65,1 +67,2 @@\n-    static final String OID_NETSCAPE_CERT_TYPE = \"2.16.840.1.113730.1.1\";\n+    static final String OID_NETSCAPE_CERT_TYPE =\n+            KnownOIDs.NETSCAPE_CertType.value();\n@@ -67,1 +70,1 @@\n-    static final String OID_KEY_USAGE = \"2.5.29.15\";\n+    static final String OID_KEY_USAGE = KnownOIDs.KeyUsage.value();\n@@ -69,1 +72,2 @@\n-    static final String OID_EXTENDED_KEY_USAGE = \"2.5.29.37\";\n+    static final String OID_EXTENDED_KEY_USAGE =\n+            KnownOIDs.extendedKeyUsage.value();\n@@ -71,1 +75,2 @@\n-    static final String OID_EKU_ANY_USAGE = \"2.5.29.37.0\";\n+    static final String OID_EKU_ANY_USAGE =\n+            KnownOIDs.anyExtendedKeyUsage.value();\n@@ -74,1 +79,1 @@\n-        NetscapeCertTypeExtension.NetscapeCertType_Id;\n+            NetscapeCertTypeExtension.NetscapeCertType_Id;\n@@ -77,1 +82,1 @@\n-                                NetscapeCertTypeExtension.SSL_CA;\n+            NetscapeCertTypeExtension.SSL_CA;\n@@ -80,1 +85,1 @@\n-                                NetscapeCertTypeExtension.OBJECT_SIGNING_CA;\n+            NetscapeCertTypeExtension.OBJECT_SIGNING_CA;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/SimpleValidator.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1240,1 +1240,1 @@\n-            return new ObjectIdentifier(oidString);\n+            return ObjectIdentifier.of(oidString);\n@@ -1258,1 +1258,1 @@\n-        return new ObjectIdentifier(keyword);\n+        return ObjectIdentifier.of(keyword);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AVA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        ObjectIdentifier.newInternal(new int[] {1, 3, 6, 1, 5, 5, 7, 48, 1});\n+        ObjectIdentifier.of(KnownOIDs.OCSP);\n@@ -48,1 +48,1 @@\n-        ObjectIdentifier.newInternal(new int[] {1, 3, 6, 1, 5, 5, 7, 48, 2});\n+        ObjectIdentifier.of(KnownOIDs.caIssuers);\n@@ -51,1 +51,1 @@\n-        ObjectIdentifier.newInternal(new int[] {1, 3, 6, 1, 5, 5, 7, 48, 3});\n+        ObjectIdentifier.of(KnownOIDs.AD_TimeStamping);\n@@ -54,1 +54,1 @@\n-        ObjectIdentifier.newInternal(new int[] {1, 3, 6, 1, 5, 5, 7, 48, 5});\n+        ObjectIdentifier.of(KnownOIDs.caRepository);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AccessDescription.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -259,7 +260,7 @@\n-        String algName = nameTable.get(algid);\n-        if (algName != null) {\n-            return algName;\n-        }\n-        if ((params != null) && algid.equals((Object)specifiedWithECDSA_oid)) {\n-            try {\n-                AlgorithmId paramsId =\n+        String oidStr = algid.toString();\n+        \/\/ first check the list of support oids\n+        KnownOIDs o = KnownOIDs.findMatch(oidStr);\n+        if (o == KnownOIDs.SpecifiedSHA2withECDSA) {\n+            if (params != null) {\n+                try {\n+                    AlgorithmId paramsId =\n@@ -267,4 +268,15 @@\n-                String paramsName = paramsId.getName();\n-                algName = makeSigAlg(paramsName, \"EC\");\n-            } catch (IOException e) {\n-                \/\/ ignore\n+                    String paramsName = paramsId.getName();\n+                    return makeSigAlg(paramsName, \"EC\");\n+                } catch (IOException e) {\n+                    \/\/ ignore\n+                }\n+            }\n+        }\n+        if (o != null) {\n+            return o.stdName();\n+        } else {\n+            String n = aliasOidsTable().get(oidStr);\n+            if (n != null) {\n+                return n;\n+            } else {\n+                return algid.toString();\n@@ -273,1 +285,0 @@\n-        return (algName == null) ? algid.toString() : algName;\n@@ -295,1 +306,2 @@\n-        return (encodedParams == null || algid.equals(specifiedWithECDSA_oid))\n+        return (encodedParams == null ||\n+            algid.toString().equals(KnownOIDs.SpecifiedSHA2withECDSA.value()))\n@@ -491,7 +503,2 @@\n-        \/\/ See if algname is in printable OID (\"dot-dot\") notation\n-        if (name.indexOf('.') != -1) {\n-            if (name.startsWith(\"OID.\")) {\n-                return new ObjectIdentifier(name.substring(\"OID.\".length()));\n-            } else {\n-                return new ObjectIdentifier(name);\n-            }\n+        if (name.startsWith(\"OID.\")) {\n+            name = name.substring(\"OID.\".length());\n@@ -500,57 +507,3 @@\n-        \/\/ Digesting algorithms\n-        if (name.equalsIgnoreCase(\"MD5\")) {\n-            return AlgorithmId.MD5_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"MD2\")) {\n-            return AlgorithmId.MD2_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA\") || name.equalsIgnoreCase(\"SHA1\")\n-            || name.equalsIgnoreCase(\"SHA-1\")) {\n-            return AlgorithmId.SHA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-256\") ||\n-            name.equalsIgnoreCase(\"SHA256\")) {\n-            return AlgorithmId.SHA256_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-384\") ||\n-            name.equalsIgnoreCase(\"SHA384\")) {\n-            return AlgorithmId.SHA384_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-512\") ||\n-            name.equalsIgnoreCase(\"SHA512\")) {\n-            return AlgorithmId.SHA512_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-224\") ||\n-            name.equalsIgnoreCase(\"SHA224\")) {\n-            return AlgorithmId.SHA224_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-512\/224\") ||\n-            name.equalsIgnoreCase(\"SHA512\/224\")) {\n-            return AlgorithmId.SHA512_224_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA-512\/256\") ||\n-            name.equalsIgnoreCase(\"SHA512\/256\")) {\n-            return AlgorithmId.SHA512_256_oid;\n-        }\n-        \/\/ Various public key algorithms\n-        if (name.equalsIgnoreCase(\"RSA\")) {\n-            return AlgorithmId.RSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"RSASSA-PSS\")) {\n-            return AlgorithmId.RSASSA_PSS_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"RSAES-OAEP\")) {\n-            return AlgorithmId.RSAES_OAEP_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"Diffie-Hellman\")\n-            || name.equalsIgnoreCase(\"DH\")) {\n-            return AlgorithmId.DH_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"DSA\")) {\n-            return AlgorithmId.DSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"EC\")) {\n-            return EC_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"ECDH\")) {\n-            return AlgorithmId.ECDH_oid;\n+        KnownOIDs k = KnownOIDs.findMatch(name);\n+        if (k != null) {\n+            return ObjectIdentifier.of(k);\n@@ -559,57 +512,11 @@\n-        \/\/ Secret key algorithms\n-        if (name.equalsIgnoreCase(\"AES\")) {\n-            return AlgorithmId.AES_oid;\n-        }\n-\n-        \/\/ Common signature types\n-        if (name.equalsIgnoreCase(\"MD5withRSA\")\n-            || name.equalsIgnoreCase(\"MD5\/RSA\")) {\n-            return AlgorithmId.md5WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"MD2withRSA\")\n-            || name.equalsIgnoreCase(\"MD2\/RSA\")) {\n-            return AlgorithmId.md2WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHAwithDSA\")\n-            || name.equalsIgnoreCase(\"SHA1withDSA\")\n-            || name.equalsIgnoreCase(\"SHA\/DSA\")\n-            || name.equalsIgnoreCase(\"SHA1\/DSA\")\n-            || name.equalsIgnoreCase(\"DSAWithSHA1\")\n-            || name.equalsIgnoreCase(\"DSS\")\n-            || name.equalsIgnoreCase(\"SHA-1\/DSA\")) {\n-            return AlgorithmId.sha1WithDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA224WithDSA\")) {\n-            return AlgorithmId.sha224WithDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA256WithDSA\")) {\n-            return AlgorithmId.sha256WithDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA1WithRSA\")\n-            || name.equalsIgnoreCase(\"SHA1\/RSA\")) {\n-            return AlgorithmId.sha1WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA256WithRSA\")) {\n-            return AlgorithmId.sha256WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA384WithRSA\")) {\n-            return AlgorithmId.sha384WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA512WithRSA\")) {\n-            return AlgorithmId.sha512WithRSAEncryption_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA1withECDSA\")\n-                || name.equalsIgnoreCase(\"ECDSA\")) {\n-            return AlgorithmId.sha1WithECDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA224withECDSA\")) {\n-            return AlgorithmId.sha224WithECDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA256withECDSA\")) {\n-            return AlgorithmId.sha256WithECDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA384withECDSA\")) {\n-            return AlgorithmId.sha384WithECDSA_oid;\n-        }\n-        if (name.equalsIgnoreCase(\"SHA512withECDSA\")) {\n-            return AlgorithmId.sha512WithECDSA_oid;\n+        \/\/ unknown algorithm oids\n+        if (name.indexOf(\".\") == -1) {\n+            \/\/ see if there is a matching oid string alias mapping from\n+            \/\/ 3rd party providers\n+            name = name.toUpperCase(Locale.ENGLISH);\n+            String oidStr = aliasOidsTable().get(name);\n+            if (oidStr != null) {\n+                return ObjectIdentifier.of(oidStr);\n+            } return null;\n+        } else {\n+            return ObjectIdentifier.of(name);\n@@ -617,6 +524,0 @@\n-\n-        return oidTable().get(name.toUpperCase(Locale.ENGLISH));\n-    }\n-\n-    private static ObjectIdentifier oid(int ... values) {\n-        return ObjectIdentifier.newInternal(values);\n@@ -625,2 +526,2 @@\n-    private static volatile Map<String,ObjectIdentifier> oidTable;\n-    private static final Map<ObjectIdentifier,String> nameTable;\n+    \/\/ oid string cache index'ed by algorithm name and oid strings\n+    private static volatile Map<String,String> aliasOidsTable;\n@@ -628,6 +529,5 @@\n-    \/** Returns the oidTable, lazily initializing it on first access. *\/\n-    private static Map<String,ObjectIdentifier> oidTable()\n-        throws IOException {\n-        \/\/ Double checked locking; safe because oidTable is volatile\n-        Map<String,ObjectIdentifier> tab;\n-        if ((tab = oidTable) == null) {\n+    \/\/ returns the aliasOidsTable, lazily initializing it on first access.\n+    private static Map<String,String> aliasOidsTable() {\n+        \/\/ Double checked locking; safe because aliasOidsTable is volatile\n+        Map<String,String> tab = aliasOidsTable;\n+        if (tab == null) {\n@@ -635,2 +535,3 @@\n-                if ((tab = oidTable) == null)\n-                    oidTable = tab = computeOidTable();\n+                if ((tab = aliasOidsTable) == null) {\n+                    aliasOidsTable = tab = collectOIDAliases();\n+                }\n@@ -642,4 +543,18 @@\n-    \/** Collects the algorithm names from the installed providers. *\/\n-    private static HashMap<String,ObjectIdentifier> computeOidTable()\n-        throws IOException {\n-        HashMap<String,ObjectIdentifier> tab = new HashMap<>();\n+    private static boolean isKnownProvider(Provider p) {\n+        String pn = p.getName();\n+        String mn = p.getClass().getModule().getName();\n+        if (pn != null && mn != null) {\n+            return ((mn.equals(\"java.base\") &&\n+                    (pn.equals(\"SUN\") || pn.equals(\"SunRsaSign\") ||\n+                    pn.equals(\"SunJCE\") || pn.equals(\"SunJSSE\"))) ||\n+                (mn.equals(\"jdk.crypto.ec\") && pn.equals(\"SunEC\")) ||\n+                (mn.equals(\"jdk.crypto.mscapi\") && pn.equals(\"SunMSCAPI\")) ||\n+                (mn.equals(\"jdk.crypto.cryptoki\") &&\n+                    pn.startsWith(\"SunPKCS11\")));\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private static ConcurrentHashMap<String, String> collectOIDAliases() {\n+        ConcurrentHashMap<String, String> t = new ConcurrentHashMap<>();\n@@ -647,0 +562,5 @@\n+            \/\/ skip providers which are already using SecurityProviderConstants\n+            \/\/ and KnownOIDs\n+            if (isKnownProvider(provider)) {\n+                continue;\n+            }\n@@ -652,1 +572,1 @@\n-                    (index=upperCaseAlias.indexOf(\"OID.\", 0)) != -1) {\n+                    (index = upperCaseAlias.indexOf(\"OID.\", 0)) != -1) {\n@@ -658,1 +578,1 @@\n-                    String oidString = alias.substring(index);\n+                    String ostr = alias.substring(index);\n@@ -663,3 +583,8 @@\n-                    if (stdAlgName != null &&\n-                        tab.get(stdAlgName) == null) {\n-                        tab.put(stdAlgName, new ObjectIdentifier(oidString));\n+                    \/\/ add the name->oid and oid->name mappings if none exists\n+                    if (KnownOIDs.findMatch(stdAlgName) == null) {\n+                        \/\/ not override earlier entries if it exists\n+                        t.putIfAbsent(stdAlgName, ostr);\n+                    }\n+                    if (KnownOIDs.findMatch(ostr) == null) {\n+                        \/\/ not override earlier entries if it exists\n+                        t.putIfAbsent(ostr, stdAlgName);\n@@ -670,1 +595,1 @@\n-        return tab;\n+        return t;\n@@ -673,10 +598,0 @@\n-    \/*****************************************************************\/\n-\n-    \/*\n-     * HASHING ALGORITHMS\n-     *\/\n-\n-    \/**\n-     * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.\n-     * OID = 1.2.840.113549.2.2\n-     *\/\n@@ -684,1 +599,1 @@\n-    ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 2});\n+            ObjectIdentifier.of(KnownOIDs.MD2);\n@@ -686,4 +601,0 @@\n-    \/**\n-     * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.\n-     * OID = 1.2.840.113549.2.5\n-     *\/\n@@ -691,1 +602,1 @@\n-    ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 5});\n+            ObjectIdentifier.of(KnownOIDs.MD5);\n@@ -693,6 +604,0 @@\n-    \/**\n-     * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.\n-     * This is sometimes called \"SHA\", though that is often confusing since\n-     * many people refer to FIPS 180 (which has an error) as defining SHA.\n-     * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.\n-     *\/\n@@ -700,1 +605,1 @@\n-    ObjectIdentifier.newInternal(new int[] {1, 3, 14, 3, 2, 26});\n+            ObjectIdentifier.of(KnownOIDs.SHA_1);\n@@ -703,1 +608,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 4});\n+            ObjectIdentifier.of(KnownOIDs.SHA_224);\n@@ -706,1 +611,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 1});\n+            ObjectIdentifier.of(KnownOIDs.SHA_256);\n@@ -709,1 +614,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 2});\n+            ObjectIdentifier.of(KnownOIDs.SHA_384);\n@@ -712,1 +617,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 3});\n+            ObjectIdentifier.of(KnownOIDs.SHA_512);\n@@ -715,1 +620,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 5});\n+            ObjectIdentifier.of(KnownOIDs.SHA_512$224);\n@@ -718,1 +623,1 @@\n-    ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 6});\n+            ObjectIdentifier.of(KnownOIDs.SHA_512$256);\n@@ -720,91 +625,2 @@\n-    \/*\n-     * COMMON PUBLIC KEY TYPES\n-     *\/\n-    private static final int[] DH_data = { 1, 2, 840, 113549, 1, 3, 1 };\n-    private static final int[] DH_PKIX_data = { 1, 2, 840, 10046, 2, 1 };\n-    private static final int[] DSA_OIW_data = { 1, 3, 14, 3, 2, 12 };\n-    private static final int[] DSA_PKIX_data = { 1, 2, 840, 10040, 4, 1 };\n-    private static final int[] RSA_data = { 2, 5, 8, 1, 1 };\n-\n-    public static final ObjectIdentifier DH_oid;\n-    public static final ObjectIdentifier DH_PKIX_oid;\n-    public static final ObjectIdentifier DSA_oid;\n-    public static final ObjectIdentifier DSA_OIW_oid;\n-    public static final ObjectIdentifier EC_oid = oid(1, 2, 840, 10045, 2, 1);\n-    public static final ObjectIdentifier ECDH_oid = oid(1, 3, 132, 1, 12);\n-    public static final ObjectIdentifier RSA_oid;\n-    public static final ObjectIdentifier RSAEncryption_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 1);\n-    public static final ObjectIdentifier RSAES_OAEP_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 7);\n-    public static final ObjectIdentifier mgf1_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 8);\n-    public static final ObjectIdentifier RSASSA_PSS_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 10);\n-\n-    \/*\n-     * COMMON SECRET KEY TYPES\n-     *\/\n-    public static final ObjectIdentifier AES_oid =\n-                                            oid(2, 16, 840, 1, 101, 3, 4, 1);\n-\n-    \/*\n-     * COMMON SIGNATURE ALGORITHMS\n-     *\/\n-    private static final int[] md2WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 2 };\n-    private static final int[] md5WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 4 };\n-    private static final int[] sha1WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 5 };\n-    private static final int[] sha1WithRSAEncryption_OIW_data =\n-                                       { 1, 3, 14, 3, 2, 29 };\n-    private static final int[] sha224WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 14 };\n-    private static final int[] sha256WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 11 };\n-    private static final int[] sha384WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 12 };\n-    private static final int[] sha512WithRSAEncryption_data =\n-                                       { 1, 2, 840, 113549, 1, 1, 13 };\n-\n-    private static final int[] shaWithDSA_OIW_data =\n-                                       { 1, 3, 14, 3, 2, 13 };\n-    private static final int[] sha1WithDSA_OIW_data =\n-                                       { 1, 3, 14, 3, 2, 27 };\n-    private static final int[] dsaWithSHA1_PKIX_data =\n-                                       { 1, 2, 840, 10040, 4, 3 };\n-\n-    public static final ObjectIdentifier md2WithRSAEncryption_oid;\n-    public static final ObjectIdentifier md5WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha1WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid;\n-    public static final ObjectIdentifier sha224WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha256WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha384WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha512WithRSAEncryption_oid;\n-    public static final ObjectIdentifier sha512_224WithRSAEncryption_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 15);\n-    public static final ObjectIdentifier sha512_256WithRSAEncryption_oid =\n-                                            oid(1, 2, 840, 113549, 1, 1, 16);;\n-\n-    public static final ObjectIdentifier shaWithDSA_OIW_oid;\n-    public static final ObjectIdentifier sha1WithDSA_OIW_oid;\n-    public static final ObjectIdentifier sha1WithDSA_oid;\n-    public static final ObjectIdentifier sha224WithDSA_oid =\n-                                            oid(2, 16, 840, 1, 101, 3, 4, 3, 1);\n-    public static final ObjectIdentifier sha256WithDSA_oid =\n-                                            oid(2, 16, 840, 1, 101, 3, 4, 3, 2);\n-\n-    public static final ObjectIdentifier sha1WithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 1);\n-    public static final ObjectIdentifier sha224WithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 3, 1);\n-    public static final ObjectIdentifier sha256WithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 3, 2);\n-    public static final ObjectIdentifier sha384WithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 3, 3);\n-    public static final ObjectIdentifier sha512WithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 3, 4);\n-    public static final ObjectIdentifier specifiedWithECDSA_oid =\n-                                            oid(1, 2, 840, 10045, 4, 3);\n+    public static final ObjectIdentifier DSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.DSA);\n@@ -812,81 +628,2 @@\n-    \/**\n-     * Algorithm ID for the PBE encryption algorithms from PKCS#5 and\n-     * PKCS#12.\n-     *\/\n-    public static final ObjectIdentifier pbeWithMD5AndDES_oid =\n-        ObjectIdentifier.newInternal(new int[]{1, 2, 840, 113549, 1, 5, 3});\n-    public static final ObjectIdentifier pbeWithMD5AndRC2_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 6});\n-    public static final ObjectIdentifier pbeWithSHA1AndDES_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 10});\n-    public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 11});\n-    public static ObjectIdentifier pbeWithSHA1AndRC4_128_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 1});\n-    public static ObjectIdentifier pbeWithSHA1AndRC4_40_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 2});\n-    public static ObjectIdentifier pbeWithSHA1AndDESede_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 3});\n-    public static ObjectIdentifier pbeWithSHA1AndRC2_128_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 5});\n-    public static ObjectIdentifier pbeWithSHA1AndRC2_40_oid =\n-        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 6});\n-\n-    static {\n-    \/*\n-     * Note the preferred OIDs are named simply with no \"OIW\" or\n-     * \"PKIX\" in them, even though they may point to data from these\n-     * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...\n-     *\/\n-    \/**\n-     * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.\n-     * Parameters include public values P and G, and may optionally specify\n-     * the length of the private key X.  Alternatively, algorithm parameters\n-     * may be derived from another source such as a Certificate Authority's\n-     * certificate.\n-     * OID = 1.2.840.113549.1.3.1\n-     *\/\n-        DH_oid = ObjectIdentifier.newInternal(DH_data);\n-\n-    \/**\n-     * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.\n-     * Parameters may include public values P and G.\n-     * OID = 1.2.840.10046.2.1\n-     *\/\n-        DH_PKIX_oid = ObjectIdentifier.newInternal(DH_PKIX_data);\n-\n-    \/**\n-     * Algorithm ID for the Digital Signing Algorithm (DSA), from the\n-     * NIST OIW Stable Agreements part 12.\n-     * Parameters may include public values P, Q, and G; or these may be\n-     * derived from\n-     * another source such as a Certificate Authority's certificate.\n-     * OID = 1.3.14.3.2.12\n-     *\/\n-        DSA_OIW_oid = ObjectIdentifier.newInternal(DSA_OIW_data);\n-\n-    \/**\n-     * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.\n-     * Parameters may include public values P, Q, and G; or these may be\n-     * derived from another source such as a Certificate Authority's\n-     * certificate.\n-     * OID = 1.2.840.10040.4.1\n-     *\/\n-        DSA_oid = ObjectIdentifier.newInternal(DSA_PKIX_data);\n-\n-    \/**\n-     * Algorithm ID for RSA keys used for any purpose, as defined in X.509.\n-     * The algorithm parameter is a single value, the number of bits in the\n-     * public modulus.\n-     * OID = 2.5.8.1.1\n-     *\/\n-        RSA_oid = ObjectIdentifier.newInternal(RSA_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where an MD2 digest is encrypted\n-     * using an RSA private key; defined in PKCS #1.  Use of this\n-     * signing algorithm is discouraged due to MD2 vulnerabilities.\n-     * OID = 1.2.840.113549.1.1.2\n-     *\/\n-        md2WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(md2WithRSAEncryption_data);\n+    public static final ObjectIdentifier EC_oid =\n+            ObjectIdentifier.of(KnownOIDs.EC);\n@@ -894,63 +631,2 @@\n-    \/**\n-     * Identifies a signing algorithm where an MD5 digest is\n-     * encrypted using an RSA private key; defined in PKCS #1.\n-     * OID = 1.2.840.113549.1.1.4\n-     *\/\n-        md5WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(md5WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA1 digest is\n-     * encrypted using an RSA private key; defined by RSA DSI.\n-     * OID = 1.2.840.113549.1.1.5\n-     *\/\n-        sha1WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(sha1WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA1 digest is\n-     * encrypted using an RSA private key; defined in NIST OIW.\n-     * OID = 1.3.14.3.2.29\n-     *\/\n-        sha1WithRSAEncryption_OIW_oid =\n-            ObjectIdentifier.newInternal(sha1WithRSAEncryption_OIW_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA224 digest is\n-     * encrypted using an RSA private key; defined by PKCS #1.\n-     * OID = 1.2.840.113549.1.1.14\n-     *\/\n-        sha224WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(sha224WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA256 digest is\n-     * encrypted using an RSA private key; defined by PKCS #1.\n-     * OID = 1.2.840.113549.1.1.11\n-     *\/\n-        sha256WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(sha256WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA384 digest is\n-     * encrypted using an RSA private key; defined by PKCS #1.\n-     * OID = 1.2.840.113549.1.1.12\n-     *\/\n-        sha384WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(sha384WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies a signing algorithm where a SHA512 digest is\n-     * encrypted using an RSA private key; defined by PKCS #1.\n-     * OID = 1.2.840.113549.1.1.13\n-     *\/\n-        sha512WithRSAEncryption_oid =\n-            ObjectIdentifier.newInternal(sha512WithRSAEncryption_data);\n-\n-    \/**\n-     * Identifies the FIPS 186 \"Digital Signature Standard\" (DSS), where a\n-     * SHA digest is signed using the Digital Signing Algorithm (DSA).\n-     * This should not be used.\n-     * OID = 1.3.14.3.2.13\n-     *\/\n-        shaWithDSA_OIW_oid = ObjectIdentifier.newInternal(shaWithDSA_OIW_data);\n+    public static final ObjectIdentifier RSAEncryption_oid =\n+            ObjectIdentifier.of(KnownOIDs.RSA);\n@@ -958,6 +634,2 @@\n-    \/**\n-     * Identifies the FIPS 186 \"Digital Signature Standard\" (DSS), where a\n-     * SHA1 digest is signed using the Digital Signing Algorithm (DSA).\n-     * OID = 1.3.14.3.2.27\n-     *\/\n-        sha1WithDSA_OIW_oid = ObjectIdentifier.newInternal(sha1WithDSA_OIW_data);\n+    public static final ObjectIdentifier RSASSA_PSS_oid =\n+            ObjectIdentifier.of(KnownOIDs.RSASSA_PSS);\n@@ -965,61 +637,2 @@\n-    \/**\n-     * Identifies the FIPS 186 \"Digital Signature Standard\" (DSS), where a\n-     * SHA1 digest is signed using the Digital Signing Algorithm (DSA).\n-     * OID = 1.2.840.10040.4.3\n-     *\/\n-        sha1WithDSA_oid = ObjectIdentifier.newInternal(dsaWithSHA1_PKIX_data);\n-\n-        nameTable = new HashMap<>();\n-        nameTable.put(MD5_oid, \"MD5\");\n-        nameTable.put(MD2_oid, \"MD2\");\n-        nameTable.put(SHA_oid, \"SHA-1\");\n-        nameTable.put(SHA224_oid, \"SHA-224\");\n-        nameTable.put(SHA256_oid, \"SHA-256\");\n-        nameTable.put(SHA384_oid, \"SHA-384\");\n-        nameTable.put(SHA512_oid, \"SHA-512\");\n-        nameTable.put(SHA512_224_oid, \"SHA-512\/224\");\n-        nameTable.put(SHA512_256_oid, \"SHA-512\/256\");\n-        nameTable.put(RSAEncryption_oid, \"RSA\");\n-        nameTable.put(RSA_oid, \"RSA\");\n-        nameTable.put(DH_oid, \"Diffie-Hellman\");\n-        nameTable.put(DH_PKIX_oid, \"Diffie-Hellman\");\n-        nameTable.put(DSA_oid, \"DSA\");\n-        nameTable.put(DSA_OIW_oid, \"DSA\");\n-        nameTable.put(EC_oid, \"EC\");\n-        nameTable.put(ECDH_oid, \"ECDH\");\n-\n-        nameTable.put(AES_oid, \"AES\");\n-\n-        nameTable.put(sha1WithECDSA_oid, \"SHA1withECDSA\");\n-        nameTable.put(sha224WithECDSA_oid, \"SHA224withECDSA\");\n-        nameTable.put(sha256WithECDSA_oid, \"SHA256withECDSA\");\n-        nameTable.put(sha384WithECDSA_oid, \"SHA384withECDSA\");\n-        nameTable.put(sha512WithECDSA_oid, \"SHA512withECDSA\");\n-        nameTable.put(md5WithRSAEncryption_oid, \"MD5withRSA\");\n-        nameTable.put(md2WithRSAEncryption_oid, \"MD2withRSA\");\n-        nameTable.put(sha1WithDSA_oid, \"SHA1withDSA\");\n-        nameTable.put(sha1WithDSA_OIW_oid, \"SHA1withDSA\");\n-        nameTable.put(shaWithDSA_OIW_oid, \"SHA1withDSA\");\n-        nameTable.put(sha224WithDSA_oid, \"SHA224withDSA\");\n-        nameTable.put(sha256WithDSA_oid, \"SHA256withDSA\");\n-        nameTable.put(sha1WithRSAEncryption_oid, \"SHA1withRSA\");\n-        nameTable.put(sha1WithRSAEncryption_OIW_oid, \"SHA1withRSA\");\n-        nameTable.put(sha224WithRSAEncryption_oid, \"SHA224withRSA\");\n-        nameTable.put(sha256WithRSAEncryption_oid, \"SHA256withRSA\");\n-        nameTable.put(sha384WithRSAEncryption_oid, \"SHA384withRSA\");\n-        nameTable.put(sha512WithRSAEncryption_oid, \"SHA512withRSA\");\n-        nameTable.put(sha512_224WithRSAEncryption_oid, \"SHA512\/224withRSA\");\n-        nameTable.put(sha512_256WithRSAEncryption_oid, \"SHA512\/256withRSA\");\n-        nameTable.put(RSASSA_PSS_oid, \"RSASSA-PSS\");\n-        nameTable.put(RSAES_OAEP_oid, \"RSAES-OAEP\");\n-\n-        nameTable.put(pbeWithMD5AndDES_oid, \"PBEWithMD5AndDES\");\n-        nameTable.put(pbeWithMD5AndRC2_oid, \"PBEWithMD5AndRC2\");\n-        nameTable.put(pbeWithSHA1AndDES_oid, \"PBEWithSHA1AndDES\");\n-        nameTable.put(pbeWithSHA1AndRC2_oid, \"PBEWithSHA1AndRC2\");\n-        nameTable.put(pbeWithSHA1AndRC4_128_oid, \"PBEWithSHA1AndRC4_128\");\n-        nameTable.put(pbeWithSHA1AndRC4_40_oid, \"PBEWithSHA1AndRC4_40\");\n-        nameTable.put(pbeWithSHA1AndDESede_oid, \"PBEWithSHA1AndDESede\");\n-        nameTable.put(pbeWithSHA1AndRC2_128_oid, \"PBEWithSHA1AndRC2_128\");\n-        nameTable.put(pbeWithSHA1AndRC2_40_oid, \"PBEWithSHA1AndRC2_40\");\n-    }\n+    public static final ObjectIdentifier MGF1_oid =\n+            ObjectIdentifier.of(KnownOIDs.MGF1);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":104,"deletions":491,"binary":false,"changes":595,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,1 @@\n-import sun.security.util.DerValue;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -97,29 +95,0 @@\n-    \/\/ OID defined in RFC 5280 Sections 4.2.1.12\n-    \/\/ more from http:\/\/www.alvestrand.no\/objectid\/1.3.6.1.5.5.7.3.html\n-    private static final Map <ObjectIdentifier, String> map =\n-            new HashMap <ObjectIdentifier, String> ();\n-\n-    private static final int[] anyExtendedKeyUsageOidData = {2, 5, 29, 37, 0};\n-    private static final int[] serverAuthOidData = {1, 3, 6, 1, 5, 5, 7, 3, 1};\n-    private static final int[] clientAuthOidData = {1, 3, 6, 1, 5, 5, 7, 3, 2};\n-    private static final int[] codeSigningOidData = {1, 3, 6, 1, 5, 5, 7, 3, 3};\n-    private static final int[] emailProtectionOidData = {1, 3, 6, 1, 5, 5, 7, 3, 4};\n-    private static final int[] ipsecEndSystemOidData = {1, 3, 6, 1, 5, 5, 7, 3, 5};\n-    private static final int[] ipsecTunnelOidData = {1, 3, 6, 1, 5, 5, 7, 3, 6};\n-    private static final int[] ipsecUserOidData = {1, 3, 6, 1, 5, 5, 7, 3, 7};\n-    private static final int[] timeStampingOidData = {1, 3, 6, 1, 5, 5, 7, 3, 8};\n-    private static final int[] OCSPSigningOidData = {1, 3, 6, 1, 5, 5, 7, 3, 9};\n-\n-    static {\n-        map.put(ObjectIdentifier.newInternal(anyExtendedKeyUsageOidData), \"anyExtendedKeyUsage\");\n-        map.put(ObjectIdentifier.newInternal(serverAuthOidData), \"serverAuth\");\n-        map.put(ObjectIdentifier.newInternal(clientAuthOidData), \"clientAuth\");\n-        map.put(ObjectIdentifier.newInternal(codeSigningOidData), \"codeSigning\");\n-        map.put(ObjectIdentifier.newInternal(emailProtectionOidData), \"emailProtection\");\n-        map.put(ObjectIdentifier.newInternal(ipsecEndSystemOidData), \"ipsecEndSystem\");\n-        map.put(ObjectIdentifier.newInternal(ipsecTunnelOidData), \"ipsecTunnel\");\n-        map.put(ObjectIdentifier.newInternal(ipsecUserOidData), \"ipsecUser\");\n-        map.put(ObjectIdentifier.newInternal(timeStampingOidData), \"timeStamping\");\n-        map.put(ObjectIdentifier.newInternal(OCSPSigningOidData), \"OCSPSigning\");\n-    };\n-\n@@ -212,3 +181,4 @@\n-            String result = map.get(oid);\n-            if (result != null) {\n-                usage += result;\n+            String res = oid.toString();\n+            KnownOIDs os = KnownOIDs.findMatch(res);\n+            if (os != null) {\n+                usage += os.stdName();\n@@ -216,1 +186,1 @@\n-                usage += oid.toString();\n+                usage += res;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/ExtendedKeyUsageExtension.java","additions":7,"deletions":37,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,2 +273,1 @@\n-                newName = new GeneralName\n-                    (new OIDName(new ObjectIdentifier((int[])null)));\n+                newName = new GeneralName(new OIDName(\"\"));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralSubtrees.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-import sun.security.util.Debug;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -78,8 +75,2 @@\n-    public static ObjectIdentifier AnyPolicy_Id;\n-    static {\n-        try {\n-            AnyPolicy_Id = new ObjectIdentifier(\"2.5.29.32.0\");\n-        } catch (IOException ioe) {\n-            \/\/ Should not happen\n-        }\n-    }\n+    public static ObjectIdentifier AnyPolicy_Id =\n+            ObjectIdentifier.of(KnownOIDs.CE_CERT_POLICIES_ANY);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/InhibitAnyPolicyExtension.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,0 @@\n-    private static final int[] CertType_data = { 2, 16, 840, 1, 113730, 1, 1 };\n-\n@@ -77,9 +75,2 @@\n-    public static ObjectIdentifier NetscapeCertType_Id;\n-\n-    static {\n-        try {\n-            NetscapeCertType_Id = new ObjectIdentifier(CertType_data);\n-        } catch (IOException ioe) {\n-            \/\/ should not happen\n-        }\n-    }\n+    public static ObjectIdentifier NetscapeCertType_Id =\n+            ObjectIdentifier.of(KnownOIDs.NETSCAPE_CertType);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NetscapeCertTypeExtension.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,3 +105,0 @@\n-    private static final int[] NetscapeCertType_data =\n-        { 2, 16, 840, 1, 113730, 1, 1 };\n-\n@@ -141,2 +138,2 @@\n-        addInternal(NETSCAPE_CERT, ObjectIdentifier.newInternal\n-                    (new int[] {2,16,840,1,113730,1,1}),\n+        addInternal(NETSCAPE_CERT,\n+                    ObjectIdentifier.of(KnownOIDs.NETSCAPE_CertType),\n@@ -233,1 +230,1 @@\n-            objId = new ObjectIdentifier(oid);\n+            objId = ObjectIdentifier.of(oid);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/OIDMap.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            oid = new ObjectIdentifier(name);\n+            oid = ObjectIdentifier.of(name);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/OIDName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.*;\n@@ -51,34 +50,0 @@\n-    \/\/ The object identifiers\n-    private static final int[] AuthorityKey_data = { 2, 5, 29, 35 };\n-    private static final int[] SubjectKey_data = { 2, 5, 29, 14 };\n-    private static final int[] KeyUsage_data = { 2, 5, 29, 15 };\n-    private static final int[] PrivateKeyUsage_data = { 2, 5, 29, 16 };\n-    private static final int[] CertificatePolicies_data = { 2, 5, 29, 32 };\n-    private static final int[] PolicyMappings_data = { 2, 5, 29, 33 };\n-    private static final int[] SubjectAlternativeName_data = { 2, 5, 29, 17 };\n-    private static final int[] IssuerAlternativeName_data = { 2, 5, 29, 18 };\n-    private static final int[] SubjectDirectoryAttributes_data = { 2, 5, 29, 9 };\n-    private static final int[] BasicConstraints_data = { 2, 5, 29, 19 };\n-    private static final int[] NameConstraints_data = { 2, 5, 29, 30 };\n-    private static final int[] PolicyConstraints_data = { 2, 5, 29, 36 };\n-    private static final int[] CRLDistributionPoints_data = { 2, 5, 29, 31 };\n-    private static final int[] CRLNumber_data = { 2, 5, 29, 20 };\n-    private static final int[] IssuingDistributionPoint_data = { 2, 5, 29, 28 };\n-    private static final int[] DeltaCRLIndicator_data = { 2, 5, 29, 27 };\n-    private static final int[] ReasonCode_data = { 2, 5, 29, 21 };\n-    private static final int[] HoldInstructionCode_data = { 2, 5, 29, 23 };\n-    private static final int[] InvalidityDate_data = { 2, 5, 29, 24 };\n-    private static final int[] ExtendedKeyUsage_data = { 2, 5, 29, 37 };\n-    private static final int[] InhibitAnyPolicy_data = { 2, 5, 29, 54 };\n-    private static final int[] CertificateIssuer_data = { 2, 5, 29, 29 };\n-    private static final int[] AuthInfoAccess_data = { 1, 3, 6, 1, 5, 5, 7, 1, 1};\n-    private static final int[] SubjectInfoAccess_data = { 1, 3, 6, 1, 5, 5, 7, 1, 11};\n-    private static final int[] FreshestCRL_data = { 2, 5, 29, 46 };\n-    private static final int[] OCSPNoCheck_data = { 1, 3, 6, 1, 5, 5, 7,\n-                                                    48, 1, 5};\n-\n-    \/\/ Additional extensions under the PKIX arc that are not necessarily\n-    \/\/ used in X.509 Certificates or CRLs.\n-    private static final int OCSPNonce_data [] = { 1, 3, 6, 1, 5, 5, 7,\n-                                                  48, 1, 2};\n-\n@@ -88,1 +53,2 @@\n-    public static final ObjectIdentifier AuthorityKey_Id;\n+    public static final ObjectIdentifier AuthorityKey_Id =\n+            ObjectIdentifier.of(KnownOIDs.AuthorityKeyID);\n@@ -93,1 +59,2 @@\n-    public static final ObjectIdentifier SubjectKey_Id;\n+    public static final ObjectIdentifier SubjectKey_Id =\n+            ObjectIdentifier.of(KnownOIDs.SubjectKeyID);\n@@ -98,1 +65,2 @@\n-    public static final ObjectIdentifier KeyUsage_Id;\n+    public static final ObjectIdentifier KeyUsage_Id =\n+            ObjectIdentifier.of(KnownOIDs.KeyUsage);\n@@ -104,1 +72,2 @@\n-    public static final ObjectIdentifier PrivateKeyUsage_Id;\n+    public static final ObjectIdentifier PrivateKeyUsage_Id =\n+            ObjectIdentifier.of(KnownOIDs.PrivateKeyUsage);\n@@ -109,1 +78,2 @@\n-    public static final ObjectIdentifier CertificatePolicies_Id;\n+    public static final ObjectIdentifier CertificatePolicies_Id =\n+            ObjectIdentifier.of(KnownOIDs.CertificatePolicies);\n@@ -115,1 +85,2 @@\n-    public static final ObjectIdentifier PolicyMappings_Id;\n+    public static final ObjectIdentifier PolicyMappings_Id =\n+            ObjectIdentifier.of(KnownOIDs.PolicyMappings);\n@@ -121,1 +92,2 @@\n-    public static final ObjectIdentifier SubjectAlternativeName_Id;\n+    public static final ObjectIdentifier SubjectAlternativeName_Id =\n+            ObjectIdentifier.of(KnownOIDs.SubjectAlternativeName);\n@@ -127,1 +99,2 @@\n-    public static final ObjectIdentifier IssuerAlternativeName_Id;\n+    public static final ObjectIdentifier IssuerAlternativeName_Id =\n+            ObjectIdentifier.of(KnownOIDs.IssuerAlternativeName);\n@@ -133,1 +106,2 @@\n-    public static final ObjectIdentifier SubjectDirectoryAttributes_Id;\n+    public static final ObjectIdentifier SubjectDirectoryAttributes_Id =\n+            ObjectIdentifier.of(KnownOIDs.SubjectDirectoryAttributes);\n@@ -139,1 +113,2 @@\n-    public static final ObjectIdentifier BasicConstraints_Id;\n+    public static final ObjectIdentifier BasicConstraints_Id =\n+            ObjectIdentifier.of(KnownOIDs.BasicConstraints);\n@@ -145,1 +120,2 @@\n-    public static final ObjectIdentifier NameConstraints_Id;\n+    public static final ObjectIdentifier NameConstraints_Id =\n+            ObjectIdentifier.of(KnownOIDs.NameConstraints);\n@@ -151,1 +127,2 @@\n-    public static final ObjectIdentifier PolicyConstraints_Id;\n+    public static final ObjectIdentifier PolicyConstraints_Id =\n+            ObjectIdentifier.of(KnownOIDs.PolicyConstraints);\n@@ -156,1 +133,2 @@\n-    public static final ObjectIdentifier CRLDistributionPoints_Id;\n+    public static final ObjectIdentifier CRLDistributionPoints_Id =\n+            ObjectIdentifier.of(KnownOIDs.CRLDistributionPoints);\n@@ -162,1 +140,2 @@\n-    public static final ObjectIdentifier CRLNumber_Id;\n+    public static final ObjectIdentifier CRLNumber_Id =\n+            ObjectIdentifier.of(KnownOIDs.CRLNumber);\n@@ -167,1 +146,2 @@\n-    public static final ObjectIdentifier IssuingDistributionPoint_Id;\n+    public static final ObjectIdentifier IssuingDistributionPoint_Id =\n+            ObjectIdentifier.of(KnownOIDs.IssuingDistributionPoint);\n@@ -172,1 +152,2 @@\n-    public static final ObjectIdentifier DeltaCRLIndicator_Id;\n+    public static final ObjectIdentifier DeltaCRLIndicator_Id =\n+            ObjectIdentifier.of(KnownOIDs.DeltaCRLIndicator);\n@@ -177,1 +158,2 @@\n-    public static final ObjectIdentifier ReasonCode_Id;\n+    public static final ObjectIdentifier ReasonCode_Id =\n+            ObjectIdentifier.of(KnownOIDs.ReasonCode);\n@@ -184,1 +166,2 @@\n-    public static final ObjectIdentifier HoldInstructionCode_Id;\n+    public static final ObjectIdentifier HoldInstructionCode_Id =\n+            ObjectIdentifier.of(KnownOIDs.HoldInstructionCode);\n@@ -190,1 +173,2 @@\n-    public static final ObjectIdentifier InvalidityDate_Id;\n+    public static final ObjectIdentifier InvalidityDate_Id =\n+            ObjectIdentifier.of(KnownOIDs.InvalidityDate);\n@@ -196,1 +180,2 @@\n-    public static final ObjectIdentifier ExtendedKeyUsage_Id;\n+    public static final ObjectIdentifier ExtendedKeyUsage_Id =\n+            ObjectIdentifier.of(KnownOIDs.extendedKeyUsage);\n@@ -201,1 +186,2 @@\n-    public static final ObjectIdentifier InhibitAnyPolicy_Id;\n+    public static final ObjectIdentifier InhibitAnyPolicy_Id =\n+            ObjectIdentifier.of(KnownOIDs.InhibitAnyPolicy);\n@@ -207,1 +193,2 @@\n-    public static final ObjectIdentifier CertificateIssuer_Id;\n+    public static final ObjectIdentifier CertificateIssuer_Id =\n+            ObjectIdentifier.of(KnownOIDs.CertificateIssuer);\n@@ -215,1 +202,2 @@\n-    public static final ObjectIdentifier AuthInfoAccess_Id;\n+    public static final ObjectIdentifier AuthInfoAccess_Id =\n+            ObjectIdentifier.of(KnownOIDs.AuthInfoAccess);\n@@ -221,1 +209,2 @@\n-    public static final ObjectIdentifier SubjectInfoAccess_Id;\n+    public static final ObjectIdentifier SubjectInfoAccess_Id =\n+            ObjectIdentifier.of(KnownOIDs.SubjectInfoAccess);\n@@ -226,1 +215,2 @@\n-    public static final ObjectIdentifier FreshestCRL_Id;\n+    public static final ObjectIdentifier FreshestCRL_Id =\n+            ObjectIdentifier.of(KnownOIDs.FreshestCRL);\n@@ -232,1 +222,2 @@\n-    public static final ObjectIdentifier OCSPNoCheck_Id;\n+    public static final ObjectIdentifier OCSPNoCheck_Id =\n+            ObjectIdentifier.of(KnownOIDs.OCSPNoCheck);\n@@ -238,46 +229,2 @@\n-    public static final ObjectIdentifier OCSPNonce_Id;\n-\n-    static {\n-        AuthorityKey_Id = ObjectIdentifier.newInternal(AuthorityKey_data);\n-        SubjectKey_Id   = ObjectIdentifier.newInternal(SubjectKey_data);\n-        KeyUsage_Id     = ObjectIdentifier.newInternal(KeyUsage_data);\n-        PrivateKeyUsage_Id = ObjectIdentifier.newInternal(PrivateKeyUsage_data);\n-        CertificatePolicies_Id =\n-            ObjectIdentifier.newInternal(CertificatePolicies_data);\n-        PolicyMappings_Id = ObjectIdentifier.newInternal(PolicyMappings_data);\n-        SubjectAlternativeName_Id =\n-            ObjectIdentifier.newInternal(SubjectAlternativeName_data);\n-        IssuerAlternativeName_Id =\n-            ObjectIdentifier.newInternal(IssuerAlternativeName_data);\n-        ExtendedKeyUsage_Id = ObjectIdentifier.newInternal(ExtendedKeyUsage_data);\n-        InhibitAnyPolicy_Id = ObjectIdentifier.newInternal(InhibitAnyPolicy_data);\n-        SubjectDirectoryAttributes_Id =\n-            ObjectIdentifier.newInternal(SubjectDirectoryAttributes_data);\n-        BasicConstraints_Id =\n-            ObjectIdentifier.newInternal(BasicConstraints_data);\n-        ReasonCode_Id = ObjectIdentifier.newInternal(ReasonCode_data);\n-        HoldInstructionCode_Id  =\n-            ObjectIdentifier.newInternal(HoldInstructionCode_data);\n-        InvalidityDate_Id = ObjectIdentifier.newInternal(InvalidityDate_data);\n-\n-        NameConstraints_Id = ObjectIdentifier.newInternal(NameConstraints_data);\n-        PolicyConstraints_Id =\n-            ObjectIdentifier.newInternal(PolicyConstraints_data);\n-        CRLDistributionPoints_Id =\n-            ObjectIdentifier.newInternal(CRLDistributionPoints_data);\n-        CRLNumber_Id =\n-            ObjectIdentifier.newInternal(CRLNumber_data);\n-        IssuingDistributionPoint_Id =\n-            ObjectIdentifier.newInternal(IssuingDistributionPoint_data);\n-        DeltaCRLIndicator_Id =\n-            ObjectIdentifier.newInternal(DeltaCRLIndicator_data);\n-        CertificateIssuer_Id =\n-            ObjectIdentifier.newInternal(CertificateIssuer_data);\n-        AuthInfoAccess_Id =\n-            ObjectIdentifier.newInternal(AuthInfoAccess_data);\n-        SubjectInfoAccess_Id =\n-            ObjectIdentifier.newInternal(SubjectInfoAccess_data);\n-        FreshestCRL_Id = ObjectIdentifier.newInternal(FreshestCRL_data);\n-        OCSPNoCheck_Id = ObjectIdentifier.newInternal(OCSPNoCheck_data);\n-        OCSPNonce_Id = ObjectIdentifier.newInternal(OCSPNonce_data);\n-    }\n+    public static final ObjectIdentifier OCSPNonce_Id =\n+            ObjectIdentifier.of(KnownOIDs.OCSPNonceExt);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PKIXExtensions.java","additions":55,"deletions":108,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1105,21 +1105,0 @@\n-    private static final int[] commonName_data = { 2, 5, 4, 3 };\n-    private static final int[] SURNAME_DATA = { 2, 5, 4, 4 };\n-    private static final int[] SERIALNUMBER_DATA = { 2, 5, 4, 5 };\n-    private static final int[] countryName_data = { 2, 5, 4, 6 };\n-    private static final int[] localityName_data = { 2, 5, 4, 7 };\n-    private static final int[] stateName_data = { 2, 5, 4, 8 };\n-    private static final int[] streetAddress_data = { 2, 5, 4, 9 };\n-    private static final int[] orgName_data = { 2, 5, 4, 10 };\n-    private static final int[] orgUnitName_data = { 2, 5, 4, 11 };\n-    private static final int[] title_data = { 2, 5, 4, 12 };\n-    private static final int[] GIVENNAME_DATA = { 2, 5, 4, 42 };\n-    private static final int[] INITIALS_DATA = { 2, 5, 4, 43 };\n-    private static final int[] GENERATIONQUALIFIER_DATA = { 2, 5, 4, 44 };\n-    private static final int[] DNQUALIFIER_DATA = { 2, 5, 4, 46 };\n-\n-    private static final int[] ipAddress_data = { 1, 3, 6, 1, 4, 1, 42, 2, 11, 2, 1 };\n-    private static final int[] DOMAIN_COMPONENT_DATA =\n-        { 0, 9, 2342, 19200300, 100, 1, 25 };\n-    private static final int[] userid_data =\n-        { 0, 9, 2342, 19200300, 100, 1, 1 };\n-\n@@ -1129,1 +1108,5 @@\n-            ObjectIdentifier.newInternal(commonName_data);\n+            ObjectIdentifier.of(KnownOIDs.CommonName);\n+\n+    \/\/ OID for the \"SURNAME=\" attribute, denoting a person's surname.\n+    public static final ObjectIdentifier SURNAME_OID =\n+            ObjectIdentifier.of(KnownOIDs.Surname);\n@@ -1135,1 +1118,1 @@\n-            ObjectIdentifier.newInternal(SERIALNUMBER_DATA);\n+            ObjectIdentifier.of(KnownOIDs.SerialNumber);\n@@ -1139,1 +1122,1 @@\n-            ObjectIdentifier.newInternal(countryName_data);\n+            ObjectIdentifier.of(KnownOIDs.CountryName);\n@@ -1143,9 +1126,1 @@\n-            ObjectIdentifier.newInternal(localityName_data);\n-\n-    \/\/ OID for the \"O=\" attribute, denoting an organization name.\n-    public static final ObjectIdentifier orgName_oid =\n-            ObjectIdentifier.newInternal(orgName_data);\n-\n-    \/\/ OID for the \"OU=\" attribute, denoting an organizational unit name.\n-    public static final ObjectIdentifier orgUnitName_oid =\n-            ObjectIdentifier.newInternal(orgUnitName_data);\n+            ObjectIdentifier.of(KnownOIDs.LocalityName);\n@@ -1155,1 +1130,1 @@\n-            ObjectIdentifier.newInternal(stateName_data);\n+            ObjectIdentifier.of(KnownOIDs.StateName);\n@@ -1159,1 +1134,1 @@\n-            ObjectIdentifier.newInternal(streetAddress_data);\n+            ObjectIdentifier.of(KnownOIDs.StreetAddress);\n@@ -1161,3 +1136,3 @@\n-    \/\/ OID for the \"T=\" attribute, denoting a person's title.\n-    public static final ObjectIdentifier title_oid =\n-            ObjectIdentifier.newInternal(title_data);\n+    \/\/ OID for the \"O=\" attribute, denoting an organization name.\n+    public static final ObjectIdentifier orgName_oid =\n+            ObjectIdentifier.of(KnownOIDs.OrgName);\n@@ -1165,4 +1140,3 @@\n-    \/\/ OID for the \"DNQUALIFIER=\" or \"DNQ=\" attribute, denoting DN\n-    \/\/ disambiguating information.\n-    public static final ObjectIdentifier DNQUALIFIER_OID =\n-            ObjectIdentifier.newInternal(DNQUALIFIER_DATA);\n+    \/\/ OID for the \"OU=\" attribute, denoting an organizational unit name.\n+    public static final ObjectIdentifier orgUnitName_oid =\n+            ObjectIdentifier.of(KnownOIDs.OrgUnitName);\n@@ -1170,3 +1144,3 @@\n-    \/\/ OID for the \"SURNAME=\" attribute, denoting a person's surname.\n-    public static final ObjectIdentifier SURNAME_OID =\n-            ObjectIdentifier.newInternal(SURNAME_DATA);\n+    \/\/ OID for the \"T=\" attribute, denoting a person's title.\n+    public static final ObjectIdentifier title_oid =\n+            ObjectIdentifier.of(KnownOIDs.Title);\n@@ -1176,1 +1150,1 @@\n-            ObjectIdentifier.newInternal(GIVENNAME_DATA);\n+            ObjectIdentifier.of(KnownOIDs.GivenName);\n@@ -1180,1 +1154,1 @@\n-            ObjectIdentifier.newInternal(INITIALS_DATA);\n+            ObjectIdentifier.of(KnownOIDs.Initials);\n@@ -1184,1 +1158,6 @@\n-            ObjectIdentifier.newInternal(GENERATIONQUALIFIER_DATA);\n+            ObjectIdentifier.of(KnownOIDs.GenerationQualifier);\n+\n+    \/\/ OID for the \"DNQUALIFIER=\" or \"DNQ=\" attribute, denoting DN\n+    \/\/ disambiguating information.\n+    public static final ObjectIdentifier DNQUALIFIER_OID =\n+            ObjectIdentifier.of(KnownOIDs.DNQualifier);\n@@ -1191,1 +1170,1 @@\n-            ObjectIdentifier.newInternal(ipAddress_data);\n+            ObjectIdentifier.of(KnownOIDs.SkipIPAddress);\n@@ -1195,1 +1174,1 @@\n-    \/\/ OID for \"DC=\" domain component attributes, used with DNSNames in DN\n+    \/\/ OID for \"DC=\" domain component attributes.used with DNSNames in DN\n@@ -1198,1 +1177,1 @@\n-            ObjectIdentifier.newInternal(DOMAIN_COMPONENT_DATA);\n+            ObjectIdentifier.of(KnownOIDs.UCL_DomainComponent);\n@@ -1202,1 +1181,1 @@\n-            ObjectIdentifier.newInternal(userid_data);\n+            ObjectIdentifier.of(KnownOIDs.UCL_UserID);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X500Name.java","additions":32,"deletions":53,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -255,1 +255,2 @@\n-            byte[] ext = crlEntry.getExtensionValue(\"2.5.29.21\");\n+            byte[] ext = crlEntry.getExtensionValue\n+                    (KnownOIDs.ReasonCode.value());\n@@ -405,1 +406,1 @@\n-            String extAlias = OIDMap.getName(new ObjectIdentifier(oid));\n+            String extAlias = OIDMap.getName(ObjectIdentifier.of(oid));\n@@ -409,1 +410,1 @@\n-                ObjectIdentifier findOID = new ObjectIdentifier(oid);\n+                ObjectIdentifier findOID = ObjectIdentifier.of(oid);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLEntryImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-            String extAlias = OIDMap.getName(new ObjectIdentifier(oid));\n+            String extAlias = OIDMap.getName(ObjectIdentifier.of(oid));\n@@ -1043,1 +1043,1 @@\n-                ObjectIdentifier findOID = new ObjectIdentifier(oid);\n+                ObjectIdentifier findOID = ObjectIdentifier.of(oid);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -133,8 +134,0 @@\n-    \/\/ recognized extension OIDS\n-    private static final String KEY_USAGE_OID = \"2.5.29.15\";\n-    private static final String EXTENDED_KEY_USAGE_OID = \"2.5.29.37\";\n-    private static final String BASIC_CONSTRAINT_OID = \"2.5.29.19\";\n-    private static final String SUBJECT_ALT_NAME_OID = \"2.5.29.17\";\n-    private static final String ISSUER_ALT_NAME_OID = \"2.5.29.18\";\n-    private static final String AUTH_INFO_ACCESS_OID = \"1.3.6.1.5.5.7.1.1\";\n-\n@@ -315,0 +308,7 @@\n+    \/\/ helper method to record certificate, if necessary, after construction\n+    public static X509CertImpl newX509CertImpl(byte[] certData) throws CertificateException {\n+        var cert = new X509CertImpl(certData);\n+        JCAUtil.tryCommitCertEvent(cert);\n+        return cert;\n+    }\n+\n@@ -1428,1 +1428,1 @@\n-            ObjectIdentifier findOID = new ObjectIdentifier(oid);\n+            ObjectIdentifier findOID = ObjectIdentifier.of(oid);\n@@ -1531,1 +1531,2 @@\n-            byte[] ext = cert.getExtensionValue(EXTENDED_KEY_USAGE_OID);\n+            byte[] ext = cert.getExtensionValue\n+                    (KnownOIDs.extendedKeyUsage.value());\n@@ -1701,1 +1702,2 @@\n-            byte[] ext = cert.getExtensionValue(SUBJECT_ALT_NAME_OID);\n+            byte[] ext = cert.getExtensionValue\n+                    (KnownOIDs.SubjectAlternativeName.value());\n@@ -1764,1 +1766,2 @@\n-            byte[] ext = cert.getExtensionValue(ISSUER_ALT_NAME_OID);\n+            byte[] ext = cert.getExtensionValue\n+                    (KnownOIDs.IssuerAlternativeName.value());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+#\n+# If this properties file fails to load, the JDK implementation will throw\n+# an unspecified error when initializing the java.security.Security class.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,6 @@\n+    if (elements != NULL) {\n+        for (i = 0; i < nElements; i++) {\n+            NSString *pbFormat = formatForIndex(elements[i]);\n+            if (pbFormat)\n+                [formatArray addObject:pbFormat];\n+        }\n@@ -140,4 +146,2 @@\n-    for (i = 0; i < nElements; i++) {\n-        NSString *pbFormat = formatForIndex(elements[i]);\n-        if (pbFormat)\n-            [formatArray addObject:pbFormat];\n+        (*env)->ReleasePrimitiveArrayCritical(env, inTypes, elements, JNI_ABORT);\n+        [[CClipboard sharedClipboard] declareTypes:formatArray withOwner:inJavaClip jniEnv:env];\n@@ -145,3 +149,0 @@\n-\n-    (*env)->ReleasePrimitiveArrayCritical(env, inTypes, elements, JNI_ABORT);\n-    [[CClipboard sharedClipboard] declareTypes:formatArray withOwner:inJavaClip jniEnv:env];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CClipboard.m","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,2 +61,3 @@\n-    CTS_GetGlyphsAsIntsForCharacters(awtFont, unicodes,\n-                                     cgGlyphs, glyphCodeInts, count);\n+    if (glyphCodeInts != NULL) {\n+        CTS_GetGlyphsAsIntsForCharacters(awtFont, unicodes,\n+                                         cgGlyphs, glyphCodeInts, count);\n@@ -64,3 +65,4 @@\n-    \/\/ Do not use JNI_COMMIT, as that will not free the buffer copy\n-    \/\/ when +ProtectJavaHeap is on.\n-    (*env)->ReleasePrimitiveArrayCritical(env, glyphs, glyphCodeInts, 0);\n+        \/\/ Do not use JNI_COMMIT, as that will not free the buffer copy\n+        \/\/ when +ProtectJavaHeap is on.\n+        (*env)->ReleasePrimitiveArrayCritical(env, glyphs, glyphCodeInts, 0);\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CCharToGlyphMapper.m","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -280,5 +280,7 @@\n-    rect[0] = partBounds.origin.x;\n-    rect[1] = partBounds.origin.y;\n-    rect[2] = partBounds.size.width;\n-    rect[3] = partBounds.size.height;\n-    (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rect, 0);\n+    if (rect != NULL) {\n+        rect[0] = partBounds.origin.x;\n+        rect[1] = partBounds.origin.y;\n+        rect[2] = partBounds.size.width;\n+        rect[3] = partBounds.size.height;\n+        (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rect, 0);\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/JRSUIController.m","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Harfbuzz v7.0.1\n+## Harfbuzz v7.2.0\n@@ -5,1 +5,1 @@\n-https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/7.0.1\/COPYING\n+https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/7.2.0\/COPYING\n@@ -13,1 +13,1 @@\n-Copyright  2010-2022  Google, Inc.\n+Copyright  2010-2023  Google, Inc.\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## libpng v1.6.38\n+## libpng v1.6.39\n@@ -191,0 +191,2 @@\n+   - Dan Field\n+   - Leon Scroggins III\n@@ -193,1 +195,0 @@\n-   - Dan Field\n","filename":"src\/java.desktop\/share\/legal\/libpng.md","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/****************************************************************************\n+ *\n+ * ftcolor.c\n+ *\n+ *   FreeType's glyph color management (body).\n+ *\n+ * Copyright (C) 2018-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#include <freetype\/internal\/ftdebug.h>\n+#include <freetype\/internal\/sfnt.h>\n+#include <freetype\/internal\/tttypes.h>\n+#include <freetype\/ftcolor.h>\n+\n+\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\n+\n+  static\n+  const FT_Palette_Data  null_palette_data = { 0, NULL, NULL, 0, NULL };\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+    if ( !apalette_data)\n+      return FT_THROW( Invalid_Argument );\n+\n+    if ( FT_IS_SFNT( face ) )\n+      *apalette_data = ( (TT_Face)face )->palette_data;\n+    else\n+      *apalette_data = null_palette_data;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_Error  error;\n+\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+    {\n+      if ( apalette )\n+        *apalette = NULL;\n+\n+      return FT_Err_Ok;\n+    }\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    error = sfnt->set_palette( ttface, palette_index );\n+    if ( error )\n+      return error;\n+\n+    ttface->palette_index = palette_index;\n+\n+    if ( apalette )\n+      *apalette = ttface->palette;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    TT_Face  ttface;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return FT_Err_Ok;\n+\n+    ttface = (TT_Face)face;\n+\n+    ttface->foreground_color      = foreground_color;\n+    ttface->have_foreground_color = 1;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+#else \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( apalette_data );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( palette_index );\n+    FT_UNUSED( apalette );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( foreground_color );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+#endif \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcolor.c","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -43,1 +43,0 @@\n-\n@@ -245,1 +244,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -248,1 +248,5 @@\n-    if (!value.subset (c)) return_trace (false);\n+    if (!value.subset (c, instancer, varIdxBase)) return_trace (false);\n+    if (c->plan->all_axes_pinned)\n+      return_trace (true);\n+\n+    \/\/TODO: update varIdxBase for partial-instancing\n@@ -299,1 +303,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -302,1 +307,1 @@\n-    return_trace (value.subset (c));\n+    return_trace (value.subset (c, instancer, varIdxBase));\n@@ -340,1 +345,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -345,0 +352,7 @@\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->stopOffset.set_float (stopOffset.to_float(instancer (varIdxBase, 0)));\n+      out->alpha.set_float (alpha.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n@@ -393,1 +407,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -405,1 +420,1 @@\n-      if (!stop.subset (c)) return_trace (false);\n+      if (!stop.subset (c, instancer)) return_trace (false);\n@@ -526,0 +541,19 @@\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xx.set_float (xx.to_float(instancer (varIdxBase, 0)));\n+      out->yx.set_float (yx.to_float(instancer (varIdxBase, 1)));\n+      out->xy.set_float (xy.to_float(instancer (varIdxBase, 2)));\n+      out->yy.set_float (yy.to_float(instancer (varIdxBase, 3)));\n+      out->dx.set_float (dx.to_float(instancer (varIdxBase, 4)));\n+      out->dy.set_float (dy.to_float(instancer (varIdxBase, 5)));\n+    }\n+    return_trace (true);\n+  }\n+\n@@ -551,1 +585,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer HB_UNUSED) const\n@@ -582,1 +617,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -587,0 +624,7 @@\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->alpha.set_float (alpha.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 3 && c->plan->all_axes_pinned)\n+        out->format = 2;\n+\n@@ -621,1 +665,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -627,1 +673,14 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->x0 = x0 + (int) roundf (instancer (varIdxBase, 0));\n+      out->y0 = y0 + (int) roundf (instancer (varIdxBase, 1));\n+      out->x1 = x1 + (int) roundf (instancer (varIdxBase, 2));\n+      out->y1 = y1 + (int) roundf (instancer (varIdxBase, 3));\n+      out->x2 = x2 + (int) roundf (instancer (varIdxBase, 4));\n+      out->y2 = y2 + (int) roundf (instancer (varIdxBase, 5));\n+    }\n+\n+    if (format == 5 && c->plan->all_axes_pinned)\n+        out->format = 4;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -672,1 +731,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -678,1 +739,14 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->x0 = x0 + (int) roundf (instancer (varIdxBase, 0));\n+      out->y0 = y0 + (int) roundf (instancer (varIdxBase, 1));\n+      out->radius0 = radius0 + (unsigned) roundf (instancer (varIdxBase, 2));\n+      out->x1 = x1 + (int) roundf (instancer (varIdxBase, 3));\n+      out->y1 = y1 + (int) roundf (instancer (varIdxBase, 4));\n+      out->radius1 = radius1 + (unsigned) roundf (instancer (varIdxBase, 5));\n+    }\n+\n+    if (format == 7 && c->plan->all_axes_pinned)\n+        out->format = 6;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -723,1 +797,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -729,1 +805,12 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 0));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 1));\n+      out->startAngle.set_float (startAngle.to_float (instancer (varIdxBase, 2)));\n+      out->endAngle.set_float (endAngle.to_float (instancer (varIdxBase, 3)));\n+    }\n+\n+    if (format == 9 && c->plan->all_axes_pinned)\n+        out->format = 8;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -749,2 +836,2 @@\n-                              (startAngle.to_float (c->instancer (varIdxBase, 2)) + 1) * (float) M_PI,\n-                              (endAngle.to_float   (c->instancer (varIdxBase, 3)) + 1) * (float) M_PI);\n+                              (startAngle.to_float (c->instancer (varIdxBase, 2)) + 1) * HB_PI,\n+                              (endAngle.to_float   (c->instancer (varIdxBase, 3)) + 1) * HB_PI);\n@@ -769,1 +856,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -779,1 +867,1 @@\n-    return_trace (out->paint.serialize_subset (c, paint, this));\n+    return_trace (out->paint.serialize_subset (c, paint, this, instancer));\n@@ -810,1 +898,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer HB_UNUSED) const\n@@ -839,1 +928,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -844,2 +934,4 @@\n-    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (!out->transform.serialize_subset (c, transform, this, instancer)) return_trace (false);\n+    if (format == 13 && c->plan->all_axes_pinned)\n+      out->format = 12;\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -874,1 +966,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -880,1 +974,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->dx = dx + (int) roundf (instancer (varIdxBase, 0));\n+      out->dy = dy + (int) roundf (instancer (varIdxBase, 1));\n+    }\n+\n+    if (format == 15 && c->plan->all_axes_pinned)\n+        out->format = 14;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -911,1 +1014,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -917,1 +1022,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scaleX.set_float (scaleX.to_float (instancer (varIdxBase, 0)));\n+      out->scaleY.set_float (scaleY.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n+    if (format == 17 && c->plan->all_axes_pinned)\n+        out->format = 16;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -948,1 +1062,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -954,1 +1070,12 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scaleX.set_float (scaleX.to_float (instancer (varIdxBase, 0)));\n+      out->scaleY.set_float (scaleY.to_float (instancer (varIdxBase, 1)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 2));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 19 && c->plan->all_axes_pinned)\n+        out->format = 18;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -993,1 +1120,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -999,1 +1128,7 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->scale.set_float (scale.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 21 && c->plan->all_axes_pinned)\n+        out->format = 20;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1028,1 +1163,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1034,1 +1171,11 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scale.set_float (scale.to_float (instancer (varIdxBase, 0)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 1));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 2));\n+    }\n+\n+    if (format == 23 && c->plan->all_axes_pinned)\n+        out->format = 22;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1071,1 +1218,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1077,1 +1226,7 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->angle.set_float (angle.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 25 && c->plan->all_axes_pinned)\n+      out->format = 24;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1106,1 +1261,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1112,1 +1269,11 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->angle.set_float (angle.to_float (instancer (varIdxBase, 0)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 1));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 2));\n+    }\n+\n+    if (format ==27 && c->plan->all_axes_pinned)\n+        out->format = 26;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1149,1 +1316,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1155,1 +1324,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xSkewAngle.set_float (xSkewAngle.to_float (instancer (varIdxBase, 0)));\n+      out->ySkewAngle.set_float (ySkewAngle.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n+    if (format == 29 && c->plan->all_axes_pinned)\n+        out->format = 28;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1186,1 +1364,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1192,1 +1372,12 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xSkewAngle.set_float (xSkewAngle.to_float (instancer (varIdxBase, 0)));\n+      out->ySkewAngle.set_float (ySkewAngle.to_float (instancer (varIdxBase, 1)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 2));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 31 && c->plan->all_axes_pinned)\n+        out->format = 30;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1231,1 +1422,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1237,2 +1429,2 @@\n-    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n-    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n+    if (!out->src.serialize_subset (c, src, this, instancer)) return_trace (false);\n+    return_trace (out->backdrop.serialize_subset (c, backdrop, this, instancer));\n@@ -1286,0 +1478,22 @@\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xMin = xMin + (int) roundf (instancer (varIdxBase, 0));\n+      out->yMin = yMin + (int) roundf (instancer (varIdxBase, 1));\n+      out->xMax = xMax + (int) roundf (instancer (varIdxBase, 2));\n+      out->yMax = yMax + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 2 && c->plan->all_axes_pinned)\n+        out->format = 1;\n+\n+    return_trace (true);\n+  }\n+\n@@ -1313,1 +1527,2 @@\n-  ClipBox* copy (hb_serialize_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1315,1 +1530,1 @@\n-    TRACE_SERIALIZE (this);\n+    TRACE_SUBSET (this);\n@@ -1317,3 +1532,3 @@\n-    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n-    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n-    default:return_trace (nullptr);\n+    case 1: return_trace (u.format1.subset (c, instancer, VarIdx::NO_VARIATION));\n+    case 2: return_trace (u.format2.subset (c, instancer));\n+    default:return_trace (c->default_return_value ());\n@@ -1370,1 +1585,3 @@\n-  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  bool subset (hb_subset_context_t *c,\n+               const void *base,\n+               const VarStoreInstancer &instancer) const\n@@ -1372,5 +1589,5 @@\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n-    return_trace (out);\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->clipBox.serialize_subset (c, clipBox, base, instancer));\n@@ -1403,1 +1620,2 @@\n-  unsigned serialize_clip_records (hb_serialize_context_t *c,\n+  unsigned serialize_clip_records (hb_subset_context_t *c,\n+                                   const VarStoreInstancer &instancer,\n@@ -1435,1 +1653,1 @@\n-      if (!c->copy (record, this)) return_trace (0);\n+      if (!record.subset (c, this, instancer)) return_trace (0);\n@@ -1449,1 +1667,1 @@\n-      if (!c->copy (record, this)) return_trace (0);\n+      if (!record.subset (c, this, instancer)) return_trace (0);\n@@ -1455,1 +1673,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1480,1 +1699,1 @@\n-    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n+    unsigned count = serialize_clip_records (c, instancer, new_gids, new_gid_offset_map);\n@@ -1614,1 +1833,2 @@\n-                  const void* src_base, hb_subset_context_t *c) const\n+                  const void* src_base, hb_subset_context_t *c,\n+                  const VarStoreInstancer &instancer) const\n@@ -1623,1 +1843,1 @@\n-    return_trace (out->paint.serialize_subset (c, paint, src_base));\n+    return_trace (out->paint.serialize_subset (c, paint, src_base, instancer));\n@@ -1642,1 +1862,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1654,1 +1875,1 @@\n-      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n+      if (_.serialize (c->serializer, c->plan->glyph_map, this, c, instancer)) out->len++;\n@@ -1673,1 +1894,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1684,1 +1906,1 @@\n-      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n+      if (unlikely (!o) || !o->serialize_subset (c, _.second, this, instancer))\n@@ -1886,1 +2108,0 @@\n-\n@@ -1957,1 +2178,6 @@\n-    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n+\n+    VarStoreInstancer instancer (varStore ? &(this+varStore) : nullptr,\n+                                 varIdxMap ? &(this+varIdxMap) : nullptr,\n+                                 c->plan->normalized_coords.as_array ());\n+\n+    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this, instancer))\n@@ -1967,2 +2193,5 @@\n-    colr_prime->layerList.serialize_subset (c, layerList, this);\n-    colr_prime->clipList.serialize_subset (c, clipList, this);\n+    colr_prime->layerList.serialize_subset (c, layerList, this, instancer);\n+    colr_prime->clipList.serialize_subset (c, clipList, this, instancer);\n+    if (!varStore || c->plan->all_axes_pinned)\n+      return_trace (true);\n+\n@@ -1987,0 +2216,1 @@\n+#ifndef HB_NO_PAINT\n@@ -1993,2 +2223,2 @@\n-    VarStoreInstancer instancer (this+varStore,\n-                                 this+varIdxMap,\n+    VarStoreInstancer instancer (&(this+varStore),\n+                                 &(this+varIdxMap),\n@@ -2025,0 +2255,1 @@\n+#endif\n@@ -2048,0 +2279,1 @@\n+#ifndef HB_NO_PAINT\n@@ -2051,2 +2283,2 @@\n-    VarStoreInstancer instancer (this+varStore,\n-                                 this+varIdxMap,\n+    VarStoreInstancer instancer (&(this+varStore),\n+                                 &(this+varIdxMap),\n@@ -2063,2 +2295,2 @@\n-        VarStoreInstancer instancer (this+varStore,\n-                                     this+varIdxMap,\n+        VarStoreInstancer instancer (&(this+varStore),\n+                                     &(this+varIdxMap),\n@@ -2134,0 +2366,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/COLR\/COLR.hh","additions":310,"deletions":77,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -76,0 +76,24 @@\n+  void collect_name_ids (const void *base,\n+                         unsigned palette_count,\n+                         unsigned color_count,\n+                         const hb_map_t *color_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (paletteLabelsZ)\n+    {\n+      + (base+paletteLabelsZ).as_array (palette_count)\n+      | hb_sink (nameids_to_retain)\n+      ;\n+    }\n+\n+    if (colorLabelsZ)\n+    {\n+      const hb_array_t<const NameID> colorLabels = (base+colorLabelsZ).as_array (color_count);\n+      for (unsigned i = 0; i < color_count; i++)\n+      {\n+        if (!color_index_map->has (i)) continue;\n+        nameids_to_retain->add (colorLabels[i]);\n+      }\n+    }\n+  }\n+\n@@ -98,1 +122,1 @@\n-      for (const auto _ : colorLabels)\n+      for (unsigned i = 0; i < color_count; i++)\n@@ -100,5 +124,2 @@\n-        const hb_codepoint_t *v;\n-        if (!color_index_map->has (_, &v)) continue;\n-        NameID new_color_idx;\n-        new_color_idx = *v;\n-        if (!c->copy<NameID> (new_color_idx))\n+        if (!color_index_map->has (i)) continue;\n+        if (!c->copy<NameID> (colorLabels[i]))\n@@ -192,0 +213,7 @@\n+  void collect_name_ids (const hb_map_t *color_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (version == 1)\n+      v1 ().collect_name_ids (this, numPalettes, numColors, color_index_map, nameids_to_retain);\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/CPAL\/CPAL.hh","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    j = (unsigned) c->last_base;\n+    unsigned idx = (unsigned) c->last_base;\n@@ -132,1 +132,1 @@\n-    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[j])) { return_trace (false); }\n+    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[idx])) { return_trace (false); }\n@@ -134,1 +134,1 @@\n-    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n+    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[idx].codepoint);\n@@ -137,1 +137,1 @@\n-      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      buffer->unsafe_to_concat_from_outbuffer (idx, buffer->idx + 1);\n@@ -148,1 +148,1 @@\n-      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      buffer->unsafe_to_concat_from_outbuffer (idx, buffer->idx + 1);\n@@ -157,1 +157,1 @@\n-    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[idx]);\n@@ -165,1 +165,1 @@\n-    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n+    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, idx));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPosFormat1.hh","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+      for (hb_codepoint_t g : glyphs->iter())\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,7 @@\n+                  \/* The coverage  table may use a range to represent a set\n+                   * of glyphs, which means a small number of bytes can\n+                   * generate a large glyph set. Manually modify the\n+                   * sanitizer max ops to take this into account.\n+                   *\n+                   * Note: This check *must* be right after coverage sanitize. *\/\n+                  c->check_ops ((this + coverage).get_population () >> 1) &&\n@@ -32,0 +39,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat1.hh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+  bool intersects_lig_glyph (const hb_set_t *glyphs) const\n+  { return glyphs->has(ligGlyph); }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Ligature.hh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,12 @@\n+  bool intersects_lig_glyph (const hb_set_t *glyphs) const\n+  {\n+    return\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_map ([glyphs] (const Ligature<Types> &_) {\n+      return _.intersects_lig_glyph (glyphs) && _.intersects (glyphs);\n+    })\n+    | hb_any\n+    ;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSet.hh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-      return _.intersects (&glyphset);\n+      return _.intersects_lig_glyph (&glyphset);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubstFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,9 @@\n-    return_trace (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  \/* The coverage  table may use a range to represent a set\n+                   * of glyphs, which means a small number of bytes can\n+                   * generate a large glyph set. Manually modify the\n+                   * sanitizer max ops to take this into account.\n+                   *\n+                   * Note: This check *must* be right after coverage sanitize. *\/\n+                  c->check_ops ((this + coverage).get_population () >> 1));\n@@ -90,0 +98,28 @@\n+  unsigned\n+  get_glyph_alternates (hb_codepoint_t  glyph_id,\n+                        unsigned        start_offset,\n+                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED))\n+    {\n+      if (alternate_count)\n+        *alternate_count = 0;\n+      return 0;\n+    }\n+\n+    if (alternate_count && *alternate_count)\n+    {\n+      hb_codepoint_t d = deltaGlyphID;\n+      hb_codepoint_t mask = get_mask ();\n+\n+      glyph_id = (glyph_id + d) & mask;\n+\n+      *alternate_glyphs = glyph_id;\n+      *alternate_count = 1;\n+    }\n+\n+    return 1;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat1.hh","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -78,0 +78,25 @@\n+  unsigned\n+  get_glyph_alternates (hb_codepoint_t  glyph_id,\n+                        unsigned        start_offset,\n+                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED))\n+    {\n+      if (alternate_count)\n+        *alternate_count = 0;\n+      return 0;\n+    }\n+\n+    if (alternate_count && *alternate_count)\n+    {\n+      glyph_id = substitute[index];\n+\n+      *alternate_glyphs = glyph_id;\n+      *alternate_count = 1;\n+    }\n+\n+    return 1;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat2.hh","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-  void transform_points (contour_point_vector_t &points) const\n+  void transform_points (contour_point_vector_t &points,\n+                         const float (&matrix)[4],\n+                         const contour_point_t &trans) const\n@@ -92,3 +94,1 @@\n-    float matrix[4];\n-    contour_point_t trans;\n-    if (get_transformation (matrix, trans))\n+    if (scaled_offsets ())\n@@ -96,10 +96,7 @@\n-      if (scaled_offsets ())\n-      {\n-        points.translate (trans);\n-        points.transform (matrix);\n-      }\n-      else\n-      {\n-        points.transform (matrix);\n-        points.translate (trans);\n-      }\n+      points.translate (trans);\n+      points.transform (matrix);\n+    }\n+    else\n+    {\n+      points.transform (matrix);\n+      points.translate (trans);\n@@ -109,2 +106,12 @@\n-  unsigned compile_with_deltas (const contour_point_t &p_delta,\n-                                char *out) const\n+  bool get_points (contour_point_vector_t &points) const\n+  {\n+    float matrix[4];\n+    contour_point_t trans;\n+    get_transformation (matrix, trans);\n+    if (unlikely (!points.resize (points.length + 1))) return false;\n+    points[points.length - 1] = trans;\n+    return true;\n+  }\n+\n+  unsigned compile_with_point (const contour_point_t &point,\n+                               char *out) const\n@@ -124,1 +131,1 @@\n-      \/\/ no overflow, copy and update value with deltas\n+      \/\/ no overflow, copy value\n@@ -127,1 +134,0 @@\n-      const HBINT16 *px = reinterpret_cast<const HBINT16 *> (p);\n@@ -129,2 +135,2 @@\n-      o[0] = px[0] + roundf (p_delta.x);\n-      o[1] = px[1] + roundf (p_delta.y);\n+      o[0] = roundf (point.x);\n+      o[1] = roundf (point.y);\n@@ -134,2 +140,2 @@\n-      int new_x = p[0] + roundf (p_delta.x);\n-      int new_y = p[1] + roundf (p_delta.y);\n+      int new_x = roundf (point.x);\n+      int new_y = roundf (point.y);\n@@ -146,1 +152,1 @@\n-        \/\/ int8 overflows after deltas applied\n+        \/\/ new point value has an int8 overflow\n@@ -174,0 +180,1 @@\n+  public:\n@@ -228,1 +235,0 @@\n-  public:\n@@ -249,0 +255,21 @@\n+#ifndef HB_NO_BEYOND_64K\n+  void lower_gid_24_to_16 ()\n+  {\n+    hb_codepoint_t gid = get_gid ();\n+    if (!(flags & GID_IS_24BIT) || gid > 0xFFFFu)\n+      return;\n+\n+    \/* Lower the flag and move the rest of the struct down. *\/\n+\n+    unsigned size = get_size ();\n+    char *end = (char *) this + size;\n+    char *p = &StructAfter<char> (flags);\n+    p += HBGlyphID24::static_size;\n+\n+    flags = flags & ~GID_IS_24BIT;\n+    set_gid (gid);\n+\n+    memmove (p - HBGlyphID24::static_size + HBGlyphID16::static_size, p, end - p);\n+  }\n+#endif\n+\n@@ -307,1 +334,1 @@\n-                                  const contour_point_vector_t &deltas,\n+                                  const contour_point_vector_t &points_with_deltas,\n@@ -322,1 +349,1 @@\n-    char *o = (char *) hb_calloc (source_len + source_len\/2, sizeof (char));\n+    char *o = (char *) hb_calloc (source_len * 2, sizeof (char));\n@@ -332,2 +359,5 @@\n-      \/* last 4 points in deltas are phantom points and should not be included *\/\n-      if (i >= deltas.length - 4) return false;\n+      \/* last 4 points in points_with_deltas are phantom points and should not be included *\/\n+      if (i >= points_with_deltas.length - 4) {\n+        free (o);\n+        return false;\n+      }\n@@ -343,1 +373,1 @@\n-        unsigned new_len = component.compile_with_deltas (deltas[i], p);\n+        unsigned new_len = component.compile_with_point (points_with_deltas[i], p);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/CompositeGlyph.hh","additions":59,"deletions":29,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -32,1 +32,8 @@\n-  enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE, VAR_COMPOSITE };\n+  enum glyph_type_t {\n+    EMPTY,\n+    SIMPLE,\n+    COMPOSITE,\n+#ifndef HB_NO_VAR_COMPOSITES\n+    VAR_COMPOSITE,\n+#endif\n+  };\n@@ -42,0 +49,1 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n@@ -44,0 +52,3 @@\n+#else\n+    return var_composite_iter_t ();\n+#endif\n@@ -49,0 +60,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return VarCompositeGlyph (*header, bytes).trim_padding ();\n+#endif\n@@ -51,0 +65,1 @@\n+    case EMPTY:     return bytes;\n@@ -58,0 +73,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No hinting\n+#endif\n@@ -60,1 +78,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -67,0 +85,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No overlaps flag\n+#endif\n@@ -69,1 +90,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -76,0 +97,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No hinting\n+#endif\n@@ -78,1 +102,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -184,1 +208,1 @@\n-    contour_point_vector_t all_points, deltas;\n+    contour_point_vector_t all_points, points_with_deltas;\n@@ -198,1 +222,1 @@\n-    if (!get_points (font, glyf, all_points, &deltas, head_maxp_info_p, composite_contours_p, false, false))\n+    if (!get_points (font, glyf, all_points, &points_with_deltas, head_maxp_info_p, composite_contours_p, false, false))\n@@ -212,2 +236,11 @@\n-    if (!plan->pinned_at_default) {\n-      switch (type) {\n+    if (!plan->pinned_at_default)\n+    {\n+      switch (type)\n+      {\n+#ifndef HB_NO_VAR_COMPOSITES\n+      case VAR_COMPOSITE:\n+        \/\/ TODO\n+        dest_end = hb_bytes_t ();\n+        break;\n+#endif\n+\n@@ -216,1 +249,1 @@\n-                                                                        deltas,\n+                                                                        points_with_deltas,\n@@ -226,1 +259,1 @@\n-      default:\n+      case EMPTY:\n@@ -250,1 +283,1 @@\n-                   contour_point_vector_t *deltas = nullptr, \/* OUT *\/\n+                   contour_point_vector_t *points_with_deltas = nullptr, \/* OUT *\/\n@@ -290,3 +323,2 @@\n-      \/* pseudo component points for each component in composite glyph *\/\n-      unsigned num_points = hb_len (CompositeGlyph (*header, bytes).iter ());\n-      if (unlikely (!points.resize (num_points))) return false;\n+      for (auto &item : get_composite_iterator ())\n+        if (unlikely (!item.get_points (points))) return false;\n@@ -302,1 +334,1 @@\n-    default:\n+    case EMPTY:\n@@ -330,1 +362,1 @@\n-      phantoms[PHANTOM_RIGHT].x = h_adv + h_delta;\n+      phantoms[PHANTOM_RIGHT].x = (int) h_adv + h_delta;\n@@ -335,6 +367,0 @@\n-    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n-    {\n-      if (unlikely (!deltas->resize (points.length))) return false;\n-      deltas->copy_vector (points);\n-    }\n-\n@@ -349,1 +375,1 @@\n-    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n+    if (points_with_deltas != nullptr && depth == 0 && type == COMPOSITE)\n@@ -351,5 +377,2 @@\n-      for (unsigned i = 0 ; i < points.length; i++)\n-      {\n-        deltas->arrayZ[i].x = points.arrayZ[i].x - deltas->arrayZ[i].x;\n-        deltas->arrayZ[i].y = points.arrayZ[i].y - deltas->arrayZ[i].y;\n-      }\n+      if (unlikely (!points_with_deltas->resize (points.length))) return false;\n+      points_with_deltas->copy_vector (points);\n@@ -376,1 +399,1 @@\n-                                                    deltas,\n+                                                    points_with_deltas,\n@@ -392,2 +415,3 @@\n-        \/* Apply component transformation & translation *\/\n-        item.transform_points (comp_points);\n+        float matrix[4];\n+        contour_point_t default_trans;\n+        item.get_transformation (matrix, default_trans);\n@@ -395,2 +419,2 @@\n-        \/* Apply translation from gvar *\/\n-        comp_points.translate (points[comp_index]);\n+        \/* Apply component transformation & translation (with deltas applied) *\/\n+        item.transform_points (comp_points, matrix, points[comp_index]);\n@@ -436,1 +460,2 @@\n-        hb_array_t<contour_point_t> record_points = points_left.sub_array (0, item.get_num_points ());\n+        unsigned item_num_points = item.get_num_points ();\n+        hb_array_t<contour_point_t> record_points = points_left.sub_array (0, item_num_points);\n@@ -451,1 +476,1 @@\n-                                                    deltas,\n+                                                    points_with_deltas,\n@@ -475,1 +500,1 @@\n-        points_left += item.get_num_points ();\n+        points_left += item_num_points;\n@@ -480,1 +505,1 @@\n-    default:\n+    case EMPTY:\n@@ -506,0 +531,2 @@\n+  glyph_type_t get_type () const { return type; }\n+  const GlyphHeader *get_header () const { return header; }\n@@ -521,0 +548,1 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n@@ -522,0 +550,1 @@\n+#endif\n@@ -529,1 +558,1 @@\n-  unsigned type;\n+  glyph_type_t type;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/Glyph.hh","additions":67,"deletions":38,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+  bool has_instructions_length () const\n+  {\n+    return instruction_len_offset () + 2 <= bytes.length;\n+  }\n+\n@@ -97,0 +102,1 @@\n+    if (!has_instructions_length ()) return;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SimpleGlyph.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+  bool allocated;\n@@ -29,1 +30,6 @@\n-    dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + dest_end.copy (c).length);\n+    hb_bytes_t end_copy = dest_end.copy (c);\n+    if (!end_copy.arrayZ || !dest_glyph.arrayZ) {\n+      return false;\n+    }\n+\n+    dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + end_copy.length);\n@@ -43,1 +49,1 @@\n-    \/* update components gids *\/\n+    \/* update components gids. *\/\n@@ -50,0 +56,55 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    for (auto &_ : Glyph (dest_glyph).get_var_composite_iterator ())\n+    {\n+      hb_codepoint_t new_gid;\n+      if (plan->new_gid_for_old_gid (_.get_gid(), &new_gid))\n+        const_cast<VarCompositeGlyphRecord &> (_).set_gid (new_gid);\n+    }\n+#endif\n+\n+#ifndef HB_NO_BEYOND_64K\n+    auto it = Glyph (dest_glyph).get_composite_iterator ();\n+    if (it)\n+    {\n+      \/* lower GID24 to GID16 in components if possible.\n+       *\n+       * TODO: VarComposite. Not as critical, since VarComposite supports\n+       * gid24 from the first version. *\/\n+      char *p = it ? (char *) &*it : nullptr;\n+      char *q = p;\n+      const char *end = dest_glyph.arrayZ + dest_glyph.length;\n+      while (it)\n+      {\n+        auto &rec = const_cast<CompositeGlyphRecord &> (*it);\n+        ++it;\n+\n+        q += rec.get_size ();\n+\n+        rec.lower_gid_24_to_16 ();\n+\n+        unsigned size = rec.get_size ();\n+\n+        memmove (p, &rec, size);\n+\n+        p += size;\n+      }\n+      memmove (p, q, end - q);\n+      p += end - q;\n+\n+      \/* We want to shorten the glyph, but we can't do that without\n+       * updating the length in the loca table, which is already\n+       * written out :-(.  So we just fill the rest of the glyph with\n+       * harmless instructions, since that's what they will be\n+       * interpreted as.\n+       *\n+       * Should move the lowering to _populate_subset_glyphs() to\n+       * fix this issue. *\/\n+\n+      hb_memset (p, 0x7A \/* TrueType instruction ROFF; harmless *\/, end - p);\n+      p += end - p;\n+      dest_glyph = hb_bytes_t (dest_glyph.arrayZ, p - (char *) dest_glyph.arrayZ);\n+\n+      \/\/ TODO: Padding; & trim serialized bytes.\n+      \/\/ TODO: Update length in loca. Ugh.\n+    }\n+#endif\n@@ -63,1 +124,4 @@\n-  { return source_glyph.compile_bytes_with_deltas (plan, font, glyf, dest_start, dest_end); }\n+  {\n+    allocated = source_glyph.compile_bytes_with_deltas (plan, font, glyf, dest_start, dest_end);\n+    return allocated;\n+  }\n@@ -67,2 +131,5 @@\n-    dest_start.fini ();\n-    dest_end.fini ();\n+    if (likely (allocated)) {\n+      allocated = false;\n+      dest_start.fini ();\n+      dest_end.fini ();\n+    }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SubsetGlyph.hh","additions":72,"deletions":5,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    GID_IS_24                   = 0x1000,\n+    GID_IS_24BIT                = 0x1000,\n@@ -46,1 +46,1 @@\n-    if (flags & GID_IS_24)              size += 1;\n+    if (flags & GID_IS_24BIT)           size += 1;\n@@ -68,1 +68,1 @@\n-    if (flags & GID_IS_24)\n+    if (flags & GID_IS_24BIT)\n@@ -74,0 +74,8 @@\n+  void set_gid (hb_codepoint_t gid)\n+  {\n+    if (flags & GID_IS_24BIT)\n+      StructAfter<HBGlyphID24> (numAxes) = gid;\n+    else\n+      StructAfter<HBGlyphID16> (numAxes) = gid;\n+  }\n+\n@@ -148,1 +156,1 @@\n-    rotation = rotation * float (M_PI);\n+    rotation = rotation * HB_PI;\n@@ -159,2 +167,2 @@\n-    skewX = skewX * float (M_PI);\n-    skewY = skewY * float (M_PI);\n+    skewX = skewX * HB_PI;\n+    skewY = skewY * HB_PI;\n@@ -177,1 +185,3 @@\n-    if (unlikely (!points.resize (points.length + get_num_points ()))) return false;\n+    unsigned num_points = get_num_points ();\n+\n+    if (unlikely (!points.resize (points.length + num_points))) return false;\n@@ -183,1 +193,1 @@\n-                                          (flags & GID_IS_24 ? 3 : 2) +\n+                                          (flags & GID_IS_24BIT ? 3 : 2) +\n@@ -186,1 +196,1 @@\n-    hb_array_t<contour_point_t> rec_points = points.as_array ().sub_array (points.length - get_num_points ());\n+    hb_array_t<contour_point_t> rec_points = points.as_array ().sub_array (points.length - num_points);\n@@ -311,2 +321,2 @@\n-    const HBUINT8  *p = (const HBUINT8 *)  (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n-    const HBUINT16 *q = (const HBUINT16 *) (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n+    const HBUINT8  *p = (const HBUINT8 *)  (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24BIT ? 3 : 2));\n+    const HBUINT16 *q = (const HBUINT16 *) (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24BIT ? 3 : 2));\n@@ -347,0 +357,7 @@\n+  const hb_bytes_t trim_padding () const\n+  {\n+    unsigned length = GlyphHeader::static_size;\n+    for (auto &comp : iter ())\n+      length += comp.get_size ();\n+    return bytes.sub_array (0, length);\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/VarCompositeGlyph.hh","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+  static bool has_valid_glyf_format(const hb_face_t* face)\n+  {\n+    const OT::head &head = *face->table.head;\n+    return head.indexToLocFormat <= 1 && head.glyphDataFormat <= 1;\n+  }\n+\n@@ -75,0 +81,7 @@\n+    if (!has_valid_glyf_format (c->plan->source)) {\n+      \/\/ glyf format is unknown don't attempt to subset it.\n+      DEBUG_MSG (SUBSET, nullptr,\n+                 \"unkown glyf format, dropping from subset.\");\n+      return_trace (false);\n+    }\n+\n@@ -88,0 +101,2 @@\n+    {\n+      hb_font_destroy (font);\n@@ -89,0 +104,1 @@\n+    }\n@@ -92,0 +108,2 @@\n+    {\n+      hb_font_destroy (font);\n@@ -93,0 +111,1 @@\n+    }\n@@ -115,1 +134,1 @@\n-      _free_compiled_subset_glyphs (glyphs, glyphs.length - 1);\n+      _free_compiled_subset_glyphs (glyphs);\n@@ -134,1 +153,1 @@\n-  void _free_compiled_subset_glyphs (hb_vector_t<glyf_impl::SubsetGlyph> &glyphs, unsigned index) const\n+  void _free_compiled_subset_glyphs (hb_vector_t<glyf_impl::SubsetGlyph> &glyphs) const\n@@ -136,1 +155,1 @@\n-    for (unsigned i = 0; i <= index && i < glyphs.length; i++)\n+    for (unsigned i = 0; i < glyphs.length; i++)\n@@ -165,1 +184,1 @@\n-    if (head.indexToLocFormat > 1 || head.glyphDataFormat > 0)\n+    if (!glyf::has_valid_glyf_format (face))\n@@ -225,0 +244,2 @@\n+  public:\n+\n@@ -288,1 +309,0 @@\n-  public:\n@@ -330,0 +350,9 @@\n+  bool get_leading_bearing_without_var_unscaled (hb_codepoint_t gid, bool is_vertical, int *lsb) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return false;\n+    if (is_vertical) return false; \/\/ TODO Humm, what to do here?\n+\n+    *lsb = glyph_for_gid (gid).get_header ()->xMin;\n+    return true;\n+  }\n+\n@@ -408,1 +437,0 @@\n-  unsigned idx = 0;\n@@ -436,2 +464,2 @@\n-        if (!plan->pinned_at_default && idx > 0)\n-          _free_compiled_subset_glyphs (glyphs, idx - 1);\n+        if (!plan->pinned_at_default)\n+          _free_compiled_subset_glyphs (glyphs);\n@@ -440,1 +468,0 @@\n-      idx++;\n@@ -454,0 +481,2 @@\n+  {\n+    hb_font_destroy (font);\n@@ -455,0 +484,1 @@\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf.hh","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-  } first_oncurve, first_offcurve, last_offcurve, last_offcurve2;\n+  } first_oncurve, first_offcurve, first_offcurve2, last_offcurve, last_offcurve2;\n@@ -35,1 +35,1 @@\n-    first_oncurve = first_offcurve = last_offcurve = last_offcurve2 = optional_point_t ();\n+    first_oncurve = first_offcurve = first_offcurve2 = last_offcurve = last_offcurve2 = optional_point_t ();\n@@ -43,1 +43,1 @@\n-     * Cubic support added (incomplete). *\/\n+     * Cubic support added. *\/\n@@ -62,1 +62,6 @@\n-        if (first_offcurve)\n+        if (is_cubic && !first_offcurve2)\n+        {\n+          first_offcurve2 = first_offcurve;\n+          first_offcurve = p;\n+        }\n+        else if (first_offcurve)\n@@ -129,3 +134,10 @@\n-        optional_point_t mid = last_offcurve.lerp (first_offcurve, .5f);\n-        draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n-                                   mid.x, mid.y);\n+        optional_point_t mid = last_offcurve.lerp (first_offcurve2 ?\n+                                                   first_offcurve2 :\n+                                                   first_offcurve, .5f);\n+        if (last_offcurve2)\n+          draw_session->cubic_to (last_offcurve2.x, last_offcurve2.y,\n+                                  last_offcurve.x, last_offcurve.y,\n+                                  mid.x, mid.y);\n+        else\n+          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                     mid.x, mid.y);\n@@ -133,1 +145,0 @@\n-        \/* now check the rest *\/\n@@ -135,0 +146,1 @@\n+      \/* now check the rest *\/\n@@ -137,2 +149,9 @@\n-        draw_session->quadratic_to (first_offcurve.x, first_offcurve.y,\n-                                   first_oncurve.x, first_oncurve.y);\n+      {\n+        if (first_offcurve2)\n+          draw_session->cubic_to (first_offcurve2.x, first_offcurve2.y,\n+                                  first_offcurve.x, first_offcurve.y,\n+                                  first_oncurve.x, first_oncurve.y);\n+        else\n+          draw_session->quadratic_to (first_offcurve.x, first_offcurve.y,\n+                                     first_oncurve.x, first_oncurve.y);\n+      }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/path-builder.hh","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  shopt -s nullglob\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/UPDATING.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -467,1 +467,2 @@\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  \/\/ This does seem like it's ever called.\n+  bool sanitize (hb_sanitize_context_t *c) const\n@@ -495,1 +496,2 @@\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int count \/*XXX Unused?*\/) const\n+  \/\/ This does seem like it's ever called.\n+  bool sanitize (hb_sanitize_context_t *c) const\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -115,1 +114,3 @@\n-    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    (__BYTE_ORDER == __BIG_ENDIAN || \\\n+     (__BYTE_ORDER == __LITTLE_ENDIAN && \\\n+      hb_has_builtin(__builtin_bswap16)))\n@@ -158,1 +159,0 @@\n-    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -160,1 +160,3 @@\n-    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    (__BYTE_ORDER == __BIG_ENDIAN || \\\n+     (__BYTE_ORDER == __LITTLE_ENDIAN && \\\n+      hb_has_builtin(__builtin_bswap32)))\n@@ -601,1 +603,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_popcount)\n@@ -604,0 +606,1 @@\n+#endif\n@@ -605,0 +608,1 @@\n+#if hb_has_builtin(__builtin_popcountl)\n@@ -607,0 +611,1 @@\n+#endif\n@@ -608,0 +613,1 @@\n+#if hb_has_builtin(__builtin_popcountll)\n@@ -644,1 +650,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_clz)\n@@ -647,0 +653,1 @@\n+#endif\n@@ -648,0 +655,1 @@\n+#if hb_has_builtin(__builtin_clzl)\n@@ -650,0 +658,1 @@\n+#endif\n@@ -651,0 +660,1 @@\n+#if hb_has_builtin(__builtin_clzll)\n@@ -718,1 +728,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_ctz)\n@@ -721,0 +731,1 @@\n+#endif\n@@ -722,0 +733,1 @@\n+#if hb_has_builtin(__builtin_ctzl)\n@@ -724,0 +736,1 @@\n+#endif\n@@ -725,0 +738,1 @@\n+#if hb_has_builtin(__builtin_ctzll)\n@@ -878,2 +892,1 @@\n-\/* avoid with xlc16 clang on AIX; it sets the gcc macros *\/\n-#if (defined(__GNUC__) && !defined(AIX) && (__GNUC__ >= 4)) || (defined(__clang__) && (__clang_major__ >= 8))\n+#if hb_has_builtin(__builtin_mul_overflow)\n@@ -1334,0 +1347,58 @@\n+\/* Adapted from kurbo implementation with extra parameters added,\n+ * and finding for a particular range instead of 0.\n+ *\n+ * For documentation and implementation see:\n+ *\n+ * [ITP method]: https:\/\/en.wikipedia.org\/wiki\/ITP_Method\n+ * [An Enhancement of the Bisection Method Average Performance Preserving Minmax Optimality]: https:\/\/dl.acm.org\/doi\/10.1145\/3423597\n+ * https:\/\/docs.rs\/kurbo\/0.8.1\/kurbo\/common\/fn.solve_itp.html\n+ * https:\/\/github.com\/linebender\/kurbo\/blob\/fd839c25ea0c98576c7ce5789305822675a89938\/src\/common.rs#L162-L248\n+ *\/\n+template <typename func_t>\n+double solve_itp (func_t f,\n+                  double a, double b,\n+                  double epsilon,\n+                  double min_y, double max_y,\n+                  double &ya, double &yb, double &y)\n+{\n+  unsigned n1_2 = (unsigned) (hb_max (ceil (log2 ((b - a) \/ epsilon)) - 1.0, 0.0));\n+  const unsigned n0 = 1; \/\/ Hardwired\n+  const double k1 = 0.2 \/ (b - a); \/\/ Hardwired.\n+  unsigned nmax = n0 + n1_2;\n+  double scaled_epsilon = epsilon * double (1llu << nmax);\n+  double _2_epsilon = 2.0 * epsilon;\n+  while (b - a > _2_epsilon)\n+  {\n+    double x1_2 = 0.5 * (a + b);\n+    double r = scaled_epsilon - 0.5 * (b - a);\n+    double xf = (yb * a - ya * b) \/ (yb - ya);\n+    double sigma = x1_2 - xf;\n+    double b_a = b - a;\n+    \/\/ This has k2 = 2 hardwired for efficiency.\n+    double b_a_k2 = b_a * b_a;\n+    double delta = k1 * b_a_k2;\n+    int sigma_sign = sigma >= 0 ? +1 : -1;\n+    double xt = delta <= fabs (x1_2 - xf) ? xf + delta * sigma_sign : x1_2;\n+    double xitp = fabs (xt - x1_2) <= r ? xt : x1_2 - r * sigma_sign;\n+    double yitp = f (xitp);\n+    if (yitp > max_y)\n+    {\n+      b = xitp;\n+      yb = yitp;\n+    }\n+    else if (yitp < min_y)\n+    {\n+      a = xitp;\n+      ya = yitp;\n+    }\n+    else\n+    {\n+      y = yitp;\n+      return xitp;\n+    }\n+    scaled_epsilon *= 0.5;\n+  }\n+  return 0.5 * (a + b);\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-algs.hh","additions":80,"deletions":9,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+\n@@ -89,0 +90,5 @@\n+\n+  public:\n+  auto keys () const HB_AUTO_RETURN (+ forw_map.keys())\n+  auto values () const HB_AUTO_RETURN (+ forw_map.values())\n+  auto iter () const HB_AUTO_RETURN (+ forw_map.iter())\n@@ -111,0 +117,3 @@\n+  hb_codepoint_t skip (unsigned count)\n+  { return next_value += count; }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bimap.hh","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+        if (g != INVALID && (v || page)) \/* The v check is to optimize out the page check if v is true. *\/\n@@ -241,1 +241,1 @@\n-        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+        if (g != INVALID && (v || page)) \/* The v check is to optimize out the page check if v is true. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- *   @HB_MEMORY_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n+ *   @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+ *\n+ * The input buffer is a sequence of Unicode codepoints, with\n+ * associated attributes such as direction and script.  The output\n+ * buffer is a sequence of glyphs, with associated attributes such\n+ * as position and cluster.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.cc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,13 @@\n-\/* Implements a lockfree cache for int->int functions. *\/\n+\/* Implements a lockfree cache for int->int functions.\n+ *\n+ * The cache is a fixed-size array of 16-bit or 32-bit integers.\n+ * The key is split into two parts: the cache index and the rest.\n+ *\n+ * The cache index is used to index into the array.  The rest is used\n+ * to store the key and the value.\n+ *\n+ * The value is stored in the least significant bits of the integer.\n+ * The key is stored in the most significant bits of the integer.\n+ * The key is shifted by cache_bits to the left to make room for the\n+ * value.\n+ *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cache.hh","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -635,0 +635,1 @@\n+    case HB_SCRIPT_TIFINAGH:\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.cc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+#ifdef HB_NO_DRAW\n+#define HB_NO_OUTLINE\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-config.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,0 +376,4 @@\n+#ifndef HB_DEBUG_JUSTIFY\n+#define HB_DEBUG_JUSTIFY (HB_DEBUG+0)\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-debug.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,10 @@\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/4207 *\/\n+\/**\n+ * HB_UNICODE_COMBINING_CLASS_CCC133:\n+ *\n+ * [Tibetan]\n+ *\n+ * Deprecated: 7.2.0\n+ **\/\n+#define HB_UNICODE_COMBINING_CLASS_CCC133 133\n+\n@@ -250,0 +260,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-deprecated.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,0 +50,6 @@\n+ *\n+ * A font face can be created from a binary blob using hb_face_create().\n+ * The face index is used to select a face from a binary blob that contains\n+ * multiple faces.  For example, a binary blob that contains both a regular\n+ * and a bold face can be used to create two font faces, one for each face\n+ * index.\n@@ -200,1 +206,1 @@\n- * and DFont that can contain more than one face.  Face indices within\n+ * DFont that can contain more than one face.  Face indices within\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.cc","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    blob = reference_table_func (\/*XXX*\/const_cast<hb_face_t *> (this), tag, user_data);\n+    blob = reference_table_func (\/*Oh, well.*\/const_cast<hb_face_t *> (this), tag, user_data);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+ *\n+ * The default font functions are implemented in terms of the\n+ * #hb_font_funcs_t methods of the parent font object.  This allows\n+ * client programs to override only the methods they need to, and\n+ * otherwise inherit the parent font's implementation, if any.\n@@ -1390,1 +1395,1 @@\n- * @glyph: : The glyph ID\n+ * @glyph: The glyph ID\n@@ -1412,1 +1417,1 @@\n- * @glyph: : The glyph ID\n+ * @glyph: The glyph ID\n@@ -2652,0 +2657,73 @@\n+\/**\n+ * hb_font_set_variation:\n+ * @font: #hb_font_t to work upon\n+ * @tag: The #hb_tag_t tag of the variation-axis name\n+ * @value: The value of the variation axis\n+ *\n+ * Change the value of one variation axis on the font.\n+ *\n+ * Note: This function is expensive to be called repeatedly.\n+ *   If you want to set multiple variation axes at the same time,\n+ *   use hb_font_set_variations() instead.\n+ *\n+ * Since: 7.1.0\n+ *\/\n+void\n+hb_font_set_variation (hb_font_t *font,\n+                       hb_tag_t tag,\n+                       float    value)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->serial_coords = ++font->serial;\n+\n+  \/\/ TODO Share some of this code with set_variations()\n+\n+  const OT::fvar &fvar = *font->face->table.fvar;\n+  auto axes = fvar.get_axes ();\n+  const unsigned coords_length = axes.length;\n+\n+  int *normalized = coords_length ? (int *) hb_calloc (coords_length, sizeof (int)) : nullptr;\n+  float *design_coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n+\n+  if (unlikely (coords_length && !(normalized && design_coords)))\n+  {\n+    hb_free (normalized);\n+    hb_free (design_coords);\n+    return;\n+  }\n+\n+  \/* Initialize design coords. *\/\n+  if (font->design_coords)\n+  {\n+    assert (coords_length == font->num_coords);\n+    for (unsigned int i = 0; i < coords_length; i++)\n+      design_coords[i] = font->design_coords[i];\n+  }\n+  else\n+  {\n+    for (unsigned int i = 0; i < coords_length; i++)\n+      design_coords[i] = axes[i].get_default ();\n+    if (font->instance_index != HB_FONT_NO_VAR_NAMED_INSTANCE)\n+    {\n+      unsigned count = coords_length;\n+      \/* This may fail if index is out-of-range;\n+       * That's why we initialize design_coords from fvar above\n+       * unconditionally. *\/\n+      hb_ot_var_named_instance_get_design_coords (font->face, font->instance_index,\n+                                                  &count, design_coords);\n+    }\n+  }\n+\n+  for (unsigned axis_index = 0; axis_index < coords_length; axis_index++)\n+    if (axes[axis_index].axisTag == tag)\n+      design_coords[axis_index] = value;\n+\n+  font->face->table.avar->map_coords (normalized, coords_length);\n+\n+  hb_ot_var_normalize_coords (font->face, coords_length, design_coords, normalized);\n+  _hb_font_adopt_var_coords (font, normalized, design_coords, coords_length);\n+\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.cc","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1153,0 +1153,5 @@\n+HB_EXTERN void\n+hb_font_set_variation (hb_font_t *font,\n+                       hb_tag_t tag,\n+                       float    value);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-using hb_ft_advance_cache_t = hb_cache_t<16, 8, 8, false>;\n+using hb_ft_advance_cache_t = hb_cache_t<16, 24, 8, false>;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-  map->keys (*keys);\n+  hb_copy (map->keys() , *keys);\n@@ -418,1 +418,1 @@\n-  map->values (*values);\n+  hb_copy (map->values() , *values);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,10 +320,0 @@\n-  void keys (hb_set_t &keys_) const\n-  {\n-    hb_copy (keys() , keys_);\n-  }\n-\n-  void values (hb_set_t &values_) const\n-  {\n-    hb_copy (values() , values_);\n-  }\n-\n@@ -356,1 +346,2 @@\n-    + keys_ref ()\n+    + iter_items ()\n+    | hb_map (&item_t::key)\n@@ -366,1 +357,2 @@\n-    + values_ref ()\n+    + iter_items ()\n+    | hb_map (&item_t::value)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.hh","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-          if (k < (&last)[distance]) return -1;\n+          if (k < (&last)[distance]\/*first*\/) return -1;\n@@ -416,1 +416,1 @@\n-                                          2,\n+                                          sizeof (CustomRange),\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+HB_OT_CORE_TABLE (OT, cvar)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face-table-list.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-#if !defined(HB_NO_COLOR)\n+#if !defined(HB_NO_COLOR) && !defined(HB_NO_PAINT)\n@@ -636,16 +636,0 @@\n-#ifndef HB_NO_VAR\n-bool\n-_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical,\n-                                             int *lsb)\n-{\n-  return font->face->table.glyf->get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n-}\n-\n-unsigned\n-_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n-{\n-  return font->face->table.glyf->get_advance_with_var_unscaled (font, glyph, is_vertical);\n-}\n-#endif\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-font.cc","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  DEFINE_SIZE_ARRAY (2, widthsZ);\n+  DEFINE_SIZE_UNBOUNDED (2);\n@@ -90,8 +90,0 @@\n-  const DeviceRecord& operator [] (unsigned int i) const\n-  {\n-    \/* XXX Null(DeviceRecord) is NOT safe as it's num-glyphs lengthed.\n-     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1300 *\/\n-    if (unlikely (i >= numRecords)) return Null (DeviceRecord);\n-    return StructAtOffset<DeviceRecord> (&this->firstDeviceRecord, i * sizeDeviceRecord);\n-  }\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hdmx-table.hh","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,1 +66,19 @@\n-    return_trace (serialize (c->serializer));\n+    head *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (c->plan->normalized_coords)\n+    {\n+      if (unlikely (!c->serializer->check_assign (out->xMin, c->plan->head_maxp_info.xMin,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->xMax, c->plan->head_maxp_info.xMax,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->yMin, c->plan->head_maxp_info.yMin,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->yMax, c->plan->head_maxp_info.yMax,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-head-table.hh","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+HB_INTERNAL bool\n+_glyf_get_leading_bearing_without_var_unscaled (hb_face_t *face, hb_codepoint_t gid, bool is_vertical, int *lsb);\n+\n@@ -95,1 +98,1 @@\n-    table->numberOfLongMetrics = num_hmetrics;\n+    c->serializer->check_assign (table->numberOfLongMetrics, num_hmetrics, HB_SERIALIZE_ERROR_INT_OVERFLOW);\n@@ -168,1 +171,1 @@\n-      else\n+      else if (idx < 0x10000u)\n@@ -174,0 +177,7 @@\n+      else\n+      {\n+        \/\/ TODO: This does not do tail optimization.\n+        UFWORD *adv = c->allocate_size<UFWORD> (UFWORD::static_size);\n+        if (unlikely (!adv)) return;\n+        *adv = _.first;\n+      }\n@@ -192,1 +202,1 @@\n-      num_long_metrics = plan->num_output_glyphs ();\n+      num_long_metrics = hb_min (plan->num_output_glyphs (), 0xFFFFu);\n@@ -211,1 +221,2 @@\n-                  (void) _mtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb);\n+                  if (!_mtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb))\n+                    (void) _glyf_get_leading_bearing_without_var_unscaled (c->plan->source, old_gid, !T::is_horizontal, &lsb);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -532,0 +532,3 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  { nameids_to_retain->add (subfamilyNameID); }\n+\n@@ -588,0 +591,3 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  { nameids_to_retain->add (uiNameID); }\n+\n@@ -635,0 +641,14 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (featUILableNameID) nameids_to_retain->add (featUILableNameID);\n+    if (featUITooltipTextNameID) nameids_to_retain->add (featUITooltipTextNameID);\n+    if (sampleTextNameID) nameids_to_retain->add (sampleTextNameID);\n+\n+    if (!firstParamUILabelNameID || !numNamedParameters || numNamedParameters >= 0x7FFF)\n+      return;\n+\n+    unsigned last_name_id = (unsigned) firstParamUILabelNameID + (unsigned) numNamedParameters - 1;\n+    if (last_name_id >= 256 && last_name_id <= 32767)\n+      nameids_to_retain->add_range (firstParamUILabelNameID, last_name_id);\n+  }\n+\n@@ -697,0 +717,13 @@\n+  void collect_name_ids (hb_tag_t tag, hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+#ifdef HB_NO_LAYOUT_FEATURE_PARAMS\n+    return;\n+#endif\n+    if (tag == HB_TAG ('s','i','z','e'))\n+      return (u.size.collect_name_ids (nameids_to_retain));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('s','s','\\0','\\0')) \/* ssXX *\/\n+      return (u.stylisticSet.collect_name_ids (nameids_to_retain));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('c','v','\\0','\\0')) \/* cvXX *\/\n+      return (u.characterVariants.collect_name_ids (nameids_to_retain));\n+  }\n+\n@@ -765,0 +798,6 @@\n+  void collect_name_ids (hb_tag_t tag, hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (featureParams)\n+      get_feature_params ().collect_name_ids (tag, nameids_to_retain);\n+  }\n+\n@@ -2236,1 +2275,5 @@\n-    int start = startCoord.to_int (), peak = peakCoord.to_int (), end = endCoord.to_int ();\n+    int peak = peakCoord.to_int ();\n+    if (peak == 0 || coord == peak)\n+      return 1.f;\n+\n+    int start = startCoord.to_int (), end = endCoord.to_int ();\n@@ -2240,1 +2283,1 @@\n-      return 1.;\n+      return 1.f;\n@@ -2242,4 +2285,1 @@\n-      return 1.;\n-\n-    if (peak == 0 || coord == peak)\n-      return 1.;\n+      return 1.f;\n@@ -2248,1 +2288,1 @@\n-      return 0.;\n+      return 0.f;\n@@ -2465,1 +2505,1 @@\n-        for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n+        for (unsigned old_gid : inner_map.keys())\n@@ -2467,2 +2507,1 @@\n-          unsigned int old = inner_map.backward (i);\n-          int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n+          int32_t delta = src->get_item_delta_fast (old_gid, r, src_delta_bytes, src_row_size);\n@@ -2485,1 +2524,1 @@\n-      for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n+      for (unsigned old_gid : inner_map.keys())\n@@ -2487,2 +2526,1 @@\n-        unsigned int old = inner_map.backward (i);\n-        int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n+        int32_t delta = src->get_item_delta_fast (old_gid, r, src_delta_bytes, src_row_size);\n@@ -2549,2 +2587,2 @@\n-      for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n-        if (get_item_delta_fast (inner_map.backward (i), r, delta_bytes, row_size) != 0)\n+      for (hb_codepoint_t old_gid : inner_map.keys())\n+        if (get_item_delta_fast (old_gid, r, delta_bytes, row_size) != 0)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -490,1 +490,2 @@\n-      matcher.set_per_syllable (c->per_syllable);\n+      \/* Per syllable matching is only for GSUB. *\/\n+      matcher.set_per_syllable (c->table_index == 0 && c->per_syllable);\n@@ -4464,0 +4465,12 @@\n+  void collect_name_ids (const hb_map_t *feature_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    unsigned count = get_feature_count ();\n+    for (unsigned i = 0 ; i < count; i++)\n+    {\n+      if (!feature_index_map->has (i)) continue;\n+      hb_tag_t tag = get_feature_tag (i);\n+      get_feature (i).collect_name_ids (tag, nameids_to_retain);\n+    }\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+ * See the <ulink url=\"http:\/\/www.microsoft.com\/typography\/otspec\/\">OpenType\n+ * specification<\/ulink> for details.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.cc","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    maxp_prime->numGlyphs = c->plan->num_output_glyphs ();\n+    maxp_prime->numGlyphs = hb_min (c->plan->num_output_glyphs (), 0xFFFFu);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-maxp-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-#include \"hb-ot-name-language-static.hh\"\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.cc","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;\n+    if (!serialize (c->serializer, glyph_names))\n+      return_trace (false);\n+\n@@ -113,4 +117,0 @@\n-    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;\n-    if (!serialize (c->serializer, glyph_names))\n-      return_trace (false);\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1070,1 +1070,2 @@\n-              info[base].indic_position() = POS_BASE_C;\n+              if (base < end)\n+                info[base].indic_position() = POS_BASE_C;\n@@ -1076,0 +1077,2 @@\n+        if (base == end)\n+          break;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.cc","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -539,0 +539,2 @@\n+\n+    nameids_to_retain->add (elidedFallbackNameID);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-stat-table.hh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,2 +225,2 @@\n-  VarStoreInstancer (const VariationStore &varStore,\n-                     const DeltaSetIndexMap &varIdxMap,\n+  VarStoreInstancer (const VariationStore *varStore,\n+                     const DeltaSetIndexMap *varIdxMap,\n@@ -230,1 +230,1 @@\n-  operator bool () const { return bool (coords); }\n+  operator bool () const { return varStore && bool (coords); }\n@@ -232,0 +232,2 @@\n+  \/* according to the spec, if colr table has varStore but does not have\n+   * varIdxMap, then an implicit identity mapping is used *\/\n@@ -233,1 +235,1 @@\n-  { return varStore.get_delta (varIdxMap.map (VarIdx::add (varIdx, offset)), coords); }\n+  { return varStore->get_delta (varIdxMap ? varIdxMap->map (VarIdx::add (varIdx, offset)) : varIdx + offset, coords); }\n@@ -235,2 +237,2 @@\n-  const VariationStore &varStore;\n-  const DeltaSetIndexMap &varIdxMap;\n+  const VariationStore *varStore;\n+  const DeltaSetIndexMap *varIdxMap;\n@@ -240,0 +242,348 @@\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#tuplevariationheader *\/\n+struct TupleVariationHeader\n+{\n+  unsigned get_size (unsigned axis_count) const\n+  { return min_size + get_all_tuples (axis_count).get_size (); }\n+\n+  unsigned get_data_size () const { return varDataSize; }\n+\n+  const TupleVariationHeader &get_next (unsigned axis_count) const\n+  { return StructAtOffset<TupleVariationHeader> (this, get_size (axis_count)); }\n+\n+  float calculate_scalar (hb_array_t<int> coords, unsigned int coord_count,\n+                          const hb_array_t<const F2DOT14> shared_tuples,\n+                          const hb_vector_t<int> *shared_tuple_active_idx = nullptr) const\n+  {\n+    const F2DOT14 *peak_tuple;\n+\n+    unsigned start_idx = 0;\n+    unsigned end_idx = coord_count;\n+\n+    if (has_peak ())\n+      peak_tuple = get_peak_tuple (coord_count).arrayZ;\n+    else\n+    {\n+      unsigned int index = get_index ();\n+      if (unlikely ((index + 1) * coord_count > shared_tuples.length))\n+        return 0.f;\n+      peak_tuple = shared_tuples.sub_array (coord_count * index, coord_count).arrayZ;\n+\n+      if (shared_tuple_active_idx)\n+      {\n+        assert (index < shared_tuple_active_idx->length);\n+        int v = (*shared_tuple_active_idx).arrayZ[index];\n+        if (v != -1)\n+        {\n+          start_idx = v;\n+          end_idx = start_idx + 1;\n+        }\n+      }\n+    }\n+\n+    const F2DOT14 *start_tuple = nullptr;\n+    const F2DOT14 *end_tuple = nullptr;\n+    bool has_interm = has_intermediate ();\n+    if (has_interm)\n+    {\n+      start_tuple = get_start_tuple (coord_count).arrayZ;\n+      end_tuple = get_end_tuple (coord_count).arrayZ;\n+    }\n+\n+    float scalar = 1.f;\n+    for (unsigned int i = start_idx; i < end_idx; i++)\n+    {\n+      int peak = peak_tuple[i].to_int ();\n+      if (!peak) continue;\n+\n+      int v = coords[i];\n+      if (v == peak) continue;\n+\n+      if (has_interm)\n+      {\n+        int start = start_tuple[i].to_int ();\n+        int end = end_tuple[i].to_int ();\n+        if (unlikely (start > peak || peak > end ||\n+                      (start < 0 && end > 0 && peak))) continue;\n+        if (v < start || v > end) return 0.f;\n+        if (v < peak)\n+        { if (peak != start) scalar *= (float) (v - start) \/ (peak - start); }\n+        else\n+        { if (peak != end) scalar *= (float) (end - v) \/ (end - peak); }\n+      }\n+      else if (!v || v < hb_min (0, peak) || v > hb_max (0, peak)) return 0.f;\n+      else\n+        scalar *= (float) v \/ peak;\n+    }\n+    return scalar;\n+  }\n+\n+  bool           has_peak () const { return tupleIndex & TuppleIndex::EmbeddedPeakTuple; }\n+  bool   has_intermediate () const { return tupleIndex & TuppleIndex::IntermediateRegion; }\n+  bool has_private_points () const { return tupleIndex & TuppleIndex::PrivatePointNumbers; }\n+  unsigned      get_index () const { return tupleIndex & TuppleIndex::TupleIndexMask; }\n+\n+  protected:\n+  struct TuppleIndex : HBUINT16\n+  {\n+    enum Flags {\n+      EmbeddedPeakTuple   = 0x8000u,\n+      IntermediateRegion  = 0x4000u,\n+      PrivatePointNumbers = 0x2000u,\n+      TupleIndexMask      = 0x0FFFu\n+    };\n+\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  hb_array_t<const F2DOT14> get_all_tuples (unsigned axis_count) const\n+  { return StructAfter<UnsizedArrayOf<F2DOT14>> (tupleIndex).as_array ((has_peak () + has_intermediate () * 2) * axis_count); }\n+  hb_array_t<const F2DOT14> get_peak_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (0, axis_count); }\n+  hb_array_t<const F2DOT14> get_start_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count, axis_count); }\n+  hb_array_t<const F2DOT14> get_end_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count + axis_count, axis_count); }\n+\n+  HBUINT16      varDataSize;    \/* The size in bytes of the serialized\n+                                 * data for this tuple variation table. *\/\n+  TuppleIndex   tupleIndex;     \/* A packed field. The high 4 bits are flags (see below).\n+                                   The low 12 bits are an index into a shared tuple\n+                                   records array. *\/\n+  \/* UnsizedArrayOf<F2DOT14> peakTuple - optional *\/\n+                                \/* Peak tuple record for this tuple variation table  optional,\n+                                 * determined by flags in the tupleIndex value.\n+                                 *\n+                                 * Note that this must always be included in the 'cvar' table. *\/\n+  \/* UnsizedArrayOf<F2DOT14> intermediateStartTuple - optional *\/\n+                                \/* Intermediate start tuple record for this tuple variation table  optional,\n+                                   determined by flags in the tupleIndex value. *\/\n+  \/* UnsizedArrayOf<F2DOT14> intermediateEndTuple - optional *\/\n+                                \/* Intermediate end tuple record for this tuple variation table  optional,\n+                                 * determined by flags in the tupleIndex value. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n+\n+struct TupleVariationData\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/\/ here check on min_size only, TupleVariationHeader and var data will be\n+    \/\/ checked while accessing through iterator.\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  unsigned get_size (unsigned axis_count) const\n+  {\n+    unsigned total_size = min_size;\n+    unsigned count = tupleVarCount;\n+    const TupleVariationHeader *tuple_var_header = &(get_tuple_var_header());\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      total_size += tuple_var_header->get_size (axis_count) + tuple_var_header->get_data_size ();\n+      tuple_var_header = &tuple_var_header->get_next (axis_count);\n+    }\n+\n+    return total_size;\n+  }\n+\n+  const TupleVariationHeader &get_tuple_var_header (void) const\n+  { return StructAfter<TupleVariationHeader> (data); }\n+\n+  struct tuple_iterator_t\n+  {\n+    void init (hb_bytes_t var_data_bytes_, unsigned int axis_count_, const void *table_base_)\n+    {\n+      var_data_bytes = var_data_bytes_;\n+      var_data = var_data_bytes_.as<TupleVariationData> ();\n+      index = 0;\n+      axis_count = axis_count_;\n+      current_tuple = &var_data->get_tuple_var_header ();\n+      data_offset = 0;\n+      table_base = table_base_;\n+    }\n+\n+    bool get_shared_indices (hb_vector_t<unsigned int> &shared_indices \/* OUT *\/)\n+    {\n+      if (var_data->has_shared_point_numbers ())\n+      {\n+        const HBUINT8 *base = &(table_base+var_data->data);\n+        const HBUINT8 *p = base;\n+        if (!unpack_points (p, shared_indices, (const HBUINT8 *) (var_data_bytes.arrayZ + var_data_bytes.length))) return false;\n+        data_offset = p - base;\n+      }\n+      return true;\n+    }\n+\n+    bool is_valid () const\n+    {\n+      return (index < var_data->tupleVarCount.get_count ()) &&\n+             var_data_bytes.check_range (current_tuple, TupleVariationHeader::min_size) &&\n+             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (),\n+                                                                current_tuple->get_size (axis_count)));\n+    }\n+\n+    bool move_to_next ()\n+    {\n+      data_offset += current_tuple->get_data_size ();\n+      current_tuple = &current_tuple->get_next (axis_count);\n+      index++;\n+      return is_valid ();\n+    }\n+\n+    const HBUINT8 *get_serialized_data () const\n+    { return &(table_base+var_data->data) + data_offset; }\n+\n+    private:\n+    const TupleVariationData *var_data;\n+    unsigned int index;\n+    unsigned int axis_count;\n+    unsigned int data_offset;\n+    const void *table_base;\n+\n+    public:\n+    hb_bytes_t var_data_bytes;\n+    const TupleVariationHeader *current_tuple;\n+  };\n+\n+  static bool get_tuple_iterator (hb_bytes_t var_data_bytes, unsigned axis_count,\n+                                  const void *table_base,\n+                                  hb_vector_t<unsigned int> &shared_indices \/* OUT *\/,\n+                                  tuple_iterator_t *iterator \/* OUT *\/)\n+  {\n+    iterator->init (var_data_bytes, axis_count, table_base);\n+    if (!iterator->get_shared_indices (shared_indices))\n+      return false;\n+    return iterator->is_valid ();\n+  }\n+\n+  bool has_shared_point_numbers () const { return tupleVarCount.has_shared_point_numbers (); }\n+\n+  static bool unpack_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                             hb_vector_t<unsigned int> &points \/* OUT *\/,\n+                             const HBUINT8 *end)\n+  {\n+    enum packed_point_flag_t\n+    {\n+      POINTS_ARE_WORDS     = 0x80,\n+      POINT_RUN_COUNT_MASK = 0x7F\n+    };\n+\n+    if (unlikely (p + 1 > end)) return false;\n+\n+    unsigned count = *p++;\n+    if (count & POINTS_ARE_WORDS)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      count = ((count & POINT_RUN_COUNT_MASK) << 8) | *p++;\n+    }\n+    if (unlikely (!points.resize (count, false))) return false;\n+\n+    unsigned n = 0;\n+    unsigned i = 0;\n+    while (i < count)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n+      unsigned stop = i + run_count;\n+      if (unlikely (stop > count)) return false;\n+      if (control & POINTS_ARE_WORDS)\n+      {\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          n += *(const HBUINT16 *)p;\n+          points.arrayZ[i] = n;\n+          p += HBUINT16::static_size;\n+        }\n+      }\n+      else\n+      {\n+        if (unlikely (p + run_count > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          n += *p++;\n+          points.arrayZ[i] = n;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static bool unpack_deltas (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                             hb_vector_t<int> &deltas \/* IN\/OUT *\/,\n+                             const HBUINT8 *end)\n+  {\n+    enum packed_delta_flag_t\n+    {\n+      DELTAS_ARE_ZERO      = 0x80,\n+      DELTAS_ARE_WORDS     = 0x40,\n+      DELTA_RUN_COUNT_MASK = 0x3F\n+    };\n+\n+    unsigned i = 0;\n+    unsigned count = deltas.length;\n+    while (i < count)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n+      unsigned stop = i + run_count;\n+      if (unlikely (stop > count)) return false;\n+      if (control & DELTAS_ARE_ZERO)\n+      {\n+        for (; i < stop; i++)\n+          deltas.arrayZ[i] = 0;\n+      }\n+      else if (control & DELTAS_ARE_WORDS)\n+      {\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          deltas.arrayZ[i] = * (const HBINT16 *) p;\n+          p += HBUINT16::static_size;\n+        }\n+      }\n+      else\n+      {\n+        if (unlikely (p + run_count > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          deltas.arrayZ[i] = * (const HBINT8 *) p++;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  bool has_data () const { return tupleVarCount; }\n+\n+  protected:\n+  struct TupleVarCount : HBUINT16\n+  {\n+    bool has_shared_point_numbers () const { return ((*this) & SharedPointNumbers); }\n+    unsigned int get_count () const { return (*this) & CountMask; }\n+\n+    protected:\n+    enum Flags\n+    {\n+      SharedPointNumbers= 0x8000u,\n+      CountMask         = 0x0FFFu\n+    };\n+    public:\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  TupleVarCount tupleVarCount;  \/* A packed field. The high 4 bits are flags, and the\n+                                 * low 12 bits are the number of tuple variation tables\n+                                 * for this glyph. The number of tuple variation tables\n+                                 * can be any number between 1 and 4095. *\/\n+  Offset16To<HBUINT8>\n+                data;           \/* Offset from the start of the base table\n+                                 * to the serialized data. *\/\n+  \/* TupleVariationHeader tupleVariationHeaders[] *\/\/* Array of tuple variation headers. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-common.hh","additions":356,"deletions":6,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright  2023  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_OT_VAR_CVAR_TABLE_HH\n+#define HB_OT_VAR_CVAR_TABLE_HH\n+\n+#include \"hb-ot-var-common.hh\"\n+\n+\n+namespace OT {\n+\/*\n+ * cvar -- control value table (CVT) Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cvar\n+ *\/\n+#define HB_OT_TAG_cvar HB_TAG('c','v','a','r')\n+\n+struct cvar\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_cvar;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  version.sanitize (c) && likely (version.major == 1) &&\n+                  tupleVariationData.sanitize (c));\n+  }\n+\n+  const TupleVariationData* get_tuple_var_data (void) const\n+  { return &tupleVariationData; }\n+\n+  static bool calculate_cvt_deltas (unsigned axis_count,\n+                                    hb_array_t<int> coords,\n+                                    unsigned num_cvt_item,\n+                                    const TupleVariationData *tuple_var_data,\n+                                    const void *base,\n+                                    hb_vector_t<float>& cvt_deltas \/* OUT *\/)\n+  {\n+    if (!coords) return true;\n+    hb_vector_t<unsigned> shared_indices;\n+    TupleVariationData::tuple_iterator_t iterator;\n+    unsigned var_data_length = tuple_var_data->get_size (axis_count);\n+    hb_bytes_t var_data_bytes = hb_bytes_t (reinterpret_cast<const char*> (tuple_var_data), var_data_length);\n+    if (!TupleVariationData::get_tuple_iterator (var_data_bytes, axis_count, base,\n+                                                 shared_indices, &iterator))\n+      return true; \/* isn't applied at all *\/\n+\n+    hb_array_t<const F2DOT14> shared_tuples = hb_array<F2DOT14> ();\n+    hb_vector_t<unsigned> private_indices;\n+    hb_vector_t<int> unpacked_deltas;\n+\n+    do\n+    {\n+      float scalar = iterator.current_tuple->calculate_scalar (coords, axis_count, shared_tuples);\n+      if (scalar == 0.f) continue;\n+      const HBUINT8 *p = iterator.get_serialized_data ();\n+      unsigned int length = iterator.current_tuple->get_data_size ();\n+      if (unlikely (!iterator.var_data_bytes.check_range (p, length)))\n+        return false;\n+\n+      const HBUINT8 *end = p + length;\n+\n+      bool has_private_points = iterator.current_tuple->has_private_points ();\n+      if (has_private_points &&\n+          !TupleVariationData::unpack_points (p, private_indices, end))\n+        return false;\n+      const hb_vector_t<unsigned int> &indices = has_private_points ? private_indices : shared_indices;\n+\n+      bool apply_to_all = (indices.length == 0);\n+      unsigned num_deltas = apply_to_all ? num_cvt_item : indices.length;\n+      if (unlikely (!unpacked_deltas.resize (num_deltas, false))) return false;\n+      if (unlikely (!TupleVariationData::unpack_deltas (p, unpacked_deltas, end))) return false;\n+\n+      for (unsigned int i = 0; i < num_deltas; i++)\n+      {\n+        unsigned int idx = apply_to_all ? i : indices[i];\n+        if (unlikely (idx >= num_cvt_item)) continue;\n+        if (scalar != 1.0f) cvt_deltas[idx] += unpacked_deltas[i] * scalar ;\n+        else cvt_deltas[idx] += unpacked_deltas[i];\n+      }\n+    } while (iterator.move_to_next ());\n+\n+    return true;\n+  }\n+\n+  static bool add_cvt_and_apply_deltas (hb_subset_plan_t *plan,\n+                                        const TupleVariationData *tuple_var_data,\n+                                        const void *base)\n+  {\n+    const hb_tag_t cvt = HB_TAG('c','v','t',' ');\n+    hb_blob_t *cvt_blob = hb_face_reference_table (plan->source, cvt);\n+    hb_blob_t *cvt_prime_blob = hb_blob_copy_writable_or_fail (cvt_blob);\n+    hb_blob_destroy (cvt_blob);\n+\n+    if (unlikely (!cvt_prime_blob))\n+      return false;\n+\n+    unsigned cvt_blob_length = hb_blob_get_length (cvt_prime_blob);\n+    unsigned num_cvt_item = cvt_blob_length \/ FWORD::static_size;\n+\n+    hb_vector_t<float> cvt_deltas;\n+    if (unlikely (!cvt_deltas.resize (num_cvt_item)))\n+    {\n+      hb_blob_destroy (cvt_prime_blob);\n+      return false;\n+    }\n+    hb_memset (cvt_deltas.arrayZ, 0, cvt_deltas.get_size ());\n+\n+    if (!calculate_cvt_deltas (plan->normalized_coords.length, plan->normalized_coords.as_array (),\n+                               num_cvt_item, tuple_var_data, base, cvt_deltas))\n+    {\n+      hb_blob_destroy (cvt_prime_blob);\n+      return false;\n+    }\n+\n+    FWORD *cvt_prime = (FWORD *) hb_blob_get_data_writable (cvt_prime_blob, nullptr);\n+    for (unsigned i = 0; i < num_cvt_item; i++)\n+      cvt_prime[i] += (int) roundf (cvt_deltas[i]);\n+\n+    bool success = plan->add_table (cvt, cvt_prime_blob);\n+    hb_blob_destroy (cvt_prime_blob);\n+    return success;\n+  }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the CVT variation table\n+                                         * initially set to 0x00010000u *\/\n+  TupleVariationData tupleVariationData; \/* TupleVariationDate for cvar table *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_CVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-cvar-table.hh","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hb-ot-var-common.hh\"\n@@ -93,305 +94,2 @@\n-\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#tuplevariationheader *\/\n-struct TupleVariationHeader\n-{\n-  unsigned get_size (unsigned axis_count) const\n-  { return min_size + get_all_tuples (axis_count).get_size (); }\n-\n-  unsigned get_data_size () const { return varDataSize; }\n-\n-  const TupleVariationHeader &get_next (unsigned axis_count) const\n-  { return StructAtOffset<TupleVariationHeader> (this, get_size (axis_count)); }\n-\n-  float calculate_scalar (hb_array_t<int> coords, unsigned int coord_count,\n-                          const hb_array_t<const F2DOT14> shared_tuples) const\n-  {\n-    hb_array_t<const F2DOT14> peak_tuple;\n-\n-    if (has_peak ())\n-      peak_tuple = get_peak_tuple (coord_count);\n-    else\n-    {\n-      unsigned int index = get_index ();\n-      if (unlikely (index * coord_count >= shared_tuples.length))\n-        return 0.f;\n-      peak_tuple = shared_tuples.sub_array (coord_count * index, coord_count);\n-    }\n-\n-    hb_array_t<const F2DOT14> start_tuple;\n-    hb_array_t<const F2DOT14> end_tuple;\n-    if (has_intermediate ())\n-    {\n-      start_tuple = get_start_tuple (coord_count);\n-      end_tuple = get_end_tuple (coord_count);\n-    }\n-\n-    float scalar = 1.f;\n-    for (unsigned int i = 0; i < coord_count; i++)\n-    {\n-      int v = coords[i];\n-      int peak = peak_tuple[i].to_int ();\n-      if (!peak || v == peak) continue;\n-\n-      if (has_intermediate ())\n-      {\n-        int start = start_tuple[i].to_int ();\n-        int end = end_tuple[i].to_int ();\n-        if (unlikely (start > peak || peak > end ||\n-                      (start < 0 && end > 0 && peak))) continue;\n-        if (v < start || v > end) return 0.f;\n-        if (v < peak)\n-        { if (peak != start) scalar *= (float) (v - start) \/ (peak - start); }\n-        else\n-        { if (peak != end) scalar *= (float) (end - v) \/ (end - peak); }\n-      }\n-      else if (!v || v < hb_min (0, peak) || v > hb_max (0, peak)) return 0.f;\n-      else\n-        scalar *= (float) v \/ peak;\n-    }\n-    return scalar;\n-  }\n-\n-  bool           has_peak () const { return tupleIndex & TuppleIndex::EmbeddedPeakTuple; }\n-  bool   has_intermediate () const { return tupleIndex & TuppleIndex::IntermediateRegion; }\n-  bool has_private_points () const { return tupleIndex & TuppleIndex::PrivatePointNumbers; }\n-  unsigned      get_index () const { return tupleIndex & TuppleIndex::TupleIndexMask; }\n-\n-  protected:\n-  struct TuppleIndex : HBUINT16\n-  {\n-    enum Flags {\n-      EmbeddedPeakTuple   = 0x8000u,\n-      IntermediateRegion  = 0x4000u,\n-      PrivatePointNumbers = 0x2000u,\n-      TupleIndexMask      = 0x0FFFu\n-    };\n-\n-    DEFINE_SIZE_STATIC (2);\n-  };\n-\n-  hb_array_t<const F2DOT14> get_all_tuples (unsigned axis_count) const\n-  { return StructAfter<UnsizedArrayOf<F2DOT14>> (tupleIndex).as_array ((has_peak () + has_intermediate () * 2) * axis_count); }\n-  hb_array_t<const F2DOT14> get_peak_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (0, axis_count); }\n-  hb_array_t<const F2DOT14> get_start_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count, axis_count); }\n-  hb_array_t<const F2DOT14> get_end_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count + axis_count, axis_count); }\n-\n-  HBUINT16      varDataSize;    \/* The size in bytes of the serialized\n-                                 * data for this tuple variation table. *\/\n-  TuppleIndex   tupleIndex;     \/* A packed field. The high 4 bits are flags (see below).\n-                                   The low 12 bits are an index into a shared tuple\n-                                   records array. *\/\n-  \/* UnsizedArrayOf<F2DOT14> peakTuple - optional *\/\n-                                \/* Peak tuple record for this tuple variation table  optional,\n-                                 * determined by flags in the tupleIndex value.\n-                                 *\n-                                 * Note that this must always be included in the 'cvar' table. *\/\n-  \/* UnsizedArrayOf<F2DOT14> intermediateStartTuple - optional *\/\n-                                \/* Intermediate start tuple record for this tuple variation table  optional,\n-                                   determined by flags in the tupleIndex value. *\/\n-  \/* UnsizedArrayOf<F2DOT14> intermediateEndTuple - optional *\/\n-                                \/* Intermediate end tuple record for this tuple variation table  optional,\n-                                 * determined by flags in the tupleIndex value. *\/\n-  public:\n-  DEFINE_SIZE_MIN (4);\n-};\n-\n-struct GlyphVariationData\n-{\n-  const TupleVariationHeader &get_tuple_var_header (void) const\n-  { return StructAfter<TupleVariationHeader> (data); }\n-\n-  struct tuple_iterator_t\n-  {\n-    void init (hb_bytes_t var_data_bytes_, unsigned int axis_count_)\n-    {\n-      var_data_bytes = var_data_bytes_;\n-      var_data = var_data_bytes_.as<GlyphVariationData> ();\n-      index = 0;\n-      axis_count = axis_count_;\n-      current_tuple = &var_data->get_tuple_var_header ();\n-      data_offset = 0;\n-    }\n-\n-    bool get_shared_indices (hb_vector_t<unsigned int> &shared_indices \/* OUT *\/)\n-    {\n-      if (var_data->has_shared_point_numbers ())\n-      {\n-        const HBUINT8 *base = &(var_data+var_data->data);\n-        const HBUINT8 *p = base;\n-        if (!unpack_points (p, shared_indices, (const HBUINT8 *) (var_data_bytes.arrayZ + var_data_bytes.length))) return false;\n-        data_offset = p - base;\n-      }\n-      return true;\n-    }\n-\n-    bool is_valid () const\n-    {\n-      return (index < var_data->tupleVarCount.get_count ()) &&\n-             var_data_bytes.check_range (current_tuple, TupleVariationHeader::min_size) &&\n-             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (),\n-                                                                current_tuple->get_size (axis_count)));\n-    }\n-\n-    bool move_to_next ()\n-    {\n-      data_offset += current_tuple->get_data_size ();\n-      current_tuple = &current_tuple->get_next (axis_count);\n-      index++;\n-      return is_valid ();\n-    }\n-\n-    const HBUINT8 *get_serialized_data () const\n-    { return &(var_data+var_data->data) + data_offset; }\n-\n-    private:\n-    const GlyphVariationData *var_data;\n-    unsigned int index;\n-    unsigned int axis_count;\n-    unsigned int data_offset;\n-\n-    public:\n-    hb_bytes_t var_data_bytes;\n-    const TupleVariationHeader *current_tuple;\n-  };\n-\n-  static bool get_tuple_iterator (hb_bytes_t var_data_bytes, unsigned axis_count,\n-                                  hb_vector_t<unsigned int> &shared_indices \/* OUT *\/,\n-                                  tuple_iterator_t *iterator \/* OUT *\/)\n-  {\n-    iterator->init (var_data_bytes, axis_count);\n-    if (!iterator->get_shared_indices (shared_indices))\n-      return false;\n-    return iterator->is_valid ();\n-  }\n-\n-  bool has_shared_point_numbers () const { return tupleVarCount.has_shared_point_numbers (); }\n-\n-  static bool unpack_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n-                             hb_vector_t<unsigned int> &points \/* OUT *\/,\n-                             const HBUINT8 *end)\n-  {\n-    enum packed_point_flag_t\n-    {\n-      POINTS_ARE_WORDS     = 0x80,\n-      POINT_RUN_COUNT_MASK = 0x7F\n-    };\n-\n-    if (unlikely (p + 1 > end)) return false;\n-\n-    unsigned count = *p++;\n-    if (count & POINTS_ARE_WORDS)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      count = ((count & POINT_RUN_COUNT_MASK) << 8) | *p++;\n-    }\n-    if (unlikely (!points.resize (count, false))) return false;\n-\n-    unsigned n = 0;\n-    unsigned i = 0;\n-    while (i < count)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      unsigned control = *p++;\n-      unsigned run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n-      if (unlikely (i + run_count > count)) return false;\n-      unsigned j;\n-      if (control & POINTS_ARE_WORDS)\n-      {\n-        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          n += *(const HBUINT16 *)p;\n-          points.arrayZ[i] = n;\n-          p += HBUINT16::static_size;\n-        }\n-      }\n-      else\n-      {\n-        if (unlikely (p + run_count > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          n += *p++;\n-          points.arrayZ[i] = n;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  static bool unpack_deltas (const HBUINT8 *&p \/* IN\/OUT *\/,\n-                             hb_vector_t<int> &deltas \/* IN\/OUT *\/,\n-                             const HBUINT8 *end)\n-  {\n-    enum packed_delta_flag_t\n-    {\n-      DELTAS_ARE_ZERO      = 0x80,\n-      DELTAS_ARE_WORDS     = 0x40,\n-      DELTA_RUN_COUNT_MASK = 0x3F\n-    };\n-\n-    unsigned i = 0;\n-    unsigned count = deltas.length;\n-    while (i < count)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      unsigned control = *p++;\n-      unsigned run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n-      if (unlikely (i + run_count > count)) return false;\n-      unsigned j;\n-      if (control & DELTAS_ARE_ZERO)\n-      {\n-        for (j = 0; j < run_count; j++, i++)\n-          deltas.arrayZ[i] = 0;\n-      }\n-      else if (control & DELTAS_ARE_WORDS)\n-      {\n-        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          deltas.arrayZ[i] = * (const HBINT16 *) p;\n-          p += HBUINT16::static_size;\n-        }\n-      }\n-      else\n-      {\n-        if (unlikely (p + run_count > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          deltas.arrayZ[i] = * (const HBINT8 *) p++;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool has_data () const { return tupleVarCount; }\n-\n-  protected:\n-  struct TupleVarCount : HBUINT16\n-  {\n-    bool has_shared_point_numbers () const { return ((*this) & SharedPointNumbers); }\n-    unsigned int get_count () const { return (*this) & CountMask; }\n-\n-    protected:\n-    enum Flags\n-    {\n-      SharedPointNumbers= 0x8000u,\n-      CountMask         = 0x0FFFu\n-    };\n-    public:\n-    DEFINE_SIZE_STATIC (2);\n-  };\n-\n-  TupleVarCount tupleVarCount;  \/* A packed field. The high 4 bits are flags, and the\n-                                 * low 12 bits are the number of tuple variation tables\n-                                 * for this glyph. The number of tuple variation tables\n-                                 * can be any number between 1 and 4095. *\/\n-  Offset16To<HBUINT8>\n-                data;           \/* Offset from the start of the GlyphVariationData table\n-                                 * to the serialized data. *\/\n-  \/* TupleVariationHeader tupleVariationHeaders[] *\/\/* Array of tuple variation headers. *\/\n-  public:\n-  DEFINE_SIZE_MIN (4);\n-};\n+struct GlyphVariationData : TupleVariationData\n+{};\n@@ -409,2 +107,2 @@\n-                     c->check_array (get_long_offset_array (), glyphCount+1) :\n-                     c->check_array (get_short_offset_array (), glyphCount+1)));\n+                     c->check_array (get_long_offset_array (), c->get_num_glyphs () + 1) :\n+                     c->check_array (get_short_offset_array (), c->get_num_glyphs () + 1)));\n@@ -421,0 +119,2 @@\n+    unsigned glyph_count = version.to_int () ? c->plan->source->get_num_glyphs () : 0;\n+\n@@ -430,1 +130,1 @@\n-    out->glyphCount = num_glyphs;\n+    out->glyphCountX = hb_min (0xFFFFu, num_glyphs);\n@@ -439,1 +139,1 @@\n-      subset_data_size += get_glyph_var_data_bytes (c->source_blob, old_gid).length;\n+      subset_data_size += get_glyph_var_data_bytes (c->source_blob, glyph_count, old_gid).length;\n@@ -471,1 +171,3 @@\n-                                ? get_glyph_var_data_bytes (c->source_blob, old_gid)\n+                                ? get_glyph_var_data_bytes (c->source_blob,\n+                                                            glyph_count,\n+                                                            old_gid)\n@@ -493,1 +195,3 @@\n-  const hb_bytes_t get_glyph_var_data_bytes (hb_blob_t *blob, hb_codepoint_t glyph) const\n+  const hb_bytes_t get_glyph_var_data_bytes (hb_blob_t *blob,\n+                                             unsigned glyph_count,\n+                                             hb_codepoint_t glyph) const\n@@ -495,2 +199,2 @@\n-    unsigned start_offset = get_offset (glyph);\n-    unsigned end_offset = get_offset (glyph+1);\n+    unsigned start_offset = get_offset (glyph_count, glyph);\n+    unsigned end_offset = get_offset (glyph_count, glyph+1);\n@@ -505,1 +209,1 @@\n-  unsigned get_offset (unsigned i) const\n+  unsigned get_offset (unsigned glyph_count, unsigned i) const\n@@ -507,1 +211,1 @@\n-    if (unlikely (i > glyphCount)) return 0;\n+    if (unlikely (i > glyph_count)) return 0;\n@@ -519,1 +223,32 @@\n-    { table = hb_sanitize_context_t ().reference_table<gvar> (face); }\n+    {\n+      table = hb_sanitize_context_t ().reference_table<gvar> (face);\n+      \/* If sanitize failed, set glyphCount to 0. *\/\n+      glyphCount = table->version.to_int () ? face->get_num_glyphs () : 0;\n+\n+      \/* For shared tuples that only have one axis active, shared the index of\n+       * that axis as a cache. This will speed up caclulate_scalar() a lot\n+       * for fonts with lots of axes and many \"monovar\" tuples. *\/\n+      hb_array_t<const F2DOT14> shared_tuples = (table+table->sharedTuples).as_array (table->sharedTupleCount * table->axisCount);\n+      unsigned count = table->sharedTupleCount;\n+      if (unlikely (!shared_tuple_active_idx.resize (count, false))) return;\n+      unsigned axis_count = table->axisCount;\n+      for (unsigned i = 0; i < count; i++)\n+      {\n+        hb_array_t<const F2DOT14> tuple = shared_tuples.sub_array (axis_count * i, axis_count);\n+        int idx = -1;\n+        for (unsigned j = 0; j < axis_count; j++)\n+        {\n+          F2DOT14 peak = tuple.arrayZ[j];\n+          if (peak.to_int () != 0)\n+          {\n+            if (idx != -1)\n+            {\n+              idx = -1;\n+              break;\n+            }\n+            idx = j;\n+          }\n+        }\n+        shared_tuple_active_idx[i] = idx;\n+      }\n+    }\n@@ -557,1 +292,1 @@\n-      if (unlikely (glyph >= table->glyphCount)) return true;\n+      if (unlikely (glyph >= glyphCount)) return true;\n@@ -559,1 +294,1 @@\n-      hb_bytes_t var_data_bytes = table->get_glyph_var_data_bytes (table.get_blob (), glyph);\n+      hb_bytes_t var_data_bytes = table->get_glyph_var_data_bytes (table.get_blob (), glyphCount, glyph);\n@@ -564,0 +299,1 @@\n+                                                   var_data_bytes.arrayZ,\n@@ -568,3 +304,1 @@\n-      contour_point_vector_t orig_points_vec;\n-      orig_points_vec.extend (points);\n-      if (unlikely (orig_points_vec.in_error ())) return false;\n+      contour_point_vector_t orig_points_vec; \/\/ Populated lazily\n@@ -573,2 +307,2 @@\n-      contour_point_vector_t deltas_vec; \/* flag is used to indicate referenced point *\/\n-      if (unlikely (!deltas_vec.resize (points.length, false))) return false;\n+      \/* flag is used to indicate referenced point *\/\n+      contour_point_vector_t deltas_vec; \/\/ Populated lazily\n@@ -577,4 +311,1 @@\n-      hb_vector_t<unsigned> end_points;\n-      for (unsigned i = 0; i < points.length; ++i)\n-        if (points.arrayZ[i].is_end_point)\n-          end_points.push (i);\n+      hb_vector_t<unsigned> end_points; \/\/ Populated lazily\n@@ -588,0 +319,1 @@\n+      bool flush = false;\n@@ -590,1 +322,2 @@\n-        float scalar = iterator.current_tuple->calculate_scalar (coords, num_coords, shared_tuples);\n+        float scalar = iterator.current_tuple->calculate_scalar (coords, num_coords, shared_tuples,\n+                                                                 shared_tuple_active_idx.in_error () ? nullptr : &shared_tuple_active_idx);\n@@ -597,0 +330,6 @@\n+        if (!deltas)\n+        {\n+          if (unlikely (!deltas_vec.resize (points.length))) return false;\n+          deltas = deltas_vec.as_array ();\n+        }\n+\n@@ -612,1 +351,18 @@\n-        hb_memset (deltas.arrayZ, 0, deltas.get_size ());\n+        if (!apply_to_all)\n+        {\n+          if (!orig_points)\n+          {\n+            orig_points_vec.extend (points);\n+            if (unlikely (orig_points_vec.in_error ())) return false;\n+            orig_points = orig_points_vec.as_array ();\n+          }\n+\n+          if (flush)\n+          {\n+            for (unsigned int i = 0; i < points.length; i++)\n+              points.arrayZ[i].translate (deltas.arrayZ[i]);\n+            flush = false;\n+\n+          }\n+          hb_memset (deltas.arrayZ, 0, deltas.get_size ());\n+        }\n@@ -614,1 +370,0 @@\n-        unsigned ref_points = 0;\n@@ -618,2 +373,8 @@\n-            unsigned int pt_index = apply_to_all ? i : indices[i];\n-            if (unlikely (pt_index >= deltas.length)) continue;\n+            unsigned int pt_index;\n+            if (apply_to_all)\n+              pt_index = i;\n+            else\n+            {\n+              pt_index = indices[i];\n+              if (unlikely (pt_index >= deltas.length)) continue;\n+            }\n@@ -621,1 +382,0 @@\n-            ref_points += !delta.flag;\n@@ -629,2 +389,8 @@\n-            unsigned int pt_index = apply_to_all ? i : indices[i];\n-            if (unlikely (pt_index >= deltas.length)) continue;\n+            unsigned int pt_index;\n+            if (apply_to_all)\n+              pt_index = i;\n+            else\n+            {\n+              pt_index = indices[i];\n+              if (unlikely (pt_index >= deltas.length)) continue;\n+            }\n@@ -632,1 +398,0 @@\n-            ref_points += !delta.flag;\n@@ -639,1 +404,1 @@\n-        if (ref_points && ref_points < orig_points.length)\n+        if (!apply_to_all)\n@@ -641,2 +406,1 @@\n-          unsigned start_point = 0;\n-          for (unsigned c = 0; c < end_points.length; c++)\n+          if (!end_points)\n@@ -644,1 +408,5 @@\n-            unsigned end_point = end_points.arrayZ[c];\n+            for (unsigned i = 0; i < points.length; ++i)\n+              if (points.arrayZ[i].is_end_point)\n+                end_points.push (i);\n+            if (unlikely (end_points.in_error ())) return false;\n+          }\n@@ -646,0 +414,3 @@\n+          unsigned start_point = 0;\n+          for (unsigned end_point : end_points)\n+          {\n@@ -692,6 +463,2 @@\n-        \/* apply specified \/ inferred deltas to points *\/\n-        for (unsigned int i = 0; i < points.length; i++)\n-        {\n-          points.arrayZ[i].x += deltas.arrayZ[i].x;\n-          points.arrayZ[i].y += deltas.arrayZ[i].y;\n-        }\n+        flush = true;\n+\n@@ -700,0 +467,4 @@\n+      if (flush)\n+        for (unsigned int i = 0; i < points.length; i++)\n+          points.arrayZ[i].translate (deltas.arrayZ[i]);\n+\n@@ -707,0 +478,2 @@\n+    unsigned glyphCount;\n+    hb_vector_t<signed> shared_tuple_active_idx;\n@@ -722,1 +495,1 @@\n-  HBUINT16      glyphCount;     \/* The number of glyphs in this font. This must match the number of\n+  HBUINT16      glyphCountX;    \/* The number of glyphs in this font. This must match the number of\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-gvar-table.hh","additions":120,"deletions":347,"binary":false,"changes":467,"status":"modified"},{"patch":"@@ -188,6 +188,2 @@\n-      for (hb_codepoint_t gid = 0; gid < plan->num_output_glyphs (); gid++)\n-      {\n-        hb_codepoint_t old_gid;\n-        if (plan->old_gid_for_new_gid (gid, &old_gid))\n-          inner_sets[0]->add (old_gid);\n-      }\n+      for (hb_codepoint_t old_gid : plan->glyphset()->iter())\n+        inner_sets[0]->add (old_gid);\n@@ -205,0 +201,1 @@\n+      {\n@@ -209,0 +206,1 @@\n+      }\n@@ -268,0 +266,3 @@\n+  const VariationStore& get_var_store () const\n+  { return this+varStore; }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-hvar-table.hh","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n- *\n@@ -88,1 +87,1 @@\n-float hb_outline_t::area () const\n+float hb_outline_t::control_area () const\n@@ -121,1 +120,1 @@\n-  bool orientation_negative = area () < 0;\n+  bool orientation_negative = control_area () < 0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.cc","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  HB_INTERNAL float area () const;\n+  HB_INTERNAL float control_area () const;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-  HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY,\n+  HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,2 +206,2 @@\n-    float cc = cosf (a * (float) M_PI);\n-    float ss = sinf (a * (float) M_PI);\n+    float cc = cosf (a * HB_PI);\n+    float ss = sinf (a * HB_PI);\n@@ -219,2 +219,2 @@\n-    float x = tanf (-sx * (float) M_PI);\n-    float y = tanf (+sy * (float) M_PI);\n+    float x = tanf (-sx * HB_PI);\n+    float y = tanf (+sy * HB_PI);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,10 @@\n-\/* Memory pool for persistent allocation of small objects. *\/\n+\/* Memory pool for persistent allocation of small objects.\n+ *\n+ * Some AI musings on this, not necessarily true:\n+ *\n+ * This is a very simple implementation, but it's good enough for our\n+ * purposes.  It's not thread-safe.  It's not very fast.  It's not\n+ * very memory efficient.  It's not very cache efficient.  It's not\n+ * very anything efficient.  But it's simple and it works.  And it's\n+ * good enough for our purposes.  If you need something more\n+ * sophisticated, use a real allocator.  Or use a real language. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-pool.hh","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,6 @@\n+ *\n+ * The priority queue is implemented as a binary heap, which is a complete\n+ * binary tree. The root of the tree is the minimum element. The heap\n+ * property is that the priority of a node is less than or equal to the\n+ * priority of its children. The heap is stored in an array, with the\n+ * children of node i stored at indices 2i + 1 and 2i + 2.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-priority-queue.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -231,0 +231,12 @@\n+\n+  bool check_ops(unsigned count)\n+  {\n+    \/* Avoid underflow *\/\n+    if (unlikely (this->max_ops < 0 || count >= (unsigned) this->max_ops))\n+    {\n+      this->max_ops = -1;\n+      return false;\n+    }\n+    return (this->max_ops -= (int) count) > 0;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-sanitize.hh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,0 +199,246 @@\n+#ifdef HB_EXPERIMENTAL_API\n+\n+static float\n+buffer_advance (hb_buffer_t *buffer)\n+{\n+  float a = 0;\n+  auto *pos = buffer->pos;\n+  unsigned count = buffer->len;\n+  if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n+    for (unsigned i = 0; i < count; i++)\n+      a += pos[i].x_advance;\n+  else\n+    for (unsigned i = 0; i < count; i++)\n+      a += pos[i].y_advance;\n+  return a;\n+}\n+\n+static void\n+reset_buffer (hb_buffer_t *buffer,\n+              hb_array_t<const hb_glyph_info_t> text)\n+{\n+  assert (buffer->ensure (text.length));\n+  buffer->have_positions = false;\n+  buffer->len = text.length;\n+  memcpy (buffer->info, text.arrayZ, text.length * sizeof (buffer->info[0]));\n+  hb_buffer_set_content_type (buffer, HB_BUFFER_CONTENT_TYPE_UNICODE);\n+}\n+\n+\/**\n+ * hb_shape_justify:\n+ * @font: a mutable #hb_font_t to use for shaping\n+ * @buffer: an #hb_buffer_t to shape\n+ * @features: (array length=num_features) (nullable): an array of user\n+ *    specified #hb_feature_t or `NULL`\n+ * @num_features: the length of @features array\n+ * @shaper_list: (array zero-terminated=1) (nullable): a `NULL`-terminated\n+ *    array of shapers to use or `NULL`\n+ * @min_target_advance: Minimum advance width\/height to aim for.\n+ * @max_target_advance: Maximum advance width\/height to aim for.\n+ * @advance: (inout): Input\/output advance width\/height of the buffer.\n+ * @var_tag: (out): Variation-axis tag used for justification.\n+ * @var_value: (out): Variation-axis value used to reach target justification.\n+ *\n+ * See hb_shape_full() for basic details. If @shaper_list is not `NULL`, the specified\n+ * shapers will be used in the given order, otherwise the default shapers list\n+ * will be used.\n+ *\n+ * In addition, justify the shaping results such that the shaping results reach\n+ * the target advance width\/height, depending on the buffer direction.\n+ *\n+ * If the advance of the buffer shaped with hb_shape_full() is already known,\n+ * put that in *advance. Otherwise set *advance to zero.\n+ *\n+ * This API is currently experimental and will probably change in the future.\n+ *\n+ * Return value: false if all shapers failed, true otherwise\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+hb_bool_t\n+hb_shape_justify (hb_font_t          *font,\n+                  hb_buffer_t        *buffer,\n+                  const hb_feature_t *features,\n+                  unsigned int        num_features,\n+                  const char * const *shaper_list,\n+                  float               min_target_advance,\n+                  float               max_target_advance,\n+                  float              *advance, \/* IN\/OUT *\/\n+                  hb_tag_t           *var_tag, \/* OUT *\/\n+                  float              *var_value \/* OUT *\/)\n+{\n+  \/\/ TODO Negative font scales?\n+\n+  \/* If default advance already matches target, nothing to do. Shape and return. *\/\n+  if (min_target_advance <= *advance && *advance <= max_target_advance)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    return hb_shape_full (font, buffer,\n+                          features, num_features,\n+                          shaper_list);\n+  }\n+\n+  hb_face_t *face = font->face;\n+\n+  \/* Choose variation tag to use for justification. *\/\n+\n+  hb_tag_t tag = HB_TAG_NONE;\n+  hb_ot_var_axis_info_t axis_info;\n+\n+  hb_tag_t tags[] =\n+  {\n+    HB_TAG ('j','s','t','f'),\n+    HB_TAG ('w','d','t','h'),\n+  };\n+  for (unsigned i = 0; i < ARRAY_LENGTH (tags); i++)\n+    if (hb_ot_var_find_axis_info (face, tags[i], &axis_info))\n+    {\n+      tag = *var_tag = tags[i];\n+      break;\n+    }\n+\n+  \/* If no suitable variation axis found, can't justify.  Just shape and return. *\/\n+  if (!tag)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    if (hb_shape_full (font, buffer,\n+                       features, num_features,\n+                       shaper_list))\n+    {\n+      *advance = buffer_advance (buffer);\n+      return true;\n+    }\n+    else\n+      return false;\n+  }\n+\n+  \/* Copy buffer text as we need it so we can shape multiple times. *\/\n+  unsigned text_len = buffer->len;\n+  auto *text_info = (hb_glyph_info_t *) hb_malloc (text_len * sizeof (buffer->info[0]));\n+  if (unlikely (text_len && !text_info))\n+    return false;\n+  hb_memcpy (text_info, buffer->info, text_len * sizeof (buffer->info[0]));\n+  auto text = hb_array<const hb_glyph_info_t> (text_info, text_len);\n+\n+  \/* If default advance was not provided to us, calculate it. *\/\n+  if (!*advance)\n+  {\n+    hb_font_set_variation (font, tag, axis_info.default_value);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    *advance = buffer_advance (buffer);\n+  }\n+\n+  \/* If default advance already matches target, nothing to do. Shape and return.\n+   * Do this again, in case advance was just calculated.\n+   *\/\n+  if (min_target_advance <= *advance && *advance <= max_target_advance)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    return true;\n+  }\n+\n+  \/* Prepare for running the solver. *\/\n+  double a, b, ya, yb;\n+  if (*advance < min_target_advance)\n+  {\n+    \/* Need to expand. *\/\n+    ya = (double) *advance;\n+    a = (double) axis_info.default_value;\n+    b = (double) axis_info.max_value;\n+\n+    \/* Shape buffer for maximum expansion to use as other\n+     * starting point for the solver. *\/\n+    hb_font_set_variation (font, tag, (float) b);\n+    reset_buffer (buffer, text);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    yb = (double) buffer_advance (buffer);\n+    \/* If the maximum expansion is less than max target,\n+     * there's nothing to solve for. Just return it. *\/\n+    if (yb <= (double) max_target_advance)\n+    {\n+      *var_value = (float) b;\n+      *advance = (float) yb;\n+      return true;\n+    }\n+  }\n+  else\n+  {\n+    \/* Need to shrink. *\/\n+    yb = (double) *advance;\n+    a = (double) axis_info.min_value;\n+    b = (double) axis_info.default_value;\n+\n+    \/* Shape buffer for maximum shrinkate to use as other\n+     * starting point for the solver. *\/\n+    hb_font_set_variation (font, tag, (float) a);\n+    reset_buffer (buffer, text);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    ya = (double) buffer_advance (buffer);\n+    \/* If the maximum shrinkate is more than min target,\n+     * there's nothing to solve for. Just return it. *\/\n+    if (ya >= (double) min_target_advance)\n+    {\n+      *var_value = (float) a;\n+      *advance = (float) ya;\n+      return true;\n+    }\n+  }\n+\n+  \/* Run the solver to find a var axis value that hits\n+   * the desired width. *\/\n+\n+  double epsilon = (b - a) \/ (1<<14);\n+  bool failed = false;\n+\n+  auto f = [&] (double x)\n+  {\n+    hb_font_set_variation (font, tag, (float) x);\n+    reset_buffer (buffer, text);\n+    if (unlikely (!hb_shape_full (font, buffer,\n+                                  features, num_features,\n+                                  shaper_list)))\n+    {\n+      failed = true;\n+      return (double) min_target_advance;\n+    }\n+\n+    double w = (double) buffer_advance (buffer);\n+    DEBUG_MSG (JUSTIFY, nullptr, \"Trying '%c%c%c%c' axis parameter %f. Advance %g. Target: min %g max %g\",\n+               HB_UNTAG (tag), x, w,\n+               (double) min_target_advance, (double) max_target_advance);\n+    return w;\n+  };\n+\n+  double y = 0;\n+  double itp = solve_itp (f,\n+                          a, b,\n+                          epsilon,\n+                          (double) min_target_advance, (double) max_target_advance,\n+                          ya, yb, y);\n+\n+  hb_free (text_info);\n+\n+  if (failed)\n+    return false;\n+\n+  *var_value = (float) itp;\n+  *advance = (float) y;\n+\n+  return true;\n+}\n+\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.cc","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -56,0 +56,12 @@\n+HB_EXTERN hb_bool_t\n+hb_shape_justify (hb_font_t          *font,\n+                  hb_buffer_t        *buffer,\n+                  const hb_feature_t *features,\n+                  unsigned int        num_features,\n+                  const char * const *shaper_list,\n+                  float               min_target_advance,\n+                  float               max_target_advance,\n+                  float              *advance, \/* IN\/OUT *\/\n+                  hb_tag_t           *var_tag, \/* OUT *\/\n+                  float              *var_value \/* OUT *\/);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-HB_SHAPER_IMPLEMENT (ot) \/* <--- This is our main OpenType shaper. *\/\n+HB_SHAPER_IMPLEMENT (ot) \/* <--- This is our main shaper. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shaper-list.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"hb-ot-hmtx-table.hh\"\n@@ -42,0 +43,1 @@\n+#include \"hb-ot-name-language-static.hh\"\n@@ -111,0 +113,22 @@\n+#ifndef HB_NO_VAR\n+bool\n+_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical,\n+                                             int *lsb)\n+{\n+  return font->face->table.glyf->get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n+}\n+\n+unsigned\n+_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n+{\n+  return font->face->table.glyf->get_advance_with_var_unscaled (font, glyph, is_vertical);\n+}\n+#endif\n+\n+bool\n+_glyf_get_leading_bearing_without_var_unscaled (hb_face_t *face, hb_codepoint_t gid, bool is_vertical, int *lsb)\n+{\n+  return face->table.glyf->get_leading_bearing_without_var_unscaled (gid, is_vertical, lsb);\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-static.cc","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  return tanf (a * float (-M_PI \/ 180.));\n+  return tanf (a * -HB_PI \/ 180.f);\n@@ -55,1 +55,1 @@\n-  return atanf (r) * float (-180. \/ M_PI);\n+  return atanf (r) * -180.f \/ HB_PI;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-style.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-    HB_TAG ('c', 'v', 't', ' '),\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.cc","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"hb-ot-cff2-table.hh\"\n@@ -41,0 +42,1 @@\n+#include \"OT\/Color\/CPAL\/CPAL.hh\"\n@@ -296,1 +298,1 @@\n-  if (table_tag == HB_OT_TAG_GSUB)\n+  if (table_tag == HB_OT_TAG_GSUB && !(plan->flags & HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE))\n@@ -348,1 +350,4 @@\n-  vars.alloc (plan->user_axes_location.get_population ());\n+  if (!vars.alloc (plan->user_axes_location.get_population ())) {\n+    hb_font_destroy (font);\n+    return nullptr;\n+  }\n@@ -384,1 +389,7 @@\n-    font = _get_hb_font_with_variations (plan);\n+    if (unlikely (!plan->check_success (font = _get_hb_font_with_variations (plan)))) {\n+      hb_font_destroy (font);\n+      gdef.destroy ();\n+      gpos.destroy ();\n+      return;\n+    }\n+\n@@ -558,3 +569,6 @@\n-        hb_codepoint_t gid = (*unicode_glyphid_map)[cp];\n-        plan->codepoint_to_glyph->set (cp, gid);\n-        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+        hb_codepoint_t *gid;\n+        if (!unicode_glyphid_map->has(cp, &gid))\n+          continue;\n+\n+        plan->codepoint_to_glyph->set (cp, *gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, *gid));\n@@ -612,1 +626,1 @@\n-  for (auto item : glyf.glyph_for_gid (gid).get_composite_iterator ())\n+  for (auto &item : glyf.glyph_for_gid (gid).get_composite_iterator ())\n@@ -620,0 +634,12 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+  for (auto &item : glyf.glyph_for_gid (gid).get_var_composite_iterator ())\n+   {\n+    operation_count =\n+      _glyf_add_gid_and_children (glyf,\n+                                  item.get_gid (),\n+                                  gids_to_retain,\n+                                  operation_count,\n+                                  depth);\n+   }\n+#endif\n+\n@@ -623,0 +649,32 @@\n+static void\n+_nameid_closure (hb_subset_plan_t* plan,\n+                 hb_set_t* drop_tables)\n+{\n+#ifndef HB_NO_STYLE\n+  plan->source->table.STAT->collect_name_ids (&plan->user_axes_location, &plan->name_ids);\n+#endif\n+#ifndef HB_NO_VAR\n+  if (!plan->all_axes_pinned)\n+    plan->source->table.fvar->collect_name_ids (&plan->user_axes_location, &plan->name_ids);\n+#endif\n+#ifndef HB_NO_COLOR\n+  if (!drop_tables->has (HB_OT_TAG_CPAL))\n+    plan->source->table.CPAL->collect_name_ids (&plan->colr_palettes, &plan->name_ids);\n+#endif\n+\n+#ifndef HB_NO_SUBSET_LAYOUT\n+  if (!drop_tables->has (HB_OT_TAG_GPOS))\n+  {\n+    hb_blob_ptr_t<GPOS> gpos = plan->source_table<GPOS> ();\n+    gpos->collect_name_ids (&plan->gpos_features, &plan->name_ids);\n+    gpos.destroy ();\n+  }\n+  if (!drop_tables->has (HB_OT_TAG_GSUB))\n+  {\n+    hb_blob_ptr_t<GSUB> gsub = plan->source_table<GSUB> ();\n+    gsub->collect_name_ids (&plan->gsub_features, &plan->name_ids);\n+    gsub.destroy ();\n+  }\n+#endif\n+}\n+\n@@ -676,0 +734,1 @@\n+  _nameid_closure (plan, drop_tables);\n@@ -759,15 +818,0 @@\n-static void\n-_nameid_closure (hb_face_t *face,\n-                 hb_set_t  *nameids,\n-                 bool all_axes_pinned,\n-                 hb_hashmap_t<hb_tag_t, float> *user_axes_location)\n-{\n-#ifndef HB_NO_STYLE\n-  face->table.STAT->collect_name_ids (user_axes_location, nameids);\n-#endif\n-#ifndef HB_NO_VAR\n-  if (!all_axes_pinned)\n-    face->table.fvar->collect_name_ids (user_axes_location, nameids);\n-#endif\n-}\n-\n@@ -786,0 +830,1 @@\n+  unsigned avar_axis_count = 0;\n@@ -787,0 +832,1 @@\n+  {\n@@ -788,0 +834,2 @@\n+    avar_axis_count = face->table.avar->get_axis_count();\n+  }\n@@ -791,1 +839,0 @@\n-  unsigned int i = 0;\n@@ -806,1 +853,1 @@\n-      if (has_avar && old_axis_idx < face->table.avar->get_axis_count ())\n+      if (has_avar && old_axis_idx < avar_axis_count)\n@@ -814,1 +861,1 @@\n-      plan->normalized_coords[i] = normalized_v;\n+      plan->normalized_coords[old_axis_idx] = normalized_v;\n@@ -816,2 +863,0 @@\n-    if (has_avar)\n-      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n@@ -821,1 +866,2 @@\n-    i++;\n+    if (has_avar && old_axis_idx < avar_axis_count)\n+      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n@@ -825,0 +871,83 @@\n+\n+static void\n+_update_instance_metrics_map_from_cff2 (hb_subset_plan_t *plan)\n+{\n+  if (!plan->normalized_coords) return;\n+  OT::cff2::accelerator_t cff2 (plan->source);\n+  if (!cff2.is_valid ()) return;\n+\n+  hb_font_t *font = nullptr;\n+  if (unlikely (!plan->check_success (font = _get_hb_font_with_variations (plan))))\n+  {\n+    hb_font_destroy (font);\n+    return;\n+  }\n+\n+  hb_glyph_extents_t extents = {0x7FFF, -0x7FFF};\n+  OT::hmtx_accelerator_t _hmtx (plan->source);\n+  float *hvar_store_cache = nullptr;\n+  if (_hmtx.has_data () && _hmtx.var_table.get_length ())\n+    hvar_store_cache = _hmtx.var_table->get_var_store ().create_cache ();\n+\n+  OT::vmtx_accelerator_t _vmtx (plan->source);\n+  float *vvar_store_cache = nullptr;\n+  if (_vmtx.has_data () && _vmtx.var_table.get_length ())\n+    vvar_store_cache = _vmtx.var_table->get_var_store ().create_cache ();\n+\n+  for (auto p : *plan->glyph_map)\n+  {\n+    hb_codepoint_t old_gid = p.first;\n+    hb_codepoint_t new_gid = p.second;\n+    if (!cff2.get_extents (font, old_gid, &extents)) continue;\n+    bool has_bounds_info = true;\n+    if (extents.x_bearing == 0 && extents.width == 0 &&\n+        extents.height == 0 && extents.y_bearing == 0)\n+      has_bounds_info = false;\n+\n+    if (has_bounds_info)\n+    {\n+      plan->head_maxp_info.xMin = hb_min (plan->head_maxp_info.xMin, extents.x_bearing);\n+      plan->head_maxp_info.xMax = hb_max (plan->head_maxp_info.xMax, extents.x_bearing + extents.width);\n+      plan->head_maxp_info.yMax = hb_max (plan->head_maxp_info.yMax, extents.y_bearing);\n+      plan->head_maxp_info.yMin = hb_min (plan->head_maxp_info.yMin, extents.y_bearing + extents.height);\n+    }\n+\n+    if (_hmtx.has_data ())\n+    {\n+      int hori_aw = _hmtx.get_advance_without_var_unscaled (old_gid);\n+      if (_hmtx.var_table.get_length ())\n+        hori_aw += (int) roundf (_hmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n+                                                                              hvar_store_cache));\n+      int lsb = extents.x_bearing;\n+      if (!has_bounds_info)\n+      {\n+        if (!_hmtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb))\n+          continue;\n+      }\n+      plan->hmtx_map.set (new_gid, hb_pair ((unsigned) hori_aw, lsb));\n+      plan->bounds_width_map.set (new_gid, extents.width);\n+    }\n+\n+    if (_vmtx.has_data ())\n+    {\n+      int vert_aw = _vmtx.get_advance_without_var_unscaled (old_gid);\n+      if (_vmtx.var_table.get_length ())\n+        vert_aw += (int) roundf (_vmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n+                                                                              vvar_store_cache));\n+\n+      int tsb = extents.y_bearing;\n+      if (!has_bounds_info)\n+      {\n+        if (!_vmtx.get_leading_bearing_without_var_unscaled (old_gid, &tsb))\n+          continue;\n+      }\n+      plan->vmtx_map.set (new_gid, hb_pair ((unsigned) vert_aw, tsb));\n+      plan->bounds_height_map.set (new_gid, extents.height);\n+    }\n+  }\n+  hb_font_destroy (font);\n+  if (hvar_store_cache)\n+    _hmtx.var_table->get_var_store ().destroy_cache (hvar_store_cache);\n+  if (vvar_store_cache)\n+    _vmtx.var_table->get_var_store ().destroy_cache (vvar_store_cache);\n+}\n@@ -887,0 +1016,2 @@\n+  if (unlikely (in_error ()))\n+    return;\n@@ -908,1 +1039,0 @@\n-  _nameid_closure (face, &name_ids, all_axes_pinned, &user_axes_location);\n@@ -912,0 +1042,4 @@\n+#ifndef HB_NO_VAR\n+  _update_instance_metrics_map_from_cff2 (this);\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.cc","additions":163,"deletions":29,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-    hb_lock_t (accelerator ? &accelerator->sanitized_table_cache_lock : nullptr);\n+    hb_lock_t lock (accelerator ? &accelerator->sanitized_table_cache_lock : nullptr);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-#if !defined(AIX)\n@@ -49,2 +47,0 @@\n-#endif\n-\n@@ -57,0 +53,1 @@\n+#include \"hb-ot-var-cvar-table.hh\"\n@@ -485,0 +482,10 @@\n+  case HB_TAG ('c', 'v', 't', ' '):\n+#ifndef HB_NO_VAR\n+    if (_is_table_present (plan->source, HB_OT_TAG_cvar) &&\n+        plan->normalized_coords && !plan->pinned_at_default)\n+    {\n+      auto &cvar = *plan->source->table.cvar;\n+      return OT::cvar::add_cvt_and_apply_deltas (plan, cvar.get_tuple_var_data (), &cvar);\n+    }\n+#endif\n+    return _passthrough (plan, tag);\n@@ -633,5 +640,0 @@\n-\n-#ifndef HB_NO_VISIBILITY\n-\/* If NO_VISIBILITY, libharfbuzz has this. *\/\n-#include \"hb-ot-name-language-static.hh\"\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+ * @HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE: If set don't perform glyph closure on layout\n+ * substitution rules (GSUB). Since: 7.2.0.\n@@ -90,0 +92,1 @@\n+  HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE =        0x00000200u,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n- * @HB_UNICODE_COMBINING_CLASS_CCC133: [Tibetan]\n+ * @HB_UNICODE_COMBINING_CLASS_CCC132: [Tibetan] Since: 7.2.0\n@@ -249,1 +249,1 @@\n-  HB_UNICODE_COMBINING_CLASS_CCC133     = 132,\n+  HB_UNICODE_COMBINING_CLASS_CCC132     = 132,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#define HB_VERSION_MINOR 0\n+#define HB_VERSION_MINOR 2\n@@ -56,1 +56,1 @@\n-#define HB_VERSION_MICRO 1\n+#define HB_VERSION_MICRO 0\n@@ -63,1 +63,1 @@\n-#define HB_VERSION_STRING \"7.0.1\"\n+#define HB_VERSION_STRING \"7.2.0\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-version.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,9 @@\n-#if (defined(__GNUC__) || defined(__clang__)) && defined(__OPTIMIZE__)\n+\/\/ gcc 10 has __has_builtin but not earlier versions. Sanction any gcc >= 5\n+\/\/ clang defines it so no need.\n+#ifdef __has_builtin\n+#define hb_has_builtin __has_builtin\n+#else\n+#define hb_has_builtin(x) ((defined(__GNUC__) && __GNUC__ >= 5))\n+#endif\n+\n+#if defined(__OPTIMIZE__) && hb_has_builtin(__builtin_expect)\n@@ -504,0 +512,6 @@\n+\/* Pie time. *\/\n+\/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4166\n+#define HB_PI 3.14159265358979f\n+#define HB_2_PI (2.f * HB_PI)\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.hh","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6112,0 +6112,12 @@\n+Version 1.6.39 [November 20, 2022]\n+  Changed the error handler of oversized chunks (i.e. larger than\n+    PNG_USER_CHUNK_MALLOC_MAX) from png_chunk_error to png_benign_error.\n+  Fixed a buffer overflow error in contrib\/tools\/pngfix.\n+  Fixed a memory leak (CVE-2019-6129) in contrib\/tools\/pngcp.\n+  Disabled the ARM Neon optimizations by default in the CMake file,\n+    following the default behavior of the configure script.\n+  Allowed configure.ac to work with the trunk version of autoconf.\n+  Removed the support for \"install\" targets from the legacy makefiles;\n+    removed the obsolete makefile.cegcc.\n+  Cleaned up the code and updated the internal documentation.\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/CHANGES","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-be appreciated.\n+be appreciated.\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/LICENSE","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-README for libpng version 1.6.38\n+README for libpng version 1.6.39\n@@ -109,67 +109,68 @@\n-      ANNOUNCE      =>  Announcement of this version, with recent changes\n-      AUTHORS       =>  List of contributing authors\n-      CHANGES       =>  Description of changes between libpng versions\n-      KNOWNBUG      =>  List of known bugs and deficiencies\n-      LICENSE       =>  License to use and redistribute libpng\n-      README        =>  This file\n-      TODO          =>  Things not implemented in the current library\n-      TRADEMARK     =>  Trademark information\n-      example.c     =>  Example code for using libpng functions\n-      libpng.3      =>  manual page for libpng (includes libpng-manual.txt)\n-      libpng-manual.txt  =>  Description of libpng and its functions\n-      libpngpf.3    =>  manual page for libpng's private functions\n-      png.5         =>  manual page for the PNG format\n-      png.c         =>  Basic interface functions common to library\n-      png.h         =>  Library function and interface declarations (public)\n-      pngpriv.h     =>  Library function and interface declarations (private)\n-      pngconf.h     =>  System specific library configuration (public)\n-      pngstruct.h   =>  png_struct declaration (private)\n-      pnginfo.h     =>  png_info struct declaration (private)\n-      pngdebug.h    =>  debugging macros (private)\n-      pngerror.c    =>  Error\/warning message I\/O functions\n-      pngget.c      =>  Functions for retrieving info from struct\n-      pngmem.c      =>  Memory handling functions\n-      pngbar.png    =>  PNG logo, 88x31\n-      pngnow.png    =>  PNG logo, 98x31\n-      pngpread.c    =>  Progressive reading functions\n-      pngread.c     =>  Read data\/helper high-level functions\n-      pngrio.c      =>  Lowest-level data read I\/O functions\n-      pngrtran.c    =>  Read data transformation functions\n-      pngrutil.c    =>  Read data utility functions\n-      pngset.c      =>  Functions for storing data into the info_struct\n-      pngtest.c     =>  Library test program\n-      pngtest.png   =>  Library test sample image\n-      pngtrans.c    =>  Common data transformation functions\n-      pngwio.c      =>  Lowest-level write I\/O functions\n-      pngwrite.c    =>  High-level write functions\n-      pngwtran.c    =>  Write data transformations\n-      pngwutil.c    =>  Write utility functions\n-      arm           =>  Contains optimized code for the ARM platform\n-      powerpc       =>  Contains optimized code for the PowerPC platform\n-      contrib       =>  Contributions\n-       arm-neon         =>  Optimized code for ARM-NEON platform\n-       powerpc-vsx      =>  Optimized code for POWERPC-VSX platform\n-       examples         =>  Example programs\n-       gregbook         =>  source code for PNG reading and writing, from\n-                            Greg Roelofs' \"PNG: The Definitive Guide\",\n-                            O'Reilly, 1999\n-       libtests         =>  Test programs\n-       mips-msa         =>  Optimized code for MIPS-MSA platform\n-       pngminim         =>  Minimal decoder, encoder, and progressive decoder\n-                            programs demonstrating use of pngusr.dfa\n-       pngminus         =>  Simple pnm2png and png2pnm programs\n-       pngsuite         =>  Test images\n-       testpngs\n-       tools            =>  Various tools\n-       visupng          =>  Contains a MSVC workspace for VisualPng\n-      intel             =>  Optimized code for INTEL-SSE2 platform\n-      mips              =>  Optimized code for MIPS platform\n-      projects      =>  Contains project files and workspaces for\n-                        building a DLL\n-       owatcom          =>  Contains a WATCOM project for building libpng\n-       visualc71        =>  Contains a Microsoft Visual C++ (MSVC)\n-                            workspace for building libpng and zlib\n-       vstudio          =>  Contains a Microsoft Visual C++ (MSVC)\n-                            workspace for building libpng and zlib\n-      scripts       =>  Directory containing scripts for building libpng:\n-                            (see scripts\/README.txt for the list of scripts)\n+    ANNOUNCE      =>  Announcement of this version, with recent changes\n+    AUTHORS       =>  List of contributing authors\n+    CHANGES       =>  Description of changes between libpng versions\n+    INSTALL       =>  Instructions to install libpng\n+    LICENSE       =>  License to use and redistribute libpng\n+    README        =>  This file\n+    TODO          =>  Things not implemented in the current library\n+    TRADEMARK     =>  Trademark information\n+    example.c     =>  Example code for using libpng functions\n+    libpng.3      =>  Manual page for libpng (includes libpng-manual.txt)\n+    libpng-manual.txt  =>  Description of libpng and its functions\n+    libpngpf.3    =>  Manual page for libpng's private functions (deprecated)\n+    png.5         =>  Manual page for the PNG format\n+    png.c         =>  Basic interface functions common to library\n+    png.h         =>  Library function and interface declarations (public)\n+    pngpriv.h     =>  Library function and interface declarations (private)\n+    pngconf.h     =>  System specific library configuration (public)\n+    pngstruct.h   =>  png_struct declaration (private)\n+    pnginfo.h     =>  png_info struct declaration (private)\n+    pngdebug.h    =>  debugging macros (private)\n+    pngerror.c    =>  Error\/warning message I\/O functions\n+    pngget.c      =>  Functions for retrieving info from struct\n+    pngmem.c      =>  Memory handling functions\n+    pngbar.png    =>  PNG logo, 88x31\n+    pngnow.png    =>  PNG logo, 98x31\n+    pngpread.c    =>  Progressive reading functions\n+    pngread.c     =>  Read data\/helper high-level functions\n+    pngrio.c      =>  Lowest-level data read I\/O functions\n+    pngrtran.c    =>  Read data transformation functions\n+    pngrutil.c    =>  Read data utility functions\n+    pngset.c      =>  Functions for storing data into the info_struct\n+    pngtest.c     =>  Library test program\n+    pngtest.png   =>  Library test sample image\n+    pngtrans.c    =>  Common data transformation functions\n+    pngwio.c      =>  Lowest-level write I\/O functions\n+    pngwrite.c    =>  High-level write functions\n+    pngwtran.c    =>  Write data transformations\n+    pngwutil.c    =>  Write utility functions\n+    arm\/          =>  Optimized code for the ARM platform\n+    intel\/        =>  Optimized code for the INTEL-SSE2 platform\n+    mips\/         =>  Optimized code for the MIPS platform\n+    powerpc\/      =>  Optimized code for the PowerPC platform\n+    ci\/           =>  Scripts for continuous integration\n+    contrib\/      =>  External contributions\n+        arm-neon\/     =>  Optimized code for the ARM-NEON platform\n+        mips-msa\/     =>  Optimized code for the MIPS-MSA platform\n+        powerpc-vsx\/  =>  Optimized code for the POWERPC-VSX platform\n+        examples\/     =>  Example programs\n+        gregbook\/     =>  Source code for PNG reading and writing, from\n+                          \"PNG: The Definitive Guide\" by Greg Roelofs,\n+                          O'Reilly, 1999\n+        libtests\/     =>  Test programs\n+        oss-fuzz\/     =>  Files used by the OSS-Fuzz project for fuzz-testing\n+                          libpng\n+        pngminim\/     =>  Minimal decoder, encoder, and progressive decoder\n+                          programs demonstrating the use of pngusr.dfa\n+        pngminus\/     =>  Simple pnm2png and png2pnm programs\n+        pngsuite\/     =>  Test images\n+        testpngs\/     =>  Test images\n+        tools\/        =>  Various tools\n+        visupng\/      =>  VisualPng, a Windows viewer for PNG images\n+    projects\/     =>  Project files and workspaces for various IDEs\n+        owatcom\/      =>  OpenWatcom project\n+        visualc71\/    =>  Microsoft Visual C++ 7.1 workspace\n+        vstudio\/      =>  Microsoft Visual Studio workspace\n+    scripts\/      =>  Scripts and makefiles for building libpng\n+                      (see scripts\/README.txt for the complete list)\n+    tests\/        =>  Test scripts\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/README","additions":69,"deletions":68,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-typedef png_libpng_version_1_6_38 Your_png_h_is_not_version_1_6_38;\n+typedef png_libpng_version_1_6_39 Your_png_h_is_not_version_1_6_39;\n@@ -846,1 +846,1 @@\n-      \"libpng version 1.6.38\" PNG_STRING_NEWLINE \\\n+      \"libpng version 1.6.39\" PNG_STRING_NEWLINE \\\n@@ -2741,1 +2741,1 @@\n-    png_size_tp whereami)\n+    size_t *whereami)\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.38 - September 14, 2022\n+ * libpng version 1.6.39 - November 20, 2022\n@@ -46,1 +46,1 @@\n- *   libpng versions 1.6.36, December 2018, through 1.6.38, September 2022:\n+ *   libpng versions 1.6.36, December 2018, through 1.6.39, November 2022:\n@@ -270,1 +270,1 @@\n- *    1.6.38                  16    10638  16.so.16.38[.0]\n+ *    1.6.39                  16    10639  16.so.16.39[.0]\n@@ -309,2 +309,2 @@\n-#define PNG_LIBPNG_VER_STRING \"1.6.38\"\n-#define PNG_HEADER_VERSION_STRING \" libpng version 1.6.38 - September 14, 2022\\n\"\n+#define PNG_LIBPNG_VER_STRING \"1.6.39\"\n+#define PNG_HEADER_VERSION_STRING \" libpng version 1.6.39 - November 20, 2022\\n\"\n@@ -318,1 +318,1 @@\n-#define PNG_LIBPNG_VER_RELEASE 38\n+#define PNG_LIBPNG_VER_RELEASE 39\n@@ -349,1 +349,1 @@\n-#define PNG_LIBPNG_VER 10638 \/* 1.6.38 *\/\n+#define PNG_LIBPNG_VER 10639 \/* 1.6.39 *\/\n@@ -459,1 +459,1 @@\n-typedef char* png_libpng_version_1_6_38;\n+typedef char* png_libpng_version_1_6_39;\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.38\n+ * libpng version 1.6.39\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngconf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/* libpng version 1.6.38 *\/\n+\/* libpng version 1.6.39 *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnglibconf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1977,1 +1977,1 @@\n-   size_t size, int *statep, png_size_tp whereami),PNG_EMPTY);\n+   size_t size, int *statep, size_t *whereami),PNG_EMPTY);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpriv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3217,1 +3217,1 @@\n-      png_chunk_error(png_ptr, \"chunk data is too large\");\n+      png_benign_error(png_ptr, \"chunk data is too large\");\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrutil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,0 +334,5 @@\n+    if (buffer == 0) {\n+        (*env)->ExceptionClear(env);\n+        JNU_ThrowOutOfMemoryError(env, \"Could not get image buffer\");\n+        return -1;\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/swing_GTKEngine.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -478,4 +478,5 @@\n-        BOOL transparent = FALSE;\n-        transparent = IsThemeBackgroundPartiallyTransparent(hTheme,part,state);\n-        copyDIBToBufferedImage(pDstBits, pSrcBits, transparent, w, h, stride);\n-        env->ReleasePrimitiveArrayCritical(array, pDstBits, 0);\n+        if (pDstBits != NULL) {\n+            BOOL transparent = IsThemeBackgroundPartiallyTransparent(hTheme, part, state);\n+            copyDIBToBufferedImage(pDstBits, pSrcBits, transparent, w, h, stride);\n+            env->ReleasePrimitiveArrayCritical(array, pDstBits, 0);\n+        }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ThemeReader.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -166,0 +166,4 @@\n+    if (pLogPalette == NULL) {\n+        env->DeleteLocalRef(paletteBytes);\n+        return NULL;\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DataTransferer.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2879,2 +2879,4 @@\n-        for (int i = 0; i < (sizeof indexMap)\/(sizeof *indexMap) && i < colorLen; i++) {\n-            colorsPtr[i] = DesktopColor2RGB(indexMap[i]);\n+        if (colorsPtr != NULL) {\n+            for (int i = 0; i < (sizeof indexMap)\/(sizeof *indexMap) && i < colorLen; i++) {\n+                colorsPtr[i] = DesktopColor2RGB(indexMap[i]);\n+            }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import javax.naming.ldap.LdapName;\n@@ -65,2 +66,0 @@\n-    private final static boolean DEBUG = false;\n-\n@@ -75,1 +74,0 @@\n-    private static final String DELTA_CRL = \"deltaRevocationList;binary\";\n@@ -116,0 +114,1 @@\n+\n@@ -203,0 +202,43 @@\n+    private static String checkName(String name) throws CertStoreException {\n+        if (name == null) {\n+            throw new CertStoreException(\"Name absent\");\n+        }\n+        try {\n+            if (new CompositeName(name).size() > 1) {\n+                throw new CertStoreException(\"Invalid name: \" + name);\n+            }\n+        } catch (InvalidNameException ine) {\n+            throw new CertStoreException(\"Invalid name: \" + name, ine);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Get the values for the given attribute. If the attribute is null\n+     * or does not contain any values, a zero length byte array is\n+     * returned. NOTE that it is assumed that all values are byte arrays.\n+     *\/\n+    private static byte[][] getAttributeValues(Attribute attr)\n+            throws NamingException {\n+        byte[][] values;\n+        if (attr == null) {\n+            values = BB0;\n+        } else {\n+            values = new byte[attr.size()][];\n+            int i = 0;\n+            NamingEnumeration<?> enum_ = attr.getAll();\n+            while (enum_.hasMore()) {\n+                Object obj = enum_.next();\n+                if (debug != null) {\n+                    if (obj instanceof String) {\n+                        debug.println(\"LDAPCertStore.getAttrValues() \"\n+                            + \"enum.next is a string!: \" + obj);\n+                    }\n+                }\n+                byte[] value = (byte[])obj;\n+                values[i++] = value;\n+            }\n+        }\n+        return values;\n+    }\n+\n@@ -221,1 +263,1 @@\n-        private final String name;\n+        private final LdapName name;\n@@ -226,8 +268,0 @@\n-            this.name = checkName(name);\n-            requestedAttributes = new ArrayList<>(5);\n-        }\n-\n-        private String checkName(String name) throws CertStoreException {\n-            if (name == null) {\n-                throw new CertStoreException(\"Name absent\");\n-            }\n@@ -235,3 +269,4 @@\n-                if (new CompositeName(name).size() > 1) {\n-                    throw new CertStoreException(\"Invalid name: \" + name);\n-                }\n+                \/\/ Convert DN to an LdapName so that it is not treated as a\n+                \/\/ composite name by JNDI. In JNDI, using a string name is\n+                \/\/ equivalent to calling new CompositeName(stringName).\n+                this.name = new LdapName(name);\n@@ -241,5 +276,1 @@\n-            return name;\n-        }\n-\n-        String getName() {\n-            return name;\n+            requestedAttributes = new ArrayList<>(5);\n@@ -263,3 +294,3 @@\n-            if (DEBUG && ((cacheHits + cacheMisses) % 50 == 0)) {\n-                System.out.println(\"Cache hits: \" + cacheHits + \"; misses: \"\n-                        + cacheMisses);\n+            if (debug != null && Debug.isVerbose() && ((cacheHits + cacheMisses) % 50 == 0)) {\n+                debug.println(\"LDAPRequest Cache hits: \" + cacheHits +\n+                    \"; misses: \" + cacheMisses);\n@@ -297,2 +328,2 @@\n-            if (DEBUG) {\n-                System.out.println(\"Request: \" + name + \":\" + requestedAttributes);\n+            if (debug != null && Debug.isVerbose()) {\n+                debug.println(\"LDAPRequest: \" + name + \":\" + requestedAttributes);\n@@ -301,1 +332,1 @@\n-                    System.out.println(\"LDAP requests: \" + requests);\n+                    debug.println(\"LDAP requests: \" + requests);\n@@ -328,0 +359,3 @@\n+                        \/\/ In JNDI, it is not possible to use an LdapName for\n+                        \/\/ the referral DN, so we must validate the syntax of\n+                        \/\/ the string DN.\n@@ -372,30 +406,0 @@\n-\n-        \/**\n-         * Get the values for the given attribute. If the attribute is null\n-         * or does not contain any values, a zero length byte array is\n-         * returned. NOTE that it is assumed that all values are byte arrays.\n-         *\/\n-        private byte[][] getAttributeValues(Attribute attr)\n-                throws NamingException {\n-            byte[][] values;\n-            if (attr == null) {\n-                values = BB0;\n-            } else {\n-                values = new byte[attr.size()][];\n-                int i = 0;\n-                NamingEnumeration<?> enum_ = attr.getAll();\n-                while (enum_.hasMore()) {\n-                    Object obj = enum_.next();\n-                    if (debug != null) {\n-                        if (obj instanceof String) {\n-                            debug.println(\"LDAPCertStore.getAttrValues() \"\n-                                + \"enum.next is a string!: \" + obj);\n-                        }\n-                    }\n-                    byte[] value = (byte[])obj;\n-                    values[i++] = value;\n-                }\n-            }\n-            return values;\n-        }\n-\n","filename":"src\/java.naming\/share\/classes\/sun\/security\/provider\/certpath\/ldap\/LDAPCertStoreImpl.java","additions":61,"deletions":57,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.List;\n@@ -264,7 +265,11 @@\n-        String authval = hdrs.firstValue(authname).orElse(null);\n-        if (authval == null) {\n-            if (exchange.client().authenticator().isPresent()) {\n-                throw new IOException(authname + \" header missing for response code \" + status);\n-            } else {\n-                \/\/ No authenticator? let the caller deal with this.\n-                return null;\n+        List<String> authvals = hdrs.allValues(authname);\n+        if (authvals.isEmpty() && exchange.client().authenticator().isPresent()) {\n+            throw new IOException(authname + \" header missing for response code \" + status);\n+        }\n+        String authval = null;\n+        for (String aval : authvals) {\n+            HeaderParser parser = new HeaderParser(aval);\n+            String scheme = parser.findKey(0);\n+            if (scheme.equalsIgnoreCase(\"Basic\")) {\n+                authval = aval;\n+                break;\n@@ -273,8 +278,2 @@\n-\n-        HeaderParser parser = new HeaderParser(authval);\n-        String scheme = parser.findKey(0);\n-\n-        \/\/ TODO: Need to generalise from Basic only. Delegate to a provider class etc.\n-\n-        if (!scheme.equalsIgnoreCase(\"Basic\")) {\n-            return null;   \/\/ error gets returned to app\n+        if (authval == null) {\n+            return null;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-            oid = new ObjectIdentifier(strOid);\n+            oid = ObjectIdentifier.of(strOid);\n","filename":"src\/java.security.jgss\/share\/classes\/org\/ietf\/jgss\/Oid.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,5 @@\n+            try {\n+                disposeContext();\n+            } catch (Exception ex) {\n+                \/\/dispose context silently\n+            }\n@@ -159,0 +164,3 @@\n+            if (context == null) {\n+                throw new IOException(\"Negotiate support cannot continue. Context is invalidated\");\n+            }\n@@ -170,0 +178,22 @@\n+\n+    \/**\n+     * Releases any system resources and cryptographic information stored in\n+     * the context object and invalidates the context.\n+     *\n+     * @throws IOException containing a reason of failure in the cause\n+     *\/\n+    @Override\n+    public void disposeContext() throws IOException {\n+        try {\n+            if (context != null) {\n+                context.dispose();\n+            }\n+        } catch (GSSException e) {\n+            if (DEBUG) {\n+                System.out.println(\"Cannot release resources. Reason:\");\n+                e.printStackTrace();\n+            }\n+            throw new IOException(\"Cannot release resources\", e);\n+        };\n+        context = null;\n+    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-                objId = new ObjectIdentifier(mechOid.toString());\n+                objId = ObjectIdentifier.of(mechOid.toString());\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSContextImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,1 +415,1 @@\n-            oid = new ObjectIdentifier\n+            oid = ObjectIdentifier.of\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSNameImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-            OID = new ObjectIdentifier(Krb5MechFactory.\n+            OID = ObjectIdentifier.of(Krb5MechFactory.\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Token.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            OID = new ObjectIdentifier(SpNegoMechFactory.\n+            OID = ObjectIdentifier.of(SpNegoMechFactory.\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/spnego\/SpNegoToken.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-                    dout.putOID(new ObjectIdentifier(mech.toString()));\n+                    dout.putOID(ObjectIdentifier.of(mech.toString()));\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/GSSNameElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-                    (new ObjectIdentifier(cStub.getMech().toString()),\n+                    (ObjectIdentifier.of(cStub.getMech().toString()),\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/NativeGSSContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,1 +260,2 @@\n-            if (ke != null && ke.getErrorCode() ==\n+            if (ke != null) {\n+                if (ke.getErrorCode() ==\n@@ -262,1 +263,5 @@\n-                ibuf = send(obuf, tempKdc, true);\n+                    ibuf = send(obuf, tempKdc, true);\n+                } else if (ke.getErrorCode() ==\n+                        Krb5.KDC_ERR_SVC_UNAVAILABLE) {\n+                    throw new KrbException(\"A service is not available\");\n+                }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/KdcComm.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+    public static final int KDC_ERR_SVC_UNAVAILABLE      = 29;   \/\/A service is not available\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/Krb5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1423,21 +1423,0 @@\n-\n-                    \/\/ The next is kind of a hack to keep from escaping in the case\n-                    \/\/ of Shift_JIS and the like.\n-\n-                    \/*\n-                    else if ((ch < m_maxCharacter) && (m_maxCharacter == 0xFFFF)\n-                    && (ch != 160))\n-                    {\n-                    writer.write(ch);  \/\/ no escaping in this case\n-                    }\n-                    else\n-                    *\/\n-                    String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\n-                    if (null != outputStringForChar)\n-                    {\n-                        writer.write(outputStringForChar);\n-                    }\n-                    else if (escapingNotNeeded(ch))\n-                    {\n-                        writer.write(ch); \/\/ no escaping in this case\n-                    }\n@@ -1446,3 +1425,15 @@\n-                        writer.write(\"&#\");\n-                        writer.write(Integer.toString(ch));\n-                        writer.write(';');\n+                        String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\n+                        if (null != outputStringForChar)\n+                        {\n+                            writer.write(outputStringForChar);\n+                        }\n+                        else if (escapingNotNeeded(ch))\n+                        {\n+                            writer.write(ch); \/\/ no escaping in this case\n+                        }\n+                        else\n+                        {\n+                            writer.write(\"&#\");\n+                            writer.write(Integer.toString(ch));\n+                            writer.write(';');\n+                        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToHTMLStream.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-javac.opt.arg.release=\\\n-    <release>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+    \/\/ flag indicating whether the current token is NSS\n+    final transient boolean isNSS;\n+\n@@ -139,1 +142,1 @@\n-        boolean isNSS = (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n+        isNSS = (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n@@ -240,1 +243,2 @@\n-                (\"Cannot serialize sensitive and unextractable keys\");\n+                    (\"Cannot serialize sensitive, unextractable \" + (isNSS ?\n+                    \", and NSS token keys\" : \"keys\"));\n@@ -463,1 +467,1 @@\n-            if (sensitive || (extractable == false)) {\n+            if (sensitive || !extractable || (isNSS && tokenObject)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -61,1 +63,1 @@\n-            } else if (\"X.509\".equals(key.getFormat())) {\n+            } else {\n@@ -63,2 +65,2 @@\n-                byte[] encoded = key.getEncoded();\n-                key = RSAPublicKeyImpl.newKey(encoded);\n+                key = RSAPublicKeyImpl.newKey(KeyType.RSA, key.getFormat(),\n+                        key.getEncoded());\n@@ -66,3 +68,0 @@\n-            } else {\n-                throw new InvalidKeyException(\"PublicKey must be instance \"\n-                        + \"of RSAPublicKey or have X.509 encoding\");\n@@ -96,1 +95,1 @@\n-            } else if (\"PKCS#8\".equals(key.getFormat())) {\n+            } else {\n@@ -98,2 +97,2 @@\n-                byte[] encoded = key.getEncoded();\n-                key = sun.security.rsa.RSAPrivateCrtKeyImpl.newKey(encoded);\n+                key = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA, key.getFormat(),\n+                        key.getEncoded());\n@@ -101,3 +100,0 @@\n-            } else {\n-                throw new InvalidKeyException(\"Private key must be instance \"\n-                        + \"of RSAPrivate(Crt)Key or have PKCS#8 encoding\");\n@@ -116,2 +112,2 @@\n-                byte[] encoded = ((X509EncodedKeySpec)keySpec).getEncoded();\n-                PublicKey key = RSAPublicKeyImpl.newKey(encoded);\n+                PublicKey key = RSAPublicKeyImpl.newKey(KeyType.RSA, \"X.509\",\n+                        ((X509EncodedKeySpec)keySpec).getEncoded());\n@@ -146,3 +142,2 @@\n-                byte[] encoded = ((PKCS8EncodedKeySpec)keySpec).getEncoded();\n-                PrivateKey key =\n-                        sun.security.rsa.RSAPrivateCrtKeyImpl.newKey(encoded);\n+                PrivateKey key = RSAPrivateCrtKeyImpl.newKey(KeyType.RSA,\n+                        \"PKCS#8\", ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n@@ -411,4 +412,0 @@\n-    private static String[] s(String ...aliases) {\n-        return aliases;\n-    }\n-\n@@ -419,1 +416,1 @@\n-        final String[] aliases;\n+        final List<String> aliases;\n@@ -423,1 +420,1 @@\n-                String[] aliases, int[] mechanisms) {\n+                List<String> aliases, int[] mechanisms) {\n@@ -466,1 +463,1 @@\n-            String[] aliases, int[] m) {\n+            List<String> aliases, int[] m) {\n@@ -470,0 +467,6 @@\n+    private static void dA(String type, String algorithm, String className,\n+            int[] m) {\n+        register(new Descriptor(type, algorithm, className,\n+                getAliases(algorithm), m));\n+    }\n+\n@@ -531,2 +534,1 @@\n-        d(MD, \"SHA1\",           P11Digest,\n-                s(\"SHA\", \"SHA-1\", \"1.3.14.3.2.26\", \"OID.1.3.14.3.2.26\"),\n+        dA(MD, \"SHA-1\",           P11Digest,\n@@ -535,2 +537,1 @@\n-        d(MD, \"SHA-224\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.4\", \"OID.2.16.840.1.101.3.4.2.4\"),\n+        dA(MD, \"SHA-224\",        P11Digest,\n@@ -538,2 +539,1 @@\n-        d(MD, \"SHA-256\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.1\", \"OID.2.16.840.1.101.3.4.2.1\"),\n+        dA(MD, \"SHA-256\",        P11Digest,\n@@ -541,2 +541,1 @@\n-        d(MD, \"SHA-384\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.2\", \"OID.2.16.840.1.101.3.4.2.2\"),\n+        dA(MD, \"SHA-384\",        P11Digest,\n@@ -544,2 +543,1 @@\n-        d(MD, \"SHA-512\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.3\", \"OID.2.16.840.1.101.3.4.2.3\"),\n+        dA(MD, \"SHA-512\",        P11Digest,\n@@ -547,2 +545,1 @@\n-        d(MD, \"SHA-512\/224\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.5\", \"OID.2.16.840.1.101.3.4.2.5\"),\n+        dA(MD, \"SHA-512\/224\",        P11Digest,\n@@ -550,2 +547,1 @@\n-        d(MD, \"SHA-512\/256\",        P11Digest,\n-                s(\"2.16.840.1.101.3.4.2.6\", \"OID.2.16.840.1.101.3.4.2.6\"),\n+        dA(MD, \"SHA-512\/256\",        P11Digest,\n@@ -556,2 +552,1 @@\n-        d(MAC, \"HmacSHA1\",      P11MAC,\n-                s(\"1.2.840.113549.2.7\", \"OID.1.2.840.113549.2.7\"),\n+        dA(MAC, \"HmacSHA1\",      P11MAC,\n@@ -559,2 +554,1 @@\n-        d(MAC, \"HmacSHA224\",    P11MAC,\n-                s(\"1.2.840.113549.2.8\", \"OID.1.2.840.113549.2.8\"),\n+        dA(MAC, \"HmacSHA224\",    P11MAC,\n@@ -562,2 +556,1 @@\n-        d(MAC, \"HmacSHA256\",    P11MAC,\n-                s(\"1.2.840.113549.2.9\", \"OID.1.2.840.113549.2.9\"),\n+        dA(MAC, \"HmacSHA256\",    P11MAC,\n@@ -565,2 +558,1 @@\n-        d(MAC, \"HmacSHA384\",    P11MAC,\n-                s(\"1.2.840.113549.2.10\", \"OID.1.2.840.113549.2.10\"),\n+        dA(MAC, \"HmacSHA384\",    P11MAC,\n@@ -568,2 +560,1 @@\n-        d(MAC, \"HmacSHA512\",    P11MAC,\n-                s(\"1.2.840.113549.2.11\", \"OID.1.2.840.113549.2.11\"),\n+        dA(MAC, \"HmacSHA512\",    P11MAC,\n@@ -571,2 +562,1 @@\n-        d(MAC, \"HmacSHA512\/224\",    P11MAC,\n-                s(\"1.2.840.113549.2.12\", \"OID.1.2.840.113549.2.12\"),\n+        dA(MAC, \"HmacSHA512\/224\",    P11MAC,\n@@ -574,2 +564,1 @@\n-        d(MAC, \"HmacSHA512\/256\",    P11MAC,\n-                s(\"1.2.840.113549.2.13\", \"OID.1.2.840.113549.2.13\"),\n+        dA(MAC, \"HmacSHA512\/256\",    P11MAC,\n@@ -584,1 +573,1 @@\n-                s(\"1.2.840.113549.1.1\", \"OID.1.2.840.113549.1.1\"),\n+                getAliases(\"PKCS1\"),\n@@ -587,2 +576,3 @@\n-        d(KPG, \"DSA\",           P11KeyPairGenerator,\n-                s(\"1.3.14.3.2.12\", \"1.2.840.10040.4.1\", \"OID.1.2.840.10040.4.1\"),\n+        List<String> dhAlias = List.of(\"DiffieHellman\");\n+\n+        dA(KPG, \"DSA\",           P11KeyPairGenerator,\n@@ -590,1 +580,2 @@\n-        d(KPG, \"DH\",            P11KeyPairGenerator,    s(\"DiffieHellman\"),\n+        d(KPG, \"DH\",            P11KeyPairGenerator,\n+                dhAlias,\n@@ -595,1 +586,1 @@\n-        d(KG,  \"ARCFOUR\",       P11KeyGenerator,        s(\"RC4\"),\n+        dA(KG,  \"ARCFOUR\",       P11KeyGenerator,\n@@ -611,1 +602,1 @@\n-                s(\"1.2.840.113549.1.1\", \"OID.1.2.840.113549.1.1\"),\n+                getAliases(\"PKCS1\"),\n@@ -613,2 +604,1 @@\n-        d(KF, \"DSA\",            P11DSAKeyFactory,\n-                s(\"1.3.14.3.2.12\", \"1.2.840.10040.4.1\", \"OID.1.2.840.10040.4.1\"),\n+        dA(KF, \"DSA\",            P11DSAKeyFactory,\n@@ -616,1 +606,2 @@\n-        d(KF, \"DH\",             P11DHKeyFactory,        s(\"DiffieHellman\"),\n+        d(KF, \"DH\",             P11DHKeyFactory,\n+                dhAlias,\n@@ -624,2 +615,1 @@\n-        d(AGP, \"EC\",            \"sun.security.util.ECParameters\",\n-                s(\"1.2.840.10045.2.1\"),\n+        dA(AGP, \"EC\",            \"sun.security.util.ECParameters\",\n@@ -633,1 +623,1 @@\n-        d(AGP, \"ChaCha20-Poly1305\",\n+        dA(AGP, \"ChaCha20-Poly1305\",\n@@ -635,1 +625,0 @@\n-                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n@@ -638,1 +627,2 @@\n-        d(KA, \"DH\",             P11KeyAgreement,        s(\"DiffieHellman\"),\n+        d(KA, \"DH\",             P11KeyAgreement,\n+                dhAlias,\n@@ -643,1 +633,1 @@\n-        d(SKF, \"ARCFOUR\",       P11SecretKeyFactory,    s(\"RC4\"),\n+        dA(SKF, \"ARCFOUR\",      P11SecretKeyFactory,\n@@ -649,2 +639,1 @@\n-        d(SKF, \"AES\",           P11SecretKeyFactory,\n-                s(\"2.16.840.1.101.3.4.1\", \"OID.2.16.840.1.101.3.4.1\"),\n+        dA(SKF, \"AES\",          P11SecretKeyFactory,\n@@ -658,1 +647,1 @@\n-        d(CIP, \"ARCFOUR\",                       P11Cipher,      s(\"RC4\"),\n+        dA(CIP, \"ARCFOUR\",                      P11Cipher,\n@@ -666,1 +655,2 @@\n-        d(CIP, \"DES\/ECB\/PKCS5Padding\",          P11Cipher,      s(\"DES\"),\n+        d(CIP, \"DES\/ECB\/PKCS5Padding\",          P11Cipher,\n+                List.of(\"DES\"),\n@@ -675,1 +665,2 @@\n-        d(CIP, \"DESede\/ECB\/PKCS5Padding\",       P11Cipher,      s(\"DESede\"),\n+        d(CIP, \"DESede\/ECB\/PKCS5Padding\",       P11Cipher,\n+                List.of(\"DESede\"),\n@@ -679,2 +670,1 @@\n-        d(CIP, \"AES_128\/CBC\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.2\", \"OID.2.16.840.1.101.3.4.1.2\"),\n+        dA(CIP, \"AES_128\/CBC\/NoPadding\",        P11Cipher,\n@@ -682,2 +672,1 @@\n-        d(CIP, \"AES_192\/CBC\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.22\", \"OID.2.16.840.1.101.3.4.1.22\"),\n+        dA(CIP, \"AES_192\/CBC\/NoPadding\",        P11Cipher,\n@@ -685,2 +674,1 @@\n-        d(CIP, \"AES_256\/CBC\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.42\", \"OID.2.16.840.1.101.3.4.1.42\"),\n+        dA(CIP, \"AES_256\/CBC\/NoPadding\",        P11Cipher,\n@@ -692,2 +680,1 @@\n-        d(CIP, \"AES_128\/ECB\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.1\", \"OID.2.16.840.1.101.3.4.1.1\"),\n+        dA(CIP, \"AES_128\/ECB\/NoPadding\",        P11Cipher,\n@@ -695,2 +682,1 @@\n-        d(CIP, \"AES_192\/ECB\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.21\", \"OID.2.16.840.1.101.3.4.1.21\"),\n+        dA(CIP, \"AES_192\/ECB\/NoPadding\",        P11Cipher,\n@@ -698,2 +684,1 @@\n-        d(CIP, \"AES_256\/ECB\/NoPadding\",          P11Cipher,\n-                s(\"2.16.840.1.101.3.4.1.41\", \"OID.2.16.840.1.101.3.4.1.41\"),\n+        dA(CIP, \"AES_256\/ECB\/NoPadding\",        P11Cipher,\n@@ -701,1 +686,2 @@\n-        d(CIP, \"AES\/ECB\/PKCS5Padding\",          P11Cipher,      s(\"AES\"),\n+        d(CIP, \"AES\/ECB\/PKCS5Padding\",          P11Cipher,\n+                List.of(\"AES\"),\n@@ -708,2 +694,1 @@\n-        d(CIP, \"AES_128\/GCM\/NoPadding\",          P11AEADCipher,\n-                s(\"2.16.840.1.101.3.4.1.6\", \"OID.2.16.840.1.101.3.4.1.6\"),\n+        dA(CIP, \"AES_128\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -711,2 +696,1 @@\n-        d(CIP, \"AES_192\/GCM\/NoPadding\",          P11AEADCipher,\n-                s(\"2.16.840.1.101.3.4.1.26\", \"OID.2.16.840.1.101.3.4.1.26\"),\n+        dA(CIP, \"AES_192\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -714,2 +698,1 @@\n-        d(CIP, \"AES_256\/GCM\/NoPadding\",          P11AEADCipher,\n-                s(\"2.16.840.1.101.3.4.1.46\", \"OID.2.16.840.1.101.3.4.1.46\"),\n+        dA(CIP, \"AES_256\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -723,2 +706,1 @@\n-        d(CIP, \"ChaCha20-Poly1305\",             P11AEADCipher,\n-                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n+        dA(CIP, \"ChaCha20-Poly1305\",            P11AEADCipher,\n@@ -727,1 +709,2 @@\n-        d(CIP, \"RSA\/ECB\/PKCS1Padding\",          P11RSACipher,   s(\"RSA\"),\n+        d(CIP, \"RSA\/ECB\/PKCS1Padding\",          P11RSACipher,\n+                List.of(\"RSA\"),\n@@ -732,1 +715,2 @@\n-        d(SIG, \"RawDSA\",        P11Signature,   s(\"NONEwithDSA\"),\n+        d(SIG, \"RawDSA\",        P11Signature,\n+                List.of(\"NONEwithDSA\"),\n@@ -734,3 +718,1 @@\n-        d(SIG, \"DSA\",           P11Signature,\n-                s(\"SHA1withDSA\", \"1.3.14.3.2.13\", \"1.3.14.3.2.27\",\n-                  \"1.2.840.10040.4.3\", \"OID.1.2.840.10040.4.3\"),\n+        dA(SIG, \"SHA1withDSA\",           P11Signature,\n@@ -738,2 +720,1 @@\n-        d(SIG, \"SHA224withDSA\", P11Signature,\n-                s(\"2.16.840.1.101.3.4.3.1\", \"OID.2.16.840.1.101.3.4.3.1\"),\n+        dA(SIG, \"SHA224withDSA\", P11Signature,\n@@ -741,2 +722,1 @@\n-        d(SIG, \"SHA256withDSA\", P11Signature,\n-                s(\"2.16.840.1.101.3.4.3.2\", \"OID.2.16.840.1.101.3.4.3.2\"),\n+        dA(SIG, \"SHA256withDSA\", P11Signature,\n@@ -744,2 +724,1 @@\n-        d(SIG, \"SHA384withDSA\", P11Signature,\n-                s(\"2.16.840.1.101.3.4.3.3\", \"OID.2.16.840.1.101.3.4.3.3\"),\n+        dA(SIG, \"SHA384withDSA\", P11Signature,\n@@ -747,2 +726,1 @@\n-        d(SIG, \"SHA512withDSA\", P11Signature,\n-                s(\"2.16.840.1.101.3.4.3.4\", \"OID.2.16.840.1.101.3.4.3.4\"),\n+        dA(SIG, \"SHA512withDSA\", P11Signature,\n@@ -751,1 +729,1 @@\n-                s(\"NONEwithDSAinP1363Format\"),\n+                List.of(\"NONEwithDSAinP1363Format\"),\n@@ -754,1 +732,1 @@\n-                s(\"SHA1withDSAinP1363Format\"),\n+                List.of(\"SHA1withDSAinP1363Format\"),\n@@ -759,2 +737,1 @@\n-        d(SIG, \"SHA1withECDSA\", P11Signature,\n-                s(\"ECDSA\", \"1.2.840.10045.4.1\", \"OID.1.2.840.10045.4.1\"),\n+        dA(SIG, \"SHA1withECDSA\", P11Signature,\n@@ -762,2 +739,1 @@\n-        d(SIG, \"SHA224withECDSA\",       P11Signature,\n-                s(\"1.2.840.10045.4.3.1\", \"OID.1.2.840.10045.4.3.1\"),\n+        dA(SIG, \"SHA224withECDSA\",       P11Signature,\n@@ -765,2 +741,1 @@\n-        d(SIG, \"SHA256withECDSA\",       P11Signature,\n-                s(\"1.2.840.10045.4.3.2\", \"OID.1.2.840.10045.4.3.2\"),\n+        dA(SIG, \"SHA256withECDSA\",       P11Signature,\n@@ -768,2 +743,1 @@\n-        d(SIG, \"SHA384withECDSA\",       P11Signature,\n-                s(\"1.2.840.10045.4.3.3\", \"OID.1.2.840.10045.4.3.3\"),\n+        dA(SIG, \"SHA384withECDSA\",       P11Signature,\n@@ -771,2 +745,1 @@\n-        d(SIG, \"SHA512withECDSA\",       P11Signature,\n-                s(\"1.2.840.10045.4.3.4\", \"OID.1.2.840.10045.4.3.4\"),\n+        dA(SIG, \"SHA512withECDSA\",       P11Signature,\n@@ -786,2 +759,1 @@\n-        d(SIG, \"MD2withRSA\",    P11Signature,\n-                s(\"1.2.840.113549.1.1.2\", \"OID.1.2.840.113549.1.1.2\"),\n+        dA(SIG, \"MD2withRSA\",    P11Signature,\n@@ -789,2 +761,1 @@\n-        d(SIG, \"MD5withRSA\",    P11Signature,\n-                s(\"1.2.840.113549.1.1.4\", \"OID.1.2.840.113549.1.1.4\"),\n+        dA(SIG, \"MD5withRSA\",    P11Signature,\n@@ -792,3 +763,1 @@\n-        d(SIG, \"SHA1withRSA\",   P11Signature,\n-                s(\"1.2.840.113549.1.1.5\", \"OID.1.2.840.113549.1.1.5\",\n-                  \"1.3.14.3.2.29\"),\n+        dA(SIG, \"SHA1withRSA\",   P11Signature,\n@@ -796,2 +765,1 @@\n-        d(SIG, \"SHA224withRSA\", P11Signature,\n-                s(\"1.2.840.113549.1.1.14\", \"OID.1.2.840.113549.1.1.14\"),\n+        dA(SIG, \"SHA224withRSA\", P11Signature,\n@@ -799,2 +767,1 @@\n-        d(SIG, \"SHA256withRSA\", P11Signature,\n-                s(\"1.2.840.113549.1.1.11\", \"OID.1.2.840.113549.1.1.11\"),\n+        dA(SIG, \"SHA256withRSA\", P11Signature,\n@@ -802,2 +769,1 @@\n-        d(SIG, \"SHA384withRSA\", P11Signature,\n-                s(\"1.2.840.113549.1.1.12\", \"OID.1.2.840.113549.1.1.12\"),\n+        dA(SIG, \"SHA384withRSA\", P11Signature,\n@@ -805,2 +771,1 @@\n-        d(SIG, \"SHA512withRSA\", P11Signature,\n-                s(\"1.2.840.113549.1.1.13\", \"OID.1.2.840.113549.1.1.13\"),\n+        dA(SIG, \"SHA512withRSA\", P11Signature,\n@@ -808,2 +773,1 @@\n-        d(SIG, \"RSASSA-PSS\", P11PSSSignature,\n-                s(\"1.2.840.113549.1.1.10\", \"OID.1.2.840.113549.1.1.10\"),\n+        dA(SIG, \"RSASSA-PSS\", P11PSSSignature,\n@@ -824,1 +788,1 @@\n-                    s(\"SunTls12RsaPremasterSecret\"),\n+                List.of(\"SunTls12RsaPremasterSecret\"),\n@@ -1131,1 +1095,1 @@\n-                        s(\"PKCS11-\" + config.getName()),\n+                        List.of(\"PKCS11-\" + config.getName()),\n@@ -1151,2 +1115,2 @@\n-                String className, String[] al, long mechanism) {\n-            super(token.provider, type, algorithm, className, toList(al),\n+                String className, List<String> al, long mechanism) {\n+            super(token.provider, type, algorithm, className, al,\n@@ -1158,4 +1122,0 @@\n-        private static List<String> toList(String[] aliases) {\n-            return (aliases == null) ? null : Arrays.asList(aliases);\n-        }\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":86,"deletions":126,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.regex.Pattern;\n@@ -35,0 +34,1 @@\n+import static sun.security.util.SecurityProviderConstants.*;\n@@ -72,0 +72,7 @@\n+    private static class ProviderServiceA extends ProviderService {\n+        ProviderServiceA(Provider p, String type, String algo, String cn,\n+            HashMap<String, String> attrs) {\n+            super(p, type, algo, cn, getAliases(algo), attrs);\n+        }\n+    }\n+\n@@ -79,3 +86,2 @@\n-            String[] aliases, HashMap<String, String> attrs) {\n-            super(p, type, algo, cn,\n-                  (aliases == null? null : Arrays.asList(aliases)), attrs);\n+            List<String> aliases, HashMap<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n@@ -187,1 +193,1 @@\n-            new String[] { \"EllipticCurve\" }, ATTRS));\n+            List.of(\"EllipticCurve\"), ATTRS));\n@@ -195,1 +201,0 @@\n-        Pattern nameSplitPattern = Pattern.compile(CurveDB.SPLIT_PATTERN);\n@@ -207,2 +212,1 @@\n-\n-            String[] commonNames = nameSplitPattern.split(namedCurve.getName());\n+            String[] commonNames = namedCurve.getNameAndAliases();\n@@ -210,1 +214,1 @@\n-                names.append(commonName.trim());\n+                names.append(commonName);\n@@ -221,4 +225,2 @@\n-        putService(new ProviderService(this, \"AlgorithmParameters\",\n-            \"EC\", \"sun.security.util.ECParameters\",\n-            new String[] { \"EllipticCurve\", \"1.2.840.10045.2.1\", \"OID.1.2.840.10045.2.1\" },\n-            apAttrs));\n+        putService(new ProviderServiceA(this, \"AlgorithmParameters\",\n+            \"EC\", \"sun.security.util.ECParameters\", apAttrs));\n@@ -242,1 +244,1 @@\n-        putService(new ProviderService(this, \"Signature\",\n+        putService(new ProviderServiceA(this, \"Signature\",\n@@ -244,1 +246,0 @@\n-            new String[] { \"1.2.840.10045.4.1\", \"OID.1.2.840.10045.4.1\" },\n@@ -246,1 +247,1 @@\n-        putService(new ProviderService(this, \"Signature\",\n+        putService(new ProviderServiceA(this, \"Signature\",\n@@ -248,1 +249,0 @@\n-            new String[] { \"1.2.840.10045.4.3.1\", \"OID.1.2.840.10045.4.3.1\"},\n@@ -250,1 +250,1 @@\n-        putService(new ProviderService(this, \"Signature\",\n+        putService(new ProviderServiceA(this, \"Signature\",\n@@ -252,1 +252,0 @@\n-            new String[] { \"1.2.840.10045.4.3.2\", \"OID.1.2.840.10045.4.3.2\"},\n@@ -254,1 +253,1 @@\n-        putService(new ProviderService(this, \"Signature\",\n+        putService(new ProviderServiceA(this, \"Signature\",\n@@ -256,1 +255,0 @@\n-            new String[] { \"1.2.840.10045.4.3.3\", \"OID.1.2.840.10045.4.3.3\" },\n@@ -258,1 +256,1 @@\n-        putService(new ProviderService(this, \"Signature\",\n+        putService(new ProviderServiceA(this, \"Signature\",\n@@ -260,1 +258,0 @@\n-            new String[] { \"1.2.840.10045.4.3.4\", \"OID.1.2.840.10045.4.3.4\" },\n@@ -287,1 +284,1 @@\n-            new String[] { \"EllipticCurve\" }, ATTRS));\n+            List.of(\"EllipticCurve\"), ATTRS));\n@@ -304,1 +301,1 @@\n-        putService(new ProviderService(this, \"KeyFactory\",\n+        putService(new ProviderServiceA(this, \"KeyFactory\",\n@@ -306,2 +303,2 @@\n-            new String[]{\"1.3.101.110\", \"OID.1.3.101.110\"}, ATTRS));\n-        putService(new ProviderService(this, \"KeyFactory\",\n+            ATTRS));\n+        putService(new ProviderServiceA(this, \"KeyFactory\",\n@@ -309,1 +306,1 @@\n-            new String[]{\"1.3.101.111\", \"OID.1.3.101.111\"}, ATTRS));\n+            ATTRS));\n@@ -313,1 +310,1 @@\n-        putService(new ProviderService(this, \"KeyPairGenerator\",\n+        putService(new ProviderServiceA(this, \"KeyPairGenerator\",\n@@ -315,2 +312,2 @@\n-            new String[]{\"1.3.101.110\", \"OID.1.3.101.110\"}, ATTRS));\n-        putService(new ProviderService(this, \"KeyPairGenerator\",\n+            ATTRS));\n+        putService(new ProviderServiceA(this, \"KeyPairGenerator\",\n@@ -318,1 +315,1 @@\n-            new String[]{\"1.3.101.111\", \"OID.1.3.101.111\"}, ATTRS));\n+            ATTRS));\n@@ -322,1 +319,1 @@\n-        putService(new ProviderService(this, \"KeyAgreement\",\n+        putService(new ProviderServiceA(this, \"KeyAgreement\",\n@@ -324,2 +321,2 @@\n-            new String[]{\"1.3.101.110\", \"OID.1.3.101.110\"}, ATTRS));\n-        putService(new ProviderService(this, \"KeyAgreement\",\n+            ATTRS));\n+        putService(new ProviderServiceA(this, \"KeyAgreement\",\n@@ -327,2 +324,1 @@\n-            new String[]{\"1.3.101.111\", \"OID.1.3.101.111\"}, ATTRS));\n-\n+            ATTRS));\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,2 +123,2 @@\n-            addParameters(255, p, 121665, (byte) 0x09, 3,\n-                new int[]{1, 3, 101, 110}, NamedParameterSpec.X25519.getName(),\n+            addParameters(255, p, 121665, (byte)0x09, 3,\n+                \"1.3.101.110\", NamedParameterSpec.X25519.getName(),\n@@ -135,2 +135,2 @@\n-            addParameters(448, p, 39081, (byte) 0x05, 2,\n-                new int[]{1, 3, 101, 111}, NamedParameterSpec.X448.getName(),\n+            addParameters(448, p, 39081, (byte)0x05, 2,\n+                \"1.3.101.111\", NamedParameterSpec.X448.getName(),\n@@ -149,1 +149,1 @@\n-        byte basePoint, int logCofactor, int[] oidBytes, String name,\n+        byte basePoint, int logCofactor, String objectId, String name,\n@@ -154,1 +154,1 @@\n-        ObjectIdentifier oid = new ObjectIdentifier(oidBytes);\n+        ObjectIdentifier oid = ObjectIdentifier.of(objectId);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XECParameters.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import java.util.Arrays;\n+import java.util.List;\n@@ -38,0 +38,1 @@\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n@@ -59,0 +60,6 @@\n+    private static class ProviderServiceA extends ProviderService {\n+        ProviderServiceA(Provider p, String type, String algo, String cn,\n+                HashMap<String, String> attrs) {\n+            super(p, type, algo, cn, getAliases(algo), attrs);\n+        }\n+    }\n@@ -60,1 +67,1 @@\n-    private static final class ProviderService extends Provider.Service {\n+    private static class ProviderService extends Provider.Service {\n@@ -66,3 +73,2 @@\n-            String[] aliases, HashMap<String, String> attrs) {\n-            super(p, type, algo, cn,\n-                  (aliases == null? null : Arrays.asList(aliases)), attrs);\n+            List<String> aliases, HashMap<String, String> attrs) {\n+            super(p, type, algo, cn, aliases, attrs);\n@@ -191,3 +197,3 @@\n-                putService(new ProviderService(p, \"Signature\",\n-                           \"SHA256withRSA\", \"sun.security.mscapi.CSignature$SHA256withRSA\",\n-                           new String[] { \"1.2.840.113549.1.1.11\", \"OID.1.2.840.113549.1.1.11\" },\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA256withRSA\",\n+                           \"sun.security.mscapi.CSignature$SHA256withRSA\",\n@@ -195,3 +201,3 @@\n-                putService(new ProviderService(p, \"Signature\",\n-                           \"SHA384withRSA\", \"sun.security.mscapi.CSignature$SHA384withRSA\",\n-                           new String[] { \"1.2.840.113549.1.1.12\", \"OID.1.2.840.113549.1.1.12\" },\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA384withRSA\",\n+                           \"sun.security.mscapi.CSignature$SHA384withRSA\",\n@@ -199,3 +205,6 @@\n-                putService(new ProviderService(p, \"Signature\",\n-                           \"SHA512withRSA\", \"sun.security.mscapi.CSignature$SHA512withRSA\",\n-                           new String[] { \"1.2.840.113549.1.1.13\", \"OID.1.2.840.113549.1.1.13\" },\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA512withRSA\",\n+                           \"sun.security.mscapi.CSignature$SHA512withRSA\",\n+                           attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"RSASSA-PSS\", \"sun.security.mscapi.CSignature$PSS\",\n@@ -203,4 +212,0 @@\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"RSASSA-PSS\", \"sun.security.mscapi.CSignature$PSS\",\n-                        new String[] { \"1.2.840.113549.1.1.10\", \"OID.1.2.840.113549.1.1.10\" },\n-                        attrs));\n@@ -213,20 +218,20 @@\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"SHA1withECDSA\", \"sun.security.mscapi.CSignature$SHA1withECDSA\",\n-                        new String[] { \"1.2.840.10045.4.1\", \"OID.1.2.840.10045.4.1\" },\n-                        attrs));\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"SHA224withECDSA\", \"sun.security.mscapi.CSignature$SHA224withECDSA\",\n-                        new String[] { \"1.2.840.10045.4.3.1\", \"OID.1.2.840.10045.4.3.1\"},\n-                        attrs));\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"SHA256withECDSA\", \"sun.security.mscapi.CSignature$SHA256withECDSA\",\n-                        new String[] { \"1.2.840.10045.4.3.2\", \"OID.1.2.840.10045.4.3.2\"},\n-                        attrs));\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"SHA384withECDSA\", \"sun.security.mscapi.CSignature$SHA384withECDSA\",\n-                        new String[] { \"1.2.840.10045.4.3.3\", \"OID.1.2.840.10045.4.3.3\"},\n-                        attrs));\n-                putService(new ProviderService(p, \"Signature\",\n-                        \"SHA512withECDSA\", \"sun.security.mscapi.CSignature$SHA512withECDSA\",\n-                        new String[] { \"1.2.840.10045.4.3.4\", \"OID.1.2.840.10045.4.3.4\"},\n-                        attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA1withECDSA\",\n+                           \"sun.security.mscapi.CSignature$SHA1withECDSA\",\n+                           attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA224withECDSA\",\n+                           \"sun.security.mscapi.CSignature$SHA224withECDSA\",\n+                           attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA256withECDSA\",\n+                           \"sun.security.mscapi.CSignature$SHA256withECDSA\",\n+                           attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA384withECDSA\",\n+                           \"sun.security.mscapi.CSignature$SHA384withECDSA\",\n+                           attrs));\n+                putService(new ProviderServiceA(p, \"Signature\",\n+                           \"SHA512withECDSA\",\n+                           \"sun.security.mscapi.CSignature$SHA512withECDSA\",\n+                           attrs));\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":44,"deletions":39,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.List;\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n+\n@@ -39,2 +42,2 @@\n-        { sd(\"MessageDigest\", \"SHA\", \"com.oracle.security.ucrypto.NativeDigestMD$SHA1\",\n-             \"SHA-1\", \"SHA1\")\n+        { sd(\"MessageDigest\", \"SHA-1\", \"com.oracle.security.ucrypto.NativeDigestMD$SHA1\",\n+             getAliases(\"SHA-1\"))\n@@ -44,1 +47,1 @@\n-             \"2.16.840.1.101.3.4.2.1\", \"OID.2.16.840.1.101.3.4.2.1\")\n+             getAliases(\"SHA-256\"))\n@@ -48,1 +51,1 @@\n-             \"2.16.840.1.101.3.4.2.2\", \"OID.2.16.840.1.101.3.4.2.2\")\n+             getAliases(\"SHA-384\"))\n@@ -52,1 +55,1 @@\n-             \"2.16.840.1.101.3.4.2.3\", \"OID.2.16.840.1.101.3.4.2.3\")\n+             getAliases(\"SHA-512\"))\n@@ -57,1 +60,6 @@\n-    private static ServiceDesc sd(String type, String algo, String cn, String... aliases) {\n+    private static ServiceDesc sd(String type, String algo, String cn) {\n+        return new ServiceDesc(type, algo, cn, null);\n+    }\n+\n+    private static ServiceDesc sd(String type, String algo, String cn,\n+            List<String> aliases) {\n","filename":"src\/jdk.crypto.ucrypto\/solaris\/classes\/com\/oracle\/security\/ucrypto\/LibMDMech.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    ServiceDesc(String type, String algo, String cn, String[] aliases) {\n+    ServiceDesc(String type, String algo, String cn, List<String> aliases) {\n@@ -49,5 +49,1 @@\n-        if (aliases != null) {\n-            this.aliases = Arrays.asList(aliases);\n-        } else {\n-            this.aliases = null;\n-        }\n+        this.aliases = aliases;\n","filename":"src\/jdk.crypto.ucrypto\/solaris\/classes\/com\/oracle\/security\/ucrypto\/ServiceDesc.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.List;\n+import static sun.security.util.SecurityProviderConstants.getAliases;\n+\n@@ -39,7 +42,7 @@\n-             \"AES\"),\n-          sd(\"Cipher\", \"AES_128\/ECB\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\",\n-             \"2.16.840.1.101.3.4.1.1\", \"OID.2.16.840.1.101.3.4.1.1\"),\n-          sd(\"Cipher\", \"AES_192\/ECB\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\",\n-             \"2.16.840.1.101.3.4.1.21\", \"OID.2.16.840.1.101.3.4.1.21\"),\n-          sd(\"Cipher\", \"AES_256\/ECB\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\",\n-             \"2.16.840.1.101.3.4.1.41\", \"OID.2.16.840.1.101.3.4.1.41\")\n+             List.of(\"AES\")),\n+          sdA(\"Cipher\", \"AES_128\/ECB\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\"),\n+          sdA(\"Cipher\", \"AES_192\/ECB\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\"),\n+          sdA(\"Cipher\", \"AES_256\/ECB\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesEcbNoPadding\")\n@@ -50,6 +53,6 @@\n-          sd(\"Cipher\", \"AES_128\/CBC\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\",\n-             \"2.16.840.1.101.3.4.1.2\", \"OID.2.16.840.1.101.3.4.1.2\"),\n-          sd(\"Cipher\", \"AES_192\/CBC\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\",\n-             \"2.16.840.1.101.3.4.1.22\", \"OID.2.16.840.1.101.3.4.1.22\"),\n-          sd(\"Cipher\", \"AES_256\/CBC\/NoPadding\", \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\",\n-             \"2.16.840.1.101.3.4.1.42\", \"OID.2.16.840.1.101.3.4.1.42\")\n+          sdA(\"Cipher\", \"AES_128\/CBC\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\"),\n+          sdA(\"Cipher\", \"AES_192\/CBC\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\"),\n+          sdA(\"Cipher\", \"AES_256\/CBC\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeCipher$AesCbcNoPadding\")\n@@ -63,6 +66,6 @@\n-          sd(\"Cipher\", \"AES_128\/GCM\/NoPadding\", \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\",\n-             \"2.16.840.1.101.3.4.1.6\", \"OID.2.16.840.1.101.3.4.1.6\"),\n-          sd(\"Cipher\", \"AES_192\/GCM\/NoPadding\", \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\",\n-             \"2.16.840.1.101.3.4.1.26\", \"OID.2.16.840.1.101.3.4.1.26\"),\n-          sd(\"Cipher\", \"AES_256\/GCM\/NoPadding\", \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\",\n-             \"2.16.840.1.101.3.4.1.46\", \"OID.2.16.840.1.101.3.4.1.46\")\n+          sdA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\"),\n+          sdA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\"),\n+          sdA(\"Cipher\", \"AES_256\/GCM\/NoPadding\",\n+              \"com.oracle.security.ucrypto.NativeGCMCipher$AesGcmNoPadding\")\n@@ -78,1 +81,1 @@\n-             \"RSA\")\n+             List.of(\"RSA\"))\n@@ -83,2 +86,2 @@\n-        { sd(\"Signature\", \"MD5withRSA\", \"com.oracle.security.ucrypto.NativeRSASignature$MD5\",\n-             \"1.2.840.113549.1.1.4\", \"OID.1.2.840.113549.1.1.4\")\n+        { sdA(\"Signature\", \"MD5withRSA\",\n+              \"com.oracle.security.ucrypto.NativeRSASignature$MD5\")\n@@ -87,3 +90,2 @@\n-        { sd(\"Signature\", \"SHA1withRSA\", \"com.oracle.security.ucrypto.NativeRSASignature$SHA1\",\n-             \"1.2.840.113549.1.1.5\", \"OID.1.2.840.113549.1.1.5\",\n-             \"1.3.14.3.2.29\")\n+        { sdA(\"Signature\", \"SHA1withRSA\",\n+              \"com.oracle.security.ucrypto.NativeRSASignature$SHA1\")\n@@ -92,2 +94,2 @@\n-        { sd(\"Signature\", \"SHA256withRSA\", \"com.oracle.security.ucrypto.NativeRSASignature$SHA256\",\n-             \"1.2.840.113549.1.1.11\", \"OID.1.2.840.113549.1.1.11\")\n+        { sdA(\"Signature\", \"SHA256withRSA\",\n+              \"com.oracle.security.ucrypto.NativeRSASignature$SHA256\")\n@@ -96,2 +98,2 @@\n-        { sd(\"Signature\", \"SHA384withRSA\", \"com.oracle.security.ucrypto.NativeRSASignature$SHA384\",\n-             \"1.2.840.113549.1.1.12\", \"OID.1.2.840.113549.1.1.12\")\n+        { sdA(\"Signature\", \"SHA384withRSA\",\n+              \"com.oracle.security.ucrypto.NativeRSASignature$SHA384\")\n@@ -100,2 +102,2 @@\n-        { sd(\"Signature\", \"SHA512withRSA\", \"com.oracle.security.ucrypto.NativeRSASignature$SHA512\",\n-             \"1.2.840.113549.1.1.13\", \"OID.1.2.840.113549.1.1.13\")\n+        { sdA(\"Signature\", \"SHA512withRSA\",\n+             \"com.oracle.security.ucrypto.NativeRSASignature$SHA512\")\n@@ -105,1 +107,2 @@\n-        { sd(\"MessageDigest\", \"MD5\", \"com.oracle.security.ucrypto.NativeDigest$MD5\") }),\n+        { sd(\"MessageDigest\", \"MD5\", \"com.oracle.security.ucrypto.NativeDigest$MD5\")\n+        }),\n@@ -107,1 +110,3 @@\n-        { sd(\"MessageDigest\", \"SHA\", \"com.oracle.security.ucrypto.NativeDigest$SHA1\", \"SHA-1\", \"SHA1\") }),\n+        { sdA(\"MessageDigest\", \"SHA-1\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA1\")\n+        }),\n@@ -109,3 +114,3 @@\n-        { sd(\"MessageDigest\", \"SHA-224\", \"com.oracle.security.ucrypto.NativeDigest$SHA224\",\n-             \"2.16.840.1.101.3.4.2.4\", \"OID.2.16.840.1.101.3.4.2.4\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA-224\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA224\")\n+        }),\n@@ -113,3 +118,3 @@\n-        { sd(\"MessageDigest\", \"SHA-256\", \"com.oracle.security.ucrypto.NativeDigest$SHA256\",\n-             \"2.16.840.1.101.3.4.2.1\", \"OID.2.16.840.1.101.3.4.2.1\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA-256\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA256\")\n+        }),\n@@ -117,3 +122,3 @@\n-        { sd(\"MessageDigest\", \"SHA-384\", \"com.oracle.security.ucrypto.NativeDigest$SHA384\",\n-             \"2.16.840.1.101.3.4.2.2\", \"OID.2.16.840.1.101.3.4.2.2\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA-384\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA384\")\n+        }),\n@@ -121,3 +126,3 @@\n-        { sd(\"MessageDigest\", \"SHA-512\", \"com.oracle.security.ucrypto.NativeDigest$SHA512\",\n-             \"2.16.840.1.101.3.4.2.3\", \"OID.2.16.840.1.101.3.4.2.3\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA-512\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA512\")\n+        }),\n@@ -125,3 +130,3 @@\n-        { sd(\"MessageDigest\", \"SHA3-224\", \"com.oracle.security.ucrypto.NativeDigest$SHA3_224\",\n-             \"2.16.840.1.101.3.4.2.7\", \"OID.2.16.840.1.101.3.4.2.7\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA3-224\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA3_224\")\n+        }),\n@@ -129,3 +134,3 @@\n-        { sd(\"MessageDigest\", \"SHA3-256\", \"com.oracle.security.ucrypto.NativeDigest$SHA3_256\",\n-             \"2.16.840.1.101.3.4.2.8\", \"OID.2.16.840.1.101.3.4.2.8\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA3-256\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA3_256\")\n+        }),\n@@ -133,3 +138,3 @@\n-        { sd(\"MessageDigest\", \"SHA3-384\", \"com.oracle.security.ucrypto.NativeDigest$SHA3_384\",\n-             \"2.16.840.1.101.3.4.2.9\", \"OID.2.16.840.1.101.3.4.2.9\")\n-    }),\n+        { sdA(\"MessageDigest\", \"SHA3-384\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA3_384\")\n+        }),\n@@ -137,3 +142,3 @@\n-        { sd(\"MessageDigest\", \"SHA3-512\", \"com.oracle.security.ucrypto.NativeDigest$SHA3_512\",\n-             \"2.16.840.1.101.3.4.2.10\", \"OID.2.16.840.1.101.3.4.2.10\")\n-    });\n+        { sdA(\"MessageDigest\", \"SHA3-512\",\n+              \"com.oracle.security.ucrypto.NativeDigest$SHA3_512\")\n+        });\n@@ -144,1 +149,6 @@\n-    private static ServiceDesc sd(String type, String algo, String cn, String... aliases) {\n+    private static ServiceDesc sd(String type, String algo, String cn) {\n+        return new ServiceDesc(type, algo, cn, null);\n+    }\n+\n+    private static ServiceDesc sd(String type, String algo, String cn,\n+            List<String> aliases) {\n@@ -148,0 +158,4 @@\n+    private static ServiceDesc sdA(String type, String algo, String cn) {\n+        return new ServiceDesc(type, algo, cn, getAliases(algo));\n+    }\n+\n","filename":"src\/jdk.crypto.ucrypto\/solaris\/classes\/com\/oracle\/security\/ucrypto\/UcryptoMech.java","additions":73,"deletions":59,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-\n@@ -137,3 +136,2 @@\n-    private static ServiceDesc sd(String type, String algo, String cn,\n-        String... aliases) {\n-        return new ServiceDesc(type, algo, cn, aliases);\n+    private static ServiceDesc sd(String type, String algo, String cn) {\n+        return new ServiceDesc(type, algo, cn, null);\n","filename":"src\/jdk.crypto.ucrypto\/solaris\/classes\/com\/oracle\/security\/ucrypto\/UcryptoProvider.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n- * @see org.jline.keymap.KeyMap\n+ * @see jdk.internal.org.jline.keymap.KeyMap\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    private final int sort;\n@@ -34,1 +35,1 @@\n-        this(value, value, null, null, null, null, true);\n+        this(value, value, null, null, null, null, true, 0);\n@@ -47,0 +48,1 @@\n+     * @param sort the sort flag\n@@ -48,1 +50,1 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete, int sort) {\n@@ -56,0 +58,16 @@\n+        this.sort = sort;\n+    }\n+\n+    \/**\n+     * Constructs a new Candidate.\n+     *\n+     * @param value the value\n+     * @param displ the display string\n+     * @param group the group\n+     * @param descr the description\n+     * @param suffix the suffix\n+     * @param key the key\n+     * @param complete the complete flag\n+     *\/\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+        this(value, displ, group, descr, suffix, key, complete, 0);\n@@ -136,0 +154,9 @@\n+    \/**\n+     * Integer used to override default sort logic.\n+     * @return the sort int\n+     *\/\n+    public int sort() {\n+        return sort;\n+    }\n+\n+\n@@ -138,1 +165,19 @@\n-        return value.compareTo(o.value);\n+        \/\/ If both candidates have same sort, use default behavior\n+        if( sort == o.sort() ) {\n+            return value.compareTo(o.value);\n+        } else {\n+            return Integer.compare(sort, o.sort());\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Candidate candidate = (Candidate) o;\n+        return Objects.equals(value, candidate.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n- * of the {@link org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n+ * of the {@link jdk.internal.org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletingParsedLine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-     * @return a map of candidates that completion matcher matches\n+     * @return a list of candidates that completion matcher matches\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -17,0 +17,6 @@\n+    \/**\n+     * Highlight buffer\n+     * @param reader LineReader\n+     * @param buffer the buffer to be highlighted\n+     * @return highlighted buffer\n+     *\/\n@@ -18,2 +24,17 @@\n-    public void setErrorPattern(Pattern errorPattern);\n-    public void setErrorIndex(int errorIndex);\n+\n+    \/**\n+     * Refresh highlight configuration\n+     *\/\n+    default void refresh(LineReader reader) {}\n+\n+    \/**\n+     * Set error pattern to be highlighted\n+     * @param errorPattern error pattern to be highlighted\n+     *\/\n+    void setErrorPattern(Pattern errorPattern);\n+\n+    \/**\n+     * Set error index to be highlighted\n+     * @param errorIndex error index to be highlighted\n+     *\/\n+    void setErrorIndex(int errorIndex);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-     * Read history from the file. If incremental only the events that are not contained within the internal list are added.\n+     * Read history from the file. If checkDuplicates is <code>true<\/code> only the events that\n+     * are not contained within the internal list are added.\n@@ -66,1 +67,1 @@\n-     * @param  incremental If true incremental read operation is performed.\n+     * @param  checkDuplicates If <code>true<\/code>, duplicate history entries will be discarded\n@@ -69,1 +70,1 @@\n-    void read(Path file, boolean incremental) throws IOException;\n+    void read(Path file, boolean checkDuplicates) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-     * Columns separated list of patterns that will not be saved in history.\n+     * Colon separated list of patterns that will not be saved in history.\n@@ -470,0 +470,3 @@\n+\n+        \/** Disable the undo feature *\/\n+        DISABLE_UNDO\n@@ -702,1 +705,1 @@\n-     * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n+     * Read a mouse event when the {@link jdk.internal.org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+\n+        String appName = this.appName;\n+        if (null == appName) {\n+            appName = terminal.getName();\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -15,2 +15,2 @@\n-    static final String REGEX_VARIABLE = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*\";\n-    static final String REGEX_COMMAND = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n+    String REGEX_VARIABLE = \"[a-zA-Z_]+[a-zA-Z0-9_-]*\";\n+    String REGEX_COMMAND = \"[:]?[a-zA-Z]+[a-zA-Z0-9_-]*\";\n@@ -37,1 +37,1 @@\n-        String out = \"\";\n+        String out;\n@@ -71,1 +71,1 @@\n-         * May throw EOFError in which case we have incomplete input.\n+         * We should tolerate and ignore errors.\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).collect(Collectors.toList())\n+        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).distinct().collect(Collectors.toList())\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,21 @@\n+    public static class BlockCommentDelims {\n+        private final String start;\n+        private final String end;\n+        public BlockCommentDelims(String start, String end) {\n+            if (start == null || end == null\n+              || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n+                throw new IllegalArgumentException(\"Bad block comment delimiter!\");\n+            }\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        public String getStart() {\n+            return start;\n+        }\n+\n+        public String getEnd() {\n+            return end;\n+        }\n+    }\n+\n@@ -42,0 +63,4 @@\n+    private String[] lineCommentDelims = null;\n+\n+    private BlockCommentDelims blockCommentDelims = null;\n+\n@@ -50,0 +75,10 @@\n+    public DefaultParser lineCommentDelims(final String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+        return this;\n+    }\n+\n+    public DefaultParser blockCommentDelims(final BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+        return this;\n+    }\n+\n@@ -110,0 +145,16 @@\n+    public void setLineCommentDelims(String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+    }\n+\n+    public String[] getLineCommentDelims() {\n+        return this.lineCommentDelims;\n+    }\n+\n+    public void setBlockCommentDelims(BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+    }\n+\n+    public BlockCommentDelims getBlockCommentDelims() {\n+        return blockCommentDelims;\n+    }\n+\n@@ -228,0 +279,5 @@\n+        boolean lineCommented = false;\n+        boolean blockCommented = false;\n+        boolean blockCommentInRightOrder = true;\n+        final String blockCommentEnd = blockCommentDelims == null ? null : blockCommentDelims.end;\n+        final String blockCommentStart = blockCommentDelims == null ? null : blockCommentDelims.start;\n@@ -240,1 +296,1 @@\n-            if (quoteStart < 0 && isQuoteChar(line, i)) {\n+            if (quoteStart < 0 && isQuoteChar(line, i) && !lineCommented && !blockCommented) {\n@@ -261,6 +317,3 @@\n-                \/\/ Delimiter\n-                if (current.length() > 0) {\n-                    words.add(current.toString());\n-                    current.setLength(0); \/\/ reset the arg\n-                    if (rawWordCursor >= 0 && rawWordLength < 0) {\n-                        rawWordLength = i - rawWordStart;\n+                if (lineCommented) {\n+                    if (isCommentDelim(line, i, System.lineSeparator())) {\n+                        lineCommented = false;\n@@ -268,0 +321,8 @@\n+                } else if (blockCommented) {\n+                    if (isCommentDelim(line, i, blockCommentEnd)) {\n+                        blockCommented = false;\n+                    }\n+                } else {\n+                    \/\/ Delimiter\n+                    rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                    rawWordStart = i + 1;\n@@ -269,1 +330,0 @@\n-                rawWordStart = i + 1;\n@@ -271,1 +331,20 @@\n-                if (!isEscapeChar(line, i)) {\n+                if (quoteStart < 0 && !blockCommented && (lineCommented || isLineCommentStarted(line, i))) {\n+                    lineCommented = true;\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && (blockCommented || isCommentDelim(line, i, blockCommentStart))) {\n+                    if (blockCommented) {\n+                        if (blockCommentEnd != null && isCommentDelim(line, i, blockCommentEnd)) {\n+                            blockCommented = false;\n+                            i += blockCommentEnd.length() - 1;\n+                        }\n+                    } else {\n+                        blockCommented = true;\n+                        rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                        i += blockCommentStart == null ? 0 : blockCommentStart.length() - 1;\n+                        rawWordStart = i + 1;\n+                    }\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && isCommentDelim(line, i, blockCommentEnd)) {\n+                    current.append(line.charAt(i));\n+                    blockCommentInRightOrder = false;\n+                } else if (!isEscapeChar(line, i)) {\n@@ -304,0 +383,8 @@\n+            if (blockCommented) {\n+                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\",\n+                        \"add: \" + blockCommentEnd);\n+            }\n+            if (!blockCommentInRightOrder) {\n+                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\",\n+                        \"missing: \" + blockCommentStart);\n+            }\n@@ -336,0 +423,11 @@\n+    private int handleDelimiterAndGetRawWordLength(StringBuilder current, List<String> words, int rawWordStart, int rawWordCursor, int rawWordLength, int pos) {\n+        if (current.length() > 0) {\n+            words.add(current.toString());\n+            current.setLength(0); \/\/ reset the arg\n+            if (rawWordCursor >= 0 && rawWordLength < 0) {\n+                return pos - rawWordStart;\n+            }\n+        }\n+        return rawWordLength;\n+    }\n+\n@@ -354,0 +452,30 @@\n+    private boolean isCommentDelim(final CharSequence buffer, final int pos, final String pattern) {\n+        if (pos < 0) {\n+            return false;\n+        }\n+\n+        if (pattern != null) {\n+            final int length = pattern.length();\n+            if (length <= buffer.length() - pos) {\n+                for (int i = 0; i < length; i++) {\n+                    if (pattern.charAt(i) != buffer.charAt(pos + i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isLineCommentStarted(final CharSequence buffer, final int pos) {\n+        if (lineCommentDelims != null) {\n+            for (String comment: lineCommentDelims) {\n+                if (isCommentDelim(buffer, pos, comment)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":137,"deletions":9,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2022, the original author or authors.\n@@ -284,1 +284,1 @@\n-        this(terminal, null, null);\n+        this(terminal, terminal.getName(), null);\n@@ -636,1 +636,2 @@\n-                undo.newState(buf.copy());\n+                if (!isSet(Option.DISABLE_UNDO))\n+                    undo.newState(buf.copy());\n@@ -682,1 +683,1 @@\n-                    if (!isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                    if (!isSet(Option.DISABLE_UNDO) && !isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n@@ -742,0 +743,1 @@\n+                startedReading.set(false);\n@@ -743,1 +745,0 @@\n-            startedReading.set(false);\n@@ -1085,1 +1086,1 @@\n-        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Constructor<?> ctor = Class.forName(\"jdk.internal.org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n@@ -1090,5 +1091,6 @@\n-        BufferedReader br = new BufferedReader(new FileReader(file));\n-        String line;\n-        commandsBuffer.clear();\n-        while ((line = br.readLine()) != null) {\n-            commandsBuffer.add(line);\n+        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n+            String line;\n+            commandsBuffer.clear();\n+            while ((line = br.readLine()) != null) {\n+                commandsBuffer.add(line);\n+            }\n@@ -1096,1 +1098,0 @@\n-        br.close();\n@@ -3598,3 +3599,3 @@\n-            FileWriter writer = new FileWriter(file);\n-            writer.write(buf.toString());\n-            writer.close();\n+            try (FileWriter writer = new FileWriter(file)) {\n+                writer.write(buf.toString());\n+            }\n@@ -3799,0 +3800,3 @@\n+                if (terminal.getType().startsWith(AbstractWindowsTerminal.TYPE_WINDOWS)) {\n+                    status.resize();\n+                }\n@@ -3950,1 +3954,2 @@\n-                     || c == '$' || c == '.' || c == '?' || c == '+') {\n+                     || c == '$' || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!'\n+                     || c == '-') {\n@@ -4523,1 +4528,1 @@\n-    private CompletingParsedLine wrap(ParsedLine line) {\n+    protected static CompletingParsedLine wrap(ParsedLine line) {\n@@ -4628,0 +4633,5 @@\n+    private int visibleDisplayRows() {\n+        Status status = Status.getStatus(terminal, false);\n+        return terminal.getSize().getRows() - (status != null ? status.size() : 0);\n+    }\n+\n@@ -5073,0 +5083,1 @@\n+        boolean customOrder = possible.stream().anyMatch(c -> c.sort() != 0);\n@@ -5075,1 +5086,1 @@\n-            Map<String, Map<String, Candidate>> sorted;\n+            Map<String, Map<Object, Candidate>> sorted;\n@@ -5082,1 +5093,1 @@\n-                        .put(cand.value(), cand);\n+                        .put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5084,1 +5095,1 @@\n-            for (Map.Entry<String, Map<String, Candidate>> entry : sorted.entrySet()) {\n+            for (Map.Entry<String, Map<Object, Candidate>> entry : sorted.entrySet()) {\n@@ -5099,1 +5110,1 @@\n-            TreeMap<String, Candidate> sorted = new TreeMap<>();\n+            TreeMap<Object, Candidate> sorted = new TreeMap<>();\n@@ -5105,1 +5116,1 @@\n-                sorted.put(cand.value(), cand);\n+                sorted.put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5132,1 +5143,1 @@\n-            while (endLine.length() + (first ? startPos : 0) > width) {\n+            while (endLine.length() + (first ? startPos : 0) > width && width > 0) {\n@@ -5210,1 +5221,1 @@\n-                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), displayRows() - promptLines())) {\n+                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), visibleDisplayRows() - promptLines())) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @deprecated use <code>org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n+ * @deprecated use <code>jdk.internal.org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/FileNameCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            } else if (aliasCommand.containsKey(cmd)) {\n+            } else {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    public void read(Path file, boolean incremental) throws IOException {\n+    public void read(Path file, boolean checkDuplicates) throws IOException {\n@@ -107,1 +107,1 @@\n-                        reader.lines().forEach(line -> addHistoryLine(path, line, incremental));\n+                        reader.lines().forEach(line -> addHistoryLine(path, line, checkDuplicates));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -19,0 +19,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -20,0 +21,4 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -24,0 +29,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -27,0 +34,1 @@\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n@@ -28,7 +36,1 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n-import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JansiSupport;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -55,0 +57,5 @@\n+    public static final String PROP_OUTPUT = \"org.jline.terminal.output\";\n+    public static final String PROP_OUTPUT_OUT = \"out\";\n+    public static final String PROP_OUTPUT_ERR = \"err\";\n+    public static final String PROP_OUTPUT_OUT_ERR = \"out-err\";\n+    public static final String PROP_OUTPUT_ERR_OUT = \"err-out\";\n@@ -64,0 +71,10 @@\n+    \/\/\n+    \/\/ Terminal output control\n+    \/\/\n+    public enum SystemOutput {\n+        SysOut,\n+        SysErr,\n+        SysOutOrSysErr,\n+        SysErrOrSysOut\n+    }\n+\n@@ -100,0 +117,1 @@\n+    private SystemOutput systemOutput;\n@@ -131,0 +149,14 @@\n+    \/**\n+     * Indicates which standard stream should be used when displaying to the terminal.\n+     * The default is to use the system output stream.\n+     * Building a system terminal will fail if one of the stream specified is not linked\n+     * to the controlling terminal.\n+     *\n+     * @param systemOutput The mode to choose the output stream.\n+     * @return The builder.\n+     *\/\n+    public TerminalBuilder systemOutput(SystemOutput systemOutput) {\n+        this.systemOutput = systemOutput;\n+        return this;\n+    }\n+\n@@ -301,5 +333,12 @@\n-        int codepage = this.codepage;\n-        if (codepage <= 0) {\n-            String str = System.getProperty(PROP_CODEPAGE);\n-            if (str != null) {\n-                codepage = Integer.parseInt(str);\n+        if (encoding == null) {\n+            int codepage = this.codepage;\n+            if (codepage <= 0) {\n+                String str = System.getProperty(PROP_CODEPAGE);\n+                if (str != null) {\n+                    codepage = Integer.parseInt(str);\n+                }\n+            }\n+            if (codepage >= 0) {\n+                encoding = getCodepageCharset(codepage);\n+            } else {\n+                encoding = StandardCharsets.UTF_8;\n@@ -331,0 +370,32 @@\n+        IllegalStateException exception = new IllegalStateException(\"Unable to create a terminal\");\n+        List<TerminalProvider> providers = new ArrayList<>();\n+        if (jna) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jna\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JNA support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (jansi) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JANSI support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (exec)\n+        {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"exec\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load EXEC support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+\n+        Terminal terminal = null;\n@@ -332,1 +403,2 @@\n-            if (system != null && ((in != null && !in.equals(System.in)) ||  (out != null && !out.equals(System.out)))) {\n+            if (system != null && ((in != null && !in.equals(System.in)) ||\n+                    (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n@@ -335,4 +407,33 @@\n-            Terminal terminal = null;\n-            IllegalStateException exception = new IllegalStateException(\"Unable to create a system terminal\");\n-            TerminalBuilderSupport tbs = new TerminalBuilderSupport(jna, jansi);\n-            if (tbs.isConsoleInput() && tbs.isConsoleOutput()) {\n+            if (attributes != null || size != null) {\n+                Log.warn(\"Attributes and size fields are ignored when creating a system terminal\");\n+            }\n+            if (out != null) {\n+                if (out.equals(System.out)) {\n+                    systemOutput = SystemOutput.SysOut;\n+                } else if (out.equals(System.err)) {\n+                    systemOutput = SystemOutput.SysErr;\n+                }\n+            }\n+            if (systemOutput == null) {\n+                String str = System.getProperty(PROP_OUTPUT);\n+                if (str != null) {\n+                    switch (str.trim().toLowerCase(Locale.ROOT)) {\n+                        case PROP_OUTPUT_OUT: systemOutput = SystemOutput.SysOut; break;\n+                        case PROP_OUTPUT_ERR: systemOutput = SystemOutput.SysErr; break;\n+                        case PROP_OUTPUT_OUT_ERR: systemOutput = SystemOutput.SysOutOrSysErr; break;\n+                        case PROP_OUTPUT_ERR_OUT: systemOutput = SystemOutput.SysErrOrSysOut; break;\n+                        default:\n+                            Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n+                                    + String.join(\", \", PROP_OUTPUT_OUT, PROP_OUTPUT_ERR, PROP_OUTPUT_OUT_ERR,PROP_OUTPUT_ERR_OUT)\n+                                    + \".\");\n+                    }\n+                }\n+            }\n+            if (systemOutput == null) {\n+                systemOutput = SystemOutput.SysOutOrSysErr;\n+            }\n+            Map<TerminalProvider.Stream, Boolean> system = Stream.of(TerminalProvider.Stream.values())\n+                    .collect(Collectors.toMap(stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n+            TerminalProvider.Stream console = select(system, systemOutput);\n+\n+            if (system.get(TerminalProvider.Stream.Input) && console != null) {\n@@ -342,64 +443,9 @@\n-                if (OSUtils.IS_WINDOWS) {\n-                    if (!OSUtils.IS_CYGWIN && !OSUtils.IS_MSYSTEM) {\n-                        boolean ansiPassThrough = OSUtils.IS_CONEMU;\n-                        if (tbs.hasJnaSupport()) {\n-                            try {\n-                                terminal = tbs.getJnaSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused, inputStreamWrapper);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                        if (terminal == null && tbs.hasJansiSupport()) {\n-                            try {\n-                                terminal = tbs.getJansiSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                    } else if (exec) {\n-                        \/\/\n-                        \/\/ Cygwin support\n-                        \/\/\n-                        try {\n-                            \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n-                            \/\/ so if the value comes from the environment, change it to xterm-256color\n-                            if (\"xterm\".equals(type) && this.type == null && System.getProperty(PROP_TYPE) == null) {\n-                                type = \"xterm-256color\";\n-                            }\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (IOException e) {\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", e.getMessage(), e);\n-                            exception.addSuppressed(e);\n-                        }\n-                    }\n-                    if (terminal == null && !jna && !jansi && (dumb == null || !dumb)) {\n-                        throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n-                                + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n-                    }\n-                } else {\n-                    if (tbs.hasJnaSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJnaSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            \/\/ ignore\n-                            Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && tbs.hasJansiSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJansiSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && exec) {\n+                boolean ansiPassThrough = OSUtils.IS_CONEMU;\n+                \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n+                \/\/ so if the value comes from the environment, change it to xterm-256color\n+                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)  && \"xterm\".equals(type)\n+                        && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                    type = \"xterm-256color\";\n+                }\n+                for ( TerminalProvider provider : providers) {\n+                    if (terminal == null) {\n@@ -407,2 +453,2 @@\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                            terminal = provider.sysTerminal(name, type, ansiPassThrough, encoding,\n+                                    nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n@@ -410,2 +456,1 @@\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", t.getMessage(), t);\n+                            Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n@@ -416,11 +461,15 @@\n-                if (terminal instanceof AbstractTerminal) {\n-                    AbstractTerminal t = (AbstractTerminal) terminal;\n-                    if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n-                        t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n-                    } else {\n-                        exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                                \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                                \"or that previously created system Terminals have been correctly closed.\"));\n-                        terminal.close();\n-                        terminal = null;\n-                    }\n+                if (terminal == null && OSUtils.IS_WINDOWS &&  !jna && !jansi && (dumb == null || !dumb)) {\n+                    throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n+                            + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n+                }\n+            }\n+            if (terminal instanceof AbstractTerminal) {\n+                AbstractTerminal t = (AbstractTerminal) terminal;\n+                if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n+                    t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n+                } else {\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n+                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n+                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    terminal.close();\n+                    terminal = null;\n@@ -436,1 +485,2 @@\n-                        color = System.getenv(\"INSIDE_EMACS\") != null;\n+                        String emacs = System.getenv(\"INSIDE_EMACS\");\n+                        color = emacs != null && emacs.contains(\"comint\");\n@@ -444,1 +494,1 @@\n-                        color = tbs.isConsoleOutput() && System.getenv(\"TERM\") != null;\n+                        color = system.get(TerminalProvider.Stream.Output) && System.getenv(\"TERM\") != null;\n@@ -448,2 +498,3 @@\n-                            Log.warn(\"input is tty: {}\", tbs.isConsoleInput());\n-                            Log.warn(\"output is tty: {}\", tbs.isConsoleOutput());\n+                            Log.warn(\"input is tty: {}\", system.get(TerminalProvider.Stream.Input));\n+                            Log.warn(\"output is tty: {}\", system.get(TerminalProvider.Stream.Output));\n+                            Log.warn(\"error is tty: {}\", system.get(TerminalProvider.Stream.Error));\n@@ -457,2 +508,2 @@\n-                        inputStreamWrapper.apply(new FileInputStream(FileDescriptor.in)),\n-                        new FileOutputStream(FileDescriptor.out),\n+                        new FileInputStream(FileDescriptor.in),\n+                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n@@ -461,4 +512,0 @@\n-            if (terminal == null) {\n-                throw exception;\n-            }\n-            return terminal;\n@@ -466,6 +513,8 @@\n-            if (jna) {\n-                try {\n-                    Pty pty = load(JnaSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n+            for ( TerminalProvider provider : providers) {\n+                if (terminal == null) {\n+                    try {\n+                        terminal = provider.newTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n+                    } catch (Throwable t) {\n+                        Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                        exception.addSuppressed(t);\n+                    }\n@@ -474,7 +523,25 @@\n-            if (jansi) {\n-                try {\n-                    Pty pty = load(JansiSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                }\n+        }\n+        if (terminal == null) {\n+            throw exception;\n+        }\n+        return terminal;\n+    }\n+\n+    private TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, SystemOutput systemOutput) {\n+        switch (systemOutput) {\n+            case SysOut:\n+                return select(system, TerminalProvider.Stream.Output);\n+            case SysErr:\n+                return select(system, TerminalProvider.Stream.Error);\n+            case SysOutOrSysErr:\n+                return select(system, TerminalProvider.Stream.Output, TerminalProvider.Stream.Error);\n+            case SysErrOrSysOut:\n+                return select(system, TerminalProvider.Stream.Error, TerminalProvider.Stream.Output);\n+        }\n+        return null;\n+    }\n+\n+    private static TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, TerminalProvider.Stream... streams) {\n+        for (TerminalProvider.Stream s : streams) {\n+            if (system.get(s)) {\n+                return s;\n@@ -482,1 +549,0 @@\n-            return new ExternalTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n@@ -484,0 +550,1 @@\n+        return null;\n@@ -515,0 +582,18 @@\n+    private static final int UTF8_CODE_PAGE = 65001;\n+\n+    private static Charset getCodepageCharset(int codepage) {\n+        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n+        if (codepage == UTF8_CODE_PAGE) {\n+            return StandardCharsets.UTF_8;\n+        }\n+        String charsetMS = \"ms\" + codepage;\n+        if (Charset.isSupported(charsetMS)) {\n+            return Charset.forName(charsetMS);\n+        }\n+        String charsetCP = \"cp\" + codepage;\n+        if (Charset.isSupported(charsetCP)) {\n+            return Charset.forName(charsetCP);\n+        }\n+        return Charset.defaultCharset();\n+    }\n+\n@@ -548,75 +633,0 @@\n-    private static class TerminalBuilderSupport {\n-        private JansiSupport jansiSupport = null;\n-        private JnaSupport jnaSupport = null;\n-        private Pty pty = null;\n-        private boolean consoleOutput;\n-\n-        TerminalBuilderSupport(boolean jna, boolean jansi) {\n-            if (jna) {\n-                try {\n-                    jnaSupport = load(JnaSupport.class);\n-                    consoleOutput = jnaSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jnaSupport = null;\n-                    Log.debug(\"jnaSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jansi) {\n-                try {\n-                    jansiSupport = load(JansiSupport.class);\n-                    consoleOutput = jansiSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jansiSupport = null;\n-                    Log.debug(\"jansiSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jnaSupport == null && jansiSupport == null) {\n-                try {\n-                    pty = ExecPty.current();\n-                    consoleOutput = true;\n-                } catch (Exception e) {\n-                    Log.debug(\"ExecPty.current(): \", e);\n-                }\n-            }\n-        }\n-\n-        public boolean isConsoleOutput() {\n-            return consoleOutput;\n-        }\n-\n-        public boolean isConsoleInput() {\n-            if (pty != null) {\n-                return true;\n-            } else if (hasJnaSupport()) {\n-                return jnaSupport.isConsoleInput();\n-            } else if (hasJansiSupport()) {\n-                return jansiSupport.isConsoleInput();\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        public boolean hasJnaSupport() {\n-            return jnaSupport != null;\n-        }\n-\n-        public boolean hasJansiSupport() {\n-            return jansiSupport != null;\n-        }\n-\n-        public JnaSupport getJnaSupport() {\n-            return jnaSupport;\n-        }\n-\n-        public JansiSupport getJansiSupport() {\n-            return jansiSupport;\n-        }\n-\n-        public Pty getExecPty() throws IOException {\n-            if (pty == null) {\n-                pty = ExecPty.current();\n-            }\n-            return pty;\n-        }\n-\n-    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":206,"deletions":196,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -89,5 +89,0 @@\n-        @Override\n-        public int readBuffered(byte[] b) throws IOException {\n-            return in.read(b);\n-        }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(name, type, selectCharset(encoding, codepage), signalHandler);\n+    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(name, type, encoding, signalHandler);\n@@ -119,29 +119,0 @@\n-    private static Charset selectCharset(Charset encoding, int codepage) {\n-        if (encoding != null) {\n-            return encoding;\n-        }\n-\n-        if (codepage >= 0) {\n-            return getCodepageCharset(codepage);\n-        }\n-\n-        \/\/ Use UTF-8 as default\n-        return StandardCharsets.UTF_8;\n-    }\n-\n-    private static Charset getCodepageCharset(int codepage) {\n-        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n-        if (codepage == UTF8_CODE_PAGE) {\n-            return StandardCharsets.UTF_8;\n-        }\n-        String charsetMS = \"ms\" + codepage;\n-        if (Charset.isSupported(charsetMS)) {\n-            return Charset.forName(charsetMS);\n-        }\n-        String charsetCP = \"cp\" + codepage;\n-        if (Charset.isSupported(charsetCP)) {\n-            return Charset.forName(charsetCP);\n-        }\n-        return Charset.defaultCharset();\n-    }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class Diag {\n+\n+    public static void main(String[] args) {\n+        diag(System.out);\n+    }\n+\n+    static void diag(PrintStream out) {\n+        out.println(\"System properties\");\n+        out.println(\"=================\");\n+        out.println(\"os.name =         \" + System.getProperty(\"os.name\"));\n+        out.println(\"OSTYPE =          \" + System.getenv(\"OSTYPE\"));\n+        out.println(\"MSYSTEM =         \" + System.getenv(\"MSYSTEM\"));\n+        out.println(\"PWD =             \" + System.getenv(\"PWD\"));\n+        out.println(\"ConEmuPID =       \" + System.getenv(\"ConEmuPID\"));\n+        out.println(\"WSL_DISTRO_NAME = \" + System.getenv(\"WSL_DISTRO_NAME\"));\n+        out.println(\"WSL_INTEROP =     \" + System.getenv(\"WSL_INTEROP\"));\n+        out.println();\n+\n+        out.println(\"OSUtils\");\n+        out.println(\"=================\");\n+        out.println(\"IS_WINDOWS = \" + OSUtils.IS_WINDOWS);\n+        out.println(\"IS_CYGWIN =  \" + OSUtils.IS_CYGWIN);\n+        out.println(\"IS_MSYSTEM = \" + OSUtils.IS_MSYSTEM);\n+        out.println(\"IS_WSL =     \" + OSUtils.IS_WSL);\n+        out.println(\"IS_WSL1 =    \" + OSUtils.IS_WSL1);\n+        out.println(\"IS_WSL2 =    \" + OSUtils.IS_WSL2);\n+        out.println(\"IS_CONEMU =  \" + OSUtils.IS_CONEMU);\n+        out.println(\"IS_OSX =     \" + OSUtils.IS_OSX);\n+        out.println();\n+\n+        out.println(\"JnaSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jna\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNA support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JansiSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Jansi support not available: \" + t);\n+        }\n+        out.println();\n+\n+        \/\/ Exec\n+        out.println(\"Exec Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"exec\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Exec support not available: \" + t);\n+        }\n+    }\n+\n+    private static void testProvider(PrintStream out, TerminalProvider provider) {\n+        try {\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream: \" + t2);\n+        }\n+        try {\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream names: \" + t2);\n+        }\n+        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n+                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+            if (terminal != null) {\n+                Attributes attr = terminal.enterRawMode();\n+                try {\n+                    out.println(\"Terminal size: \" + terminal.getSize());\n+                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    int r = t.get(1000, TimeUnit.MILLISECONDS);\n+                    StringBuilder sb = new StringBuilder();\n+                    sb.append(\"The terminal seems to work: \");\n+                    sb.append(\"terminal \").append(terminal.getClass().getName());\n+                    if (terminal instanceof AbstractPosixTerminal) {\n+                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                    }\n+                    out.println(sb);\n+                } catch (Throwable t3) {\n+                    out.println(\"Unable to read from terminal: \" + t3);\n+                    t3.printStackTrace();\n+                } finally {\n+                    terminal.setAttributes(attr);\n+                }\n+            } else {\n+                out.println(\"Not supported by provider\");\n+            }\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to open terminal: \" + t2);\n+            t2.printStackTrace();\n+        }\n+    }\n+\n+    static <S> S load(Class<S> clazz) {\n+        return ServiceLoader.load(clazz, clazz.getClassLoader()).iterator().next();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -37,1 +38,1 @@\n-    private final boolean system;\n+    private final TerminalProvider.Stream console;\n@@ -39,1 +40,1 @@\n-    public static Pty current() throws IOException {\n+    public static Pty current(TerminalProvider.Stream console) throws IOException {\n@@ -42,1 +43,4 @@\n-            return new ExecPty(result.trim(), true);\n+            if (console != TerminalProvider.Stream.Output && console != TerminalProvider.Stream.Error) {\n+                throw new IllegalArgumentException(\"console should be Output or Error: \" + console);\n+            }\n+            return new ExecPty(result.trim(), console);\n@@ -48,1 +52,1 @@\n-    protected ExecPty(String name, boolean system) {\n+    protected ExecPty(String name, TerminalProvider.Stream console) {\n@@ -50,1 +54,1 @@\n-        this.system = system;\n+        this.console = console;\n@@ -73,1 +77,1 @@\n-        return system\n+        return console != null\n@@ -80,1 +84,1 @@\n-        return system\n+        return console == TerminalProvider.Stream.Output\n@@ -82,1 +86,3 @@\n-                : new FileOutputStream(getName());\n+                : console == TerminalProvider.Stream.Error\n+                    ? new FileOutputStream(FileDescriptor.err)\n+                    : new FileOutputStream(getName());\n@@ -96,1 +102,1 @@\n-            if (!system) {\n+            if (console == null) {\n@@ -100,13 +106,1 @@\n-            try {\n-                exec(system, commands.toArray(new String[commands.size()]));\n-            } catch (IOException e) {\n-                \/\/ Handle partial failures with GNU stty, see #97\n-                if (e.toString().contains(\"unable to perform all requested operations\")) {\n-                    commands = getFlagsToSet(attr, getAttr());\n-                    if (!commands.isEmpty()) {\n-                        throw new IOException(\"Could not set the following flags: \" + String.join(\", \", commands), e);\n-                    }\n-                } else {\n-                    throw e;\n-                }\n-            }\n+            exec(console != null, commands.toArray(new String[0]));\n@@ -174,1 +168,1 @@\n-        return system\n+        return console != null\n@@ -283,1 +277,1 @@\n-        if (system) {\n+        if (console != null) {\n@@ -299,1 +293,1 @@\n-        return \"ExecPty[\" + getName() + (system ? \", system]\" : \"]\");\n+        return \"ExecPty[\" + getName() + (console != null ? \", system]\" : \"]\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExecPty.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -18,1 +18,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -146,1 +145,1 @@\n-    private class InputStreamWrapper extends NonBlockingInputStream {\n+    private static class InputStreamWrapper extends NonBlockingInputStream {\n@@ -149,1 +148,1 @@\n-        private final AtomicBoolean closed = new AtomicBoolean();\n+        private volatile boolean closed;\n@@ -157,1 +156,1 @@\n-            if (closed.get()) {\n+            if (closed) {\n@@ -165,1 +164,1 @@\n-            closed.set(true);\n+            closed = true;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+import java.util.function.Function;\n@@ -37,2 +38,3 @@\n-    public PosixSysTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding,\n-                            boolean nativeSignals, SignalHandler signalHandler) throws IOException {\n+    public PosixSysTerminal(String name, String type, Pty pty, Charset encoding,\n+                            boolean nativeSignals, SignalHandler signalHandler,\n+                            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n@@ -40,2 +42,2 @@\n-        this.input = NonBlocking.nonBlocking(getName(), in);\n-        this.output = out;\n+        this.input = NonBlocking.nonBlocking(getName(), inputStreamWrapper.apply(pty.getSlaveInput()));\n+        this.output = pty.getSlaveOutput();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.ExecHelper;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class ExecTerminalProvider implements TerminalProvider\n+{\n+\n+    public String name() {\n+        return \"exec\";\n+    }\n+\n+    public Pty current(Stream consoleStream) throws IOException {\n+        return ExecPty.current(consoleStream);\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            Pty pty = current(consoleStream);\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pty pty = current(consoleStream);\n+        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return systemStreamName( stream ) != null;\n+    }\n+\n+    public boolean isPosixSystemStream(Stream stream) {\n+        try {\n+            Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-t\", Integer.toString(stream.ordinal()))\n+                    .inheritIO().start();\n+            return p.waitFor() == 0;\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+        try {\n+            ProcessBuilder.Redirect input = stream == Stream.Input\n+                                ? ProcessBuilder.Redirect.INHERIT\n+                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            String result = ExecHelper.waitAndCapture(p);\n+            if (p.exitValue() == 0) {\n+                return result.trim();\n+            }\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return null;\n+    }\n+\n+    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n+        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n+        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n+        \/\/ the `tty` utility, it provides a way to get\n+        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+        Constructor<?> cns = rpi.getDeclaredConstructor();\n+        cns.setAccessible(true);\n+        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n+        Field f = rpi.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        f.set(input, fd);\n+        return input;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-\n-public interface JansiSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JansiSupport.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public interface JnaSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JnaSupport.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.Properties;\n+import java.util.ServiceLoader;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecTerminalProvider;\n+\n+public interface TerminalProvider\n+{\n+\n+    enum Stream {\n+        Input,\n+        Output,\n+        Error\n+    }\n+\n+    String name();\n+\n+    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n+                         Charset encoding, boolean nativeSignals,\n+                         Terminal.SignalHandler signalHandler, boolean paused,\n+                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+\n+    Terminal newTerminal(String name, String type,\n+                         InputStream masterInput, OutputStream masterOutput,\n+                         Charset encoding, Terminal.SignalHandler signalHandler,\n+                         boolean paused, Attributes attributes, Size size) throws IOException;\n+\n+    boolean isSystemStream(Stream stream);\n+\n+    String systemStreamName(Stream stream);\n+\n+    static TerminalProvider load(String name) throws IOException {\n+        switch (name) {\n+            case \"exec\": return new ExecTerminalProvider();\n+            case \"jna\": {\n+                try {\n+                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n+                } catch (ReflectiveOperationException t) {\n+                    throw new IOException(t);\n+                }\n+            }\n+        }\n+        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+        if (cl == null) {\n+            cl = ClassLoader.getSystemClassLoader();\n+        }\n+        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        if (is != null) {\n+            Properties props = new Properties();\n+            try {\n+                props.load(is);\n+                String className = props.getProperty(\"class\");\n+                if (className == null) {\n+                    throw new IOException(\"No class defined in terminal provider file \" + name);\n+                }\n+                Class<?> clazz = cl.loadClass( className );\n+                return (TerminalProvider) clazz.getConstructor().newInstance();\n+            } catch ( Exception e ) {\n+                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            }\n+        } else {\n+            throw new IOException(\"Unable to find terminal provider \" + name);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -537,1 +537,1 @@\n-            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + Double.toString(h));\n+            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + h);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-import java.util.Stack;\n+import java.util.ArrayDeque;\n@@ -24,2 +24,2 @@\n-    private static Object[] sv = new Object[26];\n-    private static Object[] dv = new Object[26];\n+    private static final Object[] sv = new Object[26];\n+    private static final Object[] dv = new Object[26];\n@@ -71,1 +71,1 @@\n-        Stack<Object> stack = new Stack<>();\n+        ArrayDeque<Object> stack = new ArrayDeque<>();\n@@ -200,1 +200,1 @@\n-                                int v = Integer.valueOf(str.substring(start, index - 1));\n+                                int v = Integer.parseInt(str.substring(start, index - 1));\n@@ -473,1 +473,1 @@\n-            return Integer.valueOf(pop.toString());\n+            return Integer.parseInt(pop.toString());\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-        int numLines = Math.max(oldLines.size(), newLines.size());\n+        int numLines = Math.min(rows, Math.max(oldLines.size(), newLines.size()));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                    .map(Map.Entry::getValue)\n+                    .map(Map.Entry::getKey)\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,7 +98,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!bytes.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int c = reader.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!bytes.hasRemaining() && !t.elapsed()) {\n+                int c = reader.read(t.timeout());\n@@ -120,3 +116,0 @@\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -154,2 +147,2 @@\n-            this.bytes = ByteBuffer.allocate(4);\n-            this.chars = CharBuffer.allocate(2);\n+            this.bytes = ByteBuffer.allocate(2048);\n+            this.chars = CharBuffer.allocate(1024);\n@@ -162,7 +155,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!chars.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int b = input.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!chars.hasRemaining() && !t.elapsed()) {\n+                int b = input.read(t.timeout());\n@@ -184,4 +173,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -201,1 +186,1 @@\n-        public int readBuffered(char[] b) throws IOException {\n+        public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -204,1 +189,3 @@\n-            } else if (b.length == 0) {\n+            } else if (off < 0 || len < 0 || off + len < b.length) {\n+                throw new IllegalArgumentException();\n+            } else if (len == 0) {\n@@ -206,0 +193,4 @@\n+            } else if (chars.hasRemaining()) {\n+                int r = Math.min(len, chars.remaining());\n+                chars.get(b, off, r);\n+                return r;\n@@ -207,32 +198,10 @@\n-                if (chars.hasRemaining()) {\n-                    int r = Math.min(b.length, chars.remaining());\n-                    chars.get(b);\n-                    return r;\n-                } else {\n-                    byte[] buf = new byte[b.length];\n-                    int l = input.readBuffered(buf);\n-                    if (l < 0) {\n-                        return l;\n-                    } else {\n-                        ByteBuffer currentBytes;\n-                        if (bytes.hasRemaining()) {\n-                            int transfer = bytes.remaining();\n-                            byte[] newBuf = new byte[l + transfer];\n-                            bytes.get(newBuf, 0, transfer);\n-                            System.arraycopy(buf, 0, newBuf, transfer, l);\n-                            currentBytes = ByteBuffer.wrap(newBuf);\n-                            bytes.position(0);\n-                            bytes.limit(0);\n-                        } else {\n-                            currentBytes = ByteBuffer.wrap(buf, 0, l);\n-                        }\n-                        CharBuffer chars = CharBuffer.wrap(b);\n-                        decoder.decode(currentBytes, chars, false);\n-                        chars.flip();\n-                        if (currentBytes.hasRemaining()) {\n-                            int pos = bytes.position();\n-                            bytes.limit(bytes.limit() + currentBytes.remaining());\n-                            bytes.put(currentBytes);\n-                            bytes.position(pos);\n-                        }\n-                        return chars.remaining();\n+                Timeout t = new Timeout(timeout);\n+                while (!chars.hasRemaining() && !t.elapsed()) {\n+                    if (!bytes.hasRemaining()) {\n+                        bytes.position(0);\n+                        bytes.limit(0);\n+                    }\n+                    int nb = input.readBuffered(bytes.array(), bytes.limit(),\n+                                            bytes.capacity() - bytes.limit(), t.timeout());\n+                    if (nb < 0) {\n+                        return nb;\n@@ -240,0 +209,4 @@\n+                    bytes.limit(bytes.limit() + nb);\n+                    chars.clear();\n+                    decoder.decode(bytes, chars, false);\n+                    chars.flip();\n@@ -241,0 +214,3 @@\n+                int nb = Math.min(len, chars.remaining());\n+                chars.get(b, off, nb);\n+                return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":33,"deletions":57,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -82,0 +82,8 @@\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(byte[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n@@ -84,1 +92,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -87,1 +97,13 @@\n-            return super.read(b, 0, b.length);\n+            Timeout t = new Timeout(timeout);\n+            int nb = 0;\n+            while (!t.elapsed()) {\n+                int r = read(nb > 0 ? 1 : t.timeout());\n+                if (r < 0) {\n+                    return nb > 0 ? nb : r;\n+                }\n+                b[off + nb++] = (byte) r;\n+                if (nb >= len || t.isInfinite()) {\n+                    break;\n+                }\n+            }\n+            return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -132,3 +130,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -139,1 +136,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -158,4 +155,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStreamImpl.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,6 +48,2 @@\n-        boolean isInfinite = (timeout <= 0L);\n-        long end = 0;\n-        if (!isInfinite) {\n-            end = System.currentTimeMillis() + timeout;\n-        }\n-        while (!closed && !buffer.hasRemaining() && (isInfinite || timeout > 0L)) {\n+        Timeout t = new Timeout(timeout);\n+        while (!closed && !buffer.hasRemaining() && !t.elapsed()) {\n@@ -57,1 +53,1 @@\n-                wait(timeout);\n+                wait(t.timeout());\n@@ -63,3 +59,0 @@\n-            if (!isInfinite) {\n-                timeout = end - System.currentTimeMillis();\n-            }\n@@ -110,7 +103,15 @@\n-    public synchronized int readBuffered(byte[] b) throws IOException {\n-        checkIoException();\n-        int res = wait(readBuffer, 0L);\n-        if (res >= 0) {\n-            res = 0;\n-            while (res < b.length && readBuffer.hasRemaining()) {\n-                b[res++] = (byte) (readBuffer.get() & 0x00FF);\n+    public synchronized int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            checkIoException();\n+            int res = wait(readBuffer, timeout);\n+            if (res >= 0) {\n+                res = 0;\n+                while (res < len && readBuffer.hasRemaining()) {\n+                    b[off + res++] = (byte) (readBuffer.get() & 0x00FF);\n+                }\n@@ -118,0 +119,2 @@\n+            rewind(readBuffer, writeBuffer);\n+            return res;\n@@ -119,2 +122,0 @@\n-        rewind(readBuffer, writeBuffer);\n-        return res;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -112,1 +112,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -120,1 +122,7 @@\n-                        notEmpty.await();\n+                        if (timeout > 0) {\n+                            if (!notEmpty.await(timeout, TimeUnit.MILLISECONDS)) {\n+                                throw new IOException( \"Timeout reading\" );\n+                            }\n+                        } else {\n+                            notEmpty.await();\n+                        }\n@@ -130,1 +138,1 @@\n-                    int r = Math.min(b.length, count);\n+                    int r = Math.min(len, count);\n@@ -132,1 +140,1 @@\n-                        b[i] = buffer[read++];\n+                        b[off + i] = buffer[read++];\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,9 @@\n-    public abstract int readBuffered(char[] b) throws IOException;\n+    public int readBuffered(char[] b) throws IOException {\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(char[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public abstract int readBuffered(char[] b, int off, int len, long timeout) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -97,1 +97,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -108,2 +110,2 @@\n-        } else if (!threadIsReading) {\n-            return in.read(b);\n+        } else if (!threadIsReading && timeout <= 0) {\n+            return in.read(b, off, len);\n@@ -111,1 +113,2 @@\n-            int c = read(-1, false);\n+            \/\/ TODO: rework implementation to read as much as possible\n+            int c = read(timeout, false);\n@@ -113,1 +116,1 @@\n-                b[0] = (char) c;\n+                b[off] = (char) c;\n@@ -116,1 +119,1 @@\n-                return -1;\n+                return c;\n@@ -161,2 +164,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -167,3 +168,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -174,1 +174,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -193,4 +193,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -12,0 +12,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n@@ -31,0 +33,6 @@\n+    public static final boolean IS_WSL = System.getenv(\"WSL_DISTRO_NAME\") != null;\n+\n+    public static final boolean IS_WSL1 = IS_WSL && System.getenv(\"WSL_INTEROP\") == null;\n+\n+    public static final boolean IS_WSL2 = IS_WSL && !IS_WSL1;\n+\n@@ -41,0 +49,1 @@\n+    public static String TEST_COMMAND;\n@@ -47,0 +56,1 @@\n+        String test;\n@@ -48,2 +58,2 @@\n-            tty = \"tty.exe\";\n-            stty = \"stty.exe\";\n+            tty = null;\n+            stty = null;\n@@ -51,1 +61,2 @@\n-            infocmp = \"infocmp.exe\";\n+            infocmp = null;\n+            test = null;\n@@ -65,0 +76,3 @@\n+                    if (test == null && new File(p, \"test.exe\").exists()) {\n+                        test = new File(p, \"test.exe\").getAbsolutePath();\n+                    }\n@@ -67,0 +81,12 @@\n+            if (tty == null) {\n+                tty = \"tty.exe\";\n+            }\n+            if (stty == null) {\n+                stty = \"stty.exe\";\n+            }\n+            if (infocmp == null) {\n+                infocmp = \"infocmp.exe\";\n+            }\n+            if (test == null) {\n+                test = \"test.exe\";\n+            }\n@@ -69,1 +95,2 @@\n-            stty = \"stty\";\n+            stty = IS_OSX ? \"\/bin\/stty\" : \"stty\";\n+            sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n@@ -71,6 +98,2 @@\n-            if (IS_OSX) {\n-                sttyfopt = \"-f\";\n-            }\n-            else {\n-                sttyfopt = \"-F\";\n-            }\n+            test = isTestCommandValid(\"\/usr\/bin\/test\") ? \"\/usr\/bin\/test\"\n+                                                       : \"\/bin\/test\";\n@@ -82,0 +105,1 @@\n+        TEST_COMMAND = test;\n@@ -84,0 +108,3 @@\n+    private static boolean isTestCommandValid(String command) {\n+        return Files.isExecutable(Paths.get(command));\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        char[] buf = new char[bufferSize];\n+        char[] buf = new char[Math.max(bufferSize, 2)];\n@@ -56,3 +56,11 @@\n-    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n-        if (closed) {\n-            return false;\n+    \/**\n+     * Blocks until more input is available, even if {@link #readBuffer} already\n+     * contains some chars; or until the reader is closed.\n+     *\n+     * @return true if more input is available, false if no additional input is\n+     *              available and the reader is closed\n+     * @throws InterruptedIOException If {@link #wait()} is interrupted\n+     *\/\n+    private boolean waitForMoreInput() throws InterruptedIOException {\n+        if (!writeBuffer.hasRemaining()) {\n+            throw new AssertionError(\"No space in write buffer\");\n@@ -61,2 +69,8 @@\n-        while (!buffer.hasRemaining()) {\n-            \/\/ Wake up waiting readers\/writers\n+        int oldRemaining = readBuffer.remaining();\n+\n+        do {\n+            if (closed) {\n+                return false;\n+            }\n+\n+            \/\/ Wake up waiting writers\n@@ -70,0 +84,4 @@\n+        } while (readBuffer.remaining() <= oldRemaining);\n+\n+        return true;\n+    }\n@@ -71,0 +89,9 @@\n+    \/**\n+     * Waits until {@code buffer.hasRemaining() == true}, or it is false and\n+     * the reader is {@link #closed}.\n+     *\n+     * @return true if {@code buffer.hasRemaining() == true}; false otherwise\n+     *         when reader is closed\n+     *\/\n+    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n+        while (!buffer.hasRemaining()) {\n@@ -74,0 +101,9 @@\n+\n+            \/\/ Wake up waiting readers\/writers\n+            notifyAll();\n+\n+            try {\n+                wait();\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n@@ -80,1 +116,1 @@\n-     * Blocks until more input is available or the reader is closed.\n+     * Blocks until input is available or the reader is closed.\n@@ -82,1 +118,1 @@\n-     * @return true if more input is available, false if the reader is closed\n+     * @return true if input is available, false if no input is available and the reader is closed\n@@ -97,1 +133,2 @@\n-        if (!wait(writeBuffer)) {\n+        \/\/ Check `closed` to throw even if writer buffer has space available\n+        if (!wait(writeBuffer) || closed) {\n@@ -125,1 +162,3 @@\n-        return rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        boolean rw = rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        notifyAll();\n+        return rw;\n@@ -134,0 +173,1 @@\n+        notifyAll();\n@@ -205,0 +245,1 @@\n+        int oldPos = output.position();\n@@ -206,2 +247,18 @@\n-        if (rewindReadBuffer() && result.isUnderflow()) {\n-            encoder.encode(readBuffer, output, false);\n+        int encodedCount = output.position() - oldPos;\n+\n+        if (result.isUnderflow()) {\n+            boolean hasMoreInput = rewindReadBuffer();\n+            boolean reachedEndOfInput = false;\n+\n+            \/\/ If encoding did not make any progress must block for more input\n+            if (encodedCount == 0 && !hasMoreInput) {\n+                reachedEndOfInput = !waitForMoreInput();\n+            }\n+\n+            result = encoder.encode(readBuffer, output, reachedEndOfInput);\n+            if (result.isError()) {\n+                result.throwException();\n+            }\n+            if (!reachedEndOfInput && output.position() - oldPos == 0) {\n+                throw new AssertionError(\"Failed to encode any chars\");\n+            }\n@@ -209,0 +266,6 @@\n+        } else if (result.isOverflow()) {\n+            if (encodedCount == 0) {\n+                throw new AssertionError(\"Output buffer has not enough space\");\n+            }\n+        } else {\n+            result.throwException();\n@@ -337,1 +400,1 @@\n-            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar()));\n+            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar() * 2));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":76,"deletions":13,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-            String name = spec.substring(1, spec.length());\n+            String name = spec.substring(1);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2002-2018, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+\/**\n+ * Helper class ti use during I\/O operations with an eventual timeout.\n+ *\/\n+public class Timeout {\n+\n+    private final long timeout;\n+    private long cur = 0;\n+    private long end = Long.MAX_VALUE;\n+\n+    public Timeout(long timeout) {\n+        this.timeout = timeout;\n+    }\n+\n+    public boolean isInfinite() {\n+        return timeout <= 0;\n+    }\n+\n+    public boolean isFinite() {\n+        return timeout > 0;\n+    }\n+\n+    public boolean elapsed() {\n+        if (timeout > 0) {\n+            cur = System.currentTimeMillis();\n+            if (end == Long.MAX_VALUE) {\n+                end = cur + timeout;\n+            }\n+            return cur >= end;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public long timeout() {\n+        return timeout > 0 ? Math.max(1, end - cur) : timeout;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -73,0 +73,1 @@\n+                                (ucs >= 0x1f000 && ucs <= 0x1feee) ||\n@@ -126,2 +127,2 @@\n-            new Interval( 0x1D242, 0x1D244 ), new Interval( 0xE0001, 0xE0001 ), new Interval( 0xE0020, 0xE007F ),\n-            new Interval( 0xE0100, 0xE01EF )\n+            new Interval( 0x1D242, 0x1D244 ), new Interval( 0x1F3FB, 0x1F3FF ), new Interval( 0xE0001, 0xE0001 ),\n+            new Interval( 0xE0020, 0xE007F ), new Interval( 0xE0100, 0xE01EF )\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WCWidth.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\E[B,\n+\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\n,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-vtp.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-\n-    uses jdk.internal.org.jline.terminal.spi.JnaSupport;\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.20.0\n+## JLine v3.22.0\n@@ -44,4 +44,4 @@\n-org.fusesource.jansi version 1.17.1\n-org.apache.sshd 2.1 to 3\n-org.apache.felix.gogo.runtime 1.1.2\n-org.apache.felix.gogo.jline 1.1.4\n+org.fusesource.jansi version 2.4.0\n+org.apache.sshd 2.9.2\n+org.apache.felix.gogo.runtime 1.1.6\n+org.apache.felix.gogo.jline 1.1.8\n@@ -265,1 +265,1 @@\n-Copyright (c) 2004-2017 QOS.ch\n+Copyright (c) 2004-2023 QOS.ch\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2019, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaSupportImpl implements JnaSupport {\n-    @Override\n-    public Pty current() throws IOException {\n-\/\/        return JnaNativePty.current();\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Pty open(Attributes attributes, Size size) throws IOException {\n-\/\/        return JnaNativePty.open(attributes, size);\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, false);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, input -> input);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n-    }\n-\n-    @Override\n-    public boolean isWindowsConsole() {\n-        return JnaWinSysTerminal.isWindowsConsole();\n-    }\n-\n-    @Override\n-    public boolean isConsoleOutput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleOutput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public boolean isConsoleInput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleInput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaSupportImpl.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+public class JnaTerminalProvider implements TerminalProvider\n+{\n+    @Override\n+    public String name() {\n+        return \"jna\";\n+    }\n+\n+\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n+\/\/        return JnaNativePty.current(console);\n+\/\/    }\n+\/\/\n+\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n+\/\/        return JnaNativePty.open(attributes, size);\n+\/\/    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+    }\n+\n+\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+\/\/                                     Stream consoleStream) throws IOException {\n+\/\/        Pty pty = current(consoleStream);\n+\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n+\/\/    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+\/\/        Pty pty = open(attributes, size);\n+\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            if (OSUtils.IS_WINDOWS) {\n+                return isWindowsSystemStream(stream);\n+            } else {\n+\/\/                return isPosixSystemStream(stream);\n+                return false;\n+            }\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+\/\/    public boolean isPosixSystemStream(Stream stream) {\n+\/\/        return JnaNativePty.isPosixSystemStream(stream);\n+\/\/    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+\/\/        if (OSUtils.IS_WINDOWS) {\n+            return null;\n+\/\/        } else {\n+\/\/            return JnaNativePty.posixSystemStreamName(stream);\n+\/\/        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -20,1 +20,1 @@\n-    private final Pointer consoleHandle;\n+    private final Pointer console;\n@@ -23,2 +23,2 @@\n-    JnaWinConsoleWriter(Pointer consoleHandle) {\n-        this.consoleHandle = consoleHandle;\n+    JnaWinConsoleWriter(Pointer console) {\n+        this.console = console;\n@@ -30,1 +30,1 @@\n-            Kernel32.INSTANCE.WriteConsoleW(this.consoleHandle, text, len, this.writtenChars, null);\n+            Kernel32.INSTANCE.WriteConsoleW(this.console, text, len, this.writtenChars, null);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -22,1 +22,0 @@\n-\n@@ -25,1 +24,0 @@\n-import jdk.internal.org.jline.terminal.Terminal;\n@@ -27,0 +25,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -34,0 +33,1 @@\n+    private static final Pointer consoleErr = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n@@ -35,1 +35,12 @@\n-    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, boolean paused, TerminalProvider.Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pointer console;\n+        switch (consoleStream) {\n+            case Output:\n+                console = JnaWinSysTerminal.consoleOut;\n+                break;\n+            case Error:\n+                console = JnaWinSysTerminal.consoleErr;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n+        }\n@@ -41,1 +52,1 @@\n-            writer = new JnaWinConsoleWriter(consoleOut);\n+            writer = new JnaWinConsoleWriter(console);\n@@ -44,1 +55,1 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -46,1 +57,1 @@\n-                Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n+                Kernel32.INSTANCE.SetConsoleMode(console, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n@@ -50,1 +61,1 @@\n-                writer = new JnaWinConsoleWriter(consoleOut);\n+                writer = new JnaWinConsoleWriter(console);\n@@ -56,1 +67,1 @@\n-                    writer = new JnaWinConsoleWriter(consoleOut);\n+                    writer = new JnaWinConsoleWriter(console);\n@@ -61,1 +72,1 @@\n-                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);\n+                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(console)), console);\n@@ -65,1 +76,1 @@\n-        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n@@ -73,12 +84,1 @@\n-    public static boolean isWindowsConsole() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleOutput() {\n+    public static boolean isWindowsSystemStream(TerminalProvider.Stream stream) {\n@@ -87,11 +87,8 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleInput() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n+            Pointer console;\n+            switch (stream) {\n+                case Input: console = consoleIn; break;\n+                case Output: console = consoleOut; break;\n+                case Error: console = consoleErr; break;\n+                default: return false;\n+            }\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -104,2 +101,3 @@\n-    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -51,6 +51,0 @@\n-    \/*\n-     * Object identifier for the subject information access X.509 certificate\n-     * extension.\n-     *\/\n-    private static final String SUBJECT_INFO_ACCESS_OID = \"1.3.6.1.5.5.7.1.11\";\n-\n@@ -60,10 +54,2 @@\n-    private static final ObjectIdentifier AD_TIMESTAMPING_Id;\n-    static {\n-        ObjectIdentifier tmp = null;\n-        try {\n-            tmp = new ObjectIdentifier(\"1.3.6.1.5.5.7.48.3\");\n-        } catch (IOException e) {\n-            \/\/ ignore\n-        }\n-        AD_TIMESTAMPING_Id = tmp;\n-    }\n+    private static final ObjectIdentifier AD_TIMESTAMPING_Id =\n+            ObjectIdentifier.of(KnownOIDs.AD_TimeStamping);\n@@ -158,2 +144,2 @@\n-            byte[] extensionValue =\n-                tsaCertificate.getExtensionValue(SUBJECT_INFO_ACCESS_OID);\n+            byte[] extensionValue = tsaCertificate.getExtensionValue\n+                    (KnownOIDs.SubjectInfoAccess.value());\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/TimestampedSigner.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-    static void init(String connectSpec, boolean openNow, int flags) {\n-        connection = new VMConnection(connectSpec, flags);\n+    static void init(String connectSpec, boolean openNow, int flags, String extraOptions) {\n+        connection = new VMConnection(connectSpec, flags, extraOptions);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Env.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1050,2 +1050,2 @@\n-         * arg1       arg2\n-         * ----       ----\n+         *                     arg1       arg2\n+         *                     ----       ----\n@@ -1088,1 +1088,0 @@\n-            connectSpec += \"options=\" + javaArgs + \",\";\n@@ -1092,4 +1091,1 @@\n-            if (! connectSpec.endsWith(\",\")) {\n-                connectSpec += \",\"; \/\/ (Bug ID 4285874)\n-            }\n-            Env.init(connectSpec, launchImmediately, traceFlags);\n+            Env.init(connectSpec, launchImmediately, traceFlags, javaArgs);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,2 @@\n-    private Map <String, com.sun.jdi.connect.Connector.Argument> parseConnectorArgs(Connector connector, String argString) {\n+    private Map <String, com.sun.jdi.connect.Connector.Argument>\n+            parseConnectorArgs(Connector connector, String argString, String extraOptions) {\n@@ -124,0 +125,5 @@\n+                if (extraOptions != null) {\n+                    sb.append(extraOptions).append(\" \");\n+                    \/\/ set extraOptions to null to avoid appending it again\n+                    extraOptions = null;\n+                }\n@@ -125,0 +131,1 @@\n+                    boolean wasEnclosed = false;\n@@ -126,0 +133,1 @@\n+                        wasEnclosed = true;\n@@ -128,0 +136,3 @@\n+                    if (wasEnclosed && hasWhitespace(s)) {\n+                        s = \"\\\"\" + s + \"\\\"\";\n+                    }\n@@ -153,0 +164,7 @@\n+        if (extraOptions != null) {\n+            \/\/ there was no \"options\" specified in argString\n+            Connector.Argument argument = arguments.get(\"options\");\n+            if (argument != null) {\n+                argument.setValue(extraOptions);\n+            }\n+        }\n@@ -156,0 +174,10 @@\n+    private static boolean hasWhitespace(String string) {\n+        int length = string.length();\n+        for (int i = 0; i < length; i++) {\n+            if (Character.isWhitespace(string.charAt(i))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -302,1 +330,1 @@\n-    VMConnection(String connectSpec, int traceFlags) {\n+    VMConnection(String connectSpec, int traceFlags, String extraOptions) {\n@@ -320,1 +348,1 @@\n-        connectorArgs = parseConnectorArgs(connector, argString);\n+        connectorArgs = parseConnectorArgs(connector, argString, extraOptions);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/VMConnection.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -43,0 +43,54 @@\n+compiler\/aot\/DeoptimizationTest.java 8310619 macosx-x64\n+compiler\/aot\/RecompilationTest.java 8310619 macosx-x64\n+compiler\/aot\/SharedUsageTest.java 8310619 macosx-x64\n+compiler\/aot\/TestHeapBase.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2CompiledTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2InterpretedTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeDynamic2NativeTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeInterface2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeInterface2CompiledTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeInterface2InterpretedTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeInterface2NativeTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2CompiledTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2InterpretedTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeSpecial2NativeTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeStatic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeStatic2CompiledTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeStatic2InterpretedTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeStatic2NativeTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2CompiledTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2InterpretedTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromAot\/AotInvokeVirtual2NativeTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromCompiled\/CompiledInvokeDynamic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromCompiled\/CompiledInvokeInterface2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromCompiled\/CompiledInvokeSpecial2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromCompiled\/CompiledInvokeStatic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromCompiled\/CompiledInvokeVirtual2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeDynamic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeInterface2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeSpecial2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeStatic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromInterpreted\/InterpretedInvokeVirtual2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromNative\/NativeInvokeSpecial2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromNative\/NativeInvokeStatic2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/calls\/fromNative\/NativeInvokeVirtual2AotTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/DisabledAOTWithLibraryTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/MultipleAOTLibraryTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/SingleAOTLibraryTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/SingleAOTOptionTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/AtFileTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/CompileClassTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/CompileClassWithDebugTest.java 8303074,8310619 linux-aarch64,macosx-x64\n+compiler\/aot\/cli\/jaotc\/CompileDirectoryTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/CompileJarTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/CompileModuleTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/IgnoreErrorsTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/ListOptionTest.java 8310619 macosx-x64\n+compiler\/aot\/cli\/jaotc\/ListOptionWrongFileTest.java 8310619 macosx-x64\n+compiler\/aot\/fingerprint\/SelfChanged.java 8310619 macosx-x64\n+compiler\/aot\/fingerprint\/SelfChangedCDS.java 8310619 macosx-x64\n+compiler\/aot\/fingerprint\/SuperChanged.java 8310619 macosx-x64\n+compiler\/aot\/verification\/ClassAndLibraryNotMatchTest.java 8310619 macosx-x64\n@@ -45,1 +99,0 @@\n-compiler\/aot\/cli\/jaotc\/CompileClassWithDebugTest.java 8303074 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-            pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",\n+            pb = ProcessTools.createTestJvm(\"-cp\", \".\",\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/ClassAndLibraryNotMatchTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-            pb = ProcessTools.createJavaProcessBuilder(true, \"-XX:+UnlockExperimentalVMOptions\",\n+            pb = ProcessTools.createTestJvm(\"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/verification\/vmflags\/BasicFlagsChange.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297730\n+ * @summary Test taking UCT between array allocation and array copy to report correct exception.\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.arraycopy.TestArrayCopyIntrinsicWithUCT::test*\n+ *                   compiler.arraycopy.TestArrayCopyIntrinsicWithUCT\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class TestArrayCopyIntrinsicWithUCT {\n+    static int zero = 0;\n+    static int zero2 = 0;\n+    static int minusOne = -1;\n+    static int iFld;\n+    static int iFld2;\n+    static boolean flag;\n+    static byte[] byArrNull = null;\n+    static A aFld = null;\n+\n+    static public void main(String[] args) {\n+        System.out.println(\"Start\"); \/\/ Ensure loaded.\n+        new A(); \/\/ Ensure loaded\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSize);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSize2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeFldSize);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeFldSize2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeStore);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeStore2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero3);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero4);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero5);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero6);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero7);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld3);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld4);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld5);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld6);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld7);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroNullPointer);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeComplex);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeControlFlowNotAllowed);\n+        flag = false;\n+        runNegativeSizeHalf();\n+        runNegativeSizeHalf();\n+    }\n+\n+    static void runNegativeSize(Supplier<byte[]> testMethod) {\n+        try {\n+            testMethod.get();\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void runNegativeSize(Function<byte[], byte[]> testMethod) {\n+        try {\n+            testMethod.apply(null);\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static byte[] testNegativeSize(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSize2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeFldSize(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+    static byte[] testNegativeFldSize2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeStore(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        iFld++; \/\/ Since we have a store here, we do not move the allocation down\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeStore2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        iFld++; \/\/ Since we have a store here, we do not move the allocation down\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero3(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero4(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero5(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero6(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero7(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld3(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld4(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld5(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld6(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld7(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroNullPointer(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int x = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        int len = byArr.length;\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        iFld = x;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeComplex(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int x = minusOne \/ zero; \/\/ div by zero trap would fail\n+        int y = aFld.i;\n+        int len = byArr.length;\n+        x = x + aFld.i2 \/ zero2;\n+        System.arraycopy(byArr, 0, b, 0, x);\n+        iFld = x + y;\n+        return b;\n+    }\n+\n+    \/\/ Optimization not applied because of additional control flow that is not considered safe.\n+    static byte[] testNegativeControlFlowNotAllowed(byte[] byArr) {\n+        int x = 23;\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        if (flag) {\n+            x = 34;\n+        }\n+        int len = x \/ zero;\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static void runNegativeSizeHalf() {\n+        try {\n+            testNegativeSizeHalf(null);\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            Asserts.assertTrue(flag, \"wrongly caught NegativeArraySizeException\");\n+        } catch (NullPointerException e) {\n+            Asserts.assertFalse(flag, \"wrongly caught NullPointerException\");\n+        }\n+        flag = !flag;\n+    }\n+\n+    static byte[] testNegativeSizeHalf(byte[] byArr) {\n+        int size = flag ? -1 : 1;\n+        byte[] b = new byte[size]; \/\/ throws NegativeArraySizeException if size == -1\n+        int len = byArr.length; \/\/ throws NullPointerException if size == 1\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+}\n+\n+class A {\n+    int i, i2;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyIntrinsicWithUCT.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -175,1 +175,1 @@\n-                    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, mix(c, \"-Xmx256m\", className).toArray(new String[0]));\n+                    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(mix(c, \"-Xmx256m\", className).toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @ignore\n+ * @bug 8201516\n+ * @summary Verify that debug information in C2 compiled code is correct.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestDebugInfo\n+ *\/\n+\/\/ ignore -- as ir_framework is not in 11.\n+public class TestDebugInfo {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\");\n+    }\n+\n+    static class MyClass {\n+        final int val;\n+\n+        @ForceInline\n+        public MyClass(int val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        synchronized void synchronizedMethod(boolean throwIt) {\n+            if (throwIt) {\n+                throw new RuntimeException(); \/\/ Make sure there is an exception state\n+            }\n+        }\n+    }\n+\n+    static Object[] array = new Object[3];\n+    static MyClass myVal = new MyClass(42);\n+\n+    \/\/ Verify that the MemBarRelease emitted at the MyClass constructor exit\n+    \/\/ does not incorrectly reference the caller method in its debug information.\n+    @Test\n+    @IR(failOn = {\"MemBarRelease.*testFinalFieldInit.*bci:-1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testFinalFieldInit() {\n+        array[0] = new MyClass(42);\n+        array[1] = new MyClass(42);\n+        array[2] = new MyClass(42);\n+    }\n+\n+    \/\/ Verify that the MemBarReleaseLock emitted at the synchronizedMethod exit\n+    \/\/ does not incorrectly reference the caller method in its debug information.\n+    @Test\n+    @IR(failOn = {\"MemBarReleaseLock.*testSynchronized.*bci:-1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testSynchronized() {\n+        try {\n+            myVal.synchronizedMethod(false);\n+            myVal.synchronizedMethod(true);\n+        } catch (Exception e) {\n+            \/\/ Ignore\n+        }\n+    }\n+\n+    static byte b0 = 0;\n+    static byte b1 = 0;\n+    static byte b2 = 0;\n+    static byte b3 = 0;\n+\n+    @ForceInline\n+    public static Integer useless3(Integer val) {\n+        return ++val;\n+    }\n+\n+    @ForceInline\n+    public static Integer useless2(Integer val) {\n+        return useless3(useless3(useless3(useless3(useless3(useless3(useless3(useless3(val))))))));\n+    }\n+\n+    @ForceInline\n+    public static Integer useless1(Integer val) {\n+        return useless2(useless2(useless2(useless2(useless2(useless2(useless2(useless2(val))))))));\n+    }\n+\n+    @ForceInline\n+    public static void useful3() {\n+        b3 = 3;\n+    }\n+\n+    @ForceInline\n+    public static void useful2() {\n+        useful3();\n+        b2 = 2;\n+    }\n+\n+    @ForceInline\n+    public static void useful1() {\n+        useful2();\n+        b1 = 1;\n+    }\n+\n+    \/\/ Verify that RenumberLiveNodes preserves the debug information side table.\n+    @Test\n+    @IR(counts = {\"StoreB.*name=b3.*useful3.*bci:1.*useful2.*bci:0.*useful1.*bci:0.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b2.*useful2.*bci:4.*useful1.*bci:0.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b1.*useful1.*bci:4.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b0.*testRenumberLiveNodes.*bci:13\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testRenumberLiveNodes() {\n+        \/\/ This generates ~3700 useless nodes to trigger RenumberLiveNodes\n+        useless1(42);\n+\n+        \/\/ Do something useful\n+        useful1();\n+        b0 = 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDebugInfo.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -140,1 +140,1 @@\n-                crashOut = ProcessTools.executeProcess(getTestJavaCommandlineWithPrefix(\n+                crashOut = ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n@@ -143,2 +143,1 @@\n-                crashOut = ProcessTools.executeProcess(ProcessTools.createJavaProcessBuilder(true,\n-                        options));\n+                crashOut = ProcessTools.executeProcess(ProcessTools.createTestJvm(options));\n@@ -188,1 +187,1 @@\n-            OutputAnalyzer oa = ProcessTools.executeProcess(getTestJavaCommandlineWithPrefix(\n+            OutputAnalyzer oa = ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n@@ -288,1 +287,1 @@\n-    private String[] getTestJavaCommandlineWithPrefix(String prefix, String... args) {\n+    private String[] getTestJvmCommandlineWithPrefix(String prefix, String... args) {\n@@ -290,1 +289,1 @@\n-            String cmd = ProcessTools.getCommandLine(ProcessTools.createJavaProcessBuilder(true, args));\n+            String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJvm(args));\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            pb = ProcessTools.createJavaProcessBuilder(true, \"--add-modules\", \"jdk.hotspot.agent\",\n+            pb = ProcessTools.createTestJvm(\"--add-modules\", \"jdk.hotspot.agent\",\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/SABase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(false,\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n@@ -266,2 +266,1 @@\n-        ProcessBuilder javaPB = ProcessTools.createJavaProcessBuilder(true,\n-                javaFlags);\n+        ProcessBuilder javaPB = ProcessTools.createTestJvm(javaFlags);\n","filename":"test\/hotspot\/jtreg\/compiler\/graalunit\/common\/GraalUnitTestLauncher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301491\n+ * @summary Check for correct return value when calling indexOfChar intrinsics with negative value.\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:CompileCommand=quiet\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.intrinsics.string.TestStringIndexOfCharIntrinsics::testIndexOfChar*\n+ *                   -XX:CompileCommand=inline,java.lang.String*::indexOf*\n+ *                   -XX:PerBytecodeTrapLimit=20000\n+ *                   -XX:PerMethodTrapLimit=20000\n+ *                   compiler.intrinsics.string.TestStringIndexOfCharIntrinsics\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestStringIndexOfCharIntrinsics {\n+\n+    static byte byArr[] = new byte[500];\n+\n+    public static void main(String[] args) {\n+        for (int j = 0; j < byArr.length; j++) {\n+            byArr[j] = (byte)j;\n+        }\n+        \/\/ Test value for aarch64\n+        byArr[24] = 0x7;\n+        byArr[23] = -0x80;\n+        \/\/ Warmup\n+        for (int i = 0; i < 10000; i++) {\n+            testIndexOfCharArg(i);\n+            testIndexOfCharConst();\n+        }\n+        Asserts.assertEquals(testIndexOfCharConst() , -1, \"must be -1 (character not found)\");\n+        Asserts.assertEquals(testIndexOfCharArg(-2147483641) , -1, \"must be -1 (character not found)\");\n+    }\n+\n+    static int testIndexOfCharConst() {\n+        String s = new String(byArr);\n+        return s.indexOf(-2147483641);\n+    }\n+\n+    static int testIndexOfCharArg(int ch) {\n+        String s = new String(byArr);\n+        return s.indexOf(ch);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringIndexOfCharIntrinsics.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8289748\n+ * @summary SIGFPE caused by C2 IdealLoopTree::do_remove_empty_loop\n+ * @key stress randomness\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TestRemoveEmptyCountedLoop::test*\n+ *                   compiler.loopopts.TestRemoveEmptyCountedLoop\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestRemoveEmptyCountedLoop {\n+\n+    public static void test1() {\n+        int k = 3;\n+        for (int i=9; i>0; i--) {\n+            for (int j=2; j<i; j++) {\n+                k = k;\n+                k = (1 % j);\n+            }\n+        }\n+    }\n+\n+    public static void test2() {\n+        int k = 3;\n+        for (int i=9; i>0; i--) {\n+            int j = 2;\n+            do {\n+                try {\n+                    k = k;\n+                    k = (1 % j);\n+                } catch (Exception e) {}\n+            } while (++j < i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test1();\n+        test2();\n+        System.out.println(\"Test passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyCountedLoop.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303511\n+ * @summary C2: assert(get_ctrl(n) == cle_out) during unrolling\n+ * @requires vm.gc.Parallel\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:+UseParallelGC TestAddPAtOuterLoopHead\n+ *\/\n+\n+\n+import java.util.Arrays;\n+\n+public class TestAddPAtOuterLoopHead {\n+    public static void main(String[] args) {\n+        boolean[] flags1 = new boolean[1000];\n+        boolean[] flags2 = new boolean[1000];\n+        Arrays.fill(flags2, true);\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper(42, 42, 43);\n+            test(flags1);\n+            test(flags2);\n+        }\n+    }\n+\n+    private static int test(boolean[] flags) {\n+        int[] array = new int[1000];\n+\n+        int k;\n+        for (k = 0; k < 10; k++) {\n+            for (int i = 0; i < 2; i++) {\n+            }\n+        }\n+        k = k \/ 10;\n+        int m;\n+        for (m = 0; m < 2; m++) {\n+            for (int i = 0; i < 2; i++) {\n+                for (int j = 0; j < 2; j++) {\n+                }\n+            }\n+        }\n+\n+\n+        int v = 0;\n+        for (int j = 0; j < 2; j++) {\n+            for (int i = 0; i < 998; i += k) {\n+                int l = testHelper(m, j, i);\n+                v = array[i + l];\n+                if (flags[i]) {\n+                    return v;\n+                }\n+            }\n+        }\n+\n+        return v;\n+    }\n+\n+    private static int testHelper(int m, int j, int i) {\n+        return m == 2 ? j : i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestAddPAtOuterLoopHead.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -33,2 +33,2 @@\n-            oa = ProcessTools.executeProcess(ProcessTools.createJavaProcessBuilder(\n-                    \/* add test vm options *\/ true, Test8015436.class.getName()));\n+            oa = ProcessTools.executeProcess(ProcessTools.createTestJvm(\n+                    Test8015436.class.getName()));\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/cr8015436\/Driver8015436.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,5 +49,0 @@\n-\n-    if (Platform.isZero()) {\n-      String expectedLowWaterMarkText = \"must be at least 0\";\n-      out.shouldContain(expectedLowWaterMarkText);\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/NumCompilerThreadsCheck.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\/* addTestVmOptions= *\/ true, OPTIONS);\n+        ProcessBuilder processBuilder = ProcessTools.createTestJvm(OPTIONS);\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/correctness\/OffTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanPlain(base, offset, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanAcquire(base, offset, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -235,1 +249,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -237,1 +251,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBooleanRelease(base, offset, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -245,1 +266,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = UNSAFE.getBoolean(base, offset);\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBoolean(base, offset, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -247,1 +275,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestBoolean.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetBytePlain(base, offset, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByteAcquire(base, offset, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByteRelease(base, offset, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = UNSAFE.getByte(base, offset);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetByte(base, offset, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestByte.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharPlain(base, offset, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharAcquire(base, offset, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetCharRelease(base, offset, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = UNSAFE.getChar(base, offset);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetChar(base, offset, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestChar.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoublePlain(base, offset, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoubleAcquire(base, offset, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDoubleRelease(base, offset, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = UNSAFE.getDouble(base, offset);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetDouble(base, offset, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestDouble.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -246,1 +246,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatPlain(base, offset, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -254,1 +261,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatAcquire(base, offset, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -256,1 +270,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -264,1 +278,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -266,1 +280,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloatRelease(base, offset, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -274,1 +295,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = UNSAFE.getFloat(base, offset);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetFloat(base, offset, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -276,1 +304,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestFloat.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntPlain(base, offset, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntAcquire(base, offset, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetIntRelease(base, offset, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = UNSAFE.getInt(base, offset);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetInt(base, offset, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestInt.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongPlain(base, offset, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongAcquire(base, offset, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLongRelease(base, offset, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = UNSAFE.getLong(base, offset);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetLong(base, offset, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestLong.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain Object\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain Object value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain Object value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetObjectPlain(base, offset, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain Object\");\n+            Object x = UNSAFE.getObject(base, offset);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain Object value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire Object\");\n+            Object x = UNSAFE.getObject(base, offset);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetObjectAcquire(base, offset, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire Object\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire Object\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire Object value\");\n@@ -235,1 +249,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease Object\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease Object\");\n@@ -237,1 +251,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease Object\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetObjectRelease(base, offset, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease Object\");\n+            Object x = UNSAFE.getObject(base, offset);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease Object value\");\n@@ -245,1 +266,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet Object\");\n+            assertEquals(success, true, \"success weakCompareAndSet Object\");\n+            Object x = UNSAFE.getObject(base, offset);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet Object\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetObject(base, offset, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet Object\");\n@@ -247,1 +275,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet Object\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet Object value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestObject.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -264,1 +264,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortPlain(base, offset, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -272,1 +279,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortAcquire(base, offset, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -274,1 +288,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -282,1 +296,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -284,1 +298,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShortRelease(base, offset, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -292,1 +313,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = UNSAFE.getShort(base, offset);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSetShort(base, offset, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -294,1 +322,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/JdkInternalMiscUnsafeAccessTestShort.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestBoolean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/SunMiscUnsafeAccessTestShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -308,1 +308,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$Type$Plain(base, offset, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = UNSAFE.get$Type$(base, offset);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -316,1 +323,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = UNSAFE.get$Type$(base, offset);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$Type$Acquire(base, offset, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -318,1 +332,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -326,1 +340,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -328,1 +342,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$Type$Release(base, offset, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = UNSAFE.get$Type$(base, offset);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -336,1 +357,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = UNSAFE.get$Type$(base, offset);\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = UNSAFE.weakCompareAndSet$Type$(base, offset, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -338,1 +366,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/X-UnsafeAccessTest.java.template","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-javac -d . ..\/..\/..\/..\/jdk\/make\/src\/classes\/build\/tools\/spp\/Spp.java\n+javac -d . ..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n@@ -126,0 +126,2 @@\n+      out=${Qualifier}UnsafeAccessTest${Type}.java\n+      rm -rf \"$out\"\n@@ -127,1 +129,1 @@\n-          $args -iX-UnsafeAccessTest.java.template -o${Qualifier}UnsafeAccessTest${Type}.java\n+          $args -iX-UnsafeAccessTest.java.template -o$out\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/generate-unsafe-access-tests.sh","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,2 +88,5 @@\n-            out.shouldContain(\"Memory and Swap Limit is: \" + expectedReadLimit)\n-                .shouldContain(\n+            if (out.getOutput().contains(\"memory_and_swap_limit_in_bytes: not supported\")) {\n+                System.out.println(\"memory_and_swap_limit_in_bytes not supported, avoiding Memory and Swap Limit check\");\n+            } else {\n+                out.shouldContain(\"Memory and Swap Limit is: \" + expectedReadLimit)\n+                    .shouldContain(\n@@ -91,1 +94,2 @@\n-                .shouldContain(\"Memory & Swap Limit: \" + expectedLimit);\n+                    .shouldContain(\"Memory & Swap Limit: \" + expectedLimit);\n+            }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithCgroupV1.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-        true,\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAt.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-        true,\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtError.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-      ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, flags);\n+      ProcessBuilder pb = ProcessTools.createTestJvm(flags);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtMultiple.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-        true,\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/TestVerifyDuringStartup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        return createJavaProcessBuilder(false, arguments);\n+        return createJavaProcessBuilder(arguments.toArray(String[]::new));\n@@ -73,4 +73,2 @@\n-    static public ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions,\n-                                                          List<String> arguments) {\n-        return createJavaProcessBuilder(addTestVmAndJavaOptions,\n-                                        arguments.toArray(String[]::new));\n+    static public ProcessBuilder createJavaProcessBuilder(String... arguments) {\n+        return ProcessTools.createJavaProcessBuilder(withDefaults(arguments));\n@@ -79,2 +77,2 @@\n-    static public ProcessBuilder createJavaProcessBuilder(String... arguments) {\n-        return createJavaProcessBuilder(false, arguments);\n+    static public ProcessBuilder createTestJvm(List<String> arguments) {\n+        return createTestJvm(arguments.toArray(String[]::new));\n@@ -83,4 +81,2 @@\n-    static public ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions,\n-                                                          String... arguments) {\n-        return ProcessTools.createJavaProcessBuilder(addTestVmAndJavaOptions,\n-                                                     withDefaults(arguments));\n+    static public ProcessBuilder createTestJvm(String... arguments) {\n+        return ProcessTools.createTestJvm(withDefaults(arguments));\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/GCArguments.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n-            true,\n+        ProcessBuilder pb = GCArguments.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseNUMAInterleaving.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, opts);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(opts);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(false,\n-                testOpts);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(testOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestLogging.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/whitebox\/TestWBGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",  classTestCName);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-cp\", \".\",  classTestCName);\n","filename":"test\/hotspot\/jtreg\/runtime\/BootstrapMethod\/BSMCalledTwice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",  \"ClassFile\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-cp\", \".\",  \"ClassFile\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/UnsupportedClassFileVersion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -51,1 +51,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(true,\n+        pb = ProcessTools.createTestJvm(\n@@ -57,1 +57,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(true,\n+        pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/SharedArchiveFile\/SharedArchiveFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",  \"Large\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-cp\", \".\",  \"Large\");\n","filename":"test\/hotspot\/jtreg\/runtime\/StackTrace\/LargeClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/RangeCheck.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,2 +79,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/DumpClassList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -117,1 +117,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/GraalWithLimitedMetaspace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmd);\n@@ -200,1 +200,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmd);\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/TestCommon.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        ProcessBuilder dumpPb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder dumpPb = ProcessTools.createTestJvm(\n@@ -61,1 +61,1 @@\n-        ProcessBuilder runPb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder runPb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/sharedStrings\/SharedStringsBasic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        ProcessBuilder dumpPb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder dumpPb = ProcessTools.createTestJvm(\n@@ -54,1 +54,1 @@\n-        ProcessBuilder runPb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder runPb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/sharedStrings\/SysDictCrash.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,2 +56,1 @@\n-            ProcessTools.createJavaProcessBuilder(\n-                    true,\n+            ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeTransitionTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @run driver ModuleOptionsTest\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/ModuleOptionsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,2 +66,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -101,2 +100,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(\n-            true,\n+        pb = ProcessTools.createTestJvm(\n@@ -134,2 +132,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(\n-            true,\n+        pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/PatchModule\/PatchModuleClassList.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-                    ProcessTools.createJavaProcessBuilder(false,\n-                                                          \"-Xlog:os=trace\",\n+                    ProcessTools.createJavaProcessBuilder(\"-Xlog:os=trace\",\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/AvailableProcessors.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-            ProcessTools.createJavaProcessBuilder(false,\n-                                                  \"-Xlog:os=trace\",\n+            ProcessTools.createJavaProcessBuilder(\"-Xlog:os=trace\",\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestUseCpuAllocPath.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",  \"Overrider\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-cp\", \".\",  \"Overrider\");\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/OverriderMsg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-verify\", \"-cp\", \".\",  classCName);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-verify\", \"-cp\", \".\",  classCName);\n@@ -81,1 +81,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(true, \"-verify\", \"-cp\", \".\",  classCName);\n+        pb = ProcessTools.createTestJvm(\"-verify\", \"-cp\", \".\",  classCName);\n@@ -98,1 +98,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(true, \"-verify\", \"-cp\", \".\",  classCName);\n+        pb = ProcessTools.createTestJvm(\"-verify\", \"-cp\", \".\",  classCName);\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestANewArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-cp\", \".\",  \"ClassFile\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-cp\", \".\",  \"ClassFile\");\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestMultiANewArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,9 @@\n+    @SuppressWarnings(\"serial\")\n+    public static class WhiteBoxPermission extends java.security.BasicPermission {\n+        \/\/ ClassFileInstaller is hard-coded to copy WhiteBox$WhiteBoxPermission, so let's\n+        \/\/ make a fake one here as well.\n+        public WhiteBoxPermission(String s) {\n+            super(s);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/sanity\/MismatchedWhiteBox\/WhiteBox.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        ProcessBuilder pt = ProcessTools.createJavaProcessBuilder(true, \"-javaagent:agent.jar\",  \"GetObjectSizeClassAgent\");\n+        ProcessBuilder pt = ProcessTools.createTestJvm(\"-javaagent:agent.jar\",  \"GetObjectSizeClassAgent\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        ProcessBuilder pt = ProcessTools.createJavaProcessBuilder(true, \"-Xmx4000m\", \"-javaagent:agent.jar\",  \"GetObjectSizeOverflowAgent\");\n+        ProcessBuilder pt = ProcessTools.createTestJvm(\"-Xmx4000m\", \"-javaagent:agent.jar\",  \"GetObjectSizeOverflowAgent\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeOverflow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestLogRotation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                   ProcessTools.executeProcess(getTestJavaCommandlineWithPrefix(\n+                   ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n@@ -261,1 +261,1 @@\n-    private static String[] getTestJavaCommandlineWithPrefix(String prefix, String... args) {\n+    private static String[] getTestJvmCommandlineWithPrefix(String prefix, String... args) {\n@@ -263,1 +263,1 @@\n-            String cmd = ProcessTools.getCommandLine(ProcessTools.createJavaProcessBuilder(true, args));\n+            String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJvm(args));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbCDSCore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-XX:+CreateCoredumpOnCrash\",\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-XX:+CreateCoredumpOnCrash\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJmapCore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,3 +177,1 @@\n-                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                        \/* addTestVmAndJavaOptions = *\/ true,\n-                        cmd);\n+                ProcessBuilder pb = ProcessTools.createTestJvm(cmd);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, args);\n+            ProcessBuilder pb = ProcessTools.createTestJvm(args);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/jtreg\/JitTesterDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmd);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ctw\/CtwTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        var pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        var pb = ProcessTools.createTestJvm(cmd);\n@@ -110,1 +110,1 @@\n-        var pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        var pb = ProcessTools.createTestJvm(cmd);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/huge\/quicklook\/largeheap\/MemOptions\/MemOptionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-            var pb = ProcessTools.createJavaProcessBuilder(true,\n+            var pb = ProcessTools.createTestJvm(\n@@ -67,1 +67,1 @@\n-            var pb = ProcessTools.createJavaProcessBuilder(true,\n+            var pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/tiered\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-            ProcessTools.createJavaProcessBuilder(true, \"-XX:MaxMetaspaceSize=100m\",\n-                                                  maxMetaspaceSize.class.getName());\n+            ProcessTools.createTestJvm(\"-XX:MaxMetaspaceSize=100m\",\n+                                       maxMetaspaceSize.class.getName());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/flags\/maxMetaspaceSize\/TestMaxMetaspaceSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+static jrawMonitorID wait_lock;\n@@ -43,1 +44,0 @@\n-static jboolean printdump = JNI_FALSE;\n@@ -45,0 +45,1 @@\n+\n@@ -51,10 +52,3 @@\n-static int entry_count = 0;\n-static int entry_error_count = 0;\n-static int exit_count = 0;\n-static int exit_error_count = 0;\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    jvmtiError err;\n-\n-    err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_THREAD_START, NULL);\n+static void\n+lock(const char* func_name, jrawMonitorID lock) {\n+    jvmtiError err = jvmti->RawMonitorEnter(lock);\n@@ -62,2 +56,2 @@\n-        printf(\"Failed to enable THREAD_START event: %s (%d)\\n\",\n-               TranslateError(err), err);\n+        printf(\"%s: unexpected error in RawMonitorEnter: %s (%d)\\n\",\n+               func_name, TranslateError(err), err);\n@@ -66,20 +60,0 @@\n-\n-    if (caps.can_generate_method_entry_events) {\n-        err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_ENTRY, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable METHOD_ENTRY event: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    if (caps.can_generate_method_exit_events) {\n-        err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable METHOD_EXIT event: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n@@ -88,26 +62,3 @@\n-void JNICALL\n-ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo thrInfo;\n-\n-    err = jvmti_env->RawMonitorEnter(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter#TS) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#TS) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n-        thr_ptr = env->NewGlobalRef(thread);\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n-        }\n-    }\n-\n-    err = jvmti_env->RawMonitorExit(access_lock);\n+static void\n+unlock(const char* func_name, jrawMonitorID lock) {\n+    jvmtiError err = jvmti->RawMonitorExit(lock);\n@@ -115,2 +66,2 @@\n-        printf(\"(RawMonitorExit#TS) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n+        printf(\"%s: unexpected error in RawMonitorExit: %s (%d)\\n\",\n+               func_name, TranslateError(err), err);\n@@ -121,7 +72,3 @@\n-void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thread, jmethodID mid) {\n-    jvmtiError err;\n-    jvmtiThreadInfo thrInfo;\n-    jint thrState;\n-\n-    err = jvmti_env->RawMonitorEnter(access_lock);\n+static void\n+wait(const char* func_name, jrawMonitorID lock, jint millis) {\n+    jvmtiError err = jvmti->RawMonitorWait(lock, (jlong)millis);\n@@ -129,2 +76,2 @@\n-        printf(\"(RawMonitorEnter#ME) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n+        printf(\"%s: unexpected error in RawMonitorWait: %s (%d)\\n\",\n+               func_name, TranslateError(err), err);\n@@ -133,0 +80,1 @@\n+}\n@@ -134,24 +82,7 @@\n-    entry_count++;\n-    err = jvmti_env->GetThreadState(thread, &thrState);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadState#ME) unexpected error: %s (%d)\\n\",\n-            TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if ((thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0) {\n-        if (entry_error_count == 0) {\n-            err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(GetThreadInfo#ME) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                result = STATUS_FAILED;\n-            }\n-            printf(\"Wrong thread \\\"%s\\\" state on MethodEntry event:\\n\",\n-                   thrInfo.name);\n-            printf(\"    expected: JVMTI_THREAD_STATE_RUNNABLE\\n\");\n-            printf(\"    got: %s (%d)\\n\",\n-                   TranslateState(thrState), thrState);\n-        }\n-        entry_error_count++;\n-        result = STATUS_FAILED;\n-    }\n+static void\n+set_notification_mode(const char* event_name,\n+                      jvmtiEventMode mode,\n+                      jvmtiEvent event_type,\n+                      jthread event_thread) {\n+    const char* action = (mode == JVMTI_ENABLE) ? \"enable\" : \"disable\";\n+    jvmtiError err = jvmti->SetEventNotificationMode(mode, event_type, event_thread);\n@@ -159,1 +90,0 @@\n-    err = jvmti_env->RawMonitorExit(access_lock);\n@@ -161,2 +91,2 @@\n-        printf(\"(RawMonitorExit#ME) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n+        printf(\"Failed to %s %s event: %s (%d)\\n\",\n+               action, event_name, TranslateError(err), err);\n@@ -165,0 +95,1 @@\n+}\n@@ -166,0 +97,3 @@\n+void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n+    set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_ENABLE,\n+                          JVMTI_EVENT_THREAD_START, NULL);\n@@ -168,3 +102,2 @@\n-void JNICALL MethodExit(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thread, jmethodID mid,\n-        jboolean was_poped_by_exception, jvalue return_value) {\n+void JNICALL\n+ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n@@ -173,1 +106,0 @@\n-    jint thrState;\n@@ -175,6 +107,1 @@\n-    err = jvmti_env->RawMonitorEnter(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter#MX) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n+    lock(\"ThreadStart\", access_lock);\n@@ -182,2 +109,1 @@\n-    exit_count++;\n-    err = jvmti_env->GetThreadState(thread, &thrState);\n+    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n@@ -185,2 +111,2 @@\n-        printf(\"(GetThreadState#MX) unexpected error: %s (%d)\\n\",\n-            TranslateError(err), err);\n+        printf(\"(GetThreadInfo#TS) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n@@ -189,16 +115,5 @@\n-    if ((thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0) {\n-        if (exit_error_count == 0) {\n-            err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(GetThreadInfo#MX) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                result = STATUS_FAILED;\n-            }\n-            printf(\"Wrong thread \\\"%s\\\" state on MethodExit event:\\n\",\n-                   thrInfo.name);\n-            printf(\"    expected: JVMTI_THREAD_STATE_RUNNABLE\\n\");\n-            printf(\"    got: %s (%d)\\n\",\n-                   TranslateState(thrState), thrState);\n-        }\n-        exit_error_count++;\n-        result = STATUS_FAILED;\n+    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n+        thr_ptr = env->NewGlobalRef(thread);\n+        printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n+        set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_DISABLE,\n+                              JVMTI_EVENT_THREAD_START, NULL);\n@@ -207,6 +122,1 @@\n-    err = jvmti_env->RawMonitorExit(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit#MX) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n+    unlock(\"ThreadStart\", access_lock);\n@@ -226,0 +136,1 @@\n+\n@@ -230,3 +141,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n+    printf(\"Agent_Initialize started\\n\");\n@@ -263,1 +172,8 @@\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n+        printf(\"(CreateRawMonitor)#access_lock unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(CreateRawMonitor#wait_lock) unexpected error: %s (%d)\\n\",\n@@ -270,10 +186,0 @@\n-    if (caps.can_generate_method_entry_events) {\n-        callbacks.MethodEntry = &MethodEntry;\n-    } else {\n-        printf(\"Warning: MethodEntry event is not implemented\\n\");\n-    }\n-    if (caps.can_generate_method_exit_events) {\n-        callbacks.MethodExit = &MethodExit;\n-    } else {\n-        printf(\"Warning: MethodExit event is not implemented\\n\");\n-    }\n@@ -287,7 +193,2 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_VM_INIT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable VM_INIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n+    set_notification_mode(\"JVMTI_EVENT_VM_INIT\", JVMTI_ENABLE,\n+                          JVMTI_EVENT_VM_INIT, NULL);\n@@ -295,0 +196,1 @@\n+    printf(\"Agent_Initialize finished\\n\\n\");\n@@ -302,1 +204,0 @@\n-    jrawMonitorID wait_lock;\n@@ -306,0 +207,1 @@\n+    printf(\"native method checkStatus started\\n\");\n@@ -319,6 +221,0 @@\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n@@ -335,24 +231,3 @@\n-        err = jvmti->RawMonitorEnter(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorWait(wait_lock, (jlong)millis);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorExit(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    err = jvmti->DestroyRawMonitor(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(DestroyRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n+        lock(\"checkStatus\", wait_lock);\n+        wait(\"checkStatus\", wait_lock, millis);\n+        unlock(\"checkStatus\", wait_lock);\n@@ -361,2 +236,1 @@\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n+    printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n@@ -364,1 +238,0 @@\n-    }\n@@ -374,0 +247,1 @@\n+    printf(\"native method checkStatus finished\\n\\n\");\n@@ -378,45 +252,1 @@\n-    jvmtiError err;\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-        JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable THREAD_START event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (caps.can_generate_method_entry_events) {\n-        err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_METHOD_ENTRY, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to disable METHOD_ENTRY event: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    if (caps.can_generate_method_exit_events) {\n-        err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to disable METHOD_EXIT event: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> total number of method entry events = %d\\n\", entry_count);\n-        printf(\">>> total number of method exit events = %d\\n\", exit_count);\n-    }\n-\n-    if (entry_error_count != 0) {\n-        printf(\"Total number of errors on METHOD_ENTRY: %d of %d events\\n\",\n-               entry_error_count, entry_count);\n-    }\n-\n-    if (exit_error_count != 0) {\n-        printf(\"Total number of errors on METHOD_EXIT: %d of %d events\\n\",\n-               exit_error_count, exit_count);\n-    }\n-\n+    printf(\"native method getRes: result: %d\\n\\n\", result);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/thrstat001.cpp","additions":64,"deletions":234,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RetransformClasses\/retransform003\/TestDriver.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- *      -agentlib:SetNativeMethodPrefix001=\n+ *      -agentlib:SetNativeMethodPrefix001\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetNativeMethodPrefix\/SetNativeMethodPrefix001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetNativeMethodPrefix\/SetNativeMethodPrefix002\/TestDriver.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-#define NSK_JVMTI_OPTION_VAL_SEP    '='\n@@ -194,12 +193,6 @@\n-int isOptSep(char c) {\n-    return isspace(c) || c == '~';\n-}\n-\n-\n-\/**\n- *\n- * The current option will not perform more than one\n- * single option which given, this is due to places explained\n- * in this question.\n- *\n- **\/\n+\/*\n+ * Tokenize a string based on a list of delimiters.\n+ *\/\n+static char* token(char **s, const char *delim) {\n+  char *p;\n+  char *start = *s;\n@@ -207,4 +200,16 @@\n- \/*\n-  * This whole play can be reduced with simple StringTokenizer (strtok).\n-  *\n-  *\/\n+  if (s == NULL || *s == NULL) {\n+    return NULL;\n+  }\n+\n+  p = strpbrk(*s, delim);\n+  if (p != NULL) {\n+    \/* Advance to next token. *\/\n+    *p = '\\0';\n+    *s = p + 1;\n+  } else {\n+    \/* End of tokens. *\/\n+    *s = NULL;\n+  }\n+\n+  return start;\n+}\n@@ -218,2 +223,0 @@\n-    size_t len;\n-    const char* opt;\n@@ -222,4 +225,4 @@\n-    context.options.string = NULL;\n-    context.options.count = 0;\n-    context.waittime = 2;\n-\n+    char *str = NULL;\n+    char *name = NULL;\n+    char *value = NULL;\n+    const char *delimiters = \" ,~\";\n@@ -227,1 +230,1 @@\n-        return NSK_TRUE;\n+        return success;\n@@ -229,2 +232,5 @@\n-    len = strlen(options);\n-    context.options.string = (char*)malloc(len + 2);\n+    \/*\n+     * Save a copy of the full options string for\n+     * ArgumentHandler.getAgentOptionsString().\n+     *\/\n+    context.options.string = strdup(options);\n@@ -232,29 +238,4 @@\n-    if (context.options.string == NULL) {\n-            nsk_complain(\"nsk_jvmti_parseOptions(): out of memory\\n\");\n-            return NSK_FALSE;\n-    }\n-    strncpy(context.options.string, options, len);\n-    context.options.string[len] = '\\0';\n-    context.options.string[len+1] = '\\0';\n-\n-    for (opt = context.options.string; ; ) {\n-        const char* opt_end;\n-        const char* val_sep;\n-        int opt_len=0;\n-        int val_len=0;\n-                int exit=1;\n-\n-        while (*opt != '\\0' && isOptSep(*opt)) opt++;\n-        if (*opt == '\\0') break;\n-\n-        val_sep = NULL;\n-        \/*\n-            This should break when the first option it encounters other wise\n-        *\/\n-        for (opt_end = opt, opt_len=0; !(*opt_end == '\\0' || isOptSep(*opt_end)); opt_end++,opt_len++) {\n-            if (*opt_end == NSK_JVMTI_OPTION_VAL_SEP) {\n-                val_sep = opt_end;\n-                exit=0;\n-                break;\n-            }\n-        }\n+    \/* Create a temporary copy of the options string to be tokenized. *\/\n+    str = strdup(options);\n+    while ((name = token(&str, delimiters)) != NULL) {\n+        value = strchr(name, '=');\n@@ -262,18 +243,2 @@\n-        if (exit == 1) break;\n-\n-        \/* now scan for the search  for the option value end.\n-\n-        *\/\n-        exit =1;\n-        opt_end++;\n-        val_sep++;\n-        \/**\n-         * I was expecting this jvmti_parseOptions(),\n-         * should be for multiple options as well.\n-         * If this break is not there then It will expects\n-         * to have. so a space should be sufficient as well.\n-         *\/\n-        for(val_len=0; !(*opt_end == '\\0' || isOptSep(*opt_end)); opt_end++,val_len++) {\n-            \/\/if (*opt_end == NSK_JVMTI_OPTION_START) {\n-            \/\/    break;\n-            \/\/}\n+        if (value != NULL) {\n+            *value++ = '\\0';\n@@ -281,2 +246,2 @@\n-\n-        if (!add_option(opt, opt_len, val_sep, val_len)) {\n+        if (!add_option(name, (int)strlen(name), value,\n+                        value ? (int)strlen(value) : 0)) {\n@@ -286,2 +251,0 @@\n-        opt_end++;\n-        opt = opt_end;\n@@ -289,1 +252,0 @@\n-\n@@ -293,1 +255,3 @@\n-\n+    if (str != NULL) {\n+      free(str);\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_tools.cpp","additions":44,"deletions":80,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            var pb = ProcessTools.createJavaProcessBuilder(true,\n+            var pb = ProcessTools.createTestJvm(\n@@ -66,1 +66,1 @@\n-            var pb = ProcessTools.createJavaProcessBuilder(true,\n+            var pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/CodeCacheInfo\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        var pb = ProcessTools.createJavaProcessBuilder(true,\n+        var pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/CodeCacheInfoOnCompilation\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package transform;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.InputStream;\n+\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.Result;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+import static jaxp.library.JAXPTestUtilities.compareWithGold;\n+import static jaxp.library.JAXPTestUtilities.compareStringWithGold;\n+import org.testng.Assert;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8268457\n+ * @library \/javax\/xml\/jaxp\/libs\n+ * @run testng transform.SurrogateTest\n+ * @summary XML Transformer outputs Unicode supplementary character incorrectly to HTML\n+ *\/\n+@Listeners({jaxp.library.FilePolicy.class})\n+public class SurrogateTest {\n+\n+    final static String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+\n+    @Test\n+    public void toHTMLTest() throws Exception {\n+        String out = \"SurrogateTest1out.html\";\n+        String expected = TEST_SRC + File.separator + \"SurrogateTest1.html\";\n+        String xsl = TEST_SRC + File.separator + \"SurrogateTest1.xsl\";\n+\n+        try (FileInputStream tFis = new FileInputStream(xsl);\n+            InputStream fis = this.getClass().getResourceAsStream(\"SurrogateTest1.xml\");\n+            FileOutputStream fos = new FileOutputStream(out)) {\n+\n+            Source tSrc = new StreamSource(tFis);\n+            TransformerFactory tf = TransformerFactory.newInstance();\n+            Transformer t = tf.newTransformer(tSrc);\n+            t.setOutputProperty(\"method\", \"html\");\n+\n+            Source src = new StreamSource(fis);\n+            Result res = new StreamResult(fos);\n+            t.transform(src, res);\n+        }\n+        compareWithGold(expected, out);\n+    }\n+\n+    @Test\n+    public void handlerTest() throws Exception {\n+        File xmlFile = new File(TEST_SRC, \"SurrogateTest2.xml\");\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        spf.setNamespaceAware(true);\n+        SAXParser sp = spf.newSAXParser();\n+        TestHandler th = new TestHandler();\n+        sp.parse(xmlFile, th);\n+        compareStringWithGold(TEST_SRC + File.separator + \"SurrogateTest2.txt\", th.sb.toString());\n+    }\n+\n+    private static class TestHandler extends DefaultHandler {\n+        private StringBuilder sb = new StringBuilder();\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            sb.append( localName + \"@attr:\" + attributes.getValue(\"attr\") + '\\n');\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\">\n+<html>\n+    <head>\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\">\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\">\n+    <\/head>\n+    <body>\n+        <form>\n+            <input id=\"tag1\" value=\"\">\n+        <\/form>\n+    <\/body>\n+<\/html>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.html","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<root>\n+    <tag1><\/tag1>\n+<\/root>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" version=\"1.0\">\n+  <xsl:output doctype-public=\"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\"\n+   doctype-system=\"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\"\n+   encoding=\"UTF-8\" indent=\"yes\" method=\"html\" omit-xml-declaration=\"yes\"\/>\n+  <xsl:template match=\"\/\">\n+    <html>\n+      <head>\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\"\/>\n+      <\/head>\n+      <body>\n+        <xsl:for-each select=\"root\">\n+          <form>\n+            <xsl:for-each select=\"tag1\">\n+              <input id=\"tag1\">\n+                <xsl:attribute name=\"value\">\n+                  <xsl:value-of select=\".\"\/>\n+                <\/xsl:attribute>\n+              <\/input>\n+            <\/xsl:for-each>\n+          <\/form>\n+        <\/xsl:for-each>\n+      <\/body>\n+    <\/html>\n+  <\/xsl:template>\n+<\/xsl:stylesheet>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.xsl","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+root@attr:null\n+tag1@attr:\n+tag2@attr:\n+tag3@attr:\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest2.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<root>\n+    <tag1 attr=\"\"\/>\n+    <tag2 attr=\"\"\/>\n+    <tag3 attr=\"\"\/>\n+<\/root>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest2.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+\n+\/*\n+ * @test\n+ * @bug 8289508\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathAncestorsTest\n+ * @summary Tests for XPath ancestor and ancestor-or-self axis specifiers.\n+ *\/\n+public class XPathAncestorsTest {\n+\n+    private static final String XML =\n+            \"<store>\\n\" +\n+            \"   <book id=\\\"1\\\" lang=\\\"en\\\">\\n\" +\n+            \"      <title\/>\\n\" +\n+            \"      <author id=\\\"1\\\"\/>\\n\" +\n+            \"      <isbn>1234<\/isbn>\\n\" +\n+            \"   <\/book>\\n\" +\n+            \"   <book id=\\\"2\\\" lang=\\\"en\\\">\\n\" +\n+            \"      <title\/>\\n\" +\n+            \"      <author id=\\\"2\\\"\/>\\n\" +\n+            \"      <isbn>5678<\/isbn>\\n\" +\n+            \"   <\/book>\\n\" +\n+            \"<\/store>\\n\"\n+            ;\n+    private static final Document doc;\n+\n+    static {\n+        try {\n+            var builder =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+            InputStream s = new ByteArrayInputStream(XML.getBytes());\n+            doc = builder.parse(s);\n+        } catch (Exception e) {\n+            System.out.println(\"Exception while initializing XML document\");\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    \/*\n+     * DataProvider:provides XPath expression using ancestor\/ancestor-or-self\n+     * and the expected node(s) from the expression\n+     *\/\n+    @DataProvider(name = \"ancestors_axes\")\n+    public Object[][] getXPathAncestors() {\n+        return new Object[][]{\n+                \/\/test ancestor\n+\n+                \/\/ abbreviated text\n+                {\"\/\/author\/ancestor::book\/ancestor::store\", \"\/store\"},\n+                {\"\/\/isbn\/ancestor::store\", \"\/store\"},\n+                {\"\/\/ancestor::book[1]\", \"\/\/book[1]\"},\n+\n+                \/\/ any node\n+                {\"\/\/book\/ancestor::*\", \"\/store\"},\n+                {\"\/\/author\/ancestor::*[ancestor::store]\/ancestor::store\", \"\/store\"},\n+                {\"\/\/author\/ancestor::node()[ancestor::store]\", \"\/\/book\"},\n+\n+                \/\/ dot reference\n+                {\"\/\/author\/ancestor::book\/..\", \"\/store\"},\n+                {\"\/\/author\/ancestor::*[ancestor::store]\/..\", \"\/store\"},\n+                {\"\/\/ancestor::book\/..\", \"\/store\"},\n+\n+                \/\/ attributes\n+                {\"\/\/author\/ancestor::*[@id]\/parent::*\", \"\/store\"},\n+                {\"\/\/author\/parent::*[@id]\/ancestor::*\", \"\/store\"},\n+                {\"\/\/author[@id='1']\/ancestor::book[1]\", \"\/\/book[1]\"},\n+                {\"\/\/author[@*]\/ancestor::book[1]\", \"\/\/book[1]\"},\n+\n+                \/\/test ancestor-or-self\n+\n+                \/\/ any node, indexing, id\n+                {\"\/store\/ancestor-or-self::*\", \"\/store\"},\n+                {\"\/\/book[*]\/ancestor-or-self::book[1]\", \"\/\/book[1]\"},\n+                {\"\/store\/book[@*]\/ancestor-or-self::book[1]\", \"\/\/book[1]\"},\n+                {\"\/\/book[@id='1']\/ancestor-or-self::book[1]\", \"\/\/book[1]\"},\n+                {\"\/\/author[@id='2']\/ancestor-or-self::book\", \"\/\/book[2]\"},\n+                {\"\/\/book[1]\/ancestor-or-self::store\", \"\/store\"},\n+\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath expressions that return empty NodeSet\n+     *\/\n+    @DataProvider(name = \"emptyNodeSet\")\n+    public Object[][] getEmptyNodeSet() {\n+        return new Object[][]{\n+                \/\/ test ancestor\n+\n+                \/\/ abbreviated text\n+                {\"\/store\/book\/ancestor::book\"},\n+                {\"\/\/author\/ancestor::store[2]\"},\n+                {\"\/\/author[3]\/ancestor::store\"},\n+\n+                \/\/ any nodes\n+                {\"\/store\/ancestor::*\"},\n+                {\"\/store\/book[3]\/ancestor::*\"},\n+                {\"\/\/book[*]\/..\/ancestor::*\"},\n+                {\"\/store\/book[@id='3']\/ancestor::*\"},\n+                {\"\/\/book\/ssn\/ancestor::*\"},\n+                {\"\/\/author\/ancestor::*[ancestor::isbn]\"},\n+                {\"\/store\/..\/ancestor::*\"},\n+                {\"\/\/ancestor::author\"},\n+\n+                \/\/ id\n+                {\"\/store\/book[@id='3']\/ancestor::*\"},\n+                {\"\/store[@*]\/ancestor::*\"},\n+                {\"\/book[@*]\/ancestor::*\/ancestor::*\"},\n+                {\"\/\/book[@category]\/ancestor::*\"},\n+\n+                \/\/test ancestor-or-self\n+\n+                \/\/ any nodes, id\n+                {\"\/store\/..\/ancestor-or-self::*\"},\n+                {\"\/\/book[3]\/ancestor-or-self::*\"},\n+                {\"\/\/author\/ancestor-or-self::title\"},\n+                {\"\/\/author[@id='2']\/ancestor-or-self::*[@id='1']\"},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies XPath ancestor and ancestor-or-self axis specifiers\n+     * by comparing expression and expected result.\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test failed\n+     *\/\n+    @Test(dataProvider = \"ancestors_axes\")\n+    void testXPathAncestors(String exp, String parent) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node result = xPath.evaluateExpression(exp, doc, Node.class);\n+        Node expected = xPath.evaluateExpression(parent, doc, Node.class);\n+        Assert.assertEquals(result, expected);\n+    }\n+\n+    \/**\n+     * Verifies no nodes returned from the XPath expression.\n+     *\n+     * @param exp XPath expression\n+     * @throws Exception\n+     *\/\n+    @Test(dataProvider = \"emptyNodeSet\")\n+    void testEmptyNodeSet(String exp) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node result = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertEquals(result, null);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathAncestorsTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+\n+\/*\n+ * @test\n+ * @bug 8289508\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathPrecedingTest\n+ * @summary Tests for XPath preceding and preceding-sibling axis specifiers.\n+ *\/\n+public class XPathPrecedingTest {\n+\n+    private static final String XML =\n+            \"<store>\\n\" +\n+            \"   <book id=\\\"1\\\" lang=\\\"en\\\">\\n\" +\n+            \"      <title>Book1<\/title>\\n\" +\n+            \"      <author id=\\\"1\\\"\/>\\n\" +\n+            \"      <isbn>1234<\/isbn>\\n\" +\n+            \"   <\/book>\\n\" +\n+            \"   <book id=\\\"2\\\" lang=\\\"en\\\" xmlns=\\\"www.foo.com\\\">\\n\" +\n+            \"      <title>Book2<\/title>\\n\" +\n+            \"      <author id=\\\"2\\\"\/>\\n\" +\n+            \"      <isbn>5678<\/isbn>\\n\" +\n+            \"   <\/book>\\n\" +\n+            \"<\/store>\\n\"\n+            ;\n+    private static final Document doc;\n+\n+    static {\n+        try {\n+            var builder =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+            InputStream s = new ByteArrayInputStream(XML.getBytes());\n+            doc = builder.parse(s);\n+        } catch (Exception e) {\n+            System.out.println(\"Exception while initializing XML document\");\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath expression using preceding\/preceding-sibling\n+     * and the expected node(s) from the expression\n+     *\/\n+    @DataProvider(name = \"preceding_axes\")\n+    public Object[][] getXPathPreceding() {\n+        return new Object[][]{\n+                \/\/ test preceding\n+\n+                \/\/ any nodes\n+                {\"\/store\/book[1]\/author\/preceding::*\", \"\/store\/book[1]\/title\"},\n+\n+                \/\/ abbreviated text\n+                {\"\/store\/book[1]\/isbn\/preceding::*[1]\", \"\/store\/book[1]\/author\"},\n+                {\"(\/store\/book[1]\/isbn\/preceding::*)[1]\", \"\/store\/book[1]\/title\"},\n+                {\"\/\/isbn\/preceding::book\", \"\/\/book[1]\"},\n+                {\"\/\/book[2]\/preceding::book\", \"\/\/book[1]\"},\n+                {\"\/store\/book[preceding::book]\", \"\/\/book[2]\"},\n+                {\"\/store\/book[preceding::book]\/preceding::book\", \"\/\/book[1]\"},\n+\n+                \/\/ id\n+                {\"\/\/author[@id='2']\/..\/preceding::book\", \"\/\/book[1]\"},\n+                {\"\/\/author[@id='2']\/preceding::node()\/preceding::book\", \"\/\/book[1]\"},\n+                {\"\/\/author[@id='1']\/preceding::title\", \"\/\/book[1]\/title\"},\n+\n+                \/\/test preceding-sibling\n+\n+                \/\/ any node\n+                {\"\/store\/book[1]\/author\/preceding-sibling::*\", \"\/store\/book[1]\/title\"},\n+                {\"\/store\/book[2]\/preceding-sibling::*\", \"\/\/book[1]\"},\n+                {\"\/\/author\/preceding-sibling::*\", \"\/\/title\"},\n+\n+                \/\/ abbreviated text\n+                {\"\/store\/book[preceding::book]\/preceding-sibling::book\", \"\/\/book[1]\"},\n+\n+                \/\/ id\n+                {\"\/store\/book[1]\/isbn[preceding-sibling::author[@id='1']]\", \"\/store\/book[1]\/isbn\"},\n+\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath expressions that return empty NodeSet\n+     *\/\n+    @DataProvider(name = \"emptyNodeSet\")\n+    public Object[][] getEmptyNodeSet() {\n+        return new Object[][]{\n+                \/\/test preceding\n+\n+                \/\/ abbreviated text\n+                {\"\/store\/preceding::book\"},\n+                {\"\/store\/book[1]\/author\/preceding::author\"},\n+\n+                \/\/ any nodes\/id\n+                {\"\/store\/book[1]\/preceding::*\"},\n+                {\"\/store\/book[1]\/title\/preceding::*\"},\n+                {\"\/store\/book[@id='1']\/preceding::*\"},\n+\n+                \/\/test preceding-sibling\n+\n+                \/\/ any nodes\n+                {\"\/store\/book[1]\/preceding-sibling::*\"},\n+                {\"\/store\/book[2]\/title\/preceding-sibling::*\"},\n+\n+                \/\/ abbreviated text \/ id\n+                {\"\/store\/book[1]\/author\/preceding-sibling::isbn\"},\n+                {\"\/\/author[@id='2']\/preceding-sibling::book\"},\n+                {\"\/\/author[@id='2']\/preceding-sibling::node()\/preceding-sibling::author\"},\n+\n+                \/\/ attribute \/ namespace\n+                {\"\/store\/book[2]\/@id\/preceding-sibling::*\"},\n+                {\"\/store\/book\/@lang\/preceding-sibling::*\"},\n+                {\"\/store\/book[2]\/namespace::*\/preceding-sibling::*\"},\n+\n+                \/\/ text node\n+                {\"\/store\/book[2]\/isbn\/text()\/preceding-sibling::*\"},\n+\n+        };\n+    }\n+\n+    \/**\n+     * Verifies XPath preceding and preceding-sibling axis specifiers by\n+     * comparing expression and expected result.\n+     * @param exp      XPath expression\n+     * @param expected expected result\n+     * @throws Exception if test failed\n+     *\/\n+    @Test(dataProvider = \"preceding_axes\")\n+    void testXPathPreceding(String exp, String parent) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node result = xPath.evaluateExpression(exp, doc, Node.class);\n+        Node expected = xPath.evaluateExpression(parent, doc, Node.class);\n+        Assert.assertEquals(result, expected);\n+    }\n+\n+    \/**\n+     * Verifies no nodes returned from the XPath expression.\n+     *\n+     * @param exp XPath expression\n+     * @throws Exception\n+     *\/\n+    @Test(dataProvider = \"emptyNodeSet\")\n+    void testEmptyNodeSet(String exp) throws Exception {\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node result = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertEquals(result, null);\n+    }\n+}\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathPrecedingTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -625,4 +625,0 @@\n-sun\/security\/pkcs11\/KeyStore\/SecretKeysBasic.java                 8209398 generic-all\n-\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/ActalisCA.java  8224768 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true);\n+        ProcessBuilder pb = ProcessTools.createTestJvm();\n","filename":"test\/jdk\/com\/sun\/jdi\/JITDebug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8234808\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm JdbOptions\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import lib.jdb.Jdb;\n+import lib.jdb.JdbCommand;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+class JbdOptionsTarg {\n+    static final String OK_MSG = \"JbdOptionsTarg: OK\";\n+\n+    static String argString(String s) {\n+        return \"arg >\" + s + \"<\";\n+    }\n+\n+    static String propString(String name, String value) {\n+        return \"prop[\" + name + \"] = >\" + value + \"<\";\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(OK_MSG);\n+        \/\/ print all args\n+        List<String> vmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n+        for (String s: vmArgs) {\n+            System.out.println(argString(s));\n+        }\n+        \/\/ print requested sys.props\n+        for (String p: args) {\n+            System.out.println(propString(p, System.getProperty(p)));\n+        }\n+    }\n+}\n+\n+public class JdbOptions {\n+    private static final String targ = JbdOptionsTarg.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ the simplest case\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options=-client -XX:+PrintVMOptions,main=\" + targ)\n+            .expectedArg(\"-XX:+PrintVMOptions\");\n+\n+        \/\/ pass property through 'options'\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options='-Dboo=foo',main=\" + targ + \" boo\")\n+            .expectedProp(\"boo\", \"foo\");\n+\n+        \/\/ property with spaces\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options=\\\"-Dboo=foo 2\\\",main=\" + targ + \" boo\")\n+            .expectedProp(\"boo\", \"foo 2\");\n+\n+        \/\/ property with spaces (with single quotes)\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options='-Dboo=foo 2',main=\" + targ + \" boo\")\n+                .expectedProp(\"boo\", \"foo 2\");\n+\n+        \/\/ properties with spaces (with single quotes)\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options=-Dboo=foo '-Dboo2=foo 2',main=\" + targ + \" boo boo2\")\n+                .expectedProp(\"boo\", \"foo\")\n+                .expectedProp(\"boo2\", \"foo 2\");\n+\n+        \/\/ 'options' contains commas - values are quoted (double quotes)\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options=\\\"-client\\\" \\\"-XX:+PrintVMOptions\\\"\"\n+                + \" -XX:+IgnoreUnrecognizedVMOptions\"\n+                + \" \\\"-XX:StartFlightRecording=dumponexit=true,maxsize=500M\\\" \\\"-XX:FlightRecorderOptions=repository=jfrrep\\\"\"\n+                + \",main=\" + targ)\n+            .expectedArg(\"-XX:StartFlightRecording=dumponexit=true,maxsize=500M\")\n+            .expectedArg(\"-XX:FlightRecorderOptions=repository=jfrrep\");\n+\n+        \/\/ 'options' contains commas - values are quoted (single quotes)\n+        test(\"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options='-client' '-XX:+PrintVMOptions'\"\n+                        + \" -XX:+IgnoreUnrecognizedVMOptions\"\n+                        + \" '-XX:StartFlightRecording=dumponexit=true,maxsize=500M' '-XX:FlightRecorderOptions=repository=jfrrep'\"\n+                        + \",main=\" + targ)\n+            .expectedArg(\"-XX:StartFlightRecording=dumponexit=true,maxsize=500M\")\n+            .expectedArg(\"-XX:FlightRecorderOptions=repository=jfrrep\");\n+\n+        \/\/ java options are specified in 2 ways, with and without spaces\n+        \/\/ options are quoted by using single and double quotes.\n+        test(\"-Dprop1=val1\",\n+                \"-Dprop2=val 2\",\n+                \"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,options=-Dprop3=val3 '-Dprop4=val 4'\"\n+                        + \" -XX:+IgnoreUnrecognizedVMOptions\"\n+                        + \" \\\"-XX:StartFlightRecording=dumponexit=true,maxsize=500M\\\"\"\n+                        + \" '-XX:FlightRecorderOptions=repository=jfrrep'\"\n+                        + \",main=\" + targ + \" prop1 prop2 prop3 prop4\")\n+                .expectedProp(\"prop1\", \"val1\")\n+                .expectedProp(\"prop2\", \"val 2\")\n+                .expectedProp(\"prop3\", \"val3\")\n+                .expectedProp(\"prop4\", \"val 4\")\n+                .expectedArg(\"-XX:StartFlightRecording=dumponexit=true,maxsize=500M\")\n+                .expectedArg(\"-XX:FlightRecorderOptions=repository=jfrrep\");\n+\n+    }\n+\n+    private static class TestResult {\n+        OutputAnalyzer out;\n+        TestResult(OutputAnalyzer output) {\n+            out = output;\n+        }\n+        TestResult expectedArg(String s) {\n+            out.shouldContain(JbdOptionsTarg.argString(s));\n+            return this;\n+        }\n+        TestResult expectedProp(String name, String value) {\n+            out.shouldContain(JbdOptionsTarg.propString(name, value));\n+            return this;\n+        }\n+    }\n+\n+    private static TestResult test(String... args) throws Exception {\n+        System.out.println();\n+        System.out.println(\"...testcase...\");\n+        if (Platform.isWindows()) {\n+            \/\/ on Windows we need to escape quotes\n+            args = Arrays.stream(args)\n+                    .map(s -> s.replace(\"\\\"\", \"\\\\\\\"\"))\n+                    .toArray(String[]::new);\n+        }\n+        try (Jdb jdb = new Jdb(args)) {\n+            jdb.waitForSimplePrompt(1024, true); \/\/ 1024 lines should be enough\n+            jdb.command(JdbCommand.run().allowExit());\n+            OutputAnalyzer out = new OutputAnalyzer(jdb.getJdbOutput());\n+            out.shouldContain(JbdOptionsTarg.OK_MSG);\n+            return new TestResult(out);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbOptions.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -85,1 +85,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/com\/sun\/jdi\/PrivateTransportTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        pb = ProcessTools.createJavaProcessBuilder(true, testArgs);\n+        pb = ProcessTools.createTestJvm(testArgs);\n","filename":"test\/jdk\/com\/sun\/jdi\/cds\/CDSJDITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-        private boolean addTestVmAndJavaOptions = true;\n@@ -99,5 +98,0 @@\n-        \/\/ default is \"true\"\n-        public Launcher addTestVmAndJavaOptions(boolean value) {\n-            addTestVmAndJavaOptions = value;\n-            return this;\n-        }\n@@ -112,2 +106,1 @@\n-            return ProcessTools.createJavaProcessBuilder(addTestVmAndJavaOptions,\n-                    debuggeeArgs.toArray(new String[0]));\n+            return ProcessTools.createTestJvm(debuggeeArgs);\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @key intermittent\n@@ -28,1 +29,4 @@\n- *           Testing for Bind exception on Windows\n+ *           Testing for Bind exception on Windows. This test may fail\n+ *           intermittently if other tests \/ process manage to bind to\n+ *           the same port that the test is using in the short window\n+ *           time where the port might appear available again.\n@@ -44,1 +48,1 @@\n-        final int serverPort = server.getAddress().getPort();\n+        int serverPort = server.getAddress().getPort();\n@@ -49,0 +53,1 @@\n+        boolean failedOnce = false;\n@@ -50,8 +55,21 @@\n-        for (int i = 0; i < 100; i++) {\n-            try {\n-                server = HttpServer.create(serverAddr, 0);\n-                server.start();\n-                server.stop(0);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-                exceptionCount++;\n+        RETRY: while (exceptionCount == 0) {\n+            for (int i = 0; i < 100; i++) {\n+                try {\n+                    server = HttpServer.create(serverAddr, 0);\n+                    server.start();\n+                    server.stop(0);\n+                } catch (Exception ex) {\n+                    if (!failedOnce) {\n+                        failedOnce = true;\n+                        server = HttpServer.create(new InetSocketAddress(0), 0);\n+                        serverPort = server.getAddress().getPort();\n+                        server.start();\n+                        server.stop(0);\n+                        serverAddr = new InetSocketAddress(serverPort);\n+                        System.out.println(\"Retrying with serverPort == \" + serverPort);\n+                        continue RETRY;\n+                    }\n+                    System.err.println(\"Got exception at iteration: \" + i );\n+                    ex.printStackTrace();\n+                    exceptionCount++;\n+                }\n@@ -59,0 +77,1 @@\n+            break;\n@@ -61,1 +80,2 @@\n-           throw new RuntimeException(\"Test Failed\");\n+           throw new RuntimeException(\"Test Failed: got \"\n+                 + exceptionCount + \" exceptions.\");\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SimpleHttpServerTest.java","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -37,0 +38,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -80,1 +83,1 @@\n-        s.setSoTimeout (5000);\n+        s.setSoTimeout ((int) Utils.adjustTimeout(5000));\n@@ -127,2 +130,2 @@\n-    public static boolean ok = false;\n-    static int requests = 0;\n+    public static volatile boolean ok = false;\n+    static volatile int requests = 0;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6393710.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6251988\n+  @summary PIT: Choice consumes MouseReleased, MouseClicked events when clicking it with left button,\n+  @key headful\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+public class ChoiceConsumeMouseEvents {\n+\n+    static volatile Frame frame;\n+    static volatile Robot robot;\n+    static volatile Choice choice1 = new Choice();\n+    static volatile boolean mousePressed = false;\n+    static volatile boolean mouseReleased = false;\n+    static volatile boolean mouseClicked = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+           if (frame != null) {\n+               EventQueue.invokeAndWait(() -> frame.dispose());\n+           }\n+        }\n+    }\n+\n+    static void createUI() {\n+        for (int i = 1; i<10; i++){\n+            choice1.add(\"item-0\"+i);\n+        }\n+        choice1.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                mousePressed = true;\n+                System.out.println(me);\n+            }\n+            public void mouseReleased(MouseEvent me) {\n+                mouseReleased = true;\n+                System.out.println(me);\n+            }\n+            public void mouseClicked(MouseEvent me) {\n+                mouseClicked = true;\n+                System.out.println(me);\n+            }\n+        });\n+\n+        frame = new Frame(\"ChoiceConsumeMouseEvents\");\n+        frame.add(choice1);\n+        frame.setSize(400, 400);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        frame.validate();\n+    }\n+\n+    static void runTest() {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(50);\n+            robot.delay(100);\n+            testMouseClick(InputEvent.BUTTON1_DOWN_MASK, 0);\n+            robot.delay(100);\n+            testMouseClick(InputEvent.BUTTON1_DOWN_MASK, 100);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Test failed. Exception thrown: \"+e);\n+        }\n+    }\n+\n+    static void testMouseClick(int button, int delay) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(button);\n+        robot.delay(delay);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        if (!(mousePressed &&\n+              mouseReleased &&\n+              mouseClicked))\n+        {\n+            throw new RuntimeException(\"Test failed. Choice should generate PRESSED, RELEASED, CLICKED events\");\n+        } else {\n+            System.out.println(\"Test passed. Choice generated MouseDragged PRESSED, RELEASED, CLICKED events\");\n+        }\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+        mousePressed = false;\n+        mouseReleased = false;\n+        mouseClicked = false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceConsumeMouseEvents.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4338368\n+  @summary Tests that choice doesn't throw spurious mouse events when losing focus\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ChoiceFocusLostTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.delay(50);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (!client.isPassed()) {\n+                throw new RuntimeException(\"Test failed: choice fires spurious events\");\n+            } else {\n+                System.out.println(\"Test passed.\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static volatile Frame frame;\n+    static volatile ChoiceBug client;\n+\n+    static void createUI() {\n+        frame = new Frame(\"ChoiceFocusLostTest\");\n+        client = new ChoiceBug();\n+        frame.add(client);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+}\n+\n+class ChoiceBug extends Panel {\n+\n+    volatile boolean passed = true;\n+\n+    public ChoiceBug() {\n+        Choice choice = new Choice();\n+        choice.add(\"item-1\");\n+        choice.add(\"item-2\");\n+        Button button = new Button(\"Button\");\n+        add(choice);\n+        add(button);\n+        choice.addMouseListener(new MouseAdapter() {\n+            public void mouseReleased(MouseEvent me) {\n+                passed = false;\n+            }\n+            public void mouseClicked(MouseEvent me) {\n+                passed = false;\n+            }\n+        });\n+        choice.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                System.out.println(\"Focus Gained\");\n+                System.out.println(fe);\n+            }\n+            public void focusLost(FocusEvent fe) {\n+                System.out.println(\"Got expected FocusLost event.\");\n+                System.out.println(fe);\n+            }\n+        });\n+        setSize(400, 400);\n+        choice.requestFocus();\n+    }\n+\n+    public boolean isPassed() {\n+        return passed;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceFocusLostTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4303064\n+  @summary Tests that choice doesn't freeze display when its container is\n+           disabled and enabled after.\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ChoiceFreezeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static volatile Frame frame;\n+    static volatile ChoiceFreezeBug client;\n+\n+    static void createUI() {\n+        frame = new Frame(\"ChoiceFreezeTest\");\n+        client = new ChoiceFreezeBug();\n+        frame.add(client);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        client.init();\n+     }\n+\n+     static void runTest() throws Exception {\n+         Robot robot = new Robot();\n+         robot.waitForIdle();\n+         robot.delay(2000);\n+         robot.mouseMove(client.choice.getLocationOnScreen().x + 1, client.choice.getLocationOnScreen().y + 1);\n+         robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.delay(1000);\n+         robot.mouseMove(client.button.getLocationOnScreen().x + 3, client.button.getLocationOnScreen().y + 3);\n+         robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.delay(1000);\n+         robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+         robot.delay(6000);\n+\n+         if (!client.isPassed()) {\n+             throw new RuntimeException(\"Test failed: display is frozen.\");\n+         }\n+    }\n+}\n+\n+class ChoiceFreezeBug extends Panel {\n+\n+    volatile Button button;\n+    volatile Choice choice;\n+    volatile ChoiceMouseListener listener = new ChoiceMouseListener();\n+\n+    public ChoiceFreezeBug() {\n+        choice = new Choice();\n+        choice.addItem(\"Item 1\");\n+        choice.addItem(\"Item 2\");\n+        button = new Button(\"Button\");\n+        add(choice);\n+        add(button);\n+        button.addMouseListener(listener);\n+        setEnabled(false);\n+    }\n+\n+    void init() {\n+        setEnabled(true);\n+        choice.requestFocus();\n+    }\n+\n+    public boolean isPassed() {\n+        return listener.isPassed();\n+    }\n+}\n+\n+class ChoiceMouseListener extends MouseAdapter {\n+\n+    volatile boolean passed = false;\n+\n+    public void mouseReleased(MouseEvent e) {\n+        passed = true;\n+    }\n+\n+    public void mousePressed(MouseEvent e) {\n+        passed = true;\n+    }\n+\n+    public boolean isPassed() {\n+        return passed;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceFreezeTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6239941\n+  @summary Choice triggers ItemEvent when selecting an item with right mouse button, Xtoolkit\n+  @key headful\n+  @requires (os.family == \"linux\")\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n+\n+public class ChoiceGeneratesItemEvents implements ItemListener {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!System.getProperty(\"os.name\").toLowerCase().startsWith(\"linux\")) {\n+            System.out.println(\"This test is for Linux only\");\n+            return;\n+        }\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+\n+            }\n+        }\n+    }\n+\n+    static volatile Frame frame;\n+    static volatile Robot robot;\n+    static volatile Choice choice1;\n+    static volatile boolean passed = true;\n+\n+    static void createUI() {\n+        choice1 = new Choice();\n+        for (int i = 1; i<10; i++){\n+            choice1.add(\"item-0\"+i);\n+        }\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        choice1.addItemListener(new ChoiceGeneratesItemEvents());\n+        frame = new Frame(\"ChoiceGeneratesItemEvents\");\n+        frame.add(choice1);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+        frame.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+        robot.delay(100);\n+        testMousePressOnChoice(InputEvent.BUTTON2_DOWN_MASK);\n+        testMousePressOnChoice(InputEvent.BUTTON3_DOWN_MASK);\n+        if (!passed) {\n+            throw new RuntimeException(\"Test failed.\");\n+        } else {\n+            System.out.println(\"Test passed. \");\n+        }\n+    }\n+\n+    static void testMousePressOnChoice(int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(2000);\n+\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 2 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/we should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        if (!color.equals(Color.red)) {\n+            throw new RuntimeException(\"Test failed. Choice wasn't open with LEFTMOUSE button.\" +button);\n+        }\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2,\n+                        pt.y + 5*choice1.getHeight());\n+        robot.delay(200);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    public void itemStateChanged(ItemEvent ie) {\n+        System.err.println(\"Opened Choice generated ItemEvent on RIGHT\/MIDDLE mouse press.\" +ie);\n+        passed = false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceGeneratesItemEvents.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 5003166\n+  @summary REG:Mouse button not validated before bringing up the drop-down menu for choice\n+  @key headful\n+  @requires (os.family == \"linux\" | os.family == \"windows\")\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+public class ChoiceHandleMouseEvent {\n+    static Robot robot;\n+    static volatile Choice choice1;\n+    static volatile Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        if (!os.startsWith(\"windows\") && !os.startsWith(\"linux\")) {\n+            System.out.println(\"This test is only for Windows and Linux\");\n+            return;\n+        }\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+       }\n+    }\n+\n+    static void createUI() {\n+        choice1 = new Choice();\n+        choice1.add(\"item-01\");\n+        choice1.add(\"item-02\");\n+        choice1.add(\"item-03\");\n+        choice1.add(\"item-04\");\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        frame = new Frame(\"ChoiceHandleMouseEvent\");\n+        frame.add(choice1);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+        frame.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+\n+        \/*\n+         * Stage 1: Choice should only opens with LEFTMOUSE click.\n+         * Should only pass on Windows or XAWT.\n+         * Choice on motif might be opened only by click on small box\n+         * in the right side.\n+         *\/\n+        testPressMouseButton(InputEvent.BUTTON2_DOWN_MASK);\n+        testPressMouseButton(InputEvent.BUTTON3_DOWN_MASK);\n+        System.out.println(\"Passed Stage 1: Choice should only opens with LEFT BUTTON.\");\n+\n+        \/*\n+         * Stage 2: Choice should only change its value if pressed\n+         * mouse button is LEFTMOUSE.\n+         *\/\n+        \/\/ first parameter is for opening choice. The second is for\n+        \/\/ selecting item inside the menu\n+        testPressMouseButton_2(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON2_DOWN_MASK);\n+        testPressMouseButton_2(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON3_DOWN_MASK);\n+        System.out.println(\"Passed Stage 2: Choice should not change its value if pressed mouse buttonis  not left.\");\n+\n+        \/*\n+         * Stage 3: Choice should only react on drags with LEFTMOUSE button.\n+         *\/\n+        \/\/ first parameter is for opening choice. The second is for\n+        \/\/ selecting item inside the menu\n+        testDragMouseButton(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON2_DOWN_MASK);\n+        testDragMouseButton(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON3_DOWN_MASK);\n+        System.out.println(\"Passed Stage 3: Choice should only react on drags with LEFTMOUSE button.\");\n+    }\n+\n+    static void testPressMouseButton(int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 3 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/we should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        System.out.println(\"RED=\"+Color.red);\n+        if (color.equals(Color.red)) {\n+            throw new RuntimeException(\"Test failed. Choice opens with \"+button);\n+        } else {\n+            System.out.println(\"Stage 1 passed.\"+ button);\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+    }\n+\n+    static void testPressMouseButton_2(int openButton, int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2,\n+                        pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(openButton);\n+        robot.mouseRelease(openButton);\n+        robot.delay(200);\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2,\n+                        pt.y + 2 * choice1.getHeight());\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+\n+        System.out.println();\n+\n+        if (choice1.getSelectedIndex() == 0) {\n+            System.out.println(\"Stage 2 passed.\" + openButton +\":\"+button);\n+        } else {\n+            throw new RuntimeException(\"Stage 2 failed.\" + openButton +\":\"+button);\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+    }\n+\n+    static void testDragMouseButton(int openButton, int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(openButton);\n+        robot.mouseRelease(openButton);\n+        robot.delay(200);\n+\n+        robot.mousePress(button);\n+        dragMouse(pt.x + choice1.getWidth()\/2, pt.y +\n+                  choice1.getHeight()\/2,\n+                  pt.x + choice1.getWidth()\/2,\n+                  pt.y + 2 * choice1.getHeight());\n+        robot.mouseRelease(button);\n+\n+        if (choice1.getSelectedIndex() == 0 ){\n+            System.out.println(\"Stage 3 passed.\" + openButton +\":\"+button);\n+            \/\/            System.out.println(\"choice1.getSelectedIndex()\" + choice1.getSelectedIndex());\n+        } else {\n+            throw new RuntimeException(\"Stage 3 failed.\" + openButton +\":\"+button);\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+    }\n+\n+    static void dragMouse(int x0, int y0, int x1, int y1) {\n+        int curX = x0;\n+        int curY = y0;\n+        int dx = x0 < x1 ? 1 : -1;\n+        int dy = y0 < y1 ? 1 : -1;\n+\n+        while (curX != x1){\n+            curX += dx;\n+            robot.mouseMove(curX, curY);\n+        }\n+        while (curY != y1 ){\n+            curY += dy;\n+            robot.mouseMove(curX, curY);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceHandleMouseEvent.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6239944\n+  @summary PIT: Right clicking on the scrollbar of the choice's dropdown disposes the drop-down, on XToolkit\n+  @key headful\n+  @requires (os.family == \"linux\" | os.family == \"windows\")\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+public class ChoiceHandleMouseEvent_2 {\n+\n+    static Robot robot;\n+    static volatile Choice choice1;\n+    static volatile Frame frame;\n+    static boolean isWindows;\n+\n+    public static void main(String[] args) throws Exception {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        if (!os.startsWith(\"windows\") && !os.startsWith(\"linux\")) {\n+            System.out.println(\"This test is only for Windows and Linux\");\n+            return;\n+        }\n+        isWindows = os.startsWith(\"windows\");\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+       }\n+    }\n+\n+    static void createUI() {\n+        choice1 = new Choice();\n+        for (int i = 1; i<50; i++) {\n+            choice1.add(\"item-0\"+i);\n+        }\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        frame = new Frame(\"ChoiceHandleMouseEvent_2\");\n+        frame.setBackground(Color.green);\n+        Panel panel = new Panel();\n+        panel.setBackground(Color.green);\n+        panel.add(choice1);\n+        frame.add(panel);\n+        frame.setSize(300,300);\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+        frame.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+        robot.delay(100);\n+\n+        \/*\n+         * Stage 1. Choice should be closed if user dragged mouse\n+         * outside of Choice after opening it.\n+         * Should only pass on Windows or XAWT.\n+         * Choice on motif might be opened only by click on small box\n+         * in the right side.\n+         *\/\n+         testDragMouseButtonOut(InputEvent.BUTTON1_DOWN_MASK);\n+         System.out.println(\"Passed Stage 1: Choice should be closed if mouse dragged out.\");\n+\n+        \/*\n+         * Stage 2: Choice should be closed if LeftMouse drag finished\n+         * on Scrollbar. This involeves only one\n+         * MousePress and one MouseRelease event\n+         *\/\n+         \/\/ first parameter is for opening choice. The second is for\n+         \/\/ selecting item inside the menu\n+         testDragMouseButtonOnSB(InputEvent.BUTTON1_DOWN_MASK);\n+         System.out.println(\"Passed Stage 2: Choice should be closed if \" +\n+                            \"LeftMouse drag finished on Scrollbar.\");\n+\n+        \/*\n+         * Stage 3: Pressing RIGHT\/MIDDLE MouseButton on Scrollbar\n+         * shouldn't close Choice's pop-down menu.\n+         * Pressing LEFT MouseButton shouldn't close it too. It should\n+         * scroll it.\n+         * This is an unstable test because we doesn't have an API to\n+         * get Scrollbar from Choice. There is a possibility not to\n+         * hit the scrollbar that couldn't been predicted.\n+         *\/\n+         \/\/ first parameter is for opening choice. The second is for\n+         \/\/ selecting item inside the menu\n+         testPressOnScrollbar(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON2_DOWN_MASK);\n+         testPressOnScrollbar(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON3_DOWN_MASK);\n+         System.out.println(\"Passed Stage 3: Choice correctly reacts on mouse click on its Scrollbar.\");\n+\n+         \/*\n+          * Stage 4: Choice should close its popdown menu if user opened a Choice then\n+          * releases Mouse and then presses Mouse again and dragged it on Choice's Scrollbar\n+          * This involves only one MousePress and one MouseRelease\n+          * event, so it differs from Stage 2.\n+          *\/\n+          \/\/ first parameter is for opening choice. The second is for\n+          \/\/ selecting item inside the menu or scrollbar\n+          testDragMouseOnScrollbar(InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON1_DOWN_MASK);\n+          System.out.println(\"Passed Stage 4: Choice should close if user opened a \" +\n+                             \"Choice then releases Mouse and then presses Mouse again \" +\n+                             \"and drag it on Choice's Scrollbar .\");\n+    }\n+\n+\n+    \/\/Stage 4\n+    static void testDragMouseOnScrollbar(int openButton, int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(openButton);\n+        robot.mouseRelease(openButton);\n+        robot.delay(200);\n+\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.mousePress(button);\n+        \/*X-coordinate should be closer to right edge of Choice, so\n+          divider 4 is used. *\/\n+        dragMouse(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2,\n+                  pt.x + choice1.getWidth() - choice1.getHeight()\/4, pt.y + 5*choice1.getHeight());\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 3 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        if (color.equals(Color.red)) {\n+            throw new RuntimeException(\n+               \"Test failed. Choice didn't close after drag without firstPress on ScrollBar \" + button);\n+        } else {\n+            System.out.println(\"Stage 4 passed.\"+ button);\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    \/\/stage 3\n+    static void testPressOnScrollbar(int openButton, int button) {\n+        if (!isWindows) {\n+            return; \/\/ Windows-only tests.\n+        }\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(openButton);\n+        robot.mouseRelease(openButton);\n+        robot.delay(200);\n+        \/*X-coordinate should be closer to right edge of Choice, so\n+          divide by 4 is used. *\/\n+        int px = pt.x + choice1.getWidth() - choice1.getHeight()\/4;\n+        int py = pt.y + 5*choice1.getHeight();\n+        robot.mouseMove(px, py);\n+        robot.delay(200);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        System.out.println(\"x= \"+px);\n+        System.out.println(\"y= \"+py);\n+\n+        \/*\n+          This is for Windows only.\n+          On XP theme choice become closed on RightMouseClick over a scrollbar.\n+          A system menu is opened after that. On Classic theme Choice doesn't react on it at all.\n+        *\/\n+        boolean isXPTheme = false;\n+        Object themeObject = Toolkit.getDefaultToolkit().getDesktopProperty(\"win.xpstyle.themeActive\");\n+        \/\/ it returns null when Classic theme is active but we should\n+        \/\/ check it's boolean value anyway if event it's not null.\n+        if (themeObject != null) {\n+            isXPTheme = ((Boolean)themeObject).booleanValue();\n+        }\n+        System.out.println(\"isXPTheme=\"+isXPTheme);\n+        px = pt.x + choice1.getWidth()\/2;\n+        py = pt.y + 3 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/we should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        System.out.println(\"RED=\"+Color.red);\n+        System.out.println(\"GREEN=\"+Color.green);\n+        if (isXPTheme && button == InputEvent.BUTTON3_DOWN_MASK) {\n+            if (!color.equals(Color.green)) {\n+                throw new RuntimeException(\"Stage 3 failed(XP theme). \" +\n+                  \"Choice wasn't closed with pressing button on its Scrollbar\" + openButton +\":\"+button);\n+            } else {\n+                System.out.println(\"Stage 3 passed(XP theme).\" + openButton +\":\"+button);\n+            }\n+        } else {\n+            if (!color.equals(Color.red)) {\n+                throw new RuntimeException(\"Stage 3 failed(classic theme). \" +\n+                   \"Choice is being closed with pressing button on its Scrollbar\" + openButton +\":\"+button);\n+            } else {\n+                System.out.println(\"Stage 3 passed(classic theme).\" + openButton +\":\"+button);\n+            }\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    \/\/ Stage 1\n+    static void testDragMouseButtonOut(int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.mousePress(button);\n+        dragMouse(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2,\n+                  pt.x + choice1.getWidth()*2, pt.y + choice1.getHeight()\/2);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 3 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        System.out.println(\"RED=\"+Color.red);\n+        \/\/ fix 6268989: On Windows Choice shouldn't been closed if\n+        \/\/  Mouse dragged outside of Choice after one mouse press.\n+        if (isWindows) {\n+            if (color.equals(Color.red)) {\n+                System.out.println(\"Stage 1 passed. On Windows Choice shouldn't be \" +\n+                      \"closed if Mouse dragged outside of Choice after one mouse press \"+button);\n+            } else {\n+                throw new RuntimeException(\"Test failed. Choice on Windows shouldn't be \" +\n+                   \"closed after drag outside of Choice after one mouse press \"+button);\n+            }\n+        } else {\n+            if (color.equals(Color.red)) {\n+                throw new RuntimeException(\"Test failed. Choice didn't close \" +\n+                                           \"after drag outside of Choice \"+button);\n+            } else {\n+                System.out.println(\"Stage 1 passed.\"+ button);\n+            }\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    \/\/stage 2\n+    static void testDragMouseButtonOnSB(int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.mousePress(button);\n+        \/*X-coordinate should be closer to right edge of Choice, so\n+          divider 4 is used. *\/\n+        dragMouse(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2,\n+                  pt.x + choice1.getWidth() - choice1.getHeight()\/4, pt.y + 5*choice1.getHeight());\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 3 * choice1.getHeight();\n+        Color color = robot.getPixelColor(px, py);\n+        \/\/should take a color on the point on the choice's menu\n+        System.out.println(\"Got color \" + color + \" at (\" + px + \",\" + py + \")\");\n+        if (isWindows) {\n+            if (color.equals(Color.red)) {\n+                System.out.println(\"Stage 2 passed. On Windows Choice shouldn't be \" +\n+                                   \" closed if Mouse dragged on its scrollbar \"+button);\n+            } else {\n+                throw new RuntimeException(\"Test failed. On Windows Choice shouldn't be \" +\n+                                           \" closed if Mouse dragged on its scrollbar  \"+button);\n+            }\n+        } else {\n+            if (color.equals(Color.red)) {\n+                throw new RuntimeException(\"Test failed. Choice didn't close after drag on ScrollBar \"+button);\n+            } else {\n+                System.out.println(\"Stage 2 passed.\"+ button);\n+            }\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    static void dragMouse(int x0, int y0, int x1, int y1) {\n+        int curX = x0;\n+        int curY = y0;\n+        int dx = x0 < x1 ? 1 : -1;\n+        int dy = y0 < y1 ? 1 : -1;\n+\n+        while (curX != x1) {\n+            curX += dx;\n+            robot.mouseMove(curX, curY);\n+        }\n+        while (curY != y1) {\n+            curY += dy;\n+            robot.mouseMove(curX, curY);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceHandleMouseEvent_2.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6272965\n+  @summary PIT: Choice triggers MousePressed when pressing mouse outside comp while drop-down is active, XTkt\n+  @key headful\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ChoiceMouseEventOutbounds {\n+\n+    static final int DELAY = 100;\n+    static volatile Choice choice1;\n+    static volatile Frame frame;\n+    static volatile Robot robot;\n+    static volatile boolean mousePressed = false;\n+    static volatile boolean mouseReleased = false;\n+    static volatile boolean mouseClicked = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static void createUI() {\n+        choice1 = new Choice();\n+        for (int i = 1; i<10; i++) {\n+            choice1.add(\"item \"+i);\n+        }\n+\n+        choice1.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                mousePressed = true;\n+                System.out.println(me);\n+            }\n+            public void mouseReleased(MouseEvent me) {\n+                mouseReleased = true;\n+                System.out.println(me);\n+            }\n+            public void mouseClicked(MouseEvent me) {\n+                mouseClicked = true;\n+                System.out.println(me);\n+            }\n+        });\n+\n+        frame = new Frame(\"ChoiceMouseEventOutbounds\");\n+        frame.add(choice1);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        frame.validate();\n+    }\n+\n+    static void runTest() throws Exception {\n+        \/\/ On Windows, Choice will not close its pop-down menu on a RIGHT\n+        \/\/ MousePress outside of the Choice. So this scenario isn't\n+        \/\/ tested here for that reason.\n+\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+        robot.delay(DELAY*10);\n+        testMouseClick(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(DELAY);\n+        testMouseClick(InputEvent.BUTTON2_DOWN_MASK);\n+        robot.delay(DELAY);\n+        testMouseClick(InputEvent.BUTTON3_DOWN_MASK);\n+\n+        System.out.println(\"Test passed: Choice doesn't generate MOUSEPRESS\/CLICK\/RELEASE outside Choice.\");\n+    }\n+\n+    static void testMouseClick(int button) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(DELAY);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(DELAY);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(DELAY*3);\n+\n+        \/\/they are true because we just pressed mouse\n+        mousePressed = false;\n+        mouseReleased = false;\n+        mouseClicked = false;\n+\n+        \/\/move mouse outside Choice\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y - choice1.getHeight());\n+        robot.delay(DELAY*3);\n+        robot.mousePress(button);\n+        robot.delay(DELAY);\n+        robot.mouseRelease(button);\n+\n+        if (mousePressed || mouseReleased || mouseClicked) {\n+            System.out.println(\"ERROR: \"+ mousePressed+\",\"+mouseReleased +\",\"+mouseClicked);\n+            throw new RuntimeException(\n+               \"Test failed. Choice shouldn't generate PRESSED, RELEASED, CLICKED events outside \"+ button);\n+        } else {\n+            System.out.println(\n+               \"Test passed. Choice didn't generated MouseDragged PRESSED, RELEASED, CLICKED events outside \"+ button);\n+        }\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(DELAY);\n+        mousePressed = false;\n+        mouseReleased = false;\n+        mouseClicked = false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceMouseEventOutbounds.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4323906\n+  @summary Test that Choice location is not updated erroneously\n+  @key headful\n+*\/\n+\n+\/**\n+ * summary: The test adds a Choice to a Container with BorderLayout, and\n+ *          adds the Container to a Frame with null Layout.  When\n+ *          the Container is moved in the x direction, the Choice should\n+ *          not move in the y direction.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class ChoiceMoveTest {\n+\n+    static volatile Frame frame;\n+    static volatile Container c;\n+    static volatile Choice ch;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"Choice Move Test\");\n+        frame.setSize(500, 500);\n+        frame.setLayout(null);\n+\n+        c = new Container();\n+        c.setBackground(Color.green);\n+        frame.add(c);\n+        c.setSize(200, 200);\n+        c.setLocation(100, 100);\n+        c.setLayout(new BorderLayout());\n+\n+        ch = new Choice();\n+        ch.setSize(100, 27);\n+        c.add(ch, BorderLayout.SOUTH);\n+        frame.setVisible(true);\n+        frame.validate();\n+    }\n+\n+    static void runTest () throws Exception {\n+        Thread.sleep(1000);\n+        \/\/ If this test ever gives us problems, try putting getLocation() in a\n+        \/\/ ComponentListener.\n+        int xbefore = ch.getLocation().x;\n+        int ybefore = ch.getLocation().y;\n+        System.out.println(\"Choice location before: \" + xbefore + \", \" + ybefore);\n+\n+        c.setLocation(200, 100);\n+        Thread.sleep(1000);\n+\n+        java.awt.Toolkit.getDefaultToolkit().sync();\n+        Thread.sleep(1000);\n+        int xafter = ch.getLocation().x;\n+        int yafter = ch.getLocation().y;\n+        System.out.println(\"Choice location after: \" + xafter + \", \" + yafter);\n+\n+        if (ybefore != yafter) {\n+            System.out.println(\"Test FAILED\");\n+            throw new RuntimeException(\"Test failed - Choice should not move in the y direction.\");\n+        }\n+        else {\n+            System.out.println(\"Test passed.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceMoveTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6239938\n+  @summary Choice drop-down does not disappear when it loses focus, on XToolkit\n+  @key headful\n+  @requires (os.family == \"linux\")\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+public class ChoiceStaysOpenedOnTAB {\n+\n+    static volatile Robot robot;\n+    static volatile Choice choice1;\n+    static volatile Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!System.getProperty(\"os.name\").toLowerCase().startsWith(\"linux\")) {\n+            System.out.println(\"This test is for Linux only\");\n+            return;\n+        }\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+               EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static void createUI() {\n+        choice1 = new Choice();\n+        for (int i = 1; i<10; i++) {\n+            choice1.add(\"item-0\"+i);\n+        }\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        Button b1 = new Button(\"FirstButton\");\n+        Button b2 = new Button(\"SecondButton\");\n+        frame = new Frame(\"ChoiceStaysOpenedOnTAB\");\n+        Panel panel = new Panel();\n+        panel.add(b1);\n+        panel.add(choice1);\n+        panel.add(b2);\n+        frame.add(panel);\n+        frame.setSize(400,400);\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+        frame.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+\n+        \/*\n+         * Choice should not lose focus while it is opened with\n+         * TAB\/Shitf-TAB KeyPress on XAWT.\n+         * Should only pass on XAWT.\n+         *\/\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+        robot.delay(1000);\n+\n+        testTABKeyPress(InputEvent.BUTTON1_DOWN_MASK, KeyEvent.VK_TAB, false);\n+        testTABKeyPress(InputEvent.BUTTON1_DOWN_MASK, KeyEvent.VK_TAB, true);\n+        System.out.println(\"Passed : Choice should not lose focus on TAB key press while it is opened.\");\n+    }\n+\n+    static void testTABKeyPress(int openButton, int keyButton, boolean isShiftUsed) {\n+        Point pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth()\/2, pt.y + choice1.getHeight()\/2);\n+        robot.delay(100);\n+        robot.mousePress(openButton);\n+        robot.mouseRelease(openButton);\n+        robot.delay(200);\n+\n+        Color color = robot.getPixelColor(pt.x + choice1.getWidth()\/2,\n+                                          pt.y + 3 * choice1.getHeight());\n+        if (!color.equals(Color.red)) {\n+            throw new RuntimeException(\n+                \"Choice wasn't opened with LEFTMOUSE button\" + openButton +\":\"+keyButton+\":\"+isShiftUsed);\n+        }\n+        robot.delay(200);\n+        if (isShiftUsed) {\n+            robot.keyPress(KeyEvent.VK_SHIFT);\n+        }\n+        robot.keyPress(keyButton);\n+        robot.keyRelease(keyButton);\n+\n+        if (isShiftUsed) {\n+            robot.keyRelease(KeyEvent.VK_SHIFT);\n+        }\n+\n+        robot.delay(200);\n+        if (!choice1.isFocusOwner()) {\n+            System.out.println(\"Choice has focus==\"+choice1.isFocusOwner());\n+            throw new RuntimeException(\n+                \"Choice has no focus after pressing TAB\/Shitf+TAB\" + openButton +\":\"+keyButton+\":\"+isShiftUsed);\n+        }\n+        int px = pt.x + choice1.getWidth()\/2;\n+        int py = pt.y + 3 * choice1.getHeight();\n+        color = robot.getPixelColor(px, py);\n+        \/\/we should take a color on the point on the choice's menu\n+        System.out.println(\"color got \"+color);\n+        if (!color.equals(Color.red)) {\n+            throw new RuntimeException(\n+                \"Choice closed after TAB\/Shift+TAB key press\" + openButton +\":\"+keyButton+\":\"+isShiftUsed);\n+        }\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceStaysOpenedOnTAB.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4902933\n+  @summary Test that dragging off an unfurled Choice prevents selecting a new item\n+  @key headful\n+*\/\n+\n+import java.awt.Choice;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowListener;\n+\n+public class DragOffNoSelectTest implements WindowListener, Runnable {\n+\n+    static volatile DragOffNoSelectTest testInstance;\n+    static volatile Frame frame;\n+    static volatile Choice theChoice;\n+    static volatile Robot robot;\n+    static final String firstItem = new String(\"First Choice Item\");\n+\n+    static volatile Object lock = new Object();\n+\n+    public static void main(String[] args) throws Exception {\n+        testInstance = new DragOffNoSelectTest();\n+        robot = new Robot();\n+        robot.setAutoDelay(500);\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            runTest();\n+        } finally {\n+            if (frame != null) {\n+               EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"DragOffNoSelectTest\");\n+        theChoice = new Choice();\n+        theChoice.add(firstItem);\n+        for (int i = 0; i < 10; i++) {\n+            theChoice.add(new String(\"Choice Item \" + i));\n+        }\n+        frame.add(theChoice);\n+        frame.addWindowListener(testInstance);\n+        frame.setSize(400, 400);\n+        frame.setLocationRelativeTo(null);\n+\n+        frame.setVisible(true);\n+        frame.validate();\n+    }\n+\n+    static void runTest() throws Exception {\n+        robot.mouseMove(10, 30);\n+        synchronized (lock) {\n+            try {\n+                lock.wait(120000);\n+            }\n+            catch (InterruptedException e) {}\n+        }\n+        robot.waitForIdle();\n+\n+        if (!firstItem.equals(theChoice.getSelectedItem())) {\n+            throw new RuntimeException(\"TEST FAILED - new item was selected\");\n+        }\n+    }\n+\n+    public void run() {\n+        robot.delay(1000);\n+        \/\/ get loc of Choice on screen\n+        Point loc = theChoice.getLocationOnScreen();\n+        \/\/ get bounds of Choice\n+        Dimension size = theChoice.getSize();\n+        robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n+\n+        robot.setAutoDelay(500);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.mouseMove(loc.x + size.width \/ 2, loc.y + size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + size.width \/ 2, loc.y + 2*size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + size.width \/ 2, loc.y + 3*size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + size.width \/ 2, loc.y + 4*size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + size.width, loc.y + 4*size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + 2*size.width, loc.y + 4*size.height + size.height \/ 2);\n+        robot.mouseMove(loc.x + 3*size.width, loc.y + 4*size.height + size.height \/ 2);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        synchronized(lock) {\n+            lock.notify();\n+        }\n+    }\n+\n+    public void windowOpened(WindowEvent e) {\n+        System.out.println(\"windowActivated()\");\n+        Thread testThread = new Thread(testInstance);\n+        testThread.start();\n+    }\n+    public void windowActivated(WindowEvent e) { }\n+    public void windowDeactivated(WindowEvent e) {}\n+    public void windowClosed(WindowEvent e) {}\n+    public void windowClosing(WindowEvent e) {}\n+    public void windowIconified(WindowEvent e) {}\n+    public void windowDeiconified(WindowEvent e) {}\n+\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Choice\/DragOffNoSelectTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8139581\n+ * @summary Verify that components are redrawn after\n+ * removal and addition to a container\n+ * @run main ComponentRedrawnTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.swing.JButton;\n+\n+public class ComponentRedrawnTest {\n+\n+    private static Frame frame;\n+    private static Panel componentPanel;\n+    private static Button buttonRemove;\n+    private static Button buttonAdd;\n+    private static Button awtButton;\n+\n+    private static volatile Robot robot;\n+    private static volatile int x;\n+    private static volatile int y;\n+    private static AtomicInteger awtPainted = new AtomicInteger();\n+    private static AtomicInteger swingPainted = new AtomicInteger();\n+\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createGUI());\n+            runTest();\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> dispose());\n+        }\n+    }\n+\n+    private static void createGUI() {\n+        frame = new Frame(\"ComponentRedrawnTest\");\n+        frame.setSize(350, 300);\n+        frame.setBackground(Color.red);\n+\n+        componentPanel = new Panel();\n+        componentPanel.setLayout(null);\n+        componentPanel.setBackground(Color.green);\n+\n+        awtButton = new Button(\"AWT Button\") {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                awtPainted.incrementAndGet();\n+            }\n+        };\n+\n+        awtButton.setBounds(0, 0, 330, 100);\n+        componentPanel.add(awtButton);\n+\n+        JButton swingButton = new JButton(\"Swing JButton\") {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                swingPainted.incrementAndGet();\n+            }\n+        };\n+\n+        swingButton.setBounds(0, 100, 330, 100);\n+        componentPanel.add(swingButton);\n+        frame.add(componentPanel, BorderLayout.CENTER);\n+        buttonRemove = new Button(\"remove\");\n+        buttonRemove.addActionListener(ae -> buttonClicked(ae));\n+\n+        buttonAdd = new Button(\"add\");\n+        buttonAdd.addActionListener(ae -> buttonClicked(ae));\n+\n+        Panel controlPanel = new Panel();\n+        controlPanel.setLayout(new BorderLayout());\n+        controlPanel.add(buttonRemove, BorderLayout.NORTH);\n+        controlPanel.add(buttonAdd, BorderLayout.SOUTH);\n+\n+        frame.add(controlPanel, BorderLayout.SOUTH);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void buttonClicked(ActionEvent ae) {\n+        if (ae.getSource() == buttonRemove) {\n+            frame.remove(componentPanel);\n+        } else if (ae.getSource() == buttonAdd) {\n+            frame.add(componentPanel);\n+        }\n+        frame.invalidate();\n+        frame.validate();\n+    }\n+\n+    private static void runTest() throws Exception {\n+        EventQueue.invokeAndWait(() -> createGUI());\n+        robot = new Robot();\n+        robot.setAutoDelay(500);\n+        awtPainted.set(0);\n+        swingPainted.set(0);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = awtButton.getLocationOnScreen().x\n+                    + awtButton.getSize().width \/ 2;\n+                y = awtButton.getLocationOnScreen().y\n+                    + awtButton.getSize().height \/ 2;\n+            });\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = buttonRemove.getLocationOnScreen().x\n+                    + buttonRemove.getSize().width \/ 2;\n+                y = buttonRemove.getLocationOnScreen().y\n+                    + buttonRemove.getSize().height \/ 2;\n+            });\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = buttonAdd.getLocationOnScreen().x\n+                    + buttonAdd.getSize().width \/ 2;\n+                y = buttonAdd.getLocationOnScreen().y\n+                    + buttonAdd.getSize().height \/ 2;\n+            });\n+\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        if (awtPainted.get() == 0) {\n+            throw new RuntimeException(\"AWT button is not painted\");\n+        }\n+        if (swingPainted.get() == 0) {\n+            throw new RuntimeException(\"Swing button is not painted\");\n+        }\n+    }\n+\n+    private static void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentRedrawnTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2014 Google Inc. All rights reserved.\n+ * Copyright (c) 2014, Google Inc. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +27,0 @@\n- * @ignore This test has huge memory requirements\n- * @run main\/timeout=1800\/othervm -Xmx8g MaxCapacity\n@@ -31,0 +30,2 @@\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 10g)\n+ * @run main\/timeout=1800\/othervm -Xmx8g MaxCapacity\n","filename":"test\/jdk\/java\/io\/ByteArrayOutputStream\/MaxCapacity.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                ProcessTools.createJavaProcessBuilder(true, MacPathTest.class.getName());\n+                ProcessTools.createTestJvm(MacPathTest.class.getName());\n","filename":"test\/jdk\/java\/io\/File\/MacPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+   @requires os.maxMemory >= 16G\n","filename":"test\/jdk\/java\/io\/File\/SetLastModified.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -96,1 +96,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/java\/io\/Serializable\/evolution\/RenamePackage\/RenamePackageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import static jdk.test.lib.process.ProcessTools.createJavaProcessBuilder;\n+import static jdk.test.lib.process.ProcessTools.createTestJvm;\n@@ -41,1 +41,1 @@\n-            ProcessBuilder pb = createJavaProcessBuilder(true, \"ShutdownInterruptedMain\");\n+            ProcessBuilder pb = createTestJvm(\"ShutdownInterruptedMain\");\n","filename":"test\/jdk\/java\/lang\/Runtime\/shutdown\/ShutdownInterruptedMain.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"CallerFromMain\");\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\"CallerFromMain\");\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerFromMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @run main\/othervm -Xmx5G HugeCapacity\n+ * @run main\/othervm -Xms5G -Xmx5G -XX:+CompactStrings HugeCapacity true\n+ * @run main\/othervm -Xms5G -Xmx5G -XX:-CompactStrings HugeCapacity false\n@@ -37,1 +38,6 @@\n-        testLatin1();\n+        if (args.length == 0) {\n+           throw new IllegalArgumentException(\"Need the argument\");\n+        }\n+        boolean isCompact = Boolean.parseBoolean(args[0]);\n+\n+        testLatin1(isCompact);\n@@ -44,1 +50,1 @@\n-    private static void testLatin1() {\n+    private static void testLatin1(boolean isCompact) {\n@@ -46,0 +52,1 @@\n+            int divisor = isCompact ? 2 : 4;\n@@ -47,2 +54,2 @@\n-            sb.ensureCapacity(Integer.MAX_VALUE \/ 2);\n-            sb.ensureCapacity(Integer.MAX_VALUE \/ 2 + 1);\n+            sb.ensureCapacity(Integer.MAX_VALUE \/ divisor);\n+            sb.ensureCapacity(Integer.MAX_VALUE \/ divisor + 1);\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/java\/lang\/System\/MacEncoding\/MacJNUEncoding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-javaagent:DummyAgent.jar\", \"TestDaemonThread\", \".\");\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\"-javaagent:DummyAgent.jar\", \"TestDaemonThread\", \".\");\n","filename":"test\/jdk\/java\/lang\/instrument\/DaemonThread\/TestDaemonThreadLauncher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -446,1 +446,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -448,1 +448,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -456,1 +463,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -458,1 +472,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -466,1 +480,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -468,1 +489,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -476,1 +497,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -478,1 +499,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean value\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -706,1 +734,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -708,1 +743,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -716,1 +751,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -718,1 +760,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -726,1 +768,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -728,1 +770,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -736,1 +785,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -738,1 +794,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -969,1 +1025,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -971,1 +1034,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -979,1 +1042,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -981,1 +1044,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -989,1 +1059,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -991,1 +1068,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -999,1 +1076,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -1001,1 +1085,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -426,1 +426,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -434,1 +441,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -436,1 +450,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -444,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -446,1 +467,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -454,1 +475,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -456,1 +477,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte value\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -700,1 +728,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -702,1 +737,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -710,1 +745,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -712,1 +754,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -720,1 +762,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -722,1 +764,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -730,1 +779,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -732,1 +788,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -979,1 +1035,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -981,1 +1044,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -989,1 +1052,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -991,1 +1054,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -999,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -1001,1 +1078,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -1009,1 +1086,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -1011,1 +1095,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -426,1 +426,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -434,1 +441,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -436,1 +450,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -444,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -446,1 +467,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -454,1 +475,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -456,1 +477,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char value\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -700,1 +728,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -702,1 +737,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -710,1 +745,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -712,1 +754,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -720,1 +762,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -722,1 +764,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -730,1 +779,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -732,1 +788,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -979,1 +1035,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -981,1 +1044,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -989,1 +1052,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -991,1 +1054,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -999,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -1001,1 +1078,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -1009,1 +1086,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -1011,1 +1095,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -494,1 +494,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -496,1 +496,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -504,1 +511,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -506,1 +520,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -514,1 +528,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -516,1 +537,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -524,1 +545,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -526,1 +547,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double value\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -722,1 +750,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -724,1 +759,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -732,1 +767,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -734,1 +776,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -742,1 +784,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -744,1 +786,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -752,1 +801,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -754,1 +810,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -953,1 +1009,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -955,1 +1018,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -963,1 +1026,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -965,1 +1028,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -973,1 +1043,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -975,1 +1052,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -983,1 +1060,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -985,1 +1069,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -494,1 +494,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -496,1 +496,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -504,1 +511,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -506,1 +520,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -514,1 +528,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -516,1 +537,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -524,1 +545,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -526,1 +547,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float value\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -722,1 +750,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -724,1 +759,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -732,1 +767,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -734,1 +776,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -742,1 +784,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -744,1 +786,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -752,1 +801,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -754,1 +810,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -953,1 +1009,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -955,1 +1018,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -963,1 +1026,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -965,1 +1028,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -973,1 +1043,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -975,1 +1052,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -983,1 +1060,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -985,1 +1069,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -426,1 +426,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -434,1 +441,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -436,1 +450,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -444,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -446,1 +467,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -454,1 +475,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -456,1 +477,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int value\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -700,1 +728,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -702,1 +737,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -710,1 +745,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -712,1 +754,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -720,1 +762,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -722,1 +764,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -730,1 +779,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -732,1 +788,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -979,1 +1035,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -981,1 +1044,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -989,1 +1052,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -991,1 +1054,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -999,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -1001,1 +1078,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -1009,1 +1086,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1011,1 +1095,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -426,1 +426,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -434,1 +441,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -436,1 +450,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -444,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -446,1 +467,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -454,1 +475,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -456,1 +477,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long value\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -700,1 +728,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -702,1 +737,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -710,1 +745,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -712,1 +754,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -720,1 +762,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -722,1 +764,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -730,1 +779,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -732,1 +788,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -979,1 +1035,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -981,1 +1044,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -989,1 +1052,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -991,1 +1054,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -999,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -1001,1 +1078,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -1009,1 +1086,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1011,1 +1095,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -426,1 +426,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -434,1 +441,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -436,1 +450,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -444,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -446,1 +467,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -454,1 +475,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -456,1 +477,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short value\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -700,1 +728,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -702,1 +737,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -710,1 +745,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -712,1 +754,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -720,1 +762,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -722,1 +764,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -730,1 +779,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -732,1 +788,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -979,1 +1035,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -981,1 +1044,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -989,1 +1052,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -991,1 +1054,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -999,1 +1069,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -1001,1 +1078,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -1009,1 +1086,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -1011,1 +1095,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -523,1 +523,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -525,1 +525,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -533,1 +540,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -535,1 +549,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -543,1 +557,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -545,1 +566,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -553,1 +574,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -555,1 +576,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String value\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -735,1 +763,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -737,1 +772,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -745,1 +780,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -747,1 +789,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -755,1 +797,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -757,1 +799,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -765,1 +814,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -767,1 +823,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -950,1 +1006,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -952,1 +1015,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -960,1 +1023,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -962,1 +1025,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -970,1 +1040,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -972,1 +1049,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -980,1 +1057,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -982,1 +1066,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsChar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1054,1 +1054,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -1056,1 +1056,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain double value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain double value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain double value\");\n@@ -1064,1 +1071,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -1066,1 +1080,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire double value\");\n@@ -1074,1 +1088,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -1076,1 +1090,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease double\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease double value\");\n@@ -1084,1 +1105,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet double\");\n+                    assertEquals(success, true, \"success weakCompareAndSet double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1086,1 +1114,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet double value\");\n@@ -1227,1 +1255,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -1229,1 +1257,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain double value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain double value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain double value\");\n@@ -1237,1 +1272,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -1239,1 +1281,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire double value\");\n@@ -1247,1 +1289,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -1249,1 +1291,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease double\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease double value\");\n@@ -1257,1 +1306,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet double\");\n+                    assertEquals(success, true, \"success weakCompareAndSet double\");\n+                    double x = (double) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet double\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1259,1 +1315,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet double\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsDouble.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1054,1 +1054,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -1056,1 +1056,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain float value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain float value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain float value\");\n@@ -1064,1 +1071,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -1066,1 +1080,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire float value\");\n@@ -1074,1 +1088,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -1076,1 +1090,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease float\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease float value\");\n@@ -1084,1 +1105,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet float\");\n+                    assertEquals(success, true, \"success weakCompareAndSet float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1086,1 +1114,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet float value\");\n@@ -1227,1 +1255,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -1229,1 +1257,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain float value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain float value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain float value\");\n@@ -1237,1 +1272,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -1239,1 +1281,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire float value\");\n@@ -1247,1 +1289,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -1249,1 +1291,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease float\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease float value\");\n@@ -1257,1 +1306,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet float\");\n+                    assertEquals(success, true, \"success weakCompareAndSet float\");\n+                    float x = (float) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet float\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1259,1 +1315,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet float\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsFloat.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1238,1 +1238,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -1240,1 +1240,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain int value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain int value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain int value\");\n@@ -1248,1 +1255,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -1250,1 +1264,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire int value\");\n@@ -1258,1 +1272,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -1260,1 +1274,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease int\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease int value\");\n@@ -1268,1 +1289,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet int\");\n+                    assertEquals(success, true, \"success weakCompareAndSet int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1270,1 +1298,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet int value\");\n@@ -1521,1 +1549,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -1523,1 +1551,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain int value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain int value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain int value\");\n@@ -1531,1 +1566,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -1533,1 +1575,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire int value\");\n@@ -1541,1 +1583,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -1543,1 +1585,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease int\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease int value\");\n@@ -1551,1 +1600,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet int\");\n+                    assertEquals(success, true, \"success weakCompareAndSet int\");\n+                    int x = (int) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet int\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1553,1 +1609,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet int\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsInt.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1238,1 +1238,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -1240,1 +1240,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain long value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain long value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain long value\");\n@@ -1248,1 +1255,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -1250,1 +1264,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire long value\");\n@@ -1258,1 +1272,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -1260,1 +1274,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease long\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease long value\");\n@@ -1268,1 +1289,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet long\");\n+                    assertEquals(success, true, \"success weakCompareAndSet long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1270,1 +1298,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet long value\");\n@@ -1521,1 +1549,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -1523,1 +1551,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain long value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain long value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain long value\");\n@@ -1531,1 +1566,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -1533,1 +1575,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire long value\");\n@@ -1541,1 +1583,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -1543,1 +1585,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease long\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease long value\");\n@@ -1551,1 +1600,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet long\");\n+                    assertEquals(success, true, \"success weakCompareAndSet long\");\n+                    long x = (long) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet long\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1553,1 +1609,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet long\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsLong.java","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestByteArrayAsShort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -449,1 +477,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -451,1 +486,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -459,1 +494,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -461,1 +503,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -469,1 +511,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -471,1 +513,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -479,1 +528,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -481,1 +537,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetRe boolean value\");\n@@ -708,1 +764,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -710,1 +773,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -718,1 +781,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -720,1 +783,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -728,1 +798,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -730,1 +807,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -738,1 +815,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -740,1 +824,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetRe byte value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetAcquire byte value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetRe char value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetAcquire char value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -393,1 +421,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -395,1 +430,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -403,1 +438,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -405,1 +447,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -413,1 +455,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -415,1 +457,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -423,1 +472,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -425,1 +481,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetRe double value\");\n@@ -596,1 +652,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -598,1 +661,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -606,1 +669,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -608,1 +671,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -616,1 +686,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -618,1 +695,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -626,1 +703,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -628,1 +712,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -393,1 +421,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -395,1 +430,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -403,1 +438,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -405,1 +447,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -413,1 +455,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -415,1 +457,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -423,1 +472,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -425,1 +481,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetRe float value\");\n@@ -596,1 +652,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -598,1 +661,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -606,1 +669,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -608,1 +671,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -616,1 +686,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -618,1 +695,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -626,1 +703,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -628,1 +712,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetRe int value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetAcquire int value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetRe long value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetAcquire long value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -471,1 +499,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -473,1 +508,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -481,1 +516,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -483,1 +525,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -491,1 +533,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -493,1 +535,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -501,1 +550,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -503,1 +559,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetRe short value\");\n@@ -752,1 +808,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -754,1 +817,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -762,1 +825,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -764,1 +827,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -772,1 +842,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -774,1 +851,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetAcquire short value\");\n@@ -782,1 +859,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -784,1 +868,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -217,1 +217,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -225,1 +232,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -227,1 +241,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -235,1 +249,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -237,1 +258,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -245,1 +266,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -247,1 +268,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -371,1 +399,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -373,1 +408,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -381,1 +416,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -383,1 +425,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -391,1 +433,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -393,1 +435,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -401,1 +450,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -403,1 +459,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetRe String value\");\n@@ -552,1 +608,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -554,1 +617,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -562,1 +625,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -564,1 +627,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -572,1 +642,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -574,1 +651,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetAcquire String value\");\n@@ -582,1 +659,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -584,1 +668,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -662,1 +662,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -664,1 +664,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -672,1 +679,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -674,1 +688,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -682,1 +696,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -684,1 +705,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -692,1 +713,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -694,1 +715,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$ value\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1039,1 +1067,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1041,1 +1076,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1049,1 +1084,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1051,1 +1093,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1059,1 +1101,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1061,1 +1103,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1069,1 +1118,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1071,1 +1127,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1419,1 +1475,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1421,1 +1484,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1429,1 +1492,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -1431,1 +1494,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1439,1 +1509,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -1441,1 +1518,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1449,1 +1526,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1451,1 +1535,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1595,1 +1595,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -1597,1 +1597,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain $type$ value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain $type$ value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1605,1 +1612,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1607,1 +1621,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1615,1 +1629,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1617,1 +1631,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1625,1 +1646,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1627,1 +1655,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet $type$ value\");\n@@ -1884,1 +1912,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -1886,1 +1914,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetPlain $type$ value\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetPlain $type$ value\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1894,1 +1929,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSetAcquire $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1896,1 +1938,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSetAcquire $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1904,1 +1946,1 @@\n-                    assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1906,1 +1948,8 @@\n-                    assertEquals(x, VALUE_2, \"weakCompareAndSetRelease $type$\");\n+                    assertEquals(x, VALUE_2, \"success weakCompareAndSetRelease $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_2, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1914,1 +1963,8 @@\n-                    assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                    assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                    $type$ x = ($type$) vh.get(array, i);\n+                    assertEquals(x, VALUE_1, \"success weakCompareAndSet $type$\");\n+                }\n+\n+                {\n+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);\n+                    assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1916,1 +1972,1 @@\n-                    assertEquals(x, VALUE_1, \"weakCompareAndSet $type$\");\n+                    assertEquals(x, VALUE_1, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestByteArrayView.java.template","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -218,1 +218,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -226,1 +233,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -228,1 +242,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -236,1 +250,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -238,1 +259,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -246,1 +267,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -248,1 +269,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -511,1 +539,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -513,1 +548,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -521,1 +556,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -523,1 +565,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -531,1 +573,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -533,1 +575,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -541,1 +590,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -543,1 +599,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetRe $type$ value\");\n@@ -831,1 +887,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -833,1 +896,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -841,1 +904,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -843,1 +906,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -851,1 +921,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -853,1 +930,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -861,1 +938,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -863,1 +947,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n- * @run main\/othervm -Xshare:off DivisionOverflow\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory > 8g)\n+ * @run main\/othervm -Xshare:off -Xmx8g DivisionOverflow\n","filename":"test\/jdk\/java\/math\/BigInteger\/largeMemory\/DivisionOverflow.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"test\/jdk\/java\/math\/BigInteger\/DivisionOverflow.java","status":"renamed"},{"patch":"@@ -28,1 +28,1 @@\n- * @ignore This test has huge memory requirements\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory > 8g)\n","filename":"test\/jdk\/java\/math\/BigInteger\/largeMemory\/StringConstructorOverflow.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/math\/BigInteger\/StringConstructorOverflow.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n- * @library \/test\/lib\n- * @ignore This test has huge memory requirements\n- * @run main\/timeout=180\/othervm -Xmx8g SymmetricRangeTests\n@@ -31,0 +28,3 @@\n+ * @library \/test\/lib\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 10g)\n+ * @run main\/timeout=180\/othervm -Xmx8g -XX:+CompactStrings SymmetricRangeTests\n","filename":"test\/jdk\/java\/math\/BigInteger\/largeMemory\/SymmetricRangeTests.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/math\/BigInteger\/SymmetricRangeTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+    static boolean retried;\n@@ -51,4 +52,0 @@\n-        String s1_type = (String)test[0];\n-        String s2_type = (String)test[1];\n-        int port = 0;\n-\n@@ -60,0 +57,9 @@\n+        doTest(test, count, ia1, ia2, silent, !retried);\n+    }\n+\n+    static void doTest(Object test[], int count, InetAddress ia1, InetAddress ia2,\n+                       boolean silent, boolean retry) throws Exception {\n+        String s1_type = (String)test[0];\n+        String s2_type = (String)test[1];\n+        int port = 0;\n+\n@@ -71,0 +77,2 @@\n+        boolean firstBound = false;\n+\n@@ -92,0 +100,7 @@\n+            \/\/ The fact that the port was available for ia1 does not\n+            \/\/ guarantee that it will also be available for ia2 as something\n+            \/\/ else might already be bound to that port.\n+            \/\/ For the sake of test stability we will retry once in\n+            \/\/ case of unexpected bind exception.\n+\n+            firstBound = true;\n@@ -144,0 +159,12 @@\n+        if (failed && retry && firstBound) {\n+            \/\/ retry once at the first failure only\n+            retried = true;\n+            if (!silent) {\n+                System.out.println(\"\");\n+                System.out.println(\"**************************\");\n+                System.out.println(\"Test \" + count + \": Retrying...\");\n+            }\n+            doTest(test, count, ia1, ia2, silent, false);\n+            return;\n+        }\n+\n","filename":"test\/jdk\/java\/net\/BindException\/Test.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -70,0 +71,1 @@\n+        CountDownLatch latch = new CountDownLatch(1);\n@@ -72,1 +74,1 @@\n-            ss = new DatagramSocket(0);\n+            ss = new DatagramSocket(0, getHost());\n@@ -80,1 +82,1 @@\n-            InetAddress localhost = InetAddress.getByName(\"localhost\"); \/\/.getLocalHost();\n+            InetAddress localhost = lookupLocalHost();\n@@ -96,1 +98,1 @@\n-\n+                latch.await(); \/\/ wait for the client to receive the packet\n@@ -105,0 +107,4 @@\n+    static InetAddress lookupLocalHost() throws UnknownHostException {\n+        return InetAddress.getByName(\"localhost\"); \/\/.getLocalHost();\n+    }\n+\n@@ -108,1 +114,1 @@\n-        try (DatagramSocket s = new DatagramSocket(0)) {\n+        try (DatagramSocket s = new DatagramSocket(0, lookupLocalHost())) {\n@@ -121,1 +127,1 @@\n-        DatagramSocket client = new DatagramSocket(0);\n+        DatagramSocket client = new DatagramSocket(0, lookupLocalHost());\n@@ -133,0 +139,2 @@\n+        svr.latch.countDown(); \/\/ unblock the server\n+\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -981,0 +981,2 @@\n+        private volatile boolean stop;\n+\n@@ -999,3 +1001,4 @@\n-            super.stop();\n-            try {\n-                ss.close();\n+            try (var toClose = ss) {\n+                stop = true;\n+                System.out.println(\"Server \" + ss + \" stop requested\");\n+                super.stop();\n@@ -1051,0 +1054,3 @@\n+            if (b.length() == 0) {\n+                return \"\";\n+            }\n@@ -1060,4 +1066,6 @@\n-            try {\n-                while (true) {\n-                    System.out.println(\"Tunnel: Waiting for client at: \" + ss);\n-                    Socket previous = clientConnection;\n+            while (!stop) {\n+                System.out.println(\"Tunnel: Waiting for client at: \" + ss);\n+                final Socket previous = clientConnection;\n+                try {\n+                    clientConnection = ss.accept();\n+                } catch (IOException io) {\n@@ -1065,7 +1073,5 @@\n-                        clientConnection = ss.accept();\n-                    } catch (IOException io) {\n-                        if (DEBUG) io.printStackTrace(System.out);\n-                        break;\n-                    } finally {\n-                        \/\/ close the previous connection\n-                        if (previous != null) previous.close();\n+                        ss.close();\n+                    } catch (IOException ex) {\n+                        if (DEBUG) {\n+                            ex.printStackTrace(System.out);\n+                        }\n@@ -1073,20 +1079,18 @@\n-                    System.out.println(\"Tunnel: Client accepted\");\n-                    Socket targetConnection = null;\n-                    InputStream  ccis = clientConnection.getInputStream();\n-                    OutputStream ccos = clientConnection.getOutputStream();\n-                    Writer w = new OutputStreamWriter(\n-                                   clientConnection.getOutputStream(), \"UTF-8\");\n-                    PrintWriter pw = new PrintWriter(w);\n-                    System.out.println(\"Tunnel: Reading request line\");\n-                    String requestLine = readLine(ccis);\n-                    System.out.println(\"Tunnel: Request line: \" + requestLine);\n-                    if (requestLine.startsWith(\"CONNECT \")) {\n-                        \/\/ We should probably check that the next word following\n-                        \/\/ CONNECT is the host:port of our HTTPS serverImpl.\n-                        \/\/ Some improvement for a followup!\n-\n-                        \/\/ Read all headers until we find the empty line that\n-                        \/\/ signals the end of all headers.\n-                        while(!requestLine.equals(\"\")) {\n-                            System.out.println(\"Tunnel: Reading header: \"\n-                                               + (requestLine = readLine(ccis)));\n+                    \/\/ log the reason that caused the server to stop accepting connections\n+                    if (!stop) {\n+                        System.err.println(\"Server will stop accepting connections due to an exception:\");\n+                        io.printStackTrace();\n+                    }\n+                    break;\n+                } finally {\n+                    \/\/ close the previous connection\n+                    if (previous != null) {\n+                        try {\n+                            previous.close();\n+                        } catch (IOException e) {\n+                            \/\/ ignore\n+                            if (DEBUG) {\n+                                System.out.println(\"Ignoring exception that happened while closing \" +\n+                                        \"an older connection:\");\n+                                e.printStackTrace(System.out);\n+                            }\n@@ -1094,15 +1098,0 @@\n-\n-                        targetConnection = new Socket(\n-                                serverImpl.getAddress().getAddress(),\n-                                serverImpl.getAddress().getPort());\n-\n-                        \/\/ Then send the 200 OK response to the client\n-                        System.out.println(\"Tunnel: Sending \"\n-                                           + \"HTTP\/1.1 200 OK\\r\\n\\r\\n\");\n-                        pw.print(\"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n-                        pw.flush();\n-                    } else {\n-                        \/\/ This should not happen. If it does let our serverImpl\n-                        \/\/ deal with it.\n-                        throw new IOException(\"Tunnel: Unexpected status line: \"\n-                                             + requestLine);\n@@ -1110,14 +1099,0 @@\n-\n-                    \/\/ Pipe the input stream of the client connection to the\n-                    \/\/ output stream of the target connection and conversely.\n-                    \/\/ Now the client and target will just talk to each other.\n-                    System.out.println(\"Tunnel: Starting tunnel pipes\");\n-                    Thread t1 = pipe(ccis, targetConnection.getOutputStream(), '+');\n-                    Thread t2 = pipe(targetConnection.getInputStream(), ccos, '-');\n-                    t1.start();\n-                    t2.start();\n-\n-                    \/\/ We have only 1 client... wait until it has finished before\n-                    \/\/ accepting a new connection request.\n-                    t1.join();\n-                    t2.join();\n@@ -1125,1 +1100,1 @@\n-            } catch (Throwable ex) {\n+                System.out.println(\"Tunnel: Client accepted\");\n@@ -1127,3 +1102,24 @@\n-                    ss.close();\n-                } catch (IOException ex1) {\n-                    ex.addSuppressed(ex1);\n+                    \/\/ We have only 1 client... process the current client\n+                    \/\/ request and wait until it has finished before\n+                    \/\/ accepting a new connection request.\n+                    processRequestAndWaitToComplete(clientConnection);\n+                } catch (IOException ioe) {\n+                    \/\/ close the client connection\n+                    try {\n+                        clientConnection.close();\n+                    } catch (IOException io) {\n+                        \/\/ ignore\n+                        if (DEBUG) {\n+                            System.out.println(\"Ignoring exception that happened during client\" +\n+                                    \" connection close:\");\n+                            io.printStackTrace(System.out);\n+                        }\n+                    } finally {\n+                        clientConnection = null;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ don't close the client connection for non-IOExceptions, instead\n+                    \/\/ just log it and move on to accept next connection\n+                    if (!stop) {\n+                        t.printStackTrace();\n+                    }\n@@ -1131,1 +1127,0 @@\n-                ex.printStackTrace(System.err);\n@@ -1135,0 +1130,52 @@\n+        private void processRequestAndWaitToComplete(final Socket clientConnection)\n+                throws IOException, InterruptedException {\n+            final Socket targetConnection;\n+            InputStream  ccis = clientConnection.getInputStream();\n+            OutputStream ccos = clientConnection.getOutputStream();\n+            Writer w = new OutputStreamWriter(\n+                    clientConnection.getOutputStream(), \"UTF-8\");\n+            PrintWriter pw = new PrintWriter(w);\n+            System.out.println(\"Tunnel: Reading request line\");\n+            String requestLine = readLine(ccis);\n+            System.out.println(\"Tunnel: Request line: \" + requestLine);\n+            if (requestLine.startsWith(\"CONNECT \")) {\n+                \/\/ We should probably check that the next word following\n+                \/\/ CONNECT is the host:port of our HTTPS serverImpl.\n+                \/\/ Some improvement for a followup!\n+\n+                \/\/ Read all headers until we find the empty line that\n+                \/\/ signals the end of all headers.\n+                while(!requestLine.equals(\"\")) {\n+                    System.out.println(\"Tunnel: Reading header: \"\n+                            + (requestLine = readLine(ccis)));\n+                }\n+\n+                targetConnection = new Socket(\n+                        serverImpl.getAddress().getAddress(),\n+                        serverImpl.getAddress().getPort());\n+\n+                \/\/ Then send the 200 OK response to the client\n+                System.out.println(\"Tunnel: Sending \"\n+                        + \"HTTP\/1.1 200 OK\\r\\n\\r\\n\");\n+                pw.print(\"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n+                pw.flush();\n+            } else {\n+                \/\/ This should not happen. If it does then consider it a\n+                \/\/ client error and throw an IOException\n+                System.out.println(\"Tunnel: Throwing an IOException due to unexpected\" +\n+                        \" request line: \" + requestLine);\n+                throw new IOException(\"Client request error - Unexpected request line\");\n+            }\n+\n+            \/\/ Pipe the input stream of the client connection to the\n+            \/\/ output stream of the target connection and conversely.\n+            \/\/ Now the client and target will just talk to each other.\n+            System.out.println(\"Tunnel: Starting tunnel pipes\");\n+            Thread t1 = pipe(ccis, targetConnection.getOutputStream(), '+');\n+            Thread t2 = pipe(targetConnection.getInputStream(), ccos, '-');\n+            t1.start();\n+            t2.start();\n+            \/\/ wait for the request to complete\n+            t1.join();\n+            t2.join();\n+        }\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPTestServer.java","additions":115,"deletions":68,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n@@ -58,0 +60,2 @@\n+        String ipv4Reversed = null;\n+\n@@ -59,1 +63,2 @@\n-            \/\/ First check that host resolves to IPv4 address\n+            \/\/ called from lookupWithIPv4Prefer\n+            \/\/ obtain an IPv4 address from the hostname.\n@@ -63,0 +68,3 @@\n+                ia = InetAddress.getByName(addr);\n+                System.out.print(addr + \":\" + ia.getHostName());\n+                return;\n@@ -67,5 +75,12 @@\n-        } else {\n-            String tmp = lookupWithIPv4Prefer();\n-            System.out.println(\"IPv4 lookup results: [\" + tmp + \"]\");\n-            if (SKIP.equals(tmp)) {\n-                System.out.println(HOST + \" can't be resolved - test skipped.\");\n+        } else if (args.length == 2 && args[0].equals(\"reverse\")) {\n+            \/\/ called from reverseWithIPv4Prefer\n+            \/\/ Check that IPv4 address can be resolved to host\n+            \/\/ with -Djava.net.preferIPv4Stack=true\n+            try {\n+                InetAddress ia = InetAddress.getByName(args[1]);\n+                addr = ia.getHostAddress();\n+                ipv4Reversed = ia.getHostName();\n+                System.out.print(addr + \":\" + ipv4Reversed);\n+                return;\n+            } catch (UnknownHostException e) {\n+                System.out.print(SKIP);\n@@ -74,0 +89,15 @@\n+        } else if (args.length != 1 || !args[0].equals(\"root\")) {\n+            throw new IllegalArgumentException(Stream.of(args).collect(Collectors.joining(\" \")));\n+        }\n+\n+        \/\/ spawn a subprocess to obtain the IPv4 address\n+        String tmp = lookupWithIPv4Prefer();\n+        System.out.println(\"IPv4 lookup results: [\" + tmp + \"]\");\n+        if (SKIP.equals(tmp)) {\n+            System.out.println(HOST + \" can't be resolved - test skipped.\");\n+            return;\n+        }\n+\n+        String[] strs = tmp.split(\":\");\n+        addr = strs[0];\n+        ipv4Name = strs[1];\n@@ -75,3 +105,7 @@\n-            String[] strs = tmp.split(\":\");\n-            addr = strs[0];\n-            ipv4Name = strs[1];\n+        \/\/ check that the a reverse lookup of the IPv4 address\n+        \/\/ will succeed with the IPv4 only stack\n+        tmp = reverseWithIPv4Prefer(addr);\n+        System.out.println(\"IPv4 reverse lookup results: [\" + tmp + \"]\");\n+        if (SKIP.equals(tmp)) {\n+            System.out.println(addr + \" can't be resolved with preferIPv4 - test skipped.\");\n+            return;\n@@ -80,1 +114,4 @@\n-        \/\/ reverse lookup\n+        strs = tmp.split(\":\");\n+        ipv4Reversed = strs[1];\n+\n+        \/\/ Now check that a reverse lookup will succeed with the dual stack.\n@@ -83,8 +120,10 @@\n-        if (args.length == 0) {\n-            System.out.print(addr + \":\" + name);\n-            return;\n-        } else {\n-            System.out.println(\"(default) \" + addr + \"--> \" + name);\n-            if (!ipv4Name.equals(name)) {\n-                throw new RuntimeException(\"Mismatch between default\"\n-                        + \" and java.net.preferIPv4Stack=true results\");\n+\n+        System.out.println(\"(default) \" + addr + \"--> \" + name\n+                               + \" (reversed IPv4: \" + ipv4Reversed + \")\");\n+        if (!ipv4Name.equals(name)) {\n+            \/\/ adding some diagnosting\n+            System.err.println(\"name=\" + name + \" doesn't match expected=\" + ipv4Name);\n+            System.err.println(\"Listing all adresses:\");\n+            for (InetAddress any : InetAddress.getAllByName(HOST)) {\n+                System.err.println(\"\\t[\" + any + \"] address=\" + any.getHostAddress()\n+                                   + \", host=\" + any.getHostName());\n@@ -92,0 +131,3 @@\n+            \/\/ make the test fail...\n+            throw new RuntimeException(\"Mismatch between default\"\n+                    + \" and java.net.preferIPv4Stack=true results\");\n@@ -103,1 +145,0 @@\n-}\n@@ -105,0 +146,9 @@\n+    static String reverseWithIPv4Prefer(String addr) throws IOException {\n+        String java = JDKToolFinder.getTestJDKTool(\"java\");\n+        String testClz = Lookup.class.getName();\n+        List<String> cmd = List.of(java, \"-Djava.net.preferIPv4Stack=true\",\n+                                   \"-cp\", CLASS_PATH, testClz, \"reverse\", addr);\n+        System.out.println(\"Executing: \" + cmd);\n+        return new OutputAnalyzer(new ProcessBuilder(cmd).start()).getOutput();\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/InetAddress\/ptr\/Lookup.java","additions":70,"deletions":20,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -32,0 +33,1 @@\n+import jdk.test.lib.Platform;\n@@ -42,0 +44,6 @@\n+\n+                \/\/JDK-8230132: Should not test on Windows with Teredo Tunneling Pseudo-Interface\n+                String dName = ni.getDisplayName();\n+                if (Platform.isWindows() && dName != null && dName.contains(\"Teredo\"))\n+                    continue;\n+\n","filename":"test\/jdk\/java\/net\/NetworkInterface\/NetworkInterfaceRetrievalTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,4 @@\n-        ServerSocket ss = new ServerSocket(0);\n-        Socket s1 = new Socket(\"localhost\", ss.getLocalPort());\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket(0, 0, loopback);\n+\n+        Socket s1 = new Socket(loopback, ss.getLocalPort());\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/SetOption.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8232097\n+ * @summary Basic sanity for creation of SCTP channels\n+ * @modules jdk.sctp\n+ * @run main\/othervm SctpSanity 1\n+ * @run main\/othervm SctpSanity 2\n+ * @run main\/othervm SctpSanity 3\n+ *\/\n+\n+import java.io.IOException;\n+import com.sun.nio.sctp.SctpChannel;\n+import com.sun.nio.sctp.SctpMultiChannel;\n+import com.sun.nio.sctp.SctpServerChannel;\n+import static java.lang.System.out;\n+\n+\/**\n+ * Tests creation of SCTP channels. The channels should either be created\n+ * or not. The latter throwing an UnsupportedOperationException. No other\n+ * behavior is acceptable. Minimally, exercises the JDK's native library\n+ * loading on operating systems that provide an implementation, even if\n+ * the system-level support is not configured.\n+ *\/\n+public class SctpSanity {\n+\n+    public static void main(String... args) throws IOException {\n+        switch (Integer.valueOf(args[0])) {\n+            case 1: testSctpChannel();        break;\n+            case 2: testSctpServerChannel();  break;\n+            case 3: testSctpMultiChannel();   break;\n+            default: throw new AssertionError(\"should not reach here\");\n+        }\n+    }\n+\n+    static void testSctpChannel() throws IOException {\n+        try (SctpChannel channel = SctpChannel.open()) {\n+            out.println(\"created SctpChannel:\" + channel);\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ ok - the platform does not support SCTP\n+            out.println(\"ok, caught:\" + uoe);\n+        }\n+    }\n+\n+    static void testSctpServerChannel() throws IOException {\n+        try (SctpServerChannel channel = SctpServerChannel.open()) {\n+            out.println(\"created SctpServerChannel:\" + channel);\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ ok - the platform does not support SCTP\n+            out.println(\"ok, caught:\" + uoe);\n+        }\n+    }\n+\n+    static void testSctpMultiChannel() throws IOException {\n+        try (SctpMultiChannel channel = SctpMultiChannel.open()) {\n+            out.println(\"created SctpMultiChannel:\" + channel);\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ ok - the platform does not support SCTP\n+            out.println(\"ok, caught:\" + uoe);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/SctpSanity.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,4 @@\n-        ServerSocket ss = new ServerSocket(0);\n-        client = new Socket(\"localhost\", ss.getLocalPort());\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+        client = new Socket(loopback, ss.getLocalPort());\n","filename":"test\/jdk\/java\/net\/Socket\/RST.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n@@ -45,1 +47,3 @@\n-        try (ServerSocket ss = new ServerSocket(0)) {\n+        try (ServerSocket ss = new ServerSocket()) {\n+            InetAddress loopback = InetAddress.getLoopbackAddress();\n+            ss.bind(new InetSocketAddress(loopback, 0));\n@@ -58,0 +62,1 @@\n+        final InetAddress address = ss.getInetAddress();\n@@ -60,1 +65,3 @@\n-            sockets[i] = new Socket(\"localhost\", port);\n+            sockets[i] = address.isAnyLocalAddress()\n+                         ? new Socket(\"localhost\", port)\n+                         : new Socket(address, port);\n","filename":"test\/jdk\/java\/net\/Socket\/Streams.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -49,0 +50,1 @@\n+import org.testng.SkipException;\n@@ -53,0 +55,2 @@\n+import jdk.test.lib.NetworkConfiguration;\n+\n@@ -60,1 +64,0 @@\n-    private static boolean shouldRun = false;\n@@ -64,1 +67,4 @@\n-        shouldRun = ensureInet6AddressFamily() && ensureIPv6OnLoopback();\n+        if (!ensureInet6AddressFamily() || !ensureIPv6OnLoopback()) {\n+            NetworkConfiguration.printSystemConfiguration(System.out);\n+            throw new SkipException(\"Host does not support IPv6\");\n+        }\n@@ -123,2 +129,0 @@\n-        if (!shouldRun) return;\n-\n@@ -139,2 +143,0 @@\n-        if (!shouldRun) return;\n-\n","filename":"test\/jdk\/java\/net\/Socks\/SocksIPv6Test.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -36,0 +37,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -80,1 +82,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -82,7 +84,14 @@\n-            ServerSocket serversocket = new ServerSocket (0);\n-            int port = serversocket.getLocalPort ();\n-            XServer server = new XServer (serversocket);\n-            server.start ();\n-            Thread.sleep (200);\n-            URL url = new URL (\"http:\/\/localhost:\"+port+\"\/index.html\");\n-            URLConnection uc = url.openConnection ();\n+            InetAddress loopback = InetAddress.getLoopbackAddress();\n+            ServerSocket serversocket = new ServerSocket();\n+            serversocket.bind(new InetSocketAddress(loopback, 0));\n+            int port = serversocket.getLocalPort();\n+            XServer server = new XServer(serversocket);\n+            server.start();\n+            Thread.sleep(200);\n+            URL url = URIBuilder.newBuilder()\n+                      .scheme(\"http\")\n+                      .loopback()\n+                      .port(port)\n+                      .path(\"\/index.html\")\n+                      .toURL();\n+            URLConnection uc = url.openConnection();\n@@ -109,0 +118,1 @@\n+            throw e;\n","filename":"test\/jdk\/java\/net\/URLConnection\/URLConnectionHeaders.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8217237\n+ * @modules java.net.http\n+ * @run main\/othervm AuthSchemesTest\n+ * @summary HttpClient does not deal well with multi-valued WWW-Authenticate challenge headers\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.*;\n+import java.net.Authenticator;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+public class AuthSchemesTest {\n+    static class BasicServer extends Thread {\n+\n+        ServerSocket server;\n+\n+        Socket s;\n+        InputStream is;\n+        OutputStream os;\n+        static final String RESPONSE = \"Hello world\";\n+        static final String respLength = Integer.toString(RESPONSE.length());\n+        static final String realm = \"wally world\";\n+\n+        String reply1 = \"HTTP\/1.1 401 Unauthorized\\r\\n\"+\n+                \"WWW-Authenticate: BarScheme\\r\\n\" +\n+                \"WWW-Authenticate: FooScheme realm=\\\"\"+realm+\"\\\"\\r\\n\" +\n+                \"WWW-Authenticate: Basic realm=\\\"\"+realm+\"\\\"\\r\\n\" +\n+                \"WWW-Authenticate: WoofScheme\\r\\n\\r\\n\";\n+\n+        String reply2 = \"HTTP\/1.1 200 OK\\r\\n\"+\n+                \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+                \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Type: text\/html; charset=iso-8859-1\\r\\n\" +\n+                \"Content-Length: \" + respLength + \"\\r\\n\\r\\n\";\n+\n+        BasicServer(ServerSocket s) {\n+            server = s;\n+        }\n+\n+        String response() {\n+            return RESPONSE;\n+        }\n+\n+        void readAll(Socket s) throws IOException {\n+            byte[] buf = new byte [128];\n+            InputStream is = s.getInputStream();\n+            s.setSoTimeout(1000);\n+            try {\n+                while (is.read(buf) > 0) ;\n+            } catch (SocketTimeoutException x) { }\n+        }\n+\n+        public void run() {\n+            try {\n+                System.out.println(\"Server 1: accept\");\n+                s = server.accept();\n+                System.out.println(\"accepted\");\n+                os = s.getOutputStream();\n+                os.write(reply1.getBytes());\n+                readAll(s);\n+                s.close();\n+\n+                System.out.println(\"Server 2: accept\");\n+                s = server.accept();\n+                System.out.println(\"accepted\");\n+                os = s.getOutputStream();\n+                os.write((reply2+RESPONSE).getBytes());\n+                readAll(s);\n+                s.close();\n+\n+            }\n+            catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            finished();\n+        }\n+\n+        boolean isfinished = false;\n+\n+        public synchronized void finished() {\n+            isfinished = true;\n+            notifyAll();\n+        }\n+\n+        public synchronized void waitforfinish() {\n+            while (!isfinished) {\n+                try {\n+                    wait();\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Auth extends Authenticator {\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(\"user\", new char[] {'a','b','c'});\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ServerSocket serversocket = null;\n+        BasicServer server = null;\n+        Auth authenticator = new Auth();\n+\n+        serversocket = new ServerSocket(0, 10, InetAddress.getLoopbackAddress());\n+        int port = serversocket.getLocalPort();\n+        server = new BasicServer(serversocket);\n+\n+        HttpClient client = HttpClient.newBuilder()\n+                .authenticator(authenticator)\n+                .build();\n+        server.start();\n+        URI uri = URI.create(\"http:\/\/127.0.0.1:\" + port + \"\/foo\");\n+        HttpRequest request = HttpRequest.newBuilder(uri)\n+                .GET()\n+                .build();\n+        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+        if (response.statusCode() != 200 || !response.body().equals(server.response())) {\n+            System.out.println(\"Status code = \" + response.statusCode());\n+            serversocket.close();\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+        serversocket.close();\n+        server.waitforfinish();\n+        System.out.println(\"OK\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthSchemesTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,4 @@\n- * @summary IPv6 support for Windows XP and 2003 server\n+ * @key intermittent\n+ * @summary IPv6 support for Windows XP and 2003 server.\n+ *          This test requires binding to the wildcard address and as such\n+ *          may fail intermittently on some platforms.\n@@ -31,1 +34,1 @@\n- * @run main UdpTest\n+ * @run main UdpTest -d\n@@ -91,0 +94,1 @@\n+        System.out.println(\"Test1 starting\");\n@@ -129,0 +133,1 @@\n+        System.out.println(\"Test2 starting\");\n@@ -179,0 +184,1 @@\n+        System.out.println(\"Test3 starting\");\n@@ -190,0 +196,1 @@\n+        System.out.println(\"Test4 starting\");\n","filename":"test\/jdk\/java\/net\/ipv6tests\/UdpTest.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- *      8149469\n+ *      8149469 8230665\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            = ProcessTools.createJavaProcessBuilder(true, Default.class.getName());\n+            = ProcessTools.createTestJvm(Default.class.getName());\n","filename":"test\/jdk\/java\/nio\/charset\/Charset\/DefaultCharsetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmd);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmd);\n","filename":"test\/jdk\/java\/nio\/charset\/coders\/SJISMappingPropTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-        if (FileUtils.areFileSystemsAccessible()) {\n+        if (FileUtils.areAllMountPointsAccessible()) {\n","filename":"test\/jdk\/java\/nio\/file\/FileStore\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, MacPath.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(MacPath.class.getName());\n","filename":"test\/jdk\/java\/nio\/file\/Path\/MacPathTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.*;\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @summary Throw error if default java.security file is missing\n+ * @bug 8155246\n+ * @library \/test\/lib\n+ * @run main ConfigFileTest\n+ *\/\n+public class ConfigFileTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        Path copyJdkDir = Path.of(\".\/jdk-8155246-tmpdir\");\n+        Path copiedJava = Optional.of(\n+                        Path.of(copyJdkDir.toString(), \"bin\", \"java\"))\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate new JDK\")\n+                );\n+\n+        if (args.length == 1) {\n+            \/\/ set up is complete. Run code to exercise loading of java.security\n+            System.out.println(Arrays.toString(Security.getProviders()));\n+        } else {\n+            Files.createDirectory(copyJdkDir);\n+            Path jdkTestDir = Path.of(Optional.of(System.getProperty(\"test.jdk\"))\n+                            .orElseThrow(() -> new RuntimeException(\"Couldn't load JDK Test Dir\"))\n+            );\n+\n+            copyJDKMinusJavaSecurity(jdkTestDir, copyJdkDir);\n+            String extraPropsFile = Path.of(System.getProperty(\"test.src\"), \"override.props\").toString();\n+\n+            \/\/ exercise some debug flags while we're here\n+            \/\/ launch JDK without java.security file being present or specified\n+            exerciseSecurity(copiedJava.toString(), \"-cp\", System.getProperty(\"test.classes\"),\n+                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\", \"ConfigFileTest\", \"runner\");\n+\n+            \/\/ test the override functionality also. Should not be allowed since\n+            \/\/ \"security.overridePropertiesFile=true\" Security property is missing.\n+            exerciseSecurity(copiedJava.toString(), \"-cp\", System.getProperty(\"test.classes\"),\n+                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n+                    \"-Djava.security.properties==file:\/\/\" + extraPropsFile, \"ConfigFileTest\", \"runner\");\n+        }\n+    }\n+\n+    private static void exerciseSecurity(String... args) throws Exception {\n+        ProcessBuilder process = new ProcessBuilder(args);\n+        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n+        oa.shouldHaveExitValue(1).shouldContain(\"java.security file missing\");\n+    }\n+\n+    private static void copyJDKMinusJavaSecurity(Path src, Path dst) throws Exception {\n+        Files.walk(src)\n+            .skip(1)\n+            .filter(p -> !p.toString().endsWith(\"java.security\"))\n+            .forEach(file -> {\n+                try {\n+                    Files.copy(file, dst.resolve(src.relativize(file)), StandardCopyOption.COPY_ATTRIBUTES);\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+security.provider.1=sun.security.provider.Sun\n+security.provider.2=sun.security.rsa.SunRsaSign\n+security.provider.3=sun.security.ssl.SunJSSE\n+security.provider.4=com.sun.crypto.provider.SunJCE\n+security.provider.5=sun.security.jgss.SunProvider\n+security.provider.6=com.sun.security.sasl.Provider\n","filename":"test\/jdk\/java\/security\/Security\/override.props","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260274\n+ * @run main\/othervm TestDefaultRandom APG 1\n+ * @run main\/othervm TestDefaultRandom APG 2\n+ * @run main\/othervm TestDefaultRandom KPG 1\n+ * @run main\/othervm TestDefaultRandom KPG 2\n+ * @run main\/othervm TestDefaultRandom CIP 1\n+ * @run main\/othervm TestDefaultRandom CIP 2\n+ * @run main\/othervm TestDefaultRandom CIP 3\n+ * @run main\/othervm TestDefaultRandom CIP 4\n+ * @run main\/othervm TestDefaultRandom KA 1\n+ * @run main\/othervm TestDefaultRandom KA 2\n+ * @run main\/othervm TestDefaultRandom KG 1\n+ * @run main\/othervm TestDefaultRandom KG 2\n+ * @summary Ensure the default SecureRandom impl is used as the javadoc\n+ * spec stated when none supplied.\n+ *\/\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import java.util.Map;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.DSAGenParameterSpec;\n+import java.security.spec.RSAKeyGenParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+public class TestDefaultRandom {\n+\n+    public static void main(String[] argv) throws Exception {\n+        if (argv.length != 2) {\n+            throw new RuntimeException(\"Error: missing test parameters\");\n+        }\n+\n+        switch (argv[0]) {\n+            case \"APG\":\n+                check(AlgorithmParameterGenerator.getInstance(\"DSA\"), argv[1]);\n+                break;\n+            case \"KPG\":\n+                check(KeyPairGenerator.getInstance(\"RSA\"), argv[1]);\n+                break;\n+            case \"CIP\":\n+                check(Cipher.getInstance(\"AES\/CBC\/NoPadding\"), argv[1]);\n+                break;\n+            case \"KA\":\n+                check(KeyAgreement.getInstance(\"DH\"), argv[1]);\n+                break;\n+            case \"KG\":\n+                check(KeyGenerator.getInstance(\"AES\"), argv[1]);\n+                break;\n+            default:\n+                throw new RuntimeException(\"Error: unsupported test type\");\n+        }\n+    }\n+\n+    private static void check(Object obj, String testNum) {\n+        if (obj == null) throw new NullPointerException();\n+\n+        SampleProvider prov = new SampleProvider();\n+        Security.insertProviderAt(prov, 1);\n+\n+        int b4Cnt = SampleProvider.count;\n+\n+        System.out.println(\"before, count = \" + b4Cnt);\n+        \/\/ Note that the arguments may not be valid, they just need to be\n+        \/\/ non-null to trigger the call for checking if the default\n+        \/\/ SecureRandom impl is used\n+        try {\n+            if (obj instanceof AlgorithmParameterGenerator) {\n+                AlgorithmParameterGenerator apg =\n+                        (AlgorithmParameterGenerator) obj;\n+                switch (testNum) {\n+                    case \"1\":\n+                        apg.init(123);\n+                        break;\n+                    case \"2\":\n+                        apg.init((AlgorithmParameterSpec) null);\n+                        break;\n+                    default:\n+                        throw new RuntimeException(\"Error: invalid test#\");\n+                }\n+            } else if (obj instanceof KeyPairGenerator) {\n+                KeyPairGenerator kpg = (KeyPairGenerator) obj;\n+                switch (testNum) {\n+                    case \"1\":\n+                        kpg.initialize(123);\n+                        break;\n+                    case \"2\":\n+                        kpg.initialize((AlgorithmParameterSpec) null);\n+                        break;\n+                    default:\n+                        throw new RuntimeException(\"Error: invalid test#\");\n+                }\n+            } else if (obj instanceof Cipher) {\n+                Cipher c = (Cipher) obj;\n+                switch (testNum) {\n+                    case \"1\":\n+                        c.init(Cipher.ENCRYPT_MODE, (Key) null);\n+                        break;\n+                    case \"2\":\n+                        c.init(Cipher.ENCRYPT_MODE, (Key) null,\n+                        (AlgorithmParameterSpec) null);\n+                        break;\n+                    case \"3\":\n+                        c.init(Cipher.ENCRYPT_MODE, (Key) null,\n+                        (AlgorithmParameters) null);\n+                        break;\n+                    case \"4\":\n+                        c.init(Cipher.ENCRYPT_MODE, (Certificate)null);\n+                        break;\n+                    default:\n+                        throw new RuntimeException(\"Error: invalid test#\");\n+                }\n+            } else if (obj instanceof KeyAgreement) {\n+                KeyAgreement ka = (KeyAgreement) obj;\n+                switch (testNum) {\n+                    case \"1\":\n+                        ka.init((Key) null);\n+                        break;\n+                    case \"2\":\n+                        ka.init((Key) null, (AlgorithmParameterSpec) null);\n+                        break;\n+                    default:\n+                        throw new RuntimeException(\"Error: invalid test#\");\n+                }\n+            } else if (obj instanceof KeyGenerator) {\n+                KeyGenerator kg = (KeyGenerator) obj;\n+                switch (testNum) {\n+                    case \"1\":\n+                        kg.init(123);\n+                        break;\n+                    case \"2\":\n+                        kg.init((AlgorithmParameterSpec) null);\n+                        break;\n+                    default:\n+                        throw new RuntimeException(\"Error: invalid test#\");\n+                }\n+            } else {\n+                throw new RuntimeException(\"Error: Unsupported type\");\n+            }\n+        } catch (GeneralSecurityException | InvalidParameterException e) {\n+            \/\/ expected; ignore\n+        }\n+        System.out.println(\"after, count = \" + SampleProvider.count);\n+        if (SampleProvider.count == b4Cnt) {\n+            throw new RuntimeException(\"Test Failed\");\n+        }\n+    }\n+\n+    private static class SampleProvider extends Provider {\n+\n+        static int count = 0;\n+        static String SR_ALGO = \"Custom\";\n+\n+        SampleProvider() {\n+            super(\"Sample\", \"1.0\", \"test provider with custom SR impl\");\n+            putService(new SampleService(this, \"SecureRandom\", SR_ALGO,\n+                    \"SampleSecureRandom.class\" \/* stub class name *\/,\n+                    null, null));\n+        }\n+\n+        private static class SampleService extends Service {\n+\n+            SampleService(Provider p, String type, String alg, String cn,\n+                    List<String> aliases, Map<String,String> attrs) {\n+                super(p, type, alg, cn, aliases, attrs);\n+            }\n+\n+            @Override\n+            public Object newInstance(Object param)\n+                    throws NoSuchAlgorithmException {\n+                String alg = getAlgorithm();\n+                String type = getType();\n+\n+                if (type.equals(\"SecureRandom\") && alg.equals(SR_ALGO)) {\n+                    SampleProvider.count++;\n+                    return new CustomSR();\n+                } else {\n+                    \/\/ should never happen\n+                    throw new NoSuchAlgorithmException(\"No support for \" + alg);\n+                }\n+            }\n+        }\n+\n+        private static class CustomSR extends SecureRandomSpi {\n+            @Override\n+            protected void engineSetSeed(byte[] seed) {\n+            }\n+\n+            @Override\n+            protected void engineNextBytes(byte[] bytes) {\n+            }\n+\n+            @Override\n+            protected byte[] engineGenerateSeed(int numBytes) {\n+                return new byte[numBytes];\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/misc\/TestDefaultRandom.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,1 +325,1 @@\n-                oidVector.add(new ObjectIdentifier(oid));\n+                oidVector.add(ObjectIdentifier.of(oid));\n","filename":"test\/jdk\/java\/security\/testlibrary\/CertificateBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,5 +48,1 @@\n-import sun.security.util.Debug;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.ObjectIdentifier;\n+import sun.security.util.*;\n@@ -62,2 +58,2 @@\n-            ObjectIdentifier.newInternal(\n-                    new int[] { 1, 3, 6, 1, 5, 5, 7, 48, 1, 1});\n+            ObjectIdentifier.of(KnownOIDs.OCSPBasicResponse);\n+\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -617,1 +617,1 @@\n-        DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n+        DateTimeFormatter df = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(Locale.US);\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/format\/TCKDateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -26,1 +26,1 @@\n- * @bug 4327164\n+ * @bug 4327164 8229338\n@@ -28,0 +28,1 @@\n+ * @run testng Basic\n@@ -30,8 +31,9 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.RandomAccess;\n-import java.util.Vector;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n@@ -40,47 +42,0 @@\n-    public static void main(String[] args) throws Exception {\n-        List a0 = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        List a[] = { a0, new ArrayList(a0), new LinkedList(a0),\n-                new Vector(a0) };\n-\n-        if (!(a[0] instanceof RandomAccess))\n-            throw new Exception(\"Arrays.asList doesn't implement RandomAccess\");\n-        if (!(a[1] instanceof RandomAccess))\n-            throw new Exception(\"ArrayList doesn't implement RandomAccess\");\n-        if (a[2] instanceof RandomAccess)\n-            throw new Exception(\"LinkedList implements RandomAccess\");\n-        if (!(a[3] instanceof RandomAccess))\n-            throw new Exception(\"Vector doesn't implement RandomAccess\");\n-\n-        for (int i = 0; i < a.length; i++) {\n-            List t = a[i];\n-            List ut = Collections.unmodifiableList(t);\n-            List st = Collections.synchronizedList(t);\n-\n-            boolean random = t instanceof RandomAccess;\n-            if ((ut instanceof RandomAccess) != random)\n-                throw new Exception(\n-                        \"Unmodifiable fails to preserve RandomAccess: \" + i);\n-            if ((st instanceof RandomAccess) != random)\n-                throw new Exception(\n-                        \"Synchronized fails to preserve RandomAccess: \" + i);\n-\n-            while (t.size() > 0) {\n-                t = t.subList(0, t.size() - 1);\n-                if ((t instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList fails to preserve RandomAccess: \" + i\n-                                    + \", \" + t.size());\n-\n-                ut = ut.subList(0, ut.size() - 1);\n-                if ((ut instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList(unmodifiable) fails to preserve RandomAccess: \"\n-                                    + i + \", \" + ut.size());\n-\n-                st = st.subList(0, st.size() - 1);\n-                if ((st instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList(synchronized) fails to preserve RandomAccess: \"\n-                                    + i + \", \" + st.size());\n-            }\n-        }\n@@ -88,6 +43,8 @@\n-        \/\/ Test that shuffle works the same on random and sequential access\n-        List al = new ArrayList();\n-        for (int j = 0; j < 100; j++)\n-            al.add(Integer.valueOf(2 * j));\n-        List ll = new LinkedList(al);\n-        Random r1 = new Random(666), r2 = new Random(666);\n+    \/*\n+     * Lists which implement Random Access interface\n+     *\/\n+    @DataProvider(name = \"testLists\")\n+    public Object[][] testData() {\n+        var intArray = new Integer[100];\n+        var stack = new Stack<>();\n+        var random = new Random();\n@@ -95,4 +52,42 @@\n-            Collections.shuffle(al, r1);\n-            Collections.shuffle(ll, r2);\n-            if (!al.equals(ll))\n-                throw new Exception(\"Shuffle failed: \" + i);\n+            var r = random.nextInt(100);\n+            stack.push(r);\n+            intArray[i] = r;\n+        }\n+        List<Integer> list = Arrays.asList(intArray);\n+        return new Object[][]{\n+                {list, true, \"Arrays.asList\"},\n+                {stack, true, \"Stack\"},\n+                {new ArrayList<>(list), true, \"ArrayList\"},\n+                {new LinkedList<>(list), false, \"LinkedList\"},\n+                {new Vector<>(list), true, \"Vector\"},\n+                {new CopyOnWriteArrayList<>(list), true, \"CopyOnWriteArrayList\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testLists\")\n+    public void testRandomAccess(List<Integer> list, boolean expectedRA, String failMsg) {\n+\n+        var actualRA = list instanceof RandomAccess;\n+        assertEquals(actualRA, expectedRA, failMsg);\n+\n+        List<Integer> unmodList = Collections.unmodifiableList(list);\n+        List<Integer> syncList = Collections.synchronizedList(list);\n+        assertEquals((unmodList instanceof RandomAccess), actualRA,\n+                \"Unmodifiable fails to preserve RandomAccess\");\n+        assertEquals((syncList instanceof RandomAccess), actualRA,\n+                \"Synchronized fails to preserve RandomAccess\");\n+\n+        while (list.size() > 0) {\n+            list = list.subList(0, list.size() - 1);\n+            assertEquals((list instanceof RandomAccess), actualRA,\n+                    \"SubList fails to preserve RandomAccess: \" + list.size());\n+\n+            unmodList = unmodList.subList(0, unmodList.size() - 1);\n+            assertEquals((unmodList instanceof RandomAccess), actualRA,\n+                    \"SubList(unmodifiable) fails to preserve RandomAccess: \"\n+                            + unmodList.size());\n+\n+            syncList = syncList.subList(0, syncList.size() - 1);\n+            assertEquals((syncList instanceof RandomAccess), actualRA,\n+                    \"SubList(synchronized) fails to preserve RandomAccess: \"\n+                            + syncList.size());\n@@ -100,0 +95,1 @@\n+    }\n@@ -101,8 +97,7 @@\n-        \/\/ Test that fill works on random & sequential access\n-        List gumbyParade = Collections.nCopies(100, \"gumby\");\n-        Collections.fill(al, \"gumby\");\n-        if (!al.equals(gumbyParade))\n-            throw new Exception(\"ArrayList fill failed\");\n-        Collections.fill(ll, \"gumby\");\n-        if (!ll.equals(gumbyParade))\n-            throw new Exception(\"LinkedList fill failed\");\n+    @Test(dataProvider = \"testLists\")\n+    public void testListCopy(List<Integer> list, boolean expectedRA, String failMsg) {\n+        ArrayList testCollection = new ArrayList<>(Collections.nCopies(100, 0));\n+        \/\/ Test that copy works on random & sequential access\n+        Collections.copy(list, testCollection);\n+        assertEquals(list, testCollection, \"Copy failed: \" + failMsg);\n+    }\n@@ -110,0 +105,3 @@\n+    @Test(dataProvider = \"testLists\")\n+    public void testListFill(List<Integer> list, boolean expectedRA, String failMsg) {\n+        ArrayList testCollection = new ArrayList<>(Collections.nCopies(100, 0));\n@@ -111,13 +109,53 @@\n-        List pokeyParade = Collections.nCopies(100, \"pokey\");\n-        Collections.copy(al, pokeyParade);\n-        if (!al.equals(pokeyParade))\n-            throw new Exception(\"ArrayList copy failed\");\n-        Collections.copy(ll, pokeyParade);\n-        if (!ll.equals(pokeyParade))\n-            throw new Exception(\"LinkedList copy failed\");\n-\n-        \/\/ Test that binarySearch works the same on random & sequential access\n-        al = new ArrayList();\n-        for (int i = 0; i < 10000; i++)\n-            al.add(Integer.valueOf(2 * i));\n-        ll = new LinkedList(al);\n+        Collections.fill(list, 0);\n+        assertEquals(list, testCollection, \"Fill failed: \" + failMsg);\n+    }\n+\n+    \/*\n+     * Test that shuffle and binarySearch work the same on random and sequential access lists.\n+     *\/\n+    @DataProvider(name = \"testFactoryLists\")\n+    public Object[][] testDataFactory() {\n+        return new Object[][]{\n+                {\"ArrayList -> LinkedList\", supplier(ArrayList::new), copyCtor(LinkedList::new)},\n+                {\"CopyOnWriteArrayList -> Stack\", supplier(CopyOnWriteArrayList::new),\n+                        copyCtor((list) -> { var s = new Stack();s.addAll(list);return s; })}\n+        };\n+    }\n+\n+    private Supplier<List<Integer>> supplier(Supplier<List<Integer>> supplier) {\n+        return supplier;\n+    }\n+\n+    private Function<List<Integer>, List<Integer>> copyCtor(Function<List<Integer>, List<Integer>> ctor) {\n+        return ctor;\n+    }\n+\n+    @Test(dataProvider = \"testFactoryLists\")\n+    public void testListShuffle(String description, Supplier<List<Integer>> randomAccessListSupplier,\n+                                Function<List<Integer>, List<Integer>> otherListFactory) {\n+\n+        \/\/e.g: ArrayList<Integer> al = new ArrayList<>();\n+        List<Integer> l1 = randomAccessListSupplier.get();\n+        for (int j = 0; j < 100; j++) {\n+            l1.add(Integer.valueOf(2 * j));\n+        }\n+        \/\/ e.g: List<Integer> ll = new LinkedList<>(al);\n+        List<Integer> l2 = otherListFactory.apply(l1);\n+        for (int i = 0; i < 100; i++) {\n+            Collections.shuffle(l1, new Random(666));\n+            Collections.shuffle(l2, new Random(666));\n+            assertEquals(l1, l2, \"Shuffle failed: \" + description);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testFactoryLists\")\n+    public void testListBinarySearch(String description, Supplier<List<Integer>> randomAccessListSupplier,\n+                                     Function<List<Integer>, List<Integer>> otherListFactory) {\n+\n+        \/\/e.g: ArrayList<Integer> al = new ArrayList<>();\n+        List<Integer> l1 = randomAccessListSupplier.get();\n+        for (int i = 0; i < 10000; i++) {\n+            l1.add(Integer.valueOf(2 * i));\n+        }\n+        \/\/ e.g: List<Integer> ll = new LinkedList<>(al);\n+        List<Integer> l2 = otherListFactory.apply(l1);\n@@ -125,4 +163,3 @@\n-            Integer key = Integer.valueOf(r1.nextInt(20000));\n-            if (Collections.binarySearch(al, key) != Collections\n-                    .binarySearch(ll, key))\n-                throw new Exception(\"Binary search failed: \" + i);\n+            Integer key = Integer.valueOf(new Random(666).nextInt(20000));\n+            assertEquals(Collections.binarySearch(l1, key), Collections\n+                    .binarySearch(l2, key), \"Binary search failed: \" + description);\n","filename":"test\/jdk\/java\/util\/RandomAccess\/Basic.java","additions":130,"deletions":93,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ThreadLocalRandom;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+\/*\n+ * @test\n+ * @bug 8254350\n+ * @run main LostInterrupt\n+ * @summary CompletableFuture.get may swallow interrupt status\n+ * @key randomness\n+ *\/\n+\n+\/\/ TODO: Rewrite as a CompletableFuture tck test ?\n+\n+\/**\n+ * Submits a task that completes immediately, then invokes CompletableFuture.get\n+ * with the interrupt status set. CompletableFuture.get should either complete\n+ * immediately with the interrupt status set, or else throw InterruptedException\n+ * with the interrupt status cleared.\n+ *\/\n+public class LostInterrupt {\n+    static final int ITERATIONS = 10_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        ForkJoinPool executor = new ForkJoinPool(1);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                CompletableFuture<String> future = new CompletableFuture<>();\n+                boolean timed = rnd.nextBoolean();\n+                executor.execute(() -> future.complete(\"foo\"));\n+\n+                Thread.currentThread().interrupt();\n+                try {\n+                    String result = timed ? future.get(1, DAYS) : future.get();\n+\n+                    if (!Thread.interrupted())\n+                        throw new AssertionError(\"lost interrupt, run=\" + i);\n+                } catch (InterruptedException expected) {\n+                    if (Thread.interrupted())\n+                        throw new AssertionError(\n+                            \"interrupt status not cleared, run=\" + i);\n+                }\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/CompletableFuture\/LostInterrupt.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8254350\n+ * @run main SwallowedInterruptedException\n+ * @key randomness\n+ *\/\n+\n+\/\/ TODO: incorporate into CompletableFuture tck tests\n+\n+public class SwallowedInterruptedException {\n+    static final int ITERATIONS = 100;\n+\n+    public static void main(String[] args) throws Throwable {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        for (int i = 1; i <= ITERATIONS; i++) {\n+            boolean timed = rnd.nextBoolean();\n+            long sleepMillis = rnd.nextLong(10);\n+\n+            CompletableFuture<Void> future = new CompletableFuture<>();\n+            CountDownLatch threadRunning = new CountDownLatch(1);\n+            AtomicReference<Throwable> fail = new AtomicReference<>();\n+\n+            Thread thread = new Thread(() -> {\n+                threadRunning.countDown();\n+\n+                try {\n+                    Void result = (timed) ? future.get(1, DAYS) : future.get();\n+\n+                    if (!Thread.currentThread().isInterrupted()) {\n+                        fail.set(new AssertionError(\n+                            \"Future.get completed with interrupt status not set\"));\n+                    }\n+                } catch (InterruptedException ex) {\n+                    if (Thread.currentThread().isInterrupted()) {\n+                        fail.set(new AssertionError(\n+                            \"InterruptedException with interrupt status set\"));\n+                    }\n+                } catch (Throwable ex) {\n+                    fail.set(ex);\n+                }\n+            });\n+            thread.start();\n+            threadRunning.await();\n+\n+            \/\/ interrupt thread, then set result after an optional (random) delay\n+            thread.interrupt();\n+            if (sleepMillis > 0)\n+                Thread.sleep(sleepMillis);\n+            future.complete(null);\n+\n+            thread.join();\n+            if (fail.get() != null) {\n+                throw new AssertionError(\n+                    String.format(\"Test failed at iteration %d with [timed=%s sleepMillis=%d]\",\n+                                  i, timed, sleepMillis),\n+                    fail.get());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/CompletableFuture\/SwallowedInterruptedException.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4422362\n+ * @summary Wrong Max Accessible Value with BoundedRangeModel components\n+ * @run main MaximumAccessibleValueTest\n+ *\/\n+\n+import javax.swing.JProgressBar;\n+import javax.swing.JScrollBar;\n+import javax.swing.JSlider;\n+import javax.swing.SwingUtilities;\n+\n+public class MaximumAccessibleValueTest {\n+\n+    public static void doTest() {\n+\n+        JScrollBar jScrollBar = new JScrollBar();\n+        JProgressBar jProgressBar = new JProgressBar();\n+        JSlider jSlider = new JSlider();\n+\n+        if (((Integer) jScrollBar.getAccessibleContext().getAccessibleValue()\n+            .getMaximumAccessibleValue()).intValue() != jScrollBar.getMaximum()\n+            - jScrollBar.getVisibleAmount()) {\n+            throw new RuntimeException(\n+                \"Wrong MaximumAccessibleValue returned by JScrollBar\");\n+        }\n+\n+        if (((Integer) jProgressBar.getAccessibleContext().getAccessibleValue()\n+            .getMaximumAccessibleValue().intValue()) != (jProgressBar\n+                .getMaximum() - jProgressBar.getModel().getExtent())) {\n+            throw new RuntimeException(\n+                \"Wrong MaximumAccessibleValue returned by JProgressBar\");\n+        }\n+\n+        if (((Integer) jSlider.getAccessibleContext().getAccessibleValue()\n+            .getMaximumAccessibleValue()).intValue() != jSlider.getMaximum()\n+            - jSlider.getModel().getExtent()) {\n+            throw new RuntimeException(\n+                \"Wrong MaximumAccessibleValue returned by JSlider\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> doTest());\n+        System.out.println(\"Test Passed\");\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/accessibility\/MaximumAccessibleValueTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4422535\n+ * @summary setCurrentAccessibleValue returns true only for an Integer\n+ * @run main SetCurrentAccessibleValueTest\n+ *\/\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JProgressBar;\n+import javax.swing.JScrollBar;\n+import javax.swing.JSlider;\n+import javax.swing.JSplitPane;\n+import javax.swing.SwingUtilities;\n+\n+public class SetCurrentAccessibleValueTest {\n+\n+    public static void doTest() {\n+        JComponent[] jComponents =\n+        { new JButton(), new JInternalFrame(), new JSplitPane(),\n+            new JScrollBar(), new JProgressBar(), new JSlider() };\n+\n+        for (JComponent jComponent : jComponents) {\n+            testIt(jComponent, (Float.valueOf(5)));\n+            testIt(jComponent, (Double.valueOf(37.266)));\n+            testIt(jComponent, (Integer.valueOf(10)));\n+            testIt(jComponent, (Long.valueOf(123L)));\n+            testIt(jComponent, (Short.valueOf((short) 123)));\n+            testIt(jComponent, (BigInteger.ONE));\n+            testIt(jComponent, (new BigDecimal(BigInteger.ONE)));\n+        }\n+\n+    }\n+\n+    static void testIt(JComponent jComponent, Number number) {\n+        if (!jComponent.getAccessibleContext().getAccessibleValue()\n+            .setCurrentAccessibleValue(number)) {\n+            throw new RuntimeException(jComponent.getClass().getName()\n+                + \" Accessible Value implementation doesn't accept \"\n+                + number.getClass().getName());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> doTest());\n+        System.out.println(\"Test Passed\");\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/accessibility\/SetCurrentAccessibleValueTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-# Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n-# ORACLE PROPRIETARY\/CONFIDENTIAL.  Use is subject to license terms.\n-\n","filename":"test\/jdk\/javax\/crypto\/SecretKeyFactory\/security.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -92,0 +92,6 @@\n+\n+                \/\/ Ignore obsolete\/deprecated Motif\n+                if (lafName.contains(\"Motif\")) {\n+                    System.out.println(\"Skipped Motif\");\n+                    continue;\n+                }\n","filename":"test\/jdk\/javax\/swing\/JRootPane\/DefaultButtonTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,4 @@\n+import java.io.File;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.Dimension;\n@@ -29,0 +33,1 @@\n+import java.awt.Toolkit;\n@@ -41,0 +46,1 @@\n+import javax.imageio.ImageIO;\n@@ -43,0 +49,1 @@\n+\n@@ -55,2 +62,2 @@\n-    private int step;\n-    private boolean spinnerValueChanged[] = {false, false, false};\n+    private int step = 0;\n+    private volatile boolean spinnerValueChanged[] = {false, false, false};\n@@ -58,2 +65,2 @@\n-    private static Point p;\n-    private static Rectangle rect;\n+    private static volatile Point p;\n+    private static volatile Rectangle rect;\n@@ -63,1 +70,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(100);\n@@ -71,0 +78,1 @@\n+                robot.delay(1000);\n@@ -109,0 +117,1 @@\n+            System.out.println(\"p \" + p + \" rect \" + rect);\n@@ -111,1 +120,2 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+\n@@ -126,0 +136,1 @@\n+            robot.waitForIdle();\n@@ -135,0 +146,1 @@\n+            robot.waitForIdle();\n@@ -136,1 +148,2 @@\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n@@ -148,0 +161,9 @@\n+                System.out.println(\"!spinnerValueChanged[0] \" + !spinnerValueChanged[0] +\n+                                   \" spinnerValueChanged[1] \" + spinnerValueChanged[1] +\n+                                   \" !spinnerValueChanged[2] \" + !spinnerValueChanged[2]);\n+                try {\n+                    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                    Rectangle screen = new Rectangle(0, 0, (int) screenSize.getWidth(), (int) screenSize.getHeight());\n+                    BufferedImage fullScreen = robot.createScreenCapture(screen);\n+                    ImageIO.write(fullScreen, \"png\", new File(\"fullScreen.png\"));\n+                } catch (Exception e) {}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/4788637\/bug4788637.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4516019\n+ * @summary Verify that clicking on the increment\/decrement buttons\n+ * of the spinner gives focus to the spinner.\n+ * @run main JSpinnerFocusTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JSpinner;\n+import javax.swing.JSpinner.DefaultEditor;\n+import javax.swing.SwingUtilities;\n+\n+public class JSpinnerFocusTest {\n+\n+    JFrame jFrame;\n+    JButton jButton;\n+    JSpinner jSpinner;\n+    Robot robot;\n+\n+    volatile Rectangle bounds;\n+    volatile boolean jTextFieldFocusStatus = false;\n+\n+    private void createGUI() {\n+        jFrame = new JFrame();\n+        jButton = new JButton();\n+        jSpinner = new JSpinner();\n+\n+        jFrame.setLayout(new BorderLayout());\n+        jFrame.add(jButton, BorderLayout.NORTH);\n+        jFrame.add(jSpinner, BorderLayout.CENTER);\n+        jFrame.setLocationRelativeTo(null);\n+        jFrame.setSize(300, 300);\n+        jFrame.setVisible(true);\n+    }\n+\n+    public void doTest() throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(400);\n+\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+\n+            robot.waitForIdle();\n+            runTest();\n+\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> {\n+                jTextFieldFocusStatus = ((DefaultEditor) jSpinner.getEditor())\n+                    .getTextField().isFocusOwner();\n+            });\n+            if (!jTextFieldFocusStatus) {\n+                throw new RuntimeException(\n+                    \"Clicking on JSpinner buttons did not\"\n+                        + \" shift focus to the JSpinner\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (jFrame != null) {\n+                    jFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private void runTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            bounds = new Rectangle(jSpinner.getLocationOnScreen(),\n+                jSpinner.getSize());\n+        });\n+\n+        \/\/ Move cursor to place it in the spinner editor\n+        robot.mouseMove(bounds.x + bounds.width \/ 2,\n+            bounds.y + bounds.height \/ 2);\n+\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        \/\/ Move cursor to click spinner up arrow button\n+        robot.mouseMove(bounds.x + bounds.width - 2,\n+            bounds.y + bounds.height \/ 4);\n+\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new JSpinnerFocusTest().doTest();\n+        System.out.println(\"Test Passed\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/JSpinnerFocusTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-                            + \" 2. Set current IM to \\\"Japanese\\\" \\n\"\n+                            + \" 2. Set current IM to \\\"Japanese\\\" and IME option to \\\"Full width Katakana\\\" \\n\"\n","filename":"test\/jdk\/javax\/swing\/JTextField\/JapaneseReadingAttributes\/JapaneseReadingAttributes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, -1, false, SignalHandler.SIG_DFL, isWrapper) {\n+        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, false, SignalHandler.SIG_DFL, isWrapper) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                    0, true, SignalHandler.SIG_DFL, in -> in) {\n+                                    true, SignalHandler.SIG_DFL, in -> in) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8304498\n+ * @summary Verify the OSUtils class is initialized properly\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.utils\n+ *\/\n+\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class OSUtilsTest {\n+    public static void main(String... args) throws Exception {\n+        new OSUtilsTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        runTestTest();\n+    }\n+\n+    void runTestTest() throws Exception {\n+        if (OSUtils.IS_WINDOWS) {\n+            return ; \/\/skip on Windows\n+        }\n+\n+        Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-z\", \"\").inheritIO().start();\n+        if (p.waitFor() != 0) {\n+            throw new AssertionError(\"Unexpected result!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/OSUtilsTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -60,1 +60,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, \"-Djava.library.path=\" + lib, \"jdk.jfr.event.sampling.TestNative$Test\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\"-Djava.library.path=\" + lib, \"jdk.jfr.event.sampling.TestNative$Test\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/sampling\/TestNative.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -34,0 +33,1 @@\n+import jdk.test.lib.jfr.VoidFunction;\n@@ -38,1 +38,1 @@\n- * @bug 8148188\n+ * @bug 8148188 8292033\n@@ -42,0 +42,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n@@ -46,1 +47,30 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) throws Throwable {\n+        testCall(() -> {\n+            \/\/ test regular cert construction\n+            TestCertificate.ONE.certificate();\n+            TestCertificate.TWO.certificate();\n+            \/\/ Generate twice to make sure we (now) capture all generate cert events\n+            TestCertificate.ONE.certificate();\n+            TestCertificate.TWO.certificate();\n+        }, 4, true);\n+\n+        testCall(() -> {\n+            \/\/ test generateCertificates method\n+            TestCertificate.certificates();\n+        }, 2, true);\n+\n+        testCall(() -> {\n+            \/\/ test generateCertPath method\n+            TestCertificate.certPath();\n+        }, 4, true);\n+\n+        testCall(() -> {\n+            \/\/ test keytool cert generation with JFR enabled\n+            \/\/ The keytool test will load the dedicated keystore\n+            \/\/ and call CertificateFactory.generateCertificate\n+            \/\/ cacerts\n+            TestCertificate.keyToolTest();\n+        }, -1, false);\n+    }\n+\n+    private static void testCall(VoidFunction f, int expected, boolean runAsserts) throws Throwable {\n@@ -50,8 +80,1 @@\n-\n-            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-            TestCertificate.ONE.generate(cf);\n-            TestCertificate.TWO.generate(cf);\n-            \/\/ Generate twice to make sure only one event per certificate is generated\n-            TestCertificate.ONE.generate(cf);\n-            TestCertificate.TWO.generate(cf);\n-\n+            f.run();\n@@ -59,1 +82,0 @@\n-\n@@ -61,3 +83,7 @@\n-            Asserts.assertEquals(events.size(), 2, \"Incorrect number of X509Certificate events\");\n-            assertEvent(events, TestCertificate.ONE);\n-            assertEvent(events, TestCertificate.TWO);\n+            if (expected >= 0) {\n+                Asserts.assertEquals(events.size(), expected, \"Incorrect number of events\");\n+            }\n+            if (runAsserts) {\n+                assertEvent(events, TestCertificate.ONE);\n+                assertEvent(events, TestCertificate.TWO);\n+            }\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestX509CertificateEvent.java","additions":42,"deletions":16,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @modules jdk.jfr\/jdk.jfr.events\n+ * @modules jdk.jfr\/jdk.jfr.events java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n@@ -53,2 +53,2 @@\n-            \/\/ intermeditate certificate test\n-            TestCertificate.generateChain(false);\n+            \/\/ intermediate certificate test\n+            TestCertificate.generateChain(false, true);\n@@ -65,1 +65,1 @@\n-            TestCertificate.generateChain(true);\n+            TestCertificate.generateChain(true, true);\n@@ -71,0 +71,11 @@\n+\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.X509Validation);\n+            recording.start();\n+            \/\/ intermediate certificate test, with no Cert for trust anchor\n+            TestCertificate.generateChain(true, false);\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            Asserts.assertEquals(events.size(), 2, \"Incorrect number of events\");\n+            assertEvent3(events);\n+        }\n@@ -114,0 +125,22 @@\n+    \/*\n+     * Self signed certificate test\n+     *\/\n+    private static void assertEvent3(List<RecordedEvent> events) throws Exception {\n+        for (RecordedEvent e : events) {\n+            int pos = e.getInt(\"certificatePosition\");\n+            switch (pos) {\n+                \/\/ use public key of cert provided in TrustAnchor\n+                case 1:\n+                    Asserts.assertEquals(e.getLong(\"certificateId\"),\n+                        Long.valueOf(TestCertificate.ROOT_CA.certificate().getPublicKey().hashCode()));\n+                    break;\n+                case 2:\n+                    Events.assertField(e, \"certificateId\")\n+                            .equal(TestCertificate.ROOT_CA.certId);\n+                    break;\n+                default:\n+                    System.out.println(events);\n+                    throw new Exception(\"Unexpected position:\" + pos);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestX509ValidationEvent.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        Process p = ProcessTools.createJavaProcessBuilder(true,\n+        Process p = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestDumpOnCrash.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-            output = ProcessTools.executeProcess(ProcessTools.createJavaProcessBuilder(false,\n+            output = ProcessTools.executeProcess(ProcessTools.createJavaProcessBuilder(\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJfrJavaBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, args);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(args);\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestDumpOnExit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -488,7 +488,6 @@\n-                pb = ProcessTools.createJavaProcessBuilder(true,\n-                                                           \"--add-exports=jdk.jfr\/jdk.jfr.internal=ALL-UNNAMED\",\n-                                                           \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                                           flightRecorderOptions,\n-                                                           \"-XX:StartFlightRecording\",\n-                                                           SUT.class.getName(),\n-                                                           tc.getTestName());\n+                pb = ProcessTools.createTestJvm(\"--add-exports=jdk.jfr\/jdk.jfr.internal=ALL-UNNAMED\",\n+                                                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                                flightRecorderOptions,\n+                                                \"-XX:StartFlightRecording\",\n+                                                SUT.class.getName(),\n+                                                tc.getTestName());\n@@ -497,6 +496,5 @@\n-                pb = ProcessTools.createJavaProcessBuilder(true,\n-                                                           \"--add-exports=jdk.jfr\/jdk.jfr.internal=ALL-UNNAMED\",\n-                                                           \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                                           \"-XX:StartFlightRecording\",\n-                                                           SUT.class.getName(),\n-                                                           tc.getTestName());\n+                pb = ProcessTools.createTestJvm(\"--add-exports=jdk.jfr\/jdk.jfr.internal=ALL-UNNAMED\",\n+                                                \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                                \"-XX:StartFlightRecording\",\n+                                                SUT.class.getName(),\n+                                                tc.getTestName());\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestMemoryOptions.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, recording1, MainClass.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(recording1, MainClass.class.getName());\n@@ -67,1 +67,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, recording1, recording2, MainClass.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(recording1, recording2, MainClass.class.getName());\n@@ -75,1 +75,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, recording1, recording2, recording3, MainClass.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(recording1, recording2, recording3, MainClass.class.getName());\n@@ -99,1 +99,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, flightRecorderOptions, recording1, recording2, MainClass.class.getName());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(flightRecorderOptions, recording1, recording2, MainClass.class.getName());\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestMultipleStartupRecordings.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, args.toArray(new String[0]));\n+        ProcessBuilder pb = ProcessTools.createTestJvm(args);\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestRetransformUsingLog.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -68,1 +68,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartDuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+        ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartName.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main QuickAckTest\n+ * @run main\/othervm QuickAckTest\n","filename":"test\/jdk\/jdk\/net\/Sockets\/QuickAckTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -41,1 +42,0 @@\n-import java.util.Random;\n@@ -48,1 +48,1 @@\n- * @bug 8190753 8011146\n+ * @bug 8190753 8011146 8279536\n@@ -93,1 +93,3 @@\n-        new Random().nextBytes(chunk);\n+        \/\/ fill it with some fixed content (the fixed content will later on help ease\n+        \/\/ the verification of the content written out)\n+        Arrays.fill(chunk, (byte) 42);\n@@ -101,0 +103,1 @@\n+                long start = System.currentTimeMillis();\n@@ -104,0 +107,2 @@\n+                System.out.println(\"Wrote entry \" + entryPath + \" of bytes \" + entry.getValue()\n+                        + \" in \" + (System.currentTimeMillis() - start) + \" milli seconds\");\n@@ -114,0 +119,1 @@\n+                    long start = System.currentTimeMillis();\n@@ -117,5 +123,2 @@\n-                        for (int i = 0, chunkoffset = (int) ((totalRead - numRead) % chunk.length);\n-                             i < numRead; i++, chunkoffset++) {\n-                            Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n-                                    \"Unexpected content in \" + entryPath);\n-                        }\n+                        Assert.assertEquals(Arrays.mismatch(buf, 0, numRead, chunk, 0, numRead), -1,\n+                                \"Unexpected content in \" + entryPath);\n@@ -123,0 +126,2 @@\n+                    System.out.println(\"Read entry \" + entryPath + \" of bytes \" + totalRead\n+                            + \" in \" + (System.currentTimeMillis() - start) + \" milli seconds\");\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSOutputStreamTest.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -34,0 +33,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n@@ -61,3 +61,2 @@\n-            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-            TestCertificate.ONE.generate(cf);\n-            TestCertificate.TWO.generate(cf);\n+            TestCertificate.ONE.certificate();\n+            TestCertificate.TWO.certificate();\n","filename":"test\/jdk\/jdk\/security\/logging\/TestX509CertificateLog.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n@@ -46,0 +47,3 @@\n+        l.addExpected(\"FINE: ValidationChain: \" +\n+                TestCertificate.ROOT_CA.certificate().getPublicKey().hashCode() +\n+                \", \" + TestCertificate.ROOT_CA.certId);\n@@ -51,1 +55,1 @@\n-            TestCertificate.generateChain(false);\n+            TestCertificate.generateChain(false, true);\n@@ -53,1 +57,3 @@\n-            TestCertificate.generateChain(true);\n+            TestCertificate.generateChain(true, true);\n+            \/\/ no cert for trust anchor\n+            TestCertificate.generateChain(true, false);\n","filename":"test\/jdk\/jdk\/security\/logging\/TestX509ValidationLog.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,2 @@\n- * Test web site with *active *TLS Server certificate:\n- * https:\/\/ssltest-a.actalis.it:8443\n- * If doesn't work then use certificate of https:\/\/www.actalis.it\n+ * Test website with *active* TLS Server certificate:\n+ * https:\/\/ssltest-active.actalis.it\/\n@@ -40,2 +39,2 @@\n- * Test web site with *revoked *TLS Server certificate:\n- * https:\/\/ssltest-r.actalis.it:8444\n+ * Test website with *revoked* TLS Server certificate:\n+ * https:\/\/ssltest-revoked.actalis.it\/\n@@ -43,2 +42,2 @@\n- * Test web site with *expired *TLS Server certificate:\n- * https:\/\/ssltest-e.actalis.it:8445\n+ * Test website with *expired* TLS Server certificate:\n+ * https:\/\/ssltest-expired.actalis.it\/\n@@ -48,40 +47,48 @@\n-    \/\/ Owner: CN=Actalis Extended Validation Server CA G1,\n-    \/\/ O=Actalis S.p.A.\/03358520967, L=Milano, ST=Milano, C=IT\n-    \/\/ Issuer: CN=Actalis Authentication Root CA, O=Actalis S.p.A.\/03358520967,\n-    \/\/ L=Milan, C=IT\n-    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIGTDCCBDSgAwIBAgIIMtYr\/GdQGsswDQYJKoZIhvcNAQELBQAwazELMAkGA1UE\\n\"\n-            + \"BhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8w\\n\"\n-            + \"MzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290\\n\"\n-            + \"IENBMB4XDTE1MDUxNDA3MDAzOFoXDTMwMDUxNDA3MDAzOFowgYcxCzAJBgNVBAYT\\n\"\n-            + \"AklUMQ8wDQYDVQQIDAZNaWxhbm8xDzANBgNVBAcMBk1pbGFubzEjMCEGA1UECgwa\\n\"\n-            + \"QWN0YWxpcyBTLnAuQS4vMDMzNTg1MjA5NjcxMTAvBgNVBAMMKEFjdGFsaXMgRXh0\\n\"\n-            + \"ZW5kZWQgVmFsaWRhdGlvbiBTZXJ2ZXIgQ0EgRzEwggEiMA0GCSqGSIb3DQEBAQUA\\n\"\n-            + \"A4IBDwAwggEKAoIBAQD1Ygc1CwmqXqjd3dTEKMLUwGdb\/3+00ytg0uBb4RB+89\/O\\n\"\n-            + \"4K\/STFZcGUjcCq6Job5cmxZBGyRRBYfCEn4vg8onedFztkO0NvD04z4wLFyxjSRT\\n\"\n-            + \"bcMm2d+\/Xci5XLA3Q9wG8TGzHTVQKmdvFpQ7b7EsmOc0uXA7w3UGhLjb2EYpu\/Id\\n\"\n-            + \"uZ1LUTyEOHc3XHXI3a3udkRBDs\/bObTcbte80DPbNetRFB+jHbIw5sH171IeBFGN\\n\"\n-            + \"PB92Iebp01yE8g3X9RqPXrrV7ririEtwFMYp+KgA8BRHxsoNV3xZmhdzJm0AMzC2\\n\"\n-            + \"waLM3H562xPM0UntAYh2pRrAUUtgURRizCT1kr6tAgMBAAGjggHVMIIB0TBBBggr\\n\"\n-            + \"BgEFBQcBAQQ1MDMwMQYIKwYBBQUHMAGGJWh0dHA6Ly9vY3NwMDUuYWN0YWxpcy5p\\n\"\n-            + \"dC9WQS9BVVRILVJPT1QwHQYDVR0OBBYEFGHB5IYeTW10dLzZlzsxcXjLP5\/cMA8G\\n\"\n-            + \"A1UdEwEB\/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbtifN7OHCUyQICNtAw\\n\"\n-            + \"RQYDVR0gBD4wPDA6BgRVHSAAMDIwMAYIKwYBBQUHAgEWJGh0dHBzOi8vd3d3LmFj\\n\"\n-            + \"dGFsaXMuaXQvYXJlYS1kb3dubG9hZDCB4wYDVR0fBIHbMIHYMIGWoIGToIGQhoGN\\n\"\n-            + \"bGRhcDovL2xkYXAwNS5hY3RhbGlzLml0L2NuJTNkQWN0YWxpcyUyMEF1dGhlbnRp\\n\"\n-            + \"Y2F0aW9uJTIwUm9vdCUyMENBLG8lM2RBY3RhbGlzJTIwUy5wLkEuJTJmMDMzNTg1\\n\"\n-            + \"MjA5NjcsYyUzZElUP2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q7YmluYXJ5MD2g\\n\"\n-            + \"O6A5hjdodHRwOi8vY3JsMDUuYWN0YWxpcy5pdC9SZXBvc2l0b3J5L0FVVEgtUk9P\\n\"\n-            + \"VC9nZXRMYXN0Q1JMMA4GA1UdDwEB\/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEA\\n\"\n-            + \"OD8D2Z2fw76+GIu+mDEgygH\/y7F9K4I6rZOc3LqGBecO3C0fGcIuuG7APtxGGk7Y\\n\"\n-            + \"nk97Qt+3pDoek9EP65\/1u128pRncZcjEAeMgKb7UuJxwoR6Sj5zhOadotKcCQqmF\\n\"\n-            + \"Si99ExNo6dTq5Eyp1KrqepLmezbO9owx4Q44mtNpfKLMgzDqOn\/dwNMo\/pGYbMfP\\n\"\n-            + \"DjhxEnta1HXgcEcgCk1Au16xkdzapwY4sXpKuwB24phfWF+cveKAQ0Rncmvrm34i\\n\"\n-            + \"9B6leZUkSHDe4mRkbO5nObhKHYRmVSr0Q\/wvGCmTgGTKuw\/Gj8+RFb5MEkOKEcJn\\n\"\n-            + \"I32CPohpiW\/jlpeLaFBIgJnXuZTxmfTX55sqtXDlKxRxFwq1W3kML4UfGZsgjx1l\\n\"\n-            + \"hX5fQ1QlEZeO9CyPpgGO5Py2KXXKhUxCtF7tawAYimWwslxvPCjHDND\/WhM1Fz9e\\n\"\n-            + \"2yqwHcSQAOUVv5mk9uYc6\/NSLwLb5in3R728GNEpHHhbx5QZhtdqR8mb56uJUDKI\\n\"\n-            + \"AwnnZckcR+SLGL2Agx7hY7YCMOQhSsO6PA81M\/mGW2hGCiZw3GULJe9ejL\/vdS0I\\n\"\n-            + \"PWrp7YLnXUa6mtXVSBKGrVrlbpJaN10+fB4Yrlk4O2sF4WNUAHMBn9T+zOXaBAhj\\n\"\n-            + \"vNlMU7+elLkTcKIB7qJJuSZChxzoevM2ciO3BpGuRxg=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Owner: CN=Actalis Organization Validated Server CA G3, O=Actalis S.p.A.,\n+    \/\/        L=Ponte San Pietro, ST=Bergamo, C=IT\n+    \/\/ Issuer: CN=Actalis Authentication Root CA, O=Actalis S.p.A .\/03358520967,\n+    \/\/         L=Milan, C=IT\n+    \/\/ Serial number: 5c3b3f37adfc28fe0fcfd3abf83f8551\n+    \/\/ Valid from: Mon Jul 06 00:20:55 PDT 2020 until: Sun Sep 22 04:22:02 PDT 2030\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIHdTCCBV2gAwIBAgIQXDs\/N638KP4Pz9Or+D+FUTANBgkqhkiG9w0BAQsFADBr\\n\" +\n+            \"MQswCQYDVQQGEwJJVDEOMAwGA1UEBwwFTWlsYW4xIzAhBgNVBAoMGkFjdGFsaXMg\\n\" +\n+            \"Uy5wLkEuLzAzMzU4NTIwOTY3MScwJQYDVQQDDB5BY3RhbGlzIEF1dGhlbnRpY2F0\\n\" +\n+            \"aW9uIFJvb3QgQ0EwHhcNMjAwNzA2MDcyMDU1WhcNMzAwOTIyMTEyMjAyWjCBiTEL\\n\" +\n+            \"MAkGA1UEBhMCSVQxEDAOBgNVBAgMB0JlcmdhbW8xGTAXBgNVBAcMEFBvbnRlIFNh\\n\" +\n+            \"biBQaWV0cm8xFzAVBgNVBAoMDkFjdGFsaXMgUy5wLkEuMTQwMgYDVQQDDCtBY3Rh\\n\" +\n+            \"bGlzIE9yZ2FuaXphdGlvbiBWYWxpZGF0ZWQgU2VydmVyIENBIEczMIICIjANBgkq\\n\" +\n+            \"hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAs73Ch+t2owm3ayTkyqy0OPuCTiybxTyS\\n\" +\n+            \"4cU4y0t2RGSwCNjLh\/rcutO0yoriZxVtPrNMcIRQ544BQhHFt\/ypW7e+t8wWKrHa\\n\" +\n+            \"r3BkKwSUbqNwpDWP1bXs7IJTVhHXWGAm7Ak1FhrrBmtXk8QtdzTzDDuxfFBK7sCL\\n\" +\n+            \"N0Jdqoqb1V1z3wsWqAvr4KlSCFW05Nh4baWm\/kXOmb8U+XR6kUmuoVvia3iBhotR\\n\" +\n+            \"TzAHTO9SWWkgjTcir\/nhBvyL2RoqkgYyP\/k50bznaVOGFnFWzfl0XnrM\/salfCBh\\n\" +\n+            \"O0\/1vNaoU8elR6AtbdCFAupgQy95GuFIRVS8n\/cF0QupfPjUl+kGSLzvGAc+6oNE\\n\" +\n+            \"alpAhKIS\/+P0uODzRrS9Eq0WX1iSj6KHtQMNN4ZKsS4nsuvYCahnAc0QwQyoduAW\\n\" +\n+            \"iU\/ynhU9WTIEe1VIoEDE79NPOI2\/80RqbZqdpAKUaf0FvuqVXhEcjiJJu+d0w9YN\\n\" +\n+            \"b7gurd6xkaSXemW\/fP4idBiNkd8aCVAdshGQYn6yh+na0Lu5IG88Z2kSIFcXDtwy\\n\" +\n+            \"zjcxkW86pwkO6GekEomVBNKcv0Cey2Smf8uhpZk15TSCeyFDrZBWH9OsDst\/Tnhz\\n\" +\n+            \"pN156Huw3M3RRdEegt33fcyPykgt0HThxrEv9DwOzhs6lCQ5RNQJO7ZvZF1ZiqgT\\n\" +\n+            \"FOJ6vs1xMqECAwEAAaOCAfQwggHwMA8GA1UdEwEB\/wQFMAMBAf8wHwYDVR0jBBgw\\n\" +\n+            \"FoAUUtiIOsifeGbtifN7OHCUyQICNtAwQQYIKwYBBQUHAQEENTAzMDEGCCsGAQUF\\n\" +\n+            \"BzABhiVodHRwOi8vb2NzcDA1LmFjdGFsaXMuaXQvVkEvQVVUSC1ST09UMEUGA1Ud\\n\" +\n+            \"IAQ+MDwwOgYEVR0gADAyMDAGCCsGAQUFBwIBFiRodHRwczovL3d3dy5hY3RhbGlz\\n\" +\n+            \"Lml0L2FyZWEtZG93bmxvYWQwHQYDVR0lBBYwFAYIKwYBBQUHAwIGCCsGAQUFBwMB\\n\" +\n+            \"MIHjBgNVHR8EgdswgdgwgZaggZOggZCGgY1sZGFwOi8vbGRhcDA1LmFjdGFsaXMu\\n\" +\n+            \"aXQvY24lM2RBY3RhbGlzJTIwQXV0aGVudGljYXRpb24lMjBSb290JTIwQ0EsbyUz\\n\" +\n+            \"ZEFjdGFsaXMlMjBTLnAuQS4lMmYwMzM1ODUyMDk2NyxjJTNkSVQ\/Y2VydGlmaWNh\\n\" +\n+            \"dGVSZXZvY2F0aW9uTGlzdDtiaW5hcnkwPaA7oDmGN2h0dHA6Ly9jcmwwNS5hY3Rh\\n\" +\n+            \"bGlzLml0L1JlcG9zaXRvcnkvQVVUSC1ST09UL2dldExhc3RDUkwwHQYDVR0OBBYE\\n\" +\n+            \"FJ+KsbXxsd6C9Cd8vojN3qlDgaNLMA4GA1UdDwEB\/wQEAwIBBjANBgkqhkiG9w0B\\n\" +\n+            \"AQsFAAOCAgEAJbygMnKJ5M6byr5Ectq05ODqwNMtky8TEF3O55g6RHhxblf6OegZ\\n\" +\n+            \"4ui4+ElHNOIXjycbeuUGuFA4LScCC9fnI1Rnn8TI2Q7OP5YWifEfnrdp99t\/tJzQ\\n\" +\n+            \"hfdi7ZTdRRZZGV9x+grfR\/RtjT2C3Lt9X4lcbuSxTea3PHAwwi0A3bYRR1L5ciPm\\n\" +\n+            \"eAnYtG9kpat8\/RuC22oxiZZ5FdjU6wrRWkASRLiIwNcFIYfvpUbMWElaCUhqaB2y\\n\" +\n+            \"YvWF8o02pnaYb4bvTCg4cVabVnojUuuXH81LeQhhsSXLwcdwSdew0NL4zCiNCn2Q\\n\" +\n+            \"iDZpz2biCWDggibmWxsUUF6AbqMHnwsdS8vsKXiFQJHeAdNAhA+kwpqYAdhUiCdj\\n\" +\n+            \"RTUdtRNUucLvZEN1OAvVYyog9xYCfhtkqgXQROMANP+Z\/+yaZahaP\/Vgak\/V00se\\n\" +\n+            \"Hdh7F+B6h5HVdwdh+17E2jl+aMTfyvBFcg2H\/9Qjyl4TY8NW\/6v0DPK52sVt8a35\\n\" +\n+            \"I+7xLGLPohAl4z6pEf2OxgjMNfXXCXS33smRgz1dLQFo8UpAb3rf84zkXaqEI6Qi\\n\" +\n+            \"2P+5pibVFQigRbn4RcE+K2a\/nm2M\/o+WZTSio+E+YXacnNk71VcO82biOof+jBKT\\n\" +\n+            \"iC3Xi7rAlypmme+QFBw9F1J89ig3smV\/HaN8tO0lfTpvm7Zvzd5TkMs=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -89,51 +96,50 @@\n-    \/\/ Owner: OID.1.3.6.1.4.1.311.60.2.1.3=IT, STREET=Via S. Clemente 53,\n-    \/\/ OID.2.5.4.15=Private Organization, CN=www.actalis.it,\n-    \/\/ SERIALNUMBER=03358520967, O=Actalis S.p.A., L=Ponte San Pietro, ST=Bergamo, C=IT\n-    \/\/ Issuer: CN=Actalis Extended Validation Server CA G1,\n-    \/\/ O=Actalis S.p.A.\/03358520967, L=Milano, ST=Milano, C=IT\n-    \/\/ Serial number: eeeee6d6463bde2\n-    \/\/ Valid from: Sat Jun 17 05:59:17 PDT 2017 until: Mon Jun 17 05:59:17 PDT 2019\n-    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIHwTCCBqmgAwIBAgIIDu7ubWRjveIwDQYJKoZIhvcNAQELBQAwgYcxCzAJBgNV\\n\"\n-            + \"BAYTAklUMQ8wDQYDVQQIDAZNaWxhbm8xDzANBgNVBAcMBk1pbGFubzEjMCEGA1UE\\n\"\n-            + \"CgwaQWN0YWxpcyBTLnAuQS4vMDMzNTg1MjA5NjcxMTAvBgNVBAMMKEFjdGFsaXMg\\n\"\n-            + \"RXh0ZW5kZWQgVmFsaWRhdGlvbiBTZXJ2ZXIgQ0EgRzEwHhcNMTcwNjE3MTI1OTE3\\n\"\n-            + \"WhcNMTkwNjE3MTI1OTE3WjCB0zELMAkGA1UEBhMCSVQxEDAOBgNVBAgMB0Jlcmdh\\n\"\n-            + \"bW8xGTAXBgNVBAcMEFBvbnRlIFNhbiBQaWV0cm8xFzAVBgNVBAoMDkFjdGFsaXMg\\n\"\n-            + \"Uy5wLkEuMRQwEgYDVQQFEwswMzM1ODUyMDk2NzEXMBUGA1UEAwwOd3d3LmFjdGFs\\n\"\n-            + \"aXMuaXQxHTAbBgNVBA8MFFByaXZhdGUgT3JnYW5pemF0aW9uMRswGQYDVQQJDBJW\\n\"\n-            + \"aWEgUy4gQ2xlbWVudGUgNTMxEzARBgsrBgEEAYI3PAIBAxMCSVQwggEiMA0GCSqG\\n\"\n-            + \"SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCwZ3++4pQYGfhXSqin1CKRJ6SOqkTcX3O0\\n\"\n-            + \"6b4jZbSNomyqyn6aHOz6ztOlj++fPzxmIzErEySOTd3G0pr+iwpYQVdeg1Y27KL8\\n\"\n-            + \"OiwwUrlV4ZMa8KKXr4BnWlDbFIo+eIcSew5V7CiodDyxpj9zjqJK497LF1jxgXtr\\n\"\n-            + \"IoMRwrh2Y0NbJCZGUCL30sQr\/W4xBnO1+pi2DbCieGe\/XoK8yEtx9FdnEFvyT9qn\\n\"\n-            + \"zYyrXvnTvfVSwzwtEIn+akjomI4WfCFLBF0M7v4dAHypfnPAAoW1c0BBqNB32zf0\\n\"\n-            + \"rYwNnD7UwZlcDihEYlgC70Dfy7bPsdq2spmOMk\/VUqb3U0LHRVM3AgMBAAGjggPh\\n\"\n-            + \"MIID3TB9BggrBgEFBQcBAQRxMG8wOgYIKwYBBQUHMAKGLmh0dHA6Ly9jYWNlcnQu\\n\"\n-            + \"YWN0YWxpcy5pdC9jZXJ0cy9hY3RhbGlzLWF1dGV2ZzEwMQYIKwYBBQUHMAGGJWh0\\n\"\n-            + \"dHA6Ly9vY3NwMDUuYWN0YWxpcy5pdC9WQS9BVVRIRVYtRzEwHQYDVR0OBBYEFK9y\\n\"\n-            + \"954QoY\/5XV6TayD1gWVy0gQOMAwGA1UdEwEB\/wQCMAAwHwYDVR0jBBgwFoAUYcHk\\n\"\n-            + \"hh5NbXR0vNmXOzFxeMs\/n9wwUAYDVR0gBEkwRzA8BgYrgR8BEQEwMjAwBggrBgEF\\n\"\n-            + \"BQcCARYkaHR0cHM6Ly93d3cuYWN0YWxpcy5pdC9hcmVhLWRvd25sb2FkMAcGBWeB\\n\"\n-            + \"DAEBMIHvBgNVHR8EgecwgeQwgaKggZ+ggZyGgZlsZGFwOi8vbGRhcDA1LmFjdGFs\\n\"\n-            + \"aXMuaXQvY24lM2RBY3RhbGlzJTIwRXh0ZW5kZWQlMjBWYWxpZGF0aW9uJTIwU2Vy\\n\"\n-            + \"dmVyJTIwQ0ElMjBHMSxvJTNkQWN0YWxpcyUyMFMucC5BLi8wMzM1ODUyMDk2Nyxj\\n\"\n-            + \"JTNkSVQ\/Y2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdDtiaW5hcnkwPaA7oDmGN2h0\\n\"\n-            + \"dHA6Ly9jcmwwNS5hY3RhbGlzLml0L1JlcG9zaXRvcnkvQVVUSEVWLUcxL2dldExh\\n\"\n-            + \"c3RDUkwwDgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEF\\n\"\n-            + \"BQcDAjAZBgNVHREEEjAQgg53d3cuYWN0YWxpcy5pdDCCAX4GCisGAQQB1nkCBAIE\\n\"\n-            + \"ggFuBIIBagFoAHYApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFc\\n\"\n-            + \"tiwHywAABAMARzBFAiEA7GC5\/kja3l8cBw1\/wBpHl\/AKH6eL1MKpmICtf5G09c4C\\n\"\n-            + \"IBM887DQEwD2E4Xx\/IP+33NMvUOhSwZ4XODgqFVXsz0wAHYA7ku9t3XOYLrhQmkf\\n\"\n-            + \"q+GeZqMPfl+wctiDAMR7iXqo\/csAAAFctiwIqwAABAMARzBFAiEAwwiR95ozXdKs\\n\"\n-            + \"+uULfrzgENbHc2rLgGIac6ZMv0xHDLACIFLQVpvQBRQfys2KVRGHQKGxqAeghQZw\\n\"\n-            + \"9nJL+U5huzfaAHYA3esdK3oNT6Ygi4GtgWhwfi6OnQHVXIiNPRHEzbbsvswAAAFc\\n\"\n-            + \"tiwMqwAABAMARzBFAiEAifV9ocxbO6b3I22jb2zxBvG2e83hXHitOhYXkHdSmZkC\\n\"\n-            + \"IDJLuPvGOczF9axgphImlUbT9dX3wRpjEi5IeV+pxMiYMA0GCSqGSIb3DQEBCwUA\\n\"\n-            + \"A4IBAQB5U6k1Onv9Y7POHGnUOI0ATHevbpbS\/7r68DZQ6cRmDIpsZyjW6PxYs9nc\\n\"\n-            + \"3ob3Pjomm+S7StDl9ehI7rYLlZC52QlXlsq1fzEQ9xSkf+VSD70A91dPIFAdI\/jQ\\n\"\n-            + \"aWvIUvQEbhfUZc0ihIple0VyWGH5bza0DLW+C8ttF8KqICUfL8S8mZgjbXvVg2fY\\n\"\n-            + \"HLW9lWR\/Pkco2yRc8gZyr9FGkXOcmJ8aFaCuJnGm\/IVRCieYp60If4DoAKz49xpF\\n\"\n-            + \"CF6RjOAJ\/\/UGSp\/ySjHMmT8PLO7NvhsT4XDDGTSeIYYpO++tbEIcLcjW9m2k5Gnh\\n\"\n-            + \"kmEenr0hdcpeLgsP3Fsy7JxyQNpL\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Owner: CN=ssltest-active.actalis.it, O=Actalis S.p.A., L=Ponte San Pietro,\n+    \/\/        ST=Bergamo, C=IT\n+    \/\/ Issuer: CN=Actalis Organization Validated Server CA G3, O=Actalis S.p A.,\n+    \/\/         L=Ponte San Pietro, ST=Bergamo, C=IT\n+    \/\/ Serial number: 4a49e2afcd448af3b7f5f14e1cd5954\n+    \/\/ Valid from: Tue Mar 08 08:00:57 PST 2022 until: Wed Mar 08 08:00:57 PST 2023\n+    private static final String VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIH0jCCBbqgAwIBAgIQBKSeKvzUSK87f18U4c1ZVDANBgkqhkiG9w0BAQsFADCB\\n\" +\n+            \"iTELMAkGA1UEBhMCSVQxEDAOBgNVBAgMB0JlcmdhbW8xGTAXBgNVBAcMEFBvbnRl\\n\" +\n+            \"IFNhbiBQaWV0cm8xFzAVBgNVBAoMDkFjdGFsaXMgUy5wLkEuMTQwMgYDVQQDDCtB\\n\" +\n+            \"Y3RhbGlzIE9yZ2FuaXphdGlvbiBWYWxpZGF0ZWQgU2VydmVyIENBIEczMB4XDTIy\\n\" +\n+            \"MDMwODE2MDA1N1oXDTIzMDMwODE2MDA1N1owdzELMAkGA1UEBhMCSVQxEDAOBgNV\\n\" +\n+            \"BAgMB0JlcmdhbW8xGTAXBgNVBAcMEFBvbnRlIFNhbiBQaWV0cm8xFzAVBgNVBAoM\\n\" +\n+            \"DkFjdGFsaXMgUy5wLkEuMSIwIAYDVQQDDBlzc2x0ZXN0LWFjdGl2ZS5hY3RhbGlz\\n\" +\n+            \"Lml0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsJnlOatNNth7gfqZ\\n\" +\n+            \"WN8HMfp9qlkDf\/YW8ReNXyTtqFEy2xZrVVmAV2XIqL1lJDYJz86mdVsz3AqIMTzo\\n\" +\n+            \"GxPlmn\/oEnF0YeRYQ1coKRdwP7hWSwqyMMhh+C7r5zMA9gQQVXV5wWR5U+bgvt23\\n\" +\n+            \"Y\/55DOqk3Fp5Odt6Lyu6xA45MwHrj2Gr\/nMKe8L7f8UYPWT98MJa1+TXB24yllOw\\n\" +\n+            \"rZE8gZByLBCVzDkVwRwTgu+HgY6zm5sJTvBT4tyJy4QD8u2xLWoZ5sXodrU0Z3Nf\\n\" +\n+            \"xU9keMFp6CIh1t+akqFgpW81b\/HWkfUO0+L6PH4hgaSPtiwp2dVFsF9v5p4on9qA\\n\" +\n+            \"2j1d9QIDAQABo4IDRTCCA0EwDAYDVR0TAQH\/BAIwADAfBgNVHSMEGDAWgBSfirG1\\n\" +\n+            \"8bHegvQnfL6Izd6pQ4GjSzB+BggrBgEFBQcBAQRyMHAwOwYIKwYBBQUHMAKGL2h0\\n\" +\n+            \"dHA6Ly9jYWNlcnQuYWN0YWxpcy5pdC9jZXJ0cy9hY3RhbGlzLWF1dGhvdmczMDEG\\n\" +\n+            \"CCsGAQUFBzABhiVodHRwOi8vb2NzcDA5LmFjdGFsaXMuaXQvVkEvQVVUSE9WLUcz\\n\" +\n+            \"MCQGA1UdEQQdMBuCGXNzbHRlc3QtYWN0aXZlLmFjdGFsaXMuaXQwUQYDVR0gBEow\\n\" +\n+            \"SDA8BgYrgR8BFAEwMjAwBggrBgEFBQcCARYkaHR0cHM6Ly93d3cuYWN0YWxpcy5p\\n\" +\n+            \"dC9hcmVhLWRvd25sb2FkMAgGBmeBDAECAjAdBgNVHSUEFjAUBggrBgEFBQcDAgYI\\n\" +\n+            \"KwYBBQUHAwEwSAYDVR0fBEEwPzA9oDugOYY3aHR0cDovL2NybDA5LmFjdGFsaXMu\\n\" +\n+            \"aXQvUmVwb3NpdG9yeS9BVVRIT1YtRzMvZ2V0TGFzdENSTDAdBgNVHQ4EFgQUIbcm\\n\" +\n+            \"54DVM6gC8DYhvnZg8ILaLrAwDgYDVR0PAQH\/BAQDAgWgMIIBfQYKKwYBBAHWeQIE\\n\" +\n+            \"AgSCAW0EggFpAWcAdQCt9776fP8QyIudPZwePhhqtGcpXc+xDCTKhYY069yCigAA\\n\" +\n+            \"AX9qTFEkAAAEAwBGMEQCIFB4RW+Fca\/jj96sFg9JtZVe\/CAQq74HAezTi2AD07qL\\n\" +\n+            \"AiBej8APns5uKmaHNYbU6lel6kdowIaUY\/+iqX82e2KhrAB2AOg+0No+9QY1MudX\\n\" +\n+            \"KLyJa8kD08vREWvs62nhd31tBr1uAAABf2pMUVMAAAQDAEcwRQIgcopYpSUDiQ2C\\n\" +\n+            \"7j06vgbfsn3ux4REvpbrbWatifLtfVMCIQCi96i+4EhAUOw4dumA7hJwlG+qD\/+5\\n\" +\n+            \"uSL3aKB9KR7apAB2AG9Tdqwx8DEZ2JkApFEV\/3cVHBHZAsEAKQaNsgiaN9kTAAAB\\n\" +\n+            \"f2pMUYEAAAQDAEcwRQIgdCNjaV7nQcCiVefX28u1vtQMy+rqT4F4i9EVJ2xbqbQC\\n\" +\n+            \"IQCrpcYqt53tX\/rSMoGnjFhDGnMhnYyc2AqzpokfhmdcVTANBgkqhkiG9w0BAQsF\\n\" +\n+            \"AAOCAgEAfXISBKP1dZQv1kkWZVDXiVY\/fv+068DKq2e8hgBcsN6b9a2rlVfBU2iq\\n\" +\n+            \"W9KqFNET5GDWf1wjM71Itjau8b1A3+apcNdEGQk3eqIOymK5kVtVvAI2ahp4926x\\n\" +\n+            \"Kkt\/sexmi1pJGA+eLfTixkCoaESh5P8U7HDW\/vUFXm2AtLQih+oT5OVoYt5e9pXr\\n\" +\n+            \"hr8oadm\/ZDJxiyDL1vcTIsl2TM4\/Fpo2IWxYzUC+YshnuLiRwWI840maJmWFx\/lJ\\n\" +\n+            \"Pzdik3P51Uef7VsCSBhTxER09\/B4IrEUMDAhVgG5QNbcFSHvnmpV8JLrNuBKUROU\\n\" +\n+            \"xnDsWieKlb5YO6S6PjGOncOrd+k4RCIYRaekSnx52WBKkpqxMEv\/rjY1Glx4Cota\\n\" +\n+            \"mpNiYDvZHGzrRQtY2eH17XhFatBxEEbJMA+0QPbFksHcKxAxJgMDncqag4TDq5fT\\n\" +\n+            \"I2NUxqiB51F5w0x+++lyLnUZ+z4BJFZ73VdtfoJ2fsuRhemOoZjHPi\/V2exXpAfb\\n\" +\n+            \"pomha3KCrTcuFv1lj8mPx5L4ciNPxuDFgjeXEaTGjS8IvdNoJIrgdHdahMwkwS\/y\\n\" +\n+            \"wei7FJ1Ey0maqRUpUlAY6sIQPQ\/KDltTuKX\/C94C5pYLI0JXCScr5xg6C+r2ckbA\\n\" +\n+            \"rjhpn3C\/NptVyZgT8bL4XT5ITrAjwPciBj0yxYzUkrLZO1wKQSQ=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -141,79 +147,49 @@\n-    \/\/ Owner:  CN=Actalis Authentication CA G3, O=Actalis S.p.A.\/03358520967, L=Milano, ST=Milano, C=IT\n-    \/\/ Issuer: CN=Actalis Authentication Root CA, O=Actalis S.p.A.\/03358520967, L=Milan, C=IT\n-    \/\/ SN:     741d584a 72fc06bc\n-    \/\/ Valid from: Wed Feb 12 22:32:23 PST 2014\n-    \/\/ Valid till: Mon Feb 12 22:32:23 PST 2024\n-    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIGTTCCBDWgAwIBAgIIdB1YSnL8BrwwDQYJKoZIhvcNAQELBQAwazELMAkGA1UE\\n\"\n-            + \"BhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8w\\n\"\n-            + \"MzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290\\n\"\n-            + \"IENBMB4XDTE0MDIxMzE1MDIyM1oXDTI0MDIxMzE1MDIyM1owezELMAkGA1UEBhMC\\n\"\n-            + \"SVQxDzANBgNVBAgMBk1pbGFubzEPMA0GA1UEBwwGTWlsYW5vMSMwIQYDVQQKDBpB\\n\"\n-            + \"Y3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzElMCMGA1UEAwwcQWN0YWxpcyBBdXRo\\n\"\n-            + \"ZW50aWNhdGlvbiBDQSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\\n\"\n-            + \"AMzhDjmhNDym6ze3PegbIKmiavXpAjgVCZ344k1DOtdSCV6k3h3rqfHqFn3mrayA\\n\"\n-            + \"btmJ0NeC886WxUUsJwHJ3bOnNBQZIHxLV+1RVD\/6TQqb6\/bPJu4rDwEfhbJSmErc\\n\"\n-            + \"29wUJWqxXMhSAWTHi3Pq0vrkx59e5KTEyfB2kHo6InlR72sCCRdtCL9aDuDm8nYK\\n\"\n-            + \"pTSAJr36ultwME5NyCNSyN2JIK0wYbEi7MVNbp5KN9MusTp3cOMDoVBreYulmnEu\\n\"\n-            + \"TNazmoAv0K8oLS7iX7c9x+zGjUUAucFEuSlRn3sL6hFAiKjy4PDClvnyqQHBBdZr\\n\"\n-            + \"\/3JOxAcgXv7aZ4\/STeXeDXsCAwEAAaOCAeMwggHfMEEGCCsGAQUFBwEBBDUwMzAx\\n\"\n-            + \"BggrBgEFBQcwAYYlaHR0cDovL3BvcnRhbC5hY3RhbGlzLml0L1ZBL0FVVEgtUk9P\\n\"\n-            + \"VDAdBgNVHQ4EFgQUqqr9yowdTfEug+EG\/PqO6g4jrj0wDwYDVR0TAQH\/BAUwAwEB\\n\"\n-            + \"\/zAfBgNVHSMEGDAWgBRS2Ig6yJ94Zu2J83s4cJTJAgI20DBUBgNVHSAETTBLMEkG\\n\"\n-            + \"BFUdIAAwQTA\/BggrBgEFBQcCARYzaHR0cHM6Ly9wb3J0YWwuYWN0YWxpcy5pdC9S\\n\"\n-            + \"ZXBvc2l0b3J5L1BvbGljeS9TU0wvQ1BTMIHiBgNVHR8EgdowgdcwgZSggZGggY6G\\n\"\n-            + \"gYtsZGFwOi8vbGRhcC5hY3RhbGlzLml0L2NuJTNkQWN0YWxpcyUyMEF1dGhlbnRp\\n\"\n-            + \"Y2F0aW9uJTIwUm9vdCUyMENBLG8lM2RBY3RhbGlzJTIwUy5wLkEuJTJmMDMzNTg1\\n\"\n-            + \"MjA5NjcsYyUzZElUP2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q7YmluYXJ5MD6g\\n\"\n-            + \"PKA6hjhodHRwOi8vcG9ydGFsLmFjdGFsaXMuaXQvUmVwb3NpdG9yeS9BVVRILVJP\\n\"\n-            + \"T1QvZ2V0TGFzdENSTDAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQELBQADggIB\\n\"\n-            + \"ABP93l+9QBgzHF0Clf3gMAelGqwXT25DwZVFIkBw6YyqOPcaqzw1XKHJJEMQ8xOp\\n\"\n-            + \"8uuiPLP\/ObxEXBBvH7ofNW7nRUIzGsuLPhzdfJhdzilCVAvz4WRsX44nWOQS4Qu0\\n\"\n-            + \"npo7dbq\/KxFUCUO9yNEJp6YxNloy8XFIlazkHFTKGJqoUpsGoc7B9YmPchhE2FPb\\n\"\n-            + \"OZiOCg4Y2Qp43UJfnENgZ3gJFh16juQE1uS8Q\/JJI7ZzJfJ\/W0uQoDnCprOPUpLF\\n\"\n-            + \"G03e0asFxwQqhL84Jvf7rJZaWvwydHP4hH47nzpHWEGXwfJLXXoO7LHgqVB7K9Ar\\n\"\n-            + \"Zf3pY0S\/3Fs+AN\/PrEY3Z3rb7ypQLRiot1oJLl8matiGEF4aFL5DDkr9wfRAZ8S8\\n\"\n-            + \"WT69vN68ENGgEwyeZSlQxn+4g6quHRav0fmF2fGnLaq7tteSPVocT7XaMEpkHqNs\\n\"\n-            + \"x1q\/PJbr39s\/1QVZtS9CrdoCr0QAnBaX\/\/PPB6ansSLFcvEqM9QcV9xQZex88ToX\\n\"\n-            + \"nk3TcHtA0ezWJlCkg626MhdQZrhHbkauHfIGSOmCkn3zHp0BZQ6Vo7UOdRMT7QS7\\n\"\n-            + \"y7AkET9Qmapwh2CFUdCJSXklVRd+06XhhOB37NQU0pGJQJ3xjEPrILZ8kLhW3Tyq\\n\"\n-            + \"Iv30LW7MXZ4yQn\/JHEZbuiOOb4R45hsPZxe6gOq\/e+sf\\n\"\n-            + \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Owner:  CN=ssltest-r.actalis.it, O=Actalis S.p.A., L=Ponte San Pietro, ST=Bergamo, C=IT\n-    \/\/ Issuer: CN=Actalis Authentication CA G3, O=Actalis S.p.A.\/03358520967, L=Milano, ST=Milano, C=IT\n-    \/\/ SN:     0455de97 5c71c96f\n-    \/\/ Valid from: Thu Jan 28 16:23:52 PST 2016\n-    \/\/ Valid till: Mon Jan 28 16:23:52 PST 2019\n-    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIFmDCCBICgAwIBAgIIBFXel1xxyW8wDQYJKoZIhvcNAQELBQAwezELMAkGA1UE\\n\"\n-            + \"BhMCSVQxDzANBgNVBAgMBk1pbGFubzEPMA0GA1UEBwwGTWlsYW5vMSMwIQYDVQQK\\n\"\n-            + \"DBpBY3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzElMCMGA1UEAwwcQWN0YWxpcyBB\\n\"\n-            + \"dXRoZW50aWNhdGlvbiBDQSBHMzAeFw0xNjAxMjkwODUzNTJaFw0xOTAxMjkwODUz\\n\"\n-            + \"NTJaMHIxCzAJBgNVBAYTAklUMRAwDgYDVQQIDAdCZXJnYW1vMRkwFwYDVQQHDBBQ\\n\"\n-            + \"b250ZSBTYW4gUGlldHJvMRcwFQYDVQQKDA5BY3RhbGlzIFMucC5BLjEdMBsGA1UE\\n\"\n-            + \"AwwUc3NsdGVzdC1yLmFjdGFsaXMuaXQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\\n\"\n-            + \"ggEKAoIBAQClbzoXCvD21FD7Oy\/TKZu4fmDFJrISrNfasLlC3krLHkgb1vg23Z1P\\n\"\n-            + \"+7rIymDgrJSzjvYmisl+VM7xXxTsyI2pp9Qp\/uzTMAMML9ISd\/s0LaMBiNN5iPyj\\n\"\n-            + \"W91gGzGe30Jc319afKwFBaveSv7NO3DWsmHw9koezWkKUug2dnQCVXk1uTSdobnq\\n\"\n-            + \"wOgwxdd86LpZnFLxBIYdU68S4vogAQZjdja\/S1+tF6JnfvY6o\/xRJmQckVtNmUs6\\n\"\n-            + \"Dj3KoN2o\/8BEgSCYcJz8tfoZcVazVkWOp\/u6moUnm1\/IKSYNgtHnB1ub0fB2AttW\\n\"\n-            + \"Vi7cs3SG\/tDMMP8yc1kWScWf8CYj\/AI1AgMBAAGjggInMIICIzA\/BggrBgEFBQcB\\n\"\n-            + \"AQQzMDEwLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwMDMuYWN0YWxpcy5pdC9WQS9B\\n\"\n-            + \"VVRILUczMB0GA1UdDgQWBBRIKN5WmrjivlnT1rDzsH1WZ+PuvTAMBgNVHRMBAf8E\\n\"\n-            + \"AjAAMB8GA1UdIwQYMBaAFKqq\/cqMHU3xLoPhBvz6juoOI649MGAGA1UdIARZMFcw\\n\"\n-            + \"SwYGK4EfARQBMEEwPwYIKwYBBQUHAgEWM2h0dHBzOi8vcG9ydGFsLmFjdGFsaXMu\\n\"\n-            + \"aXQvUmVwb3NpdG9yeS9Qb2xpY3kvU1NML0NQUzAIBgZngQwBAgIwgd8GA1UdHwSB\\n\"\n-            + \"1zCB1DCBlKCBkaCBjoaBi2xkYXA6Ly9sZGFwMDMuYWN0YWxpcy5pdC9jbiUzZEFj\\n\"\n-            + \"dGFsaXMlMjBBdXRoZW50aWNhdGlvbiUyMENBJTIwRzMsbyUzZEFjdGFsaXMlMjBT\\n\"\n-            + \"LnAuQS4lMmYwMzM1ODUyMDk2NyxjJTNkSVQ\/Y2VydGlmaWNhdGVSZXZvY2F0aW9u\\n\"\n-            + \"TGlzdDtiaW5hcnkwO6A5oDeGNWh0dHA6Ly9jcmwwMy5hY3RhbGlzLml0L1JlcG9z\\n\"\n-            + \"aXRvcnkvQVVUSC1HMy9nZXRMYXN0Q1JMMA4GA1UdDwEB\/wQEAwIFoDAdBgNVHSUE\\n\"\n-            + \"FjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHwYDVR0RBBgwFoIUc3NsdGVzdC1yLmFj\\n\"\n-            + \"dGFsaXMuaXQwDQYJKoZIhvcNAQELBQADggEBAHZLND53\/CZoMlDtfln0ZByCEhoF\\n\"\n-            + \"\/XtA9cYy2azRGgS\/VY4WUccvg99MM50cwn5GPRsJpoaFXeDrjV3DkOUK1jERzjx4\\n\"\n-            + \"5y83K\/AkCGe7uU17aS+tweETizBAfHNj78oHmZDmkDSEY2STaeuHNDJ9ft0v3QTb\\n\"\n-            + \"VW54R5W3OBU7L\/sJoEUdRxzGN7vO82PboGvyApMCWDRLKE7bPP4genQtF3XPcaFl\\n\"\n-            + \"ekuSiEVYS+KnM2v9tCWHqw6x7raWHFB9w1kAKNwv0hbEJkeC+a2bCdPwv8hs\/\/sa\\n\"\n-            + \"gUF4p61mIpf+5qmQ6gcZOClPWyrbYdQdfCvKgbEdKhwB0v5KS0NIRRn41SE=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Owner: CN=ssltest-revoked.actalis.it, O=Actalis S.p.A., L=Ponte San Pietro, ST=Bergamo, C=IT\n+    \/\/ Issuer: CN=Actalis Organization Validated Server CA G3, O=Actalis S.p.A.,\n+    \/\/ L=Ponte San Pietro, ST=Bergamo, C=IT\n+    \/\/ Serial number: 320955171b78d49507508910da2c5bc4\n+    \/\/ Valid from: Tue Sep 27 03:40:43 PDT 2022 until: Wed Sep 27 03:40:43 PDT 2023\n+    private static final String REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIH1TCCBb2gAwIBAgIQMglVFxt41JUHUIkQ2ixbxDANBgkqhkiG9w0BAQsFADCB\\n\" +\n+            \"iTELMAkGA1UEBhMCSVQxEDAOBgNVBAgMB0JlcmdhbW8xGTAXBgNVBAcMEFBvbnRl\\n\" +\n+            \"IFNhbiBQaWV0cm8xFzAVBgNVBAoMDkFjdGFsaXMgUy5wLkEuMTQwMgYDVQQDDCtB\\n\" +\n+            \"Y3RhbGlzIE9yZ2FuaXphdGlvbiBWYWxpZGF0ZWQgU2VydmVyIENBIEczMB4XDTIy\\n\" +\n+            \"MDkyNzEwNDA0M1oXDTIzMDkyNzEwNDA0M1oweDELMAkGA1UEBhMCSVQxEDAOBgNV\\n\" +\n+            \"BAgMB0JlcmdhbW8xGTAXBgNVBAcMEFBvbnRlIFNhbiBQaWV0cm8xFzAVBgNVBAoM\\n\" +\n+            \"DkFjdGFsaXMgUy5wLkEuMSMwIQYDVQQDDBpzc2x0ZXN0LXJldm9rZWQuYWN0YWxp\\n\" +\n+            \"cy5pdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKdBnbeFtw\/Ejp1U\\n\" +\n+            \"gr86BQ5rqgGXWWXb7fsOhPb5On9RXTojg6oaeIV4GxHsMZhEDKQdcZ6JWAo2dbtp\\n\" +\n+            \"\/7ereFEDWG\/YJahLHFZ\/ihXG4AmfObYEhoGbKitW75fOs\/aWC7Veck\/sXsw7cjLW\\n\" +\n+            \"GY623ybcF9DBExg3S4uLRaSkv5hXUDu\/CzphUgwiEd5YNBZjcryOiS8+Y5EQ+2q+\\n\" +\n+            \"g+tdRG9m5G5YxeHWgQz2HDDwLDsJhWkb8\/RsUurU\/I+avHPhYk13K5Ysf311gww8\\n\" +\n+            \"bAsplfdJ2gdn8Is+EAEH4GJHqMybC95YDh1w5dY7dk\/lIoNX4hYUIQimirIr3OW8\\n\" +\n+            \"Svkj1G8CAwEAAaOCA0cwggNDMAwGA1UdEwEB\/wQCMAAwHwYDVR0jBBgwFoAUn4qx\\n\" +\n+            \"tfGx3oL0J3y+iM3eqUOBo0swfgYIKwYBBQUHAQEEcjBwMDsGCCsGAQUFBzAChi9o\\n\" +\n+            \"dHRwOi8vY2FjZXJ0LmFjdGFsaXMuaXQvY2VydHMvYWN0YWxpcy1hdXRob3ZnMzAx\\n\" +\n+            \"BggrBgEFBQcwAYYlaHR0cDovL29jc3AwOS5hY3RhbGlzLml0L1ZBL0FVVEhPVi1H\\n\" +\n+            \"MzAlBgNVHREEHjAcghpzc2x0ZXN0LXJldm9rZWQuYWN0YWxpcy5pdDBRBgNVHSAE\\n\" +\n+            \"SjBIMDwGBiuBHwEUATAyMDAGCCsGAQUFBwIBFiRodHRwczovL3d3dy5hY3RhbGlz\\n\" +\n+            \"Lml0L2FyZWEtZG93bmxvYWQwCAYGZ4EMAQICMB0GA1UdJQQWMBQGCCsGAQUFBwMC\\n\" +\n+            \"BggrBgEFBQcDATBIBgNVHR8EQTA\/MD2gO6A5hjdodHRwOi8vY3JsMDkuYWN0YWxp\\n\" +\n+            \"cy5pdC9SZXBvc2l0b3J5L0FVVEhPVi1HMy9nZXRMYXN0Q1JMMB0GA1UdDgQWBBS6\\n\" +\n+            \"o8qJpg3ixoyA2QBayptaTfc+5DAOBgNVHQ8BAf8EBAMCBaAwggF+BgorBgEEAdZ5\\n\" +\n+            \"AgQCBIIBbgSCAWoBaAB2AK33vvp8\/xDIi509nB4+GGq0Zyldz7EMJMqFhjTr3IKK\\n\" +\n+            \"AAABg36SGRYAAAQDAEcwRQIgDXxSCQGfcIYroxNiDJg08IX38Y9+r5CC6T4NeW14\\n\" +\n+            \"FzgCIQDdEhEYsGIWpwyrnTLr4RFB5CMEq+84dByNT07UYkiVwwB2AHoyjFTYty22\\n\" +\n+            \"IOo44FIe6YQWcDIThU070ivBOlejUutSAAABg36SGTUAAAQDAEcwRQIgL2ig9RrM\\n\" +\n+            \"FPWESGRYGJJJYRHdcayHev66jawrf98saN8CIQD\/CInlI3Vo7SBzzN\/4uykjYsFZ\\n\" +\n+            \"u9RypT6AYv6AHPlNdQB2AG9Tdqwx8DEZ2JkApFEV\/3cVHBHZAsEAKQaNsgiaN9kT\\n\" +\n+            \"AAABg36SGU0AAAQDAEcwRQIhAOCD\/dOs4HjyC+GQaQRh4U+\/mUwWyu+CnlHdebmD\\n\" +\n+            \"hAvFAiAvBE0rbxgm8TpZLG2TaMk3dqZj7Q6FFdLlqTsvwhKa3jANBgkqhkiG9w0B\\n\" +\n+            \"AQsFAAOCAgEAEnPALMVp1pySJgHhugLWAUgiD6stpDWCKfaBxPr+jf34A5wS+m5r\\n\" +\n+            \"2VhYyNQpOwIQB76K2RSJQrdpg7Dg2L6EiUnbbClSTrOkZ4XX5ggBIjldDEx4ZxhI\\n\" +\n+            \"zwSw4KB6+DDAVMwsCL0q0E7AAPOMaZ0RDLteusqQYIYm08TXfJPWD8LjQPt\/8Uie\\n\" +\n+            \"LOqm1eLUuwJc+eHFWV+Xr8Uea6SFwqNEj7qPHb2MElctET\/MhSIIUKI1ObmrFwyB\\n\" +\n+            \"ElKEPaUh9L0HXpnuD8IWc7tw2mdvnWJhuGG8G6JkasTGvtZ4gKIDBdTrJcuj7MCS\\n\" +\n+            \"amz3ZBCY47tP1ohgImjqwg4ITYjX6UQXgj\/nBVDdu+nXkEhx16uPJkTYWaun9Nio\\n\" +\n+            \"8RjYIOxXmDD39QbGUElP0Epsr2wcVT9tIFYMGzUpIO51mCk3Aq1AmiQZwZZhqOIN\\n\" +\n+            \"RDx7lGESPj3IgdVfJi9Ing\/OUNtS46Ug9DSuDcGqdY7KnTYEUdWGsUJNtnpjd4lS\\n\" +\n+            \"U6oIAeW1aKuOve6iNg1vsFAN57aJNh1ih3BOup58J9ve42bNlAYWN8wiNxM+Aeba\\n\" +\n+            \"ArUSTnH\/QEYCyMRD0XqIREVR9VhNODgSZbL3XedYBAW9wImi1whp+u+8aReXd7lC\\n\" +\n+            \"Q3kD9KRyfZ9Kk05Glf3DsZMWvp1N2ZZWaU2Ms5U3ijUheCiBrqrs8a8=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -224,1 +200,0 @@\n-        boolean ocspEnabled = false;\n@@ -231,1 +206,0 @@\n-            ocspEnabled = true;\n@@ -235,1 +209,1 @@\n-        pathValidator.validate(new String[]{VALID, INT_VALID},\n+        pathValidator.validate(new String[]{VALID, INT},\n@@ -238,7 +212,0 @@\n-        \/\/ Revoked certificate is using SHA1 signature\n-        if (ocspEnabled) {\n-            \/\/ Revoked test certificate is expired\n-            \/\/ and backdated revocation check is only possible with OCSP\n-            pathValidator.setValidationDate(\"July 01, 2016\");\n-        }\n-\n@@ -246,1 +213,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+        pathValidator.validate(new String[]{REVOKED, INT},\n@@ -248,4 +215,1 @@\n-                \"Fri Jan 29 01:06:42 PST 2016\", System.out);\n-\n-        \/\/ reset validation date back to current date\n-        pathValidator.resetValidationDate();\n+                \"Tue Sep 27 03:52:40 PDT 2022\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/ActalisCA.java","additions":157,"deletions":193,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,2 @@\n-        FtpServer server = new FtpServer(0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        FtpServer server = new FtpServer(loopback, 0);\n@@ -113,2 +114,2 @@\n-        URL url = new URL(\"ftp:\/\/user:passwd@localhost:\" + port + \"\/foo.txt\");\n-        URLConnection con = url.openConnection();\n+        URL url = new URL(\"ftp:\/\/user:passwd@\" + server.getAuthority() + \"\/foo.txt\");\n+        URLConnection con = url.openConnection(Proxy.NO_PROXY);\n","filename":"test\/jdk\/sun\/net\/ftp\/B6427768.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.net.InetAddress;\n@@ -40,1 +41,2 @@\n-        FtpServer server = new FtpServer(0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        FtpServer server = new FtpServer(loopback, 0);\n@@ -43,1 +45,1 @@\n-        int port = server.getLocalPort();\n+        String authority = server.getAuthority();\n@@ -45,1 +47,1 @@\n-        URL url = new URL(\"ftp:\/\/localhost:\" + port + \"\/filedoesNotExist.txt\");\n+        URL url = new URL(\"ftp:\/\/\" + authority + \"\/filedoesNotExist.txt\");\n","filename":"test\/jdk\/sun\/net\/ftp\/FtpURLConnectionLeak.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -100,3 +101,3 @@\n-            server = new TestHttpServer (new AuthHeaderTest(), 1, 10, 0);\n-            System.out.println (\"Server: listening on port: \" + server.getLocalPort());\n-            client (\"http:\/\/localhost:\"+server.getLocalPort()+\"\/d1\/foo.html\");\n+            server = new TestHttpServer (new AuthHeaderTest(), 1, 10, loopback, 0);\n+            System.out.println (\"Server: listening on port: \" + server.getAuthority());\n+            client (\"http:\/\/\" + server.getAuthority() + \"\/d1\/foo.html\");\n","filename":"test\/jdk\/sun\/net\/www\/AuthHeaderTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,3 +241,0 @@\n-            if (pasv == null)\n-                pasv = new ServerSocket(0);\n-            int port = pasv.getLocalPort();\n@@ -249,0 +246,3 @@\n+            if (pasv == null)\n+                pasv = new ServerSocket(0, 0, rAddress);\n+            int port = pasv.getLocalPort();\n@@ -269,1 +269,1 @@\n-                pasv = new ServerSocket(0);\n+                pasv = new ServerSocket(0, 0, parent.getInetAddress());\n","filename":"test\/jdk\/sun\/net\/www\/ftptest\/FtpCommandHandler.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,10 @@\n+    \/**\n+     * Creates an instance of an FTP server which will listen for incoming\n+     * connections on the specified port. If the port is set to 0, it will\n+     * automatically select an available ephemeral port.\n+     *\/\n+    public FtpServer(InetAddress addr, int port) throws IOException {\n+        listener = new ServerSocket();\n+        listener.bind(new InetSocketAddress(addr, port));\n+    }\n+\n@@ -103,0 +113,15 @@\n+    public InetAddress getInetAddress() {\n+        return listener.getInetAddress();\n+    }\n+\n+    public String getAuthority() {\n+        InetAddress address = getInetAddress();\n+        String hostaddr = address.isAnyLocalAddress()\n+            ? \"localhost\" : address.getHostAddress();\n+        if (hostaddr.indexOf(':') > -1) {\n+            hostaddr = \"[\" + hostaddr + \"]\";\n+        }\n+        return hostaddr + \":\" + getLocalPort();\n+    }\n+\n+\n","filename":"test\/jdk\/sun\/net\/www\/ftptest\/FtpServer.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -39,0 +40,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -64,1 +66,7 @@\n-            client(\"http:\/\/localhost:\" + port + \"\/chunked\/\");\n+            String url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(server.getAddress().getAddress())\n+                .port(port)\n+                .path(\"\/chunked\/\")\n+                .build().toString();\n+            client(url);\n@@ -86,1 +94,2 @@\n-        HttpServer httpServer = HttpServer.create(new InetSocketAddress(0), 0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer httpServer = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n","filename":"test\/jdk\/sun\/net\/www\/http\/ChunkedInputStream\/ChunkedEncodingTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/net\/www\/http\/ChunkedInputStream\/ChunkedEncodingWithProgressMonitorTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -63,1 +65,7 @@\n-            URL url = new URL(\"http:\/\/localhost:\" + address.getPort() + \"\/testAvailable\/\");\n+            URL url = URIBuilder.newBuilder()\n+                      .scheme(\"http\")\n+                      .host(address.getAddress())\n+                      .port(address.getPort())\n+                      .path(\"\/testAvailable\/\")\n+                      .toURLUnchecked();\n+\n@@ -105,1 +113,3 @@\n-        httpServer = com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(0), 0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        InetSocketAddress sockaddr = new InetSocketAddress(loopback, 0);\n+        httpServer = com.sun.net.httpserver.HttpServer.create(sockaddr, 0);\n","filename":"test\/jdk\/sun\/net\/www\/http\/ChunkedInputStream\/TestAvailable.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main MultiThreadTest\n@@ -43,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -45,0 +48,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -46,0 +51,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -54,1 +60,1 @@\n-    static Object threadlock = new Object ();\n+    static final Object threadlock = new Object ();\n@@ -56,0 +62,5 @@\n+    \/\/ KEEP_ALIVE sent by the server\n+    static final int KEEP_ALIVE = 1; \/\/ seconds\n+    \/\/ The sending thread will sleep for this time after sending\n+    \/\/ half the number of its requests\n+    static final int SLEEP = KEEP_ALIVE * 1000 + 500; \/\/ ms\n@@ -66,0 +77,3 @@\n+    \/\/ Set to true after all requests have been sent\n+    static final AtomicBoolean DONE = new AtomicBoolean();\n+\n@@ -82,6 +96,4 @@\n-    String uri;\n-    byte[] b;\n-    int requests;\n-\n-    MultiThreadTest(int port, int requests) throws Exception {\n-        uri = \"http:\/\/localhost:\" + port + \"\/foo.html\";\n+    final String uri;\n+    final byte[] b;\n+    final int requests;\n+    final CountDownLatch countDown;\n@@ -89,0 +101,3 @@\n+    MultiThreadTest(String authority, int requests, CountDownLatch latch) throws Exception {\n+        countDown = latch;\n+        uri = \"http:\/\/\" + authority + \"\/foo.html\";\n@@ -91,4 +106,0 @@\n-\n-        synchronized (threadlock) {\n-            threadCounter ++;\n-        }\n@@ -99,1 +110,0 @@\n-\n@@ -103,0 +113,4 @@\n+                \/\/ sleep after sending half of the requests, that\n+                \/\/ should cause the connections to be closed as idle\n+                \/\/ if sleeping more than KeepAlive.\n+                if (i == requests\/2) Thread.sleep(SLEEP);\n@@ -107,6 +121,1 @@\n-            synchronized (threadlock) {\n-                threadCounter --;\n-                if (threadCounter == 0) {\n-                    threadlock.notifyAll();\n-                }\n-            }\n+            countDown.countDown();\n@@ -114,1 +123,2 @@\n-        debug(\"client: end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"client: end at \" + at() + \"ms, thread duration \"\n+                + Duration.ofNanos(System.nanoTime() - start).toMillis() + \"ms\");\n@@ -118,0 +128,11 @@\n+    \/\/ time at which main() started its work.\n+    static volatile long MAIN_START;\n+\n+    \/\/ number of millis since MAIN_START\n+    public static long at() {\n+        return at(System.nanoTime());\n+    }\n+    \/\/ number of millis between MAIN_START and the given time stamp\n+    public static long at(long nanoTime) {\n+        return Duration.ofNanos(nanoTime - MAIN_START).toMillis();\n+    }\n@@ -136,1 +157,3 @@\n-        ServerSocket ss = new ServerSocket(0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n@@ -139,0 +162,1 @@\n+        var latch = new CountDownLatch(threads);\n@@ -140,5 +164,8 @@\n-        Object lock = MultiThreadTest.getLock();\n-        synchronized (lock) {\n-            for (int i=0; i<threads; i++) {\n-                MultiThreadTest t = new MultiThreadTest(ss.getLocalPort(), requests);\n-                t.start ();\n+        MAIN_START = System.nanoTime();\n+        try {\n+            Object lock = MultiThreadTest.getLock();\n+            List<MultiThreadTest> tests = new ArrayList<>();\n+            for (int i = 0; i < threads; i++) {\n+                MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests, latch);\n+                tests.add(t);\n+                t.start();\n@@ -146,4 +173,0 @@\n-            try {\n-                lock.wait();\n-            } catch (InterruptedException e) {}\n-        }\n@@ -151,16 +174,39 @@\n-        \/\/ shutdown server - we're done.\n-        svr.shutdown();\n-\n-        int cnt = svr.connectionCount();\n-        MultiThreadTest.debug(\"Connections = \" + cnt);\n-        int reqs = Worker.getRequests ();\n-        MultiThreadTest.debug(\"Requests = \" + reqs);\n-        System.out.println (\"Connection count = \" + cnt + \" Request count = \" + reqs);\n-\n-        \/\/ We may have received traffic from something else than\n-        \/\/ our client. We should only count those workers for which\n-        \/\/ the expected header has been found.\n-        int validConnections = 0;\n-        for (Worker w : svr.workers()) {\n-            if (w.headerFound) validConnections++;\n-        }\n+            latch.await();\n+            long end = System.nanoTime();\n+            DONE.compareAndSet(false, true);\n+            for (var test : tests) test.join();\n+\n+            MultiThreadTest.debug(\"DONE at \" + at(end) + \"ms\");\n+\n+            \/\/ shutdown server - we're done.\n+            svr.shutdown();\n+\n+            int cnt = svr.connectionCount();\n+            MultiThreadTest.debug(\"Connections = \" + cnt);\n+            int reqs = Worker.getRequests();\n+            MultiThreadTest.debug(\"Requests = \" + reqs);\n+            System.out.println(\"Connection count = \" + cnt + \" Request count = \" + reqs);\n+\n+            \/\/ We may have received traffic from something else than\n+            \/\/ our client. We should only count those workers for which\n+            \/\/ the expected header has been found.\n+            int validConnections = 0;\n+            \/\/ We detect worker threads that may have timed out, so we don't include them in\n+            \/\/ the count to compare with the number of connections.\n+            int becameIdle = 0;\n+            for (Worker w : svr.workers()) {\n+                if (w.headerFound > 0) {\n+                    validConnections++;\n+                    if (w.mayHaveTimedOut(end)) {\n+                        debug(\"Worker \" + w.id + \" may have timed out\");\n+                        becameIdle++;\n+                    } else {\n+                        long at0 = at(w.lastReading);\n+                        long at1 = at(w.lastReplied);\n+                        debug(\"Worker \" + w.id +\" has not timed out - last used at \" +\n+                            Math.max(at0, at1));\n+                    }\n+                } else {\n+                    debug(\"Worker \" + w.id + \" is not a valid connection\");\n+                }\n+            }\n@@ -168,3 +214,15 @@\n-        if (validConnections > threads + 1 || validConnections == 0) { \/\/ could be less\n-            throw new RuntimeException (\"Expected \" + threads + \" connections: used \" + validConnections);\n-        }\n+            if (validConnections > threads) {\n+                if (SLEEP > KEEP_ALIVE) {\n+                    debug(\"INFO: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" while using \" + threads\n+                            + \" threads to make concurrent connections\");\n+                } else {\n+                    debug(\"WARNING: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" where only \" + threads\n+                            + \" connections and none idle were expected!\");\n+                }\n+            }\n@@ -172,10 +230,3 @@\n-        \/\/ Sometimes the client drops a connection after a while and\n-        \/\/ spawns a new one. Why this is happening is not clear,\n-        \/\/ and JDK-8223783 is logged to follow up on this. For the sake\n-        \/\/ of test stabilization we don't fail on `threads + 1` connections\n-        \/\/ but log a warning instead.\n-        if (validConnections == threads + 1) {\n-            debug(\"WARNING: \" + validConnections\n-                + \" have been used, where only \" + threads\n-                + \" were expected!\");\n-        }\n+            if (validConnections > threads + becameIdle || validConnections == 0) { \/\/ could be less\n+                throw new RuntimeException(\"Expected \" + (threads + becameIdle) + \" connections: used \" + validConnections);\n+            }\n@@ -183,6 +234,6 @@\n-        if (validConnections != cnt) {\n-            debug(\"WARNING: got \" + (cnt - validConnections) + \" unexpected connections!\");\n-        }\n-        if  (validConnections == cnt && reqs != threads*requests) {\n-            throw new RuntimeException (\"Expected \"+ threads*requests+ \" requests: got \" +reqs);\n-        }\n+            if (validConnections != cnt) {\n+                debug(\"INFO: got \" + (cnt - validConnections) + \" unexpected connections\");\n+            }\n+            if (reqs != threads * requests) {\n+                throw new RuntimeException(\"Expected \" + threads * requests + \" requests: got \" + reqs);\n+            }\n@@ -190,2 +241,10 @@\n-        for (Thread worker : svr.workers()) {\n-            worker.join(60_000);\n+        } finally {\n+            debug(\"waiting for worker to shutdown at \" + at() +\"ms\");\n+            for (Worker worker : svr.workers()) {\n+                \/\/ We want to verify that the client will eventually\n+                \/\/ close the idle connections. So just join the worker\n+                \/\/ and wait... This shouldn't take more than the granularity\n+                \/\/ of the keep-alive cache timer - so we're not actually\n+                \/\/ going to have to wait for one full minute here.\n+                worker.join(60_000);\n+            }\n@@ -194,1 +253,1 @@\n-        debug(\"main thread end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"main thread end - \" + at() + \"ms\");\n@@ -212,0 +271,10 @@\n+        public String getAuthority() {\n+            InetAddress address = ss.getInetAddress();\n+            String hostaddr = address.isAnyLocalAddress()\n+                ? \"localhost\" : address.getHostAddress();\n+            if (hostaddr.indexOf(':') > -1) {\n+                hostaddr = \"[\" + hostaddr + \"]\";\n+            }\n+            return hostaddr + \":\" + ss.getLocalPort();\n+        }\n+\n@@ -222,0 +291,4 @@\n+            try {\n+                ss.close();\n+            } catch (IOException x) {\n+            }\n@@ -226,1 +299,2 @@\n-                ss.setSoTimeout(2000);\n+                ss.setSoTimeout(6000);\n+                long startServer = System.nanoTime();\n@@ -230,0 +304,1 @@\n+                    long acceptTime;\n@@ -233,2 +308,4 @@\n-                        MultiThreadTest.debug(\"server: return accept.\");\n-                    } catch (SocketTimeoutException te) {\n+                        acceptTime = System.nanoTime();\n+                        MultiThreadTest.debug(\"server: return accept (at \" +\n+                                MultiThreadTest.at(acceptTime)+ \"ms)\");\n+                    } catch (IOException te) {\n@@ -238,1 +315,2 @@\n-                                MultiThreadTest.debug(\"server: Shuting down.\");\n+                                MultiThreadTest.debug(\"server: Shuting down at: \"\n+                                        + MultiThreadTest.at() + \"ms\");\n@@ -242,1 +320,3 @@\n-                        continue;\n+                        if (te instanceof SocketTimeoutException)\n+                            continue;\n+                        throw te;\n@@ -249,1 +329,1 @@\n-                        w = new Worker(s, id);\n+                        w = new Worker(s, id, acceptTime);\n@@ -271,5 +351,28 @@\n-        Socket s;\n-        int id;\n-        volatile boolean headerFound;\n-\n-        Worker(Socket s, int id) {\n+        final long TIMEOUT = MultiThreadTest.KEEP_ALIVE; \/\/ seconds\n+        final long KEEP_ALIVE_NS = Duration.ofSeconds(TIMEOUT).toNanos(); \/\/ nanos\n+        final Socket s;\n+        final int id;\n+\n+        \/\/ time at which the connection was accepted (nanos)\n+        final long acceptTime;\n+\n+        \/\/ number of requests that had the expected URI\n+        volatile int headerFound;\n+        \/\/ time at which the worker thread exited\n+        volatile long stopTime;\n+        \/\/ Time at which the first call to is.read() for the last request\n+        \/\/ returned. This includes cases where -1 was returned.\n+        volatile long startReading;\n+        \/\/ Lat time at which a byte was read from the stream.\n+        volatile long lastReading;\n+        \/\/ number of times that the time between two consecutive received requests\n+        \/\/ exceeded the KEEP_ALIVE timeout.\n+        volatile int timeoutExceeded;\n+        \/\/ Number of requests handled by this worker\n+        volatile int requestHandled;\n+        \/\/ Time at which the last byte of the last reply was sent\n+        volatile long lastReplied;\n+        \/\/ Whether the worker was asked to stop\n+        volatile boolean done;\n+\n+        Worker(Socket s, int id, long acceptTime) {\n@@ -279,0 +382,2 @@\n+            \/\/ no time can have a value before accepTime\n+            this.acceptTime = lastReading = lastReplied = startReading = acceptTime;\n@@ -296,0 +401,22 @@\n+        \/**\n+         * {@return Whether this worker might have been idle for more\n+         * than the KEEP_ALIVE timeout}\n+         * This will be true if the worker detected that the idle timeout\n+         * was exceeded between two consecutive request, or\n+         * if the time between the last reply and `nanosNow` exceeds\n+         * the keep-alive time.\n+         * @param nanosNow a timestamp in nano seconds\n+         *\/\n+        public boolean mayHaveTimedOut(long nanosNow) {\n+            \/\/ the minimum time elapsed between nanosNow and:\n+            \/\/  - the time the socket was accepted\n+            \/\/  - the last time a byte was received\n+            \/\/  - the last time a reply was sent.\n+            \/\/ We must not use `startReading` here because `startReading` may\n+            \/\/ be set if the client asynchronously closes the connection\n+            \/\/ after all requests have been sent. We should really only\n+            \/\/ take into account `lastReading` and `lastReplied`.\n+            long idle = Math.min(nanosNow - lastReading, nanosNow - lastReplied);\n+            return timeoutExceeded > 0 || idle >= KEEP_ALIVE_NS;\n+        }\n+\n@@ -298,0 +425,1 @@\n+            long last;\n@@ -300,0 +428,5 @@\n+                last = System.nanoTime();\n+                if (count == 0) {\n+                    \/\/ time at which the first byte of the request (or EOF) was received\n+                    startReading = last;\n+                }\n@@ -302,0 +435,2 @@\n+                \/\/ time at which the last byte of the request was received (excludes EOF)\n+                lastReading = last;\n@@ -318,0 +453,3 @@\n+            \/\/ lastUsed starts when the connection was accepted\n+            long lastUsed = acceptTime;\n+            int expectedReqs = 0;\n@@ -328,1 +466,0 @@\n-\n@@ -330,1 +467,1 @@\n-                    int n=0;\n+                    int n;\n@@ -333,0 +470,8 @@\n+                    long idle = startReading - lastUsed;\n+                    if (idle >= KEEP_ALIVE_NS) {\n+                        if (!MultiThreadTest.DONE.get()) {\n+                            \/\/ avoid increasing timeoutExceeded after the test is no\n+                            \/\/ longer sending requests.\n+                            timeoutExceeded++;\n+                        }\n+                    }\n@@ -334,1 +479,2 @@\n-                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown\");\n+                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown at \"\n+                                + MultiThreadTest.at() + \"ms\");\n@@ -339,1 +485,2 @@\n-                        headerFound = true;\n+                        headerFound = ++expectedReqs;\n+                        incRequests();\n@@ -342,0 +489,2 @@\n+                        s.close();\n+                        return;\n@@ -346,1 +495,1 @@\n-                        \"(\" + n + \" bytes).\");\n+                        \"(\" + n + \" bytes) at \" + MultiThreadTest.at() + \"ms\");\n@@ -348,1 +497,0 @@\n-                    incRequests();\n@@ -353,1 +501,1 @@\n-                    out.print(\"Keep-Alive: timeout=15, max=\"+max+\"\\r\\n\");\n+                    out.print(\"Keep-Alive: timeout=\" + TIMEOUT + \", max=\"+max+\"\\r\\n\");\n@@ -359,1 +507,2 @@\n-\n+                    requestHandled++;\n+                    lastUsed = lastReplied = System.nanoTime();\n@@ -369,0 +518,1 @@\n+                long end = stopTime = System.nanoTime();\n@@ -372,2 +522,8 @@\n-                MultiThreadTest.debug(\"worker: \" + id  + \" end - \" +\n-                            Duration.ofNanos(System.nanoTime() - start));\n+                MultiThreadTest.debug(\"worker: \" + id + \" end at \" +\n+                            MultiThreadTest.at() + \"ms,  elapsed since worker start: \" +\n+                            Duration.ofNanos(end - start).toMillis() + \"ms, elapsed since accept: \" +\n+                            Duration.ofNanos(end - acceptTime).toMillis() +\n+                            \"ms, timeout exceeded: \" + timeoutExceeded +\n+                            \", successfuly handled \" + requestHandled + \"\/\" +\n+                             expectedReqs + \" genuine requests, \" +\n+                            \", mayHaveTimedOut: \" + mayHaveTimedOut(end));\n@@ -376,0 +532,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/MultiThreadTest.java","additions":246,"deletions":89,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -39,0 +40,1 @@\n+import java.net.InetAddress;\n@@ -45,0 +47,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -69,1 +72,6 @@\n-            URL url = new URL(\"http:\/\/localhost:\" + address.getPort() + \"\/test\/\");\n+            URL url = URIBuilder.newBuilder()\n+                      .scheme(\"http\")\n+                      .host(address.getAddress())\n+                      .port(address.getPort())\n+                      .path(\"\/test\/\")\n+                      .toURLUnchecked();\n@@ -96,1 +104,2 @@\n-        httpServer = com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(0), 0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        httpServer = com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/RetryPost.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.net.InetAddress;\n@@ -57,1 +58,0 @@\n-    static final String LOCALHOST = \"localhost\";\n@@ -122,2 +122,1 @@\n-            String url = String.format(\"http:\/\/%s:%d\/test\/\",\n-                    LOCALHOST, server.getPort());\n+            String url = String.format(\"http:\/\/%s\/test\/\", server.getAuthority());\n@@ -325,0 +324,10 @@\n+        public String getAuthority() {\n+            InetAddress address = server.getAddress().getAddress();\n+            String hostaddr = address.isAnyLocalAddress()\n+                ? \"localhost\" : address.getHostAddress();\n+            if (hostaddr.indexOf(':') > -1) {\n+                hostaddr = \"[\" + hostaddr + \"]\";\n+            }\n+            return hostaddr + \":\" + getPort();\n+        }\n+\n@@ -334,0 +343,1 @@\n+            InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -335,1 +345,1 @@\n-                    new InetSocketAddress(0), 0);\n+                    new InetSocketAddress(loopback, 0), 0);\n@@ -345,1 +355,1 @@\n-            System.out.println(\"HttpServer: started on port \" + getPort());\n+            System.out.println(\"HttpServer: started on port \" + getAuthority());\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpURLConnection\/DigestAuth.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293562\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 B8293562\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+public class B8293562 {\n+    static HttpServer server;\n+    static CountDownLatch closing = new CountDownLatch(1);\n+    static CountDownLatch secondRequestDone = new CountDownLatch(1);\n+    static CompletableFuture<Void> result = new CompletableFuture<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        clientHttpCalls();\n+    }\n+\n+    public static void startHttpServer() throws Exception {\n+        server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10);\n+        server.setExecutor(Executors.newCachedThreadPool());\n+        server.start();\n+    }\n+\n+    public static void clientHttpCalls() throws Exception {\n+        try {\n+            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n+            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n+            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n+            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+\n+            URL testUrl = new URL (baseURLStr);\n+\n+            \/\/ SlowCloseSocketFactory is not a real SSLSocketFactory;\n+            \/\/ it produces regular non-SSL sockets. Effectively, the request\n+            \/\/ is made over http.\n+            HttpsURLConnection.setDefaultSSLSocketFactory(new SlowCloseSocketFactory());\n+            System.out.println(\"Performing first request\");\n+            HttpsURLConnection uc = (HttpsURLConnection)testUrl.openConnection(Proxy.NO_PROXY);\n+            byte[] buf = new byte[1024];\n+            try {\n+                uc.getInputStream();\n+                throw new RuntimeException(\"Expected 404 here\");\n+            } catch (FileNotFoundException ignored) { }\n+            try (InputStream is = uc.getErrorStream()) {\n+                while (is.read(buf) >= 0) {\n+                }\n+            }\n+            System.out.println(\"First request completed\");\n+            closing.await();\n+            \/\/ KeepAliveThread is closing the connection now\n+            System.out.println(\"Performing second request\");\n+            HttpsURLConnection uc2 = (HttpsURLConnection)testUrl.openConnection(Proxy.NO_PROXY);\n+\n+            try {\n+                uc2.getInputStream();\n+                throw new RuntimeException(\"Expected 404 here\");\n+            } catch (FileNotFoundException ignored) { }\n+            try (InputStream is = uc2.getErrorStream()) {\n+                while (is.read(buf) >= 0) {\n+                }\n+            }\n+            System.out.println(\"Second request completed\");\n+            \/\/ let the socket know it can close now\n+            secondRequestDone.countDown();\n+            result.get();\n+            System.out.println(\"Test completed successfully\");\n+        } finally {\n+            server.stop(1);\n+        }\n+    }\n+\n+    static class SlowCloseSocket extends SSLSocket {\n+        @Override\n+        public synchronized void close() throws IOException {\n+            String threadName = Thread.currentThread().getName();\n+            System.out.println(\"Connection closing, thread name: \" + threadName);\n+            closing.countDown();\n+            super.close();\n+            if (threadName.equals(\"Keep-Alive-Timer\")) {\n+                try {\n+                    if (secondRequestDone.await(5, TimeUnit.SECONDS)) {\n+                        result.complete(null);\n+                    } else {\n+                        result.completeExceptionally(new RuntimeException(\n+                                \"Wait for second request timed out\"));\n+                    }\n+                } catch (InterruptedException e) {\n+                    result.completeExceptionally(new RuntimeException(\n+                            \"Wait for second request was interrupted\"));\n+                }\n+            } else {\n+                result.completeExceptionally(new RuntimeException(\n+                        \"Close invoked from unexpected thread\"));\n+            }\n+            System.out.println(\"Connection closed\");\n+        }\n+\n+        \/\/ required abstract method overrides\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) { }\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) { }\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+        @Override\n+        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void startHandshake() throws IOException { }\n+        @Override\n+        public void setUseClientMode(boolean mode) { }\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+        @Override\n+        public void setNeedClientAuth(boolean need) { }\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setWantClientAuth(boolean want) { }\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) { }\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    static class SlowCloseSocketFactory extends SSLSocketFactory {\n+\n+        @Override\n+        public Socket createSocket() throws IOException {\n+            return new SlowCloseSocket();\n+        }\n+        \/\/ required abstract method overrides\n+        @Override\n+        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public String[] getDefaultCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,3 +46,4 @@\n-        HttpServer s = HttpServer.create (new InetSocketAddress(0), 10);\n-        s.createContext (\"\/\", new HttpHandler () {\n-            public void handle (HttpExchange e) {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer s = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n+        s.createContext(\"\/\", new HttpHandler() {\n+            public void handle(HttpExchange e) {\n@@ -53,1 +54,1 @@\n-                    o.write (buf);\n+                    o.write(buf);\n@@ -94,2 +95,2 @@\n-            System.out.println (\"TEST FAILED\");\n-            throw new RuntimeException ();\n+            System.out.println(\"TEST FAILED\");\n+            throw new RuntimeException();\n@@ -97,1 +98,1 @@\n-            System.out.println (\"TEST OK\");\n+            System.out.println(\"TEST OK\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/6550798\/test.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -36,1 +37,1 @@\n-\n+import jdk.test.lib.net.URIBuilder;\n@@ -82,1 +83,3 @@\n-        ss = new ServerSocket(0);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ss = new ServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n@@ -89,1 +92,5 @@\n-        URL url = new URL(\"http:\/\/localhost:\" + ss.getLocalPort());\n+        URL url = URIBuilder.newBuilder()\n+            .scheme(\"http\")\n+            .host(ss.getInetAddress())\n+            .port(ss.getLocalPort())\n+            .toURL();\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/CloseOptionHeader.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import java.net.InetAddress;\n@@ -43,0 +45,1 @@\n+import javax.net.ssl.SSLHandshakeException;\n@@ -47,0 +50,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -94,0 +98,1 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -97,1 +102,1 @@\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n+            (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);\n@@ -140,1 +145,8 @@\n-        URL url = new URL(\"https:\/\/localhost:\" + serverPort +\"\/\");\n+        URL url = URIBuilder.newBuilder()\n+                  .scheme(\"https\")\n+                  .loopback()\n+                  .port(serverPort)\n+                  .path(\"\/\")\n+                  .toURL();\n+\n+        System.out.println(\"Client ready to connect to: \" + url);\n@@ -143,1 +155,1 @@\n-        InputStream in = url.openConnection().getInputStream();\n+        InputStream in = url.openConnection(java.net.Proxy.NO_PROXY).getInputStream();\n@@ -186,0 +198,4 @@\n+    private boolean sslConnectionFailed() {\n+        return clientException instanceof SSLHandshakeException;\n+    }\n+\n@@ -232,1 +248,5 @@\n-                serverThread.join();\n+                \/\/ don't join the server thread if the\n+                \/\/ client failed to connect\n+                if (!sslConnectionFailed()) {\n+                    serverThread.join();\n+                }\n@@ -262,1 +282,1 @@\n-            local.initCause(remote);\n+            local.addSuppressed(remote);\n@@ -277,1 +297,1 @@\n-            if (exception != startException) {\n+            if (exception != startException && startException != null) {\n@@ -326,1 +346,1 @@\n-                        System.err.println(\"Client died...\");\n+                        System.err.println(\"Client died: \" + e);\n@@ -336,0 +356,1 @@\n+                System.err.println(\"Client died: \" + e);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/CookieHttpsClientTest.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @library \/test\/lib\n@@ -41,0 +42,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -96,0 +98,1 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -99,1 +102,1 @@\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n+            (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);\n@@ -166,1 +169,5 @@\n-                URL url = new URL(\"https:\/\/localhost:\" + serverPort);\n+                URL url = URIBuilder.newBuilder()\n+                          .scheme(\"https\")\n+                          .loopback()\n+                          .port(serverPort)\n+                          .toURL();\n@@ -187,1 +194,5 @@\n-                URL url = new URL(\"https:\/\/localhost:\" + serverPort);\n+                URL url = URIBuilder.newBuilder()\n+                          .scheme(\"https\")\n+                          .loopback()\n+                          .port(serverPort)\n+                          .toURL();\n@@ -242,0 +253,4 @@\n+    private boolean sslConnectionFailed() {\n+        return clientException instanceof SSLHandshakeException;\n+    }\n+\n@@ -285,1 +300,3 @@\n-            serverThread.join();\n+            if (!sslConnectionFailed()) {\n+                serverThread.join();\n+            }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/ReadTimeout.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -98,0 +100,1 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -101,1 +104,1 @@\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n+            (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, loopback);\n@@ -157,1 +160,5 @@\n-            URL url = new URL(\"https:\/\/localhost:\"+serverPort);\n+            URL url = URIBuilder.newBuilder()\n+                      .scheme(\"https\")\n+                      .loopback()\n+                      .port(serverPort)\n+                      .toURL();\n@@ -193,0 +200,4 @@\n+    private boolean sslConnectionFailed() {\n+        return clientException instanceof SSLHandshakeException;\n+    }\n+\n@@ -236,1 +247,3 @@\n-            serverThread.join();\n+            if (!sslConnectionFailed()) {\n+                serverThread.join();\n+            }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/Redirect.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8048194\n+ * @bug 8048194 8242151\n@@ -60,1 +60,1 @@\n-        GSSHeader h1 = new GSSHeader(new ObjectIdentifier(\"1.2.3.4\"), 1);\n+        GSSHeader h1 = new GSSHeader(ObjectIdentifier.of(\"1.2.3.4\"), 1);\n@@ -81,1 +81,1 @@\n-                new ObjectIdentifier(GSSUtil.GSS_SPNEGO_MECH_OID.toString()),\n+                ObjectIdentifier.of(GSSUtil.GSS_SPNEGO_MECH_OID.toString()),\n","filename":"test\/jdk\/sun\/security\/jgss\/spnego\/NotPreferredMech.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274205\n+ * @summary Handle KDC_ERR_SVC_UNAVAILABLE error code from KDC\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file Unavailable.java\n+ * @run main jdk.test.lib.FileInstaller TestHosts TestHosts\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts Unavailable\n+ *\/\n+\n+import sun.security.krb5.Config;\n+import sun.security.krb5.PrincipalName;\n+import sun.security.krb5.internal.KRBError;\n+import sun.security.krb5.internal.KerberosTime;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Locale;\n+\n+public class Unavailable {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Good KDC\n+        KDC kdc1 = KDC.create(OneKDC.REALM);\n+        kdc1.addPrincipal(OneKDC.USER, OneKDC.PASS);\n+        kdc1.addPrincipalRandKey(\"krbtgt\/\" + OneKDC.REALM);\n+\n+        \/\/ The \"not available\" KDC\n+        KDC kdc2 = new KDC(OneKDC.REALM, \"kdc.\" + OneKDC.REALM.toLowerCase(Locale.US), 0, true) {\n+            @Override\n+            protected byte[] processAsReq(byte[] in) throws Exception {\n+                KRBError err = new KRBError(null, null, null,\n+                        KerberosTime.now(), 0,\n+                        29, \/\/ KDC_ERR_SVC_UNAVAILABLE\n+                        null, new PrincipalName(\"krbtgt\/\" + OneKDC.REALM),\n+                        null, null);\n+                return err.asn1Encode();\n+            }\n+        };\n+\n+        Files.write(Path.of(OneKDC.KRB5_CONF), String.format(\n+                \"[libdefaults]\\n\" +\n+                \"default_realm = RABBIT.HOLE\\n\" +\n+                \"\\n\" +\n+                \"[realms]\\n\" +\n+                \"RABBIT.HOLE = {\\n\" +\n+                \"    kdc = kdc.rabbit.hole:%d\\n\" +\n+                \"    kdc = kdc.rabbit.hole:%d\\n\" +\n+                \"}\\n\",\n+                kdc2.getPort(), kdc1.getPort()).getBytes());\n+        System.setProperty(\"java.security.krb5.conf\", OneKDC.KRB5_CONF);\n+        Config.refresh();\n+\n+        Context.fromUserPass(OneKDC.USER, OneKDC.PASS, false);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/Unavailable.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -293,2 +293,2 @@\n-            System.err.println(\"ERROR: wrong checksum\" + checksum);\n-            System.err.println(\"Expected checksum\" + CHECKSUM);\n+            System.err.println(\"ERROR: wrong checksum \" + checksum);\n+            System.err.println(\"Expected checksum \" + CHECKSUM);\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8048357\n+ * @bug 8048357 8242151\n@@ -65,1 +65,1 @@\n-            new ObjectIdentifier(\"1.2.3.4\"),\n+            ObjectIdentifier.of(\"1.2.3.4\"),\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs10\/PKCS10AttrEncoding.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8048357\n+ * @bug 8048357 8242151\n@@ -89,1 +89,1 @@\n-                        new ObjectIdentifier(\"1.9.50.51.52\"));\n+                        ObjectIdentifier.of(\"1.9.50.51.52\"));\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs10\/PKCS10AttributeReader.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,6 +33,7 @@\n-import java.security.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n-\n-import java.util.*;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -310,8 +311,13 @@\n-            double ver = getNSSInfo(\"nss\");\n-            if (ver < 3.251d && p.getName().contains(\"SunPKCS11-NSS\") &&\n-                System.getProperty(\"os.name\").equals(\"SunOS\")) {\n-                \/\/ buggy behaviour from solaris on 11.2 OS (nss < 3.251)\n-                System.out.println(\"Skipping: SunPKCS11-NSS: Old NSS: \" + ver);\n-                return; \/\/ OK\n-            } else {\n-                throw e;\n+            System.out.println(\"Exception occured using \" + p.getName() + \" version \" + p.getVersionStr());\n+\n+            if (isNSS(p)) {\n+                double ver = getNSSInfo(\"nss\");\n+                String osName = System.getProperty(\"os.name\");\n+                if (ver < 3.251d && osName.equals(\"SunOS\")) {\n+                    \/\/ buggy behaviour from solaris on 11.2 OS (nss < 3.251)\n+                    System.out.println(\"Skipping: SunPKCS11-NSS: Old NSS: \" + ver);\n+                    return; \/\/ OK\n+                } else if (ver > 3.139 && ver < 3.15 && osName.equals(\"Linux\")) {\n+                    \/\/ warn about buggy behaviour on Linux with nss 3.14\n+                    System.out.println(\"Warning: old NSS \" + ver + \" might be problematic, consider upgrading it\");\n+                }\n@@ -319,0 +325,1 @@\n+            throw e;\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            revision = \"3.41-VS2017\",\n+            revision = \"3.46-VS2017\",\n@@ -998,1 +998,1 @@\n-            revision = \"3.41-VS2017\",\n+            revision = \"3.46-VS2017\",\n@@ -1005,1 +1005,1 @@\n-            revision = \"3.41\",\n+            revision = \"3.46\",\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4856966\n+ * @bug 4856966 8023980\n@@ -45,0 +45,78 @@\n+    private static final String PKCS1_PRIV_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PRIVATE KEY-----\n+        \/\/ and -----END RSA PRIVATE KEY-----\n+        \"MIIEowIBAAKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+Stp\" +\n+        \"CCJCcUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27\" +\n+        \"Stm098pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqam\" +\n+        \"v5YnCKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P\" +\n+        \"8X2praOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sO\" +\n+        \"rwjCQKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQABAoIBADn6sXOynoiUC1IP\" +\n+        \"sck8lGOTSjSSujfyrVCSsJlJV6qCfuX9va6rS8QDjjnBu531PtxoSHxoPizy2Pvg\" +\n+        \"W+kKATPGR\/am9DjLuFlKq7GRjoYfWyMEdVtGaKvq9ng4fBF6LHyjHz0VFrPyhQJ6\" +\n+        \"TovHeXzCguYBkzAlnbAeb\/vqzs\/kABbOuSHVi7DsaixCoEX9zOptFYQw\/l8rh68+\" +\n+        \"UF2bpNNH3jOC1uN3vZtuSwCupqtN+2Mpkx2h04Rk75vWIhrnPeMgmcd3yP4LNZMR\" +\n+        \"mfaynb63RRzVkNis7+NVk016SQ1oL79mrBvy5rBg3HeCeArwvqZAmOaWsLSWHzCy\" +\n+        \"zlVlMTECgYEA6JlnMpC956Qi8HX5ye4Hu2ovBdbNGtH\/TMkZmColJz9P7CvNkNIb\" +\n+        \"Od6mvLMydbPHkhdBUDWD4rhiCKHrf5zKju1i24YqWcvuSGotWj4\/KQ3+87mLZM+7\" +\n+        \"daBsJBmSEVB80sgA9ItqSgOyNoNFpiDgFnlszAfb0n9XXEzB\/pwSw1UCgYEA5eXI\" +\n+        \"d+eKugugP+n6CluQfyxfN6WWCzfqWToCTTxPn2i12AiEssXy+kyLjupJVLWSivdo\" +\n+        \"83wD5LuxFRGc9P+aKQERPhb0AFaxf1llUCXla65\/x2So5xjMvtuzgQ0OktPJqJXq\" +\n+        \"hYGunctsr5rje33+7vlx4xWkrL2PrQWzJabn7SUCgYEAqw3FesY\/Ik7u8u+P1xSZ\" +\n+        \"0xXvptek1oiAu7NYgzLbR9WjrQc5kbsyEojPDg6qmSyxI5q+iYIRj3YRgk+xpJNl\" +\n+        \"0154SQCNvKPghJiw6aDFSifkytA01tp9\/a8QWCwF433RjiFPsoekjvHQ6Y34dofO\" +\n+        \"xDhf7lwJKPBFCrfYIqocklECgYAIPI9OHHGP8NKw94UJ0fX\/WGug5sHVbQ9sWvOy\" +\n+        \"KLMBlxLMxqFadlUaOpvVZvdxnX++ktajwpGxJDhX9OWWsYGobm1buB7N1E1Prrg+\" +\n+        \"gt0RWpMhZa3Xeb\/8Jorr2Lfo8sWK0LQyTE8hQCSIthfoWL9FeJJn\/GKF\/dSj8kxU\" +\n+        \"0QIGMQKBgG\/8U\/zZ87DzfXS81P1p+CmH474wmou4KD2\/zXp\/lDR9+dlIUeijlIbU\" +\n+        \"P6Y5xJvT33Y40giW9irShgDHjZgw0ap11K3b2HzLImdPEaBiENo735rpLs8WLK9H\" +\n+        \"+yeRbiP2y9To7sTihm9Jrkctzp6sqFtKyye1+S21X1tMz8NGfXen\";\n+\n+    private static final String PKCS1_PUB_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PUBLIC KEY-----\n+        \/\/ and -----END RSA PUBLIC KEY-----\n+        \"MIIBCgKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+StpCCJC\" +\n+        \"cUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27Stm0\" +\n+        \"98pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqamv5Yn\" +\n+        \"CKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P8X2p\" +\n+        \"raOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sOrwjC\" +\n+        \"QKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQAB\";\n+\n+\n+    private static final PrivateKey CUSTOM_PRIV;\n+    private static final PublicKey CUSTOM_PUB;\n+\n+    static {\n+        byte[] encodedPriv = Base64.getDecoder().decode(PKCS1_PRIV_STR);\n+        CUSTOM_PRIV = new PrivateKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPriv;\n+            }\n+        };\n+        byte[] encodedPub = Base64.getDecoder().decode(PKCS1_PUB_STR);\n+        CUSTOM_PUB = new PublicKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPub;\n+            }\n+        };\n+    }\n+\n@@ -71,2 +149,5 @@\n-        if (key1.equals(key2) == false) {\n-            throw new Exception(\"Keys not equal\");\n+        \/\/ skip equals check when key1 is custom key\n+        if (key1 != CUSTOM_PRIV && key1 != CUSTOM_PUB) {\n+            if (!key1.equals(key2)) {\n+                throw new Exception(\"Keys not equal\");\n+            }\n@@ -74,1 +155,3 @@\n-        if (Arrays.equals(key1.getEncoded(), key2.getEncoded()) == false) {\n+        \/\/ only compare encodings if keys are of the same format\n+        if (key1.getFormat().equals(key2.getFormat()) &&\n+            !Arrays.equals(key1.getEncoded(), key2.getEncoded())) {\n@@ -79,2 +162,4 @@\n-    private static void testPublic(KeyFactory kf, PublicKey key) throws Exception {\n-        System.out.println(\"Testing public key...\");\n+    private static void testPublic(KeyFactory kf, PublicKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PUB? \"PKCS#1\" : \"\") +\n+            \" public key...\");\n@@ -86,3 +171,3 @@\n-        KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n-        PublicKey key5 = kf.generatePublic(x509Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PUB) {\n+            testKey(key, key);\n+        }\n@@ -92,1 +177,7 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+            KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n+            PublicKey key5 = kf.generatePublic(x509Spec2);\n+            testKey(key, key5);\n+        }\n+\n@@ -95,2 +186,4 @@\n-    private static void testPrivate(KeyFactory kf, PrivateKey key) throws Exception {\n-        System.out.println(\"Testing private key...\");\n+    private static void testPrivate(KeyFactory kf, PrivateKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == CUSTOM_PRIV? \"PKCS#1\" : \"\") +\n+            \" private key...\");\n@@ -102,3 +195,3 @@\n-        KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n-        PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n-        testKey(key, key);\n+        if (key != CUSTOM_PRIV) {\n+            testKey(key, key);\n+        }\n@@ -108,1 +201,6 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"PKCS#8\")) {\n+            KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n+            PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n+            testKey(key, key5);\n+        }\n@@ -148,0 +246,4 @@\n+        \/\/ repeat the test w\/ PKCS#1 RSA Private Key\n+        test(kf, CUSTOM_PRIV);\n+        test(kf, CUSTOM_PUB);\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestKeyFactory.java","additions":119,"deletions":17,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8076190 8153005 8266182\n+ * @bug 8076190 8242151 8153005 8266182\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6958026\n+ * @bug 6958026 8242151\n@@ -78,1 +78,1 @@\n-                new ObjectIdentifier(\"1.2.840.113549.1.12.1.3\"), algParams);\n+                ObjectIdentifier.of(\"1.2.840.113549.1.12.1.3\"), algParams);\n","filename":"test\/jdk\/sun\/security\/pkcs12\/PKCS12SameKeyId.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @bug 8076190 8153005 8266293\n+ * @bug 8076190 8242151 8153005 8266293\n","filename":"test\/jdk\/sun\/security\/pkcs12\/ParamsPreferences.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @bug 8154523\n+ * @bug 8154523 8247895\n@@ -38,1 +38,1 @@\n-        sr.setSeed(0);\n+        sr.setSeed(1);\n@@ -48,1 +48,1 @@\n-        sr2.setSeed(1);\n+        sr2.setSeed(2);\n","filename":"test\/jdk\/sun\/security\/provider\/SecureRandom\/SHA1PRNGReseed.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021,  Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4853305 8254717\n+ * @bug 4853305 8023980 8254717\n@@ -44,0 +44,78 @@\n+    private static final String PKCS1_PRIV_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PRIVATE KEY-----\n+        \/\/ and -----END RSA PRIVATE KEY-----\n+        \"MIIEowIBAAKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+Stp\" +\n+        \"CCJCcUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27\" +\n+        \"Stm098pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqam\" +\n+        \"v5YnCKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P\" +\n+        \"8X2praOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sO\" +\n+        \"rwjCQKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQABAoIBADn6sXOynoiUC1IP\" +\n+        \"sck8lGOTSjSSujfyrVCSsJlJV6qCfuX9va6rS8QDjjnBu531PtxoSHxoPizy2Pvg\" +\n+        \"W+kKATPGR\/am9DjLuFlKq7GRjoYfWyMEdVtGaKvq9ng4fBF6LHyjHz0VFrPyhQJ6\" +\n+        \"TovHeXzCguYBkzAlnbAeb\/vqzs\/kABbOuSHVi7DsaixCoEX9zOptFYQw\/l8rh68+\" +\n+        \"UF2bpNNH3jOC1uN3vZtuSwCupqtN+2Mpkx2h04Rk75vWIhrnPeMgmcd3yP4LNZMR\" +\n+        \"mfaynb63RRzVkNis7+NVk016SQ1oL79mrBvy5rBg3HeCeArwvqZAmOaWsLSWHzCy\" +\n+        \"zlVlMTECgYEA6JlnMpC956Qi8HX5ye4Hu2ovBdbNGtH\/TMkZmColJz9P7CvNkNIb\" +\n+        \"Od6mvLMydbPHkhdBUDWD4rhiCKHrf5zKju1i24YqWcvuSGotWj4\/KQ3+87mLZM+7\" +\n+        \"daBsJBmSEVB80sgA9ItqSgOyNoNFpiDgFnlszAfb0n9XXEzB\/pwSw1UCgYEA5eXI\" +\n+        \"d+eKugugP+n6CluQfyxfN6WWCzfqWToCTTxPn2i12AiEssXy+kyLjupJVLWSivdo\" +\n+        \"83wD5LuxFRGc9P+aKQERPhb0AFaxf1llUCXla65\/x2So5xjMvtuzgQ0OktPJqJXq\" +\n+        \"hYGunctsr5rje33+7vlx4xWkrL2PrQWzJabn7SUCgYEAqw3FesY\/Ik7u8u+P1xSZ\" +\n+        \"0xXvptek1oiAu7NYgzLbR9WjrQc5kbsyEojPDg6qmSyxI5q+iYIRj3YRgk+xpJNl\" +\n+        \"0154SQCNvKPghJiw6aDFSifkytA01tp9\/a8QWCwF433RjiFPsoekjvHQ6Y34dofO\" +\n+        \"xDhf7lwJKPBFCrfYIqocklECgYAIPI9OHHGP8NKw94UJ0fX\/WGug5sHVbQ9sWvOy\" +\n+        \"KLMBlxLMxqFadlUaOpvVZvdxnX++ktajwpGxJDhX9OWWsYGobm1buB7N1E1Prrg+\" +\n+        \"gt0RWpMhZa3Xeb\/8Jorr2Lfo8sWK0LQyTE8hQCSIthfoWL9FeJJn\/GKF\/dSj8kxU\" +\n+        \"0QIGMQKBgG\/8U\/zZ87DzfXS81P1p+CmH474wmou4KD2\/zXp\/lDR9+dlIUeijlIbU\" +\n+        \"P6Y5xJvT33Y40giW9irShgDHjZgw0ap11K3b2HzLImdPEaBiENo735rpLs8WLK9H\" +\n+        \"+yeRbiP2y9To7sTihm9Jrkctzp6sqFtKyye1+S21X1tMz8NGfXen\";\n+\n+    private static final String PKCS1_PUB_STR =\n+        \/\/ the BASE64 string between -----BEGIN RSA PUBLIC KEY-----\n+        \/\/ and -----END RSA PUBLIC KEY-----\n+        \"MIIBCgKCAQEA0OIArlYES4X1XMTLDordtN\/XIWFE1wvhl40RsHWM2n99+StpCCJC\" +\n+        \"cUb5FJ2\/kefj\/XRwB6p5IMpIZrHZqC8XXzlX5fpiFaSu2xnk17oWUKoErW27Stm0\" +\n+        \"98pU2RoUxWPKVl+42a8iVp8tijNElBNFALCGi0zXOhcTxMh0q1Wk0UhMJqamv5Yn\" +\n+        \"CKmT4THwwGYn\/KeK3M7Qa+o5MoVBHLbeT9LJgEmSluVzIh44Lh6weX0bw72P8X2p\" +\n+        \"raOhbzg2B343MqS\/rMLw6On+0i7ccEgp23vX9G5w85q4A5FSIrk4S\/pyv5sOrwjC\" +\n+        \"QKBW1TS0\/2iB9zNkFMj5\/+h7l2oqTT7sSQIDAQAB\";\n+\n+\n+    private static final PrivateKey P1_PRIV;\n+    private static final PublicKey P1_PUB;\n+\n+    static {\n+        byte[] encodedPriv = Base64.getDecoder().decode(PKCS1_PRIV_STR);\n+        P1_PRIV = new PrivateKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPriv;\n+            }\n+        };\n+        byte[] encodedPub = Base64.getDecoder().decode(PKCS1_PUB_STR);\n+        P1_PUB = new PublicKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"RSA\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return \"PKCS#1\";\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                \/\/ skip cloning for testing key.\n+                return encodedPub;\n+            }\n+        };\n+    }\n+\n@@ -66,1 +144,1 @@\n-                throw new Exception(\"Format not PKCS#8\");\n+                throw new Exception(\"Format not PKCS#8: \" + key2.getFormat());\n@@ -69,2 +147,5 @@\n-        if (key1.equals(key2) == false) {\n-            throw new Exception(\"Keys not equal\");\n+        \/\/ skip equals check when key1 is custom key\n+        if (key1 != P1_PRIV && key1 != P1_PUB) {\n+            if (!key1.equals(key2)) {\n+                throw new Exception(\"Keys not equal\");\n+            }\n@@ -72,1 +153,4 @@\n-        if (Arrays.equals(key1.getEncoded(), key2.getEncoded()) == false) {\n+\n+        \/\/ only compare encodings if keys are of the same format\n+        if (key1.getFormat().equals(key2.getFormat()) &&\n+            !Arrays.equals(key1.getEncoded(), key2.getEncoded())) {\n@@ -77,2 +161,5 @@\n-    private static void testPublic(KeyFactory kf, PublicKey key) throws Exception {\n-        System.out.println(\"Testing public key...\");\n+    private static void testPublic(KeyFactory kf, PublicKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == P1_PUB? \"PKCS#1\" : \"\") +\n+            \" public key...\");\n+\n@@ -84,3 +171,3 @@\n-        KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n-        PublicKey key5 = kf.generatePublic(x509Spec2);\n-        testKey(key, key);\n+        if (key != P1_PUB) {\n+            testKey(key, key);\n+        }\n@@ -90,1 +177,6 @@\n-        testKey(key, key5);\n+\n+        if (key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+            KeySpec x509Spec2 = new X509EncodedKeySpec(key.getEncoded());\n+            PublicKey key5 = kf.generatePublic(x509Spec2);\n+            testKey(key, key5);\n+        }\n@@ -93,2 +185,4 @@\n-    private static void testPrivate(KeyFactory kf, PrivateKey key) throws Exception {\n-        System.out.println(\"Testing private key...\");\n+    private static void testPrivate(KeyFactory kf, PrivateKey key)\n+            throws Exception {\n+        System.out.println(\"Testing \" + (key == P1_PRIV? \"PKCS#1\" : \"\") +\n+            \" private key...\");\n@@ -100,3 +194,3 @@\n-        KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n-        PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n-        testKey(key, key);\n+        if (key != P1_PRIV) {\n+            testKey(key, key);\n+        }\n@@ -106,1 +200,5 @@\n-        testKey(key, key5);\n+        if (key.getFormat().equalsIgnoreCase(\"PKCS#8\")) {\n+            KeySpec pkcs8Spec2 = new PKCS8EncodedKeySpec(key.getEncoded());\n+            PrivateKey key5 = kf.generatePrivate(pkcs8Spec2);\n+            testKey(key, key5);\n+        }\n@@ -144,0 +242,4 @@\n+        \/\/ repeat the test w\/ PKCS#1 RSA Private Key\n+        test(kf, P1_PRIV);\n+        test(kf, P1_PUB);\n+\n","filename":"test\/jdk\/sun\/security\/rsa\/TestKeyFactory.java","additions":120,"deletions":18,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8242897\n+ * @summary Ensure that RSA key factory can parse X.509 encodings containing\n+ * non-standard RSA oid as in older JDK releases before JDK-8146293\n+ * @run main TestRSAOidSupport\n+ *\/\n+\n+import java.security.KeyFactory;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+\n+public class TestRSAOidSupport {\n+\n+    \/\/ SubjectKeyInfo DER encoding w\/ Algorithm id 1.3.14.3.2.15\n+    \/\/ which can be used to generate RSA Public Key before PSS\n+    \/\/ support is added\n+    private static String DER_BYTES =\n+             \"3058300906052b0e03020f0500034b003048024100d7157c65e8f22557d8\" +\n+             \"a857122cfe85bddfaba3064c21b345e2a7cdd8a6751e519ab861c5109fb8\" +\n+             \"8cce45d161b9817bc0eccdc30fda69e62cc577775f2c1d66bd0203010001\";\n+\n+    \/\/ utility method for converting hex string to byte array\n+    static byte[] toByteArray(String s) {\n+        byte[] bytes = new byte[s.length() \/ 2];\n+        for (int i = 0; i < bytes.length; i++) {\n+            int index = i * 2;\n+            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n+            bytes[i] = (byte) v;\n+        }\n+        return bytes;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        X509EncodedKeySpec x509Spec = new X509EncodedKeySpec\n+                (toByteArray(DER_BYTES));\n+        String keyAlgo = \"RSA\";\n+        KeyFactory kf = KeyFactory.getInstance(keyAlgo, \"SunRsaSign\");\n+        RSAPublicKey rsaKey = (RSAPublicKey) kf.generatePublic(x509Spec);\n+\n+        if (rsaKey.getAlgorithm() != keyAlgo) {\n+            throw new RuntimeException(\"Key algo should be \" + keyAlgo +\n+                    \", but got \" + rsaKey.getAlgorithm());\n+        }\n+        kf = KeyFactory.getInstance(\"RSASSA-PSS\", \"SunRsaSign\");\n+        try {\n+            kf.generatePublic(x509Spec);\n+            throw new RuntimeException(\"Should throw IKSE\");\n+        } catch (InvalidKeySpecException ikse) {\n+            System.out.println(\"Expected IKSE exception thrown\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/rsa\/TestRSAOidSupport.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8168261\n+ * @summary Use server cipher suites preference by default\n+ * @run main\/othervm DefaultCipherSuitePreference\n+ *\/\n+\n+import javax.net.SocketFactory;\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManager;\n+\n+public class DefaultCipherSuitePreference {\n+    private static final String[] contextAlgorithms = {\n+            \"Default\", \"SSL\", \"TLS\", \"SSLv3\", \"TLSv1\",\n+            \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\"\n+        };\n+\n+    public static void main(String[] args) throws Exception {\n+        for (String algorithm : contextAlgorithms) {\n+            System.out.println(\"Checking SSLContext of \" + algorithm);\n+            SSLContext sslContext = SSLContext.getInstance(algorithm);\n+\n+            \/\/ Default SSLContext is initialized automatically.\n+            if (!algorithm.equals(\"Default\")) {\n+                \/\/ Use default TK, KM and random.\n+                sslContext.init((KeyManager[])null, (TrustManager[])null, null);\n+            }\n+\n+            \/\/\n+            \/\/ Check SSLContext\n+            \/\/\n+            \/\/ Check default SSLParameters of SSLContext\n+            checkDefaultCipherSuitePreference(\n+                    sslContext.getDefaultSSLParameters(),\n+                    \"SSLContext.getDefaultSSLParameters()\");\n+\n+            \/\/ Check supported SSLParameters of SSLContext\n+            checkDefaultCipherSuitePreference(\n+                    sslContext.getSupportedSSLParameters(),\n+                    \"SSLContext.getSupportedSSLParameters()\");\n+\n+            \/\/\n+            \/\/ Check SSLEngine\n+            \/\/\n+            \/\/ Check SSLParameters of SSLEngine\n+            SSLEngine engine = sslContext.createSSLEngine();\n+            engine.setUseClientMode(true);\n+            checkDefaultCipherSuitePreference(\n+                    engine.getSSLParameters(),\n+                    \"client mode SSLEngine.getSSLParameters()\");\n+\n+            engine.setUseClientMode(false);\n+            checkDefaultCipherSuitePreference(\n+                    engine.getSSLParameters(),\n+                    \"server mode SSLEngine.getSSLParameters()\");\n+\n+            \/\/\n+            \/\/ Check SSLSocket\n+            \/\/\n+            \/\/ Check SSLParameters of SSLSocket\n+            SocketFactory fac = sslContext.getSocketFactory();\n+            SSLSocket socket = (SSLSocket)fac.createSocket();\n+            checkDefaultCipherSuitePreference(\n+                    socket.getSSLParameters(),\n+                    \"SSLSocket.getSSLParameters()\");\n+\n+            \/\/\n+            \/\/ Check SSLServerSocket\n+            \/\/\n+            \/\/ Check SSLParameters of SSLServerSocket\n+            SSLServerSocketFactory sf = sslContext.getServerSocketFactory();\n+            SSLServerSocket ssocket = (SSLServerSocket)sf.createServerSocket();\n+            checkDefaultCipherSuitePreference(\n+                    ssocket.getSSLParameters(),\n+                    \"SSLServerSocket.getSSLParameters()\");\n+        }\n+    }\n+\n+    private static void checkDefaultCipherSuitePreference(\n+            SSLParameters parameters, String context) throws Exception {\n+        if (!parameters.getUseCipherSuitesOrder()) {\n+            throw new Exception(\n+                    \"The local cipher suite preference is not honored \" +\n+                    \"in the connection populated SSLParameters object (\" +\n+                    context + \")\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLContextImpl\/DefaultCipherSuitePreference.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -129,0 +129,4 @@\n+<<<<<<< HEAD\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\n+                    Utils.addTestJavaOpts(\"SSLEngineKeyLimit\", \"p\", args[1]));\n+=======\n@@ -132,0 +136,1 @@\n+>>>>>>> a829804de566fb89ad0fe45d242a09db24a5867c\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true,\n+            ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -46,1 +48,0 @@\n-import java.nio.file.Path;\n@@ -48,0 +49,1 @@\n+import java.nio.file.Path;\n@@ -50,1 +52,0 @@\n-import java.util.Arrays;\n@@ -52,0 +53,1 @@\n+import java.util.Arrays;\n@@ -60,0 +62,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -62,1 +65,0 @@\n-import java.util.jar.Manifest;\n@@ -64,1 +66,1 @@\n-import java.util.concurrent.TimeUnit;\n+import java.util.jar.Manifest;\n@@ -67,0 +69,1 @@\n+\n@@ -71,2 +74,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -182,1 +183,1 @@\n-        boolean failed = generateReport(tsaList, signItems);\n+        boolean failed = generateReport(jdkInfoList, tsaList, signItems);\n@@ -418,0 +419,1 @@\n+        int index = 0;\n@@ -423,0 +425,3 @@\n+                jdkInfo.index = index++;\n+                jdkInfo.version = String.format(\n+                        \"%s(%d)\", jdkInfo.version, jdkInfo.index);\n@@ -911,1 +916,1 @@\n-    private static boolean generateReport(List<TsaInfo> tsaList,\n+    private static boolean generateReport(List<JdkInfo> jdkList, List<TsaInfo> tsaList,\n@@ -918,0 +923,9 @@\n+\n+        \/\/ Generates JDK list\n+        report.append(\"JDK list:\\n\");\n+        for(JdkInfo jdkInfo : jdkList) {\n+            report.append(String.format(\"%d=%s%n\",\n+                    jdkInfo.index,\n+                    jdkInfo.runtimeVersion));\n+        }\n+\n@@ -1027,0 +1041,1 @@\n+        private int index;\n@@ -1029,1 +1044,2 @@\n-        private final String version;\n+        private final String runtimeVersion;\n+        private String version;\n@@ -1037,2 +1053,3 @@\n-            version = execJdkUtils(jdkPath, JdkUtils.M_JAVA_RUNTIME_VERSION);\n-            if (version == null || version.isBlank()) {\n+            jarsignerPath = jarsignerPath(jdkPath);\n+            runtimeVersion = execJdkUtils(jdkPath, JdkUtils.M_JAVA_RUNTIME_VERSION);\n+            if (runtimeVersion == null || runtimeVersion.isBlank()) {\n@@ -1042,3 +1059,3 @@\n-            majorVersion = Integer.parseInt((version.matches(\"^1[.].*\") ?\n-                 version.substring(2) : version).replaceAll(\"[^0-9].*$\", \"\"));\n-            jarsignerPath = jarsignerPath(jdkPath);\n+            version = execJdkUtils(jdkPath, JdkUtils.M_JAVA_VERSION);\n+            majorVersion = Integer.parseInt((runtimeVersion.matches(\"^1[.].*\") ?\n+                    runtimeVersion.substring(2) : runtimeVersion).replaceAll(\"[^0-9].*$\", \"\"));\n@@ -1076,1 +1093,1 @@\n-                    + ((version == null) ? 0 : version.hashCode());\n+                    + ((runtimeVersion == null) ? 0 : runtimeVersion.hashCode());\n@@ -1089,2 +1106,2 @@\n-            if (version == null) {\n-                if (other.version != null)\n+            if (runtimeVersion == null) {\n+                if (other.runtimeVersion != null)\n@@ -1092,1 +1109,1 @@\n-            } else if (!version.equals(other.version))\n+            } else if (!runtimeVersion.equals(other.runtimeVersion))\n@@ -1099,1 +1116,1 @@\n-            return \"JdkInfo[\" + version + \", \" + jdkPath + \"]\";\n+            return \"JdkInfo[\" + runtimeVersion + \", \" + jdkPath + \"]\";\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    static final String M_JAVA_VERSION = \"javaVersion\";\n@@ -45,0 +46,5 @@\n+    static String javaVersion() {\n+        return System.getProperty(\"java.version\");\n+    }\n+\n+    \/\/ Returns the JDK build runtime version.\n@@ -66,1 +72,3 @@\n-        if (M_JAVA_RUNTIME_VERSION.equals(args[0])) {\n+        if (M_JAVA_VERSION.equals(args[0])) {\n+            System.out.print(javaVersion());\n+        } else if (M_JAVA_RUNTIME_VERSION.equals(args[0])) {\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/compatibility\/JdkUtils.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8242151\n@@ -1602,1 +1603,1 @@\n-                        .getExtension(new ObjectIdentifier(oid));\n+                        .getExtension(ObjectIdentifier.of(oid));\n@@ -1611,1 +1612,1 @@\n-                .getExtension(new ObjectIdentifier(\"1.2.3\")).isCritical());\n+                .getExtension(ObjectIdentifier.of(\"1.2.3\")).isCritical());\n@@ -1613,1 +1614,1 @@\n-                .getExtension(new ObjectIdentifier(\"1.2.3\")).isCritical());\n+                .getExtension(ObjectIdentifier.of(\"1.2.3\")).isCritical());\n@@ -1643,3 +1644,3 @@\n-        assertTrue(a.getExtension(new ObjectIdentifier(\"1.2.3\")).isCritical());\n-        assertTrue(!a.getExtension(new ObjectIdentifier(\"1.2.4\")).isCritical());\n-        assertTrue(!a.getExtension(new ObjectIdentifier(\"1.2.5\")).isCritical());\n+        assertTrue(a.getExtension(ObjectIdentifier.of(\"1.2.3\")).isCritical());\n+        assertTrue(!a.getExtension(ObjectIdentifier.of(\"1.2.4\")).isCritical());\n+        assertTrue(!a.getExtension(ObjectIdentifier.of(\"1.2.5\")).isCritical());\n@@ -1650,1 +1651,1 @@\n-        assertTrue(!a.getExtension(new ObjectIdentifier(\"2.3.4\")).isCritical());\n+        assertTrue(!a.getExtension(ObjectIdentifier.of(\"2.3.4\")).isCritical());\n@@ -1660,2 +1661,2 @@\n-        assertTrue(!b.getExtension(new ObjectIdentifier(\"1.2.3\")).isCritical());\n-        assertTrue(b.getExtension(new ObjectIdentifier(\"1.2.4\")).isCritical());\n+        assertTrue(!b.getExtension(ObjectIdentifier.of(\"1.2.3\")).isCritical());\n+        assertTrue(b.getExtension(ObjectIdentifier.of(\"1.2.4\")).isCritical());\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-import sun.security.x509.AlgorithmId;\n-import static sun.security.rsa.RSAUtil.KeyType;\n+import sun.security.rsa.RSAUtil.KeyType;\n@@ -47,1 +46,1 @@\n-    private AlgorithmId rsaId;\n+    private AlgorithmParameterSpec keyParams;\n@@ -101,1 +100,1 @@\n-            this.rsaId = RSAUtil.createAlgorithmId(type, tmpParams);\n+            this.keyParams = RSAUtil.checkParamsAgainstType(type, tmpParams);\n@@ -539,1 +538,1 @@\n-            PublicKey publicKey = new RSAPublicKeyImpl(rsaId, n, e);\n+            PublicKey publicKey = new RSAPublicKeyImpl(type, keyParams, n, e);\n@@ -541,1 +540,1 @@\n-                    rsaId, n, e, d, p, q, pe, qe, coeff);\n+                    type, keyParams, n, e, d, p, q, pe, qe, coeff);\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/java.base\/sun\/security\/rsa\/RSAKeyPairGenerator.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8022444\n+ * @bug 8022444 8242151\n@@ -35,4 +35,2 @@\n-        ObjectIdentifier oid1 = new ObjectIdentifier(\"1.3.6.1.4.1.42.2.17\");\n-        ObjectIdentifier oid2 =\n-                new ObjectIdentifier(new int[]{1, 3, 6, 1, 4, 1, 42, 2, 17});\n-        ObjectIdentifier oid3 = new ObjectIdentifier(\"1.2.3.4\");\n+        ObjectIdentifier oid1 = ObjectIdentifier.of(\"1.3.6.1.4.1.42.2.17\");\n+        ObjectIdentifier oid2 = ObjectIdentifier.of(\"1.2.3.4\");\n@@ -41,2 +39,1 @@\n-        assertEquals(oid1, oid2);\n-        assertNotEquals(oid1, oid3);\n+        assertNotEquals(oid1, oid2);\n","filename":"test\/jdk\/sun\/security\/util\/Oid\/OidEquals.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @bug 6418422\n- * @bug 6418425\n- * @bug 6418433\n+ * @bug 6418422 6418425 6418433 8242151\n@@ -89,46 +87,0 @@\n-\n-        int[][] goodInts = {\n-            {0,0}, {0,1}, {1,0}, {1,2},\n-            {0,39}, {1,39}, {2,47}, {2,40,3,6}, {2,100,3}, {2,123456,3},\n-            {1,2,3}, {1,2,3445},\n-            {1,3,6,1,4,1,42,2,17},\n-        };\n-\n-        for (int[] is: goodInts) {\n-            testGood(is);\n-        }\n-\n-        int[][] badInts = new int[][] {\n-            {0}, {1}, {2},\n-            {3,1,1}, {3}, {4},\n-            {1,40}, {1,111,1},\n-            {-1,2}, {0,-2}, {1,-2}, {2,-2},\n-            {1,2,-3,4}, {1,2,3,-4},\n-        };\n-\n-        for (int[] is: badInts) {\n-            testBad(is);\n-        }\n-\n-    }\n-\n-    static void testBad(int[] ints) throws Exception {\n-        System.err.println(\"Trying \" + Arrays.toString(ints));\n-        try {\n-            new ObjectIdentifier(ints);\n-            throw new Exception(\"should be invalid ObjectIdentifier\");\n-        } catch (IOException ioe) {\n-            System.err.println(ioe);\n-        }\n-    }\n-\n-    static void testGood(int[] ints) throws Exception {\n-        System.err.println(\"Trying \" + Arrays.toString(ints));\n-        ObjectIdentifier oid = new ObjectIdentifier(ints);\n-        DerOutputStream os = new DerOutputStream();\n-        os.putOID(oid);\n-        DerInputStream is = new DerInputStream(os.toByteArray());\n-        ObjectIdentifier oid2 = is.getOID();\n-        if (!oid.equals(oid2)) {\n-            throw new Exception(\"Test DER I\/O fails: \" + oid + \" and \" + oid2);\n-        }\n@@ -139,1 +91,1 @@\n-        ObjectIdentifier oid = new ObjectIdentifier(s);\n+        ObjectIdentifier oid = ObjectIdentifier.of(s);\n@@ -155,1 +107,1 @@\n-            new ObjectIdentifier(s);\n+            ObjectIdentifier.of(s);\n","filename":"test\/jdk\/sun\/security\/util\/Oid\/OidFormat.java","additions":4,"deletions":52,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4811968 6908628 8006564 8130696\n+ * @bug 4811968 6908628 8006564 8130696 8242151\n@@ -121,1 +121,1 @@\n-        new ObjectOutputStream(bout).writeObject(new ObjectIdentifier(oid));\n+        new ObjectOutputStream(bout).writeObject(ObjectIdentifier.of(oid));\n","filename":"test\/jdk\/sun\/security\/util\/Oid\/S11N.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 4170635\n+ * @bug 4170635 8242151\n@@ -43,2 +43,0 @@\n-        int data[] = { 1, 2, 840, 113549, 2, 5 };\n-\n@@ -49,1 +47,1 @@\n-        ObjectIdentifier oid = new ObjectIdentifier(data);\n+        ObjectIdentifier oid = ObjectIdentifier.of(\"1.2.840.113549.2.5\");\n","filename":"test\/jdk\/sun\/security\/x509\/AVA\/AVAEqualsHashCode.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4162868 8130181\n+ * @bug 4162868 8130181 8242151\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/sun.security.util\n@@ -42,2 +43,10 @@\n-        AlgorithmId algid = AlgorithmId.getAlgorithmId(\"XYZ\");\n-        String alias = \"Alg.Alias.Signature.OID.\" + algid.toString();\n+        AlgorithmId algid = AlgorithmId.getAlgorithmId(TestProvider.ALG_NAME);\n+        String oid = algid.getOID().toString();\n+        if (!oid.equals(TestProvider.ALG_OID)) {\n+            throw new Exception(\"Provider alias oid not used, found \" + oid);\n+        }\n+        String name = algid.getName();\n+        if (!name.equalsIgnoreCase(TestProvider.ALG_NAME)) {\n+            throw new Exception(\"provider alias name not used, found \" + name);\n+        }\n+        String alias = \"Alg.Alias.Signature.OID.\" + oid;\n@@ -45,1 +54,2 @@\n-        if (stdAlgName == null || !stdAlgName.equalsIgnoreCase(\"XYZ\")) {\n+        if (stdAlgName == null ||\n+                !stdAlgName.equalsIgnoreCase(TestProvider.ALG_NAME)) {\n@@ -49,1 +59,0 @@\n-}\n@@ -51,1 +60,1 @@\n-class TestProvider extends Provider {\n+    static class TestProvider extends Provider {\n@@ -53,1 +62,4 @@\n-    public TestProvider() {\n+        static String ALG_OID = \"1.2.3.4.5.6.7.8.9.0\";\n+        static String ALG_NAME = \"XYZ\";\n+\n+        public TestProvider() {\n@@ -56,2 +68,2 @@\n-        AccessController.doPrivileged(new PrivilegedAction() {\n-            public Object run() {\n+            AccessController.doPrivileged(new PrivilegedAction() {\n+                public Object run() {\n@@ -59,9 +71,10 @@\n-                put(\"Signature.XYZ\", \"test.xyz\");\n-                \/\/ preferred OID\n-                put(\"Alg.Alias.Signature.OID.1.2.3.4.5.6.7.8.9.0\",\n-                    \"XYZ\");\n-                put(\"Alg.Alias.Signature.9.8.7.6.5.4.3.2.1.0\",\n-                    \"XYZ\");\n-                return null;\n-            }\n-        });\n+                    put(\"Signature.\" + ALG_NAME, \"test.xyz\");\n+                    \/\/ preferred OID\n+                    put(\"Alg.Alias.Signature.OID.\" + ALG_OID,\n+                        ALG_NAME);\n+                    put(\"Alg.Alias.Signature.9.8.7.6.5.4.3.2.1.0\",\n+                        ALG_NAME);\n+                    return null;\n+                }\n+            });\n+        }\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/ExtensibleAlgorithmId.java","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8049237\n+ * @bug 8049237 8242151\n@@ -156,1 +156,0 @@\n-        int[] oidData = new int[]{1, 2, 3, 4};\n@@ -158,1 +157,2 @@\n-        GeneralNameInterface oidInf = new OIDName(new ObjectIdentifier(oidData));\n+        GeneralNameInterface oidInf =\n+                new OIDName(ObjectIdentifier.of(\"1.2.3.4\"));\n","filename":"test\/jdk\/sun\/security\/x509\/X509CertImpl\/V3Certificate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 4273559\n+ * @bug 4273559 8242151\n@@ -117,1 +117,1 @@\n-        ObjectIdentifier oid = new ObjectIdentifier(name);\n+        ObjectIdentifier oid = ObjectIdentifier.of(name);\n","filename":"test\/jdk\/sun\/security\/x509\/equalNames\/AltNamesEqualsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -371,0 +371,20 @@\n+    @Test\n+    public void upgradeableModule() throws IOException {\n+        Path mpath = Paths.get(System.getProperty(\"java.home\"), \"jmods\");\n+        if (!Files.exists(mpath)) {\n+            return;\n+        }\n+\n+        makeModule(\"m1\");\n+        makeModule(\"java.compiler\", \"m1\");\n+        makeModule(\"m2\", \"java.compiler\");\n+\n+        makeJmod(\"m1\");\n+        makeJmod(\"m2\");\n+        makeJmod(\"java.compiler\",\n+                    \"--module-path\",\n+                    lib.toString() + File.pathSeparator + mpath,\n+                    \"--hash-modules\", \"java\\\\.(?!se)|^m.*\");\n+\n+        checkHashes(\"java.compiler\",  Set.of(\"m2\"));\n+    }\n","filename":"test\/jdk\/tools\/jmod\/hashes\/HashesTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.compiler\n+ * @modules java.compiler\n+ *          jdk.compiler\n@@ -54,0 +55,1 @@\n+    private static final Path UPGRADE_MODS_DIRS = Paths.get(\"upgrademods\");\n@@ -59,1 +61,3 @@\n-\n+    \/\/ test module m2 uses java.compiler internals\n+    private static final String TEST2_MODULE = \"m2\";\n+    private static final String TEST2_MAIN_CLASS = \"jdk.test2.Main\";\n@@ -77,0 +81,5 @@\n+        \/\/ javac -d upgrademods\/java.compiler src\/java.compiler\/**\n+        compiled = CompilerUtils.compile(\n+                SRC_DIR.resolve(\"java.compiler\"),\n+                UPGRADE_MODS_DIRS.resolve(\"java.compiler\"));\n+        assertTrue(compiled, \"module java.compiler did not compile\");\n@@ -78,0 +87,7 @@\n+        \/\/ javac --upgrade-module-path upgrademods -d mods\/m2 src\/m2\/**\n+        compiled = CompilerUtils.compile(\n+                SRC_DIR.resolve(TEST2_MODULE),\n+                MODS_DIR.resolve(TEST2_MODULE),\n+                \"--upgrade-module-path\", UPGRADE_MODS_DIRS.toString(),\n+                \"--add-exports\", \"java.compiler\/javax.tools.internal=m2\");\n+        assertTrue(compiled, \"module \" + TEST2_MODULE + \" did not compile\");\n@@ -149,0 +165,16 @@\n+    \/**\n+     * Test --add-exports with upgraded module\n+     *\/\n+    public void testWithUpgradedModule() throws Exception {\n+\n+        \/\/ java --add-exports java.compiler\/javax.tools.internal=m2\n+        \/\/      --upgrade-module-path upgrademods --module-path mods -m ...\n+        String mid = TEST2_MODULE + \"\/\" + TEST2_MAIN_CLASS;\n+        int exitValue = executeTestJava(\n+                \"--add-exports\", \"java.compiler\/javax.tools.internal=m2\",\n+                \"--upgrade-module-path\", UPGRADE_MODS_DIRS.toString(),\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"-m\", mid)\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue();\n@@ -150,0 +182,2 @@\n+        assertTrue(exitValue == 0);\n+    }\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/AddExportsTest.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+package javax.annotation.processing;\n@@ -26,0 +27,1 @@\n+public interface Generated {\n@@ -27,1 +29,2 @@\n-provides jdk.internal.org.jline.terminal.spi.JnaSupport with jdk.internal.org.jline.terminal.impl.jna.JnaSupportImpl;\n+\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/java.compiler\/javax\/annotation\/processing\/Generated.java","additions":4,"deletions":1,"binary":false,"changes":5,"previous_filename":"src\/jdk.internal.le\/windows\/classes\/module-info.java.extra","status":"renamed"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.tools;\n+\n+public class ToolsHelper {\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/java.compiler\/javax\/tools\/ToolsHelper.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.tools.internal;\n+\n+public class Helper {\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/java.compiler\/javax\/tools\/internal\/Helper.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module java.compiler {\n+    exports javax.tools;\n+    exports javax.annotation.processing;\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/java.compiler\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/**\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test2;\n+\n+import javax.tools.internal.Helper;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        Helper h = new Helper();\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/m2\/jdk\/test2\/Main.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m2 {\n+    requires java.compiler;\n+}\n","filename":"test\/jdk\/tools\/launcher\/modules\/addexports\/src\/m2\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -327,1 +327,1 @@\n-        return \"\" + WB.isJFRIncludedInVmBuild();\n+        return \"\" + WB.isJFRIncluded();\n@@ -401,1 +401,1 @@\n-        return \"\" + WB.isCDSIncludedInVmBuild();\n+        return \"\" + WB.isCDSIncluded();\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+                \"-sourcepath\", System.getProperty(\"test.src.path\"),\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/InheritDocForUserTags\/DocTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n- *      @Test\n+ *      {@literal @}Test\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/lib\/JavadocTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -38,0 +39,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -40,2 +42,2 @@\n-    public ExecPtyGetFlagsToSetTest(String name, boolean system) {\n-        super(name, system);\n+    public ExecPtyGetFlagsToSetTest(String name, TerminalProvider.Stream stream) {\n+        super(name, stream);\n@@ -51,1 +53,1 @@\n-            new ExecPtyGetFlagsToSetTest(\"stty\", true);\n+            new ExecPtyGetFlagsToSetTest(\"stty\", TerminalProvider.Stream.Output);\n","filename":"test\/langtools\/jdk\/jshell\/ExecPtyGetFlagsToSetTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-  java=\"${TESTJAVA+${TESTJAVA}\/bin\/}java\"\n- javac=\"${TESTJAVA+${TESTJAVA}\/bin\/}javac\"\n-   jar=\"${TESTJAVA+${TESTJAVA}\/bin\/}jar\"\n-jimage=\"${TESTJAVA+${TESTJAVA}\/bin\/}jimage\"\n+  java=\"${TESTJAVA+${TESTJAVA}\/bin\/}java${EXE_SUFFIX}\"\n+ javac=\"${TESTJAVA+${TESTJAVA}\/bin\/}javac${EXE_SUFFIX}\"\n+   jar=\"${TESTJAVA+${TESTJAVA}\/bin\/}jar${EXE_SUFFIX}\"\n+jimage=\"${TESTJAVA+${TESTJAVA}\/bin\/}jimage${EXE_SUFFIX}\"\n","filename":"test\/langtools\/tools\/javac\/Paths\/Util.sh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -196,0 +196,12 @@\n+    \/**\n+     * Combines given arguments with default JTReg arguments for a jvm running a test.\n+     * This is the combination of JTReg arguments test.vm.opts and test.java.opts\n+     * @return The combination of JTReg test java options and user args.\n+     *\/\n+    public static String[] prependTestJavaOpts(String... userArgs) {\n+        List<String> opts = new ArrayList<String>();\n+        Collections.addAll(opts, getTestJavaOpts());\n+        Collections.addAll(opts, userArgs);\n+        return opts.toArray(new String[0]);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmdLine);\n@@ -412,1 +412,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(cmdLine);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public static final double ERROR_MARGIN = 0.1;\n+    public static final double ERROR_MARGIN = 0.25;\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.nio.file.FileVisitOption;\n@@ -39,0 +40,1 @@\n+import java.util.EnumSet;\n@@ -167,1 +169,1 @@\n-        Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));\n+        Files.walkFileTree(jdkSrcDir, EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE, new CopyFileVisitor(jdkSrcDir, jdkDstDir));\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, arguments.toArray(new String[0]));\n+        ProcessBuilder pb = ProcessTools.createTestJvm(arguments);\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/AppExecutorHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,13 +280,1 @@\n-        return createJavaProcessBuilder(false, command);\n-    }\n-\n-    \/**\n-     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n-     * <p>\n-     * @param addTestVmAndJavaOptions If true, adds test.vm.opts and test.java.opts\n-     *        to the java arguments.\n-     * @param command Arguments to pass to the java command.\n-     * @return The ProcessBuilder instance representing the java command.\n-     *\/\n-    public static ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions, List<String> command) {\n-        return createJavaProcessBuilder(addTestVmAndJavaOptions, command.toArray(String[]::new));\n+        return createJavaProcessBuilder(command.toArray(String[]::new));\n@@ -302,12 +290,0 @@\n-        return createJavaProcessBuilder(false, command);\n-    }\n-\n-    \/**\n-     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n-     *\n-     * @param addTestVmAndJavaOptions If true, adds test.vm.opts and test.java.opts\n-     *        to the java arguments.\n-     * @param command Arguments to pass to the java command.\n-     * @return The ProcessBuilder instance representing the java command.\n-     *\/\n-    public static ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions, String... command) {\n@@ -322,4 +298,0 @@\n-        if (addTestVmAndJavaOptions) {\n-            Collections.addAll(args, Utils.getTestJavaOpts());\n-        }\n-\n@@ -347,0 +319,30 @@\n+    \/**\n+     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n+     * The default jvm options from jtreg, test.vm.opts and test.java.opts, are added.\n+     *\n+     * The command line will be like:\n+     * {test.jdk}\/bin\/java {test.vm.opts} {test.java.opts} cmds\n+     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n+     *\n+     * @param command Arguments to pass to the java command.\n+     * @return The ProcessBuilder instance representing the java command.\n+     *\/\n+    public static ProcessBuilder createTestJvm(List<String> command) {\n+        return createTestJvm(command.toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n+     * The default jvm options from jtreg, test.vm.opts and test.java.opts, are added.\n+     *\n+     * The command line will be like:\n+     * {test.jdk}\/bin\/java {test.vm.opts} {test.java.opts} cmds\n+     * Create ProcessBuilder using the java launcher from the jdk to be tested.\n+     *\n+     * @param command Arguments to pass to the java command.\n+     * @return The ProcessBuilder instance representing the java command.\n+     *\/\n+    public static ProcessBuilder createTestJvm(String... command) {\n+        return createJavaProcessBuilder(Utils.prependTestJavaOpts(command));\n+    }\n+\n@@ -378,1 +380,1 @@\n-        ProcessBuilder pb = createJavaProcessBuilder(true, cmds);\n+        ProcessBuilder pb = createTestJvm(cmds);\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            oid = new ObjectIdentifier(((KnownOIDs) expected).value());\n+            oid = ObjectIdentifier.of(((KnownOIDs) expected).value());\n@@ -106,1 +106,1 @@\n-            oid = new ObjectIdentifier(KnownOIDs.findMatch((String)expected).value());\n+            oid = ObjectIdentifier.of(KnownOIDs.findMatch((String)expected).value());\n","filename":"test\/lib\/jdk\/test\/lib\/security\/DerUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,10 +27,15 @@\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509Certificate;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n+import java.io.IOException;\n+import java.io.SequenceInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.security.cert.Certificate;\n+import java.util.*;\n+\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -125,0 +130,2 @@\n+    private static final CertificateFactory CERTIFICATE_FACTORY = getCertificateFactory();\n+\n@@ -146,1 +153,9 @@\n-    public X509Certificate generate(CertificateFactory cf) throws CertificateException {\n+    private static CertificateFactory getCertificateFactory() {\n+        try {\n+            return CertificateFactory.getInstance(\"X.509\");\n+        } catch (CertificateException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public X509Certificate certificate() throws CertificateException {\n@@ -148,1 +163,39 @@\n-        return (X509Certificate) cf.generateCertificate(is);\n+        return (X509Certificate) CERTIFICATE_FACTORY.generateCertificate(is);\n+    }\n+\n+    public static Collection<? extends Certificate> certificates() throws CertificateException {\n+        ByteArrayInputStream is1 = new ByteArrayInputStream((TestCertificate.ONE.encoded + \"\\n\").getBytes());\n+        ByteArrayInputStream is2 = new ByteArrayInputStream(TestCertificate.TWO.encoded.getBytes());\n+        return CERTIFICATE_FACTORY.generateCertificates(new SequenceInputStream(is1, is2));\n+    }\n+\n+    public static void certPath() throws CertificateException {\n+        CertPath cp = CERTIFICATE_FACTORY.generateCertPath(List.of(TestCertificate.ONE.certificate(),\n+                TestCertificate.TWO.certificate()));\n+\n+        \/\/ Get the encoded form of the CertPath we made\n+        byte[] encoded = cp.getEncoded(\"PKCS7\");\n+        CERTIFICATE_FACTORY.generateCertPath(new ByteArrayInputStream(encoded), \"PKCS7\");\n+    }\n+\n+    public static void keyToolTest() throws Exception {\n+        String config =\n+                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n+                \"<configuration version=\\\"2.0\\\" description=\\\"test\\\">\\n\" +\n+                \"    <event name=\\\"jdk.X509Certificate\\\">\\n\" +\n+                \"       <setting name=\\\"enabled\\\">true<\/setting>\\n\" +\n+                \"       <setting name=\\\"stackTrace\\\">true<\/setting>\\n\" +\n+                \"    <\/event>\\n\" +\n+                \"<\/configuration>\";\n+        Files.writeString(Path.of(\"config.jfc\"), config);\n+\n+        SecurityTools.keytool(\"-J-XX:StartFlightRecording=filename=keytool.jfr,settings=config.jfc\",\n+            \"-genkeypair\", \"-alias\", \"testkey\", \"-keyalg\", \"RSA\", \"-keysize\", \"2048\", \"-dname\",\n+            \"CN=8292033.oracle.com,OU=JPG,C=US\", \"-keypass\", \"changeit\",\n+            \"-validity\", \"365\", \"-keystore\", \"keystore.pkcs12\", \"-storepass\", \"changeit\")\n+            .shouldHaveExitValue(0);\n+        \/\/ The keytool command will load the keystore and call CertificateFactory.generateCertificate\n+        jfrTool(\"keytool.jfr\")\n+            .shouldContain(\"8292033.oracle.com\") \/\/ should record our new cert\n+            .shouldNotContain(\"algorithm = N\/A\") \/\/ shouldn't record cert under construction\n+            .shouldHaveExitValue(0);\n@@ -151,1 +204,8 @@\n-    public static void generateChain(boolean selfSignedTest) throws Exception {\n+    private static OutputAnalyzer jfrTool(String jfrFile) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jfr\"), \"print\", \"--events\",\n+                \"jdk.X509Certificate\", jfrFile});\n+        return new OutputAnalyzer(pb.start());\n+    }\n+\n+    public static void generateChain(boolean selfSignedTest, boolean trustAnchorCert) throws Exception {\n@@ -157,3 +217,3 @@\n-        X509Certificate c1 = TestCertificate.ONE.generate(cf);\n-        X509Certificate c2 = TestCertificate.TWO.generate(cf);\n-        X509Certificate ca = TestCertificate.ROOT_CA.generate(cf);\n+        X509Certificate c1 = TestCertificate.ONE.certificate();\n+        X509Certificate c2 = TestCertificate.TWO.certificate();\n+        X509Certificate ca = TestCertificate.ROOT_CA.certificate();\n@@ -161,1 +221,6 @@\n-        TrustAnchor ta = new TrustAnchor(ca, null);\n+        TrustAnchor ta;\n+        if (trustAnchorCert) {\n+            ta = new TrustAnchor(ca, null);\n+        } else {\n+            ta = new TrustAnchor(ca.getIssuerX500Principal(), ca.getPublicKey(), null);\n+        }\n@@ -175,1 +240,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestCertificate.java","additions":84,"deletions":19,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-            tstInfoOut.putOID(new ObjectIdentifier(policyId));\n+            tstInfoOut.putOID(ObjectIdentifier.of(policyId));\n@@ -207,1 +207,1 @@\n-                    new ObjectIdentifier(\"1.2.840.113549.1.9.16.1.4\"),\n+                    ObjectIdentifier.of(\"1.2.840.113549.1.9.16.1.4\"),\n","filename":"test\/lib\/jdk\/test\/lib\/security\/timestamp\/TsaSigner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n@@ -44,0 +46,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -241,0 +245,87 @@\n+    \/**\n+     * Checks whether all file systems are accessible. This is performed\n+     * by checking free disk space on all mounted file systems via a\n+     * separate, spawned process. File systems are considered to be\n+     * accessible if this process completes successfully before a given\n+     * fixed duration has elapsed.\n+     *\n+     * @implNote On Unix this executes the {@code df} command in a separate\n+     * process and on Windows always returns {@code true}.\n+     *\n+     * @return whether file systems appear to be accessible\n+     *\n+     * @throws RuntimeException if there are duplicate mount points or some\n+     * other execution problem occurs\n+     *\/\n+    public static boolean areAllMountPointsAccessible() {\n+        final AtomicBoolean areMountPointsOK = new AtomicBoolean(true);\n+        if (!IS_WINDOWS) {\n+            Thread thr = new Thread(() -> {\n+                try {\n+                    Process proc = new ProcessBuilder(\"df\").start();\n+                    BufferedReader reader = new BufferedReader\n+                        (new InputStreamReader(proc.getInputStream()));\n+                    \/\/ Skip the first line as it is the \"df\" output header.\n+                    if (reader.readLine() != null ) {\n+                        String prevMountPoint = null, mountPoint = null;\n+                        while ((mountPoint = reader.readLine()) != null) {\n+                            if (prevMountPoint != null &&\n+                                mountPoint.equals(prevMountPoint)) {\n+                                throw new RuntimeException\n+                                    (\"System configuration error: \" +\n+                                    \"duplicate mount point \" + mountPoint +\n+                                    \" detected\");\n+                            }\n+                            prevMountPoint = mountPoint;\n+                        }\n+                    }\n+\n+                    try {\n+                        proc.waitFor(90, TimeUnit.SECONDS);\n+                    } catch (InterruptedException ignored) {\n+                    }\n+                    try {\n+                        int exitValue = proc.exitValue();\n+                        if (exitValue != 0) {\n+                            System.err.printf(\"df process exited with %d != 0%n\",\n+                                exitValue);\n+                            areMountPointsOK.set(false);\n+                        }\n+                    } catch (IllegalThreadStateException ignored) {\n+                        System.err.println(\"df command apparently hung\");\n+                        areMountPointsOK.set(false);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(ioe);\n+                };\n+            });\n+\n+            final AtomicReference throwableReference =\n+                new AtomicReference<Throwable>();\n+            thr.setUncaughtExceptionHandler(\n+                new Thread.UncaughtExceptionHandler() {\n+                    public void uncaughtException(Thread t, Throwable e) {\n+                        throwableReference.set(e);\n+                    }\n+                });\n+\n+            thr.start();\n+            try {\n+                thr.join(120*1000L);\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+\n+            Throwable uncaughtException = (Throwable)throwableReference.get();\n+            if (uncaughtException != null) {\n+                throw new RuntimeException(uncaughtException);\n+            }\n+\n+            if (thr.isAlive()) {\n+                throw new RuntimeException(\"df thread did not join in time\");\n+            }\n+        }\n+\n+        return areMountPointsOK.get();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -523,2 +523,2 @@\n-  public native boolean isCDSIncludedInVmBuild();\n-  public native boolean isJFRIncludedInVmBuild();\n+  public native boolean isCDSIncluded();\n+  public native boolean isJFRIncluded();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/lib\/sun\/hotspot\/code\/Compiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}