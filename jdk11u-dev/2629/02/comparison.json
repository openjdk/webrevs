{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.io.IOException;\n@@ -45,0 +46,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -53,2 +55,0 @@\n-    private static final int MAX_HANDSHAKE_LOOPS = 200;\n-    private static final int MAX_APP_READ_LOOPS = 60;\n@@ -78,2 +78,3 @@\n-    private static Exception clientException = null;\n-    private static Exception serverException = null;\n+    private final AtomicBoolean exceptionOccurred = new AtomicBoolean(false);\n+\n+    private final CountDownLatch serverStarted = new CountDownLatch(1);\n@@ -151,1 +152,1 @@\n-        int loops = MAX_HANDSHAKE_LOOPS;\n+        int loops = 0;\n@@ -153,7 +154,1 @@\n-        while (!endLoops &&\n-                (serverException == null) && (clientException == null)) {\n-\n-            if (--loops < 0) {\n-                throw new RuntimeException(\n-                        \"Too many loops to produce handshake packets\");\n-            }\n+        while (!endLoops && !exceptionOccurred.get()) {\n@@ -162,1 +157,1 @@\n-            log(side, \"=======handshake(\" + loops + \", \" + hs + \")=======\");\n+            log(side, \"=======handshake(\" + ++loops + \", \" + hs + \")=======\");\n@@ -317,7 +312,1 @@\n-        int loops = MAX_APP_READ_LOOPS;\n-        while ((serverException == null) && (clientException == null)) {\n-            if (--loops < 0) {\n-                throw new RuntimeException(\n-                        \"Too much loops to receive application data\");\n-            }\n-\n+        while (!exceptionOccurred.get()) {\n@@ -325,2 +314,2 @@\n-            DatagramPacket packet = new DatagramPacket(buf, buf.length);\n-            socket.receive(packet);\n+            DatagramPacket packet = readFromSocket(socket, buf);\n+\n@@ -342,0 +331,18 @@\n+    \/*\n+    Some tests failed with receive time-out errors when the client tried to read\n+    from the server. The server thread had exited normally so the read _should_\n+    succeed. So let's try to read a couple of times before giving up.\n+     *\/\n+    DatagramPacket readFromSocket(DatagramSocket socket, byte[] buffer) throws IOException {\n+        for (int i = 1 ; i <= 2 ; ++i) {\n+            try {\n+                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n+                socket.receive(packet);\n+                return packet;\n+            } catch (SocketTimeoutException exc) {\n+                System.out.println(\"Attempt \" + i + \": Timeout occurred reading from socket.\");\n+            }\n+        }\n+        throw new IOException(\"Did not receive data after 2 attempts.\");\n+    }\n+\n@@ -347,8 +354,2 @@\n-        int loops = MAX_HANDSHAKE_LOOPS \/ 2;\n-        while (!endLoops &&\n-                (serverException == null) && (clientException == null)) {\n-\n-            if (--loops < 0) {\n-                throw new RuntimeException(\n-                        \"Too many loops to produce handshake packets\");\n-            }\n+        int loops = 0;\n+        while (!endLoops && !exceptionOccurred.get()) {\n@@ -364,1 +365,1 @@\n-                    loops + \", \" + rs + \", \" + hs + \")----\");\n+                    ++loops + \", \" + rs + \", \" + hs + \")----\");\n@@ -524,4 +525,0 @@\n-    \/\/ Will the handshaking and application data exchange succeed?\n-    public boolean isGoodJob() {\n-        return true;\n-    }\n@@ -547,2 +544,2 @@\n-            ExecutorService pool = Executors.newFixedThreadPool(2);\n-            Future<String> server, client;\n+            ExecutorService pool = Executors.newFixedThreadPool(1);\n+            Future<Void> server;\n@@ -550,2 +547,1 @@\n-            try {\n-                server = pool.submit(new ServerCallable(\n+            server = pool.submit(() -> runServer(\n@@ -553,27 +549,1 @@\n-                client = pool.submit(new ClientCallable(\n-                        testCase, clientSocket, serverSocketAddr));\n-            } finally {\n-                pool.shutdown();\n-            }\n-\n-            boolean failed = false;\n-\n-            \/\/ wait for client to finish\n-            try {\n-                System.out.println(\"Client finished: \" + client.get());\n-            } catch (CancellationException | InterruptedException\n-                        | ExecutionException e) {\n-                System.out.println(\"Exception on client side: \");\n-                e.printStackTrace(System.out);\n-                failed = true;\n-            }\n-\n-            \/\/ wait for server to finish\n-            try {\n-                System.out.println(\"Client finished: \" + server.get());\n-            } catch (CancellationException | InterruptedException\n-                        | ExecutionException e) {\n-                System.out.println(\"Exception on server side: \");\n-                e.printStackTrace(System.out);\n-                failed = true;\n-            }\n+            pool.shutdown();\n@@ -581,3 +551,2 @@\n-            if (failed) {\n-                throw new RuntimeException(\"Test failed\");\n-            }\n+            runClient(testCase, clientSocket, serverSocketAddr);\n+            server.get();\n@@ -587,5 +556,5 @@\n-    final static class ServerCallable implements Callable<String> {\n-\n-        private final DTLSOverDatagram testCase;\n-        private final DatagramSocket socket;\n-        private final InetSocketAddress clientSocketAddr;\n+    Void runServer(DTLSOverDatagram testCase, DatagramSocket socket,\n+                          InetSocketAddress clientSocketAddr) throws Exception {\n+        try {\n+            serverStarted.countDown();\n+            testCase.doServerSide(socket, clientSocketAddr);\n@@ -593,2 +562,2 @@\n-        ServerCallable(DTLSOverDatagram testCase, DatagramSocket socket,\n-                InetSocketAddress clientSocketAddr) {\n+        } catch (Exception exc) {\n+            exceptionOccurred.set(true);\n@@ -596,3 +565,4 @@\n-            this.testCase = testCase;\n-            this.socket = socket;\n-            this.clientSocketAddr = clientSocketAddr;\n+            \/\/ log for debugging clarity\n+            System.out.println(\"Unexpected exception in server\");\n+            exc.printStackTrace(System.err);\n+            throw exc;\n@@ -601,22 +571,1 @@\n-        @Override\n-        public String call() throws Exception {\n-            try {\n-                testCase.doServerSide(socket, clientSocketAddr);\n-            } catch (Exception e) {\n-                System.out.println(\"Exception in  ServerCallable.call():\");\n-                e.printStackTrace(System.out);\n-                serverException = e;\n-\n-                if (testCase.isGoodJob()) {\n-                    throw e;\n-                } else {\n-                    return \"Well done, server!\";\n-                }\n-            }\n-\n-            if (testCase.isGoodJob()) {\n-                return \"Well done, server!\";\n-            } else {\n-                throw new Exception(\"No expected exception\");\n-            }\n-        }\n+        return null;\n@@ -625,12 +574,4 @@\n-    final static class ClientCallable implements Callable<String> {\n-\n-        private final DTLSOverDatagram testCase;\n-        private final DatagramSocket socket;\n-        private final InetSocketAddress serverSocketAddr;\n-\n-        ClientCallable(DTLSOverDatagram testCase, DatagramSocket socket,\n-                InetSocketAddress serverSocketAddr) {\n-\n-            this.testCase = testCase;\n-            this.socket = socket;\n-            this.serverSocketAddr = serverSocketAddr;\n+    private void runClient(DTLSOverDatagram testCase, DatagramSocket socket,\n+                           InetSocketAddress serverSocketAddr) throws Exception {\n+        if(!serverStarted.await(5, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Server did not start within 5 seconds.\");\n@@ -639,15 +580,4 @@\n-        @Override\n-        public String call() throws Exception {\n-            try {\n-                testCase.doClientSide(socket, serverSocketAddr);\n-            } catch (Exception e) {\n-                System.out.println(\"Exception in ClientCallable.call():\");\n-                e.printStackTrace(System.out);\n-                clientException = e;\n-\n-                if (testCase.isGoodJob()) {\n-                    throw e;\n-                } else {\n-                    return \"Well done, client!\";\n-                }\n-            }\n+        try {\n+            testCase.doClientSide(socket, serverSocketAddr);\n+        } catch (Exception exc) {\n+            exceptionOccurred.set(true);\n@@ -655,5 +585,4 @@\n-            if (testCase.isGoodJob()) {\n-                return \"Well done, client!\";\n-            } else {\n-                throw new Exception(\"No expected exception\");\n-            }\n+            \/\/ log for debugging clarity\n+            System.out.println(\"Unexpected exception in client.\");\n+            exc.printStackTrace(System.err);\n+            throw exc;\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":63,"deletions":134,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -41,1 +42,1 @@\n- * Test that if handshake messages are crasged, the handshake would fail\n+ * Test that if handshake messages are changed, the handshake would fail\n@@ -45,1 +46,1 @@\n-    boolean needInvalidRecords = true;\n+    private static final AtomicBoolean needInvalidRecords = new AtomicBoolean(true);\n@@ -50,1 +51,0 @@\n-    }\n@@ -52,3 +52,7 @@\n-    @Override\n-    public boolean isGoodJob() {\n-        return false;\n+        if (needInvalidRecords.get()) {\n+            \/\/ if this is true, the createHandshakePacket() method\n+            \/\/ was NOT called twice to create ClientHello messages\n+            throw new RuntimeException(\n+                    \"The invalid handshake packet was not\"\n+                    + \" rejected as it should have been.\");\n+        }\n@@ -57,0 +61,1 @@\n+\n@@ -59,1 +64,1 @@\n-        if ((ba.length >= 60) &&\n+        if (needInvalidRecords.get() && (ba.length >= 60) &&\n@@ -68,10 +73,0 @@\n-            if (!needInvalidRecords) {\n-                \/\/ The 2nd ClientHello with cookie.  The 1st one should be\n-                \/\/ rejected as expected.\n-                \/\/\n-                \/\/ This may happen if the last few bytes of the packet are\n-                \/\/ for supported_version extension.\n-                throw new RuntimeException(\n-                    \"the crashed handshake message was rejected as expected\");\n-            }\n-\n@@ -79,1 +74,1 @@\n-            needInvalidRecords = false;\n+            needInvalidRecords.set(false);\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/InvalidRecords.java","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"}]}