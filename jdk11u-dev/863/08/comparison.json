{"files":[{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Data structure to hold info from \/proc\/self\/cgroup\n+ *\n+ * man 7 cgroups\n+ *\n+ * @see CgroupSubsystemFactory\n+ *\/\n+class CgroupInfo {\n+\n+    private final String name;\n+    private final int hierarchyId;\n+    private final boolean enabled;\n+\n+    private CgroupInfo(String name, int hierarchyId, boolean enabled) {\n+        this.name = name;\n+        this.hierarchyId = hierarchyId;\n+        this.enabled = enabled;\n+    }\n+\n+    String getName() {\n+        return name;\n+    }\n+\n+    int getHierarchyId() {\n+        return hierarchyId;\n+    }\n+\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    static CgroupInfo fromCgroupsLine(String line) {\n+        String[] tokens = line.split(\"\\\\s+\");\n+        if (tokens.length != 4) {\n+            return null;\n+        }\n+        \/\/ discard 3'rd field, num_cgroups\n+        return new CgroupInfo(tokens[0] \/* name *\/,\n+                              Integer.parseInt(tokens[1]) \/* hierarchyId *\/,\n+                              (Integer.parseInt(tokens[3]) == 1) \/* enabled *\/);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.util.Objects;\n+\n+public class CgroupMetrics implements Metrics {\n+\n+    private final CgroupSubsystem subsystem;\n+\n+    CgroupMetrics(CgroupSubsystem subsystem) {\n+        this.subsystem = Objects.requireNonNull(subsystem);\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return subsystem.getProvider();\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        return subsystem.getCpuUsage();\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return subsystem.getPerCpuUsage();\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        return subsystem.getCpuUserUsage();\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        return subsystem.getCpuSystemUsage();\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return subsystem.getCpuPeriod();\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return subsystem.getCpuQuota();\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        return subsystem.getCpuShares();\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return subsystem.getCpuNumPeriods();\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return subsystem.getCpuNumThrottled();\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return subsystem.getCpuThrottledTime();\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return subsystem.getEffectiveCpuCount();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        return subsystem.getCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        return subsystem.getEffectiveCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        return subsystem.getCpuSetMems();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        return subsystem.getEffectiveCpuSetMems();\n+    }\n+\n+    public long getMemoryFailCount() {\n+        return subsystem.getMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        return subsystem.getMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return subsystem.getMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return subsystem.getTcpMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        return subsystem.getMemoryAndSwapLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return subsystem.getMemoryAndSwapUsage();\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        return subsystem.getMemorySoftLimit();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return subsystem.getBlkIOServiceCount();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return subsystem.getBlkIOServiced();\n+    }\n+\n+    public static Metrics getInstance() {\n+        if (!isUseContainerSupport()) {\n+            \/\/ Return null on -XX:-UseContainerSupport\n+            return null;\n+        }\n+        return CgroupSubsystemFactory.create();\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Marker interface for cgroup-based metrics\n+ *\n+ *\/\n+public interface CgroupSubsystem extends Metrics {\n+\n+    \/**\n+     * Returned for metrics of type long if the underlying implementation\n+     * has determined that no limit is being imposed.\n+     *\/\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Cgroup version agnostic controller logic\n+ *\n+ *\/\n+public interface CgroupSubsystemController {\n+\n+    public static final String EMPTY_STR = \"\";\n+\n+    public String path();\n+\n+    \/**\n+     * getStringValue\n+     *\n+     * Return the first line of the file \"param\" argument from the controller.\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @return Returns the contents of the file specified by param or null if\n+     *         an error occurs.\n+     *\/\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        if (controller == null) return null;\n+\n+        try {\n+            return CgroupUtil.readStringValue(controller, param);\n+        }\n+        catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Get an entry from file \"param\" within the \"controller\" directory path\n+     * which matches string \"match\". Applies \"conversion\" to the matching line.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param match\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The long value as derived by applying \"conversion\" to the matching\n+     *         line or \"defaultRetval\" if there was an error or no match found.\n+     *\/\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                     String param,\n+                                                     String match,\n+                                                     Function<String, Long> conversion,\n+                                                     long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (controller == null) {\n+            return retval;\n+        }\n+        try {\n+            Path filePath = Paths.get(controller.path(), param);\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            for (String line : lines) {\n+                if (line.startsWith(match)) {\n+                    retval = conversion.apply(line);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore. Default is unlimited.\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * Get a long value from directory \"controller\" and file \"param\", by\n+     * applying \"conversion\" to the string value within the file.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The converted long value or \"defaultRetval\" if there was an\n+     *         error.\n+     *\/\n+    public static long getLongValue(CgroupSubsystemController controller,\n+                                    String param,\n+                                    Function<String, Long> conversion,\n+                                    long defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+        if (strval == null) return defaultRetval;\n+        return conversion.apply(strval);\n+    }\n+\n+    \/**\n+     * Get a double value from file \"param\" within \"controller\".\n+     *\n+     * @param controller\n+     * @param param\n+     * @param defaultRetval\n+     * @return The double value or \"defaultRetval\" if there was an error.\n+     *\/\n+    public static double getDoubleValue(CgroupSubsystemController controller, String param, double defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+\n+        if (strval == null) return defaultRetval;\n+\n+        double retval = Double.parseDouble(strval);\n+\n+        return retval;\n+    }\n+\n+    \/**\n+     * getLongEntry\n+     *\n+     * Return the long value from the line containing the string \"entryname\"\n+     * within file \"param\" in the \"controller\".\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param entryname\n+     * @return long value or \"defaultRetval\" if there was an error or no match\n+     *         was found.\n+     *\/\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname, long defaultRetval) {\n+        if (controller == null) return defaultRetval;\n+\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+\n+            Optional<String> result = lines.map(line -> line.split(\" \"))\n+                                           .filter(line -> (line.length == 2 &&\n+                                                   line[0].equals(entryname)))\n+                                           .map(line -> line[1])\n+                                           .findFirst();\n+\n+            return result.isPresent() ? Long.parseLong(result.get()) : defaultRetval;\n+        } catch (UncheckedIOException e) {\n+            return defaultRetval;\n+        } catch (IOException e) {\n+            return defaultRetval;\n+        }\n+    }\n+\n+    \/**\n+     * stringRangeToIntArray\n+     *\n+     * Convert a string in the form of  1,3-4,6 to an array of\n+     * integers containing all the numbers in the range.\n+     *\n+     * @param range\n+     * @return int[] containing a sorted list of numbers as represented by\n+     *         the string range. Returns null if there was an error or the input\n+     *         was an empty string.\n+     *\/\n+    public static int[] stringRangeToIntArray(String range) {\n+        if (range == null || EMPTY_STR.equals(range)) return null;\n+\n+        ArrayList<Integer> results = new ArrayList<>();\n+        String strs[] = range.split(\",\");\n+        for (String str : strs) {\n+            if (str.contains(\"-\")) {\n+                String lohi[] = str.split(\"-\");\n+                \/\/ validate format\n+                if (lohi.length != 2) {\n+                    continue;\n+                }\n+                int lo = Integer.parseInt(lohi[0]);\n+                int hi = Integer.parseInt(lohi[1]);\n+                for (int i = lo; i <= hi; i++) {\n+                    results.add(i);\n+                }\n+            }\n+            else {\n+                results.add(Integer.parseInt(str));\n+            }\n+        }\n+\n+        \/\/ sort results\n+        results.sort(null);\n+\n+        \/\/ convert ArrayList to primitive int array\n+        int[] ints = new int[results.size()];\n+        int i = 0;\n+        for (Integer n : results) {\n+            ints[i++] = n;\n+        }\n+\n+        return ints;\n+    }\n+\n+    \/**\n+     * Convert a number from its string representation to a long.\n+     *\n+     * @param strval\n+     * @param overflowRetval\n+     * @param defaultRetval\n+     * @return The converted long value. \"overflowRetval\" is returned if the\n+     *         string representation exceeds the range of type long.\n+     *         \"defaultRetval\" is returned if another type of error occurred\n+     *         during conversion.\n+     *\/\n+    public static long convertStringToLong(String strval, long overflowRetval, long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes, cgroups v1) we may overflow\n+            \/\/ the range of signed long. In this case, return overflowRetval\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.lang.System.Logger;\n+import java.lang.System.Logger.Level;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.cgroupv2.CgroupV2Subsystem;\n+\n+class CgroupSubsystemFactory {\n+\n+    private static final String CPU_CTRL = \"cpu\";\n+    private static final String CPUACCT_CTRL = \"cpuacct\";\n+    private static final String CPUSET_CTRL = \"cpuset\";\n+    private static final String BLKIO_CTRL = \"blkio\";\n+    private static final String MEMORY_CTRL = \"memory\";\n+\n+    static CgroupMetrics create() {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n+            for (String line : lines) {\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                }\n+                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+                switch (info.getName()) {\n+                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If no controller is enabled, return no metrics.\n+        if (!anyControllersEnabled) {\n+            return null;\n+        }\n+        \/\/ Warn about mixed cgroups v1 and cgroups v2 controllers. The code is\n+        \/\/ not ready to deal with that on a per-controller basis. Return no metrics\n+        \/\/ in that case\n+        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+            Logger logger = System.getLogger(\"jdk.internal.platform\");\n+            logger.log(Level.DEBUG, \"Mixed cgroupv1 and cgroupv2 not supported. Metrics disabled.\");\n+            return null;\n+        }\n+\n+        if (isCgroupsV2) {\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            return subsystem != null ? new CgroupMetrics(subsystem) : null;\n+        } else {\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            return subsystem != null ? new CgroupV1MetricsImpl(subsystem) : null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public final class CgroupUtil {\n+\n+    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n+\n+    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(controller.path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ *\n+ * Cgroup v1 extensions to the Metrics interface. Linux, only.\n+ *\n+ *\/\n+public interface CgroupV1Metrics extends Metrics {\n+\n+    \/**\n+     * Returns the largest amount of physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available. Returns -2 if this metric is not\n+     *         supported.\n+     *\n+     *\/\n+    public long getMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that kernel memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of kernel physical memory, in bytes, that\n+     * can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set.\n+     *\n+     *\/\n+    public long getKernelMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of kernel physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the amount of kernel physical memory, in bytes, that\n+     * is currently allocated in the current Isolation Group.\n+     *\n+     * @return The amount of memory in bytes allocated or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryUsage();\n+\n+    \/**\n+     * Returns the number of times that networking memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of networking physical memory, in bytes,\n+     * that can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit.\n+     *\n+     *\/\n+    public long getTcpMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of networking physical memory, in bytes,\n+     * that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that user memory requests in the\n+     * Isolation Group have exceeded the memory + swap limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapFailCount();\n+\n+    \/**\n+     * Returns the largest amount of physical memory and swap space,\n+     * in bytes, that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapMaxUsage();\n+\n+    \/**\n+     * Returns the state of the Operating System Out of Memory termination\n+     * policy.\n+     *\n+     * @return Returns true if operating system will terminate processes\n+     *         in the Isolation Group that exceed the amount of available\n+     *         memory, otherwise false. null will be returned if this\n+     *         capability is not available on the current operating system.\n+     *\n+     *\/\n+    public Boolean isMemoryOOMKillEnabled();\n+\n+    \/**\n+     * Returns the (attempts per second * 1000), if enabled, that the\n+     * operating system tries to satisfy a memory request for any\n+     * process in the current Isolation Group when no free memory is\n+     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n+     * determine if this support is enabled.\n+     *\n+     * @return Memory pressure or 0 if not enabled or -1 if metric is not\n+     *         available.\n+     *\n+     *\/\n+    public double getCpuSetMemoryPressure();\n+\n+    \/**\n+     * Returns the state of the memory pressure detection support.\n+     *\n+     * @return true if support is available and enabled. false otherwise.\n+     *\n+     *\/\n+    public Boolean isCpuSetMemoryPressureEnabled();\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1Metrics.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Cgroup v1 Metrics extensions\n+ *\n+ *\/\n+public class CgroupV1MetricsImpl extends CgroupMetrics implements CgroupV1Metrics {\n+\n+    private final CgroupV1Metrics metrics;\n+\n+    CgroupV1MetricsImpl(CgroupV1Metrics metrics) {\n+        super((CgroupSubsystem)metrics);\n+        this.metrics = metrics;\n+    }\n+\n+    @Override\n+    public long getMemoryMaxUsage() {\n+        return metrics.getMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return metrics.getKernelMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryLimit() {\n+        return metrics.getKernelMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return metrics.getKernelMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return metrics.getKernelMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return metrics.getTcpMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryLimit() {\n+        return metrics.getTcpMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return metrics.getTcpMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return metrics.getMemoryAndSwapFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return metrics.getMemoryAndSwapMaxUsage();\n+    }\n+\n+    @Override\n+    public Boolean isMemoryOOMKillEnabled() {\n+        return metrics.isMemoryOOMKillEnabled();\n+    }\n+\n+    @Override\n+    public double getCpuSetMemoryPressure() {\n+        return metrics.getCpuSetMemoryPressure();\n+    }\n+\n+    @Override\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        return metrics.isCpuSetMemoryPressureEnabled();\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1MetricsImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+\n+    private boolean hierarchical;\n+    private boolean swapenabled;\n+\n+    public CgroupV1MemorySubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n+    boolean isSwapEnabled() {\n+        return swapenabled;\n+    }\n+\n+    void setSwapEnabled(boolean swapenabled) {\n+        this.swapenabled = swapenabled;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,511 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class CgroupV1Subsystem implements CgroupSubsystem, CgroupV1Metrics {\n+    private CgroupV1MemorySubSystemController memory;\n+    private CgroupV1SubsystemController cpu;\n+    private CgroupV1SubsystemController cpuacct;\n+    private CgroupV1SubsystemController cpuset;\n+    private CgroupV1SubsystemController blkio;\n+    private boolean activeSubSystems;\n+\n+    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+\n+    private static final String PROVIDER_NAME = \"cgroupv1\";\n+\n+    private CgroupV1Subsystem() {\n+        activeSubSystems = false;\n+    }\n+\n+    public static CgroupV1Subsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private static CgroupV1Subsystem initSubSystem() {\n+        CgroupV1Subsystem subsystem = new CgroupV1Subsystem();\n+\n+        \/**\n+         * Find the cgroup mount points for subsystems\n+         * by reading \/proc\/self\/mountinfo\n+         *\n+         * Example for docker MemorySubSystem subsystem:\n+         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n+         *\n+         * Example for host:\n+         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            lines.filter(line -> line.contains(\" - cgroup \"))\n+                 .map(line -> line.split(\" \"))\n+                 .forEach(entry -> createSubSystemController(subsystem, entry));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/**\n+         * Read \/proc\/self\/cgroup and map host mount point to\n+         * local one via \/proc\/self\/mountinfo content above\n+         *\n+         * Docker example:\n+         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+         *\n+         * Host example:\n+         * 5:memory:\/user.slice\n+         *\n+         * Construct a path to the process specific memory and cpuset\n+         * cgroup directory.\n+         *\n+         * For a container running under Docker from memory example above\n+         * the paths would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\n+         *\n+         * For a Host from memory example above the path would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\/user.slice\n+         *\n+         *\/\n+        try (Stream<String> lines =\n+            CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+\n+            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n+            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n+            \/\/ contain a ':'.\n+            lines.map(line -> line.split(\":\", 3))\n+                 .filter(line -> (line.length >= 3))\n+                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ Return Metrics object if we found any subsystems.\n+        if (subsystem.activeSubSystems()) {\n+            return subsystem;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * createSubSystem objects and initialize mount points\n+     *\/\n+    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n+        if (mountentry.length < 5) return;\n+\n+        Path p = Paths.get(mountentry[4]);\n+        String[] subsystemNames = p.getFileName().toString().split(\",\");\n+\n+        for (String subsystemName: subsystemNames) {\n+            switch (subsystemName) {\n+                case \"memory\":\n+                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuset\":\n+                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuacct\":\n+                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpu\":\n+                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"blkio\":\n+                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                default:\n+                    \/\/ Ignore subsystems that we don't support\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n+     *\/\n+    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n+        String controller = entry[1];\n+        String base = entry[2];\n+        if (controller != null && base != null) {\n+            for (String cName: controller.split(\",\")) {\n+                switch (cName) {\n+                    case \"memory\":\n+                        setPath(subsystem, subsystem.memoryController(), base);\n+                        break;\n+                    case \"cpuset\":\n+                        setPath(subsystem, subsystem.cpuSetController(), base);\n+                        break;\n+                    case \"cpuacct\":\n+                        setPath(subsystem, subsystem.cpuController(), base);\n+                        break;\n+                    case \"cpu\":\n+                        setPath(subsystem, subsystem.cpuAcctController(), base);\n+                        break;\n+                    case \"blkio\":\n+                        setPath(subsystem, subsystem.blkIOController(), base);\n+                        break;\n+                    \/\/ Ignore subsystems that we don't support\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void setPath(CgroupV1Subsystem subsystem, CgroupV1SubsystemController controller, String base) {\n+        if (controller != null) {\n+            controller.setPath(base);\n+            if (controller instanceof CgroupV1MemorySubSystemController) {\n+                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n+                boolean isHierarchial = getHierarchical(memorySubSystem);\n+                memorySubSystem.setHierarchical(isHierarchial);\n+                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n+                memorySubSystem.setSwapEnabled(isSwapEnabled);\n+            }\n+            subsystem.setActiveSubSystems();\n+        }\n+    }\n+\n+\n+    private static boolean getSwapEnabled(CgroupV1MemorySubSystemController controller) {\n+         long retval = getLongValue(controller, \"memory.memsw.limit_in_bytes\");\n+         return retval > 0;\n+     }\n+\n+\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n+    private void setActiveSubSystems() {\n+        activeSubSystems = true;\n+    }\n+\n+    private boolean activeSubSystems() {\n+        return activeSubSystems;\n+    }\n+\n+    private void setMemorySubSystem(CgroupV1MemorySubSystemController memory) {\n+        this.memory = memory;\n+    }\n+\n+    private void setCpuController(CgroupV1SubsystemController cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    private void setCpuAcctController(CgroupV1SubsystemController cpuacct) {\n+        this.cpuacct = cpuacct;\n+    }\n+\n+    private void setCpuSetController(CgroupV1SubsystemController cpuset) {\n+        this.cpuset = cpuset;\n+    }\n+\n+    private void setBlkIOController(CgroupV1SubsystemController blkio) {\n+        this.blkio = blkio;\n+    }\n+\n+    private CgroupV1SubsystemController memoryController() {\n+        return memory;\n+    }\n+\n+    private CgroupV1SubsystemController cpuController() {\n+        return cpu;\n+    }\n+\n+    private CgroupV1SubsystemController cpuAcctController() {\n+        return cpuacct;\n+    }\n+\n+    private CgroupV1SubsystemController cpuSetController() {\n+        return cpuset;\n+    }\n+\n+    private CgroupV1SubsystemController blkIOController() {\n+        return blkio;\n+    }\n+\n+    private static long getLongValue(CgroupSubsystemController controller,\n+                              String parm) {\n+        return CgroupSubsystemController.getLongValue(controller,\n+                                                      parm,\n+                                                      CgroupV1SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    \/*****************************************************************\n+     * CPU Accounting Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuUsage() {\n+        return getLongValue(cpuacct, \"cpuacct.usage\");\n+    }\n+\n+    public long[] getPerCpuUsage() {\n+        String usagelist = CgroupSubsystemController.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n+        if (usagelist == null) {\n+            return null;\n+        }\n+\n+        String list[] = usagelist.split(\" \");\n+        long percpu[] = new long[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            percpu[i] = Long.parseLong(list[i]);\n+        }\n+        return percpu;\n+    }\n+\n+    public long getCpuUserUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPU Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuPeriod() {\n+        return getLongValue(cpu, \"cpu.cfs_period_us\");\n+    }\n+\n+    public long getCpuQuota() {\n+        return getLongValue(cpu, \"cpu.cfs_quota_us\");\n+    }\n+\n+    public long getCpuShares() {\n+        long retval = getLongValue(cpu, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024)\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        else\n+            return retval;\n+    }\n+\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPUSet Subsystem\n+     ****************************************************************\/\n+\n+    public int[] getCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.cpus\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n+    }\n+\n+    public int[] getCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.mems\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_mems\"));\n+    }\n+\n+    public double getCpuSetMemoryPressure() {\n+        return CgroupV1SubsystemController.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n+    }\n+\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        long val = getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n+        return (val == 1);\n+    }\n+\n+\n+    \/*****************************************************************\n+     * Memory Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getMemoryFailCount() {\n+        return getLongValue(memory, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryLimit() {\n+        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryUsage() {\n+        return getLongValue(memory, \"memory.usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.limit_in_bytes\"));\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\"));\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryFailCount();\n+        }\n+        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getMemoryAndSwapLimit() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryLimit();\n+        }\n+        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryMaxUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n+    }\n+\n+    public long getMemorySoftLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+    }\n+\n+\n+    \/*****************************************************************\n+     * BlKIO Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getBlkIOServiceCount() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n+    }\n+\n+    public long getBlkIOServiced() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":511,"deletions":0,"binary":false,"changes":511,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n+\n+    public CgroupV1SubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static double getDoubleValue(CgroupSubsystemController controller, String parm) {\n+        return CgroupSubsystemController.getDoubleValue(controller,\n+                                                        parm,\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             Long.MAX_VALUE \/* overflow value *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long longValOrUnlimited(long value) {\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+    }\n+\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                String param,\n+                                                String match) {\n+        return CgroupSubsystemController.getLongValueMatchingLine(controller,\n+                                                                  param,\n+                                                                  match,\n+                                                                  CgroupV1SubsystemController::convertHierachicalLimitLine,\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public static long convertHierachicalLimitLine(String line) {\n+        String[] tokens = line.split(\"\\\\s\");\n+        if (tokens.length == 2) {\n+            String strVal = tokens[1];\n+            return CgroupV1SubsystemController.convertStringToLong(strVal);\n+        }\n+        return CgroupV1SubsystemController.UNLIMITED_MIN + 1; \/\/ unlimited\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,545 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.platform.cgroupv1.SubSystem.MemorySubSystem;\n-\n-public class Metrics implements jdk.internal.platform.Metrics {\n-    private MemorySubSystem memory;\n-    private SubSystem cpu;\n-    private SubSystem cpuacct;\n-    private SubSystem cpuset;\n-    private SubSystem blkio;\n-    private boolean activeSubSystems;\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-\n-    private static final Metrics INSTANCE = initContainerSubSystems();\n-\n-    private static final String PROVIDER_NAME = \"cgroupv1\";\n-\n-    private Metrics() {\n-        activeSubSystems = false;\n-    }\n-\n-    public static Metrics getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private static Metrics initContainerSubSystems() {\n-        if (!isUseContainerSupport()) {\n-            return null;\n-        }\n-        Metrics metrics = new Metrics();\n-\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystem(metrics, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemPath(metrics, line));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/\/ Return Metrics object if we found any subsystems.\n-        if (metrics.activeSubSystems()) {\n-            return metrics;\n-        }\n-\n-        return null;\n-    }\n-\n-    static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystem(Metrics metric, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    metric.setMemorySubSystem(new MemorySubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    metric.setCpuSetSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    metric.setCpuAcctSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    metric.setCpuSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    metric.setBlkIOSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemPath(Metrics metric, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(metric, metric.MemorySubSystem(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(metric, metric.CpuSetSubSystem(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(metric, metric.CpuAcctSubSystem(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(metric, metric.CpuSubSystem(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(metric, metric.BlkIOSubSystem(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(Metrics metric, SubSystem subsystem, String base) {\n-        if (subsystem != null) {\n-            subsystem.setPath(base);\n-            if (subsystem instanceof MemorySubSystem) {\n-                MemorySubSystem memorySubSystem = (MemorySubSystem)subsystem;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            metric.setActiveSubSystems();\n-        }\n-    }\n-\n-\n-    private static boolean getHierarchical(MemorySubSystem subsystem) {\n-        long hierarchical = SubSystem.getLongValue(subsystem, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n-    private static boolean getSwapEnabled(MemorySubSystem subsystem) {\n-        long retval = SubSystem.getLongValue(subsystem, \"memory.memsw.limit_in_bytes\");\n-        return retval > 0;\n-    }\n-\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n-    private void setMemorySubSystem(MemorySubSystem memory) {\n-        this.memory = memory;\n-    }\n-\n-    private void setCpuSubSystem(SubSystem cpu) {\n-        this.cpu = cpu;\n-    }\n-\n-    private void setCpuAcctSubSystem(SubSystem cpuacct) {\n-        this.cpuacct = cpuacct;\n-    }\n-\n-    private void setCpuSetSubSystem(SubSystem cpuset) {\n-        this.cpuset = cpuset;\n-    }\n-\n-    private void setBlkIOSubSystem(SubSystem blkio) {\n-        this.blkio = blkio;\n-    }\n-\n-    private SubSystem MemorySubSystem() {\n-        return memory;\n-    }\n-\n-    private SubSystem CpuSubSystem() {\n-        return cpu;\n-    }\n-\n-    private SubSystem CpuAcctSubSystem() {\n-        return cpuacct;\n-    }\n-\n-    private SubSystem CpuSetSubSystem() {\n-        return cpuset;\n-    }\n-\n-    private SubSystem BlkIOSubSystem() {\n-        return blkio;\n-    }\n-\n-    public String getProvider() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    \/*****************************************************************\n-     * CPU Accounting Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuUsage() {\n-        return SubSystem.getLongValue(cpuacct, \"cpuacct.usage\");\n-    }\n-\n-    public long[] getPerCpuUsage() {\n-        String usagelist = SubSystem.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n-        if (usagelist == null) {\n-            return new long[0];\n-        }\n-\n-        String list[] = usagelist.split(\" \");\n-        long percpu[] = new long[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            percpu[i] = Long.parseLong(list[i]);\n-        }\n-        return percpu;\n-    }\n-\n-    public long getCpuUserUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n-    }\n-\n-    public long getCpuSystemUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPU Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuPeriod() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_period_us\");\n-    }\n-\n-    public long getCpuQuota() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_quota_us\");\n-    }\n-\n-    public long getCpuShares() {\n-        long retval = SubSystem.getLongValue(cpu, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return -1;\n-        else\n-            return retval;\n-    }\n-\n-    public long getCpuNumPeriods() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n-    }\n-\n-    public long getCpuNumThrottled() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n-    }\n-\n-    public long getCpuThrottledTime() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n-    }\n-\n-    public long getEffectiveCpuCount() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPUSet Subsystem\n-     ****************************************************************\/\n-\n-    public int[] getCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.cpus\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n-    }\n-\n-    public int[] getCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.mems\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_mems\"));\n-    }\n-\n-    public double getCpuSetMemoryPressure() {\n-        return SubSystem.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n-    }\n-\n-    public boolean isCpuSetMemoryPressureEnabled() {\n-        long val = SubSystem.getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n-        return (val == 1);\n-    }\n-\n-\n-    \/*****************************************************************\n-     * Memory Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.failcnt\");\n-    }\n-\n-    public long getMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public static long convertHierachicalLimitLine(String line) {\n-        String[] tokens = line.split(\"\\\\s\");\n-        if (tokens.length == 2) {\n-            String strVal = tokens[1];\n-            return SubSystem.convertStringToLong(strVal);\n-        }\n-        return unlimited_minimum + 1; \/\/ unlimited\n-    }\n-\n-    public long getMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.failcnt\");\n-    }\n-\n-    public long getKernelMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.kmem.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getKernelMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n-    }\n-\n-    public long getTcpMemoryLimit() {\n-        long retval =  SubSystem.getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getTcpMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.failcnt\");\n-    }\n-\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = SubSystem.getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n-    }\n-\n-    public boolean isMemoryOOMKillEnabled() {\n-        long val = SubSystem.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n-    }\n-\n-    public long getMemorySoftLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.soft_limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-\n-    \/*****************************************************************\n-     * BlKIO Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getBlkIOServiceCount() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n-    }\n-\n-    public long getBlkIOServiced() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n-    }\n-\n-    private static native boolean isUseContainerSupport();\n-\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":0,"deletions":545,"binary":false,"changes":545,"status":"deleted"},{"patch":"@@ -1,298 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class SubSystem {\n-    String root;\n-    String mountPoint;\n-    String path;\n-\n-    public SubSystem(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    \/**\n-     * getSubSystemStringValue\n-     *\n-     * Return the first line of the file \"parm\" argument from the subsystem.\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @return Returns the contents of the file specified by param.\n-     *\/\n-    public static String getStringValue(SubSystem subsystem, String parm) {\n-        if (subsystem == null) return null;\n-\n-        try {\n-            return subsystem.readStringValue(parm);\n-        } catch (IOException e) {\n-            return null;\n-        }\n-    }\n-\n-    private String readStringValue(String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(path(), param));\n-        try (BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValueMatchingLine(SubSystem subsystem,\n-                                                     String param,\n-                                                     String match,\n-                                                     Function<String, Long> conversion) {\n-        long retval = Metrics.unlimited_minimum + 1; \/\/ default unlimited\n-        try {\n-            List<String> lines = subsystem.readMatchingLines(param);\n-            for (String line: lines) {\n-                if (line.startsWith(match)) {\n-                    retval = conversion.apply(line);\n-                    break;\n-                }\n-            }\n-        } catch (IOException e) {\n-            \/\/ Ignore. Default is unlimited.\n-        }\n-        return retval;\n-    }\n-\n-    private List<String> readMatchingLines(String param) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () ->\n-                    Files.readAllLines(Paths.get(path(), param));\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-        return convertStringToLong(strval);\n-    }\n-\n-    public static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    public static double getDoubleValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-\n-        if (strval == null) return 0L;\n-\n-        double retval = Double.parseDouble(strval);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * getSubSystemlongEntry\n-     *\n-     * Return the long value from the line containing the string \"entryname\"\n-     * within file \"parm\" in the \"subsystem\".\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @param entryname\n-     * @return long value\n-     *\/\n-    public static long getLongEntry(SubSystem subsystem, String parm, String entryname) {\n-        String val = null;\n-\n-        if (subsystem == null) return 0L;\n-\n-        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n-\n-            Optional<String> result = lines.map(line -> line.split(\" \"))\n-                                           .filter(line -> (line.length == 2 &&\n-                                                   line[0].equals(entryname)))\n-                                           .map(line -> line[1])\n-                                           .findFirst();\n-\n-            return result.isPresent() ? Long.parseLong(result.get()) : 0L;\n-        } catch (IOException e) {\n-            return 0L;\n-        } catch (UncheckedIOException e) {\n-            return 0L;\n-        }\n-    }\n-\n-    public static int getIntValue(SubSystem subsystem, String parm) {\n-        String val = getStringValue(subsystem, parm);\n-\n-        if (val == null) return 0;\n-\n-        return Integer.parseInt(val);\n-    }\n-\n-    \/**\n-     * StringRangeToIntArray\n-     *\n-     * Convert a string in the form of  1,3-4,6 to an array of\n-     * integers containing all the numbers in the range.\n-     *\n-     * @param range\n-     * @return int[] containing a sorted list of processors or memory nodes\n-     *\/\n-    public static int[] StringRangeToIntArray(String range) {\n-        int[] ints = new int[0];\n-\n-        if (range == null) return ints;\n-\n-        ArrayList<Integer> results = new ArrayList<>();\n-        String strs[] = range.split(\",\");\n-        for (String str : strs) {\n-            if (str.contains(\"-\")) {\n-                String lohi[] = str.split(\"-\");\n-                \/\/ validate format\n-                if (lohi.length != 2) {\n-                    continue;\n-                }\n-                int lo = Integer.parseInt(lohi[0]);\n-                int hi = Integer.parseInt(lohi[1]);\n-                for (int i = lo; i <= hi; i++) {\n-                    results.add(i);\n-                }\n-            }\n-            else {\n-                results.add(Integer.parseInt(str));\n-            }\n-        }\n-\n-        \/\/ sort results\n-        results.sort(null);\n-\n-        \/\/ convert ArrayList to primitive int array\n-        ints = new int[results.size()];\n-        int i = 0;\n-        for (Integer n : results) {\n-            ints[i++] = n;\n-        }\n-\n-        return ints;\n-    }\n-\n-    public static class MemorySubSystem extends SubSystem {\n-\n-        private boolean hierarchical;\n-        private boolean swapenabled;\n-\n-        public MemorySubSystem(String root, String mountPoint) {\n-            super(root, mountPoint);\n-        }\n-\n-        boolean isHierarchical() {\n-            return hierarchical;\n-        }\n-\n-        void setHierarchical(boolean hierarchical) {\n-            this.hierarchical = hierarchical;\n-        }\n-\n-        boolean isSwapEnabled() {\n-            return swapenabled;\n-        }\n-\n-        void setSwapEnabled(boolean swapenabled) {\n-            this.swapenabled = swapenabled;\n-        }\n-\n-    }\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":0,"deletions":298,"binary":false,"changes":298,"status":"deleted"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupV2Subsystem implements CgroupSubsystem {\n+\n+    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static final long[] LONG_ARRAY_NOT_SUPPORTED = null;\n+    private static final int[] INT_ARRAY_UNAVAILABLE = null;\n+    private final CgroupSubsystemController unified;\n+    private static final String PROVIDER_NAME = \"cgroupv2\";\n+    private static final int PER_CPU_SHARES = 1024;\n+    private static final String MAX_VAL = \"max\";\n+    private static final Object EMPTY_STR = \"\";\n+\n+    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+        this.unified = unified;\n+    }\n+\n+    private long getLongVal(String file) {\n+        return CgroupSubsystemController.getLongValue(unified,\n+                                                      file,\n+                                                      CgroupV2SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    private static CgroupV2Subsystem initSubsystem() {\n+        \/\/ read mountinfo so as to determine root mount path\n+        String mountPath = null;\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n+                            .collect(Collectors.joining());\n+            String[] tokens = l.split(\" \");\n+            mountPath = tokens[4];\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        String cgroupPath = null;\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n+            for (String line: lines) {\n+                String[] tokens = line.split(\":\");\n+                if (tokens.length != 3) {\n+                    return null; \/\/ something is not right.\n+                }\n+                if (!\"0\".equals(tokens[0])) {\n+                    \/\/ hierarchy must be zero for cgroups v2\n+                    return null;\n+                }\n+                cgroupPath = tokens[2];\n+                break;\n+            }\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                mountPath,\n+                cgroupPath);\n+        return new CgroupV2Subsystem(unified);\n+    }\n+\n+    public static CgroupSubsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return LONG_ARRAY_NOT_SUPPORTED;\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return limitFromString(quota);\n+    }\n+\n+    private long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = getLongVal(\"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        String cpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus\");\n+        return getCpuSet(cpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        String effCpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus.effective\");\n+        return getCpuSet(effCpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        String cpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems\");\n+        return getCpuSet(cpuSetMems);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        String effCpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems.effective\");\n+        return getCpuSet(effCpuSetMems);\n+    }\n+\n+    private int[] getCpuSet(String cpuSetVal) {\n+        if (cpuSetVal == null || EMPTY_STR.equals(cpuSetVal)) {\n+            return INT_ARRAY_UNAVAILABLE;\n+        }\n+        return CgroupSubsystemController.stringRangeToIntArray(cpuSetVal);\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return getLongVal(\"memory.current\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return getLongVal(\"memory.swap.current\");\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.high\");\n+        return limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRandWIOs);\n+    }\n+\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRBytesAndWBytesIO);\n+    }\n+\n+    private long sumTokensIOStat(Function<String, Long> mapFunc) {\n+        try {\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+                                .map(mapFunc)\n+                                .collect(Collectors.summingLong(e -> e));\n+        } catch (UncheckedIOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+\n+    private static String[] getRWIOMatchTokenNames() {\n+        return new String[] { \"rios\", \"wios\" };\n+    }\n+\n+    private static String[] getRWBytesIOMatchTokenNames() {\n+        return new String[] { \"rbytes\", \"wbytes\" };\n+    }\n+\n+    public static Long lineToRandWIOs(String line) {\n+        String[] matchNames = getRWIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    public static Long lineToRBytesAndWBytesIO(String line) {\n+        String[] matchNames = getRWBytesIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    private static Long ioStatLineToLong(String line, String[] matchNames) {\n+        if (line == null || EMPTY_STR.equals(line)) {\n+            return Long.valueOf(0);\n+        }\n+        String[] tokens = line.split(\"\\\\s+\");\n+        long retval = 0;\n+        for (String t: tokens) {\n+            String[] valKeys = t.split(\"=\");\n+            if (valKeys.length != 2) {\n+                \/\/ ignore device ids $MAJ:$MIN\n+                continue;\n+            }\n+            for (String match: matchNames) {\n+                if (match.equals(valKeys[0])) {\n+                    retval += longOrZero(valKeys[1]);\n+                }\n+            }\n+        }\n+        return Long.valueOf(retval);\n+    }\n+\n+    private static long longOrZero(String val) {\n+        long lVal = 0;\n+        try {\n+            lVal = Long.parseLong(val);\n+        } catch (NumberFormatException e) {\n+            \/\/ keep at 0\n+        }\n+        return lVal;\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.nio.file.Paths;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_platform_CgroupMetrics.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsUseContainerSupport();\n+}\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jvm.h\"\n-\n-#include \"jdk_internal_platform_cgroupv1_Metrics.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n-{\n-    return JVM_IsUseContainerSupport();\n-}\n","filename":"src\/java.base\/linux\/native\/libjava\/Metrics.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,1 @@\n-            \/\/ We currently only support cgroupv1\n-            Class<?> c = Class.forName(\"jdk.internal.platform.cgroupv1.Metrics\");\n-            @SuppressWarnings(\"unchecked\")\n+            Class<?> c = Class.forName(\"jdk.internal.platform.CgroupMetrics\");\n@@ -77,1 +75,1 @@\n-     * The provider for Linux is cgroupsv1.\n+     * The provider for Linux is cgroups (version 1 or 2).\n@@ -93,1 +91,2 @@\n-     * @return Time in nanoseconds or 0L if metric is not available.\n+     * @return Time in nanoseconds, -1 if unknown or\n+     *         -2 if the metric is not supported.\n@@ -109,1 +108,1 @@\n-     *         this metric is not available, a zero length array will be\n+     *         this metric is not supported or not available, null will be\n@@ -119,1 +118,2 @@\n-     * @return User time in nanoseconds or 0L if metric is not available.\n+     * @return User time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -128,1 +128,2 @@\n-     * @return System time in nanoseconds or 0L if metric is not available.\n+     * @return System time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -141,1 +142,2 @@\n-     * @return time in microseconds or 0L if metric is not available.\n+     * @return time in microseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -151,1 +153,2 @@\n-     * @return time in microseconds or -1 if the quota is unlimited.\n+     * @return time in microseconds, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n@@ -170,1 +173,2 @@\n-     * @return shares value or -1 if no share set.\n+     * @return shares value, -1 if the metric is not available or\n+     *         -2 if cpu shares are not supported.\n@@ -177,2 +181,1 @@\n-     * a CPU quota has been setup for the Isolation Group; otherwise\n-     * returns 0.\n+     * a CPU quota has been setup for the Isolation Group\n@@ -180,1 +183,2 @@\n-     * @return count of elapsed periods or 0 if the quota is unlimited.\n+     * @return count of elapsed periods, -1 if the metric is not available\n+     *         or -2 if the metric is not supported.\n@@ -190,1 +194,2 @@\n-     * @return count of throttled periods or 0 if the quota is unlimited.\n+     * @return count of throttled periods, -1 if the metric is not available or\n+     *         -2 if it is not supported.\n@@ -200,1 +205,2 @@\n-     * @return Throttled time in nanoseconds or 0 if the quota is unlimited.\n+     * @return Throttled time in nanoseconds, -1 if the metric is not available\n+     *         or -2 if it is not supported.\n@@ -232,2 +238,2 @@\n-     * @return An array of available CPUs or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available CPUs. Returns null if the metric is not\n+     *         available or the metric is not supported.\n@@ -244,2 +250,2 @@\n-     * @return An array of available and online CPUs or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online CPUs. Returns null\n+     *         if the metric is not available or the metric is not supported.\n@@ -258,2 +264,2 @@\n-     * @return An array of available memory nodes or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available memory nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -270,2 +276,2 @@\n-     * @return An array of available and online nodes or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -276,21 +282,0 @@\n-    \/**\n-     * Returns the (attempts per second * 1000), if enabled, that the\n-     * operating system tries to satisfy a memory request for any\n-     * process in the current Isolation Group when no free memory is\n-     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n-     * to determine if this support is enabled.\n-     *\n-     * @return Memory pressure or 0 if not enabled or metric is not\n-     *         available.\n-     *\n-     *\/\n-    public double getCpuSetMemoryPressure();\n-\n-    \/**\n-     * Returns the state of the memory pressure detection support.\n-     *\n-     * @return true if the support is available and enabled, otherwise false.\n-     *\n-     *\/\n-    public boolean isCpuSetMemoryPressureEnabled();\n-\n@@ -305,2 +290,3 @@\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available. Returns -2 if the metric is not\n+     *         supported.\n@@ -315,2 +301,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit or -2 if this metric is not supported.\n@@ -321,10 +307,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryMaxUsage();\n-\n@@ -335,2 +311,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available or -2 if the metric is not\n+     *         supported.\n@@ -341,70 +318,0 @@\n-    \/**\n-     * Returns the number of times that kernel memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of kernel physical memory, in bytes, that\n-     * can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of kernel physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryMaxUsage();\n-\n-    \/**\n-     * Returns the amount of kernel physical memory, in bytes, that\n-     * is currently allocated in the current Isolation Group.\n-     *\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryUsage();\n-\n-    \/**\n-     * Returns the number of times that networking memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of networking physical memory, in bytes,\n-     * that can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of networking physical memory, in bytes,\n-     * that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryMaxUsage();\n-\n@@ -415,2 +322,2 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if the metric\n+     *         is not available. Returns -2 if this metric is not supported.\n@@ -421,10 +328,0 @@\n-    \/**\n-     * Returns the number of times that user memory requests in the\n-     * Isolation Group have exceeded the memory + swap limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapFailCount();\n-\n@@ -435,2 +332,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set or -2 if this metric is not supported.\n@@ -441,10 +338,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory and swap space,\n-     * in bytes, that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapMaxUsage();\n-\n@@ -455,2 +342,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available. Returns -2 if this metric is not\n+     *         supported.\n@@ -461,12 +349,0 @@\n-    \/**\n-     * Returns the state of the Operating System Out of Memory termination\n-     * policy.\n-     *\n-     * @return Returns true if operating system will terminate processes\n-     *         in the Isolation Group that exceed the amount of available\n-     *         memory, otherwise false.  Flase will be returned if this\n-     *         capability is not available on the current operating system.\n-     *\n-     *\/\n-    public boolean isMemoryOOMKillEnabled();\n-\n@@ -481,2 +357,2 @@\n-     *         conditions.  If this metric is not available, 0 will be\n-     *         returned.\n+     *         conditions.  If this metric is not available, -1 will be\n+     *         returned. Returns -2 if the metric is not supported.\n@@ -495,1 +371,2 @@\n-     * @return The count of requests or 0 if this metric is not available.\n+     * @return The count of requests or -1 if the metric is not available.\n+     *         Returns -2 if this metric is not supported.\n@@ -504,1 +381,2 @@\n-     * @return The number of bytes transferred or 0 if this metric is not available.\n+     * @return The number of bytes transferred or -1 if the metric is not\n+     *         available. Returns -2 if this metric is not supported.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":52,"deletions":174,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.lang.module.ModuleDescriptor.Requires;\n@@ -52,0 +51,1 @@\n+import java.lang.module.ModuleDescriptor.Requires;\n@@ -65,1 +65,0 @@\n-import java.text.Normalizer;\n@@ -67,0 +66,1 @@\n+import java.text.Normalizer;\n@@ -122,0 +122,1 @@\n+\n@@ -326,0 +327,2 @@\n+        final long longRetvalNotSupported = -2;\n+\n@@ -328,5 +331,3 @@\n-        ostream.println(INDENT + \"CPU Period: \" + c.getCpuPeriod() +\n-               (c.getCpuPeriod() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Quota: \" + c.getCpuQuota() +\n-               (c.getCpuQuota() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Shares: \" + c.getCpuShares());\n+        ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + \"CPU Period: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + \"CPU Quota: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuShares(), INDENT + \"CPU Shares: \", longRetvalNotSupported));\n@@ -335,2 +336,3 @@\n-        ostream.println(INDENT + \"List of Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -338,6 +340,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Processors: N\/A\");\n@@ -347,2 +352,3 @@\n-        ostream.println(INDENT + \"List of Effective Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Effective Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -350,6 +356,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Effective Processors: N\/A\");\n@@ -359,2 +368,3 @@\n-        ostream.println(INDENT + \"List of Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -362,6 +372,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Memory Nodes: N\/A\");\n@@ -371,2 +384,3 @@\n-        ostream.println(INDENT + \"List of Available Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Available Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -374,6 +388,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Available Memory Nodes: N\/A\");\n@@ -382,3 +399,0 @@\n-        ostream.println(INDENT + \"CPUSet Memory Pressure Enabled: \"\n-                + c.isCpuSetMemoryPressureEnabled());\n-\n@@ -386,2 +400,1 @@\n-        ostream.println(INDENT + \"Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Limit: \", longRetvalNotSupported));\n@@ -390,2 +403,1 @@\n-        ostream.println(INDENT + \"Memory Soft Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Soft Limit: \", longRetvalNotSupported));\n@@ -394,6 +406,1 @@\n-        ostream.println(INDENT + \"Memory & Swap Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n-\n-        limit = c.getKernelMemoryLimit();\n-        ostream.println(INDENT + \"Kernel Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory & Swap Limit: \", longRetvalNotSupported));\n@@ -401,3 +408,2 @@\n-        limit = c.getTcpMemoryLimit();\n-        ostream.println(INDENT + \"TCP Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(\"\");\n+    }\n@@ -405,2 +411,9 @@\n-        ostream.println(INDENT + \"Out Of Memory Killer Enabled: \"\n-                + c.isMemoryOOMKillEnabled());\n+    private static String formatLimitString(long limit, String prefix, long unavailable) {\n+        if (limit >= 0) {\n+            return prefix + SizePrefix.scaleValue(limit);\n+        } else if (limit == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + \"Unlimited\";\n+        }\n+    }\n@@ -408,1 +421,8 @@\n-        ostream.println(\"\");\n+    private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {\n+        if (cpuVal >= 0) {\n+            return prefix + cpuVal + \"us\";\n+        } else if (cpuVal == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + cpuVal;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":79,"deletions":59,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        if (containerMetrics != null) {\n+        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,8 +46,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(metrics);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @run junit\/othervm TestCgroupSubsystemController\n+ *\/\n+\n+\/**\n+ *\n+ * Basic unit test for CgroupSubsystemController\n+ *\n+ *\/\n+public class TestCgroupSubsystemController {\n+\n+    private static final double DELTA = 0.01;\n+    private Path existingDirectory;\n+    private Path existingFile;\n+    private String existingFileName = \"test-controller-file\";\n+    private String existingFileContents = \"foobar\";\n+    private String doubleValueContents = \"1.5\";\n+    private String longValueContents = \"3000000000\";\n+    private String longValueMatchingLineContents = \"testme\\n\" +\n+                                                   \"itemfoo 25\";\n+    private String longEntryContents = \"s 1\\n\" +\n+                                       \"t 2\";\n+    private String longEntryName = \"longEntry\";\n+    private String longEntryMatchingLineName = \"longMatchingLine\";\n+    private String doubleValueName = \"doubleValue\";\n+    private String longValueName = \"longValue\";\n+    private CgroupSubsystemController mockController;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemController.class.getSimpleName());\n+            existingFile = Paths.get(existingDirectory.toString(), existingFileName);\n+            Files.writeString(existingFile, existingFileContents, StandardCharsets.UTF_8);\n+            Path longFile = Paths.get(existingDirectory.toString(), longValueName);\n+            Files.writeString(longFile, longValueContents);\n+            Path doubleFile = Paths.get(existingDirectory.toString(), doubleValueName);\n+            Files.writeString(doubleFile, doubleValueContents);\n+            Path longEntryFile = Paths.get(existingDirectory.toString(), longEntryName);\n+            Files.writeString(longEntryFile, longEntryContents);\n+            Path longMatchingLine = Paths.get(existingDirectory.toString(), longEntryMatchingLineName);\n+            Files.writeString(longMatchingLine, longValueMatchingLineContents);\n+            mockController = new MockCgroupSubsystemController(existingDirectory.toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void getStringValueNullController() {\n+        String val = CgroupSubsystemController.getStringValue(null, \"ignore\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueIOException() throws IOException {\n+        String val = CgroupSubsystemController.getStringValue(mockController, \"don-t-exist.txt\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueSuccess() {\n+        String actual = CgroupSubsystemController.getStringValue(mockController, existingFileName);\n+        assertEquals(existingFileContents, actual);\n+    }\n+\n+    @Test\n+    public void convertStringToLong() {\n+        String strVal = \"1230\";\n+        long longVal = Long.parseLong(strVal);\n+        long actual = CgroupSubsystemController.convertStringToLong(strVal, -1L, 0);\n+        assertEquals(longVal, actual);\n+\n+        String overflowVal = \"9223372036854775808\"; \/\/ Long.MAX_VALUE + 1\n+        long overflowDefault = -1;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+        overflowDefault = Long.MAX_VALUE;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+    }\n+\n+    @Test\n+    public void convertStringRangeToIntArray() {\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(null));\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(\"\"));\n+        String strRange = \"2,4,6\";\n+        int[] actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        int[] expected = new int[] { 2, 4, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+        strRange = \"6,1-3\";\n+        actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        expected = new int[] { 1, 2, 3, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void getDoubleValue() {\n+        double defaultValue = -3;\n+        double actual = CgroupSubsystemController.getDoubleValue(null, null, defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+        double expected = Double.parseDouble(doubleValueContents);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, doubleValueName, defaultValue);\n+        assertEquals(expected, actual, DELTA);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, \"don't-exist\", defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+    }\n+\n+    @Test\n+    public void getLongValue() {\n+        long defaultValue = -4;\n+        long actual = CgroupSubsystemController.getLongValue(null, null, Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValue(mockController, \"dont-exist\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        long expected = Long.parseLong(longValueContents);\n+        actual = CgroupSubsystemController.getLongValue(mockController, longValueName, Long::parseLong, defaultValue);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void getLongEntry() {\n+        long defaultValue = -5;\n+        long actual = CgroupSubsystemController.getLongEntry(null, null, \"no-matter\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, \"dont-exist\", \"foo-bar\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, longEntryName, \"t\", defaultValue);\n+        assertEquals(2, actual);\n+    }\n+\n+    @Test\n+    public void getLongMatchingLine() {\n+        long defaultValue = -6;\n+        long actual = CgroupSubsystemController.getLongValueMatchingLine(null, null, \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, \"dont-exist\", \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, longEntryMatchingLineName, \"item\", TestCgroupSubsystemController::convertLong, defaultValue);\n+        assertEquals(25, actual);\n+    }\n+\n+    public static long convertLong(String line) {\n+        return Long.parseLong(line.split(\"\\\\s+\")[1]);\n+    }\n+\n+    static class MockCgroupSubsystemController implements CgroupSubsystemController {\n+\n+        private final String path;\n+\n+        public MockCgroupSubsystemController(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String path() {\n+            return path;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -146,0 +146,5 @@\n+        if (\"cgroupv2\".equals(metrics.getProvider()) && shares < 1024) {\n+            \/\/ Adjust input shares for < 1024 cpu shares as the\n+            \/\/ impl. rounds up to the next multiple of 1024\n+            shares = 1024;\n+        }\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+import jdk.internal.platform.CgroupV1Metrics;\n@@ -78,0 +80,1 @@\n+            boolean atLeastOneAllocationWorked = false;\n@@ -81,0 +84,1 @@\n+                    atLeastOneAllocationWorked = true;\n@@ -90,0 +94,6 @@\n+            if (!atLeastOneAllocationWorked) {\n+                System.out.println(\"Allocation failed immediately. Ignoring test!\");\n+                return;\n+            }\n+            \/\/ Be sure bytes allocations don't get optimized out\n+            System.out.println(\"DEBUG: Bytes allocation length 1: \" + bytes[0].length);\n@@ -113,9 +123,16 @@\n-        long limit = getMemoryValue(value);\n-        long kmemlimit = Metrics.systemMetrics().getKernelMemoryLimit();\n-        \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n-        \/\/ This feature is deprecated. Only perform the check if we get an actual\n-        \/\/ limit back.\n-        if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n-            throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n-                    + limit + \"]\" + \", got : [\"\n-                    + kmemlimit + \"]\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            System.out.println(\"TEST PASSED!!!\");\n+            long limit = getMemoryValue(value);\n+            long kmemlimit = mCgroupV1.getKernelMemoryLimit();\n+            \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n+            \/\/ This feature is deprecated. Only perform the check if we get an actual\n+            \/\/ limit back.\n+            if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n+                throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n+                            + limit + \"]\" + \", got : [\"\n+                            + kmemlimit + \"]\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -123,1 +140,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n@@ -157,2 +173,11 @@\n-        if (!(oomKillFlag ^ Metrics.systemMetrics().isMemoryOOMKillEnabled())) {\n-            throw new RuntimeException(\"oomKillFlag error\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            Boolean expected = Boolean.valueOf(oomKillFlag);\n+            Boolean actual = mCgroupV1.isMemoryOOMKillEnabled();\n+            if (!(expected.equals(actual))) {\n+                throw new RuntimeException(\"oomKillFlag error\");\n+            }\n+            System.out.println(\"TEST PASSED!!!\");\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -160,1 +185,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            if (cpuSetMems.length > 1) {\n+            if (cpuSetMems != null && cpuSetMems.length > 1) {\n@@ -84,1 +84,1 @@\n-            } else if (cpuSetMems.length == 1) {\n+            } else if (cpuSetMems != null && cpuSetMems.length == 1) {\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -60,4 +62,15 @@\n-            testKernelMemoryLimit(\"100m\");\n-            testKernelMemoryLimit(\"1g\");\n-\n-            testOomKillFlag(\"100m\", false);\n+            Metrics m = Metrics.systemMetrics();\n+            \/\/ kernel memory, '--kernel-memory' switch, and OOM killer,\n+            \/\/ '--oom-kill-disable' switch, tests not supported by cgroupv2\n+            \/\/ runtimes\n+            if (m != null) {\n+                if (\"cgroupv1\".equals(m.getProvider())) {\n+                    testKernelMemoryLimit(\"100m\");\n+                    testKernelMemoryLimit(\"1g\");\n+\n+                    testOomKillFlag(\"100m\", false);\n+                } else {\n+                    System.out.println(\"kernel memory tests and OOM Kill flag tests not \" +\n+                                       \"possible with cgroupv2.\");\n+                }\n+            }\n@@ -71,1 +84,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -137,1 +152,2 @@\n-        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+        OutputAnalyzer oa = DockerTestUtils.dockerRunJava(opts);\n+        oa.shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -57,2 +58,1 @@\n-        try {\n-            Stream<String> stream = Files.lines(Paths.get(path));\n+        try (Stream<String> stream = Files.lines(Paths.get(path))) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CPUSetsReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+interface CgroupMetricsTester {\n+\n+    public static final double ERROR_MARGIN = 0.1;\n+    public static final String EMPTY_STR = \"\";\n+\n+    public void testMemorySubsystem();\n+    public void testCpuAccounting();\n+    public void testCpuSchedulingMetrics();\n+    public void testCpuSets();\n+    public void testCpuConsumption() throws IOException, InterruptedException;\n+    public void testMemoryUsage() throws Exception;\n+    public void testMisc();\n+\n+    public static long convertStringToLong(String strval, long overflowRetval) {\n+        long retval = 0;\n+        if (strval == null) return 0L;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n+            \/\/ In this case, return Long.MAX_VALUE\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static boolean compareWithErrorMargin(long oldVal, long newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static boolean compareWithErrorMargin(double oldVal, double newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static void fail(String controller, String metric, long oldVal, long testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, String oldVal, String testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, double oldVal, double testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, boolean oldVal, boolean testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void warn(String controller, String metric, long oldVal, long testVal) {\n+        System.err.println(\"Warning - \" + controller + \":\" + metric\n+                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static Integer[] convertCpuSetsToArray(String cpusstr) {\n+        if (cpusstr == null || EMPTY_STR.equals(cpusstr)) {\n+            return new Integer[0];\n+        }\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] cpuSets = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n+            if (a.contains(\"-\")) {\n+                String[] range = a.split(\"-\");\n+                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n+                        Integer.parseInt(range[1])).boxed();\n+            } else {\n+                return Stream.of(Integer.parseInt(a));\n+            }\n+        }).toArray(Integer[]::new);\n+        return cpuSets;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc.\n@@ -24,0 +24,1 @@\n+\n@@ -26,17 +27,2 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n+import java.util.Objects;\n+\n@@ -45,0 +31,4 @@\n+\/**\n+ * Cgroup version agnostic metrics tester\n+ *\n+ *\/\n@@ -47,293 +37,2 @@\n-    private static final double ERROR_MARGIN = 0.1;\n-    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-    long startSysVal;\n-    long startUserVal;\n-    long startUsage;\n-    long startPerCpu[];\n-\n-    enum SubSystem {\n-        MEMORY(\"memory\"),\n-        CPUSET(\"cpuset\"),\n-        CPU(\"cpu\"),\n-        CPUACCT(\"cpuacct\"),\n-        BLKIO(\"blkio\");\n-\n-        private String value;\n-\n-        SubSystem(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private static final Set<String> allowedSubSystems =\n-            Stream.of(SubSystem.values()).map(SubSystem::value).collect(Collectors.toSet());\n-\n-    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n-\n-    private static void setPath(String[] line) {\n-        String cgroupPath = line[2];\n-        String[] subSystems = line[1].split(\",\");\n-\n-        for (String subSystem : subSystems) {\n-            if (allowedSubSystems.contains(subSystem)) {\n-                String[] paths = subSystemPaths.get(subSystem);\n-                String finalPath = \"\";\n-                String root = paths[0];\n-                String mountPoint = paths[1];\n-                if (root != null && cgroupPath != null) {\n-                    if (root.equals(\"\/\")) {\n-                        if (!cgroupPath.equals(\"\/\")) {\n-                            finalPath = mountPoint + cgroupPath;\n-                        } else {\n-                            finalPath = mountPoint;\n-                        }\n-                    } else {\n-                        if (root.equals(cgroupPath)) {\n-                            finalPath = mountPoint;\n-                        } else {\n-                            if (cgroupPath.startsWith(root)) {\n-                                if (cgroupPath.length() > root.length()) {\n-                                    String cgroupSubstr = cgroupPath.substring(root.length());\n-                                    finalPath = mountPoint + cgroupSubstr;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n-            }\n-        }\n-    }\n-\n-    private static void createSubsystems(String[] line) {\n-        if (line.length < 5) return;\n-        Path p = Paths.get(line[4]);\n-        String subsystemName = p.getFileName().toString();\n-        if (subsystemName != null) {\n-            for (String subSystem : subsystemName.split(\",\")) {\n-                if (allowedSubSystems.contains(subSystem)) {\n-                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n-                }\n-            }\n-        }\n-    }\n-\n-    public void setup() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ Initialize CPU usage metrics before we do any testing.\n-        startSysVal = metrics.getCpuSystemUsage();\n-        startUserVal = metrics.getCpuUserUsage();\n-        startUsage = metrics.getCpuUsage();\n-        startPerCpu = metrics.getPerCpuUsage();\n-\n-        try {\n-            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n-            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n-                    .map(line -> line.split(\" \"))\n-                    .forEach(MetricsTester::createSubsystems);\n-            lines.close();\n-\n-            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n-            lines.map(line -> line.split(\":\"))\n-                    .filter(line -> (line.length >= 3))\n-                    .forEach(MetricsTester::setPath);\n-            lines.close();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    private static String getFileContents(SubSystem subSystem, String fileName) {\n-        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n-        try {\n-            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n-        } catch (FileNotFoundException e) {\n-            System.err.println(\"Unable to open : \" + fname);\n-            return \"\";\n-        }\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0L : convertStringToLong(data);\n-    }\n-\n-    private static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String metric, String subMetric) {\n-        String stats = getFileContents(subSystem, metric);\n-        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n-        for (int i = 0; i < tokens.length; i++) {\n-            if (tokens[i].startsWith(subMetric)) {\n-                String strval = tokens[i].split(\"\\\\s+\")[1];\n-                return convertStringToLong(strval);\n-            }\n-        }\n-        return 0L;\n-    }\n-\n-    private static double getDoubleValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n-    }\n-\n-    private boolean compareWithErrorMargin(long oldVal, long newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private boolean compareWithErrorMargin(double oldVal, double newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private static void fail(SubSystem system, String metric, long oldVal, long testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, String oldVal, String testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, double oldVal, double testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, boolean oldVal, boolean testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void warn(SubSystem system, String metric, long oldVal, long testVal) {\n-        System.err.println(\"Warning - \" + system.value + \":\" + metric\n-                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    public void testMemorySubsystem() {\n-        Metrics metrics = Metrics.systemMetrics();\n-\n-        \/\/ User Memory\n-        long oldVal = metrics.getMemoryFailCount();\n-        long newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/ Kernel memory\n-        oldVal = metrics.getKernelMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/TCP Memory\n-        oldVal = metrics.getTcpMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/  Memory and Swap\n-        \/\/ Skip swap tests if no swap is configured.\n-        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n-            oldVal = metrics.getMemoryAndSwapFailCount();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.failcnt\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapLimit();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\");\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapMaxUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n-            }\n-        }\n+    private static final String CGROUP_V1 = \"cgroupv1\";\n+    private static final String CGROUP_V2 = \"cgroupv2\";\n@@ -341,14 +40,12 @@\n-        oldVal = metrics.getMemorySoftLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n-        boolean newOomKillEnabled = getLongValueFromFile(SubSystem.MEMORY,\n-                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n-        if (oomKillEnabled != newOomKillEnabled) {\n-            throw new RuntimeException(\"Test failed for - \" + SubSystem.MEMORY.value + \":\"\n-                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n-                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+    private static CgroupMetricsTester createInstance(Metrics m) {\n+        Objects.requireNonNull(m);\n+        if (CGROUP_V1.equals(m.getProvider())) {\n+            MetricsTesterCgroupV1 t = new MetricsTesterCgroupV1();\n+            t.setup();\n+            return t;\n+        } else if (CGROUP_V2.equals(m.getProvider())) {\n+            return new MetricsTesterCgroupV2();\n+        } else {\n+            System.err.println(\"WARNING: Metrics provider, '\" + m.getProvider()\n+                                                              + \"' is unknown!\");\n+            return null;\n@@ -358,253 +55,9 @@\n-    public void testCpuAccounting() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuUsage();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.usage\");\n-\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n-        }\n-\n-        Long[] newVals = Stream.of(getFileContents(SubSystem.CPUACCT, \"cpuacct.usage_percpu\")\n-                .split(\"\\\\s+\"))\n-                .map(Long::parseLong)\n-                .toArray(Long[]::new);\n-        Long[] oldVals = LongStream.of(metrics.getPerCpuUsage()).boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(SubSystem.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n-            }\n-        }\n-\n-        oldVal = metrics.getCpuUserUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"user\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuSystemUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"system\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSchedulingMetrics() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuPeriod();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_period_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuQuota();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_quota_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuShares();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.shares\");\n-        if (newVal == 0 || newVal == 1024) newVal = -1;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.shares\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumPeriods();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_periods\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumThrottled();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuThrottledTime();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"throttled_time\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSets() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-\n-        String cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.cpus\");\n-        \/\/ Parse range string in the format 1,2-6,7\n-        Integer[] newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n-                Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-        cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.mems\");\n-        newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n-                    Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_mems\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        double oldValue = metrics.getCpuSetMemoryPressure();\n-        double newValue = getDoubleValueFromFile(SubSystem.CPUSET, \"cpuset.memory_pressure\");\n-        if (!compareWithErrorMargin(oldValue, newValue)) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n-        }\n-\n-        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n-        boolean newV = getLongValueFromFile(SubSystem.CPUSET,\n-                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n-        if (oldV != newV) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n-        }\n-    }\n-\n-    public void testBlkIO() {\n-        Metrics metrics = Metrics.systemMetrics();\n-            long oldVal = metrics.getBlkIOServiceCount();\n-        long newVal = getLongValueFromFile(SubSystem.BLKIO,\n-                \"blkio.throttle.io_service_bytes\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n-                    oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getBlkIOServiced();\n-        newVal = getLongValueFromFile(SubSystem.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuConsumption() throws IOException, InterruptedException {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ make system call\n-        long newSysVal = metrics.getCpuSystemUsage();\n-        long newUserVal = metrics.getCpuUserUsage();\n-        long newUsage = metrics.getCpuUsage();\n-        long[] newPerCpu = metrics.getPerCpuUsage();\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newSysVal < startSysVal) {\n-            fail(SubSystem.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n-        }\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newUserVal < startUserVal) {\n-            fail(SubSystem.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n-        }\n-\n-        if (newUsage <= startUsage) {\n-            fail(SubSystem.CPU, \"getCpuUsage\", newUsage, startUsage);\n-        }\n-\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n-            }\n-        }\n-\n-        if(!success) fail(SubSystem.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n-    }\n-\n-    public void testMemoryUsage() throws Exception {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n-        long memoryUsage = metrics.getMemoryUsage();\n-        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n-\n-        \/\/ allocate memory in a loop and check more than once for new values\n-        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n-        \/\/ e.g. because the system could free up memory\n-        byte[][] bytes = new byte[32][];\n-        for (int i = 0; i < 32; i++) {\n-            bytes[i] = new byte[8*1024*1024];\n-            newMemoryUsage = metrics.getMemoryUsage();\n-            if (newMemoryUsage > memoryUsage) {\n-                break;\n-            }\n-        }\n-        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n-\n-        if (newMemoryMaxUsage < memoryMaxUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n-                    newMemoryMaxUsage);\n-        }\n-\n-        if (newMemoryUsage < memoryUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n-        }\n+    public void testAll(Metrics m) throws Exception {\n+        CgroupMetricsTester tester =  createInstance(m);\n+        tester.testCpuAccounting();\n+        tester.testCpuConsumption();\n+        tester.testCpuSchedulingMetrics();\n+        tester.testCpuSets();\n+        tester.testMemorySubsystem();\n+        tester.testMemoryUsage();\n+        tester.testMisc();\n@@ -614,0 +67,1 @@\n+        Metrics m = Metrics.systemMetrics();\n@@ -615,2 +69,1 @@\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n+        if (m == null) {\n@@ -622,8 +75,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(m);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":34,"deletions":588,"binary":false,"changes":622,"status":"modified"},{"patch":"@@ -0,0 +1,572 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class MetricsTesterCgroupV1 implements CgroupMetricsTester {\n+\n+    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n+    long startSysVal;\n+    long startUserVal;\n+    long startUsage;\n+    long startPerCpu[];\n+\n+    enum Controller {\n+        MEMORY(\"memory\"),\n+        CPUSET(\"cpuset\"),\n+        CPU(\"cpu\"),\n+        CPUACCT(\"cpuacct\"),\n+        BLKIO(\"blkio\");\n+\n+        private String value;\n+\n+        Controller(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private static final Set<String> allowedSubSystems =\n+            Stream.of(Controller.values()).map(Controller::value).collect(Collectors.toSet());\n+\n+    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n+\n+    private static void setPath(String[] line) {\n+        String cgroupPath = line[2];\n+        String[] subSystems = line[1].split(\",\");\n+\n+        for (String subSystem : subSystems) {\n+            if (allowedSubSystems.contains(subSystem)) {\n+                String[] paths = subSystemPaths.get(subSystem);\n+                String finalPath = \"\";\n+                String root = paths[0];\n+                String mountPoint = paths[1];\n+                if (root != null && cgroupPath != null) {\n+                    if (root.equals(\"\/\")) {\n+                        if (!cgroupPath.equals(\"\/\")) {\n+                            finalPath = mountPoint + cgroupPath;\n+                        } else {\n+                            finalPath = mountPoint;\n+                        }\n+                    } else {\n+                        if (root.equals(cgroupPath)) {\n+                            finalPath = mountPoint;\n+                        } else {\n+                            if (cgroupPath.startsWith(root)) {\n+                                if (cgroupPath.length() > root.length()) {\n+                                    String cgroupSubstr = cgroupPath.substring(root.length());\n+                                    finalPath = mountPoint + cgroupSubstr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n+            }\n+        }\n+    }\n+\n+    private static void createSubsystems(String[] line) {\n+        if (line.length < 5) return;\n+        Path p = Paths.get(line[4]);\n+        String subsystemName = p.getFileName().toString();\n+        if (subsystemName != null) {\n+            for (String subSystem : subsystemName.split(\",\")) {\n+                if (allowedSubSystems.contains(subSystem)) {\n+                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setup() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+        startPerCpu = metrics.getPerCpuUsage();\n+        if (startPerCpu == null) {\n+            startPerCpu = new long[0];\n+        }\n+\n+        try {\n+            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n+            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n+                    .map(line -> line.split(\" \"))\n+                    .forEach(MetricsTesterCgroupV1::createSubsystems);\n+            lines.close();\n+\n+            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n+            lines.map(line -> line.split(\":\"))\n+                    .filter(line -> (line.length >= 3))\n+                    .forEach(MetricsTesterCgroupV1::setPath);\n+            lines.close();\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private static String getFileContents(Controller subSystem, String fileName) {\n+        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n+        try {\n+            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n+        } catch (FileNotFoundException e) {\n+            System.err.println(\"Unable to open : \" + fname);\n+            return null;\n+        }\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return (data == null || data.isEmpty()) ? 0L : convertStringToLong(data);\n+    }\n+\n+    private static long convertStringToLong(String strval) {\n+        return CgroupMetricsTester.convertStringToLong(strval, Long.MAX_VALUE);\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String metric, String subMetric) {\n+        String stats = getFileContents(subSystem, metric);\n+        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n+        for (int i = 0; i < tokens.length; i++) {\n+            if (tokens[i].startsWith(subMetric)) {\n+                String strval = tokens[i].split(\"\\\\s+\")[1];\n+                return convertStringToLong(strval);\n+            }\n+        }\n+        return 0L;\n+    }\n+\n+    private static double getDoubleValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n+    }\n+\n+    private static void fail(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, String oldVal, String testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, double oldVal, double testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, boolean oldVal, boolean testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void warn(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.warn(system.value, metric, oldVal, testVal);\n+    }\n+\n+    public void testMemorySubsystem() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueFromFile(Controller.MEMORY, \"memory.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/ Kernel memory\n+        oldVal = metrics.getKernelMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/TCP Memory\n+        oldVal = metrics.getTcpMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/  Memory and Swap\n+        \/\/ Skip swap tests if no swap is configured.\n+        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n+            oldVal = metrics.getMemoryAndSwapFailCount();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.failcnt\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapLimit();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.limit_in_bytes\");\n+            newVal = newVal > unlimited_minimum ? -1L : newVal;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapMaxUsage();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n+            }\n+\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                oldVal = metrics.getMemoryAndSwapUsage();\n+                newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.usage_in_bytes\");\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                    fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                }\n+            }\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.soft_limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n+        boolean newOomKillEnabled = getLongValueFromFile(Controller.MEMORY,\n+                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n+        if (oomKillEnabled != newOomKillEnabled) {\n+            throw new RuntimeException(\"Test failed for - \" + Controller.MEMORY.value + \":\"\n+                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n+                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+        }\n+    }\n+\n+    public void testCpuAccounting() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.usage\");\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n+        }\n+\n+        String newValsStr = getFileContents(Controller.CPUACCT, \"cpuacct.usage_percpu\");\n+        Long[] newVals = new Long[0];\n+        if (newValsStr != null) {\n+            newVals = Stream.of(newValsStr\n+                .split(\"\\\\s+\"))\n+                .map(Long::parseLong)\n+                .toArray(Long[]::new);\n+        }\n+        long[] oldValsPrim = metrics.getPerCpuUsage();\n+        Long[] oldVals = LongStream.of(oldValsPrim == null ? new long[0] : oldValsPrim)\n+                                    .boxed().toArray(Long[]::new);\n+        for (int i = 0; i < oldVals.length; i++) {\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+            }\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"user\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"system\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSchedulingMetrics() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_period_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_quota_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.shares\");\n+        if (newVal == 0 || newVal == 1024) newVal = -1;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.shares\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"throttled_time\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSets() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getFileContents(Controller.CPUSET, \"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n+                Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSets.length != 0) {\n+            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSetMems.length != 0) {\n+            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        double oldValue = metrics.getCpuSetMemoryPressure();\n+        double newValue = getDoubleValueFromFile(Controller.CPUSET, \"cpuset.memory_pressure\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldValue, newValue)) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n+        }\n+\n+        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n+        boolean newV = getLongValueFromFile(Controller.CPUSET,\n+                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n+        if (oldV != newV) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n+        }\n+    }\n+\n+    private void testBlkIO() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+            long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getLongValueFromFile(Controller.BLKIO,\n+                \"blkio.throttle.io_service_bytes\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n+                    oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getLongValueFromFile(Controller.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuConsumption() throws IOException, InterruptedException {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+        long[] newPerCpu = metrics.getPerCpuUsage();\n+        if (newPerCpu == null) {\n+            newPerCpu = new long[0];\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(Controller.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(Controller.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(Controller.CPU, \"getCpuUsage\", newUsage, startUsage);\n+        }\n+\n+        boolean success = false;\n+        for (int i = 0; i < startPerCpu.length; i++) {\n+            if (newPerCpu[i] > startPerCpu[i]) {\n+                success = true;\n+                break;\n+            }\n+        }\n+\n+        if(!success) fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                Arrays.toString(startPerCpu));\n+    }\n+\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testBlkIO();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":572,"deletions":0,"binary":false,"changes":572,"status":"added"},{"patch":"@@ -0,0 +1,468 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.Metrics;\n+\n+public class MetricsTesterCgroupV2 implements CgroupMetricsTester {\n+\n+    private static final long UNLIMITED = -1;\n+    private static final UnifiedController UNIFIED = new UnifiedController();\n+    private static final String MAX = \"max\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    private final long startSysVal;\n+    private final long startUserVal;\n+    private final long startUsage;\n+\n+    static class UnifiedController {\n+\n+        private static final String NAME = \"unified\";\n+        private final String path;\n+\n+        UnifiedController() {\n+            path = constructPath();\n+        }\n+\n+        String getPath() {\n+            return path;\n+        }\n+\n+        private static String constructPath() {\n+            String mountPath;\n+            String cgroupPath;\n+            try {\n+                List<String> fifthTokens = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))\n+                        .filter( l -> l.contains(\"- cgroup2\"))\n+                        .map(UnifiedController::splitAndMountPath)\n+                        .collect(Collectors.toList());\n+                if (fifthTokens.size() != 1) {\n+                    throw new AssertionError(\"Expected only one cgroup2 line\");\n+                }\n+                mountPath = fifthTokens.get(0);\n+\n+                List<String> cgroupPaths = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))\n+                        .filter( l -> l.startsWith(\"0:\"))\n+                        .map(UnifiedController::splitAndCgroupPath)\n+                        .collect(Collectors.toList());\n+                if (cgroupPaths.size() != 1) {\n+                    throw new AssertionError(\"Expected only one unified controller line\");\n+                }\n+                cgroupPath = cgroupPaths.get(0);\n+                return Paths.get(mountPath, cgroupPath).toString();\n+            } catch (IOException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static String splitAndMountPath(String input) {\n+            String[] tokens = input.split(\"\\\\s+\");\n+            return tokens[4]; \/\/ fifth entry is the mount path\n+        }\n+\n+        public static String splitAndCgroupPath(String input) {\n+            String[] tokens = input.split(\":\");\n+            return tokens[2];\n+        }\n+    }\n+\n+    private long getLongLimitValueFromFile(String file) {\n+        String strVal = getStringVal(file);\n+        if (MAX.equals(strVal)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(strVal);\n+    }\n+\n+    public MetricsTesterCgroupV2() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+    }\n+\n+    private long getLongValueFromFile(String file) {\n+        return convertStringToLong(getStringVal(file));\n+    }\n+\n+    private long getLongValueEntryFromFile(String file, String metric) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            String strVal = Files.lines(filePath).filter(l -> l.startsWith(metric)).collect(Collectors.joining());\n+            String[] keyValues = strVal.split(\"\\\\s+\");\n+            String value = keyValues[1];\n+            return convertStringToLong(value);\n+        } catch (IOException e) {\n+            return 0;\n+        }\n+    }\n+\n+    private String getStringVal(String file) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            return Files.lines(filePath).collect(Collectors.joining());\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private void fail(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void fail(String metric, String oldVal, String newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void warn(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.warn(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private long getCpuShares(String file) {\n+        long rawVal = getLongValueFromFile(file);\n+        if (rawVal == 0 || rawVal == 100) {\n+            return UNLIMITED;\n+        }\n+        int shares = (int)rawVal;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    private long getCpuMaxValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 0 \/* $MAX index *\/);\n+    }\n+\n+    private long getCpuPeriodValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 1 \/* $PERIOD index *\/);\n+    }\n+\n+    private long getCpuValueFromFile(String file, int index) {\n+        String maxPeriod = getStringVal(file);\n+        if (maxPeriod == null) {\n+            return UNLIMITED;\n+        }\n+        String[] tokens = maxPeriod.split(\"\\\\s+\");\n+        String val = tokens[index];\n+        if (MAX.equals(val)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(val);\n+    }\n+\n+    private long convertStringToLong(String val) {\n+        return CgroupMetricsTester.convertStringToLong(val, UNLIMITED);\n+    }\n+\n+    @Override\n+    public void testMemorySubsystem() {\n+        Metrics metrics = Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueEntryFromFile(\"memory.events\", \"max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.events[max]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(\"memory.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueEntryFromFile(\"memory.stat\", \"sock\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.stat[sock]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.swap.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapUsage();\n+        newVal = getLongValueFromFile(\"memory.swap.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.high\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.high\", oldVal, newVal);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testCpuAccounting() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[usage_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[user_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[system_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSchedulingMetrics() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getCpuPeriodValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$PERIOD]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getCpuMaxValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$MAX]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getCpuShares(\"cpu.weight\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.weight\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_periods]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_throttled]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[throttled_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSets() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        int[] cpus = mapNullToEmpty(metrics.getCpuSetCpus());\n+        Integer[] oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getStringVal(\"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetCpus());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.cpus.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+    }\n+\n+    private int[] mapNullToEmpty(int[] cpus) {\n+        if (cpus == null) {\n+            \/\/ Not available. For sake of testing continue with an\n+            \/\/ empty array.\n+            cpus = new int[0];\n+        }\n+        return cpus;\n+    }\n+\n+    @Override\n+    public void testCpuConsumption() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(\"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(\"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(\"getCpuUsage\", newUsage, startUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testIOStat();\n+    }\n+\n+    private void testIOStat() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getIoStatAccumulate(new String[] { \"rios\", \"wios\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rios\/wios: \", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getIoStatAccumulate(new String[] { \"rbytes\", \"wbytes\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rbytes\/wbytes: \", oldVal, newVal);\n+        }\n+    }\n+\n+    private long getIoStatAccumulate(String[] matchNames) {\n+        try {\n+            return Files.lines(Paths.get(UNIFIED.getPath(), \"io.stat\"))\n+                    .map(line -> {\n+                        long accumulator = 0;\n+                        String[] tokens = line.split(\"\\\\s+\");\n+                        for (String t: tokens) {\n+                            String[] keyVal = t.split(\"=\");\n+                            if (keyVal.length != 2) {\n+                                continue;\n+                            }\n+                            for (String match: matchNames) {\n+                                if (match.equals(keyVal[0])) {\n+                                    accumulator += Long.parseLong(keyVal[1]);\n+                                }\n+                            }\n+                        }\n+                        return accumulator;\n+                    }).collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":468,"deletions":0,"binary":false,"changes":468,"status":"added"}]}