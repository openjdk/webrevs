{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -46,2 +48,4 @@\n-        final Throwable[] throwable = new Throwable[1];\n-        final ConcurrentHashMap<Integer, Integer> m = new ConcurrentHashMap<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+        try {\n+            final Throwable[] throwable = new Throwable[1];\n+            final ConcurrentHashMap<Integer, Integer> m = new ConcurrentHashMap<>();\n@@ -49,5 +53,5 @@\n-        \/\/ Number of workers equal to the number of processors\n-        \/\/ Each worker will put globally unique keys into the map\n-        final int nWorkers = Runtime.getRuntime().availableProcessors();\n-        final int sizePerWorker = 1024;\n-        final int maxSize = nWorkers * sizePerWorker;\n+            \/\/ Number of workers equal to the number of processors\n+            \/\/ Each worker will put globally unique keys into the map\n+            final int nWorkers = Runtime.getRuntime().availableProcessors();\n+            final int sizePerWorker = 1024;\n+            final int maxSize = nWorkers * sizePerWorker;\n@@ -55,7 +59,7 @@\n-        \/\/ The foreman keeps checking that the size of the arrays\n-        \/\/ obtained from the key and value sets is never less than the\n-        \/\/ previously observed size and is never greater than the maximum size\n-        \/\/ NOTE: these size constraints are not specific to toArray and are\n-        \/\/ applicable to any form of traversal of the collection views\n-        CompletableFuture<?> foreman = CompletableFuture.runAsync(new Runnable() {\n-            private int prevSize = 0;\n+            \/\/ The foreman keeps checking that the size of the arrays\n+            \/\/ obtained from the key and value sets is never less than the\n+            \/\/ previously observed size and is never greater than the maximum size\n+            \/\/ NOTE: these size constraints are not specific to toArray and are\n+            \/\/ applicable to any form of traversal of the collection views\n+            CompletableFuture<?> foreman = CompletableFuture.runAsync(new Runnable() {\n+                private int prevSize = 0;\n@@ -63,8 +67,8 @@\n-            private boolean checkProgress(Object[] a) {\n-                int size = a.length;\n-                if (size < prevSize) throw new RuntimeException(\"WRONG WAY\");\n-                if (size > maxSize) throw new RuntimeException(\"OVERSHOOT\");\n-                if (size == maxSize) return true;\n-                prevSize = size;\n-                return false;\n-            }\n+                private boolean checkProgress(Object[] a) {\n+                    int size = a.length;\n+                    if (size < prevSize) throw new RuntimeException(\"WRONG WAY\");\n+                    if (size > maxSize) throw new RuntimeException(\"OVERSHOOT\");\n+                    if (size == maxSize) return true;\n+                    prevSize = size;\n+                    return false;\n+                }\n@@ -72,9 +76,12 @@\n-            @Override\n-            public void run() {\n-                try {\n-                    Integer[] empty = new Integer[0];\n-                    while (true) {\n-                        if (checkProgress(m.values().toArray())) return;\n-                        if (checkProgress(m.keySet().toArray())) return;\n-                        if (checkProgress(m.values().toArray(empty))) return;\n-                        if (checkProgress(m.keySet().toArray(empty))) return;\n+                @Override\n+                public void run() {\n+                    try {\n+                        Integer[] empty = new Integer[0];\n+                        while (true) {\n+                            if (checkProgress(m.values().toArray())) return;\n+                            if (checkProgress(m.keySet().toArray())) return;\n+                            if (checkProgress(m.values().toArray(empty))) return;\n+                            if (checkProgress(m.keySet().toArray(empty))) return;\n+                        }\n+                    } catch (Throwable t) {\n+                        throwable[0] = t;\n@@ -83,5 +90,1 @@\n-                catch (Throwable t) {\n-                    throwable[0] = t;\n-                }\n-            }\n-        });\n+            }, executor);\n@@ -89,8 +92,8 @@\n-        \/\/ Create workers\n-        \/\/ Each worker will put globally unique keys into the map\n-        CompletableFuture<?>[] workers = IntStream.range(0, nWorkers).\n-                mapToObj(w -> CompletableFuture.runAsync(() -> {\n-                    for (int i = 0, o = w * sizePerWorker; i < sizePerWorker; i++)\n-                        m.put(o + i, i);\n-                })).\n-                toArray(CompletableFuture<?>[]::new);\n+            \/\/ Create workers\n+            \/\/ Each worker will put globally unique keys into the map\n+            CompletableFuture<?>[] workers = IntStream.range(0, nWorkers).\n+                    mapToObj(w -> CompletableFuture.runAsync(() -> {\n+                        for (int i = 0, o = w * sizePerWorker; i < sizePerWorker; i++)\n+                            m.put(o + i, i);\n+                    }, executor)).\n+                    toArray(CompletableFuture<?>[]::new);\n@@ -98,3 +101,3 @@\n-        \/\/ Wait for workers and then foreman to complete\n-        CompletableFuture.allOf(workers).join();\n-        foreman.join();\n+            \/\/ Wait for workers and then foreman to complete\n+            CompletableFuture.allOf(workers).join();\n+            foreman.join();\n@@ -102,2 +105,5 @@\n-        if (throwable[0] != null)\n-            throw throwable[0];\n+            if (throwable[0] != null)\n+                throw throwable[0];\n+        } finally {\n+            executor.shutdownNow();\n+        }\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/ToArray.java","additions":56,"deletions":50,"binary":false,"changes":106,"status":"modified"}]}