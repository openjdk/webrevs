{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+\/\/ controller names have to match the *_IDX indices\n+static const char* cg_controller_name[] = { \"cpu\", \"cpuset\", \"cpuacct\", \"memory\", \"pids\" };\n+\n@@ -42,0 +45,1 @@\n+  CgroupV1Controller* pids = NULL;\n@@ -96,12 +100,19 @@\n-    if (strcmp(info._name, \"memory\") == 0) {\n-      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n-      memory->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuset\") == 0) {\n-      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuset->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpu\") == 0) {\n-      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpu->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuacct->set_subsystem_path(info._cgroup_path);\n+    if (info._data_complete) { \/\/ pids controller might have incomplete data\n+      if (strcmp(info._name, \"memory\") == 0) {\n+        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuset\") == 0) {\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpu\") == 0) {\n+        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"pids\") == 0) {\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids->set_subsystem_path(info._cgroup_path);\n+      }\n+    } else {\n+      log_debug(os, container)(\"CgroupInfo for %s not complete\", cg_controller_name[i]);\n@@ -111,1 +122,1 @@\n-  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, pids, memory);\n@@ -125,1 +136,1 @@\n-  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct are enabled\n@@ -127,1 +138,2 @@\n-  bool all_controllers_enabled;\n+  \/\/ pids might not be enabled on older Linux distros (SLES 12.1, RHEL 7.1)\n+  bool all_required_controllers_enabled;\n@@ -139,4 +151,3 @@\n-      log_debug(os, container)(\"Can't open %s, %s\",\n-                               proc_cgroups, os::strerror(errno));\n-      *flags = INVALID_CGROUPS_GENERIC;\n-      return false;\n+    log_debug(os, container)(\"Can't open %s, %s\", proc_cgroups, os::strerror(errno));\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -170,0 +181,5 @@\n+    } else if (strcmp(name, \"pids\") == 0) {\n+      log_debug(os, container)(\"Detected optional pids controller entry in %s\", proc_cgroups);\n+      cg_infos[PIDS_IDX]._name = os::strdup(name);\n+      cg_infos[PIDS_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[PIDS_IDX]._enabled = (enabled == 1);\n@@ -175,1 +191,1 @@\n-  all_controllers_enabled = true;\n+  all_required_controllers_enabled = true;\n@@ -177,2 +193,8 @@\n-    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n-    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+    \/\/ pids controller is optional. All other controllers are required\n+    if (i != PIDS_IDX) {\n+      is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+      all_required_controllers_enabled = all_required_controllers_enabled && cg_infos[i]._enabled;\n+    }\n+    if (log_is_enabled(Debug, os, container) && !cg_infos[i]._enabled) {\n+      log_debug(os, container)(\"controller %s is not enabled\\n\", cg_controller_name[i]);\n+    }\n@@ -181,2 +203,2 @@\n-  if (!all_controllers_enabled) {\n-    \/\/ one or more controllers disabled, disable container support\n+  if (!all_required_controllers_enabled) {\n+    \/\/ one or more required controllers disabled, disable container support\n@@ -223,1 +245,1 @@\n-        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for memory\");\n@@ -226,1 +248,1 @@\n-        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuset\");\n@@ -229,1 +251,1 @@\n-        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpu\");\n@@ -232,1 +254,1 @@\n-        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuacc\");\n@@ -234,0 +256,4 @@\n+      } else if (strcmp(token, \"pids\") == 0) {\n+        assert(hierarchy_id == cg_infos[PIDS_IDX]._hierarchy_id, \"\/proc\/cgroups (%d) and \/proc\/self\/cgroup (%d) hierarchy mismatch for pids\",\n+                                                                 cg_infos[PIDS_IDX]._hierarchy_id, hierarchy_id);\n+        cg_infos[PIDS_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -284,1 +310,1 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n@@ -291,0 +317,2 @@\n+     *\n+     * 44 31 0:39 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:23 - cgroup cgroup rw,pids\n@@ -336,0 +364,6 @@\n+        } else if (strcmp(token, \"pids\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[PIDS_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[PIDS_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[PIDS_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[PIDS_IDX]._data_complete = true;\n@@ -390,0 +424,4 @@\n+  if (log_is_enabled(Debug, os, container) && !cg_infos[PIDS_IDX]._data_complete) {\n+    log_debug(os, container)(\"Optional cgroup v1 pids subsystem not found\");\n+    \/\/ keep the other controller info, pids is optional\n+  }\n@@ -393,1 +431,0 @@\n-\n@@ -517,0 +554,19 @@\n+\n+jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n+  \/\/ some controllers, for example the pids controller.\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":87,"deletions":31,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,2 @@\n-\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n-#define CG_INFO_LENGTH 4\n+\/\/ Five controllers: cpu, cpuset, cpuacct, memory, pids\n+#define CG_INFO_LENGTH 5\n@@ -70,0 +70,1 @@\n+#define PIDS_IDX       4\n@@ -243,0 +244,1 @@\n+    jlong limit_from_str(char* limit_str);\n@@ -247,0 +249,1 @@\n+    virtual jlong pids_max() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,25 @@\n+\n+\n+char* CgroupV1Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(pidsmax);\n+}\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::pids_max() {\n+  if (_pids == NULL) return OSCONTAINER_ERROR;\n+  char * pidsmax_str = pids_max_val();\n+  return limit_from_str(pidsmax_str);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,2 @@\n+    jlong pids_max();\n+\n@@ -104,0 +106,3 @@\n+    CgroupV1Controller* _pids = NULL;\n+\n+    char * pids_max_val();\n@@ -109,0 +114,1 @@\n+                      CgroupV1Controller* pids,\n@@ -113,0 +119,1 @@\n+      _pids = pids;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -206,18 +206,0 @@\n-jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == NULL) {\n-    return OSCONTAINER_ERROR;\n-  }\n-  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n-  }\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n-  }\n-  os::free(limit_str);\n-  return (jlong)limit;\n-}\n-\n@@ -247,0 +229,22 @@\n+char* CgroupV2Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(pidsmax);\n+}\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::pids_max() {\n+  char * pidsmax_str = pids_max_val();\n+  return limit_from_str(pidsmax_str);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    jlong limit_from_str(char* limit_str);\n+    char *pids_max_val();\n@@ -82,0 +82,2 @@\n+    jlong pids_max();\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,5 @@\n+\n+jlong OSContainer::pids_max() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->pids_max();\n+}\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+  static jlong pids_max();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2456,0 +2456,1 @@\n+    st->print_cr(\"container information not found.\");\n@@ -2547,0 +2548,9 @@\n+\n+  j = OSContainer::OSContainer::pids_max();\n+  st->print(\"maximum number of tasks: \");\n+  if (j > 0) {\n+    st->print_cr(JLONG_FORMAT, j);\n+  } else {\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -894,1 +894,1 @@\n-  CgroupInfo cg_infos[4];\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+    @Override\n+    public long getPidsMax() {\n+        return subsystem.getPidsMax();\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+    public static final String MAX_VAL = \"max\";\n+\n+    public static long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final String PIDS_CTRL = \"pids\";\n@@ -152,0 +153,1 @@\n+            case PIDS_CTRL:     infos.put(PIDS_CTRL, info); break;\n@@ -255,0 +257,1 @@\n+                    case PIDS_CTRL:\n@@ -306,0 +309,1 @@\n+                        case PIDS_CTRL:\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    private CgroupV1SubsystemController pids;\n@@ -129,0 +130,9 @@\n+            case \"pids\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setPidsController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n@@ -173,0 +183,4 @@\n+    private void setPidsController(CgroupV1SubsystemController pids) {\n+        this.pids = pids;\n+    }\n+\n@@ -397,0 +411,7 @@\n+    \/*****************************************************************\n+     *  pids subsystem\n+     ****************************************************************\/\n+    public long getPidsMax() {\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(pids, \"pids.max\");\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -48,1 +48,0 @@\n-    private static final String MAX_VAL = \"max\";\n@@ -152,8 +151,1 @@\n-        return limitFromString(quota);\n-    }\n-\n-    private long limitFromString(String strVal) {\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        return Long.parseLong(strVal);\n+        return CgroupSubsystem.limitFromString(quota);\n@@ -254,1 +246,1 @@\n-        return limitFromString(strVal);\n+        return CgroupSubsystem.limitFromString(strVal);\n@@ -282,1 +274,1 @@\n-        long swapLimit = limitFromString(strVal);\n+        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n@@ -313,1 +305,7 @@\n-        return limitFromString(softLimitStr);\n+        return CgroupSubsystem.limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getPidsMax() {\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(unified, \"pids.max\");\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -355,0 +355,13 @@\n+    \/*****************************************************************\n+     * pids subsystem\n+     ****************************************************************\/\n+\n+    \/**\n+     * Returns the maximum number of tasks that may be created in the Isolation Group.\n+     *\n+     * @return The maximum number of tasks, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n+     *\n+     *\/\n+    public long getPidsMax();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -408,0 +408,3 @@\n+        limit = c.getPidsMax();\n+        ostream.println(formatLimitString(limit, INDENT + \"Maximum Processes Limit: \",\n+                                          longRetvalNotSupported, false));\n@@ -412,0 +415,4 @@\n+        return formatLimitString(limit, prefix, unavailable, true);\n+    }\n+\n+    private static String formatLimitString(long limit, String prefix, long unavailable, boolean scale) {\n@@ -413,1 +420,5 @@\n-            return prefix + SizePrefix.scaleValue(limit);\n+            if (scale) {\n+                return prefix + SizePrefix.scaleValue(limit);\n+            } else {\n+                return prefix + limit;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -109,0 +109,1 @@\n+            \"pids 0 1 1\\n\" +\n@@ -172,1 +173,1 @@\n-            \"pids    3   80  1\";\n+            \"pids    9   80  1\";  \/\/ hierarchy has to match procSelfCgroupHybridContent\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            \"memory_max_usage_in_bytes\"\n+            \"memory_max_usage_in_bytes\",\n+            \"maximum number of tasks\"\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @summary Test JVM's awareness of pids controller\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox PrintContainerInfo\n+ * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver TestPids\n+ *\/\n+import java.util.List;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+\n+public class TestPids {\n+    private static final String imageName = Common.imageName(\"pids\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        Common.prepareWhiteBox();\n+        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-BasicTest\", \"jdk-docker\");\n+\n+        try {\n+            testPids();\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void testPids() throws Exception {\n+        System.out.println(\"Testing pids controller ...\");\n+        testPids(\"400\");\n+        testPids(\"800\");\n+        testPids(\"2000\");\n+        testPids(\"Unlimited\");\n+    }\n+\n+    private static DockerRunOptions commonOpts() {\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"PrintContainerInfo\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addJavaOpts(\"-Xlog:os+container=trace\", \"-cp\", \"\/test-classes\/\");\n+        Common.addWhiteBoxOpts(opts);\n+        return opts;\n+    }\n+\n+    private static void checkResult(List<String> lines, String lineMarker, String expectedValue) {\n+        boolean lineMarkerFound = false;\n+\n+        for (String line : lines) {\n+            if (line.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+                System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+                return;\n+            }\n+\n+            if (line.contains(lineMarker)) {\n+                lineMarkerFound = true;\n+                String[] parts = line.split(\":\");\n+                System.out.println(\"DEBUG: line = \" + line);\n+                System.out.println(\"DEBUG: parts.length = \" + parts.length);\n+\n+                Asserts.assertEquals(parts.length, 2);\n+                String actual = parts[1].replaceAll(\"\\\\s\",\"\");\n+                \/\/ Unlimited pids leads on some setups not to \"max\" in the output, but to a high number\n+                if (expectedValue.equals(\"max\")) {\n+                    if (actual.equals(\"max\")) {\n+                        System.out.println(\"Found expected max for unlimited pids value.\");\n+                    } else {\n+                        try {\n+                            int ai = Integer.parseInt(actual);\n+                            if (ai > 20000) {\n+                                System.out.println(\"Limit value \" + ai + \" got accepted as unlimited, log line was \" + line);\n+                            } else {\n+                                throw new RuntimeException(\"Limit value \" + ai + \" is not accepted as unlimited, log line was \" + line);\n+                            }\n+                        } catch (NumberFormatException ex) {\n+                            throw new RuntimeException(\"Could not convert \" + actual + \" to an integer, log line was \" + line);\n+                        }\n+                    }\n+                } else {\n+                    Asserts.assertEquals(actual, expectedValue);\n+                }\n+                break;\n+            }\n+        }\n+        Asserts.assertTrue(lineMarkerFound);\n+    }\n+\n+    private static void testPids(String value) throws Exception {\n+        Common.logNewTestCase(\"pids controller test, limiting value = \" + value);\n+\n+        DockerRunOptions opts = commonOpts();\n+        if (value.equals(\"Unlimited\")) {\n+            opts.addDockerOpts(\"--pids-limit=-1\");\n+        } else {\n+            opts.addDockerOpts(\"--pids-limit=\"+value);\n+        }\n+\n+        List<String> lines = Common.run(opts).asLines();\n+        if (value.equals(\"Unlimited\")) {\n+            checkResult(lines, \"Maximum number of tasks is: \", \"max\");\n+        } else {\n+            checkResult(lines, \"Maximum number of tasks is: \", value);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @summary Test JDK Metrics class when running inside a docker container with limited pids\n+ * @bug 8266490\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build TestPidsLimit\n+ * @run driver TestPidsLimit\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+\n+public class TestPidsLimit {\n+    private static final String imageName = Common.imageName(\"pids\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-BasicTest\", \"jdk-docker\");\n+\n+        try {\n+            testPidsLimit(\"1000\");\n+            testPidsLimit(\"2000\");\n+            testPidsLimit(\"Unlimited\");\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void checkResult(List<String> lines, String lineMarker, String expectedValue) {\n+        boolean lineMarkerFound = false;\n+\n+        for (String line : lines) {\n+            if (line.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+                System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+                return;\n+            }\n+\n+            if (line.contains(lineMarker)) {\n+                lineMarkerFound = true;\n+                String[] parts = line.split(\":\");\n+                System.out.println(\"DEBUG: line = \" + line);\n+                System.out.println(\"DEBUG: parts.length = \" + parts.length);\n+\n+                Asserts.assertEquals(parts.length, 2);\n+                String actual = parts[1].replaceAll(\"\\\\s\",\"\");\n+                \/\/ Unlimited pids leads on some setups not to \"max\" in the output, but to a high number\n+                if (expectedValue.equals(\"Unlimited\")) {\n+                    if (actual.equals(\"Unlimited\")) {\n+                        System.out.println(\"Found expected value for unlimited pids.\");\n+                    } else {\n+                        try {\n+                            int ai = Integer.parseInt(actual);\n+                            if (ai > 20000) {\n+                                System.out.println(\"Limit value \" + ai + \" got accepted as unlimited, log line was \" + line);\n+                            } else {\n+                                throw new RuntimeException(\"Limit value \" + ai + \" is not accepted as unlimited, log line was \" + line);\n+                            }\n+                        } catch (NumberFormatException ex) {\n+                            throw new RuntimeException(\"Could not convert \" + actual + \" to an integer, log line was \" + line);\n+                        }\n+                    }\n+                } else {\n+                    Asserts.assertEquals(actual, expectedValue);\n+                }\n+                break;\n+            }\n+        }\n+        Asserts.assertTrue(lineMarkerFound);\n+    }\n+\n+    private static void testPidsLimit(String pidsLimit) throws Exception {\n+        Common.logNewTestCase(\"testPidsLimit (limit: \" + pidsLimit + \")\");\n+        DockerRunOptions opts = Common.newOptsShowSettings(imageName);\n+        if (pidsLimit.equals(\"Unlimited\")) {\n+            opts.addDockerOpts(\"--pids-limit=-1\");\n+        } else {\n+            opts.addDockerOpts(\"--pids-limit=\"+pidsLimit);\n+        }\n+\n+        OutputAnalyzer out = DockerTestUtils.dockerRunJava(opts);\n+        out.shouldHaveExitValue(0);\n+        \/\/ some docker enviroments do not have the pids limit capabilities\n+        String sdr = out.getOutput();\n+        if (sdr.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+            System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+        } else {\n+            List<String> lines = new ArrayList<>();\n+            sdr.lines().forEach(s -> lines.add(s));\n+            checkResult(lines, \"Maximum Processes Limit: \", pidsLimit);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,4 @@\n+    public static DockerRunOptions newOptsShowSettings(String imageNameAndTag) {\n+        return new DockerRunOptions(imageNameAndTag, \"\/jdk\/bin\/java\", \"-version\", \"-XshowSettings:system\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/Common.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}