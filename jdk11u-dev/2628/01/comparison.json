{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,5 +53,5 @@\n-    private static int MAX_HANDSHAKE_LOOPS = 200;\n-    private static int MAX_APP_READ_LOOPS = 60;\n-    private static int SOCKET_TIMEOUT = 10 * 1000; \/\/ in millis\n-    private static int BUFFER_SIZE = 1024;\n-    private static int MAXIMUM_PACKET_SIZE = 1024;\n+    private static final int MAX_HANDSHAKE_LOOPS = 200;\n+    private static final int MAX_APP_READ_LOOPS = 60;\n+    private static final int SOCKET_TIMEOUT = 10 * 1000; \/\/ in millis\n+    private static final int BUFFER_SIZE = 1024;\n+    private static final int MAXIMUM_PACKET_SIZE = 1024;\n@@ -62,14 +62,12 @@\n-    private static String pathToStores = \"..\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-    private static Exception clientException = null;\n-    private static Exception serverException = null;\n-\n-    private static ByteBuffer serverApp =\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+    private static final String KEY_STORE_FILE = \"keystore\";\n+    private static final String TRUST_STORE_FILE = \"truststore\";\n+\n+    private static final String KEY_FILENAME =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEY_STORE_FILE;\n+    private static final String TRUST_FILENAME =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUST_STORE_FILE;\n+\n+    private static final ByteBuffer SERVER_APP =\n@@ -77,1 +75,1 @@\n-    private static ByteBuffer clientApp =\n+    private static final ByteBuffer CLIENT_APP =\n@@ -80,0 +78,2 @@\n+    private static Exception clientException = null;\n+    private static Exception serverException = null;\n@@ -94,0 +94,1 @@\n+        String side = \"Server\";\n@@ -99,1 +100,1 @@\n-        handshake(engine, socket, clientSocketAddr, \"Server\");\n+        handshake(engine, socket, clientSocketAddr, side);\n@@ -102,1 +103,1 @@\n-        receiveAppData(engine, socket, clientApp);\n+        receiveAppData(engine, socket, CLIENT_APP);\n@@ -105,1 +106,1 @@\n-        deliverAppData(engine, socket, serverApp, clientSocketAddr);\n+        deliverAppData(engine, socket, SERVER_APP, clientSocketAddr, side);\n@@ -113,0 +114,1 @@\n+        String side = \"Client\";\n@@ -118,1 +120,1 @@\n-        handshake(engine, socket, serverSocketAddr, \"Client\");\n+        handshake(engine, socket, serverSocketAddr, side);\n@@ -121,1 +123,1 @@\n-        deliverAppData(engine, socket, clientApp, serverSocketAddr);\n+        deliverAppData(engine, socket, CLIENT_APP, serverSocketAddr, side);\n@@ -124,1 +126,1 @@\n-        receiveAppData(engine, socket, serverApp);\n+        receiveAppData(engine, socket, SERVER_APP);\n@@ -156,1 +158,1 @@\n-                        \"Too much loops to produce handshake packets\");\n+                        \"Too many loops to produce handshake packets\");\n@@ -161,25 +163,0 @@\n-            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||\n-                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {\n-\n-                log(side, \"Receive DTLS records, handshake status is \" + hs);\n-\n-                ByteBuffer iNet;\n-                ByteBuffer iApp;\n-                if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n-                    byte[] buf = new byte[BUFFER_SIZE];\n-                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n-                    try {\n-                        socket.receive(packet);\n-                    } catch (SocketTimeoutException ste) {\n-                        log(side, \"Warning: \" + ste);\n-\n-                        List<DatagramPacket> packets = new ArrayList<>();\n-                        boolean finished = onReceiveTimeout(\n-                                engine, peerAddr, side, packets);\n-\n-                        log(side, \"Reproduced \" + packets.size() + \" packets\");\n-                        for (DatagramPacket p : packets) {\n-                            printHex(\"Reproduced packet\",\n-                                p.getData(), p.getOffset(), p.getLength());\n-                            socket.send(p);\n-                        }\n@@ -187,5 +164,38 @@\n-                        if (finished) {\n-                            log(side, \"Handshake status is FINISHED \"\n-                                    + \"after calling onReceiveTimeout(), \"\n-                                    + \"finish the loop\");\n-                            endLoops = true;\n+            switch (hs) {\n+                case NEED_UNWRAP:\n+                case NEED_UNWRAP_AGAIN: {\n+                    log(side, \"Receive DTLS records, handshake status is \" + hs);\n+\n+                    ByteBuffer iNet;\n+                    ByteBuffer iApp;\n+\n+                    if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                        byte[] buf = new byte[BUFFER_SIZE];\n+                        DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                        try {\n+                            socket.receive(packet);\n+                        } catch (SocketTimeoutException ste) {\n+                            log(side, \"Warning: \" + ste);\n+\n+                            List<DatagramPacket> packets = new ArrayList<>();\n+                            boolean finished = onReceiveTimeout(\n+                                    engine, peerAddr, side, packets);\n+\n+                            log(side, \"Reproduced \" + packets.size() + \" packets\");\n+                            for (DatagramPacket p : packets) {\n+                                printHex(\"Reproduced packet\",\n+                                        p.getData(), p.getOffset(), p.getLength());\n+                                socket.send(p);\n+                            }\n+\n+                            if (finished) {\n+                                log(side, \"Handshake status is FINISHED \"\n+                                        + \"after calling onReceiveTimeout(), \"\n+                                        + \"finish the loop\");\n+                                endLoops = true;\n+                            }\n+\n+                            log(side, \"New handshake status is \"\n+                                    + engine.getHandshakeStatus());\n+\n+                            continue;\n@@ -194,4 +204,3 @@\n-                        log(side, \"New handshake status is \"\n-                                + engine.getHandshakeStatus());\n-\n-                        continue;\n+                        iNet = ByteBuffer.wrap(buf, 0, packet.getLength());\n+                    } else {\n+                        iNet = ByteBuffer.allocate(0);\n@@ -200,1 +209,0 @@\n-                    iNet = ByteBuffer.wrap(buf, 0, packet.getLength());\n@@ -202,12 +210,0 @@\n-                } else {\n-                    iNet = ByteBuffer.allocate(0);\n-                    iApp = ByteBuffer.allocate(BUFFER_SIZE);\n-                }\n-\n-                SSLEngineResult r = engine.unwrap(iNet, iApp);\n-                SSLEngineResult.Status rs = r.getStatus();\n-                hs = r.getHandshakeStatus();\n-                if (rs == SSLEngineResult.Status.OK) {\n-                    \/\/ OK\n-                } else if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-                    log(side, \"BUFFER_OVERFLOW, handshake status is \" + hs);\n@@ -215,18 +211,2 @@\n-                    \/\/ the client maximum fragment size config does not work?\n-                    throw new Exception(\"Buffer overflow: \" +\n-                        \"incorrect client maximum fragment size\");\n-                } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-                    log(side, \"BUFFER_UNDERFLOW, handshake status is \" + hs);\n-\n-                    \/\/ bad packet, or the client maximum fragment size\n-                    \/\/ config does not work?\n-                    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                        throw new Exception(\"Buffer underflow: \" +\n-                            \"incorrect client maximum fragment size\");\n-                    } \/\/ otherwise, ignore this packet\n-                } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                    throw new Exception(\n-                            \"SSL engine closed, handshake status is \" + hs);\n-                } else {\n-                    throw new Exception(\"Can't reach here, result is \" + rs);\n-                }\n+                    SSLEngineResult r = engine.unwrap(iNet, iApp);\n+                    hs = r.getHandshakeStatus();\n@@ -234,13 +214,15 @@\n-                if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                    log(side, \"Handshake status is FINISHED, finish the loop\");\n-                    endLoops = true;\n-                }\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n-                List<DatagramPacket> packets = new ArrayList<>();\n-                boolean finished = produceHandshakePackets(\n-                    engine, peerAddr, side, packets);\n-\n-                log(side, \"Produced \" + packets.size() + \" packets\");\n-                for (DatagramPacket p : packets) {\n-                    socket.send(p);\n-                }\n+                    verifySSLEngineResultStatus(r, side);\n+                    if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n+                        log(side, \"Handshake status is FINISHED, finish the loop\");\n+                        endLoops = true;\n+                    }\n+                } break;\n+                case NEED_WRAP: {\n+                    List<DatagramPacket> packets = new ArrayList<>();\n+                    boolean finished = produceHandshakePackets(\n+                            engine, peerAddr, side, packets);\n+\n+                    log(side, \"Produced \" + packets.size() + \" packets\");\n+                    for (DatagramPacket p : packets) {\n+                        socket.send(p);\n+                    }\n@@ -248,4 +230,11 @@\n-                if (finished) {\n-                    log(side, \"Handshake status is FINISHED \"\n-                            + \"after producing handshake packets, \"\n-                            + \"finish the loop\");\n+                    if (finished) {\n+                        log(side, \"Handshake status is FINISHED \"\n+                                + \"after producing handshake packets, \"\n+                                + \"finish the loop\");\n+                        endLoops = true;\n+                    }\n+                } break;\n+                case NEED_TASK: runDelegatedTasks(engine); break;\n+                case NOT_HANDSHAKING: {\n+                    log(side,\n+                            \"Handshake status is NOT_HANDSHAKING, finish the loop\");\n@@ -253,14 +242,5 @@\n-                }\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n-                runDelegatedTasks(engine);\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                log(side,\n-                    \"Handshake status is NOT_HANDSHAKING, finish the loop\");\n-                endLoops = true;\n-            } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                throw new Exception(\n-                        \"Unexpected status, SSLEngine.getHandshakeStatus() \"\n-                                + \"shouldn't return FINISHED\");\n-            } else {\n-                throw new Exception(\n-                        \"Can't reach here, handshake status is \" + hs);\n+                } break;\n+                case FINISHED: throw new Exception( \"Unexpected status, \" +\n+                        \"SSLEngine.getHandshakeStatus() shouldn't return FINISHED\");\n+                default: throw new Exception(\"Can't reach here, \" +\n+                        \"handshake status is \" + hs);\n@@ -294,0 +274,26 @@\n+    void verifySSLEngineResultStatus(SSLEngineResult r, String side) throws Exception {\n+        SSLEngineResult.Status rs = r.getStatus();\n+        SSLEngineResult.HandshakeStatus hs = r.getHandshakeStatus();\n+        switch (rs) {\n+            case OK: log(side, \"SSLEngineResult status OK\"); break;\n+            case BUFFER_OVERFLOW: {\n+                log(side, \"BUFFER_OVERFLOW, handshake status is \" + hs);\n+                \/\/ the client maximum fragment size config does not work?\n+                throw new Exception(\"Buffer overflow: \" +\n+                        \"incorrect client maximum fragment size\");\n+            }\n+            case BUFFER_UNDERFLOW: {\n+                log(side, \"BUFFER_UNDERFLOW, handshake status is \" + hs);\n+                \/\/ bad packet, or the client maximum fragment size\n+                \/\/ config does not work?\n+                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+                    throw new Exception(\"Buffer underflow: \" +\n+                            \"incorrect client maximum fragment size\");\n+                } \/\/ otherwise, ignore this packet\n+            } break;\n+            case CLOSED: throw new Exception(\n+                    \"SSL engine closed, handshake status is \" + hs);\n+            default: throw new Exception(\"Can't reach here, result is \" + rs);\n+        }\n+    }\n+\n@@ -296,1 +302,1 @@\n-            ByteBuffer appData, SocketAddress peerAddr) throws Exception {\n+            ByteBuffer appData, SocketAddress peerAddr, String side) throws Exception {\n@@ -300,1 +306,1 @@\n-                produceApplicationPackets(engine, appData, peerAddr);\n+                produceApplicationPackets(engine, appData, peerAddr, side);\n@@ -347,1 +353,1 @@\n-                        \"Too much loops to produce handshake packets\");\n+                        \"Too many loops to produce handshake packets\");\n@@ -359,22 +365,0 @@\n-            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-                \/\/ the client maximum fragment size config does not work?\n-                throw new Exception(\"Buffer overflow: \" +\n-                            \"incorrect server maximum fragment size\");\n-            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-                log(side,\n-                        \"Produce handshake packets: BUFFER_UNDERFLOW occured\");\n-                log(side,\n-                        \"Produce handshake packets: Handshake status: \" + hs);\n-                \/\/ bad packet, or the client maximum fragment size\n-                \/\/ config does not work?\n-                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                    throw new Exception(\"Buffer underflow: \" +\n-                            \"incorrect server maximum fragment size\");\n-                } \/\/ otherwise, ignore this packet\n-            } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                throw new Exception(\"SSLEngine has closed\");\n-            } else if (rs == SSLEngineResult.Status.OK) {\n-                \/\/ OK\n-            } else {\n-                throw new Exception(\"Can't reach here, result is \" + rs);\n-            }\n@@ -382,1 +366,2 @@\n-            \/\/ SSLEngineResult.Status.OK:\n+            verifySSLEngineResultStatus(r, side);\n+\n@@ -399,12 +384,10 @@\n-                if (nhs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n-                    runDelegatedTasks(engine);\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||\n-                    nhs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN ||\n-                    nhs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-\n-                    endInnerLoop = true;\n-                    endLoops = true;\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n-                    endInnerLoop = true;\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                    throw new Exception(\n+                switch (nhs) {\n+                    case NEED_TASK: runDelegatedTasks(engine); break;\n+                    case NEED_UNWRAP:\n+                    case NEED_UNWRAP_AGAIN:\n+                    case NOT_HANDSHAKING: {\n+                        endInnerLoop = true;\n+                        endLoops = true;\n+                    } break;\n+                    case NEED_WRAP: endInnerLoop = true; break;\n+                    case FINISHED:  throw new Exception(\n@@ -412,3 +395,2 @@\n-                                    + \"shouldn't return FINISHED\");\n-                } else {\n-                    throw new Exception(\"Can't reach here, handshake status is \"\n+                                    + \"should not return FINISHED\");\n+                    default: throw new Exception(\"Can't reach here, handshake status is \"\n@@ -417,0 +399,1 @@\n+\n@@ -431,1 +414,1 @@\n-            SocketAddress socketAddr) throws Exception {\n+            SocketAddress socketAddr, String side) throws Exception {\n@@ -438,15 +421,1 @@\n-        SSLEngineResult.Status rs = r.getStatus();\n-        if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-            \/\/ the client maximum fragment size config does not work?\n-            throw new Exception(\"Buffer overflow: \" +\n-                        \"incorrect server maximum fragment size\");\n-        } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-            \/\/ unlikely\n-            throw new Exception(\"Buffer underflow during wraping\");\n-        } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                throw new Exception(\"SSLEngine has closed\");\n-        } else if (rs == SSLEngineResult.Status.OK) {\n-            \/\/ OK\n-        } else {\n-            throw new Exception(\"Can't reach here, result is \" + rs);\n-        }\n+        verifySSLEngineResultStatus(r, side);\n@@ -454,1 +423,0 @@\n-        \/\/ SSLEngineResult.Status.OK:\n@@ -475,1 +443,1 @@\n-            \/\/ Normally, this pakcet should be a handshake message\n+            \/\/ Normally, this packet should be a handshake message\n@@ -493,1 +461,1 @@\n-                    } else {                        \/\/ cipherext\n+                    } else {                        \/\/ ciphertext\n@@ -498,1 +466,1 @@\n-                        \/\/ following packets any mroe as a Finished\n+                        \/\/ following packets any more as a Finished\n@@ -543,2 +511,2 @@\n-                .trustStore(KeyStoreUtils.loadKeyStore(trustFilename, passphrase))\n-                .keyStore(KeyStoreUtils.loadKeyStore(keyFilename, passphrase))\n+                .trustStore(KeyStoreUtils.loadKeyStore(TRUST_FILENAME, passphrase))\n+                .keyStore(KeyStoreUtils.loadKeyStore(KEY_FILENAME, passphrase))\n@@ -562,2 +530,7 @@\n-        try (DatagramSocket serverSocket = new DatagramSocket();\n-                DatagramSocket clientSocket = new DatagramSocket()) {\n+        InetSocketAddress serverSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n+        InetSocketAddress clientSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n+\n+        try (DatagramSocket serverSocket = new DatagramSocket(serverSocketAddress);\n+                DatagramSocket clientSocket = new DatagramSocket(clientSocketAddress)) {\n@@ -569,1 +542,1 @@\n-                    InetAddress.getLocalHost(), serverSocket.getLocalPort());\n+                    InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n@@ -572,1 +545,1 @@\n-                    InetAddress.getLocalHost(), clientSocket.getLocalPort());\n+                    InetAddress.getLoopbackAddress(), clientSocket.getLocalPort());\n@@ -690,1 +663,1 @@\n-    final static void printHex(String prefix, ByteBuffer bb) {\n+    static void printHex(String prefix, ByteBuffer bb) {\n@@ -703,1 +676,1 @@\n-    final static void printHex(String prefix,\n+    static void printHex(String prefix,\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":166,"deletions":193,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-        handshakeType = Byte.valueOf(args[1]);\n+        handshakeType = Byte.parseByte(args[1]);\n@@ -100,1 +100,1 @@\n-        if (needPacketLoss && (!(isClient ^ engine.getUseClientMode()))) {\n+        if (needPacketLoss && (isClient == engine.getUseClientMode())) {\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-        handshakeType = Byte.valueOf(args[1]);\n+        handshakeType = Byte.parseByte(args[1]);\n@@ -101,1 +101,1 @@\n-        if (needPacketDuplicate && (!(isClient ^ engine.getUseClientMode()))) {\n+        if (needPacketDuplicate && (isClient == engine.getUseClientMode())) {\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/RespondToRetransmit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}