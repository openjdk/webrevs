{"files":[{"patch":"@@ -166,3 +166,0 @@\n-        \/\/System.out.println(\"\\nSerialized RefAddr object: \");\n-        \/\/System.out.println(new sun.security.util.HexDumpEncoder().encode(bytes));\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/Base64Test.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -35,1 +36,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -315,1 +316,1 @@\n-        new HexDumpEncoder().encodeBuffer(response, System.out);\n+        HexPrinter.simple().format(response);\n@@ -323,1 +324,1 @@\n-                new HexDumpEncoder().encodeBuffer(challenge, System.out);\n+                HexPrinter.simple().format(challenge);\n@@ -328,1 +329,1 @@\n-                new HexDumpEncoder().encodeBuffer(response, System.out);\n+                HexPrinter.simple().format(response);\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/ntlm\/NTLMTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -53,5 +53,5 @@\n-    private static int MAX_HANDSHAKE_LOOPS = 200;\n-    private static int MAX_APP_READ_LOOPS = 60;\n-    private static int SOCKET_TIMEOUT = 10 * 1000; \/\/ in millis\n-    private static int BUFFER_SIZE = 1024;\n-    private static int MAXIMUM_PACKET_SIZE = 1024;\n+    private static final int MAX_HANDSHAKE_LOOPS = 200;\n+    private static final int MAX_APP_READ_LOOPS = 60;\n+    private static final int SOCKET_TIMEOUT = 10 * 1000; \/\/ in millis\n+    private static final int BUFFER_SIZE = 1024;\n+    private static final int MAXIMUM_PACKET_SIZE = 1024;\n@@ -62,14 +62,12 @@\n-    private static String pathToStores = \"..\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-    private static Exception clientException = null;\n-    private static Exception serverException = null;\n-\n-    private static ByteBuffer serverApp =\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+    private static final String KEY_STORE_FILE = \"keystore\";\n+    private static final String TRUST_STORE_FILE = \"truststore\";\n+\n+    private static final String KEY_FILENAME =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEY_STORE_FILE;\n+    private static final String TRUST_FILENAME =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUST_STORE_FILE;\n+\n+    private static final ByteBuffer SERVER_APP =\n@@ -77,1 +75,1 @@\n-    private static ByteBuffer clientApp =\n+    private static final ByteBuffer CLIENT_APP =\n@@ -80,0 +78,2 @@\n+    private static Exception clientException = null;\n+    private static Exception serverException = null;\n@@ -94,0 +94,1 @@\n+        String side = \"Server\";\n@@ -99,1 +100,1 @@\n-        handshake(engine, socket, clientSocketAddr, \"Server\");\n+        handshake(engine, socket, clientSocketAddr, side);\n@@ -102,1 +103,1 @@\n-        receiveAppData(engine, socket, clientApp);\n+        receiveAppData(engine, socket, CLIENT_APP);\n@@ -105,1 +106,1 @@\n-        deliverAppData(engine, socket, serverApp, clientSocketAddr);\n+        deliverAppData(engine, socket, SERVER_APP, clientSocketAddr, side);\n@@ -113,0 +114,1 @@\n+        String side = \"Client\";\n@@ -118,1 +120,1 @@\n-        handshake(engine, socket, serverSocketAddr, \"Client\");\n+        handshake(engine, socket, serverSocketAddr, side);\n@@ -121,1 +123,1 @@\n-        deliverAppData(engine, socket, clientApp, serverSocketAddr);\n+        deliverAppData(engine, socket, CLIENT_APP, serverSocketAddr, side);\n@@ -124,1 +126,1 @@\n-        receiveAppData(engine, socket, serverApp);\n+        receiveAppData(engine, socket, SERVER_APP);\n@@ -156,1 +158,1 @@\n-                        \"Too much loops to produce handshake packets\");\n+                        \"Too many loops to produce handshake packets\");\n@@ -161,25 +163,0 @@\n-            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||\n-                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {\n-\n-                log(side, \"Receive DTLS records, handshake status is \" + hs);\n-\n-                ByteBuffer iNet;\n-                ByteBuffer iApp;\n-                if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n-                    byte[] buf = new byte[BUFFER_SIZE];\n-                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n-                    try {\n-                        socket.receive(packet);\n-                    } catch (SocketTimeoutException ste) {\n-                        log(side, \"Warning: \" + ste);\n-\n-                        List<DatagramPacket> packets = new ArrayList<>();\n-                        boolean finished = onReceiveTimeout(\n-                                engine, peerAddr, side, packets);\n-\n-                        log(side, \"Reproduced \" + packets.size() + \" packets\");\n-                        for (DatagramPacket p : packets) {\n-                            printHex(\"Reproduced packet\",\n-                                p.getData(), p.getOffset(), p.getLength());\n-                            socket.send(p);\n-                        }\n@@ -187,5 +164,38 @@\n-                        if (finished) {\n-                            log(side, \"Handshake status is FINISHED \"\n-                                    + \"after calling onReceiveTimeout(), \"\n-                                    + \"finish the loop\");\n-                            endLoops = true;\n+            switch (hs) {\n+                case NEED_UNWRAP:\n+                case NEED_UNWRAP_AGAIN: {\n+                    log(side, \"Receive DTLS records, handshake status is \" + hs);\n+\n+                    ByteBuffer iNet;\n+                    ByteBuffer iApp;\n+\n+                    if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                        byte[] buf = new byte[BUFFER_SIZE];\n+                        DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                        try {\n+                            socket.receive(packet);\n+                        } catch (SocketTimeoutException ste) {\n+                            log(side, \"Warning: \" + ste);\n+\n+                            List<DatagramPacket> packets = new ArrayList<>();\n+                            boolean finished = onReceiveTimeout(\n+                                    engine, peerAddr, side, packets);\n+\n+                            log(side, \"Reproduced \" + packets.size() + \" packets\");\n+                            for (DatagramPacket p : packets) {\n+                                printHex(\"Reproduced packet\",\n+                                        p.getData(), p.getOffset(), p.getLength());\n+                                socket.send(p);\n+                            }\n+\n+                            if (finished) {\n+                                log(side, \"Handshake status is FINISHED \"\n+                                        + \"after calling onReceiveTimeout(), \"\n+                                        + \"finish the loop\");\n+                                endLoops = true;\n+                            }\n+\n+                            log(side, \"New handshake status is \"\n+                                    + engine.getHandshakeStatus());\n+\n+                            continue;\n@@ -194,4 +204,3 @@\n-                        log(side, \"New handshake status is \"\n-                                + engine.getHandshakeStatus());\n-\n-                        continue;\n+                        iNet = ByteBuffer.wrap(buf, 0, packet.getLength());\n+                    } else {\n+                        iNet = ByteBuffer.allocate(0);\n@@ -200,1 +209,0 @@\n-                    iNet = ByteBuffer.wrap(buf, 0, packet.getLength());\n@@ -202,4 +210,0 @@\n-                } else {\n-                    iNet = ByteBuffer.allocate(0);\n-                    iApp = ByteBuffer.allocate(BUFFER_SIZE);\n-                }\n@@ -207,13 +211,2 @@\n-                SSLEngineResult r = engine.unwrap(iNet, iApp);\n-                SSLEngineResult.Status rs = r.getStatus();\n-                hs = r.getHandshakeStatus();\n-                if (rs == SSLEngineResult.Status.OK) {\n-                    \/\/ OK\n-                } else if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-                    log(side, \"BUFFER_OVERFLOW, handshake status is \" + hs);\n-\n-                    \/\/ the client maximum fragment size config does not work?\n-                    throw new Exception(\"Buffer overflow: \" +\n-                        \"incorrect client maximum fragment size\");\n-                } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-                    log(side, \"BUFFER_UNDERFLOW, handshake status is \" + hs);\n+                    SSLEngineResult r = engine.unwrap(iNet, iApp);\n+                    hs = r.getHandshakeStatus();\n@@ -221,26 +214,15 @@\n-                    \/\/ bad packet, or the client maximum fragment size\n-                    \/\/ config does not work?\n-                    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                        throw new Exception(\"Buffer underflow: \" +\n-                            \"incorrect client maximum fragment size\");\n-                    } \/\/ otherwise, ignore this packet\n-                } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                    throw new Exception(\n-                            \"SSL engine closed, handshake status is \" + hs);\n-                } else {\n-                    throw new Exception(\"Can't reach here, result is \" + rs);\n-                }\n-\n-                if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                    log(side, \"Handshake status is FINISHED, finish the loop\");\n-                    endLoops = true;\n-                }\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n-                List<DatagramPacket> packets = new ArrayList<>();\n-                boolean finished = produceHandshakePackets(\n-                    engine, peerAddr, side, packets);\n-\n-                log(side, \"Produced \" + packets.size() + \" packets\");\n-                for (DatagramPacket p : packets) {\n-                    socket.send(p);\n-                }\n+                    verifySSLEngineResultStatus(r, side);\n+                    if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n+                        log(side, \"Handshake status is FINISHED, finish the loop\");\n+                        endLoops = true;\n+                    }\n+                } break;\n+                case NEED_WRAP: {\n+                    List<DatagramPacket> packets = new ArrayList<>();\n+                    boolean finished = produceHandshakePackets(\n+                            engine, peerAddr, side, packets);\n+\n+                    log(side, \"Produced \" + packets.size() + \" packets\");\n+                    for (DatagramPacket p : packets) {\n+                        socket.send(p);\n+                    }\n@@ -248,4 +230,11 @@\n-                if (finished) {\n-                    log(side, \"Handshake status is FINISHED \"\n-                            + \"after producing handshake packets, \"\n-                            + \"finish the loop\");\n+                    if (finished) {\n+                        log(side, \"Handshake status is FINISHED \"\n+                                + \"after producing handshake packets, \"\n+                                + \"finish the loop\");\n+                        endLoops = true;\n+                    }\n+                } break;\n+                case NEED_TASK: runDelegatedTasks(engine); break;\n+                case NOT_HANDSHAKING: {\n+                    log(side,\n+                            \"Handshake status is NOT_HANDSHAKING, finish the loop\");\n@@ -253,14 +242,5 @@\n-                }\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n-                runDelegatedTasks(engine);\n-            } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                log(side,\n-                    \"Handshake status is NOT_HANDSHAKING, finish the loop\");\n-                endLoops = true;\n-            } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                throw new Exception(\n-                        \"Unexpected status, SSLEngine.getHandshakeStatus() \"\n-                                + \"shouldn't return FINISHED\");\n-            } else {\n-                throw new Exception(\n-                        \"Can't reach here, handshake status is \" + hs);\n+                } break;\n+                case FINISHED: throw new Exception( \"Unexpected status, \" +\n+                        \"SSLEngine.getHandshakeStatus() shouldn't return FINISHED\");\n+                default: throw new Exception(\"Can't reach here, \" +\n+                        \"handshake status is \" + hs);\n@@ -294,0 +274,26 @@\n+    void verifySSLEngineResultStatus(SSLEngineResult r, String side) throws Exception {\n+        SSLEngineResult.Status rs = r.getStatus();\n+        SSLEngineResult.HandshakeStatus hs = r.getHandshakeStatus();\n+        switch (rs) {\n+            case OK: log(side, \"SSLEngineResult status OK\"); break;\n+            case BUFFER_OVERFLOW: {\n+                log(side, \"BUFFER_OVERFLOW, handshake status is \" + hs);\n+                \/\/ the client maximum fragment size config does not work?\n+                throw new Exception(\"Buffer overflow: \" +\n+                        \"incorrect client maximum fragment size\");\n+            }\n+            case BUFFER_UNDERFLOW: {\n+                log(side, \"BUFFER_UNDERFLOW, handshake status is \" + hs);\n+                \/\/ bad packet, or the client maximum fragment size\n+                \/\/ config does not work?\n+                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+                    throw new Exception(\"Buffer underflow: \" +\n+                            \"incorrect client maximum fragment size\");\n+                } \/\/ otherwise, ignore this packet\n+            } break;\n+            case CLOSED: throw new Exception(\n+                    \"SSL engine closed, handshake status is \" + hs);\n+            default: throw new Exception(\"Can't reach here, result is \" + rs);\n+        }\n+    }\n+\n@@ -296,1 +302,1 @@\n-            ByteBuffer appData, SocketAddress peerAddr) throws Exception {\n+            ByteBuffer appData, SocketAddress peerAddr, String side) throws Exception {\n@@ -300,1 +306,1 @@\n-                produceApplicationPackets(engine, appData, peerAddr);\n+                produceApplicationPackets(engine, appData, peerAddr, side);\n@@ -347,1 +353,1 @@\n-                        \"Too much loops to produce handshake packets\");\n+                        \"Too many loops to produce handshake packets\");\n@@ -359,22 +365,0 @@\n-            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-                \/\/ the client maximum fragment size config does not work?\n-                throw new Exception(\"Buffer overflow: \" +\n-                            \"incorrect server maximum fragment size\");\n-            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-                log(side,\n-                        \"Produce handshake packets: BUFFER_UNDERFLOW occured\");\n-                log(side,\n-                        \"Produce handshake packets: Handshake status: \" + hs);\n-                \/\/ bad packet, or the client maximum fragment size\n-                \/\/ config does not work?\n-                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-                    throw new Exception(\"Buffer underflow: \" +\n-                            \"incorrect server maximum fragment size\");\n-                } \/\/ otherwise, ignore this packet\n-            } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                throw new Exception(\"SSLEngine has closed\");\n-            } else if (rs == SSLEngineResult.Status.OK) {\n-                \/\/ OK\n-            } else {\n-                throw new Exception(\"Can't reach here, result is \" + rs);\n-            }\n@@ -382,1 +366,2 @@\n-            \/\/ SSLEngineResult.Status.OK:\n+            verifySSLEngineResultStatus(r, side);\n+\n@@ -399,12 +384,10 @@\n-                if (nhs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n-                    runDelegatedTasks(engine);\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||\n-                    nhs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN ||\n-                    nhs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n-\n-                    endInnerLoop = true;\n-                    endLoops = true;\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n-                    endInnerLoop = true;\n-                } else if (nhs == SSLEngineResult.HandshakeStatus.FINISHED) {\n-                    throw new Exception(\n+                switch (nhs) {\n+                    case NEED_TASK: runDelegatedTasks(engine); break;\n+                    case NEED_UNWRAP:\n+                    case NEED_UNWRAP_AGAIN:\n+                    case NOT_HANDSHAKING: {\n+                        endInnerLoop = true;\n+                        endLoops = true;\n+                    } break;\n+                    case NEED_WRAP: endInnerLoop = true; break;\n+                    case FINISHED:  throw new Exception(\n@@ -412,3 +395,2 @@\n-                                    + \"shouldn't return FINISHED\");\n-                } else {\n-                    throw new Exception(\"Can't reach here, handshake status is \"\n+                                    + \"should not return FINISHED\");\n+                    default: throw new Exception(\"Can't reach here, handshake status is \"\n@@ -417,0 +399,1 @@\n+\n@@ -431,1 +414,1 @@\n-            SocketAddress socketAddr) throws Exception {\n+            SocketAddress socketAddr, String side) throws Exception {\n@@ -438,15 +421,1 @@\n-        SSLEngineResult.Status rs = r.getStatus();\n-        if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n-            \/\/ the client maximum fragment size config does not work?\n-            throw new Exception(\"Buffer overflow: \" +\n-                        \"incorrect server maximum fragment size\");\n-        } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n-            \/\/ unlikely\n-            throw new Exception(\"Buffer underflow during wraping\");\n-        } else if (rs == SSLEngineResult.Status.CLOSED) {\n-                throw new Exception(\"SSLEngine has closed\");\n-        } else if (rs == SSLEngineResult.Status.OK) {\n-            \/\/ OK\n-        } else {\n-            throw new Exception(\"Can't reach here, result is \" + rs);\n-        }\n+        verifySSLEngineResultStatus(r, side);\n@@ -454,1 +423,0 @@\n-        \/\/ SSLEngineResult.Status.OK:\n@@ -475,1 +443,1 @@\n-            \/\/ Normally, this pakcet should be a handshake message\n+            \/\/ Normally, this packet should be a handshake message\n@@ -493,1 +461,1 @@\n-                    } else {                        \/\/ cipherext\n+                    } else {                        \/\/ ciphertext\n@@ -498,1 +466,1 @@\n-                        \/\/ following packets any mroe as a Finished\n+                        \/\/ following packets any more as a Finished\n@@ -543,2 +511,2 @@\n-                .trustStore(KeyStoreUtils.loadKeyStore(trustFilename, passphrase))\n-                .keyStore(KeyStoreUtils.loadKeyStore(keyFilename, passphrase))\n+                .trustStore(KeyStoreUtils.loadKeyStore(TRUST_FILENAME, passphrase))\n+                .keyStore(KeyStoreUtils.loadKeyStore(KEY_FILENAME, passphrase))\n@@ -562,2 +530,7 @@\n-        try (DatagramSocket serverSocket = new DatagramSocket();\n-                DatagramSocket clientSocket = new DatagramSocket()) {\n+        InetSocketAddress serverSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n+        InetSocketAddress clientSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n+\n+        try (DatagramSocket serverSocket = new DatagramSocket(serverSocketAddress);\n+                DatagramSocket clientSocket = new DatagramSocket(clientSocketAddress)) {\n@@ -569,1 +542,1 @@\n-                    InetAddress.getLocalHost(), serverSocket.getLocalPort());\n+                    InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n@@ -572,1 +545,1 @@\n-                    InetAddress.getLocalHost(), clientSocket.getLocalPort());\n+                    InetAddress.getLoopbackAddress(), clientSocket.getLocalPort());\n@@ -690,2 +663,1 @@\n-    final static void printHex(String prefix, ByteBuffer bb) {\n-        HexDumpEncoder  dump = new HexDumpEncoder();\n+    static void printHex(String prefix, ByteBuffer bb) {\n@@ -696,1 +668,1 @@\n-                dump.encodeBuffer(bb.slice(), System.out);\n+                HexPrinter.simple().format(bb.slice());\n@@ -704,1 +676,1 @@\n-    final static void printHex(String prefix,\n+    static void printHex(String prefix,\n@@ -707,2 +679,0 @@\n-        HexDumpEncoder  dump = new HexDumpEncoder();\n-\n@@ -712,2 +682,1 @@\n-                ByteBuffer bb = ByteBuffer.wrap(bytes, offset, length);\n-                dump.encodeBuffer(bb, System.out);\n+                HexPrinter.simple().format(bytes, offset, length);\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":169,"deletions":200,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-        handshakeType = Byte.valueOf(args[1]);\n+        handshakeType = Byte.parseByte(args[1]);\n@@ -100,1 +100,1 @@\n-        if (needPacketLoss && (!(isClient ^ engine.getUseClientMode()))) {\n+        if (needPacketLoss && (isClient == engine.getUseClientMode())) {\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-        handshakeType = Byte.valueOf(args[1]);\n+        handshakeType = Byte.parseByte(args[1]);\n@@ -101,1 +101,1 @@\n-        if (needPacketDuplicate && (!(isClient ^ engine.getUseClientMode()))) {\n+        if (needPacketDuplicate && (isClient == engine.getUseClientMode())) {\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/RespondToRetransmit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @library \/test\/lib\n@@ -37,1 +38,0 @@\n-import sun.security.util.HexDumpEncoder;\n@@ -40,0 +40,2 @@\n+import jdk.test.lib.hexdump.HexPrinter;\n+\n@@ -78,1 +80,1 @@\n-            (new HexDumpEncoder()).encodeBuffer(bytes, System.out);\n+            HexPrinter.simple().format(bytes);\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloBufferUnderflowException.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @library \/test\/lib\n@@ -39,1 +40,2 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n+\n@@ -66,1 +68,0 @@\n-        HexDumpEncoder dump = new HexDumpEncoder();\n@@ -69,1 +70,1 @@\n-            dump.encodeBuffer(bytes, System.out);\n+            HexPrinter.simple().format(bytes);\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloChromeInterOp.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -75,1 +75,1 @@\n-                new HexDumpEncoder().encodeBuffer(t, System.out);\n+                HexPrinter.simple().format(t);\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/MSOID2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -36,1 +37,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -207,1 +208,1 @@\n-        new HexDumpEncoder().encodeBuffer(data, System.err);\n+        HexPrinter.simple().dest(System.err).format(data);\n","filename":"test\/jdk\/sun\/security\/krb5\/etype\/KerberosAesSha2.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -87,2 +87,2 @@\n-        HexDumpEncoder hde = new HexDumpEncoder();\n-        System.out.println(\"Plaintext:\\n\" + hde.encode(plain) + \"\\n\");\n+        HexPrinter hp = HexPrinter.simple();\n+        System.out.println(\"Plaintext:\\n\" + hp.toString(plain) + \"\\n\");\n@@ -95,1 +95,1 @@\n-        System.out.println(hde.encode(encrypted) + \"\\n\");\n+        System.out.println(hp.toString(encrypted) + \"\\n\");\n@@ -102,1 +102,1 @@\n-        System.out.println(hde.encode(encrypted2) + \"\\n\");\n+        System.out.println(hp.toString(encrypted2) + \"\\n\");\n@@ -109,1 +109,1 @@\n-        System.out.println(hde.encode(decrypted) + \"\\n\");\n+        System.out.println(hp.toString(decrypted) + \"\\n\");\n@@ -118,1 +118,1 @@\n-        System.out.println(hde.encode(decrypted) + \"\\n\");\n+        System.out.println(hp.toString(decrypted) + \"\\n\");\n","filename":"test\/jdk\/sun\/security\/mscapi\/PublicKeyInterop.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -43,1 +44,0 @@\n-import sun.security.util.HexDumpEncoder;\n@@ -58,0 +58,1 @@\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -61,2 +62,0 @@\n-    static final HexDumpEncoder hexDump = new HexDumpEncoder();\n-\n@@ -123,1 +122,1 @@\n-        System.out.println(hexDump.encode(strm.toByteArray()));\n+        HexPrinter.simple().format(strm.toByteArray());\n@@ -134,1 +133,1 @@\n-            System.out.println(hexDump.encode(strm.toByteArray()));\n+            HexPrinter.simple().format(strm.toByteArray());\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/SignerOrder.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -45,1 +46,0 @@\n-import sun.security.util.HexDumpEncoder;\n@@ -51,0 +51,1 @@\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -55,2 +56,0 @@\n-    static final HexDumpEncoder hexDump = new HexDumpEncoder();\n-\n@@ -284,1 +283,1 @@\n-        hexDump.encodeBuffer(bytes, out);\n+        HexPrinter.simple().dest(out).format(bytes);\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -35,1 +36,0 @@\n-import sun.security.util.HexDumpEncoder;\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -61,1 +62,1 @@\n-        new HexDumpEncoder().encodeBuffer(bout.toByteArray(), System.err);\n+        HexPrinter.simple().dest(System.err).format(bout.toByteArray());\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs9\/UnknownAttribute.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -230,1 +230,1 @@\n-                            new HexDumpEncoder().encode(buf));\n+                            HexPrinter.minimal().toString(buf));\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -34,1 +35,1 @@\n-import sun.security.util.HexDumpEncoder;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -66,1 +67,1 @@\n-        HexDumpEncoder e = new HexDumpEncoder();\n+        HexPrinter e = HexPrinter.simple();\n@@ -68,1 +69,1 @@\n-            System.out.println(\"Sucess: out:\" + e.encodeBuffer(out));\n+            System.out.println(\"Success: out:\" + e.toString(out));\n@@ -70,2 +71,2 @@\n-            System.out.println(\"Failed: encode:\" + e.encodeBuffer(out));\n-            System.out.println(\"getEncoded:\" + e.encodeBuffer(enc));\n+            System.out.println(\"Failed: encode:\" + e.toString(out));\n+            System.out.println(\"getEncoded:\" + e.toString(enc));\n@@ -75,1 +76,1 @@\n-            System.out.println(\"Sucess: X500Name(byte[]):\" + x.toString());\n+            System.out.println(\"Success: X500Name(byte[]):\" + x.toString());\n","filename":"test\/jdk\/sun\/security\/x509\/X500Name\/NullX500Name.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+# This file identifies the root of the test-suite hierarchy.\n+# It also contains test-suite configuration information.\n+\n+# Minimum jtreg version\n+requiredVersion=7.3.1+1\n+\n+# Path to libraries in the topmost test directory. This is needed so @library\n+# does not need ..\/..\/ notation to reach them\n+external.lib.roots = ..\/..\/\n","filename":"test\/lib-test\/TEST.ROOT","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,409 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+\n+\/*\n+ * @test\n+ * @summary Check HexPrinter formatting\n+ * @library \/test\/lib\n+ * @compile HexPrinterTest.java\n+ * @run testng jdk.test.lib.hexdump.HexPrinterTest\n+ *\/\n+public class HexPrinterTest {\n+\n+    @Test\n+    static void testMinimalToStringByteArray() {\n+        int len = 16;\n+        byte[] bytes = genData(len);\n+        StringBuilder expected = new StringBuilder(bytes.length * 2);\n+        for (int i = 0; i < len; i++)\n+            expected.append(String.format(\"%02x\", bytes[i]));\n+        String actual = HexPrinter.minimal().toString(bytes);\n+        System.out.println(actual);\n+        Assert.assertEquals(actual, expected.toString(), \"Minimal format incorrect\");\n+    }\n+\n+    @DataProvider(name = \"ColumnParams\")\n+    Object[][] columnParams() {\n+        return new Object[][]{\n+                {\"%4d: \", \"%d \", 10, \" ; \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"},\n+                {\"%03o: \", \"%d \", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n+                {\"%5d: \", \"%02x:\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n+                {\"%5d: \", \"%3d\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n+                {\"%05o: \", \"%3o\", 8, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n+                {\"%6x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"%d \"), \"\\n\"},\n+                {\"%2x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"},\n+                {\"%5d: \", \"%02x\", 16, \" | \", 50, HexPrinter.Formatters.ofPrimitive(short.class, \"%d \"), \"\\n\"},\n+        };\n+    }\n+\n+    @DataProvider(name = \"BuiltinParams\")\n+    Object[][] builtinParams() {\n+        return new Object[][]{\n+                {\"minimal\", \"\", \"%02x\", 16, \"\", 64, HexPrinter.Formatters.NONE, \"\"},\n+                {\"canonical\", \"%08x  \", \"%02x \", 16, \"|\", 31, HexPrinter.Formatters.ASCII, \"|\\n\"},\n+                {\"simple\", \"%5d: \", \"%02x \", 16, \" \/\/ \", 64, HexPrinter.Formatters.PRINTABLE, \"\\n\"},\n+                {\"source\", \"    \", \"(byte)%3d, \", 8, \" \/\/ \", 64, HexPrinter.Formatters.PRINTABLE,\n+                        \"\\n\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"BuiltinParams\")\n+    public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,\n+                             String annoDelim, int annoWidth,\n+                             HexPrinter.Formatter mapper, String lineSep) {\n+        HexPrinter f = switch (name) {\n+            case \"minimal\" -> HexPrinter.minimal();\n+            case \"simple\" -> HexPrinter.simple();\n+            case \"canonical\" -> HexPrinter.canonical();\n+            case \"source\" -> HexPrinter.source();\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + name);\n+        };\n+\n+        testParams(f, offsetFormat, binFormat, colWidth, annoDelim, annoWidth, mapper, lineSep);\n+\n+        String actual = f.toString();\n+        HexPrinter f2 = HexPrinter.simple()\n+                .withOffsetFormat(offsetFormat)\n+                .withBytesFormat(binFormat, colWidth)\n+                .formatter(mapper, annoDelim, annoWidth)\n+                .withLineSeparator(lineSep);\n+        String expected = f2.toString();\n+        Assert.assertEquals(actual, expected, \"toString of \" + name + \" does not match\");\n+    }\n+\n+    @Test(dataProvider = \"ColumnParams\")\n+    public void testToStringTwoLines(String offsetFormat, String binFormat, int colWidth,\n+                                     String annoDelim, int annoWidth,\n+                                     HexPrinter.Formatter mapper, String lineSep) {\n+        HexPrinter f = HexPrinter.simple()\n+                .withOffsetFormat(offsetFormat)\n+                .withBytesFormat(binFormat, colWidth)\n+                .formatter(mapper, annoDelim, annoWidth)\n+                .withLineSeparator(lineSep);\n+        testParams(f, offsetFormat, binFormat, colWidth, annoDelim, annoWidth, mapper, lineSep);\n+    }\n+\n+    public static void testParams(HexPrinter printer, String offsetFormat, String binFormat, int colWidth,\n+                                  String annoDelim, int annoWidth,\n+                                  HexPrinter.Formatter mapper, String lineSep) {\n+        byte[] bytes = genData(colWidth * 2);\n+        System.out.println(\"Params: \" + printer.toString());\n+        String out = printer.toString(bytes);\n+        System.out.println(out);\n+\n+        \/\/ Compare the actual output with the expected output of each formatting element\n+        int padToWidth = colWidth * String.format(binFormat, 0xff).length();\n+        int ndx = 0;\n+        int valuesStart = 0;\n+        int l;\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (i % colWidth == 0) {\n+                String offset = String.format(offsetFormat, i);\n+                l = offset.length();\n+                Assert.assertEquals(out.substring(ndx, ndx + l), offset,\n+                        \"offset format mismatch: \" + ndx);\n+                ndx += l;\n+                valuesStart = ndx;\n+            }\n+            String value = String.format(binFormat, (0xff & bytes[i]));\n+            l = value.length();\n+            Assert.assertEquals(out.substring(ndx, ndx + l), value,\n+                    \"value format mismatch: \" + ndx + \", i: \" + i);\n+            ndx += l;\n+            if (((i + 1) % colWidth) == 0) {\n+                \/\/ Rest of line is for padding, delimiter, formatter\n+                String padding = \" \".repeat(padToWidth - (ndx - valuesStart));\n+                Assert.assertEquals(out.substring(ndx, ndx + padding.length()), padding, \"padding\");\n+                ndx += padding.length();\n+                Assert.assertEquals(out.substring(ndx, ndx + annoDelim.length()), annoDelim,\n+                        \"delimiter mismatch\");\n+                ndx += annoDelim.length();\n+\n+                \/\/ Formatter output is tested separately\n+                ndx = out.indexOf(lineSep, ndx) + lineSep.length();\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"PrimitiveFormatters\")\n+    Object[][] formatterParams() {\n+        return new Object[][]{\n+                {byte.class, \"\"},\n+                {byte.class, \"%02x: \"},\n+                {short.class, \"%d \"},\n+                {int.class, \"%08x, \"},\n+                {long.class, \"%16x \"},\n+                {float.class, \"%3.4f \"},\n+                {double.class, \"%6.3g \"},\n+                {boolean.class, \"%b \"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"PrimitiveFormatters\")\n+    public void testFormatter(Class<?> primClass, String fmtString) {\n+        HexPrinter.Formatter formatter = HexPrinter.Formatters.ofPrimitive(primClass, fmtString);\n+        \/\/ Create a byte array with data for two lines\n+        int colWidth = 8;\n+        byte[] bytes = genData(colWidth);\n+        StringBuilder sb = new StringBuilder();\n+        DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n+        DataInputStream in2 = new DataInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            while (true) {\n+                formatter.annotate(in, sb);\n+                Object n = readPrimitive(primClass, in2);\n+                String expected = String.format(fmtString, n);\n+                Assert.assertEquals(sb.toString(), expected, \"mismatch\");\n+                sb.setLength(0);\n+            }\n+        } catch (IOException ioe) {\n+            \/\/ EOF is done\n+        }\n+        try {\n+            Assert.assertEquals(in.available(), 0, \"not all input consumed\");\n+            Assert.assertEquals(in2.available(), 0, \"not all 2nd stream input consumed\");\n+        } catch (IOException ioe) {\n+            \/\/\n+        }\n+    }\n+\n+    @Test(dataProvider = \"PrimitiveFormatters\")\n+    static void testHexPrinterPrimFormatter(Class<?> primClass, String fmtString) {\n+        \/\/ Create a byte array with data for two lines\n+        int colWidth = 8;\n+        byte[] bytes = genData(colWidth);\n+\n+        HexPrinter p = HexPrinter.simple()\n+                .formatter(primClass, fmtString);\n+        String actual = p.toString(bytes);\n+        System.out.println(actual);\n+        \/\/ The formatter should produce the same output as using the formatter method\n+        \/\/ with an explicit formatter for the primitive\n+        String expected = HexPrinter.simple()\n+                .formatter(HexPrinter.Formatters.ofPrimitive(primClass, fmtString))\n+                .toString(bytes);\n+        Assert.assertEquals(actual, expected, \"mismatch\");\n+    }\n+\n+    private static Object readPrimitive(Class<?> primClass, DataInputStream in) throws IOException {\n+        if (int.class.equals(primClass)) {\n+            return in.readInt();\n+        } else if (byte.class.equals(primClass)) {\n+            return (int) in.readByte();\n+        } else if (short.class.equals(primClass)) {\n+            return in.readShort();\n+        } else if (char.class.equals(primClass)) {\n+            return in.readChar();\n+        } else if (long.class.equals(primClass)) {\n+            return in.readLong();\n+        } else if (float.class.equals(primClass)) {\n+            return in.readFloat();\n+        } else if (double.class.equals(primClass)) {\n+            return in.readDouble();\n+        } else if (boolean.class.equals(primClass)) {\n+            return in.readBoolean();\n+        } else {\n+            throw new RuntimeException(\"unknown primitive class: \" + primClass);\n+        }\n+    }\n+\n+    @DataProvider(name = \"sources\")\n+    Object[][] sources() {\n+        return new Object[][]{\n+                {genBytes(21), 0, -1},\n+                {genBytes(21), 5, 12},\n+        };\n+    }\n+\n+    public static byte[] genData(int len) {\n+        \/\/ Create a byte array with data for two lines\n+        byte[] bytes = new byte[len];\n+        for (int i = 0; i < len \/ 2; i++) {\n+            bytes[i] = (byte) (i + 'A');\n+            bytes[i + len \/ 2] = (byte) (i + 'A' + 128);\n+        }\n+        return bytes;\n+    }\n+\n+    public static byte[] genFloat(int len) {\n+        byte[] bytes = null;\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             DataOutputStream out = new DataOutputStream(baos)) {\n+            for (int i = 0; i < len; i++) {\n+                out.writeFloat(i);\n+            }\n+            bytes = baos.toByteArray();\n+        } catch (IOException unused) {\n+        }\n+        return bytes;\n+    }\n+\n+    public static byte[] genDouble(int len) {\n+        byte[] bytes = null;\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             DataOutputStream out = new DataOutputStream(baos)) {\n+            for (int i = 0; i < len; i++) {\n+                out.writeDouble(i);\n+            }\n+            bytes = baos.toByteArray();\n+        } catch (IOException unused) {\n+        }\n+        return bytes;\n+    }\n+\n+    public static byte[] genBytes(int len) {\n+        byte[] bytes = new byte[len];\n+        for (int i = 0; i < len; i++)\n+            bytes[i] = (byte) ('A' + i);\n+        return bytes;\n+    }\n+\n+    public ByteBuffer genByteBuffer(int len) {\n+        return ByteBuffer.wrap(genBytes(len));\n+    }\n+\n+    public InputStream genInputStream(int len) {\n+        return new ByteArrayInputStream(genBytes(len));\n+    }\n+\n+    @Test\n+    public void testNilPrinterBigBuffer() {\n+        byte[] bytes = new byte[1024];\n+        HexPrinter p = HexPrinter.minimal();\n+        String r = p.toString(bytes);\n+        Assert.assertEquals(r.length(), bytes.length * 2, \"encoded byte wrong size\");\n+        Assert.assertEquals(r.replace(\"00\", \"\").length(), 0, \"contents not all zeros\");\n+    }\n+\n+    @Test(dataProvider = \"sources\")\n+    public void testToStringByteBuffer(byte[] bytes, int offset, int length) {\n+        if (length < 0)\n+            length = bytes.length - offset;\n+        ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\n+        System.out.printf(\"Source: %s, off: %d, len: %d%n\",\n+                bytes.getClass().getName(), offset, length);\n+        String actual;\n+        if (offset == 0 && length < 0) {\n+            bb.position(offset);\n+            bb.limit(length);\n+            actual = HexPrinter.simple().toString(bb);\n+        } else\n+            actual = HexPrinter.simple().toString(bb, offset, length);\n+        System.out.println(actual);\n+        String expected = HexPrinter.simple().toString(bytes, offset, length);\n+        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+    }\n+\n+    @Test(dataProvider = \"sources\")\n+    public void testFormatBytes(byte[] bytes, int offset, int length) {\n+        int len = length >= 0 ? length : bytes.length;\n+        System.out.printf(\"Source: %s, off: %d, len: %d%n\",\n+                \"bytes\", offset, len);\n+        StringBuilder sb = new StringBuilder();\n+        if (offset == 0 && length < 0)\n+            HexPrinter.simple().dest(sb).format(bytes);\n+        else\n+            HexPrinter.simple().dest(sb).format(bytes, offset, len);\n+        String actual = sb.toString();\n+        System.out.println(actual);\n+        String expected = HexPrinter.simple().toString(bytes, offset, len);\n+        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+    }\n+\n+    @Test(dataProvider = \"sources\")\n+    public void testFormatByteBuffer(byte[] bytes, int offset, int length) {\n+        if (length < 0)\n+            length = bytes.length - offset;\n+        ByteBuffer bb = ByteBuffer.wrap(bytes, 0, bytes.length);\n+        System.out.printf(\"Source: %s, off: %d, len: %d%n\",\n+                bytes.getClass().getName(), offset, length);\n+        StringBuilder sb = new StringBuilder();\n+        if (offset == 0 && length < 0) {\n+            bb.position(offset);\n+            bb.limit(length);\n+            HexPrinter.simple().dest(sb).format(bb);\n+        } else\n+            HexPrinter.simple().dest(sb).format(bb, offset, length);\n+        String actual = sb.toString();\n+        System.out.println(actual);\n+        String expected = HexPrinter.simple().toString(bytes, offset, length);\n+        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+    }\n+\n+    @Test(dataProvider = \"sources\")\n+    public void testFormatInputStream(byte[] bytes, int offset, int length) {\n+        \/\/ Offset is ignored\n+        InputStream is = new ByteArrayInputStream(bytes, 0, length);\n+        StringBuilder sb = new StringBuilder();\n+        System.out.printf(\"Source: %s, off: %d, len: %d%n\",\n+                bytes.getClass().getName(), offset, length);\n+        HexPrinter.simple().dest(sb).format(is);\n+        String actual = sb.toString();\n+        System.out.println(actual);\n+        String expected = HexPrinter.simple().toString(bytes, 0, length);\n+        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullByteArray() {\n+        HexPrinter.simple().dest(System.out).format((byte[]) null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullByteArrayOff() {\n+        HexPrinter.simple().dest(System.out).format((byte[]) null, 0, 1);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullByteBuffer() {\n+        HexPrinter.simple().dest(System.out).format((ByteBuffer) null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullByteBufferOff() {\n+        HexPrinter.simple().dest(System.out).format((ByteBuffer) null, 0, 1);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullInputStream() {\n+        HexPrinter.simple().dest(System.out).format((InputStream) null);\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/HexPrinterTest.java","additions":409,"deletions":0,"binary":false,"changes":409,"status":"added"},{"patch":"@@ -0,0 +1,1181 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.CharArrayWriter;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+\n+\/**\n+ * Decode a sequence of bytes to a readable format.\n+ * <p>\n+ * The predefined formats are:\n+ * <DL>\n+ * <DT>{@link #minimal() Minimal format}:  {@code \"Now is the time for Java.\\n\"}<\/DT>\n+ * <DD><pre>    {@code\n+ *     4e6f77206973207468652074696d6520666f72204a6176612e0a} <\/pre>\n+ * <\/DD>\n+ *\n+ * <DT>{@link #simple() Simple format}: {@code \"Now is the time for Java.\\n\"}<\/DT>\n+ * <DD><pre>{@code\n+ *     0: 4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20  \/\/ Now is the time for Java.\\n\n+ *    16: 66 6f 72 20 4a 61 76 61 2e 0a} <\/pre>\n+ * <\/DD>\n+ *\n+ * <DT>{@link #canonical() Canonical format}: {@code \"Now is the time for Java.\\n\"}<\/DT>\n+ * <DD><pre>{@code\n+ *     00000000  4e 6f 77 20 69 73 20 74 68 65 20 74 69 6d 65 20 |Now is the time |\n+ *     00000010  66 6f 72 20 4a 61 76 61 2e 0a                   |for Java.|} <\/pre>\n+ * <\/DD>\n+ * <DT>{@link #source() Byte array initialization source}: {@code \"Now is the time for Java.\\n\"}<\/DT>\n+ * <DD><pre>{@code\n+ *     (byte) 78, (byte)111, (byte)119, (byte) 32, (byte)105, (byte)115, (byte) 32, (byte)116,  \/\/ Now is t\n+ *     (byte)104, (byte)101, (byte) 32, (byte)116, (byte)105, (byte)109, (byte)101, (byte) 32,  \/\/ he time\n+ *     (byte)102, (byte)111, (byte)114, (byte) 32, (byte) 74, (byte) 97, (byte)118, (byte) 97,  \/\/ for Java\n+ *     (byte) 46, (byte) 10,                                                                    \/\/ .\\n}<\/pre>\n+ * <\/DD>\n+ * <\/DL>\n+ * <p>\n+ * The static factories {@link #minimal minimal}, {@link #simple simple},\n+ * {@link #canonical canonical}, and {@link #source() Java source}\n+ * return predefined {@code HexPrinter}s for the formats above.\n+ * HexPrinter holds the formatting parameters that control the width and formatting\n+ * of each of the offset, byte values, and formatted output.\n+ * New HexPrinters with different parameters are created using an existing HexPrinter\n+ * as a template with the methods {@link #formatter(Formatter)},\n+ * {@link #withBytesFormat(String, int)}, {@link #withOffsetFormat(String)},\n+ * and {@link #withLineSeparator(String)}.\n+ * <p>\n+ * The source of the bytes includes byte arrays, InputStreams, and ByteBuffers.\n+ * For example, {@link #toString(InputStream)} reads the input and returns a String.\n+ * Each of the {@code toString(...)} methods immediately reads and\n+ * formats all of the bytes from the source and returns a String.\n+ * <p>\n+ * Each of the  {@code format(...)} methods immediately reads and\n+ * formats all of the bytes from the source and appends it to the destination.\n+ * For example, {@link #format(InputStream)} reads the input and\n+ * appends the output to {@link System#out System.out} unless the\n+ * {@link #dest(Appendable) destination} is changed to an {@link Appendable}\n+ * such as {@link PrintStream}, {@link StringBuilder}, or {@link Writer}.\n+ * <p>\n+ * {@linkplain Formatter Formatter} functions read and interpret the bytes to show the\n+ * structure and content of a protocol or data stream.\n+ * Built-in formatters include {@link HexPrinter#formatter(Class, String) primitives},\n+ * {@link Formatters#PRINTABLE printable ascii},\n+ * and {@link Formatters#utf8Parser(DataInputStream, Appendable) UTF-8 strings}.\n+ * The {@link #formatter(Formatter, String, int) formatter} method sets the\n+ * formatting function, the delimiter, and the width.\n+ * Custom formatter functions can be implemented as a lambda, a method, an inner class, or a concrete class.\n+ * <p>\n+ * The format of each line is customizable.\n+ * The {@link #withOffsetFormat(String) withOffsetFormat} method controls\n+ * the format of the byte offset.\n+ * The {@link #withBytesFormat(String, int) withBytesFormat} method controls\n+ * the printing of each byte value including the separator,\n+ * and the maximum number of byte values per line.\n+ * The offset and byte values are formatted using the familiar\n+ * {@link String#format String formats} with spacing\n+ * and delimiters included in the format string.\n+ * The {@link #withLineSeparator(String) withLineSeparator} method sets\n+ * the line separator.\n+ * <p>\n+ * Examples:\n+ * <UL>\n+ * <LI> Encoding bytes to a minimal string.\n+ * <pre>{@code\n+ * byte[] bytes = new byte[] { ' ', 0x41, 0x42, '\\n'};\n+ * String s = HexPrinter.minimal().toString(bytes);\n+ * Result: \"2041420a\"\n+ * }<\/pre>\n+ * <LI>Simple formatting of a byte array.\n+ * <pre>{@code\n+ * byte[] bytes = new byte[] { ' ', 0x41, 0x42, '\\n'};\n+ * String s = HexPrinter.simple().toString(bytes);\n+ * Result:    0: 20 41 42 0a                                      \/\/  AB\\n\n+ * }<\/pre>\n+ * <LI>Simple formatting of a ByteBuffer.\n+ * <pre>{@code\n+ * ByteBuffer bb = ByteBuffer.wrap(bytes);\n+ * String s = HexPrinter.simple().toString(bb);\n+ * Result:    0: 20 41 42 0a                                      \/\/  AB\\n\n+ * }<\/pre>\n+ * <LI>Simple formatting of ranges of a byte array to System.err.\n+ * <pre>{@code\n+ * byte[] bytes = new byte[] { ' ', 0x41, 0x42, 0x43, 0x44, '\\n'};\n+ * HexPrinter hex = HexPrinter.simple()\n+ *                            .dest(System.err);\n+ *                            .format(bytes, 1, 2)\n+ *                            .format(bytes, 3, 2);\n+ * Result:\n+ * 1: 41 42                                            \/\/ AB\n+ * 3: 43 44                                            \/\/ CD\n+ * }<\/pre>\n+ * <\/UL>\n+ * <p>\n+ * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; use of identity-sensitive operations (including reference equality\n+ * ({@code ==}), identity hash code, or synchronization) on instances\n+ * may have unpredictable results and should be avoided.\n+ * The {@code equals} method should be used for comparisons.\n+ *\n+ * <p>\n+ * This class is immutable and thread-safe.\n+ *\/\n+public final class HexPrinter {\n+\n+    \/**\n+     * Mnemonics for control characters.\n+     *\/\n+    static final String[] CONTROL_MNEMONICS = {\n+            \"nul\", \"soh\", \"stx\", \"etx\", \"eot\", \"enq\", \"ack\", \"bel\",\n+            \"b\", \"t\", \"n\", \"vt\", \"f\", \"r\", \"so\", \"si\",\n+            \"dle\", \"dc1\", \"dc2\", \"dc3\", \"dc4\", \"nak\", \"syn\", \"etb\",\n+            \"can\", \"em\", \"sub\", \"esc\", \"fs\", \"gs\", \"rs\", \"us\"\n+    };\n+    private static final String initOffsetFormat = \"%5d: \";\n+    private static final int initBytesCount = 16;   \/\/ 16 byte values\n+    private static final String initBytesFormat = \"%02x \";\n+    private static final int initAnnoWidth = initBytesCount * 4;\n+    private static final String initAnnoDelim = \" \/\/ \";\n+\n+    final Appendable dest;              \/\/ Final output target\n+    final String offsetFormat;          \/\/ Byte offset Formatter String\n+    final String bytesFormat;           \/\/ Hex bytes Formatter string\n+    final int bytesCount;               \/\/ Maximum number of byte values per line\n+    final String annoDelim;             \/\/ Annotation delimiter\n+    final int annoWidth;                \/\/ Annotation field width (characters)\n+    final String lineSeparator;         \/\/ End of line separator\n+    final Formatter annoFormatter;      \/\/ formatter function\n+\n+    \/**\n+     * Construct a new HexPrinter with all new values.\n+     *\n+     * @param printer       the formatter\n+     * @param offsetFormat  the offset format\n+     * @param bytesFormat   the bytes format\n+     * @param bytesCount    the count of bytes per line\n+     * @param annoDelim     the delimiter before the annotation\n+     * @param annoWidth     the width of the annotation\n+     * @param lineSeparator the line separator\n+     * @param dest          the destination\n+     *\/\n+    private HexPrinter(Formatter printer, String offsetFormat, String bytesFormat, int bytesCount,\n+                       String annoDelim, int annoWidth,\n+                       String lineSeparator, Appendable dest) {\n+        this.annoFormatter = Objects.requireNonNull(printer, \"formatter\");\n+        this.bytesCount = bytesCount;\n+        this.bytesFormat = Objects.requireNonNull(bytesFormat, bytesFormat);\n+        this.offsetFormat = Objects.requireNonNull(offsetFormat, \"offsetFormat\");\n+        this.annoDelim = Objects.requireNonNull(annoDelim, \"annoDelim\");\n+        this.annoWidth = annoWidth;\n+        this.lineSeparator = Objects.requireNonNull(lineSeparator, \"lineSeparator\");\n+        this.dest = Objects.requireNonNull(dest, \"dest\");\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the parameters to produce a minimal string.\n+     * The parameters are set to:\n+     * <UL>\n+     * <LI>byte offset format: none {@code \"\"},\n+     * <LI>each byte value is formatted as 2 hex digits: {@code \"%02x\"},\n+     * <LI>maximum number of byte values per line: unbounded,\n+     * <LI>delimiter for the annotation: none {@code \"\"},\n+     * <LI>formatter: {@link Formatters#NONE does not output a formatted byte}, and\n+     * <LI>destination: {@link System#out System.out}.\n+     * <\/UL>\n+     * Example,\n+     * <pre>\n+     * {@code     byte[] bytes = new byte[] { ' ', 0x41, 0x42, '\\n'};\n+     *     String s = HexPrinter.minimal()\n+     *             .toString(bytes);\n+     *     Result: \"2041420a\"\n+     * }<\/pre>\n+     *\n+     * @return a new HexPrinter\n+     *\/\n+    public static HexPrinter minimal() {\n+        return new HexPrinter(Formatters.NONE, \"\",\n+                \"%02x\", initBytesCount,\n+                \"\", initAnnoWidth, \"\",\n+                System.out);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the parameters to produce canonical output.\n+     * The parameters are set to:\n+     * <UL>\n+     * <LI>byte offset format: {@code \"%08x  \"},\n+     * <LI>each byte value is formatted as 2 hex digits and a space: {@code \"%02x \"},\n+     * <LI>maximum number of byte values per line: {@value initBytesCount},\n+     * <LI>delimiter for the annotation: {@code \"|\"},\n+     * <LI>formatter: {@link Formatters#ASCII ASCII bytes}, and\n+     * <LI>line separator: \"|\" + {@link  System#lineSeparator()},\n+     * <LI>destination: {@link System#out System.out}.\n+     * <\/UL>\n+     * Example,\n+     * <pre>\n+     * {@code     byte[] bytes = new byte[] { ' ', 0x41, 0x42, '\\n'};\n+     *     String s = HexPrinter.canonical()\n+     *             .toString(bytes);\n+     *\n+     *     Result: \"00000000  20 41 42 0a                                     | AB|\"\n+     * }<\/pre>\n+     *\n+     * @return a new HexPrinter\n+     *\/\n+    public static HexPrinter canonical() {\n+        return new HexPrinter(Formatters.ASCII, \"%08x  \",\n+                \"%02x \", initBytesCount,\n+                \"|\", 31, \"|\" + System.lineSeparator(),\n+                System.out);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting simple formatting parameters to output\n+     * to a multi-line string.\n+     * The parameters are set to:\n+     * <UL>\n+     * <LI>byte offset format: signed decimal width 5 and a space, {@code \"%5d: \"},\n+     * <LI>each byte value is formatted as 2 hex digits and a space: {@code \"%02x \"},\n+     * <LI>maximum number of byte values per line: {@value initBytesCount},\n+     * <LI>delimiter for the annotation: {@code \" \/\/ \"},\n+     * <LI>width for the annotation: {@value initAnnoWidth},\n+     * <LI>line separator: {@link System#lineSeparator()},\n+     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}\n+     * showing printable characters, mnemonics for control chars, and\n+     * otherwise the decimal byte values,\n+     * <LI>destination default: {@link System#out System.out}.\n+     * <\/UL>\n+     * Example,\n+     * <pre>\n+     * {@code    byte[] bytes = new byte[] { ' ', 0x41, 0x42, '\\n'};\n+     *    String s = HexPrinter.simple()\n+     *            .toString(bytes);\n+     *\n+     *    Result: \"    0: 20 41 42 0a                                      \/\/  AB\\n\"\n+     * }<\/pre>\n+     *\n+     * @return a new HexPrinter\n+     *\/\n+    public static HexPrinter simple() {\n+        return new HexPrinter(Formatters.PRINTABLE, initOffsetFormat,\n+                initBytesFormat, initBytesCount,\n+                initAnnoDelim, initAnnoWidth, System.lineSeparator(),\n+                System.out);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting formatting parameters to output\n+     * to a multi-line string as a byte array initialization for Java source.\n+     * The parameters are set to:\n+     * <UL>\n+     * <LI>byte offset format: 4 space indent: {@code \"    \"},\n+     * <LI>each byte value is formatted as: {@code \"(byte)%3d, \"},\n+     * <LI>maximum number of byte values per line: {@code 8},\n+     * <LI>delimiter for the annotation: {@code \" \/\/ \"},\n+     * <LI>width for the annotation: {@value initAnnoWidth},\n+     * <LI>line separator: {@link System#lineSeparator()},\n+     * <LI>formatter: {@link Formatters#PRINTABLE printable ASCII}\n+     * showing printable characters, mnemonics for control chars, and\n+     * otherwise the decimal byte values,\n+     * <LI>destination default: {@link System#out System.out}.\n+     * <\/UL>\n+     *\n+     * @return a new HexPrinter\n+     *\/\n+    public static HexPrinter source() {\n+        return new HexPrinter(Formatters.PRINTABLE, \"    \",\n+                \"(byte)%3d, \", 8,\n+                \" \/\/ \", initAnnoWidth, System.lineSeparator(),\n+                System.out);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the destination to the Appendable.\n+     * {@code Appendable} classes include: {@link PrintStream}, {@link Writer},\n+     * {@link StringBuilder}, and {@link StringBuffer}.\n+     *\n+     * @param dest the Appendable destination for the output, non-null\n+     * @return a new HexPrinter\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter dest(Appendable dest) {\n+        Objects.requireNonNull(dest, \"dest\");\n+        return new HexPrinter(annoFormatter, offsetFormat,\n+                bytesFormat, bytesCount, annoDelim,\n+                annoWidth, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * and append the output.\n+     * All output is appended and flushed to the destination.\n+     * <p>\n+     * The result is equivalent to calling\n+     * {@code format(new ByteArrayInputStream(source))}.\n+     *\n+     * @param source a non-null array of bytes.\n+     * @return this HexPrinter\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter format(byte[] source) {\n+        Objects.requireNonNull(source, \"byte array must be non-null\");\n+        return format(new ByteArrayInputStream(source));\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read the bytes from offset\n+     * for length and append the output.\n+     * All output is appended and flushed to the destination.\n+     * Only {@code length} bytes starting at the {@code offset} are formatted.\n+     * <p>\n+     * The result is equivalent to calling\n+     * {@code format(new ByteArrayInputStream(source, offset, len))}.\n+     *\n+     * @param source a non-null array of bytes.\n+     * @param offset the offset into the array to start\n+     * @param length the length of bytes in the array to format\n+     * @return this HexPrinter\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter format(byte[] source, int offset, int length) {\n+        Objects.requireNonNull(source, \"byte array must be non-null\");\n+        return format(new ByteArrayInputStream(source, offset, length), offset);\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * and append the output.\n+     * All output is appended and flushed to the destination.\n+     * <p>\n+     * The {@code format} method invokes the {@code formatter} to read bytes from the\n+     * source and append the formatted sequence of byte values to the destination.\n+     * As the bytes are read they are printed using the {@link #withBytesFormat}\n+     * to fill the bytes values of the output destination.\n+     * The output of the {@code formatter} fills the annotation field.\n+     * A new line is started when either the byte values or annotation\n+     * is filled to its respective width. The offset of the first byte on the line\n+     * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.\n+     * <p>\n+     * This method may block indefinitely reading from the input stream,\n+     * or writing to the output stream. The behavior for the case where\n+     * the input and\/or output stream is asynchronously closed,\n+     * or the thread interrupted during the transfer, is highly input\n+     * and output stream specific, and therefore not specified.\n+     * <p>\n+     * If an I\/O error occurs reading from the input stream or\n+     * writing to the output stream, then it may do so after some bytes\n+     * have been read or written. Consequently the input stream\n+     * may not be at end of stream and one, or both, streams may be\n+     * in an inconsistent state. It is strongly recommended that both streams\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @param source an InputStream to read from, the stream not closed and\n+     *               is at end-of-file.\n+     * @return this HexPrinter\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter format(InputStream source) {\n+        return format(source, 0);\n+    }\n+\n+    \/**\n+     * Format an InputStream and supply the initial offset.\n+     *\n+     * @param source an InputStream\n+     * @param offset an offset\n+     * @return this HexPrinter\n+     *\/\n+    private HexPrinter format(InputStream source, int offset) {\n+        Objects.requireNonNull(source, \"InputStream must be non-null\");\n+        try (AnnotationWriter writer =\n+                     new AnnotationWriter(this, source, offset, dest)) {\n+            writer.flush();\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read the bytes\n+     * from the offset for the length and append the output.\n+     * All annotation output is appended and flushed to the output destination.\n+     * The ByteBuffer position and limit are unused and not modified.\n+     *\n+     * @param source a ByteBuffer\n+     * @param offset the offset in the ByteBuffer\n+     * @param length the length in the ByteBuffer\n+     * @return this HexPrinter\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter format(ByteBuffer source, int offset, int length) {\n+        Objects.requireNonNull(source, \"ByteBuffer must be non-null\");\n+        ByteArrayInputStream bais;\n+        if (source.hasArray() && !source.isReadOnly()) {\n+            bais = new ByteArrayInputStream(source.array(), offset, length);\n+        } else {\n+            int size = source.limit() - source.position();\n+            byte[] bytes = new byte[size];\n+            source.get(bytes, offset, length);\n+            bais = new ByteArrayInputStream(bytes);\n+        }\n+        return format(bais, offset);\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * in the source and append the output.\n+     * The source bytes are from the {@code ByteBuffer.position()}\n+     * to the {@code ByteBuffer.limit()}.\n+     * The position is not modified.\n+     * All output is appended and flushed to the destination.\n+     *\n+     * @param source a ByteBuffer\n+     * @return this HexPrinter\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public HexPrinter format(ByteBuffer source) {\n+        return format(source, source.position(), source.limit());\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * and return a String.\n+     *\n+     * @param source a non-null array of bytes.\n+     * @return the output as a non-null {@code String}\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public String toString(byte[] source) {\n+        Objects.requireNonNull(source, \"byte array must be non-null\");\n+        return toString(new ByteArrayInputStream(source));\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read the bytes from offset\n+     * for length and return a String.\n+     * Only {@code length} bytes starting at the {@code offset} are formatted.\n+     *\n+     * @param source a non-null array of bytes.\n+     * @param offset the offset into the array to start\n+     * @param length the length of bytes in the array to format\n+     * @return the output as a non-null {@code String}\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public String toString(byte[] source, int offset, int length) {\n+        Objects.requireNonNull(source, \"byte array must be non-null\");\n+        StringBuilder sb = new StringBuilder();\n+        try (AnnotationWriter writer =\n+                     new AnnotationWriter(this, new ByteArrayInputStream(source, offset, length),\n+                             offset, sb)) {\n+            writer.flush();\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * and return a String.\n+     * <p>\n+     * The {@code toString} method invokes the formatter to read bytes from the\n+     * source and append the formatted sequence of byte values.\n+     * As the bytes are read they are printed using the {@link #withBytesFormat}\n+     * to fill the second field of the line.\n+     * The output of the {@code formatter} fills the annotation field.\n+     * A new line is started when either the byte values or annotation\n+     * is filled to its respective width. The offset of the first byte on the line\n+     * is inserted at the beginning of each line using {@link #withOffsetFormat(String)}.\n+     * <p>\n+     * This method may block indefinitely reading from the input stream,\n+     * or writing to the output stream. The behavior for the case where\n+     * the input and\/or output stream is asynchronously closed,\n+     * or the thread interrupted during the transfer, is highly input\n+     * and output stream specific, and therefore not specified.\n+     * <p>\n+     * If an I\/O error occurs reading from the input stream or\n+     * writing to the output stream, then it may do so after some bytes\n+     * have been read or written. Consequently the input stream\n+     * may not be at end of stream and one, or both, streams may be\n+     * in an inconsistent state. It is strongly recommended that both streams\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @param source an InputStream to read from, the stream not closed and\n+     *               is at end-of-file upon return.\n+     * @return the output as a non-null {@code String}\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public String toString(InputStream source) {\n+        Objects.requireNonNull(source, \"InputStream must be non-null\");\n+        StringBuilder sb = new StringBuilder();\n+        try (AnnotationWriter writer =\n+                     new AnnotationWriter(this, source, 0, sb)) {\n+            writer.flush();\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read the bytes\n+     * from the offset for the length and return a String.\n+     * The ByteBuffer position and limit are unused and not modified.\n+     *\n+     * @param source a ByteBuffer\n+     * @param offset the offset in the ByteBuffer\n+     * @param length the length in the ByteBuffer\n+     * @return the output as a non-null {@code String}\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public String toString(ByteBuffer source, int offset, int length) {\n+        Objects.requireNonNull(source, \"ByteBuffer must be non-null\");\n+        StringBuilder sb = new StringBuilder();\n+        ByteArrayInputStream bais;\n+        if (source.hasArray() && !source.isReadOnly()) {\n+            bais = new ByteArrayInputStream(source.array(), offset, length);\n+        } else {\n+            byte[] bytes = new byte[length];\n+            source.get(bytes, offset, length);\n+            bais = new ByteArrayInputStream(bytes);\n+        }\n+        try (AnnotationWriter writer =\n+                     new AnnotationWriter(this, bais, offset, sb)) {\n+            writer.flush();\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * The formatter function is called repeatedly to read all of the bytes\n+     * in the source and return a String.\n+     * The source bytes are from the {@code ByteBuffer.position()}\n+     * to the {@code ByteBuffer.limit()}.\n+     * The position is not modified.\n+     *\n+     * @param source a ByteBuffer\n+     * @return the output as a non-null {@code String}\n+     * @throws java.io.UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public String toString(ByteBuffer source) {\n+        return toString(source, source.position(), source.limit());\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the format for the byte offset.\n+     * The format string is specified by {@link String#format String format}\n+     * including any delimiters. For example, {@code \"%3x: \"}.\n+     * If the format is an empty string, there is no offset in the output.\n+     *\n+     * @param offsetFormat a new format string for the byte offset.\n+     * @return a new HexPrinter\n+     *\/\n+    public HexPrinter withOffsetFormat(String offsetFormat) {\n+        Objects.requireNonNull(offsetFormat, \"offsetFormat\");\n+        return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,\n+                annoDelim, annoWidth, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the format for each byte value and\n+     * the maximum number of byte values per line.\n+     * The format string is specified by {@link String#format String format},\n+     * including any delimiters or padding. For example, {@code \"%02x \"}.\n+     * If the byteFormat is an empty String, there are no byte values in the output.\n+     *\n+     * @param byteFormat a format string for each byte\n+     * @param bytesCount the maximum number of byte values per line\n+     * @return a new HexPrinter\n+     *\/\n+    public HexPrinter withBytesFormat(String byteFormat, int bytesCount) {\n+        Objects.requireNonNull(bytesFormat, \"bytesFormat\");\n+        return new HexPrinter(annoFormatter, offsetFormat, byteFormat, bytesCount,\n+                annoDelim, annoWidth, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the line separator.\n+     * The line separator can be set to an empty string or to\n+     * a string to be added at the end of each line.  It should include the line\n+     * separator {@link System#lineSeparator()} if a line break is to be output.\n+     *\n+     * @param separator the line separator\n+     * @return a new HexPrinter\n+     *\/\n+    public HexPrinter withLineSeparator(String separator) {\n+        return new HexPrinter(annoFormatter, offsetFormat, bytesFormat, bytesCount,\n+                annoDelim, annoWidth, separator, dest);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the formatter.\n+     * The widths, delimiters and other parameters are unchanged.\n+     *\n+     * @param formatter a non-null Formatter\n+     * @return a new HexPrinter\n+     *\/\n+    public HexPrinter formatter(Formatter formatter) {\n+        Objects.requireNonNull(formatter, \"Formatter must be non-null\");\n+        return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,\n+                annoDelim, annoWidth, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the formatter, delimiter, and width of the annotation.\n+     * Note: The annotations may exceed the width.\n+     *\n+     * @param formatter a non-null Formatter\n+     * @param delim     a string delimiter for the annotation\n+     * @param width     the width of the annotation, non-negative\n+     * @return a new HexPrinter\n+     *\/\n+    public HexPrinter formatter(Formatter formatter, String delim, int width) {\n+        Objects.requireNonNull(formatter, \"formatter\");\n+        Objects.requireNonNull(delim, \"delim\");\n+        return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,\n+                delim, width, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * Returns a new HexPrinter setting the formatter to format a primitive type\n+     * using the format string.\n+     * The format string should include any pre or post spacing and delimiters.\n+     * <p>\n+     * This is a convenience function equivalent to finding a formatter using\n+     * {@link HexPrinter.Formatters#ofPrimitive}.\n+     * <\/p>\n+     *\n+     * @param primClass a primitive class, for example, {@code int.class}\n+     * @param fmtString a {@link java.util.Formatter format string}.\n+     * @return a new HexPrinter\n+     * @throws IllegalArgumentException if the class is not a primitive class\n+     *\/\n+    public HexPrinter formatter(Class<?> primClass, String fmtString) {\n+        Formatter formatter = getFormatter(primClass, fmtString);\n+        return new HexPrinter(formatter, offsetFormat, bytesFormat, bytesCount,\n+                annoDelim, annoWidth, lineSeparator, dest);\n+    }\n+\n+    \/**\n+     * Returns a formatter for the primitive type using the format string.\n+     * The formatter reads a value of the primitive type from the stream\n+     * and formats it using the format string.\n+     * The format string includes any pre or post spacing and delimiters.\n+     *\n+     * @param primClass a primitive class, for example, {@code int.class}\n+     * @param fmtString a {@link java.util.Formatter format string}\n+     * @return a Formatter for the primitive type using the format string\n+     *\/\n+    static Formatter getFormatter(Class<?> primClass, String fmtString) {\n+        return new PrimitiveFormatter(primClass, fmtString);\n+    }\n+\n+    \/**\n+     * Returns a string describing this HexPrinter.\n+     * The string indicates the type of the destination and\n+     * the formatting options.\n+     *\n+     * @return a String describing this HexPrinter\n+     *\/\n+    public String toString() {\n+        return \"formatter: \" + annoFormatter\n+                + \", dest: \" + dest.getClass().getName()\n+                + \", offset: \\\"\" + offsetFormat\n+                + \"\\\", bytes: \" + bytesCount\n+                + \" x \\\"\" + bytesFormat + \"\\\"\"\n+                + \", delim: \\\"\" + annoDelim + \"\\\"\"\n+                + \", width: \" + annoWidth\n+                + \", nl: \\\"\" + expand(lineSeparator) + \"\\\"\";\n+    }\n+\n+    private String expand(String sep) {\n+        return sep.replace(\"\\n\", \"\\\\n\")\n+                .replace(\"\\r\", \"\\\\r\");\n+    }\n+\n+    private static class PrimitiveFormatter implements Formatter {\n+\n+        private final Class<?> primClass;\n+        private final String fmtString;\n+\n+        PrimitiveFormatter(Class<?> primClass, String fmtString) {\n+            Objects.requireNonNull(primClass, \"primClass\");\n+            Objects.requireNonNull(fmtString, \"fmtString\");\n+            if (!primClass.isPrimitive())\n+                throw new IllegalArgumentException(\"Not a primitive type: \" + primClass.getName());\n+            this.primClass = primClass;\n+            this.fmtString = fmtString;\n+        }\n+\n+        public void annotate(DataInputStream in, Appendable out) throws IOException {\n+            if (primClass == byte.class) {\n+                int v = in.readByte();\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == boolean.class) {\n+                boolean v = in.readByte() != 0;\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == short.class | primClass == char.class) {\n+                int v = in.readShort();\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == float.class) {\n+                float v = in.readFloat();\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == int.class) {\n+                int v = in.readInt();\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == double.class) {\n+                double v = in.readDouble();\n+                out.append(String.format(fmtString, v));\n+            } else if (primClass == long.class) {\n+                long v = in.readLong();\n+                out.append(String.format(fmtString, v));\n+            } else {\n+                throw new AssertionError(\"missing case on primitive class\");\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"(\" + primClass.getName() + \", \\\"\" + fmtString + \"\\\")\";\n+        }\n+    }\n+\n+    \/**\n+     * Formatter function reads bytes from a stream and\n+     * appends a readable annotation to the output destination.\n+     * <p>\n+     * Each invocation of the {@link #annotate annotate} method reads and annotates\n+     * a single instance of its protocol or data type.\n+     * <p>\n+     * Built-in formatting functions are provided in the {@link Formatters} class.\n+     * <p>\n+     * As described by the {@link HexPrinter#toString(InputStream)} method,\n+     * the {@link #annotate annotate} method is called to read bytes and produce\n+     * the descriptive annotation.\n+     * <p>\n+     * For example, a custom lambda formatter to read a float value (4 bytes) and\n+     * print as a floating number could be written as a static method.\n+     * <pre>{@code\n+     *     \/\/ Format 4 bytes read from the input as a float 3.4.\n+     *     static void annotate(DataInputStream in, Appendable out) throws IOException {\n+     *         float f = in.readFloat();\n+     *         out.append(String.format(\"%3.4f, \", f));\n+     *     }\n+     *\n+     *     byte[] bytes = new byte[] {00 00 00 00 3f 80 00 00 40 00 00 00 40 40 00 00};\n+     *     HexPrinter pp = HexPrinter.simple()\n+     *         .withBytesFormat(\"%02x \", 8)\n+     *         .formatter(Example::annotate)\n+     *         .format(bytes);\n+     *\n+     * Result:\n+     *     0: 00 00 00 00 3f 80 00 00  \/\/ 0.0000, 1.0000,\n+     *     8: 40 00 00 00 40 40 00 00  \/\/ 2.0000, 3.0000,\n+     * }<\/pre>\n+     *\n+     * <p>\n+     * The details of the buffering and calling of the formatter {@code annotate}\n+     * methods is roughly as follows.\n+     * The bytes read by the {@code annotate} method are logically buffered\n+     * for each line of output.\n+     * The {@code annotate} method writes its description of the bytes read\n+     * to the output, this output is also buffered.\n+     * When the number of bytes read exceeds the\n+     * {@link #withBytesFormat(String, int) byte values count per line},\n+     * the buffered output exceeds the\n+     * {@link #formatter(Formatter, String, int) width of the annotation field},\n+     * or a new line {@code \"\\n\"} character is found in the output then\n+     * a line of output is assembled and written to the destination Appendable.\n+     * The formatter's {@code annotate} method is called repeatedly\n+     * until the input is completely consumed or an exception is thrown.\n+     * Any remaining buffered bytes or description are flushed to the destination Appendable.\n+     *\/\n+    @FunctionalInterface\n+    public interface Formatter {\n+\n+        \/**\n+         * Read bytes from the input stream and append a descriptive annotation\n+         * to the output destination.\n+         *\n+         * @param in  a DataInputStream\n+         * @param out an Appendable for the output\n+         * @throws IOException if an I\/O error occurs\n+         *\/\n+        void annotate(DataInputStream in, Appendable out) throws IOException;\n+    }\n+\n+    \/**\n+     * Built-in formatters for printable byte, ASCII, UTF-8 and primitive types.\n+     * Formatters for primitive types and different formatting options\n+     * can be found by calling {@link #ofPrimitive(Class, String)}.\n+     *\/\n+    public enum Formatters implements Formatter {\n+        \/**\n+         * Read a byte and if it is ASCII write it,\n+         * otherwise, write its mnemonic or its decimal value.\n+         *\/\n+        PRINTABLE,\n+        \/**\n+         * Read a byte, if it is ASCII write it, otherwise write a \".\".\n+         *\/\n+        ASCII,\n+        \/**\n+         * Read a modified UTF-8 string and write it.\n+         *\/\n+        UTF8,\n+        \/**\n+         * Read a byte and write nothing.\n+         *\/\n+        NONE;\n+\n+        public void annotate(DataInputStream in, Appendable out) throws IOException {\n+            switch (this) {\n+                case PRINTABLE: bytePrintable(in, out); break;\n+                case ASCII: byteASCII(in, out); break;\n+                case UTF8: utf8Parser(in, out); break;\n+                case NONE: byteNoneParser(in, out); break;\n+            }\n+        }\n+\n+        \/**\n+         * Read a byte and write it as ASCII if it is printable,\n+         * print its mnemonic if it is a control character,\n+         * and print its decimal value otherwise.\n+         * A space separator character is appended for control and decimal values.\n+         *\n+         * @param in  a DataInputStream\n+         * @param out an Appendable to write to\n+         * @throws IOException if an I\/O error occurs\n+         *\/\n+        static void bytePrintable(DataInputStream in, Appendable out) throws IOException {\n+            int v = in.readUnsignedByte();\n+            if (v < 32) {\n+                out.append(\"\\\\\").append(CONTROL_MNEMONICS[v]);\n+            } else if (v < 126 && Character.isDefined(v)) {\n+                out.append((char) v);\n+            } else {\n+                out.append(\"\\\\\").append(Integer.toString(v, 10));\n+            }\n+        }\n+\n+        \/**\n+         * Read a byte and write it as ASCII if it is printable, otherwise print \".\".\n+         *\n+         * @param in  a DataInputStream\n+         * @param out an Appendable to write to\n+         * @throws IOException if an I\/O error occurs\n+         *\/\n+        static void byteASCII(DataInputStream in, Appendable out) throws IOException {\n+            int v = in.readUnsignedByte();\n+            if (Character.isDefined(v)) {\n+                out.append((char) v);\n+            } else {\n+                out.append('.');\n+            }\n+        }\n+\n+        \/**\n+         * Read a modified UTF-8 string and write it to the output destination.\n+         *\n+         * @param in  a DataInputStream\n+         * @param out an Appendable to write the output to\n+         * @throws IOException if an I\/O error occurs\n+         *\/\n+        static void utf8Parser(DataInputStream in, Appendable out) throws IOException {\n+            out.append(in.readUTF()).append(\" \");\n+        }\n+\n+        \/**\n+         * Read a a byte and write nothing.\n+         *\n+         * @param in  a DataInputStream\n+         * @param out an Appendable to write the output to\n+         * @throws IOException if an I\/O error occurs\n+         *\/\n+        static void byteNoneParser(DataInputStream in, Appendable out) throws IOException {\n+            in.readByte();\n+        }\n+\n+        \/**\n+         * Returns a {@code Formatter} for a primitive using the format string.\n+         * The format string includes any pre or post spacing or delimiters.\n+         * A value of the primitive is read using the type specific methods\n+         * of {@link DataInputStream}, formatted using the format string, and\n+         * written to the output.\n+         *\n+         * @param primClass a primitive class, for example, {@code int.class}\n+         * @param fmtString a {@link java.util.Formatter format string}.\n+         * @return a Formatter\n+         *\/\n+        public static Formatter ofPrimitive(Class<?> primClass, String fmtString) {\n+            Objects.requireNonNull(primClass, \"primClass\");\n+            Objects.requireNonNull(fmtString, \"fmtString\");\n+            return new PrimitiveFormatter(primClass, fmtString);\n+        }\n+    }\n+\n+    \/**\n+     * Internal implementation of the annotation output and processor of annotated output.\n+     * Created for each new input source and discarded after each use.\n+     * An OffsetInputStream is created to buffer and count the input bytes.\n+     *\n+     *\/\n+    private static final class AnnotationWriter extends CharArrayWriter {\n+        private final transient OffsetInputStream source;\n+        private final transient DataInputStream in;\n+        private final transient int baseOffset;\n+        private final transient HexPrinter params;\n+        private final transient int bytesColWidth;\n+        private final transient int annoWidth;\n+        private final transient Appendable dest;\n+\n+        \/**\n+         * Construct a new AnnotationWriter to process the source into the destination.\n+         * Initializes the DataInputStream and marking of the input to keep track\n+         * of bytes as they are read by the formatter.\n+         * @param params formatting parameters\n+         * @param source source InputStream\n+         * @param baseOffset initial offset\n+         * @param dest destination Appendable\n+         *\/\n+        AnnotationWriter(HexPrinter params, InputStream source, int baseOffset, Appendable dest) {\n+            this.params = params;\n+            this.baseOffset = baseOffset;\n+            Objects.requireNonNull(source, \"Source is null\");\n+            this.source = new OffsetInputStream(source);\n+            this.source.mark(1024);\n+            this.in = new DataInputStream(this.source);\n+            this.bytesColWidth = params.bytesCount * String.format(params.bytesFormat, 255).length();\n+            this.annoWidth = params.annoWidth;\n+            this.dest = dest;\n+        }\n+\n+        @Override\n+        public void write(int c) {\n+            super.write(c);\n+            checkFlush();\n+        }\n+\n+        @Override\n+        public void write(char[] c, int off, int len) {\n+            super.write(c, off, len);\n+            for (int i = 0; i < len; i++) {\n+                if (c[off+i] == '\\n') {\n+                    process();\n+                    return;\n+                }\n+            }\n+            checkFlush();\n+        }\n+\n+        @Override\n+        public void write(String str, int off, int len) {\n+            super.write(str, off, len);\n+            if (str.indexOf('\\n') >=0 )\n+                process();\n+            else\n+                checkFlush();\n+        }\n+\n+        private void checkFlush() {\n+            if (size() > annoWidth)\n+                process();\n+        }\n+\n+        \/**\n+         * The annotation printing function is called repeatedly to read all of the bytes\n+         * in the source stream and annotate the stream.\n+         * The annotated output is appended to the output dest or buffered.\n+         * <p>\n+         *     The HexPrinter is not closed and can be used as a template\n+         *     to create a new formatter with a new Source or different formatting\n+         *     options.\n+         * <\/p>\n+         *\/\n+        @Override\n+        public void flush() {\n+            try {\n+                while (true) {\n+                    if (source.markedByteCount() >= params.bytesCount)\n+                        process();\n+                    params.annoFormatter.annotate(in, this);\n+                    if (source.markedByteCount() > 256) {\n+                        \/\/ Normally annotations would cause processing more often\n+                        \/\/ Guard against overrunning the mark\/reset buffer.\n+                        process();\n+                    }\n+                }\n+            } catch (IOException ioe) {\n+                process();\n+                if (!(ioe instanceof EOFException)) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            } catch (UncheckedIOException uio) {\n+                process();      \/\/ clear out the buffers\n+                throw uio;\n+            }\n+        }\n+\n+        \/**\n+         * Merge the buffered stream of annotations with the formatted bytes\n+         * and append them to the dest.\n+         * <p>\n+         * The annotation mapping function has read some bytes and buffered\n+         * some output that corresponds to those bytes.\n+         * The un-formatted bytes are in the OffsetInputStream after the mark.\n+         * The stream is reset and the bytes are read again.\n+         * Each line of the produced one line at a time to the dest.\n+         * The byte offset is formatted according to the offsetFormat.\n+         * The bytes after the mark are read and formatted using the bytesFormat\n+         * and written to the dest up to the bytesWidth.\n+         * The annotation stream is appended to the dest, but only up to the\n+         * first newline (if any). The alignment between the annotated stream\n+         * and the formatted bytes is approximate.\n+         * New line characters in the annotation cause a new line to be started\n+         * without regard to the number of formatted bytes. The column of formatted\n+         * bytes may be incomplete.\n+         *\/\n+        private void process() {\n+            String info = toString();\n+            reset();\n+            int count = source.markedByteCount();\n+            try {\n+                source.reset();\n+                long binColOffset = source.byteOffset();\n+                while (count > 0 || info.length() > 0) {\n+                    dest.append(String.format(params.offsetFormat, binColOffset + baseOffset));\n+                    int colWidth = 0;\n+                    int byteCount = Math.min(params.bytesCount, count);\n+                    for (int i = 0; i < byteCount; i++) {\n+                        int b = source.read();\n+                        if (b == -1)\n+                            throw new IllegalStateException(\"BUG\");\n+                        String s = String.format(params.bytesFormat, b);\n+                        colWidth += s.length();\n+                        dest.append(s);\n+                    }\n+                    binColOffset += byteCount;\n+                    count -= byteCount;\n+\n+                    \/\/ Pad out the bytes column to its width\n+                    dest.append(\" \".repeat(Math.max(0, bytesColWidth - colWidth)));\n+                    dest.append(params.annoDelim);\n+\n+                    \/\/ finish a line and prepare for next line\n+                    \/\/ Add a line from annotation buffer\n+                    if (info.length() > 0) {\n+                        int nl = info.indexOf('\\n');\n+                        if (nl < 0) {\n+                            dest.append(info);\n+                            info = \"\";\n+                        } else {\n+                            dest.append(info, 0, nl);\n+                            info = info.substring(nl + 1);\n+                        }\n+                    }\n+                    dest.append(params.lineSeparator);\n+                }\n+            } catch (IOException ioe) {\n+                try {\n+                    dest.append(\"\\nIOException during annotations: \")\n+                        .append(ioe.getMessage())\n+                        .append(\"\\n\");\n+                } catch (IOException ignore) {\n+                    \/\/ ignore\n+                }\n+            }\n+            \/\/ reset the mark for the next line\n+            source.mark(1024);\n+        }\n+    }\n+\n+    \/**\n+     * Buffered InputStream that keeps track of byte offset.\n+     *\/\n+    private static final class OffsetInputStream extends BufferedInputStream {\n+        private long byteOffset;\n+        private long markByteOffset;\n+\n+        OffsetInputStream(InputStream in) {\n+            super(in);\n+            byteOffset = 0;\n+            markByteOffset = 0;\n+        }\n+\n+        long byteOffset() {\n+            return byteOffset;\n+        }\n+\n+        @Override\n+        public void reset() throws IOException {\n+            super.reset();\n+            byteOffset = markByteOffset;\n+        }\n+\n+        @Override\n+        public synchronized void mark(int readlimit) {\n+            super.mark(readlimit);\n+            markByteOffset = byteOffset;\n+        }\n+\n+        int markedByteCount() {\n+            if (markpos < 0)\n+                return 0;\n+            return pos - markpos;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            int b = super.read();\n+            if (b >= 0)\n+                byteOffset++;\n+            return b;\n+        }\n+\n+        @Override\n+        public long skip(long n) throws IOException {\n+            long size = super.skip(n);\n+            byteOffset += size;\n+            return size;\n+        }\n+\n+        @Override\n+        public int read(byte[] b) throws IOException {\n+            int size = super.read(b);\n+            byteOffset += Math.max(size, 0);\n+            return size;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            int size = super.read(b, off, len);\n+            byteOffset += Math.max(size, 0);\n+            return size;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/HexPrinter.java","additions":1181,"deletions":0,"binary":false,"changes":1181,"status":"added"}]}