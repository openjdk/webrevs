{"files":[{"patch":"@@ -218,0 +218,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-\/\/ This class generates simple event in a loop\n-\/\/ for a specified time.\n-\/\/ Pass the time in seconds as a parameter.\n+\/\/ This class generates simple event in a loop for a specified time.\n@@ -32,0 +30,1 @@\n+    public static final String MAIN_METHOD_STARTED = \"MAIN_METHOD_STARTED\";\n@@ -43,1 +42,0 @@\n-\n@@ -50,0 +48,2 @@\n+        System.out.println(MAIN_METHOD_STARTED);\n+\n@@ -60,0 +60,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/EventGeneratorLoop.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.nio.file.Path;\n@@ -45,0 +44,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n@@ -52,0 +53,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -57,0 +59,1 @@\n+    private static final long TIME_TO_WAIT_FOR_MAIN_METHOD_START = 5 * 1000; \/\/ milliseconds\n@@ -69,1 +72,3 @@\n-            DockerThread t = startMainContainer();\n+            MainContainer mainContainer = new MainContainer();\n+            mainContainer.start();\n+            mainContainer.waitForMainMethodStart(TIME_TO_WAIT_FOR_MAIN_METHOD_START);\n@@ -71,2 +76,1 @@\n-            waitForMainContainerToStart(500, 10);\n-            t.checkForErrors();\n+            long mainProcPid = testCase01();\n@@ -74,5 +78,5 @@\n-            OutputAnalyzer jcmdOut = testCase01();\n-            long mainProcPid = findProcess(jcmdOut, \"EventGeneratorLoop\");\n-\n-            t.assertIsAlive();\n-            testCase02(mainProcPid);\n+            \/\/ Excluding the test case below until JDK-8228850 is fixed\n+            \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n+            \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n+            \/\/ mainContainer.assertIsAlive();\n+            \/\/ testCase02(mainProcPid);\n@@ -82,1 +86,1 @@\n-            \/\/ t.assertIsAlive();\n+            \/\/ mainContainer.assertIsAlive();\n@@ -85,2 +89,1 @@\n-            t.join(TIME_TO_RUN_MAIN_PROCESS * 1000);\n-            t.checkForErrors();\n+            mainContainer.waitForAndCheck(TIME_TO_RUN_MAIN_PROCESS * 1000);\n@@ -93,3 +96,3 @@\n-    \/\/ Run \"jcmd -l\" in a sidecar container and find a process that runs EventGeneratorLoop\n-    private static OutputAnalyzer testCase01() throws Exception {\n-        return runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n+    \/\/ Run \"jcmd -l\" in a sidecar container, find a target process.\n+    private static long testCase01() throws Exception {\n+        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n@@ -97,2 +100,7 @@\n-            .shouldContain(\"sun.tools.jcmd.JCmd\")\n-            .shouldContain(\"EventGeneratorLoop\");\n+            .shouldContain(\"sun.tools.jcmd.JCmd\");\n+        long pid = findProcess(out, \"EventGeneratorLoop\");\n+        if (pid == -1) {\n+            throw new RuntimeException(\"Could not find specified process\");\n+        }\n+\n+        return pid;\n@@ -120,37 +128,0 @@\n-    private static DockerThread startMainContainer() throws Exception {\n-        \/\/ start \"main\" container (the observee)\n-        DockerRunOptions opts = commonDockerOpts(\"EventGeneratorLoop\");\n-        opts.addDockerOpts(\"--cap-add=SYS_PTRACE\")\n-            .addDockerOpts(\"--name\", MAIN_CONTAINER_NAME)\n-            .addDockerOpts(\"-v\", \"\/tmp\")\n-            .addJavaOpts(\"-XX:+UsePerfData\")\n-            .addClassOptions(\"\" + TIME_TO_RUN_MAIN_PROCESS);\n-        DockerThread t = new DockerThread(opts);\n-        t.start();\n-\n-        return t;\n-    }\n-\n-    private static void waitForMainContainerToStart(int delayMillis, int count) throws Exception {\n-        boolean started = false;\n-        for(int i=0; i < count; i++) {\n-            try {\n-                Thread.sleep(delayMillis);\n-            } catch (InterruptedException e) {}\n-            if (isMainContainerRunning()) {\n-                started = true;\n-                break;\n-            }\n-        }\n-        if (!started) {\n-            throw new RuntimeException(\"Main container did not start\");\n-        }\n-    }\n-\n-    private static boolean isMainContainerRunning() throws Exception {\n-        OutputAnalyzer out =\n-            DockerTestUtils.execute(Container.ENGINE_COMMAND,\n-                                    \"ps\", \"--no-trunc\",\n-                                    \"--filter\", \"name=\" + MAIN_CONTAINER_NAME);\n-        return out.getStdout().contains(MAIN_CONTAINER_NAME);\n-    }\n@@ -162,1 +133,1 @@\n-    private static OutputAnalyzer runSideCar(String MAIN_CONTAINER_NAME, String whatToRun,\n+    private static OutputAnalyzer runSideCar(String mainContainerName, String whatToRun,\n@@ -169,2 +140,2 @@\n-            \"--pid=container:\" + MAIN_CONTAINER_NAME,\n-            \"--volumes-from\", MAIN_CONTAINER_NAME,\n+            \"--pid=container:\" + mainContainerName,\n+            \"--volumes-from\", mainContainerName,\n@@ -179,0 +150,1 @@\n+    \/\/ Returns PID of a matching process, or -1 if not found.\n@@ -185,1 +157,1 @@\n-            throw new RuntimeException(\"Could not find matching process\");\n+            return -1;\n@@ -200,0 +172,8 @@\n+    private static void sleep(long delay) {\n+        try {\n+            Thread.sleep(delay);\n+        } catch (InterruptedException e) {\n+            System.out.println(\"InterruptedException\" + e.getMessage());\n+        }\n+    }\n+\n@@ -201,3 +181,3 @@\n-    static class DockerThread extends Thread {\n-        DockerRunOptions runOpts;\n-        Exception exception;\n+    static class MainContainer {\n+        boolean mainMethodStarted;\n+        Process p;\n@@ -205,2 +185,23 @@\n-        DockerThread(DockerRunOptions opts) {\n-            runOpts = opts;\n+        private Consumer<String> outputConsumer = s -> {\n+            if (!mainMethodStarted && s.contains(EventGeneratorLoop.MAIN_METHOD_STARTED)) {\n+                System.out.println(\"MainContainer: setting mainMethodStarted\");\n+                mainMethodStarted = true;\n+            }\n+        };\n+\n+        public Process start() throws Exception {\n+            \/\/ start \"main\" container (the observee)\n+            DockerRunOptions opts = commonDockerOpts(\"EventGeneratorLoop\");\n+            opts.addDockerOpts(\"--cap-add=SYS_PTRACE\")\n+                .addDockerOpts(\"--name\", MAIN_CONTAINER_NAME)\n+                .addDockerOpts(\"--volume\", \"\/tmp\")\n+                .addDockerOpts(\"--volume\", Paths.get(\".\").toAbsolutePath() + \":\/workdir\/\")\n+                .addJavaOpts(\"-XX:+UsePerfData\")\n+                .addClassOptions(\"\" + TIME_TO_RUN_MAIN_PROCESS);\n+\n+            List<String> cmd = DockerTestUtils.buildJavaCommand(opts);\n+            ProcessBuilder pb = new ProcessBuilder(cmd);\n+            p = ProcessTools.startProcess(\"main-container-process\",\n+                                          pb,\n+                                          outputConsumer);\n+            return p;\n@@ -209,6 +210,11 @@\n-        public void run() {\n-            try {\n-                DockerTestUtils.dockerRunJava(runOpts);\n-            } catch (Exception e) {\n-                exception = e;\n-            }\n+        public void waitForMainMethodStart(long howLong) {\n+            long expiration = System.currentTimeMillis() + howLong;\n+\n+            do {\n+                if (mainMethodStarted) {\n+                    return;\n+                }\n+                sleep(200);\n+            } while (System.currentTimeMillis() < expiration);\n+\n+            throw new RuntimeException(\"Timed out while waiting for main() to start\");\n@@ -218,2 +224,3 @@\n-            if (!isAlive()) {\n-                throw new RuntimeException(\"DockerThread stopped unexpectedly\");\n+            if (!p.isAlive()) {\n+                throw new RuntimeException(\"Main container process stopped unexpectedly, exit value: \"\n+                                           + p.exitValue());\n@@ -223,4 +230,8 @@\n-        public void checkForErrors() throws Exception {\n-            if (exception != null) {\n-                throw new RuntimeException(\"DockerThread threw exception\"\n-                                           + exception.getMessage());\n+        public void waitFor(long timeout) throws Exception {\n+            p.waitFor(timeout, TimeUnit.MILLISECONDS);\n+        }\n+\n+        public void waitForAndCheck(long timeout) throws Exception {\n+            waitFor(timeout);\n+            if (p.exitValue() != 0) {\n+                throw new RuntimeException(\"DockerThread stopped unexpectedly\");\n@@ -229,0 +240,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":87,"deletions":75,"binary":false,"changes":162,"status":"modified"}]}