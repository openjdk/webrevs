{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+\n@@ -99,5 +101,6 @@\n-            if (chc.localSupportedSignAlgs == null) {\n-                chc.localSupportedSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.activeProtocols);\n+            if (chc.localSupportedCertSignAlgs == null) {\n+                chc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                chc.sslConfig,\n+                                chc.algorithmConstraints, chc.activeProtocols,\n+                                CERTIFICATE_SCOPE);\n@@ -107,1 +110,1 @@\n-                    chc.localSupportedSignAlgs.size();\n+                    chc.localSupportedCertSignAlgs.size();\n@@ -111,1 +114,1 @@\n-            for (SignatureScheme ss : chc.localSupportedSignAlgs) {\n+            for (SignatureScheme ss : chc.localSupportedCertSignAlgs) {\n@@ -118,1 +121,1 @@\n-                    new SignatureSchemesSpec(chc.localSupportedSignAlgs));\n+                    new SignatureSchemesSpec(chc.localSupportedCertSignAlgs));\n@@ -198,1 +201,3 @@\n-                            spec.signatureSchemes);\n+                            spec.signatureSchemes,\n+                            CERTIFICATE_SCOPE);\n+\n@@ -247,5 +252,8 @@\n-            List<SignatureScheme> sigAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints,\n-                            List.of(shc.negotiatedProtocol));\n+            if (shc.localSupportedCertSignAlgs == null) {\n+                shc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc.sslConfig,\n+                                shc.algorithmConstraints,\n+                                List.of(shc.negotiatedProtocol),\n+                                CERTIFICATE_SCOPE);\n+            }\n@@ -253,1 +261,2 @@\n-            int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+            int vectorLen = SignatureScheme.sizeInRecord()\n+                    * shc.localSupportedCertSignAlgs.size();\n@@ -257,1 +266,1 @@\n-            for (SignatureScheme ss : sigAlgs) {\n+            for (SignatureScheme ss : shc.localSupportedCertSignAlgs) {\n@@ -264,1 +273,1 @@\n-                    new SignatureSchemesSpec(shc.localSupportedSignAlgs));\n+                    new SignatureSchemesSpec(shc.localSupportedCertSignAlgs));\n@@ -343,1 +352,3 @@\n-                            spec.signatureSchemes);\n+                            spec.signatureSchemes,\n+                            CERTIFICATE_SCOPE);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -383,1 +386,0 @@\n-\n@@ -610,1 +612,2 @@\n-            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+            ServerHandshakeContext shc = (ServerHandshakeContext) context;\n+\n@@ -613,3 +616,12 @@\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols);\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc.sslConfig,\n+                                shc.algorithmConstraints, shc.activeProtocols,\n+                                HANDSHAKE_SCOPE);\n+            }\n+\n+            if (shc.localSupportedCertSignAlgs == null) {\n+                shc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc.sslConfig,\n+                                shc.algorithmConstraints, shc.activeProtocols,\n+                                CERTIFICATE_SCOPE);\n@@ -618,2 +630,9 @@\n-            if (shc.localSupportedSignAlgs == null ||\n-                    shc.localSupportedSignAlgs.isEmpty()) {\n+            \/\/ According to TLSv1.2 RFC, CertificateRequest message must\n+            \/\/ contain signature schemes supported for both:\n+            \/\/ handshake signatures and certificate signatures.\n+            List<SignatureScheme> certReqSignAlgs =\n+                    new ArrayList<>(shc.localSupportedSignAlgs);\n+            certReqSignAlgs.retainAll(shc.localSupportedCertSignAlgs);\n+\n+            if (certReqSignAlgs == null ||\n+                    certReqSignAlgs.isEmpty()) {\n@@ -628,1 +647,1 @@\n-                    shc.localSupportedSignAlgs);\n+                    certReqSignAlgs);\n@@ -709,6 +728,17 @@\n-            List<SignatureScheme> sss = new LinkedList<>();\n-            for (int id : crm.algorithmIds) {\n-                SignatureScheme ss = SignatureScheme.valueOf(id);\n-                if (ss != null) {\n-                    sss.add(ss);\n-                }\n+            List<SignatureScheme> signAlgs =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc.sslConfig,\n+                            chc.algorithmConstraints, chc.negotiatedProtocol,\n+                            crm.algorithmIds,\n+                            HANDSHAKE_SCOPE);\n+\n+            List<SignatureScheme> signCertAlgs =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc.sslConfig,\n+                            chc.algorithmConstraints, chc.negotiatedProtocol,\n+                            crm.algorithmIds,\n+                            CERTIFICATE_SCOPE);\n+\n+            if (signAlgs == null || signAlgs.isEmpty() || signCertAlgs.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n@@ -716,3 +746,4 @@\n-            chc.peerRequestedSignatureSchemes = sss;\n-            chc.peerRequestedCertSignSchemes = sss;     \/\/ use the same schemes\n-            chc.handshakeSession.setPeerSupportedSignatureAlgorithms(sss);\n+\n+            chc.peerRequestedSignatureSchemes = signAlgs;\n+            chc.peerRequestedCertSignSchemes = signCertAlgs;\n+            chc.handshakeSession.setPeerSupportedSignatureAlgorithms(signCertAlgs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":49,"deletions":18,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    final AlgorithmConstraints              algorithmConstraints;\n+    final SSLAlgorithmConstraints           algorithmConstraints;\n@@ -138,0 +138,1 @@\n+    List<SignatureScheme>                   localSupportedCertSignAlgs;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        this.localSupportedSignAlgs = new ArrayList<>(\n+        this.localSupportedCertSignAlgs = new ArrayList<>(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PostHandshakeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n@@ -417,6 +418,6 @@\n-        \/\/ Make sure that the server handshake context's localSupportedSignAlgs\n-        \/\/ field is populated.  This is particularly important when\n-        \/\/ client authentication was used in an initial session and it is\n-        \/\/ now being resumed.\n-        if (shc.localSupportedSignAlgs == null) {\n-            shc.localSupportedSignAlgs =\n+        \/\/ Make sure that the server handshake context's\n+        \/\/ localSupportedCertSignAlgs field is populated.  This is particularly\n+        \/\/ important when client authentication was used in an initial session,\n+        \/\/ and it is now being resumed.\n+        if (shc.localSupportedCertSignAlgs == null) {\n+            shc.localSupportedCertSignAlgs =\n@@ -425,1 +426,2 @@\n-                            shc.algorithmConstraints, shc.activeProtocols);\n+                            shc.algorithmConstraints, shc.activeProtocols,\n+                            CERTIFICATE_SCOPE);\n@@ -447,1 +449,1 @@\n-                !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n+                !shc.localSupportedCertSignAlgs.containsAll(sessionSigAlgs)) {\n@@ -641,1 +643,1 @@\n-            if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {\n+            if (!chc.localSupportedCertSignAlgs.containsAll(sessionSigAlgs)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    private static final AlgorithmConstraints tlsDisabledAlgConstraints =\n+    private static final DisabledAlgorithmConstraints tlsDisabledAlgConstraints =\n@@ -49,1 +49,1 @@\n-    private static final AlgorithmConstraints x509DisabledAlgConstraints =\n+    private static final DisabledAlgorithmConstraints x509DisabledAlgConstraints =\n@@ -59,1 +59,1 @@\n-    static final AlgorithmConstraints DEFAULT =\n+    static final SSLAlgorithmConstraints DEFAULT =\n@@ -63,1 +63,1 @@\n-    static final AlgorithmConstraints DEFAULT_SSL_ONLY =\n+    static final SSLAlgorithmConstraints DEFAULT_SSL_ONLY =\n@@ -87,1 +87,1 @@\n-    static AlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+    static SSLAlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n@@ -91,1 +91,1 @@\n-    private static AlgorithmConstraints wrap(\n+    private static SSLAlgorithmConstraints wrap(\n@@ -202,1 +202,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -207,1 +207,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -212,1 +212,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -217,1 +217,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -255,1 +255,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -260,1 +260,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -265,1 +265,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -270,1 +270,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -276,0 +276,4 @@\n+    \/\/ Checks if algorithm is disabled for the given TLS scopes.\n+    boolean permits(String algorithm, Set<SSLScope> scopes) {\n+        return tlsDisabledAlgConstraints.permits(algorithm, scopes);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+\/*\n+ * Scopes defining different parts of TLS protocol.\n+ *\/\n+\n+public enum SSLScope {\n+    \/\/ Handshake signature scope as in signature_algorithms extension.\n+    HANDSHAKE_SIGNATURE(\"HandshakeSignature\"),\n+\n+    \/\/ Certificate signature scope as in signature_algorithms_cert extension.\n+    CERTIFICATE_SIGNATURE(\"CertificateSignature\");\n+\n+    private final String name;\n+\n+    SSLScope(String name) {\n+        this.name = name;\n+    }\n+\n+    \/\/ Note: the SSLScope name is case-insensitive.\n+    public static SSLScope nameOf(String scopeName) {\n+        for (SSLScope scope : SSLScope.values()) {\n+            if (scope.name.equalsIgnoreCase(scopeName)) {\n+                return scope;\n+            }\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLScope.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,1 @@\n-        this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?\n+        this.localSupportedSignAlgs = hc.localSupportedCertSignAlgs == null ?\n@@ -189,1 +189,1 @@\n-                        new ArrayList<>(hc.localSupportedSignAlgs));\n+                        new ArrayList<>(hc.localSupportedCertSignAlgs));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -279,1 +282,10 @@\n-                                shc.algorithmConstraints, shc.activeProtocols);\n+                                shc.algorithmConstraints, shc.activeProtocols,\n+                                HANDSHAKE_SCOPE);\n+                }\n+\n+                if (shc.localSupportedCertSignAlgs == null) {\n+                    shc.localSupportedCertSignAlgs =\n+                            SignatureScheme.getSupportedAlgorithms(\n+                                    shc.sslConfig,\n+                                    shc.algorithmConstraints, shc.activeProtocols,\n+                                    CERTIFICATE_SCOPE);\n@@ -508,1 +520,10 @@\n-                                shc.algorithmConstraints, shc.activeProtocols);\n+                                shc.algorithmConstraints, shc.activeProtocols,\n+                                HANDSHAKE_SCOPE);\n+                }\n+\n+                if (shc.localSupportedCertSignAlgs == null) {\n+                    shc.localSupportedCertSignAlgs =\n+                            SignatureScheme.getSupportedAlgorithms(\n+                                    shc.sslConfig,\n+                                    shc.algorithmConstraints, shc.activeProtocols,\n+                                    CERTIFICATE_SCOPE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -189,1 +191,2 @@\n-                            chc.algorithmConstraints, chc.activeProtocols);\n+                            chc.algorithmConstraints, chc.activeProtocols,\n+                            HANDSHAKE_SCOPE);\n@@ -283,1 +286,7 @@\n-                            spec.signatureSchemes);\n+                            spec.signatureSchemes,\n+                            HANDSHAKE_SCOPE);\n+\n+            if (sss == null || sss.isEmpty()) {\n+                throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n@@ -335,1 +344,1 @@\n-                    \"received CertificateRequest handshake message\");\n+                    \"received ClientHello handshake message\");\n@@ -417,1 +426,2 @@\n-                            List.of(shc.negotiatedProtocol));\n+                            List.of(shc.negotiatedProtocol),\n+                            HANDSHAKE_SCOPE);\n@@ -518,1 +528,7 @@\n-                            spec.signatureSchemes);\n+                            spec.signatureSchemes,\n+                            HANDSHAKE_SCOPE);\n+\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.util.EnumSet;\n@@ -222,3 +221,7 @@\n-    \/\/ performance optimization\n-    private static final Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =\n-        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));\n+    \/\/ Handshake signature scope.\n+    static final Set<SSLScope> HANDSHAKE_SCOPE =\n+            Set.of(SSLScope.HANDSHAKE_SIGNATURE);\n+\n+    \/\/ Certificate signature scope.\n+    static final Set<SSLScope> CERTIFICATE_SCOPE =\n+            Set.of(SSLScope.CERTIFICATE_SIGNATURE);\n@@ -226,0 +229,3 @@\n+    \/\/ Non-TLS specific SIGNATURE CryptoPrimitive.\n+    private static final Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =\n+            Set.of(CryptoPrimitive.SIGNATURE);\n@@ -358,10 +364,10 @@\n-    private boolean isPermitted(AlgorithmConstraints constraints) {\n-        return constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.name, null) &&\n-               constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.keyAlgorithm, null) &&\n-               constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.algorithm, (signAlgParams != null ?\n-                                signAlgParams.parameters : null)) &&\n-               (namedGroup != null ?\n-                        namedGroup.isPermitted(constraints) : true);\n+    private boolean isPermitted(\n+            SSLAlgorithmConstraints constraints, Set<SSLScope> scopes) {\n+        return constraints.permits(this.name, scopes)\n+                && constraints.permits(this.keyAlgorithm, scopes)\n+                && constraints.permits(this.algorithm, scopes)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.name, null)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.keyAlgorithm, null)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.algorithm,\n+                (signAlgParams != null ? signAlgParams.parameters : null))\n+                && (namedGroup == null || namedGroup.isPermitted(constraints));\n@@ -371,1 +377,1 @@\n-    \/\/ constraints.\n+    \/\/ constraints and SSL scopes.\n@@ -374,2 +380,3 @@\n-            AlgorithmConstraints constraints,\n-            List<ProtocolVersion> activeProtocols) {\n+            SSLAlgorithmConstraints constraints,\n+            List<ProtocolVersion> activeProtocols,\n+            Set<SSLScope> scopes) {\n@@ -391,1 +398,1 @@\n-                if (ss.supportedProtocols.contains(pv)) {\n+                if (ss.isSupportedProtocol(pv, scopes)) {\n@@ -398,1 +405,1 @@\n-                if (ss.isPermitted(constraints)) {\n+                if (ss.isPermitted(constraints, scopes)) {\n@@ -417,2 +424,4 @@\n-            AlgorithmConstraints constraints,\n-            ProtocolVersion protocolVersion, int[] algorithmIds) {\n+            SSLAlgorithmConstraints constraints,\n+            ProtocolVersion protocolVersion,\n+            int[] algorithmIds,\n+            Set<SSLScope> scopes) {\n@@ -428,5 +437,3 @@\n-            } else if (ss.isAvailable &&\n-                    ss.supportedProtocols.contains(protocolVersion) &&\n-                    (config.signatureSchemes.isEmpty() ||\n-                        config.signatureSchemes.contains(ss)) &&\n-                    ss.isPermitted(constraints)) {\n+            } else if ((config.signatureSchemes.isEmpty()\n+                        || config.signatureSchemes.contains(ss))\n+                    && ss.isAllowed(constraints, protocolVersion, scopes)) {\n@@ -446,1 +453,1 @@\n-            AlgorithmConstraints constraints,\n+            SSLAlgorithmConstraints constraints,\n@@ -452,4 +459,2 @@\n-            if (ss.isAvailable &&\n-                    ss.handshakeSupportedProtocols.contains(version) &&\n-                    certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &&\n-                    ss.isPermitted(constraints)) {\n+            if (certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm)\n+                    && ss.isAllowed(constraints, version, HANDSHAKE_SCOPE)) {\n@@ -464,1 +469,1 @@\n-            AlgorithmConstraints constraints,\n+            SSLAlgorithmConstraints constraints,\n@@ -480,2 +485,1 @@\n-            if (ss.isAvailable && (keySize >= ss.minimalKeySize) &&\n-                    ss.handshakeSupportedProtocols.contains(version) &&\n+            if (keySize >= ss.minimalKeySize &&\n@@ -483,1 +487,1 @@\n-                    ss.isPermitted(constraints)) {\n+                    ss.isAllowed(constraints, version, HANDSHAKE_SCOPE)) {\n@@ -543,0 +547,20 @@\n+    \/\/ Returns true if this signature scheme is supported for the given\n+    \/\/ protocol version and SSL scopes.\n+    private boolean isSupportedProtocol(\n+            ProtocolVersion version, Set<SSLScope> scopes) {\n+        if (scopes != null && scopes.equals(HANDSHAKE_SCOPE)) {\n+            return this.handshakeSupportedProtocols.contains(version);\n+        } else {\n+            return this.supportedProtocols.contains(version);\n+        }\n+    }\n+\n+    \/\/ Returns true if this signature scheme is available, supported and\n+    \/\/ permitted for the given constraints, protocol version and SSL scopes.\n+    private boolean isAllowed(SSLAlgorithmConstraints constraints,\n+            ProtocolVersion version, Set<SSLScope> scopes) {\n+        return isAvailable\n+                && isSupportedProtocol(version, scopes)\n+                && isPermitted(constraints, scopes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":60,"deletions":36,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.security.ssl.SSLScope;\n@@ -50,0 +51,1 @@\n+import java.util.Collections;\n@@ -182,0 +184,6 @@\n+    \/\/ Checks if algorithm is disabled for the given TLS scopes.\n+    public boolean permits(String algorithm, Set<SSLScope> scopes) {\n+        List<Constraint> list = algorithmConstraints.getConstraints(algorithm);\n+        return list == null || list.stream().allMatch(c -> c.permits(scopes));\n+    }\n+\n@@ -434,1 +442,1 @@\n-                        c = new UsageConstraint(algorithm, s);\n+                        c = new UsageConstraint(algorithm, s, propertyName);\n@@ -605,0 +613,11 @@\n+        \/**\n+         * Check if the algorithm constraint permits the given TLS scopes.\n+         *\n+         * @param scopes TLS scopes\n+         * @return 'true' if TLS scopes are allowed,\n+         *         'false' otherwise.\n+         *\/\n+        public boolean permits(Set<SSLScope> scopes) {\n+            return true;\n+        }\n+\n@@ -782,1 +801,1 @@\n-     * variant value in ConstraintsParameters.\n+     * variant value in ConstraintsParameters and against TLS scopes.\n@@ -786,0 +805,1 @@\n+        Set<SSLScope> scopes;\n@@ -787,1 +807,2 @@\n-        UsageConstraint(String algorithm, String[] usages) {\n+        UsageConstraint(\n+                String algorithm, String[] usages, String propertyName) {\n@@ -789,1 +810,34 @@\n-            this.usages = usages;\n+\n+            \/\/ Support TLS scopes only for jdk.tls.disabledAlgorithms property.\n+            if (PROPERTY_TLS_DISABLED_ALGS.equals(propertyName)) {\n+                for (String usage : usages) {\n+                    SSLScope scope = SSLScope.nameOf(usage);\n+\n+                    if (scope != null) {\n+                        if (this.scopes == null) {\n+                            this.scopes = new HashSet<>(usages.length);\n+                        }\n+                        this.scopes.add(scope);\n+                    } else {\n+                        this.usages = usages;\n+                    }\n+                }\n+\n+                if (this.scopes != null && this.usages != null) {\n+                    throw new IllegalArgumentException(\n+                            \"Can't mix TLS protocol specific constraints\"\n+                            + \" with other usage constraints\");\n+                }\n+\n+            } else {\n+                this.usages = usages;\n+            }\n+        }\n+\n+        @Override\n+        public boolean permits(Set<SSLScope> scopes) {\n+            if (this.scopes == null || scopes == null) {\n+                return true;\n+            }\n+\n+            return Collections.disjoint(this.scopes, scopes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -748,5 +748,24 @@\n-# syntax of the disabled algorithm string. Additionally, TLS cipher suites\n-# can be disabled with this property using one or more \"*\" wildcard characters.\n-# For example, \"TLS_RSA_*\" disables all cipher suites that start with\n-# \"TLS_RSA_\". Only cipher suites starting with \"TLS_\" are allowed to have\n-# wildcard characters.\n+# syntax of the disabled algorithm string.\n+#\n+# Additional TLS-specific syntax supported by this property:\n+#\n+#   - TLS cipher suites can be disabled with this property using one or more\n+#     \"*\" wildcard characters. For example, \"TLS_RSA_*\" disables all cipher\n+#     suites that start with \"TLS_RSA_\". Only cipher suites starting with\n+#     \"TLS_\" are allowed to have wildcard characters.\n+#\n+#   - TLS protocol specific usage constraints are supported by this property:\n+#\n+#     UsageConstraint:\n+#         usage UsageType { UsageType }\n+#\n+#     UsageType:\n+#         HandshakeSignature | CertificateSignature\n+#\n+#     HandshakeSignature restricts the use of the algorithm in TLS handshake\n+#     signatures. CertificateSignature restricts the use of the algorithm in\n+#     certificate signatures. An algorithm with this constraint cannot include\n+#     other usage types defined in the jdk.certpath.disabledAlgorithms\n+#     property. The usage type follows the keyword and more than one usage type\n+#     can be specified with a whitespace delimiter.\n+#     Example: \"rsa_pkcs1_sha1 usage HandshakeSignature\"\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +481,1 @@\n-    private KeyManager createKeyManager(\n+    static KeyManager createKeyManager(\n@@ -537,1 +537,1 @@\n-    private TrustManager createTrustManager(\n+    static TrustManager createTrustManager(\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+import java.util.Objects;\n@@ -200,1 +202,1 @@\n-    private static boolean isOpen(SSLEngine engine) {\n+    static boolean isOpen(SSLEngine engine) {\n@@ -243,1 +245,1 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n@@ -259,0 +261,83 @@\n+\n+    \/* Implementation of ByteBuffer.slice(int, int) for JDK11 *\/\n+    protected static final ByteBuffer slice(ByteBuffer buffer, int index, int length) {\n+        final int limit = buffer.limit();\n+        final int position = buffer.position();\n+        buffer.position(index);\n+        buffer.limit(index + length);\n+        ByteBuffer slice = buffer.slice();\n+        buffer.limit(limit);\n+        buffer.position(position);\n+        return slice;\n+    }\n+\n+    \/**\n+     * Given a TLS record containing one or more handshake messages, return\n+     * the specific handshake message as a ByteBuffer (a slice of the record)\n+     *\n+     * @param tlsRecord A ByteBuffer containing a TLS record.  It is\n+     *         assumed that the position of the ByteBuffer is on the\n+     *         first byte of the TLS record header.\n+     * @param hsMsgId The message identifier for the handshake message\n+     *         being sought.\n+     *         <a\n+     *         href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#appendix-B.3\">\n+     *         Message Identifiers\n+     *         <\/a>\n+     * @param isDtls Indicates whether DTLS protocol being used.\n+     * @return a ByteBuffer containing the TLS handshake message.\n+     *         The position of the returned ByteBuffer will be on the\n+     *         first byte of the TLS handshake message data,\n+     *         immediately following the handshake header.\n+     *         If the message is not found, null will be returned.\n+     * @throws SSLException if the incoming ByteBuffer does not contain\n+     *         a well-formed TLS message.\n+     *\/\n+    protected static ByteBuffer extractHandshakeMsg(\n+            ByteBuffer tlsRecord, int hsMsgId, boolean isDtls)\n+            throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        \/\/ Skip DTLS-specific bytes\n+        if (isDtls) {\n+            tlsRecord.position(tlsRecord.position() + 8);\n+        }\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                                   \"Record length = \" + recLen\n+                                   + \", Remaining = \" +\n+                                   tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+            \/\/ Skip DTLS-specific bytes\n+            if (isDtls) {\n+                tlsRecord.position(tlsRecord.position() + 8);\n+            }\n+\n+            if (msgType == hsMsgId) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                ByteBuffer buf = slice(tlsRecord, tlsRecord.position(), msgLen);\n+                tlsRecord.reset();\n+                return buf;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+        return null;\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":88,"deletions":3,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLException;\n+\n+\/**\n+ * This is not a test. Actual tests are implemented by concrete subclasses.\n+ * The abstract class AbstractCheckSignatureSchemes provides a base framework\n+ * for checking TLS signature schemes.\n+ *\/\n+\n+public abstract class AbstractCheckSignatureSchemes extends SSLEngineTemplate {\n+\n+    \/\/ Helper map to correlate integral SignatureScheme identifiers to\n+    \/\/ their IANA string name counterparts.\n+    protected static final Map<Integer, String> sigSchemeMap = Map.ofEntries(\n+            new SimpleImmutableEntry(0x0401, \"rsa_pkcs1_sha256\"),\n+            new SimpleImmutableEntry(0x0501, \"rsa_pkcs1_sha384\"),\n+            new SimpleImmutableEntry(0x0601, \"rsa_pkcs1_sha512\"),\n+            new SimpleImmutableEntry(0x0403, \"ecdsa_secp256r1_sha256\"),\n+            new SimpleImmutableEntry(0x0503, \"ecdsa_secp384r1_sha384\"),\n+            new SimpleImmutableEntry(0x0603, \"ecdsa_secp521r1_sha512\"),\n+            new SimpleImmutableEntry(0x0804, \"rsa_pss_rsae_sha256\"),\n+            new SimpleImmutableEntry(0x0805, \"rsa_pss_rsae_sha384\"),\n+            new SimpleImmutableEntry(0x0806, \"rsa_pss_rsae_sha512\"),\n+            new SimpleImmutableEntry(0x0807, \"ed25519\"),\n+            new SimpleImmutableEntry(0x0808, \"ed448\"),\n+            new SimpleImmutableEntry(0x0809, \"rsa_pss_pss_sha256\"),\n+            new SimpleImmutableEntry(0x080a, \"rsa_pss_pss_sha384\"),\n+            new SimpleImmutableEntry(0x080b, \"rsa_pss_pss_sha512\"),\n+            new SimpleImmutableEntry(0x0101, \"rsa_md5\"),\n+            new SimpleImmutableEntry(0x0201, \"rsa_pkcs1_sha1\"),\n+            new SimpleImmutableEntry(0x0202, \"dsa_sha1\"),\n+            new SimpleImmutableEntry(0x0203, \"ecdsa_sha1\"),\n+            new SimpleImmutableEntry(0x0301, \"rsa_sha224\"),\n+            new SimpleImmutableEntry(0x0302, \"dsa_sha224\"),\n+            new SimpleImmutableEntry(0x0303, \"ecdsa_sha224\"),\n+            new SimpleImmutableEntry(0x0402, \"rsa_pkcs1_sha256\"));\n+\n+    \/\/ Other useful TLS definitions for these tests\n+    protected static final int TLS_HS_CLI_HELLO = 1;\n+    protected static final int TLS_HS_CERT_REQ = 13;\n+    protected static final int SIG_ALGS_EXT = 13;\n+    protected static final int SIG_ALGS_CERT_EXT = 50;\n+\n+    protected AbstractCheckSignatureSchemes() throws Exception {\n+        super();\n+    }\n+\n+    \/\/ Returns the protocol for test to use.\n+    abstract String getProtocol();\n+\n+    protected boolean isDtls() {\n+        return getProtocol().startsWith(\"DTLS\");\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[]{getProtocol()});\n+        return clientEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setWantClientAuth(true);\n+        serverEngine.setEnabledProtocols(new String[]{getProtocol()});\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    public ContextParameters getServerContextParameters() {\n+        return new ContextParameters(getProtocol(), \"PKIX\", \"NewSunX509\");\n+    }\n+\n+    @Override\n+    public ContextParameters getClientContextParameters() {\n+        return new ContextParameters(getProtocol(), \"PKIX\", \"NewSunX509\");\n+    }\n+\n+    protected ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord, int hsMsgId)\n+            throws SSLException {\n+        return extractHandshakeMsg(tlsRecord, hsMsgId, isDtls());\n+    }\n+\n+    \/**\n+     * Parses the ClientHello message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the ClientHello\n+     * message body (AFTER the handshake header) and contains the entire\n+     * hello message.  Upon successful completion of this method the ByteBuffer\n+     * will have its position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data    The ByteBuffer containing the ClientHello bytes.\n+     * @param extCode Code of the TLS extension from which to extract\n+     *                signature schemes.\n+     * @return        A List of the signature schemes in string form.\n+     *\/\n+    protected List<String> getSigSchemesCliHello(\n+            ByteBuffer data, int extCode) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Skip over the protocol version and client random\n+        data.position(data.position() + 34);\n+\n+        \/\/ Jump past the session ID (if there is one)\n+        int sessLen = Byte.toUnsignedInt(data.get());\n+        if (sessLen != 0) {\n+            data.position(data.position() + sessLen);\n+        }\n+\n+        \/\/ Skip DTLS-specific opaque cookie if any\n+        if (isDtls()) {\n+            int cookieLen = Byte.toUnsignedInt(data.get());\n+            if (cookieLen != 0) {\n+                data.position(data.position() + cookieLen);\n+            }\n+        }\n+\n+        \/\/ Jump past the cipher suites\n+        int csLen = Short.toUnsignedInt(data.getShort());\n+        if (csLen != 0) {\n+            data.position(data.position() + csLen);\n+        }\n+\n+        \/\/ ...and the compression\n+        int compLen = Byte.toUnsignedInt(data.get());\n+        if (compLen != 0) {\n+            data.position(data.position() + compLen);\n+        }\n+\n+        \/\/ Now for the fun part.  Go through the extensions and look\n+        \/\/ for the two status request exts.\n+        List<String> extSigAlgs = getSigSchemesFromExt(data, extCode);\n+\n+        \/\/ We should be at the end of the ClientHello\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Parses the CertificateRequest message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the\n+     * CertificateRequest message body (AFTER the handshake header) and\n+     * contains the entire CR message.  Upon successful completion of this\n+     * method the ByteBuffer will have its position reset to the initial\n+     * offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data The ByteBuffer containing the CertificateRequest bytes\n+     *\n+     * @return A List of the signature schemes in string form.  If no\n+     * signature_algorithms extension is present in the CertificateRequest\n+     * then an empty list will be returned.\n+     *\/\n+    protected List<String> getSigSchemesCertReq(ByteBuffer data) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        \/\/ Collect the SignatureAndHashAlgorithms\n+        List<String> extSigAlgs = new ArrayList();\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            String schemeName = sigSchemeMap.get(\n+                    Short.toUnsignedInt(data.getShort()));\n+            if (schemeName != null) {\n+                extSigAlgs.add(schemeName);\n+            }\n+        }\n+\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Gets signatures schemes from the given TLS extension.\n+     * The buffer should be positioned at the start of the extension.\n+     *\/\n+    protected List<String> getSigSchemesFromExt(\n+            ByteBuffer data, int extCode) {\n+\n+        List<String> extSigAlgs = new ArrayList<>();\n+        data.getShort(); \/\/ read length\n+\n+        while (data.hasRemaining()) {\n+            int extType = Short.toUnsignedInt(data.getShort());\n+            int extLen = Short.toUnsignedInt(data.getShort());\n+            if (extType == extCode) {\n+                \/\/ Start processing signature algorithms\n+                int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+                for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+                    String schemeName = sigSchemeMap.get(\n+                            Short.toUnsignedInt(data.getShort()));\n+                    if (schemeName != null) {\n+                        extSigAlgs.add(schemeName);\n+                    }\n+                }\n+            } else {\n+                \/\/ Not the extension we're looking for.  Skip past the\n+                \/\/ extension data\n+                data.position(data.position() + extLen);\n+            }\n+        }\n+\n+        return extSigAlgs;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/AbstractCheckSignatureSchemes.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers DTLS 1.2.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeDTLS12\n+ *\/\n+\n+import java.security.Security;\n+\n+public class DisableSignatureSchemePerScopeDTLS12\n+        extends DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableSignatureSchemePerScopeDTLS12() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeDTLS12().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"DTLSv1.2\";\n+    }\n+\n+    \/\/ No CertificateRequest in DTLS server flight.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeDTLS12.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers TLS 1.2.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeTLS12\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+public class DisableSignatureSchemePerScopeTLS12 extends\n+        AbstractCheckSignatureSchemes {\n+\n+    \/\/ Disabled for Handshake scope.\n+    protected static final String HANDSHAKE_DISABLED_SIG = \"rsa_pss_rsae_sha384\";\n+\n+    \/\/ Disabled for Certificate scope.\n+    protected static final String CERTIFICATE_DISABLED_SIG = \"ecdsa_secp384r1_sha384\";\n+\n+    \/\/ jdk.tls.disabledAlgorithms value\n+    \/\/ We differ from \"HandshakeSignature\" and \"CertificateSignature\" specified\n+    \/\/ in java.security to check case-insensitive matching.\n+    protected static final String DISABLED_CONSTRAINTS =\n+            HANDSHAKE_DISABLED_SIG + \" usage HandShakesignature, \"\n+            + CERTIFICATE_DISABLED_SIG + \" usage certificateSignature\";\n+\n+    protected DisableSignatureSchemePerScopeTLS12() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeTLS12().run();\n+    }\n+\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n+    \/\/ Run things in TLS handshake order.\n+    protected void run() throws Exception {\n+\n+        \/\/ Produce client_hello\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n+\n+        checkClientHello();\n+\n+        \/\/ Consume client_hello.\n+        serverEngine.unwrap(cTOs, serverIn);\n+        runDelegatedTasks(serverEngine);\n+\n+        \/\/ Produce server_hello.\n+        serverEngine.wrap(serverOut, sTOc);\n+        sTOc.flip();\n+\n+        checkCertificateRequest();\n+    }\n+\n+    protected void checkClientHello() throws Exception {\n+        \/\/ --- Check signature_algorithms extension ---\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ handshake signature scheme.\n+        assertFalse(sigAlgsSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms extension MUST contain disabled\n+        \/\/ certificate signature scheme.\n+        assertTrue(sigAlgsSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" isn't present in ClientHello's\"\n+                + \" signature_algorithms extension\");\n+\n+        \/\/ --- Check signature_algorithms_cert extension ---\n+\n+        \/\/ Get signature_algorithms_cert extension signature schemes.\n+        List<String> sigAlgsCertSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_CERT_EXT);\n+\n+        \/\/ signature_algorithms_cert extension MUST contain disabled\n+        \/\/ handshake signature scheme.\n+        assertTrue(sigAlgsCertSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" isn't present in ClientHello's\"\n+                + \" signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms_cert extension MUST NOT contain disabled\n+        \/\/ certificate signature scheme.\n+        assertFalse(sigAlgsCertSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+    }\n+\n+    protected void checkCertificateRequest() throws Exception {\n+        \/\/ Get CertificateRequest message signature schemes.\n+        List<String> sigAlgsCertSS = getSigSchemesCertReq(\n+                extractHandshakeMsg(sTOc, TLS_HS_CERT_REQ));\n+\n+        \/\/ TLSv1.2 CertificateRequest message MUST NOT contain both:\n+        \/\/ disabled handshake signature scheme and disabled\n+        \/\/ certificate signature scheme\n+\n+        assertFalse(sigAlgsCertSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" present in CertificateRequest\");\n+\n+        assertFalse(sigAlgsCertSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" present in CertificateRequest\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers TLS 1.3.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeTLS13\n+ *\/\n+\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+public class DisableSignatureSchemePerScopeTLS13\n+        extends DisableSignatureSchemePerScopeTLS12 {\n+\n+    \/\/ Signature schemes not supported in TLSv1.3 only for the handshake.\n+    \/\/ This is regardless of jdk.tls.disabledAlgorithms configuration.\n+    List<String> NOT_SUPPORTED_FOR_HANDSHAKE = List.of(\n+            \"rsa_pkcs1_sha1\",\n+            \"rsa_pkcs1_sha256\",\n+            \"rsa_pkcs1_sha384\",\n+            \"rsa_pkcs1_sha512\"\n+    );\n+\n+    protected DisableSignatureSchemePerScopeTLS13() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeTLS13().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"TLSv1.3\";\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        super.checkClientHello();\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ Should not be present in signature_algorithms extension.\n+        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n+                assertFalse(sigAlgsSS.contains(ss),\n+                        \"Signature Scheme \" + ss\n+                        + \" present in ClientHello's signature_algorithms extension\"));\n+\n+        \/\/ Get signature_algorithms_cert extension signature schemes.\n+        List<String> sigAlgsCertSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_CERT_EXT);\n+\n+        \/\/ Should be present in signature_algorithms_cert extension.\n+        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n+                assertTrue(sigAlgsCertSS.contains(ss),\n+                        \"Signature Scheme \" + ss\n+                        + \" isn't present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n+    }\n+\n+    \/\/ TLSv1.3 sends CertificateRequest signature schemes in\n+    \/\/ signature_algorithms and signature_algorithms_cert extensions. Same as\n+    \/\/ ClientHello, but they are encrypted. So we skip CertificateRequest\n+    \/\/ signature schemes verification for TLSv1.3.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS13.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm MixingTLSUsageConstraintsWithNonTLS\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.security.Security;\n+\n+public class MixingTLSUsageConstraintsWithNonTLS extends SSLSocketTemplate {\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                \"rsa_pkcs1_sha1 usage handshakeSignature certificateSignature TLSServer\");\n+\n+        runAndCheckException(\n+                () -> new MixingTLSUsageConstraintsWithNonTLS().run(),\n+                e -> {\n+                    assertTrue(e instanceof ExceptionInInitializerError);\n+                    assertTrue(\n+                            e.getCause() instanceof IllegalArgumentException);\n+                    assertEquals(e.getCause().getMessage(),\n+                            \"Can't mix TLS protocol specific constraints\"\n+                                    + \" with other usage constraints\");\n+                });\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MixingTLSUsageConstraintsWithNonTLS.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,381 @@\n+\/*\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.2.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=true\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+\n+public class SigAlgosExtTestWithTLS12 extends SSLEngineTemplate {\n+\n+    private static final boolean CLIENT_AUTH\n+            = Boolean.getBoolean(\"test.clientAuth\");\n+    private static final boolean EXPECT_FAIL\n+            = Boolean.getBoolean(\"test.expectFail\");\n+\n+    private static final String[] CA_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n+            \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n+            \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n+            \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n+            \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n+            \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n+            \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n+            \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n+            \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n+            \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n+            \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n+            \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n+            \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n+            \"J8FXY9Nj\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_KEYS = new String[] {\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n+            \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n+            \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n+            \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n+            \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"\n+    };\n+\n+    private static final String[] EE_ALGS = new String[] {\n+            \"EC\",\n+            \"EC\"\n+    };\n+\n+    private static final String[] EE_ALIASES = new String[] {\n+            \"EC-SHA256\",\n+            \"EC-SHA384\"\n+    };\n+\n+    private static final Map<Integer, String> SIG_SCHEMES_MAP = Map.of(\n+            0x0403, \"ecdsa_secp256r1_sha256\",\n+            0x0503, \"ecdsa_secp384r1_sha384\");\n+\n+    private static final int TLS_HS_CLI_HELLO = 1;\n+    private static final int TLS_HS_CERT_REQ = 13;\n+    private static final int HELLO_EXT_SIG_ALGS = 13;\n+\n+    public SigAlgosExtTestWithTLS12() throws Exception {\n+        super();\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager for client use.\n+     *\/\n+    public KeyManager createClientKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createClientTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public KeyManager createServerKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createServerTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(CLIENT_AUTH);\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n+        return clientEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+\n+        try {\n+            new SigAlgosExtTestWithTLS12().run();\n+            if (EXPECT_FAIL) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (EXPECT_FAIL && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            clientEngine.wrap(clientOut, cTOs);\n+            cTOs.flip();\n+\n+            \/\/ Consume the ClientHello and get the server flight of handshake\n+            \/\/ messages.  We expect that it will be one TLS record containing\n+            \/\/ multiple handshake messages, one of which is a CertificateRequest\n+            \/\/ when the client authentication is required.\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            \/\/ Wrap the server flight\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+\n+            if (CLIENT_AUTH && EXPECT_FAIL) {\n+                twistCertReqMsg(sTOc);\n+            }\n+\n+            clientEngine.unwrap(sTOc, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                clientEngine.closeOutbound();\n+                dataDone = true;\n+                serverEngine.closeOutbound();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Twists signature schemes in CertificateRequest message for negative\n+     * client authentication cases.\n+     *\n+     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n+     *      that the position of the ByteBuffer is on the first byte of the TLS\n+     *      record header.\n+     *\n+     * @throws SSLException if the incoming ByteBuffer does not contain a\n+     *      well-formed TLS message.\n+     *\/\n+    private static void twistCertReqMsg(\n+            ByteBuffer tlsRecord) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        \/\/ Simple sanity checks\n+        if (type != 22) {\n+            throw new SSLException(\"Not a handshake: Type = \" + type);\n+        } else if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+\n+            if (msgType == TLS_HS_CERT_REQ) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                int bufPos = tlsRecord.position();\n+                ByteBuffer buf = slice(tlsRecord, bufPos, msgLen);\n+\n+                \/\/ Replace the signature scheme with an unknown value\n+                twistSigSchemesCertReq(buf, (short) 0x0000);\n+                byte[] bufBytes = new byte[buf.limit()];\n+                buf.get(bufBytes);\n+                tlsRecord.position(bufPos).put(bufBytes);\n+\n+                break;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+    }\n+\n+    \/**\n+     * Replace the signature schemes in CertificateRequest message with an\n+     * alternative value.  It is assumed that the provided ByteBuffer has its\n+     * position set at the first byte of the CertificateRequest message body\n+     * (AFTER the handshake header) and contains the entire CR message.  Upon\n+     * successful completion of this method the ByteBuffer will have its\n+     * position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the CertificateRequest bytes\n+     * @param altSigScheme an alternative signature scheme\n+     *\/\n+    private static void twistSigSchemesCertReq(ByteBuffer data,\n+                                               Short altSigScheme) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            System.err.println(\n+                    \"Use alternative signature scheme: \" + altSigScheme);\n+            data.putShort(data.position(), altSigScheme);\n+        }\n+\n+        data.reset();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.3, but doesn't cover client authentication.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS13\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS13\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSocket;\n+\n+public class SigAlgosExtTestWithTLS13 extends SSLSocketTemplate {\n+\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getClientContextParameters());\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        socket.setEnabledProtocols(new String[] { \"TLSv1.3\" });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean expectFail = Boolean.getBoolean(\"test.expectFail\");\n+        try {\n+            new SigAlgosExtTestWithTLS13().run();\n+            if (expectFail) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (expectFail && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}