{"files":[{"patch":"@@ -211,0 +211,1 @@\n+    ls.cr();\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    st->print_cr(\"pd set count = #%d\", count);\n+    st->print(\"pd set count = #%d\", count);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+\n@@ -245,3 +246,2 @@\n-    p->set_klass(klass);\n-    p->set_next(bucket(index));\n-    set_entry(index, p);\n+    Hashtable<InstanceKlass*, mtClass>::add_entry(index, p);\n+\n@@ -481,2 +481,1 @@\n-      probe->name()->print_on(st);\n-      st->print(\" , loaders:\");\n+      st->print(\"Symbol: %s loaders:\", probe->name()->as_C_string());\n@@ -484,0 +483,2 @@\n+        st->cr();\n+        st->print(\"    \");\n@@ -485,1 +486,0 @@\n-        st->print(\", \");\n@@ -491,0 +491,2 @@\n+\n+void LoaderConstraintTable::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  void print() const;\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1347,6 +1347,0 @@\n-  \/\/ The following guarantee is meant to ensure that no loader constraints\n-  \/\/ exist yet, since the constraints table is not shared.  This becomes\n-  \/\/ more important now that we don't re-initialize vtables\/itables for\n-  \/\/ shared classes at runtime, where constraints were previously created.\n-  guarantee(SystemDictionary::constraints()->number_of_entries() == 0,\n-            \"loader constraints are not saved\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}