{"files":[{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4423838\n+  @summary KEY_TYPED and KEY_PRESSED generated by the same key are notified to\n+           different TextFields\n+  @key headful\n+  @run main QuickTypeTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.EventQueue;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+import java.util.Properties;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTextField;\n+\n+public class QuickTypeTest {\n+    static final int TEST_TIMEOUT=10000;\n+    static JFrame frame1;\n+    static JFrame frame2;\n+    static JTextField tf1;\n+    static JTextField tf2;\n+    static SmartKeyAdapter ska;\n+    static Object keyMonitor;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame1 = new JFrame(\"First Frame\");\n+                frame2 = new JFrame(\"Second Frame\");\n+                tf1 = new JTextField(\"\", 10);\n+                tf2 = new JTextField(\"\", 10);\n+                frame1.getContentPane().add(tf1);\n+                frame2.getContentPane().add(tf2);\n+                frame1.setLocation(200,220);\n+                frame2.setLocation(220,300);\n+                frame1.pack();\n+                frame2.pack();\n+                keyMonitor = new Object();\n+                ska = new SmartKeyAdapter(frame2, keyMonitor);\n+                tf1.addKeyListener(ska);\n+                frame1.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Object tf1Monitor = new Object();\n+            MonitoredFocusListener monitorer = new MonitoredFocusListener(tf1Monitor);\n+            tf1.addFocusListener(monitorer);\n+            Point origin = tf1.getLocationOnScreen();\n+            Dimension dim = tf1.getSize();\n+            robot.mouseMove((int)origin.getX() + (int)dim.getWidth()\/2,\n+                            (int)origin.getY() + (int)dim.getHeight()\/2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (!tf1.isFocusOwner()) {\n+                synchronized (tf1Monitor) {\n+                    tf1Monitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            if (!tf1.isFocusOwner()) {\n+                throw new RuntimeException(\"TEST FAILED. tf1 doesn't receive focus.\");\n+            }\n+\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.keyPress(KeyEvent.VK_B);\n+            robot.keyRelease(KeyEvent.VK_B);\n+            if (!ska.isFrameShown) {\n+                synchronized (keyMonitor) {\n+                    keyMonitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            if (!ska.isFrameShown) {\n+                throw new RuntimeException(\"TEST FAILED. Second frame is not shown.\");\n+            }\n+\n+            Object waitMonitor = new Object();\n+            ReleaseWaiter waiter = new ReleaseWaiter(waitMonitor, KeyEvent.VK_C);\n+            tf1.addKeyListener(waiter);\n+            tf2.addKeyListener(waiter);\n+            robot.keyPress(KeyEvent.VK_C);\n+            robot.keyRelease(KeyEvent.VK_C);\n+\n+            synchronized (waitMonitor) {\n+                waitMonitor.wait(2000);\n+            }\n+\n+            if ((tf1.getText().length() > 2) || (tf2.getText().length() < 1)) {\n+                System.out.println(\"tf1's text = \\\"\" + tf1.getText() + \"\\\"\");\n+                System.out.println(\"tf2's text = \\\"\" + tf2.getText() + \"\\\"\");\n+                System.out.println(\"l1 = \" + tf1.getText().length());\n+                System.out.println(\"l2 = \" + tf2.getText().length());\n+                throw new RuntimeException(\"TEST FAILED.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame1 != null) {\n+                    frame1.dispose();\n+                }\n+                if (frame2 != null) {\n+                    frame2.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+ }\/\/ class QuickTypeTest\n+\n+class ReleaseWaiter extends KeyAdapter {\n+    Object monitor;\n+    int keycode;\n+    public ReleaseWaiter(Object monitor, int keycode) {\n+        this.monitor = monitor;\n+        this.keycode = keycode;\n+    }\n+\n+    public void keyReleased(KeyEvent ke) {\n+        System.out.println(\"keyReleased \" + ke.getKeyCode());\n+        if (ke.getKeyCode() == keycode) {\n+            synchronized (monitor) {\n+                monitor.notify();\n+            }\n+        }\n+    }\n+}\n+\n+class SmartKeyAdapter implements KeyListener {\n+    JFrame frame;\n+    int charCounter = 0;\n+    boolean isFrameShown = false;\n+    Object monitor;\n+\n+    public SmartKeyAdapter(JFrame frame, Object monitor) {\n+        this.frame = frame;\n+        this.monitor = monitor;\n+    }\n+\n+    public void keyReleased(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+    }\n+    public void keyPressed(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+        charCounter++;\n+        if (charCounter == 2) {\n+            frame.setVisible(true);\n+            isFrameShown = true;\n+            synchronized (monitor) {\n+                monitor.notify();\n+            }\n+        }\n+    }\n+    public void keyTyped(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+    }\n+}\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusLost(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+    }\n+    public void focusGained(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/QuickTypeTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug       5070991\n+  @key headful\n+  @summary   Tests for a transitivity problem with ROW_TOLERANCE in SortingFTP.\n+  @run       main RowToleranceTransitivityTest\n+*\/\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JCheckBox;\n+import javax.swing.JFrame;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class RowToleranceTransitivityTest {\n+    static JFrame frame;\n+    static JPanel panel;\n+    static JFormattedTextField ft;\n+    static JCheckBox cb;\n+    static GridBagConstraints gc;\n+    static Robot robot;\n+\n+    static AtomicBoolean focusGained = new AtomicBoolean(false);\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        robot.setAutoWaitForIdle(true);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                gc = new GridBagConstraints();\n+                frame = new JFrame(\"JFrame\");\n+                JPanel panel = new JPanel(new GridBagLayout());\n+                ft = new JFormattedTextField();\n+                cb = new JCheckBox(\"JCheckBox\");\n+                Dimension dim = new Dimension(100, ft.getPreferredSize().height);\n+                ft.setPreferredSize(dim);\n+                ft.setMinimumSize(dim);\n+                gc.gridx = 5;\n+                gc.gridy = 1;\n+                gc.gridwidth = 10;\n+                panel.add(ft, gc);\n+\n+                gc.gridy = 3;\n+                panel.add(cb, gc);\n+\n+                cb.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent e) {\n+                        System.out.println(e.toString());\n+                        synchronized (focusGained) {\n+                            focusGained.set(true);\n+                            focusGained.notifyAll();\n+                        }\n+                    }\n+                });\n+\n+                gc.weightx = 1.0;\n+                gc.gridwidth = 1;\n+                gc.gridy = 0;\n+                gc.gridx = 0;\n+                for (int n = 0; n < 7; n++) {\n+                    panel.add(getlabel(), gc);\n+                    gc.gridy++;\n+                }\n+\n+                gc.gridx = 0;\n+                gc.gridy = 0;\n+                for (int n = 0; n < 7; n++) {\n+                    panel.add(getlabel(), gc);\n+                    gc.gridx++;\n+                }\n+\n+                frame.getContentPane().add(panel);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                frame.setAlwaysOnTop(true);\n+\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+    static void test() throws Exception {\n+        robot.delay(500);\n+\n+        \/\/ Set focus on the first component to start traversal\n+        if (!setFocusOn(ft, new Runnable() {\n+            public void run() {\n+                clickOn(ft);\n+            }\n+            })) {\n+            System.out.println(\"Couldn't set focus on \" + ft);\n+            throw new RuntimeException(\"Test couldn't be performed.\");\n+        }\n+\n+        robot.delay(500);\n+\n+        \/\/ Try to traverse\n+        if (!setFocusOn(cb, new Runnable() {\n+            public void run() {\n+                robot.keyPress(KeyEvent.VK_TAB);\n+            }\n+            })) {\n+            System.out.println(\"Focus got stuck while traversing.\");\n+            throw new RuntimeException(\"Test failed!\");\n+        }\n+\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    static boolean setFocusOn(Component comp, Runnable action) {\n+\n+        if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() == comp) {\n+            System.out.println(\"Already focus owner: \" + comp);\n+            return true;\n+        }\n+\n+        focusGained.set(false);\n+\n+        System.out.println(\"Setting focus on \" + comp);\n+\n+        comp.addFocusListener(new FocusAdapter() {\n+                public void focusGained(FocusEvent e) {\n+                    System.out.println(e.toString());\n+                    synchronized (focusGained) {\n+                        focusGained.set(true);\n+                        focusGained.notifyAll();\n+                    }\n+                }\n+            });\n+\n+        action.run();\n+\n+        synchronized (focusGained) {\n+            if (!focusGained.get()) {\n+                try {\n+                    focusGained.wait(3000);\n+                } catch (InterruptedException e) {\n+                    System.out.println(\"Unexpected exception caught!\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        return focusGained.get();\n+    }\n+\n+    static JLabel getlabel(){\n+        Dimension dim = new Dimension(5, 9); \/\/ LayoutComparator.ROW_TOLERANCE = 10;\n+        JLabel l = new JLabel(\"*\");\n+        l.setMinimumSize(dim);\n+        l.setMaximumSize(dim);\n+        l.setPreferredSize(dim);\n+        return l;\n+    }\n+\n+    static void clickOn(Component c) {\n+        Point p = c.getLocationOnScreen();\n+        Dimension d = c.getSize();\n+\n+        System.out.println(\"Clicking \" + c);\n+\n+        if (c instanceof Frame) {\n+            robot.mouseMove(p.x + (int)(d.getWidth()\/2), p.y + ((Frame)c).getInsets().top\/2);\n+        } else {\n+            robot.mouseMove(p.x + (int)(d.getWidth()\/2), p.y + (int)(d.getHeight()\/2));\n+        }\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/RowToleranceTransitivityTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4794413\n+ * @summary Tests that access to temporaryLostComponent from two different threads doesn't cause a deadlock\n+ * @key headful\n+ * @run main TemporaryLostComponentDeadlock\n+*\/\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class TemporaryLostComponentDeadlock {\n+    static Dialog frame1;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            frame = new Frame(\"frame\");\n+            frame1 = new Dialog(frame, \"Frame 1\", false);\n+            frame1.add(new Button(\"focus owner\"));\n+            frame1.pack();\n+            frame1.setLocationRelativeTo(null);\n+            frame1.setVisible(true);\n+        });\n+\n+        Thread t1 = new Thread() {\n+            public void run() {\n+                synchronized(frame1) {\n+                    frame1.dispose();\n+                    synchronized(frame1) {\n+                        frame1.notify();\n+                    }\n+                }\n+            }\n+        };\n+        try {\n+            synchronized(frame1) {\n+                t1.start();\n+                frame1.wait();\n+            }\n+        } catch( InterruptedException ie) {\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+}\/\/ class TemporaryLostComponentDeadlock\n","filename":"test\/jdk\/java\/awt\/Focus\/TemporaryLostComponentDeadlock.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4457455\n+  @summary Component and KeyboardFocusManager use wrong names of the properties\n+  @run main TraversalKeysPropertyNamesTest\n+*\/\n+\n+import java.awt.AWTKeyStroke;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n+import java.awt.KeyboardFocusManager;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashSet;\n+\n+public class TraversalKeysPropertyNamesTest implements PropertyChangeListener {\n+    final String[] properties = {\n+        \"forwardDefaultFocusTraversalKeys\",\n+        \"backwardDefaultFocusTraversalKeys\",\n+        \"upCycleDefaultFocusTraversalKeys\",\n+        \"downCycleDefaultFocusTraversalKeys\",\n+        \"forwardFocusTraversalKeys\",\n+        \"backwardFocusTraversalKeys\",\n+        \"upCycleFocusTraversalKeys\",\n+        \"downCycleFocusTraversalKeys\"\n+    };\n+    final int PROPERTIES_COUNT = properties.length;\n+    boolean[] flags = new boolean[PROPERTIES_COUNT];\n+\n+    public static void main(String[] args) throws Exception {\n+        TraversalKeysPropertyNamesTest test = new TraversalKeysPropertyNamesTest();\n+        test.start();\n+    }\n+\n+    public void start() throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Container cont = new Container() {};\n+            HashSet forwardKeys = new HashSet();\n+            forwardKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl A\"));\n+            HashSet backwardKeys = new HashSet();\n+            backwardKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl B\"));\n+            HashSet upKeys = new HashSet();\n+            upKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl C\"));\n+            HashSet downKeys = new HashSet();\n+            downKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl D\"));\n+\n+            KeyboardFocusManager manager =\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+            manager.addPropertyChangeListener(this);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, backwardKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, forwardKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, downKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, upKeys);\n+\n+            cont.addPropertyChangeListener(this);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, backwardKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, forwardKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, downKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, upKeys);\n+\n+            for (int i = 0; i < PROPERTIES_COUNT; i++) {\n+                if (!flags[i]) {\n+                    throw new RuntimeException(\n+                        \"Notification on \"+properties[i]+\" change was not received\");\n+                }\n+            }\n+        });\n+    }\/\/ start()\n+\n+    public void propertyChange(PropertyChangeEvent pce) {\n+        String property = pce.getPropertyName();\n+        System.err.println(property);\n+        int index;\n+        for (index = 0; index < PROPERTIES_COUNT; index++) {\n+            if (property.equals(properties[index])) {\n+                break;\n+            }\n+        }\n+\n+        if (index < PROPERTIES_COUNT) {\n+            flags[index] = true;\n+        }\n+    }\n+ }\/\/ class TraversalKeysPropertyNamesTest\n","filename":"test\/jdk\/java\/awt\/Focus\/TraversalKeysPropertyNamesTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4394789\n+  @summary KeyboardFocusManager.upFocusCycle is not working for Swing properly\n+  @key headful\n+  @run main UpFocusCycleTest\n+*\/\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Color;\n+import java.awt.DefaultKeyboardFocusManager;\n+import java.awt.EventQueue;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.Robot;\n+import javax.swing.DefaultFocusManager;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+\n+public class UpFocusCycleTest {\n+    static boolean isFailed = true;\n+    static Object sema = new Object();\n+    static JFrame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeAndWait(() -> {\n+\n+                frame = new JFrame(\"Test frame\");\n+\n+                Container container1 = frame.getContentPane();\n+                container1.setBackground(Color.yellow);\n+\n+                JButton button = new JButton(\"Button\");\n+                button.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent fe) {\n+                        DefaultKeyboardFocusManager manager = new DefaultFocusManager();\n+                        manager.upFocusCycle(button);\n+                        System.out.println(\"Button receive focus\");\n+                        frame.addFocusListener(new FocusAdapter() {\n+                            public void focusGained(FocusEvent fe) {\n+                                System.out.println(\"Frame receive focus\");\n+                                synchronized (sema) {\n+                                    isFailed = false;\n+                                    sema.notifyAll();\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+                container1.add(button,BorderLayout.WEST);\n+                button.requestFocus();\n+                frame.setSize(300,300);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (isFailed) {\n+                System.out.println(\"Test FAILED\");\n+                throw new RuntimeException(\"Test FAILED\");\n+            } else {\n+                System.out.println(\"Test PASSED\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+ }\/\/ class UpFocusCycleTest\n","filename":"test\/jdk\/java\/awt\/Focus\/UpFocusCycleTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug        5074189\n+  @summary    Tests that VetoableChangeListener doesn't initiate infinite loop.\n+  @key headful\n+  @run main VetoableChangeListenerLoopTest\n+*\/\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.WindowEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyVetoException;\n+import java.beans.VetoableChangeListener;\n+\n+public class VetoableChangeListenerLoopTest {\n+    static Button b1;\n+    static Button b2;\n+    static Frame frame;\n+    static Robot robot;\n+\n+    static int counter = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(() -> {\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                    addVetoableChangeListener(new VetoableChangeListener () {\n+                        public void vetoableChange(PropertyChangeEvent evt)\n+                                               throws PropertyVetoException {\n+                            if (b1.equals(evt.getNewValue())) {\n+                                System.out.println(\"VETOING: \" + (counter++));\n+                                if (counter > 2) {\n+                                    throw new RuntimeException(\"Test failed!\");\n+                                }\n+                                throw new PropertyVetoException(\"Change in property\", evt);\n+                            }\n+                        }\n+                    });\n+\n+                Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n+                    public void eventDispatched(AWTEvent e) {\n+                        System.out.println(e.toString());\n+                    }\n+                }, FocusEvent.FOCUS_EVENT_MASK | WindowEvent.WINDOW_FOCUS_EVENT_MASK);\n+\n+                b1 = new Button(\"Button 1\");\n+                b2 = new Button(\"Button 2\");\n+                Frame frame = new Frame();\n+                frame.add(b1);\n+                frame.add(b2);\n+                frame.setSize(200, 100);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+    static void test() {\n+        b2.requestFocusInWindow();\n+        waitTillFocus(b2);\n+        b2.setVisible(false);\n+    }\n+\n+\n+    static void waitTillFocus(Component comp) {\n+        while (!checkFocusOwner(comp)) {\n+            robot.delay(100);\n+        }\n+    }\n+\n+    static boolean checkFocusOwner(Component comp) {\n+        return (comp == KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner());\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/VetoableChangeListenerLoopTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}