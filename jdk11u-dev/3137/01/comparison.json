{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=11.0.30\n+version=11.0.31\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=30\n+DEFAULT_VERSION_UPDATE=31\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2026-01-20\n+DEFAULT_VERSION_DATE=2026-04-21\n@@ -40,1 +40,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/autoconf\/version-numbers","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2371,210 +2371,0 @@\n-\/\/ Look at the method's handlers.  If the bci is in the handler's try block\n-\/\/ then check if the handler_pc is already on the stack.  If not, push it\n-\/\/ unless the handler has already been scanned.\n-void ClassVerifier::push_handlers(ExceptionTable* exhandlers,\n-                                  GrowableArray<u4>* handler_list,\n-                                  GrowableArray<u4>* handler_stack,\n-                                  u4 bci) {\n-  int exlength = exhandlers->length();\n-  for(int x = 0; x < exlength; x++) {\n-    if (bci >= exhandlers->start_pc(x) && bci < exhandlers->end_pc(x)) {\n-      u4 exhandler_pc = exhandlers->handler_pc(x);\n-      if (!handler_list->contains(exhandler_pc)) {\n-        handler_stack->append_if_missing(exhandler_pc);\n-        handler_list->append(exhandler_pc);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Return TRUE if all code paths starting with start_bc_offset end in\n-\/\/ bytecode athrow or loop.\n-bool ClassVerifier::ends_in_athrow(u4 start_bc_offset) {\n-  ResourceMark rm;\n-  \/\/ Create bytecode stream.\n-  RawBytecodeStream bcs(method());\n-  u4 code_length = method()->code_size();\n-  bcs.set_start(start_bc_offset);\n-  u4 target;\n-  \/\/ Create stack for storing bytecode start offsets for if* and *switch.\n-  GrowableArray<u4>* bci_stack = new GrowableArray<u4>(30);\n-  \/\/ Create stack for handlers for try blocks containing this handler.\n-  GrowableArray<u4>* handler_stack = new GrowableArray<u4>(30);\n-  \/\/ Create list of handlers that have been pushed onto the handler_stack\n-  \/\/ so that handlers embedded inside of their own TRY blocks only get\n-  \/\/ scanned once.\n-  GrowableArray<u4>* handler_list = new GrowableArray<u4>(30);\n-  \/\/ Create list of visited branch opcodes (goto* and if*).\n-  GrowableArray<u4>* visited_branches = new GrowableArray<u4>(30);\n-  ExceptionTable exhandlers(_method());\n-\n-  while (true) {\n-    if (bcs.is_last_bytecode()) {\n-      \/\/ if no more starting offsets to parse or if at the end of the\n-      \/\/ method then return false.\n-      if ((bci_stack->is_empty()) || ((u4)bcs.end_bci() == code_length))\n-        return false;\n-      \/\/ Pop a bytecode starting offset and scan from there.\n-      bcs.set_start(bci_stack->pop());\n-    }\n-    Bytecodes::Code opcode = bcs.raw_next();\n-    u4 bci = bcs.bci();\n-\n-    \/\/ If the bytecode is in a TRY block, push its handlers so they\n-    \/\/ will get parsed.\n-    push_handlers(&exhandlers, handler_list, handler_stack, bci);\n-\n-    switch (opcode) {\n-      case Bytecodes::_if_icmpeq:\n-      case Bytecodes::_if_icmpne:\n-      case Bytecodes::_if_icmplt:\n-      case Bytecodes::_if_icmpge:\n-      case Bytecodes::_if_icmpgt:\n-      case Bytecodes::_if_icmple:\n-      case Bytecodes::_ifeq:\n-      case Bytecodes::_ifne:\n-      case Bytecodes::_iflt:\n-      case Bytecodes::_ifge:\n-      case Bytecodes::_ifgt:\n-      case Bytecodes::_ifle:\n-      case Bytecodes::_if_acmpeq:\n-      case Bytecodes::_if_acmpne:\n-      case Bytecodes::_ifnull:\n-      case Bytecodes::_ifnonnull:\n-        target = bcs.dest();\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode starting offset and scan from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target > bci) { \/\/ forward branch\n-            if (target >= code_length) return false;\n-            \/\/ Push the branch target onto the stack.\n-            bci_stack->push(target);\n-            \/\/ then, scan bytecodes starting with next.\n-            bcs.set_start(bcs.next_bci());\n-          } else { \/\/ backward branch\n-            \/\/ Push bytecode offset following backward branch onto the stack.\n-            bci_stack->push(bcs.next_bci());\n-            \/\/ Check bytecodes starting with branch target.\n-            bcs.set_start(target);\n-          }\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-\n-      case Bytecodes::_goto:\n-      case Bytecodes::_goto_w: {\n-        int offset = (opcode == Bytecodes::_goto ? bcs.get_offset_s2() : bcs.get_offset_s4());\n-        int min_offset = -1 * max_method_code_size;\n-        \/\/ Check offset for overflow\n-        if (offset < min_offset || offset > max_method_code_size) return false;\n-\n-        target = bci + offset;\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Been here before, pop new starting offset from stack.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target >= code_length) return false;\n-          \/\/ Continue scanning from the target onward.\n-          bcs.set_start(target);\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-        }\n-\n-      \/\/ Check that all switch alternatives end in 'athrow' bytecodes. Since it\n-      \/\/ is  difficult to determine where each switch alternative ends, parse\n-      \/\/ each switch alternative until either hit a 'return', 'athrow', or reach\n-      \/\/ the end of the method's bytecodes.  This is gross but should be okay\n-      \/\/ because:\n-      \/\/ 1. tableswitch and lookupswitch byte codes in handlers for ctor explicit\n-      \/\/    constructor invocations should be rare.\n-      \/\/ 2. if each switch alternative ends in an athrow then the parsing should be\n-      \/\/    short.  If there is no athrow then it is bogus code, anyway.\n-      case Bytecodes::_lookupswitch:\n-      case Bytecodes::_tableswitch:\n-        {\n-          address aligned_bcp = align_up(bcs.bcp() + 1, jintSize);\n-          u4 default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;\n-          int keys, delta;\n-          if (opcode == Bytecodes::_tableswitch) {\n-            jint low = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            jint high = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n-            \/\/ This is invalid, but let the regular bytecode verifier\n-            \/\/ report this because the user will get a better error message.\n-            if (low > high) return true;\n-            keys = high - low + 1;\n-            delta = 1;\n-          } else {\n-            keys = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            delta = 2;\n-          }\n-          \/\/ Invalid, let the regular bytecode verifier deal with it.\n-          if (keys < 0) return true;\n-\n-          \/\/ Push the offset of the next bytecode onto the stack.\n-          bci_stack->push(bcs.next_bci());\n-\n-          \/\/ Push the switch alternatives onto the stack.\n-          for (int i = 0; i < keys; i++) {\n-            int min_offset = -1 * max_method_code_size;\n-            int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n-            if (offset < min_offset || offset > max_method_code_size) return false;\n-            u4 target = bci + offset;\n-            if (target > code_length) return false;\n-            bci_stack->push(target);\n-          }\n-\n-          \/\/ Start bytecode parsing for the switch at the default alternative.\n-          if (default_offset > code_length) return false;\n-          bcs.set_start(default_offset);\n-          break;\n-        }\n-\n-      case Bytecodes::_return:\n-        return false;\n-\n-      case Bytecodes::_athrow:\n-        {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode offset and starting scanning from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        }\n-        break;\n-\n-      default:\n-        ;\n-    } \/\/ end switch\n-  } \/\/ end while loop\n-\n-  return false;\n-}\n-\n@@ -2605,19 +2395,0 @@\n-      ExceptionTable exhandlers(_method());\n-      int exlength = exhandlers.length();\n-      for(int i = 0; i < exlength; i++) {\n-        u2 start_pc = exhandlers.start_pc(i);\n-        u2 end_pc = exhandlers.end_pc(i);\n-\n-        if (bci >= start_pc && bci < end_pc) {\n-          if (!ends_in_athrow(exhandlers.handler_pc(i))) {\n-            verify_error(ErrorContext::bad_code(bci),\n-              \"Bad <init> method call from after the start of a try block\");\n-            return;\n-          } else if (log_is_enabled(Info, verification)) {\n-            ResourceMark rm(THREAD);\n-            log_info(verification)(\"Survived call to ends_in_athrow(): %s\",\n-                                          current_class()->name()->as_C_string());\n-          }\n-        }\n-      }\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":0,"deletions":229,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,11 +311,0 @@\n-  \/\/ Used by ends_in_athrow() to push all handlers that contain bci onto the\n-  \/\/ handler_stack, if the handler has not already been pushed on the stack.\n-  void push_handlers(ExceptionTable* exhandlers,\n-                     GrowableArray<u4>* handler_list,\n-                     GrowableArray<u4>* handler_stack,\n-                     u4 bci);\n-\n-  \/\/ Returns true if all paths starting with start_bc_offset end in athrow\n-  \/\/ bytecode or loop.\n-  bool ends_in_athrow(u4 start_bc_offset);\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,0 +418,1 @@\n+        ResourceMark rm(THREAD);\n@@ -426,0 +427,1 @@\n+      ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -709,6 +709,8 @@\n-            List<SignatureScheme> sss = new LinkedList<>();\n-            for (int id : crm.algorithmIds) {\n-                SignatureScheme ss = SignatureScheme.valueOf(id);\n-                if (ss != null) {\n-                    sss.add(ss);\n-                }\n+            List<SignatureScheme> sss =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc.sslConfig,\n+                            chc.algorithmConstraints, chc.negotiatedProtocol,\n+                            crm.algorithmIds);\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n@@ -716,0 +718,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -284,0 +284,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n@@ -335,1 +339,1 @@\n-                    \"received CertificateRequest handshake message\");\n+                    \"received ClientHello handshake message\");\n@@ -519,0 +523,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build sun.hotspot.WhiteBox SurvivorAlignmentTestMain AlignmentHelper\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -38,1 +39,0 @@\n-import java.security.NoSuchAlgorithmException;\n@@ -48,0 +48,9 @@\n+\/*\n+ * This test verifies that setEnabledProtocols() does not override the\n+ * jdk.tls.disabledAlgorithms property. Both the client and server throw\n+ * an exception when creating a handshake context.\n+ *\n+ * In the TLSWontNegotiateDisabledCipherAlgoos test, one side of the connection\n+ * disables the cipher suites and the other side enables them and verifies\n+ * that the handshake cannot complete successfully.\n+ *\/\n@@ -50,12 +59,7 @@\n-    private static final String pathToStores = \"..\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String passwd = \"passphrase\";\n-\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+    public static final SSLContextTemplate.Cert[] CERTIFICATES = {\n+            SSLContextTemplate.Cert.EE_DSA_SHA1_1024,\n+            SSLContextTemplate.Cert.EE_DSA_SHA224_1024,\n+            SSLContextTemplate.Cert.EE_DSA_SHA256_1024,\n+            SSLContextTemplate.Cert.CA_ECDSA_SECP256R1,\n+            SSLContextTemplate.Cert.CA_RSA_2048\n+    };\n@@ -123,5 +127,0 @@\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n@@ -135,1 +134,1 @@\n-                checkFailure(disabled_ciphersuites);\n+                checkFailure(DISABLED_CIPHERSUITES);\n@@ -145,1 +144,1 @@\n-                checkSuccess(disabled_ciphersuites);\n+                checkSuccess(DISABLED_CIPHERSUITES);\n@@ -158,1 +157,1 @@\n-        try (SSLServer server = SSLServer.init(ciphersuites)) {\n+        try (SSLServer server = new SSLServer(ciphersuites)) {\n@@ -166,1 +165,1 @@\n-                try (SSLClient client = SSLClient.init(port, ciphersuite)) {\n+                try (SSLClient client = new SSLClient(port, ciphersuite)) {\n@@ -193,1 +192,1 @@\n-        try (SSLServer server = SSLServer.init(ciphersuites)) {\n+        try (SSLServer server = new SSLServer(ciphersuites)) {\n@@ -201,1 +200,1 @@\n-                try (SSLClient client = SSLClient.init(port, ciphersuite)) {\n+                try (SSLClient client = new SSLClient(port, ciphersuite)) {\n@@ -240,1 +239,2 @@\n-    static class SSLServer implements Runnable, AutoCloseable {\n+    static class SSLServer extends SSLContextTemplate implements Runnable, AutoCloseable {\n+\n@@ -248,1 +248,13 @@\n-        private SSLServer(SSLServerSocket ssocket) {\n+        private SSLServer(String[] ciphersuites) throws Exception {\n+            SSLContext context = createSSLContext(null,\n+                    DisabledAlgorithms.CERTIFICATES, getServerContextParameters());\n+            SSLServerSocketFactory ssf = context.getServerSocketFactory();\n+            SSLServerSocket ssocket = (SSLServerSocket)\n+                    ssf.createServerSocket(0);\n+\n+            if (ciphersuites != null) {\n+                System.out.println(\"Server: enable cipher suites: \"\n+                        + java.util.Arrays.toString(ciphersuites));\n+                ssocket.setEnabledCipherSuites(ciphersuites);\n+            }\n+\n@@ -282,2 +294,2 @@\n-                                    + \"because socket was closed, \"\n-                                    + \"please ignore it\");\n+                                + \"because socket was closed, \"\n+                                + \"please ignore it\");\n@@ -328,16 +340,0 @@\n-\n-        static SSLServer init(String[] ciphersuites)\n-                throws IOException {\n-            SSLServerSocketFactory ssf = (SSLServerSocketFactory)\n-                    SSLServerSocketFactory.getDefault();\n-            SSLServerSocket ssocket = (SSLServerSocket)\n-                    ssf.createServerSocket(0);\n-\n-            if (ciphersuites != null) {\n-                System.out.println(\"Server: enable cipher suites: \"\n-                        + java.util.Arrays.toString(ciphersuites));\n-                ssocket.setEnabledCipherSuites(ciphersuites);\n-            }\n-\n-            return new SSLServer(ssocket);\n-        }\n@@ -346,1 +342,1 @@\n-    static class SSLClient implements AutoCloseable {\n+    static class SSLClient extends SSLContextTemplate implements AutoCloseable {\n@@ -350,1 +346,11 @@\n-        private SSLClient(SSLSocket socket) {\n+        private SSLClient(int port, String ciphersuite) throws Exception {\n+            SSLContext context = createSSLContext(DisabledAlgorithms.CERTIFICATES,\n+                    null, getClientContextParameters());\n+            SSLSocketFactory ssf = context.getSocketFactory();\n+            SSLSocket socket = (SSLSocket) ssf.createSocket(\"localhost\", port);\n+\n+            if (ciphersuite != null) {\n+                System.out.println(\"Client: enable cipher suite: \"\n+                        + ciphersuite);\n+                socket.setEnabledCipherSuites(new String[]{ciphersuite});\n+            }\n@@ -390,22 +396,0 @@\n-\n-        static SSLClient init(int port)\n-                throws NoSuchAlgorithmException, IOException {\n-            return init(port, null);\n-        }\n-\n-        static SSLClient init(int port, String ciphersuite)\n-                throws NoSuchAlgorithmException, IOException {\n-            SSLContext context = SSLContext.getDefault();\n-            SSLSocketFactory ssf = (SSLSocketFactory)\n-                    context.getSocketFactory();\n-            SSLSocket socket = (SSLSocket) ssf.createSocket(\"localhost\", port);\n-\n-            if (ciphersuite != null) {\n-                System.out.println(\"Client: enable cipher suite: \"\n-                        + ciphersuite);\n-                socket.setEnabledCipherSuites(new String[] { ciphersuite });\n-            }\n-\n-            return new SSLClient(socket);\n-        }\n-\n@@ -413,2 +397,0 @@\n-\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/DisabledAlgorithms.java","additions":52,"deletions":70,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.security.Security;\n+import java.util.List;\n+\n+\/*\n+ * @test id=Server\n+ * @bug 8301379\n+ * @summary Verify that Java will not negotiate disabled cipher suites when the\n+ * other side of the connection requests them.\n+ *\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm TLSWontNegotiateDisabledCipherAlgos server true\n+ *\/\n+\n+\/*\n+ * @test id=Client\n+ * @bug 8301379\n+ * @summary Verify that Java will not negotiate disabled cipher suites when the\n+ * other side of the connection requests them.\n+ *\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm TLSWontNegotiateDisabledCipherAlgos server false\n+ *\/\n+\n+\n+public class TLSWontNegotiateDisabledCipherAlgos {\n+\n+    public static void main(String [] args) throws Exception {\n+        boolean useDisabledAlgo = Boolean.parseBoolean(args[1]);\n+        if (useDisabledAlgo) {\n+            Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+        }\n+\n+        if (args[0].equals(\"server\")) {\n+            try (TLSServer server = new TLSServer(useDisabledAlgo)) {\n+                List<String> command = List.of(\n+                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n+                        \"TLSWontNegotiateDisabledCipherAlgos\",\n+                        \"client\",\n+                        Boolean.toString(!useDisabledAlgo),\n+                        Integer.toString(server.getListeningPort())\n+                );\n+                ProcessBuilder builder = new ProcessBuilder(command);\n+                Process p = builder.inheritIO().start();\n+                server.run();\n+                p.destroy();\n+            }\n+        } else if (args[0].equals(\"client\")) {\n+            try (TLSClient client = new TLSClient(Integer.parseInt(args[2]), useDisabledAlgo)) {\n+                client.run();\n+            }\n+        }\n+    }\n+\n+    private static class TLSClient extends SSLContextTemplate implements AutoCloseable {\n+        private final SSLSocket socket;\n+\n+        public TLSClient(int portNumber, boolean useDisableAlgo) throws Exception {\n+            SSLContext context = createClientSSLContext();\n+            socket = (SSLSocket)context.getSocketFactory().createSocket(\"localhost\", portNumber);\n+            if (useDisableAlgo) {\n+                socket.setEnabledCipherSuites(DisabledAlgorithms.DISABLED_CIPHERSUITES);\n+            }\n+        }\n+\n+        public void run() throws IOException {\n+            try {\n+                socket.getOutputStream().write(\"SECRET MESSAGE\".getBytes(StandardCharsets.UTF_8));\n+                throw new RuntimeException(\"SSL handshake completed successfully.\");\n+            } catch (SSLHandshakeException exc) {\n+                if (!exc.getMessage().equals(\"Received fatal alert: handshake_failure\")) {\n+                    throw new RuntimeException(\"Expected handshake_failure message. Got: \"\n+                            + \"\\\"\" + exc.getMessage() + \"\\\" message.\", exc);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            socket.close();\n+        }\n+    }\n+\n+    private static class TLSServer extends SSLContextTemplate implements AutoCloseable {\n+        private SSLServerSocket serverSocket;\n+\n+        public TLSServer(boolean useDisableAlgo) throws Exception {\n+            SSLContext ctx = createServerSSLContext();\n+            serverSocket = (SSLServerSocket) ctx.getServerSocketFactory().createServerSocket(0);\n+            if (useDisableAlgo) {\n+                serverSocket.setEnabledCipherSuites(DisabledAlgorithms.DISABLED_CIPHERSUITES);\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            serverSocket.close();\n+        }\n+\n+        public int getListeningPort() {\n+            return serverSocket.getLocalPort();\n+        }\n+\n+        public void run() throws IOException {\n+            try (Socket clientSocket = serverSocket.accept()) {\n+                try {\n+                    byte[] bytes = clientSocket.getInputStream().readAllBytes();\n+                    throw new RuntimeException(\"The expected SSLHandshakeException was not thrown.\");\n+                } catch (SSLHandshakeException exc) {\n+                    if (!exc.getMessage().contains(\"no cipher suites in common\")) {\n+                        throw exc;\n+                    } else {\n+                        System.out.println(\"Success: The connection could not be negotiated (as expected.)\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/TLSWontNegotiateDisabledCipherAlgos.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +481,1 @@\n-    private KeyManager createKeyManager(\n+    static KeyManager createKeyManager(\n@@ -537,1 +537,1 @@\n-    private TrustManager createTrustManager(\n+    static TrustManager createTrustManager(\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    private static boolean isOpen(SSLEngine engine) {\n+    static boolean isOpen(SSLEngine engine) {\n@@ -243,1 +243,1 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.2.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=true\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+\n+public class SigAlgosExtTestWithTLS12 extends SSLEngineTemplate {\n+\n+    private static final boolean CLIENT_AUTH\n+            = Boolean.getBoolean(\"test.clientAuth\");\n+    private static final boolean EXPECT_FAIL\n+            = Boolean.getBoolean(\"test.expectFail\");\n+\n+    private static final String[] CA_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n+            \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n+            \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n+            \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n+            \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n+            \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n+            \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n+            \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n+            \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n+            \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n+            \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n+            \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n+            \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n+            \"J8FXY9Nj\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_KEYS = new String[] {\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n+            \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n+            \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n+            \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n+            \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"\n+    };\n+\n+    private static final String[] EE_ALGS = new String[] {\n+            \"EC\",\n+            \"EC\"\n+    };\n+\n+    private static final String[] EE_ALIASES = new String[] {\n+            \"EC-SHA256\",\n+            \"EC-SHA384\"\n+    };\n+\n+    private static final Map<Integer, String> SIG_SCHEMES_MAP = Map.of(\n+            0x0403, \"ecdsa_secp256r1_sha256\",\n+            0x0503, \"ecdsa_secp384r1_sha384\");\n+\n+    private static final int TLS_HS_CLI_HELLO = 1;\n+    private static final int TLS_HS_CERT_REQ = 13;\n+    private static final int HELLO_EXT_SIG_ALGS = 13;\n+\n+    public SigAlgosExtTestWithTLS12() throws Exception {\n+        super();\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager for client use.\n+     *\/\n+    public KeyManager createClientKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createClientTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public KeyManager createServerKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createServerTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(CLIENT_AUTH);\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n+        return clientEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+\n+        try {\n+            new SigAlgosExtTestWithTLS12().run();\n+            if (EXPECT_FAIL) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (EXPECT_FAIL && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            clientEngine.wrap(clientOut, cTOs);\n+            cTOs.flip();\n+\n+            \/\/ Consume the ClientHello and get the server flight of handshake\n+            \/\/ messages.  We expect that it will be one TLS record containing\n+            \/\/ multiple handshake messages, one of which is a CertificateRequest\n+            \/\/ when the client authentication is required.\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            \/\/ Wrap the server flight\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+\n+            if (CLIENT_AUTH && EXPECT_FAIL) {\n+                twistCertReqMsg(sTOc);\n+            }\n+\n+            clientEngine.unwrap(sTOc, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                clientEngine.closeOutbound();\n+                dataDone = true;\n+                serverEngine.closeOutbound();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Twists signature schemes in CertificateRequest message for negative\n+     * client authentication cases.\n+     *\n+     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n+     *      that the position of the ByteBuffer is on the first byte of the TLS\n+     *      record header.\n+     *\n+     * @throws SSLException if the incoming ByteBuffer does not contain a\n+     *      well-formed TLS message.\n+     *\/\n+    private static void twistCertReqMsg(\n+            ByteBuffer tlsRecord) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        \/\/ Simple sanity checks\n+        if (type != 22) {\n+            throw new SSLException(\"Not a handshake: Type = \" + type);\n+        } else if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+\n+            if (msgType == TLS_HS_CERT_REQ) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                int bufPos = tlsRecord.position();\n+                ByteBuffer buf = slice(tlsRecord, bufPos, msgLen);\n+\n+                \/\/ Replace the signature scheme with an unknown value\n+                twistSigSchemesCertReq(buf, (short) 0x0000);\n+                byte[] bufBytes = new byte[buf.limit()];\n+                buf.get(bufBytes);\n+                tlsRecord.position(bufPos).put(bufBytes);\n+\n+                break;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+    }\n+\n+    \/* Implementation of ByteBuffer.slice(int, int) for JDK11 *\/\n+    private static final ByteBuffer slice(ByteBuffer buffer, int index, int length) {\n+        final int limit = buffer.limit();\n+        final int position = buffer.position();\n+        buffer.position(index);\n+        buffer.limit(index + length);\n+        ByteBuffer slice = buffer.slice();\n+        buffer.limit(limit);\n+        buffer.position(position);\n+        return slice;\n+    }\n+\n+    \/**\n+     * Replace the signature schemes in CertificateRequest message with an\n+     * alternative value.  It is assumed that the provided ByteBuffer has its\n+     * position set at the first byte of the CertificateRequest message body\n+     * (AFTER the handshake header) and contains the entire CR message.  Upon\n+     * successful completion of this method the ByteBuffer will have its\n+     * position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the CertificateRequest bytes\n+     * @param altSigScheme an alternative signature scheme\n+     *\/\n+    private static void twistSigSchemesCertReq(ByteBuffer data,\n+                                               Short altSigScheme) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            System.err.println(\n+                    \"Use alternative signature scheme: \" + altSigScheme);\n+            data.putShort(data.position(), altSigScheme);\n+        }\n+\n+        data.reset();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (C) 2021, Tencent. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.3, but doesn't cover client authentication.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS13\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS13\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSocket;\n+\n+public class SigAlgosExtTestWithTLS13 extends SSLSocketTemplate {\n+\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getClientContextParameters());\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        socket.setEnabledProtocols(new String[] { \"TLSv1.3\" });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean expectFail = Boolean.getBoolean(\"test.expectFail\");\n+        try {\n+            new SigAlgosExtTestWithTLS13().run();\n+            if (expectFail) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (expectFail && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,1 +451,1 @@\n-        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+        if (newVal < oldVal) {\n@@ -456,1 +457,1 @@\n-        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+        if (newVal < oldVal) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}