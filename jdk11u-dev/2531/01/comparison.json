{"files":[{"patch":"@@ -95,3 +95,1 @@\n-        URI uri = req.uri();\n-        InetSocketAddress proxy = req.proxy();\n-        String key = Http2Connection.keyFor(uri, proxy);\n+        String key = Http2Connection.keyFor(req);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-             keyFor(request.uri(), request.proxy()));\n+             keyFor(request));\n@@ -523,6 +523,5 @@\n-    static String keyFor(URI uri, InetSocketAddress proxy) {\n-        boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n-\n-        String host = uri.getHost();\n-        int port = uri.getPort();\n-        return keyString(isSecure, proxy, host, port);\n+    static String keyFor(final HttpRequestImpl request) {\n+        final InetSocketAddress targetAddr = request.getAddress();\n+        final InetSocketAddress proxy = request.proxy();\n+        final boolean secure = request.secure();\n+        return keyString(secure, proxy, targetAddr.getHostString(), targetAddr.getPort());\n@@ -531,1 +530,0 @@\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,1 @@\n+        public abstract InetSocketAddress getRemoteAddress();\n@@ -267,0 +268,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n@@ -322,0 +329,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.net.URISyntaxException;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.testlibrary.SimpleSSLContext;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.Assume;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8305906\n+ * @summary verify that the HttpClient pools and reuses a connection for HTTP\/2 requests\n+ * @library \/test\/lib \/lib\/testlibrary server\/ ..\/\n+ * @build jdk.testlibrary.SimpleSSLContext HttpServerAdapters\n+ *        ReferenceTracker jdk.test.lib.net.IPSupport\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @run junit\/othervm ConnectionReuseTest\n+ * @run junit\/othervm -Djava.net.preferIPv6Addresses=true ConnectionReuseTest\n+ *\/\n+\n+@RunWith(value = Parameterized.class)\n+public class ConnectionReuseTest implements HttpServerAdapters {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer http2_Server; \/\/ h2 server over HTTP\n+    private static HttpTestServer https2_Server; \/\/ h2 server over HTTPS\n+\n+    @BeforeClass\n+    public static void beforeAll() throws Exception {\n+        if (IPSupport.preferIPv6Addresses()) {\n+            IPSupport.printPlatformSupport(System.err); \/\/ for debug purposes\n+            \/\/ this test is run with -Djava.net.preferIPv6Addresses=true, so skip (all) tests\n+            \/\/ if IPv6 isn't supported on this host\n+            Assume.assumeTrue(\"Skipping tests - IPv6 is not supported\", IPSupport.hasIPv6());\n+        }\n+        sslContext = new SimpleSSLContext().get();\n+        assertNotNull(sslContext.toString(), \"Unexpected null sslContext\");\n+\n+        http2_Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", false, 0));\n+        http2_Server.addHandler(new Handler(), \"\/\");\n+        http2_Server.start();\n+        System.out.println(\"Started HTTP v2 server at \" + http2_Server.serverAuthority());\n+\n+        https2_Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", true, sslContext));\n+        https2_Server.addHandler(new Handler(), \"\/\");\n+        https2_Server.start();\n+        System.out.println(\"Started HTTPS v2 server at \" + https2_Server.serverAuthority());\n+    }\n+\n+    @AfterClass\n+    public static void afterAll() {\n+        if (https2_Server != null) {\n+            System.out.println(\"Stopping server \" + https2_Server);\n+            https2_Server.stop();\n+        }\n+        if (http2_Server != null) {\n+            System.out.println(\"Stopping server \" + http2_Server);\n+            http2_Server.stop();\n+        }\n+    }\n+\n+    @Parameters\n+    public static Iterable<Object[]> requestURIs() throws Exception  {\n+        final List<Object[]> arguments = new ArrayList<>();\n+        if (IPSupport.preferIPv6Addresses()) {\n+            IPSupport.printPlatformSupport(System.err);\n+            Assume.assumeTrue(\"Skipping tests - IPv6 is not supported\", IPSupport.hasIPv6());\n+        }\n+        \/\/ h2 over HTTPS\n+        sslContext = new SimpleSSLContext().get();\n+        https2_Server = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2_Server.addHandler(new Handler(), \"\/\");\n+        https2_Server.start();\n+        arguments.add(new Object[]{new URI(\"https:\/\/\" + https2_Server.serverAuthority() + \"\/\")});\n+        \/\/ h2 over HTTP\n+        http2_Server = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2_Server.addHandler(new Handler(), \"\/\");\n+        http2_Server.start();\n+        arguments.add(new Object[]{new URI(\"http:\/\/\" + http2_Server.serverAuthority() + \"\/\")});\n+        if (IPSupport.preferIPv6Addresses()) {\n+            if (http2_Server.getAddress().getAddress().isLoopbackAddress()) {\n+                \/\/ h2 over HTTP, use the short form of the host, in the request URI\n+                arguments.add(new Object[]{new URI(\"http:\/\/[::1]:\" + http2_Server.getAddress().getPort() + \"\/\")});\n+             }\n+        }\n+        return arguments;\n+    }\n+\n+    private final URI requestURI;\n+\n+    public ConnectionReuseTest(final URI requestURI) {\n+        this.requestURI = requestURI;\n+    }\n+\n+    \/**\n+     * Uses a single instance of a HttpClient and issues multiple requests to {@code requestURI}\n+     * and expects that each of the request internally uses the same connection\n+     *\/\n+\n+    @Test\n+    public void testConnReuse() throws Throwable {\n+        final HttpClient.Builder builder = HttpClient.newBuilder()\n+                .proxy(NO_PROXY).sslContext(sslContext);\n+        final HttpRequest req = HttpRequest.newBuilder().uri(requestURI)\n+                .GET().version(HTTP_2).build();\n+        final ReferenceTracker tracker = ReferenceTracker.INSTANCE;\n+        Throwable testFailure = null;\n+        HttpClient client = tracker.track(builder.build());\n+        try {\n+            String clientConnAddr = null;\n+            for (int i = 1; i <= 5; i++) {\n+                System.out.println(\"Issuing request(\" + i + \") \" + req);\n+                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                assertEquals(\"unexpected response code\", 200, resp.statusCode());\n+                final String respBody = resp.body();\n+                System.out.println(\"Server side handler responded to a request from \" + respBody);\n+                if (respBody == Handler.UNKNOWN_CLIENT_ADDR){\n+                    System.out.println(\"server handler couldn't determine client address in request\");\n+                }\n+                if (i == 1) {\n+                    \/\/ for the first request we just keep track of the client connection address\n+                    \/\/ that got used for this request\n+                    clientConnAddr = respBody;\n+                } else {\n+                    \/\/ verify that the client connection used to issue the request is the same\n+                    \/\/ as the previous request's client connection\n+                    assertEquals(\"HttpClient unexpectedly used a\" + \" different connection for request(\" + i + \")\", clientConnAddr, respBody);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            testFailure = t;\n+        } finally {\n+            \/\/ dereference the client to allow the tracker to verify the resources\n+            \/\/ have been released\n+            client = null;\n+            \/\/ wait for the client to be shutdown\n+            final AssertionError trackerFailure = tracker.check(2000);\n+            if (testFailure != null) {\n+                if (trackerFailure != null) {\n+                    \/\/ add the failure reported by the tracker as a suppressed\n+                    \/\/ exception and throw the original test failure\n+                    testFailure.addSuppressed(trackerFailure);\n+                }\n+                throw testFailure;\n+            }\n+            if (trackerFailure != null) {\n+                \/\/ the test itself didn't fail but the tracker check failed.\n+                \/\/ fail the test with this exception\n+                throw trackerFailure;\n+            }\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        private static final String UNKNOWN_CLIENT_ADDR = \"unknown\";\n+\n+        @Override\n+        public void handle(final HttpTestExchange t) throws IOException {\n+            final InetSocketAddress clientAddr = t.getRemoteAddress();\n+            System.out.println(\"Handling request \" + t.getRequestURI() + \" from \" + clientAddr);\n+            \/\/ we write out the client address into the response body\n+            final byte[] responseBody = clientAddr == null\n+                    ? UNKNOWN_CLIENT_ADDR.getBytes(StandardCharsets.UTF_8)\n+                    : clientAddr.toString().getBytes(StandardCharsets.UTF_8);\n+            t.sendResponseHeaders(200, responseBody.length);\n+            try (final OutputStream os = t.getResponseBody()) {\n+                os.write(responseBody);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionReuseTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"}]}