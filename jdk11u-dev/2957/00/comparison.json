{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -38,1 +39,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -51,1 +52,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -1777,1 +1778,3 @@\n-  aep = __ pc();  __ push_ptr();   __ jmp(L);\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ jmp(L);\n@@ -1779,2 +1782,6 @@\n-  fep = __ pc(); __ push(ftos); __ jmp(L);\n-  dep = __ pc(); __ push(dtos); __ jmp(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push(ftos);\n+      __ jmp(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push(dtos);\n+      __ jmp(L);\n@@ -1782,2 +1789,6 @@\n-  fep = __ pc();  __ push_f(xmm0); __ jmp(L);\n-  dep = __ pc();  __ push_d(xmm0); __ jmp(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f(xmm0);\n+      __ jmp(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d(xmm0);\n+      __ jmp(L);\n@@ -1785,4 +1796,6 @@\n-  lep = __ pc();  __ push_l();     __ jmp(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ jmp(L);\n+  bep = cep = sep = iep = __ pc();      \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();    \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -34,1 +35,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -34,1 +35,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -43,1 +44,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/macroAssembler.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -52,1 +54,1 @@\n-#define COMMENT_COLUMN  40 LP64_ONLY(+8) \/*could be an option*\/\n+#define COMMENT_COLUMN  52 LP64_ONLY(+8) \/*could be an option*\/\n@@ -166,0 +168,1 @@\n+  bool          _print_file_name;\n@@ -194,0 +197,45 @@\n+  struct SourceFileInfo {\n+    struct Link : public CHeapObj<mtCode> {\n+      const char* file;\n+      int line;\n+      Link* next;\n+      Link(const char* f, int l) : file(f), line(l), next(NULL) {}\n+    };\n+    Link *head, *tail;\n+\n+    static unsigned hash(const address& a) {\n+      return primitive_hash<address>(a);\n+    }\n+    static bool equals(const address& a0, const address& a1) {\n+      return primitive_equals<address>(a0, a1);\n+    }\n+    void append(const char* file, int line) {\n+      if (tail != NULL && tail->file == file && tail->line == line) {\n+        \/\/ Don't print duplicated lines at the same address. This could happen with C\n+        \/\/ macros that end up having multiple \"__\" tokens on the same __LINE__.\n+        return;\n+      }\n+      Link *link = new Link(file, line);\n+      if (head == NULL) {\n+        head = tail = link;\n+      } else {\n+        tail->next = link;\n+        tail = link;\n+      }\n+    }\n+    SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {\n+      append(file, line);\n+    }\n+  };\n+\n+  typedef ResourceHashtable<\n+      address, SourceFileInfo,\n+      SourceFileInfo::hash,\n+      SourceFileInfo::equals,\n+      15889,      \/\/ prime number\n+      ResourceObj::C_HEAP> SourceFileInfoTable;\n+\n+  static SourceFileInfoTable _src_table;\n+  static const char* _cached_src;\n+  static GrowableArray<const char*>* _cached_src_lines;\n+\n@@ -215,0 +263,1 @@\n+    print_hook_comments(pc0, _nm != NULL);\n@@ -224,0 +273,2 @@\n+  static void hook(const char* file, int line, address pc);\n+  void print_hook_comments(address pc, bool newline);\n@@ -226,0 +277,86 @@\n+decode_env::SourceFileInfoTable decode_env::_src_table;\n+const char* decode_env::_cached_src = NULL;\n+GrowableArray<const char*>* decode_env::_cached_src_lines = NULL;\n+\n+void decode_env::hook(const char* file, int line, address pc) {\n+  \/\/ For simplication, we never free from this table. It's really not\n+  \/\/ necessary as we add to the table only when PrintInterpreter is true,\n+  \/\/ which means we are debugging the VM and a little bit of extra\n+  \/\/ memory usage doesn't matter.\n+  SourceFileInfo* found = _src_table.get(pc);\n+  if (found != NULL) {\n+    found->append(file, line);\n+  } else {\n+    SourceFileInfo sfi(file, line);\n+    _src_table.put(pc, sfi); \/\/ sfi is copied by value\n+  }\n+}\n+\n+void decode_env::print_hook_comments(address pc, bool newline) {\n+  SourceFileInfo* found = _src_table.get(pc);\n+  outputStream* st = output();\n+  if (found != NULL) {\n+    for (SourceFileInfo::Link *link = found->head; link; link = link->next) {\n+      const char* file = link->file;\n+      int line = link->line;\n+      if (_cached_src == NULL || strcmp(_cached_src, file) != 0) {\n+        FILE* fp;\n+\n+        \/\/ _cached_src_lines is a single cache of the lines of a source file, and we refill this cache\n+        \/\/ every time we need to print a line from a different source file. It's not the fastest,\n+        \/\/ but seems bearable.\n+        if (_cached_src_lines != NULL) {\n+          for (int i=0; i<_cached_src_lines->length(); i++) {\n+            os::free((void*)_cached_src_lines->at(i));\n+          }\n+          _cached_src_lines->clear();\n+        } else {\n+          _cached_src_lines = new (ResourceObj::C_HEAP, mtCode)GrowableArray<const char*>(0, true);\n+        }\n+\n+        if ((fp = fopen(file, \"r\")) == NULL) {\n+          _cached_src = NULL;\n+          return;\n+        }\n+        _cached_src = file;\n+\n+        char line[500]; \/\/ don't write lines that are too long in your source files!\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+          size_t len = strlen(line);\n+          if (len > 0 && line[len-1] == '\\n') {\n+            line[len-1] = '\\0';\n+          }\n+          _cached_src_lines->append(os::strdup(line));\n+        }\n+        fclose(fp);\n+        _print_file_name = true;\n+      }\n+\n+      if (_print_file_name) {\n+        \/\/ We print the file name whenever we switch to a new file, or when\n+        \/\/ Disassembler::decode is called to disassemble a new block of code.\n+        _print_file_name = false;\n+        if (newline) {\n+          st->cr();\n+        }\n+        st->move_to(COMMENT_COLUMN);\n+        st->print(\";;@FILE: %s\", file);\n+        newline = true;\n+      }\n+\n+      int index = line - 1; \/\/ 1-based line number -> 0-based index.\n+      if (index >= _cached_src_lines->length()) {\n+        \/\/ This could happen if source file is mismatched.\n+      } else {\n+        const char* source_line = _cached_src_lines->at(index);\n+        if (newline) {\n+          st->cr();\n+        }\n+        st->move_to(COMMENT_COLUMN);\n+        st->print(\";;%5d: %s\", line, source_line);\n+        newline = true;\n+      }\n+    }\n+  }\n+}\n+\n@@ -241,1 +378,2 @@\n-  _bytes_per_line(Disassembler::pd_instruction_alignment())\n+  _bytes_per_line(Disassembler::pd_instruction_alignment()),\n+  _print_file_name(true)\n@@ -566,0 +704,6 @@\n+\n+\/\/ To prevent excessive code expansion in the interpreter generator, we\n+\/\/ do not inline this function into Disassembler::hook().\n+void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {\n+  decode_env::hook(file, line, masm->code_section()->end());\n+}\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":146,"deletions":2,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -80,0 +80,11 @@\n+  static void _hook(const char* file, int line, class MacroAssembler* masm);\n+\n+  \/\/ This functions makes it easy to generate comments in the generated\n+  \/\/ interpreter code, by riding on the customary __ macro in the interpreter generator.\n+  \/\/ See templateTable_x86.cpp for an example.\n+  template<class T> inline static T* hook(const char* file, int line, T* masm) {\n+    if (PrintInterpreter) {\n+      _hook(file, line, masm);\n+    }\n+    return masm;\n+  }\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -36,1 +37,1 @@\n-# define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}