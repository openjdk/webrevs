{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -267,3 +266,6 @@\n-                int count = countLeadingBackslash(verificationType, s, s.length());\n-                while (count-- > 0) {\n-                    cmdbuf.append(BACKSLASH);   \/\/ double the number of backslashes\n+                if (verificationType == VERIFICATION_WIN32_SAFE ||\n+                    verificationType == VERIFICATION_LEGACY) {\n+                    int count = countLeadingBackslash(verificationType, s, s.length());\n+                    while (count-- > 0) {\n+                        cmdbuf.append(BACKSLASH);   \/\/ double the number of backslashes\n+                    }\n@@ -272,0 +274,8 @@\n+            } else if (verificationType == VERIFICATION_WIN32_SAFE &&\n+                 (s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\") && s.length() > 2)) {\n+                \/\/ Check that quoted argument does not escape the final quote\n+                cmdbuf.append(s);\n+                int count = countLeadingBackslash(verificationType, s, s.length() - 1);\n+                while (count-- > 0) {\n+                    cmdbuf.insert(cmdbuf.length() - 1, BACKSLASH);    \/\/ double the number of backslashes\n+                }\n@@ -280,3 +290,1 @@\n-     * Return the argument without quotes (1st and last) if properly quoted, else the arg.\n-     * A properly quoted string has first and last characters as quote and\n-     * the last quote is not escaped.\n+     * Return the argument without quotes (first and last) if quoted, otherwise the arg.\n@@ -290,3 +298,0 @@\n-        if (str.endsWith(\"\\\\\\\"\")) {\n-            return str;    \/\/ not properly quoted, treat as unquoted\n-        }\n","filename":"src\/java.base\/windows\/classes\/java\/lang\/ProcessImpl.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8282008\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm ArgCheck\n+ * @summary Check invocation of exe and non-exe programs using ProcessBuilder\n+ *      and arguments with spaces, backslashes, and simple quoting.\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Class to check invocation of java, .cmd, and vbs scripts with arguments and various quote cases.\n+ * Can be run standalone to compare results with other Java versions.\n+ *\/\n+public class ArgCheck {\n+\n+    private static final Path SRC_DIR = Paths.get(System.getProperty(\"test.src\", \".\"));\n+    private static final Path WORK_DIR = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+    private static final Path TEST_CLASSES = Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+    private static final String ECHO_CMD_PATH = WORK_DIR.resolve(\"EchoArguments.cmd\").toString();\n+    private static final String ECHO_VBS_PATH = WORK_DIR.resolve(\"EchoArguments.vbs\").toString();\n+\n+    \/\/ Test argument containing both a space and a trailing backslash\n+    \/\/ Depending on the mode the final backslash may act as an escape that may turn an added quote to a literal quote\n+    private static final String SPACE_AND_BACKSLASH = \"SPACE AND BACKSLASH\\\\\";\n+    private static final char DOUBLE_QUOTE = '\"';\n+    private static final char BACKSLASH = '\\\\';\n+\n+    private static final String AMBIGUOUS_PROP_NAME = \"jdk.lang.Process.allowAmbiguousCommands\";\n+    private static final String AMBIGUOUS_PROP_VALUE = System.getProperty(AMBIGUOUS_PROP_NAME);\n+    private static final Boolean AMBIGUOUS_PROP_BOOLEAN = AMBIGUOUS_PROP_VALUE == null ? null :\n+                                                          Boolean.valueOf(!\"false\".equals(AMBIGUOUS_PROP_VALUE));\n+\n+    private static final List<String> ECHO_JAVA_ARGS = Arrays.asList(\"java\", \"-classpath\", TEST_CLASSES.toString(), \"ArgCheck\");\n+    private static final List<String> ECHO_CMD_ARGS = Arrays.asList(ECHO_CMD_PATH);\n+    private static final List<String> ECHO_VBS_ARGS = Arrays.asList(\"CScript\", \"\/b\", ECHO_VBS_PATH);\n+\n+    \/**\n+     * If zero arguments are supplied, run the test cases, by launching each as a child process.\n+     * If there are arguments, then this is a child Java process that prints each argument to stdout.\n+     * The test can be run manually with -Djdk.lang.Process.allowAmbiguousCommands={\"true\", \"false\", \"\"}\n+     * to run a matching subset of the tests.\n+     *\/\n+    public static void main(String[] args) throws IOException {\n+        if (args.length > 0) {\n+            \/\/ Echo supplied arguments and exit\n+            for (String arg : args)\n+                System.out.println(arg);\n+            return;\n+        }\n+\n+        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n+\n+        createFiles();\n+\n+        int errors = 0;\n+        int success = 0;\n+        int skipped = 0;\n+\n+        for (CMD cmd : CASES) {\n+            \/\/ If System property jdk.lang.process.allowAmbiguousCommands matches the case, test it\n+            \/\/ If undefined, test them all\n+            if (AMBIGUOUS_PROP_BOOLEAN == null ||\n+                    AMBIGUOUS_PROP_BOOLEAN.booleanValue() == cmd.allowAmbiguous) {\n+                try {\n+                    testCommand(cmd);\n+                    success++;\n+                } catch (Exception ex) {\n+                    ex.printStackTrace();\n+                    errors++;\n+                }\n+            } else {\n+                \/\/ skip unmatched cases\n+                skipped++;\n+            }\n+        }\n+        if (skipped > 0) {\n+            System.out.printf(\"%d cases skipped, they did not match the tests with jdk.lang.Process.allowAmbiguousCommands: %s%n\",\n+                    skipped, AMBIGUOUS_PROP_BOOLEAN);\n+        }\n+        System.out.printf(\"\\nSuccess: %d, errors: %d%n\", success, errors);\n+        if (errors > 0) {\n+            throw new RuntimeException(\"Errors: \" + errors);\n+        }\n+    }\n+\n+    \/**\n+     * A CMD holds the parameters and the expected result of invoking a process with the parameters.\n+     *\/\n+    static class CMD {\n+        \/**\n+         * Construct a test case.\n+         * @param allowAmbiguous  true\/false to set property jdk.lang.Process.allowAmbiguousCommands\n+         * @param command list of command parameters to invoke the executable or script\n+         * @param arguments list of arguments (appended to the command)\n+         * @param expected    expected lines of output from invoked command\n+         *\/\n+        CMD(boolean allowAmbiguous, List<String> command, List<String> arguments, List<String> expected) {\n+            this.allowAmbiguous = allowAmbiguous;\n+            this.command = command;\n+            this.arguments = arguments;\n+            this.expected = expected;\n+        }\n+\n+        final boolean allowAmbiguous;\n+        final List<String> command;\n+        final List<String> arguments;\n+        final List<String> expected;\n+    }\n+\n+    \/**\n+     * List of cases with the command, arguments, allowAmbiguous setting, and the expected results\n+     *\/\n+    static final List<CMD> CASES = Arrays.asList(\n+\n+            \/\/ allowAmbiguousCommands = false, without application supplied double-quotes.\n+            \/\/ The space in the argument requires it to be quoted, the final backslash\n+            \/\/ must not be allowed to turn the quote that is added into a literal\n+            \/\/ instead of closing the quote.\n+            new CMD(false,\n+                    ECHO_JAVA_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_1\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_1\")),\n+            new CMD(false,\n+                    ECHO_CMD_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_2\"),\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_2\")),\n+            new CMD(false,\n+                    ECHO_VBS_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_3\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH + BACKSLASH, \"ARG_3\")),\n+\n+            \/\/ allowAmbiguousCommands = false, WITH application supplied double-quotes around the argument\n+            \/\/ The argument has surrounding quotes so does not need further quoting.\n+            \/\/ However, for exe commands, the final backslash must not be allowed to turn the quote\n+            \/\/ into a literal instead of closing the quote.\n+            new CMD(false,\n+                    ECHO_JAVA_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_11\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_11\")),\n+            new CMD(false,\n+                    ECHO_CMD_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_12\"),\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_12\")),\n+            new CMD(false,\n+                    ECHO_VBS_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_13\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH + BACKSLASH, \"ARG_13\")),\n+\n+            \/\/ Legacy mode tests; allowAmbiguousCommands = true; no application supplied quotes\n+            \/\/ The space in the argument requires it to be quoted, the final backslash\n+            \/\/ must not be allowed to turn the quote that is added into a literal\n+            \/\/ instead of closing the quote.\n+            new CMD(true,\n+                    ECHO_JAVA_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_21\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_21\")),\n+            new CMD(true,\n+                    ECHO_CMD_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_22\"),\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + BACKSLASH + DOUBLE_QUOTE, \"ARG_22\")),\n+            new CMD(true,\n+                    ECHO_VBS_ARGS,\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_23\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH + BACKSLASH, \"ARG_23\")),\n+\n+            \/\/ allowAmbiguousCommands = true, WITH application supplied double-quotes around the argument\n+            \/\/ The argument has surrounding quotes so does not need further quoting.\n+            \/\/ The backslash before the final quote is ignored and is interpreted differently for each command.\n+            new CMD(true,\n+                    ECHO_JAVA_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_31\"),\n+                    Arrays.asList(\"SPACE AND BACKSLASH\\\" ARG_31\")),\n+            new CMD(true,\n+                    ECHO_CMD_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_32\"),\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_32\")),\n+            new CMD(true,\n+                    ECHO_VBS_ARGS,\n+                    Arrays.asList(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_33\"),\n+                    Arrays.asList(SPACE_AND_BACKSLASH, \"ARG_33\"))\n+    );\n+\n+    \/**\n+     * Common function to Invoke a process with the commands and check the result.\n+     *\n+     * @param cmd a CMD test case with arguments, allowAmbiguousCommands mode, and expected output\n+     *\/\n+    private static void testCommand(CMD cmd) throws Exception {\n+        System.setProperty(AMBIGUOUS_PROP_NAME, Boolean.toString(cmd.allowAmbiguous));\n+        List<String> actual = null;\n+        List<String> arguments = new ArrayList<>(cmd.command);\n+        arguments.addAll(cmd.arguments);\n+        try {\n+            \/\/ Launch the process and wait for termination\n+            ProcessBuilder pb = new ProcessBuilder(arguments);\n+            Process process = pb.start();\n+            try (InputStream is = process.getInputStream()) {\n+                String str = readAllBytesAsString(is);\n+                str = str.replace(\"\\r\", \"\");\n+                actual = Arrays.asList(str.split(\"\\n\"));\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe.getMessage(), ioe);\n+            }\n+            int exitCode = process.waitFor();\n+            if (exitCode != 0) {\n+                actual = new ArrayList(actual);\n+                actual.add(\"Exit code: \" + exitCode);\n+            }\n+        } catch (IOException ioe) {\n+            actual = Arrays.asList(ioe.getMessage().replace(arguments.get(0), \"CMD\"));\n+        } catch (Exception ex) {\n+            actual = Arrays.asList(ex.getMessage());       \/\/ Use exception message as output\n+        }\n+        if (!Objects.equals(actual, cmd.expected)) {\n+            System.out.println(\"Invoking(\" + cmd.allowAmbiguous + \"): \" + arguments);\n+            if (actual.size() != cmd.expected.size()) {\n+                System.out.println(\"Args Length: actual: \" + actual.size() + \" expected: \" + cmd.expected.size());\n+            }\n+            System.out.println(\"Actual:   \" + actual);\n+            System.out.println(\"Expected: \" + cmd.expected);\n+            System.out.println();\n+            throw new RuntimeException(\"Unexpected output\");\n+        }\n+    }\n+\n+    \/**\n+     * Private method to readAllBytes as a String.\n+     * (InputStream.readAllBytes is not supported by the JDK until 9)\n+     * @param is an InputStream\n+     * @return a String with the contents\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static String readAllBytesAsString(InputStream is) throws IOException {\n+        final int BUF_SIZE = 8192;\n+        byte[] bytes = new byte[BUF_SIZE];\n+        int off = 0;\n+        int len;\n+        while ((len = is.read(bytes, off, bytes.length - off)) > 0) {\n+            off += len;\n+            if (off >= bytes.length) {\n+                \/\/ no space in buffer, reallocate larger\n+                bytes = Arrays.copyOf(bytes, bytes.length + BUF_SIZE);\n+            }\n+        }\n+        return new String(bytes, 0, off, Charset.defaultCharset());\n+    }\n+\n+    \/**\n+     * Initialize .cmd and .vbs scripts.\n+     *\n+     * @throws Error if an exception occurs\n+     *\/\n+    private static void createFiles() throws IOException {\n+        Files.write(Paths.get(ECHO_CMD_PATH), EchoArgumentsCmd.getBytes(StandardCharsets.UTF_8));\n+        Files.write(Paths.get(ECHO_VBS_PATH), EchoArgumentsVbs.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    \/**\n+     * Self contained .cmd to echo each argument on a separate line.\n+     *\/\n+    static final String EchoArgumentsCmd = \"@echo off\\n\" +\n+            \"set p1=\\n\" +\n+            \"set p2=\\n\" +\n+            \"\\n\" +\n+            \"if not [%1]==[] set p1=%1\\n\" +\n+            \"if not [%2]==[] set p2=%2\\n\" +\n+            \"if not [%3]==[] set p3=%3\\n\" +\n+            \"if defined p1 echo %p1%\\n\" +\n+            \"if defined p2 echo %p2%\\n\" +\n+            \"if defined p3 echo %p3%\\n\" +\n+            \"exit \/b 0\\n\";\n+\n+\n+    \/**\n+     * Self contained .vbs to echo each argument on a separate line.\n+     *\/\n+    static final String EchoArgumentsVbs = \"Option Explicit\\n\" +\n+            \"Dim arg\\n\" +\n+            \"for each arg in WScript.Arguments\\n\" +\n+            \"  WScript.StdOut.WriteLine(arg)\\n\" +\n+            \"Next\\n\";\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ArgCheck.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"}]}