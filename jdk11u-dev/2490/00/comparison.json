{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -73,20 +75,57 @@\n-    private static final Optional<MemoryPoolMXBean> NON_SEGMENTED_CODE_CACHE_POOL;\n-    private static final Optional<MemoryPoolMXBean> NON_NMETHODS_POOL;\n-    private static final Optional<MemoryPoolMXBean> PROFILED_NMETHODS_POOL;\n-    private static final Optional<MemoryPoolMXBean> NON_PROFILED_NMETHODS_POOL ;\n-\n-    \/\/ Limit numbers are arbitrary, feel free to change if arguably necessary\n-    private static final int NON_SEGMENTED_CACHE_ALLOWANCE = 2_000_000;\n-    private static final int SEGMENTED_CACHE_ALLOWANCE = 1_000_000;\n-\n-    static {\n-        var pools = ManagementFactory.getMemoryPoolMXBeans();\n-        NON_SEGMENTED_CODE_CACHE_POOL = pools.stream()\n-            .filter(pool -> pool.getName().equals(\"CodeCache\")).findFirst();\n-        NON_NMETHODS_POOL = pools.stream()\n-            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-nmethods'\")).findFirst();\n-        PROFILED_NMETHODS_POOL = pools.stream()\n-            .filter(pool -> pool.getName().equals(\"CodeHeap 'profiled nmethods'\")).findFirst();\n-        NON_PROFILED_NMETHODS_POOL = pools.stream()\n-            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-profiled nmethods'\")).findFirst();\n-    }\n+    \/**\n+     * The class is used for periodical checks if a code-cache consuming operation\n+     * could be executed (i.e. if code cache has enought free space for a typical operation).\n+     *\/\n+    private static class CodeCacheMonitor {\n+\n+        private static final Optional<MemoryPoolMXBean> NON_SEGMENTED_CODE_CACHE_POOL;\n+        private static final Optional<MemoryPoolMXBean> NON_NMETHODS_POOL;\n+        private static final Optional<MemoryPoolMXBean> PROFILED_NMETHODS_POOL;\n+        private static final Optional<MemoryPoolMXBean> NON_PROFILED_NMETHODS_POOL;\n+\n+        \/\/ Trial runs show up that maximal increase in code cache consumption between checks (for one\n+        \/\/ cycle\/tree build in MHTransformationGen::createSequence), falls within the following intervals:\n+        \/\/\n+        \/\/ | Threads number | Without Xcomp | With Xcomp |\n+        \/\/ |----------------|---------------|------------|\n+        \/\/ |       1        |   100-200 K   |  400-500 K |\n+        \/\/ |      10        |    1 - 2 M    |    5-6 M   |\n+        \/\/\n+        \/\/ Those numbers are approximate (since trees are generated randomly and the total consumption\n+        \/\/ between checks depends on how threads are aligned - for example, if all threads finish up their\n+        \/\/ cycles approximately at one time, the consumption increase will be the highest, like with a\n+        \/\/ resonance's amplitude)\n+        \/\/ The 10 threads is chosen as it is a typical number for multi-threaded tests.\n+        \/\/\n+        \/\/ Based on these numbers, values of 10 M for Xcomp and 5 M for non-Xcomp, were suggested.\n+        private static final int NON_SEGMENTED_CACHE_ALLOWANCE = Platform.isComp() ? 10_000_000 : 5_000_000;\n+        private static final int SEGMENTED_CACHE_ALLOWANCE = Platform.isComp() ? 10_000_000 : 5_000_000;\n+\n+        static {\n+            var pools = ManagementFactory.getMemoryPoolMXBeans();\n+            NON_SEGMENTED_CODE_CACHE_POOL = pools.stream()\n+                .filter(pool -> pool.getName().equals(\"CodeCache\")).findFirst();\n+            NON_NMETHODS_POOL = pools.stream()\n+                .filter(pool -> pool.getName().equals(\"CodeHeap 'non-nmethods'\")).findFirst();\n+            PROFILED_NMETHODS_POOL = pools.stream()\n+                .filter(pool -> pool.getName().equals(\"CodeHeap 'profiled nmethods'\")).findFirst();\n+            NON_PROFILED_NMETHODS_POOL = pools.stream()\n+                .filter(pool -> pool.getName().equals(\"CodeHeap 'non-profiled nmethods'\")).findFirst();\n+        }\n+\n+        public static final boolean isCodeCacheEffectivelyFull() {\n+            var result = new Object() { boolean value = false; };\n+\n+            BiConsumer<MemoryPoolMXBean, Integer> check = (pool, limit) -> {\n+                var usage = pool.getUsage();\n+                result.value |= usage.getMax() - usage.getUsed() < limit;\n+            };\n+\n+            NON_SEGMENTED_CODE_CACHE_POOL.ifPresent(pool -> check.accept(pool, NON_SEGMENTED_CACHE_ALLOWANCE));\n+            NON_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+            PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+            NON_PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+\n+            return result.value;\n+        }\n+    };\n@@ -98,16 +137,0 @@\n-    private static final boolean isCodeCacheEffectivelyFull() {\n-        var result = new Object() { boolean value = false; };\n-\n-        BiConsumer<MemoryPoolMXBean, Integer> check = (pool, limit) -> {\n-            var usage = pool.getUsage();\n-            result.value |= usage.getMax() - usage.getUsed() < limit;\n-        };\n-\n-        NON_SEGMENTED_CODE_CACHE_POOL.ifPresent(pool -> check.accept(pool, NON_SEGMENTED_CACHE_ALLOWANCE));\n-        NON_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n-        PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n-        NON_PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n-\n-        return result.value;\n-    }\n-\n@@ -136,1 +159,1 @@\n-            if (isCodeCacheEffectivelyFull()) {\n+            if (CodeCacheMonitor.isCodeCacheEffectivelyFull()) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/share\/MHTransformationGen.java","additions":61,"deletions":38,"binary":false,"changes":99,"status":"modified"}]}