{"files":[{"patch":"@@ -283,1 +283,0 @@\n-vmTestbase\/vm\/mlvm\/mixed\/stress\/java\/findDeadlock\/TestDescription.java 8208278 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -56,0 +57,1 @@\n+    static CountDownLatch _threadsRunningLatch;\n@@ -66,1 +68,1 @@\n-            Env.traceVerbose(place + \": Locking \" + n);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Locking \" + n);\n@@ -71,1 +73,1 @@\n-                Env.traceVerbose(place + \": Locking interruptibly \" + n);\n+                Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Locking interruptibly \" + n);\n@@ -78,1 +80,1 @@\n-                    Env.traceVerbose(place + \": LOCKED \" + n);\n+                    Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": LOCKED \" + n);\n@@ -81,1 +83,1 @@\n-                Env.traceVerbose(place + \": interrupted while locking \" + n);\n+                Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": interrupted while locking \" + n);\n@@ -90,1 +92,1 @@\n-        Env.traceVerbose(place + \": Unlocking \" + n);\n+        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Unlocking \" + n);\n@@ -92,1 +94,1 @@\n-        Env.traceVerbose(place + \": UNLOCKED \" + n);\n+        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": UNLOCKED \" + n);\n@@ -101,1 +103,1 @@\n-            Env.traceVerbose(thread.getName() + \": Entered BSM. Lock=\" + lockNum);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entered BSM. Lock=\" + lockNum);\n@@ -110,0 +112,1 @@\n+                _threadsRunningLatch.countDown();\n@@ -126,1 +129,1 @@\n-            Env.traceVerbose(thread.getName() + \": Entered target method. Lock=\" + lockNum);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entered target method. Lock=\" + lockNum);\n@@ -135,0 +138,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -141,1 +145,2 @@\n-                        Env.traceVerbose(thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n+                        _threadsRunningLatch.countDown();\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n@@ -144,1 +149,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n@@ -148,1 +153,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n@@ -151,0 +156,1 @@\n+                            _threadsRunningLatch.countDown();\n@@ -154,1 +160,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n@@ -166,0 +172,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -172,0 +179,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -18208,1 +18216,1 @@\n-        Env.traceNormal(\"Starting test...\");\n+        Env.traceNormal(\"Iteration \" + _iteration + \" Starting test...\");\n@@ -18210,0 +18218,1 @@\n+        \/\/ Sanity check that all the locks are available.\n@@ -18220,0 +18229,3 @@\n+        \/\/ Threads generally wait on this after claiming their first lock,\n+        \/\/ and then when released will try to claim the second, which leads\n+        \/\/ to deadlock.\n@@ -18221,0 +18233,6 @@\n+\n+        \/\/ Threads signal this latch after being released from the startbarrier\n+        \/\/ so that they are closer to triggering deadlock before the main thread\n+        \/\/ starts to check for it.\n+        _threadsRunningLatch = new CountDownLatch(THREAD_NUM);\n+\n@@ -18224,1 +18242,2 @@\n-        for ( int i = 0; i < THREAD_NUM; i++ )\n+        \/\/ Start the new batch of threads.\n+        for ( int i = 0; i < THREAD_NUM; i++ ) {\n@@ -18226,0 +18245,1 @@\n+        }\n@@ -18228,0 +18248,8 @@\n+            \/\/ If a thread encounters an error before it reaches the start barrier\n+            \/\/ then we will hang here until the test times out. So we do a token\n+            \/\/ check for such failure.\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure before startBarrier was reached\");\n+                return false;\n+            }\n+\n@@ -18229,20 +18257,7 @@\n-            Env.traceVerbose(\"Start race...\");\n-\n-            \/\/\n-            \/\/ Wait for the deadlock and detect it using ThreadMXBean\n-            \/\/\n-\n-            boolean resultsReady = false;\n-            for ( int i = 0; i < 10 && ! resultsReady && ! _testFailed; i++ ) {\n-                Env.traceNormal(\"Waiting for threads to lock up...\");\n-                Thread.sleep(100);\n-\n-                resultsReady = true;\n-                for ( int t = 0; t < THREAD_NUM; t++ ) {\n-                    if ( _iteration == 0 && t % 3 != 2 && ! _locks[t].hasQueuedThreads() ) {\n-                        Env.traceVerbose(\"Lock \" + t + \": no waiters\");\n-                        resultsReady = false;\n-                    } else {\n-                        Env.traceVerbose(\"Lock \" + t + \": has waiters\");\n-                    }\n-                }\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" Start race...\");\n+\n+            \/\/ Wait till all threads poised to deadlock. Again we may hang here\n+            \/\/ if unexpected errors are encountered, so again a token check.\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure after startBarrier was reached\");\n+                return false;\n@@ -18251,2 +18266,1 @@\n-            if ( ! resultsReady )\n-                Env.traceImportant(\"Warning: threads are still not deadlocked?\");\n+            _threadsRunningLatch.await();\n@@ -18254,3 +18268,15 @@\n-            long[] deadlockedThreads = _threadMXBean.findDeadlockedThreads();\n-            if ( deadlockedThreads == null ) {\n-                Env.complain(\"Found no deadlocked threads. Expected to find \" + THREAD_NUM);\n+            \/\/ There is a race now between checking for a deadlock and the threads\n+            \/\/ actually engaging in that deadlock. We can't query all of the \"locks\"\n+            \/\/ involved to see if they are owned and have waiters (no API for built-in\n+            \/\/ monitors). Nor can we check the thread states because they could be blocked\n+            \/\/ on incidental synchronization (like I\/O monitors when logging is enabled).\n+            \/\/ So we simply loop checking for a deadlock until we find it, or else the\n+            \/\/ overall test times out.\n+\n+            long[] deadlockedThreads = null;\n+            do {\n+                deadlockedThreads = _threadMXBean.findDeadlockedThreads();\n+            } while (deadlockedThreads == null && !_testFailed);\n+\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure while checking for deadlock\");\n@@ -18258,1 +18284,3 @@\n-            } else if ( deadlockedThreads.length != THREAD_NUM ) {\n+            }\n+\n+            if (deadlockedThreads.length != THREAD_NUM) {\n@@ -18263,1 +18291,1 @@\n-                return ! _testFailed;\n+                return true;\n@@ -18266,0 +18294,1 @@\n+            \/\/ Tells the locking threads the interrupt was expected.\n@@ -18268,0 +18297,4 @@\n+            \/\/ Break the deadlock by dropping the attempt to lock\n+            \/\/ the interruptible locks, which then causes all other\n+            \/\/ locks to be released and allow threads acquiring\n+            \/\/ non-interruptible locks to proceed.\n@@ -18270,4 +18303,7 @@\n-            for ( int i = 0; i < THREAD_NUM; i++ ) {\n-                _threads[i].join(1000);\n-                if ( _threads[i].isAlive() )\n-                    Env.getLog().complain(\"Thread \" + _threads[i].getName() + \" is still alive\");\n+            \/\/ Wait for all threads to terminate before proceeding to next\n+            \/\/ iteration. If we only join() for a limited time and its too short\n+            \/\/ then we not only complain here, but will also find locks that are\n+            \/\/ still locked. It is far simpler to only proceed when all threads\n+            \/\/ are done and rely on the overall test timeout to detect problems.\n+            for (int i = 0; i < THREAD_NUM; i++) {\n+                _threads[i].join();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/mixed\/stress\/java\/findDeadlock\/INDIFY_Test.java","additions":82,"deletions":46,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -58,0 +59,1 @@\n+    static CountDownLatch _threadsRunningLatch;\n@@ -68,1 +70,1 @@\n-            Env.traceVerbose(place + \": Locking \" + n);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Locking \" + n);\n@@ -73,1 +75,1 @@\n-                Env.traceVerbose(place + \": Locking interruptibly \" + n);\n+                Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Locking interruptibly \" + n);\n@@ -80,1 +82,1 @@\n-                    Env.traceVerbose(place + \": LOCKED \" + n);\n+                    Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": LOCKED \" + n);\n@@ -83,1 +85,1 @@\n-                Env.traceVerbose(place + \": interrupted while locking \" + n);\n+                Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": interrupted while locking \" + n);\n@@ -92,1 +94,1 @@\n-        Env.traceVerbose(place + \": Unlocking \" + n);\n+        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": Unlocking \" + n);\n@@ -94,1 +96,1 @@\n-        Env.traceVerbose(place + \": UNLOCKED \" + n);\n+        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + place + \": UNLOCKED \" + n);\n@@ -103,1 +105,1 @@\n-            Env.traceVerbose(thread.getName() + \": Entered BSM. Lock=\" + lockNum);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entered BSM. Lock=\" + lockNum);\n@@ -112,0 +114,1 @@\n+                _threadsRunningLatch.countDown();\n@@ -128,1 +131,1 @@\n-            Env.traceVerbose(thread.getName() + \": Entered target method. Lock=\" + lockNum);\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entered target method. Lock=\" + lockNum);\n@@ -137,0 +140,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -143,1 +147,2 @@\n-                        Env.traceVerbose(thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n+                        _threadsRunningLatch.countDown();\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n@@ -146,1 +151,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n@@ -150,1 +155,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Entering synchronize ( \" + lockNum + \" )\");\n@@ -153,0 +158,1 @@\n+                            _threadsRunningLatch.countDown();\n@@ -156,1 +162,1 @@\n-                        Env.traceVerbose(thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n+                        Env.traceVerbose(\"Iteration \" + _iteration + \" \" + thread.getName() + \": Exited synchronize ( \" + lockNum + \" )\");\n@@ -168,0 +174,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -174,0 +181,1 @@\n+                        _threadsRunningLatch.countDown();\n@@ -258,1 +266,1 @@\n-        Env.traceNormal(\"Starting test...\");\n+        Env.traceNormal(\"Iteration \" + _iteration + \" Starting test...\");\n@@ -260,0 +268,1 @@\n+        \/\/ Sanity check that all the locks are available.\n@@ -270,0 +279,3 @@\n+        \/\/ Threads generally wait on this after claiming their first lock,\n+        \/\/ and then when released will try to claim the second, which leads\n+        \/\/ to deadlock.\n@@ -271,0 +283,6 @@\n+\n+        \/\/ Threads signal this latch after being released from the startbarrier\n+        \/\/ so that they are closer to triggering deadlock before the main thread\n+        \/\/ starts to check for it.\n+        _threadsRunningLatch = new CountDownLatch(THREAD_NUM);\n+\n@@ -274,1 +292,2 @@\n-        for ( int i = 0; i < THREAD_NUM; i++ )\n+        \/\/ Start the new batch of threads.\n+        for ( int i = 0; i < THREAD_NUM; i++ ) {\n@@ -276,0 +295,1 @@\n+        }\n@@ -278,0 +298,8 @@\n+            \/\/ If a thread encounters an error before it reaches the start barrier\n+            \/\/ then we will hang here until the test times out. So we do a token\n+            \/\/ check for such failure.\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure before startBarrier was reached\");\n+                return false;\n+            }\n+\n@@ -279,20 +307,7 @@\n-            Env.traceVerbose(\"Start race...\");\n-\n-            \/\/\n-            \/\/ Wait for the deadlock and detect it using ThreadMXBean\n-            \/\/\n-\n-            boolean resultsReady = false;\n-            for ( int i = 0; i < 10 && ! resultsReady && ! _testFailed; i++ ) {\n-                Env.traceNormal(\"Waiting for threads to lock up...\");\n-                Thread.sleep(100);\n-\n-                resultsReady = true;\n-                for ( int t = 0; t < THREAD_NUM; t++ ) {\n-                    if ( _iteration == 0 && t % 3 != 2 && ! _locks[t].hasQueuedThreads() ) {\n-                        Env.traceVerbose(\"Lock \" + t + \": no waiters\");\n-                        resultsReady = false;\n-                    } else {\n-                        Env.traceVerbose(\"Lock \" + t + \": has waiters\");\n-                    }\n-                }\n+            Env.traceVerbose(\"Iteration \" + _iteration + \" Start race...\");\n+\n+            \/\/ Wait till all threads poised to deadlock. Again we may hang here\n+            \/\/ if unexpected errors are encountered, so again a token check.\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure after startBarrier was reached\");\n+                return false;\n@@ -301,2 +316,1 @@\n-            if ( ! resultsReady )\n-                Env.traceImportant(\"Warning: threads are still not deadlocked?\");\n+            _threadsRunningLatch.await();\n@@ -304,3 +318,15 @@\n-            long[] deadlockedThreads = _threadMXBean.findDeadlockedThreads();\n-            if ( deadlockedThreads == null ) {\n-                Env.complain(\"Found no deadlocked threads. Expected to find \" + THREAD_NUM);\n+            \/\/ There is a race now between checking for a deadlock and the threads\n+            \/\/ actually engaging in that deadlock. We can't query all of the \"locks\"\n+            \/\/ involved to see if they are owned and have waiters (no API for built-in\n+            \/\/ monitors). Nor can we check the thread states because they could be blocked\n+            \/\/ on incidental synchronization (like I\/O monitors when logging is enabled).\n+            \/\/ So we simply loop checking for a deadlock until we find it, or else the\n+            \/\/ overall test times out.\n+\n+            long[] deadlockedThreads = null;\n+            do {\n+                deadlockedThreads = _threadMXBean.findDeadlockedThreads();\n+            } while (deadlockedThreads == null && !_testFailed);\n+\n+            if (_testFailed) {\n+                Env.complain(\"Unexpected thread failure while checking for deadlock\");\n@@ -308,1 +334,3 @@\n-            } else if ( deadlockedThreads.length != THREAD_NUM ) {\n+            }\n+\n+            if (deadlockedThreads.length != THREAD_NUM) {\n@@ -313,1 +341,1 @@\n-                return ! _testFailed;\n+                return true;\n@@ -316,0 +344,1 @@\n+            \/\/ Tells the locking threads the interrupt was expected.\n@@ -318,0 +347,4 @@\n+            \/\/ Break the deadlock by dropping the attempt to lock\n+            \/\/ the interruptible locks, which then causes all other\n+            \/\/ locks to be released and allow threads acquiring\n+            \/\/ non-interruptible locks to proceed.\n@@ -320,4 +353,7 @@\n-            for ( int i = 0; i < THREAD_NUM; i++ ) {\n-                _threads[i].join(1000);\n-                if ( _threads[i].isAlive() )\n-                    Env.getLog().complain(\"Thread \" + _threads[i].getName() + \" is still alive\");\n+            \/\/ Wait for all threads to terminate before proceeding to next\n+            \/\/ iteration. If we only join() for a limited time and its too short\n+            \/\/ then we not only complain here, but will also find locks that are\n+            \/\/ still locked. It is far simpler to only proceed when all threads\n+            \/\/ are done and rely on the overall test timeout to detect problems.\n+            for (int i = 0; i < THREAD_NUM; i++) {\n+                _threads[i].join();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/mixed\/stress\/java\/findDeadlock\/INDIFY_Test.jmpp","additions":82,"deletions":46,"binary":false,"changes":128,"status":"modified"}]}