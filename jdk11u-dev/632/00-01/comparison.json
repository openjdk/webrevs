{"files":[{"patch":"@@ -345,3 +345,0 @@\n-  \/\/ To call this, one must have the MultiArray_lock held, but the _klasses list still has lock free reads.\n-  assert_locked_or_safepoint(MultiArray_lock);\n-\n@@ -1166,40 +1163,0 @@\n-\/\/ Iterating over the CLDG needs to be locked because\n-\/\/ unloading can remove entries concurrently soon.\n-class ClassLoaderDataGraphIterator : public StackObj {\n-  ClassLoaderData* _next;\n-  Thread*          _thread;\n-  HandleMark       _hm;  \/\/ clean up handles when this is done.\n-  Handle           _holder;\n-  NoSafepointVerifier _nsv; \/\/ No safepoints allowed in this scope\n-                            \/\/ unless verifying at a safepoint.\n-\n-public:\n-  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    _thread = Thread::current();\n-    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  }\n-\n-  ClassLoaderData* get_next() {\n-    ClassLoaderData* cld = _next;\n-    \/\/ Skip already unloaded CLD for concurrent unloading.\n-    while (cld != NULL && !cld->is_alive()) {\n-      cld = cld->next();\n-    }\n-    if (cld != NULL) {\n-      \/\/ Keep cld that is being returned alive.\n-      _holder = Handle(_thread, cld->holder_phantom());\n-      _next = cld->next();\n-    } else {\n-      _next = NULL;\n-    }\n-    return cld;\n-  }\n-};\n-\n-void ClassLoaderDataGraph::loaded_cld_do(CLDClosure* cl) {\n-  ClassLoaderDataGraphIterator iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  friend class ClassLoaderDataGraphIterator;\n@@ -106,2 +105,0 @@\n-  \/\/ Iteration through CLDG not by GC.\n-  static void loaded_cld_do(CLDClosure* cl);\n@@ -184,1 +181,0 @@\n-  friend class ClassLoaderDataGraphIterator;\n@@ -294,2 +290,0 @@\n-\n-  oop holder_phantom() const;\n@@ -301,0 +295,1 @@\n+  oop holder_phantom() const;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -1591,9 +1590,7 @@\n-      if (ik->is_loaded()) {\n-        \/\/ Link the class to cause the bytecodes to be rewritten and the\n-        \/\/ cpcache to be created. Class verification is done according\n-        \/\/ to -Xverify setting.\n-        _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);\n-        guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n-\n-        ik->constants()->resolve_class_constants(THREAD);\n-      }\n+      \/\/ Link the class to cause the bytecodes to be rewritten and the\n+      \/\/ cpcache to be created. Class verification is done according\n+      \/\/ to -Xverify setting.\n+      _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);\n+      guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n+\n+      ik->constants()->resolve_class_constants(THREAD);\n@@ -1628,21 +1625,0 @@\n-class CollectCLDClosure : public CLDClosure {\n-  GrowableArray<ClassLoaderData*> _loaded_cld;\n-  GrowableArray<jobject> _loaded_cld_handles; \/\/ keep the CLDs alive\n-  Thread* _current_thread;\n-public:\n-  CollectCLDClosure(Thread* thread) : _current_thread(thread) {}\n-  ~CollectCLDClosure() {\n-      for (int i = 0; i < _loaded_cld_handles.length(); i++) {\n-        JNIHandles::destroy_local(_loaded_cld_handles.at(i));\n-      }\n-  }\n-  void do_cld(ClassLoaderData* cld) {\n-    assert(cld->is_alive(), \"must be\");\n-    _loaded_cld.append(cld);\n-    oop holder = cld->holder_phantom();\n-    _loaded_cld_handles.append(JNIHandles::make_local(_current_thread, holder));\n-  }\n-\n-  int nof_cld() const                { return _loaded_cld.length(); }\n-  ClassLoaderData* cld_at(int index) { return _loaded_cld.at(index); }\n-};\n@@ -1651,12 +1627,0 @@\n-  \/\/ Collect all loaded ClassLoaderData.\n-  CollectCLDClosure collect_cld(THREAD);\n-  {\n-    MutexLocker ml(MultiArray_lock);\n-    \/\/ ClassLoaderDataGraph::loaded_cld_do requires ClassLoaderDataGraph_lock.\n-    \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n-    \/\/ Therefore, we need to first collect all the CLDs, and then link their classes after\n-    \/\/ releasing the lock.\n-    MutexLocker lock(ClassLoaderDataGraph_lock);\n-    ClassLoaderDataGraph::loaded_cld_do(&collect_cld);\n-  }\n-\n@@ -1668,4 +1632,1 @@\n-    for (int i = 0; i < collect_cld.nof_cld(); i++) {\n-      ClassLoaderData* cld = collect_cld.cld_at(i);\n-      cld->classes_do(&link_closure);\n-    }\n+    ClassLoaderDataGraph::loaded_classes_do(&link_closure);\n@@ -1676,1 +1637,0 @@\n-    MutexLocker ml(MultiArray_lock);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":8,"deletions":48,"binary":false,"changes":56,"status":"modified"}]}