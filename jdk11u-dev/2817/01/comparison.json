{"files":[{"patch":"@@ -565,8 +565,5 @@\n-  if (log_is_enabled(Info, redefine, class, update)) {\n-    ResourceMark rm;\n-    if (!(*trace_name_printed)) {\n-      log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n-      *trace_name_printed = true;\n-    }\n-    log_debug(redefine, class, update, constantpool)\n-          (\"cpc %s entry update: %s(%s)\", entry_type, new_method->name()->as_C_string(), new_method->signature()->as_C_string());\n+  ResourceMark rm;\n+\n+  if (!(*trace_name_printed)) {\n+    log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n+    *trace_name_printed = true;\n@@ -574,0 +571,2 @@\n+  log_trace(redefine, class, update, constantpool)\n+    (\"cpc %s entry update: %s\", entry_type, new_method->external_name());\n@@ -609,1 +608,1 @@\n-  Method* m = get_interesting_method_entry(NULL);\n+  Method* m = get_interesting_method_entry();\n@@ -619,1 +618,1 @@\n-Method* ConstantPoolCacheEntry::get_interesting_method_entry(Klass* k) {\n+Method* ConstantPoolCacheEntry::get_interesting_method_entry() {\n@@ -640,3 +639,1 @@\n-  if (m == NULL || !m->is_method() || (k != NULL && m->method_holder() != k)) {\n-    \/\/ robustness for above sanity checks or method is not in\n-    \/\/ the interesting class\n+  if (m == NULL || !m->is_method()) {\n@@ -645,1 +642,0 @@\n-  \/\/ the method is in the interesting class so the entry is interesting\n@@ -804,1 +800,1 @@\n-void ConstantPoolCache::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n+void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {\n@@ -807,1 +803,1 @@\n-    Method* old_method = entry->get_interesting_method_entry(holder);\n+    Method* old_method = entry->get_interesting_method_entry();\n@@ -816,5 +812,1 @@\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n@@ -827,0 +819,1 @@\n+  ResourceMark rm;\n@@ -828,2 +821,5 @@\n-    if (entry_at(i)->get_interesting_method_entry(NULL) != NULL &&\n-        !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+    Method* m = entry_at(i)->get_interesting_method_entry();\n+    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+      log_trace(redefine, class, update, constantpool)\n+        (\"cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s\",\n+         constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n@@ -838,1 +834,1 @@\n-    if (entry_at(i)->get_interesting_method_entry(NULL) != NULL) {\n+    if (entry_at(i)->get_interesting_method_entry() != NULL) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  Method* get_interesting_method_entry(Klass* k);\n+  Method* get_interesting_method_entry();\n@@ -509,1 +509,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool* trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2952,1 +2952,1 @@\n-void InstanceKlass::adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed) {\n+void InstanceKlass::adjust_default_methods(bool* trace_name_printed) {\n@@ -2957,1 +2957,1 @@\n-      if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+      if (old_method == NULL || !old_method->is_old()) {\n@@ -2961,6 +2961,1 @@\n-\n-      Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-      assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-      assert(old_method != new_method, \"sanity check\");\n-\n+      Method* new_method = old_method->get_new_method();\n@@ -2968,0 +2963,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1158,1 +1158,1 @@\n-  void adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed);\n+  void adjust_default_methods(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -967,1 +967,1 @@\n-void klassVtable::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n+void klassVtable::adjust_method_entries(bool * trace_name_printed) {\n@@ -969,0 +969,2 @@\n+  ResourceMark rm;\n+\n@@ -971,1 +973,1 @@\n-    if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+    if (old_method == NULL || !old_method->is_old()) {\n@@ -976,5 +978,1 @@\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n@@ -982,0 +980,1 @@\n+\n@@ -989,11 +988,5 @@\n-    if (log_is_enabled(Info, redefine, class, update)) {\n-      ResourceMark rm;\n-      if (!(*trace_name_printed)) {\n-        log_info(redefine, class, update)\n-          (\"adjust: klassname=%s for methods from name=%s\",\n-           _klass->external_name(), old_method->method_holder()->external_name());\n-        *trace_name_printed = true;\n-      }\n-      log_debug(redefine, class, update, vtables)\n-        (\"vtable method update: %s(%s), updated default = %s\",\n-         new_method->name()->as_C_string(), new_method->signature()->as_C_string(), updated_default ? \"true\" : \"false\");\n+    if (!(*trace_name_printed)) {\n+      log_info(redefine, class, update)\n+        (\"adjust: klassname=%s for methods from name=%s\",\n+         _klass->external_name(), old_method->method_holder()->external_name());\n+      *trace_name_printed = true;\n@@ -1001,0 +994,3 @@\n+    log_trace(redefine, class, update, vtables)\n+      (\"vtable method update: class: %s method: %s, updated default = %s\",\n+       _klass->external_name(), new_method->external_name(), updated_default ? \"true\" : \"false\");\n@@ -1006,0 +1002,2 @@\n+  ResourceMark rm;\n+\n@@ -1010,0 +1008,3 @@\n+      log_trace(redefine, class, update, vtables)\n+        (\"vtable check found old method entry: class: %s old: %d obsolete: %d, method: %s\",\n+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n@@ -1297,2 +1298,2 @@\n-void klassItable::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n-\n+void klassItable::adjust_method_entries(bool * trace_name_printed) {\n+  ResourceMark rm;\n@@ -1300,0 +1301,1 @@\n+\n@@ -1302,1 +1304,1 @@\n-    if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+    if (old_method == NULL || !old_method->is_old()) {\n@@ -1306,6 +1308,1 @@\n-\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n@@ -1314,8 +1311,3 @@\n-    if (log_is_enabled(Info, redefine, class, update)) {\n-      ResourceMark rm;\n-      if (!(*trace_name_printed)) {\n-        log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n-        *trace_name_printed = true;\n-      }\n-      log_trace(redefine, class, update, itables)\n-        (\"itable method update: %s(%s)\", new_method->name()->as_C_string(), new_method->signature()->as_C_string());\n+    if (!(*trace_name_printed)) {\n+      log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n+      *trace_name_printed = true;\n@@ -1323,0 +1315,2 @@\n+    log_trace(redefine, class, update, itables)\n+      (\"itable method update: class: %s method: %s\", _klass->external_name(), new_method->external_name());\n@@ -1328,0 +1322,1 @@\n+  ResourceMark rm;\n@@ -1329,0 +1324,1 @@\n+\n@@ -1333,0 +1329,3 @@\n+      log_trace(redefine, class, update, itables)\n+        (\"itable check found old method entry: class: %s old: %d obsolete: %d, method: %s\",\n+         _klass->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":35,"deletions":36,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n@@ -325,1 +325,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,4 +62,6 @@\n-int         VM_RedefineClasses::_matching_methods_length = 0;\n-int         VM_RedefineClasses::_deleted_methods_length  = 0;\n-int         VM_RedefineClasses::_added_methods_length    = 0;\n-Klass*      VM_RedefineClasses::_the_class = NULL;\n+int       VM_RedefineClasses::_matching_methods_length = 0;\n+int       VM_RedefineClasses::_deleted_methods_length  = 0;\n+int       VM_RedefineClasses::_added_methods_length    = 0;\n+\n+\/\/ This flag is global as the constructor does not reset it:\n+bool      VM_RedefineClasses::_has_redefined_Object = false;\n@@ -76,0 +78,1 @@\n+  _the_class = NULL;\n@@ -210,1 +213,2 @@\n-  \/\/ Clean out MethodData pointing to old Method*\n+  \/\/ Adjust constantpool caches and vtables for all classes\n+  \/\/ that reference methods of the evolved classes.\n@@ -213,2 +217,2 @@\n-  MethodDataCleaner clean_weak_method_links;\n-  ClassLoaderDataGraph::classes_do(&clean_weak_method_links);\n+  AdjustAndCleanMetadata adjust_and_clean_metadata(thread);\n+  ClassLoaderDataGraph::classes_do(&adjust_and_clean_metadata);\n@@ -3426,1 +3430,2 @@\n-\/\/ to fix up these pointers.\n+\/\/ to fix up these pointers.  MethodData also points to old methods and\n+\/\/ must be cleaned.\n@@ -3429,1 +3434,1 @@\n-void VM_RedefineClasses::AdjustCpoolCacheAndVtable::do_klass(Klass* k) {\n+void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {\n@@ -3434,1 +3439,0 @@\n-  InstanceKlass *the_class = InstanceKlass::cast(_the_class);\n@@ -3437,3 +3441,6 @@\n-  \/\/ array class vtables also\n-  if (k->is_array_klass() && _the_class == SystemDictionary::Object_klass()) {\n-    k->vtable().adjust_method_entries(the_class, &trace_name_printed);\n+  \/\/ array class vtables also. The _has_redefined_Object flag is global.\n+  \/\/ Once the java.lang.Object has been redefined (by the current or one\n+  \/\/ of the previous VM_RedefineClasses operations) we have to always\n+  \/\/ adjust method entries for array classes.\n+  if (k->is_array_klass() && _has_redefined_Object) {\n+    k->vtable().adjust_method_entries(&trace_name_printed);\n@@ -3445,15 +3452,8 @@\n-    \/\/ HotSpot specific optimization! HotSpot does not currently\n-    \/\/ support delegation from the bootstrap class loader to a\n-    \/\/ user-defined class loader. This means that if the bootstrap\n-    \/\/ class loader is the initiating class loader, then it will also\n-    \/\/ be the defining class loader. This also means that classes\n-    \/\/ loaded by the bootstrap class loader cannot refer to classes\n-    \/\/ loaded by a user-defined class loader. Note: a user-defined\n-    \/\/ class loader can delegate to the bootstrap class loader.\n-    \/\/\n-    \/\/ If the current class being redefined has a user-defined class\n-    \/\/ loader as its defining class loader, then we can skip all\n-    \/\/ classes loaded by the bootstrap class loader.\n-    bool is_user_defined = (_the_class->class_loader() != NULL);\n-    if (is_user_defined && ik->class_loader() == NULL) {\n-      return;\n+    \/\/ Clean MethodData of this class's methods so they don't refer to\n+    \/\/ old methods that are no longer running.\n+    Array<Method*>* methods = ik->methods();\n+    int num_methods = methods->length();\n+    for (int index = 0; index < num_methods; ++index) {\n+      if (methods->at(index)->method_data() != NULL) {\n+        methods->at(index)->method_data()->clean_weak_method_links();\n+      }\n@@ -3462,22 +3462,5 @@\n-    \/\/ Fix the vtable embedded in the_class and subclasses of the_class,\n-    \/\/ if one exists. We discard scratch_class and we don't keep an\n-    \/\/ InstanceKlass around to hold obsolete methods so we don't have\n-    \/\/ any other InstanceKlass embedded vtables to update. The vtable\n-    \/\/ holds the Method*s for virtual (but not final) methods.\n-    \/\/ Default methods, or concrete methods in interfaces are stored\n-    \/\/ in the vtable, so if an interface changes we need to check\n-    \/\/ adjust_method_entries() for every InstanceKlass, which will also\n-    \/\/ adjust the default method vtable indices.\n-    \/\/ We also need to adjust any default method entries that are\n-    \/\/ not yet in the vtable, because the vtable setup is in progress.\n-    \/\/ This must be done after we adjust the default_methods and\n-    \/\/ default_vtable_indices for methods already in the vtable.\n-    \/\/ If redefining Unsafe, walk all the vtables looking for entries.\n-    if (ik->vtable_length() > 0 && (_the_class->is_interface()\n-        || _the_class == SystemDictionary::internal_Unsafe_klass()\n-        || ik->is_subtype_of(_the_class))) {\n-      \/\/ ik->vtable() creates a wrapper object; rm cleans it up\n-      ResourceMark rm(_thread);\n-\n-      ik->vtable().adjust_method_entries(the_class, &trace_name_printed);\n-      ik->adjust_default_methods(the_class, &trace_name_printed);\n+    \/\/ Adjust all vtables, default methods and itables, to clean out old methods.\n+    ResourceMark rm(_thread);\n+    if (ik->vtable_length() > 0) {\n+      ik->vtable().adjust_method_entries(&trace_name_printed);\n+      ik->adjust_default_methods(&trace_name_printed);\n@@ -3486,12 +3469,2 @@\n-    \/\/ If the current class has an itable and we are either redefining an\n-    \/\/ interface or if the current class is a subclass of the_class, then\n-    \/\/ we potentially have to fix the itable. If we are redefining an\n-    \/\/ interface, then we have to call adjust_method_entries() for\n-    \/\/ every InstanceKlass that has an itable since there isn't a\n-    \/\/ subclass relationship between an interface and an InstanceKlass.\n-    \/\/ If redefining Unsafe, walk all the itables looking for entries.\n-    if (ik->itable_length() > 0 && (_the_class->is_interface()\n-        || _the_class == SystemDictionary::internal_Unsafe_klass()\n-        || ik->is_subclass_of(_the_class))) {\n-      ResourceMark rm(_thread);\n-      ik->itable().adjust_method_entries(the_class, &trace_name_printed);\n+    if (ik->itable_length() > 0) {\n+      ik->itable().adjust_method_entries(&trace_name_printed);\n@@ -3501,1 +3474,1 @@\n-    \/\/ methods in the_class. We have to update method information in\n+    \/\/ old methods.  We have to update method information in\n@@ -3507,7 +3480,11 @@\n-    \/\/ Special case: if the current class is the_class, then new_cp\n-    \/\/ has already been attached to the_class and old_cp has already\n-    \/\/ been added as a previous version. The new_cp doesn't have any\n-    \/\/ cached references to old methods so it doesn't need to be\n-    \/\/ updated. We can simply start with the previous version(s) in\n-    \/\/ that case.\n-    constantPoolHandle other_cp;\n+    \/\/ Special case: if the current class is being redefined by the current\n+    \/\/ VM_RedefineClasses operation, then new_cp has already been attached\n+    \/\/ to the_class and old_cp has already been added as a previous version.\n+    \/\/ The new_cp doesn't have any cached references to old methods so it\n+    \/\/ doesn't need to be updated and we could optimize by skipping it.\n+    \/\/ However, the current class can be marked as being redefined by another\n+    \/\/ VM_RedefineClasses operation which has already executed its doit_prologue\n+    \/\/ and needs cpcache method entries adjusted. For simplicity, the cpcache\n+    \/\/ update is done unconditionally. It should result in doing nothing for\n+    \/\/ classes being redefined by the current VM_RedefineClasses operation.\n+    \/\/ Method entries in the previous version(s) are adjusted as well.\n@@ -3516,7 +3493,5 @@\n-    if (ik != _the_class) {\n-      \/\/ this klass' constant pool cache may need adjustment\n-      other_cp = constantPoolHandle(ik->constants());\n-      cp_cache = other_cp->cache();\n-      if (cp_cache != NULL) {\n-        cp_cache->adjust_method_entries(the_class, &trace_name_printed);\n-      }\n+    \/\/ this klass' constant pool cache may need adjustment\n+    ConstantPool* other_cp = ik->constants();\n+    cp_cache = other_cp->cache();\n+    if (cp_cache != NULL) {\n+      cp_cache->adjust_method_entries(&trace_name_printed);\n@@ -3531,17 +3506,1 @@\n-        cp_cache->adjust_method_entries(pv_node, &trace_name_printed);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Clean method data for this class\n-void VM_RedefineClasses::MethodDataCleaner::do_klass(Klass* k) {\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    \/\/ Clean MethodData of this class's methods so they don't refer to\n-    \/\/ old methods that are no longer running.\n-    Array<Method*>* methods = ik->methods();\n-    int num_methods = methods->length();\n-    for (int index = 0; index < num_methods; ++index) {\n-      if (methods->at(index)->method_data() != NULL) {\n-        methods->at(index)->method_data()->clean_weak_method_links();\n+        cp_cache->adjust_method_entries(&trace_name_printed);\n@@ -3979,0 +3938,3 @@\n+  \/\/ Set a flag to control and optimize adjusting method entries\n+  _has_redefined_Object |= the_class == SystemDictionary::Object_klass();\n+\n@@ -4203,5 +4165,0 @@\n-  \/\/ Adjust constantpool caches and vtables for all classes\n-  \/\/ that reference methods of the evolved class.\n-  AdjustCpoolCacheAndVtable adjust_cpool_cache_and_vtable(THREAD);\n-  ClassLoaderDataGraph::classes_do(&adjust_cpool_cache_and_vtable);\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":56,"deletions":99,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  \/\/ facility and the AdjustCpoolCacheAndVtable helper:\n+  \/\/ facility and the CheckClass and AdjustAndCleanMetadata helpers.\n@@ -344,4 +344,4 @@\n-  static Method**      _matching_old_methods;\n-  static Method**      _matching_new_methods;\n-  static Method**      _deleted_methods;\n-  static Method**      _added_methods;\n+  static Method**        _matching_old_methods;\n+  static Method**        _matching_new_methods;\n+  static Method**        _deleted_methods;\n+  static Method**        _added_methods;\n@@ -351,1 +351,2 @@\n-  static Klass*          _the_class;\n+  static bool            _has_redefined_Object;\n+  static bool            _has_null_class_loader;\n@@ -355,0 +356,1 @@\n+  Klass*                      _the_class;\n@@ -515,2 +517,2 @@\n-  \/\/ to fix up these pointers.\n-  class AdjustCpoolCacheAndVtable : public KlassClosure {\n+  \/\/ to fix up these pointers and clean MethodData out.\n+  class AdjustAndCleanMetadata : public KlassClosure {\n@@ -519,1 +521,1 @@\n-    AdjustCpoolCacheAndVtable(Thread* t) : _thread(t) {}\n+    AdjustAndCleanMetadata(Thread* t) : _thread(t) {}\n@@ -523,6 +525,0 @@\n-  \/\/ Clean MethodData out\n-  class MethodDataCleaner : public KlassClosure {\n-   public:\n-    MethodDataCleaner() {}\n-    void do_klass(Klass* k);\n-  };\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,5 +225,1 @@\n-          InstanceKlass* holder = old_method->method_holder();\n-          new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-          assert(holder == new_method->method_holder(), \"call after swapping redefined guts\");\n-          assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-          assert(old_method != new_method, \"sanity check\");\n+          new_method = old_method->get_new_method();\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}