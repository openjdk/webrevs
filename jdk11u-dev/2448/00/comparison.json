{"files":[{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4311614\n+  @summary  findComponentAt() should check for isShowing() instead of isVisible()\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+\n+public class FindComponentAtTest {\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Panel aContainer;\n+            Panel bContainer;\n+            Panel cContainer;\n+            Button button = new Button(\"button4\");\n+            Frame frame = new Frame(\"FindComponentAtTest\");\n+\n+            try {\n+                aContainer = new Panel();\n+                bContainer = new Panel();\n+                cContainer = new Panel();\n+                aContainer.setName(\"ACONT\");\n+                bContainer.setName(\"BCONT\");\n+\n+                frame.add(aContainer);\n+\n+                aContainer.add(bContainer);\n+                bContainer.add(cContainer);\n+                cContainer.add(button);\n+\n+                bContainer.setVisible(false);\n+\n+                frame.setSize(200, 200);\n+                frame.setVisible(true);\n+                frame.validate();\n+\n+                System.out.println(\"Test set for FindComponentAt() method.\");\n+                System.out.println(\"aContainer - visible\");\n+                System.out.println(\"bContainer - child of aContainer - is invisible\");\n+                System.out.println(\"cContainer - child of bContainer - is visible\");\n+                System.out.println(\"button4  - child of cContainer - is visible\");\n+                Component comp = cContainer.findComponentAt(\n+                        cContainer.getWidth() \/ 2,\n+                        cContainer.getHeight() \/ 2);\n+\n+                if (comp != null) {\n+                    throw new RuntimeException(\n+                            \"cContainer: Visible component inserted into \"\n+                                    + \"invisible container have found \"\n+                                    + \"by findComponentAt(x, y) method\");\n+                }\n+            } finally {\n+                frame.dispose();\n+            }\n+            System.out.println(\"FindComponentAt Test Succeeded.\");\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Container\/FindComponentAtTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4196100\n+  @summary Make sure findComponentAt() only returns visible components.\n+  @key headful\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import javax.swing.JFrame;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JPanel;\n+\n+public class FindComponentTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            FindComponentFrame findComponentAtTest = new FindComponentFrame();\n+\n+            try {\n+                if (!findComponentAtTest.didItWork()) {\n+                    throw new RuntimeException(\n+                            \"findComponentAt() returned non-visible component\");\n+                }\n+            } finally {\n+                findComponentAtTest.dispose();\n+            }\n+        });\n+    }\n+}\n+\n+\n+class FindComponentFrame extends JFrame {\n+        public FindComponentFrame() {\n+            super(\"FindComponentFrame\");\n+        }\n+\n+        public boolean didItWork() {\n+            setTitle(\"FindComponentTest\");\n+            setSize(new Dimension(200, 200));\n+\n+            JTabbedPane tabbedpane = new JTabbedPane();\n+            setContentPane(tabbedpane);\n+\n+            JPanel panel1 = new JPanel();\n+            panel1.setName(\"Panel 1\");\n+            panel1.setLayout(new BorderLayout());\n+            tabbedpane.add(panel1);\n+            JPanel subPanel = new JPanel();\n+            subPanel.setName(\"Sub-Panel\");\n+            subPanel.setBackground(Color.green);\n+            panel1.add(subPanel); \/\/ add sub panel to 1st tab\n+\n+            JPanel panel2 = new JPanel();\n+            panel2.setName(\"Panel 2\");\n+            tabbedpane.add(panel2);\n+\n+            tabbedpane.setSelectedIndex(1); \/\/ display 2nd tab\n+            setVisible(true);\n+\n+            boolean success = tabbedpane.findComponentAt(50,50)\n+                                        .getName().equals(\"Panel 2\");\n+            return success;\n+        }\n+}\n","filename":"test\/jdk\/java\/awt\/Container\/FindComponentTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,509 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @summary unit test for ability of FocusTraversalPolicyProvider\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.ContainerOrderFocusTraversalPolicy;\n+import java.awt.DefaultFocusTraversalPolicy;\n+import java.awt.EventQueue;\n+import java.awt.FocusTraversalPolicy;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.Window;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.LayoutFocusTraversalPolicy;\n+\n+public class FocusTraversalPolicyProviderTest {\n+    final String errorOrderMessage = \"Test Failed. Traversal Order not correct.\";\n+    final String successStage = \"Test stage completed.Passed.\";\n+\n+    final int n_buttons = 4;\n+    final int jumps = 3 * n_buttons;\n+    Container[] cycle_roots = new Container[3];\n+    Panel[] a_conts = new Panel[cycle_roots.length];\n+    Panel[] b_conts = new Panel[cycle_roots.length];\n+    Component[][] a_buttons = new Component[cycle_roots.length][n_buttons];\n+    Component[][] b_buttons = new Component[cycle_roots.length][n_buttons];\n+\n+    static volatile Frame mainFrame = null;\n+    static volatile Frame frame = null;\n+    static volatile JFrame jframe = null;\n+\n+    static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        FocusTraversalPolicyProviderTest test\n+                = new FocusTraversalPolicyProviderTest();\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(test::init);\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(test::testStages);\n+\n+            EventQueue.invokeAndWait(test::initSwingContInFrame);\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(test::testSwingContInFrame);\n+            \/\/ test for Swing container in java.awt.Frame\n+            System.out.println(\"Test passed.\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (mainFrame != null) mainFrame.dispose();\n+                if (frame != null) frame.dispose();\n+                if (jframe != null) jframe.dispose();\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        mainFrame = new Frame(\"FocusTraversalPolicyProviderTest - main\");\n+        mainFrame.setSize(400, 400);\n+        mainFrame.setLocationRelativeTo(null);\n+        mainFrame.setVisible(true);\n+\n+        for (int i = 0; i < cycle_roots.length; i++) {\n+            cycle_roots[i] = new Panel();\n+            cycle_roots[i].setFocusable(false);\n+            cycle_roots[i].setName(\"root\" + i);\n+            cycle_roots[i].setFocusCycleRoot(true);\n+            cycle_roots[i].setLayout (new GridLayout(1, 2));\n+            mainFrame.add(cycle_roots[i]);\n+\n+            a_conts[i] = new Panel();\n+            a_conts[i].setName(\"ac\" + i);\n+            a_conts[i].setFocusable(false);\n+            cycle_roots[i].add(a_conts[i]);\n+\n+            b_conts[i] = new Panel();\n+            b_conts[i].setName(\"bc\" + i);\n+            b_conts[i].setFocusable(false);\n+            cycle_roots[i].add(b_conts[i]);\n+\n+            for (int j = 0; j < n_buttons; j++){\n+                String name = \"a\" + i + \"x\" + j;\n+                a_buttons[i][j] = new Button(name);\n+                a_buttons[i][j].setName(name);\n+                a_conts[i].add(a_buttons[i][j]);\n+            }\n+\n+            for (int j = 0; j < n_buttons; j++){\n+                String name = \"b\" + i + \"x\" + j;\n+                b_buttons[i][j] = new Button(name);\n+                b_buttons[i][j].setName(name);\n+                b_conts[i].add(b_buttons[i][j]);\n+            }\n+        }\n+\n+        cycle_roots[0].setFocusTraversalPolicy(new DefaultFocusTraversalPolicy());\n+        cycle_roots[1].setFocusTraversalPolicy(new ContainerOrderFocusTraversalPolicy());\n+        cycle_roots[2].setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());\n+    }\n+\n+    public void testStages() {\n+        for (int i = 0; i < cycle_roots.length; i++) {\n+            testStage(cycle_roots[i], a_conts[i], b_conts[i],\n+                    a_buttons[i], b_buttons[i]);\n+        }\n+    }\n+\n+    void testStage(Container aFCR, Container aCont, Container bCont,\n+                   Component[] a_comps, Component[] b_comps) {\n+            System.out.println(\"focus cycle root = \" + aFCR.getName());\n+            System.out.println(\"policy = \" + aFCR.getFocusTraversalPolicy());\n+            System.out.println(\"aContainer = \" + aCont.getName());\n+            System.out.println(\"bContainer = \" + bCont.getName());\n+            System.out.println(\"Both containers are not Providers.\");\n+\n+            Component[] a_comps_backward = revertArray(a_comps);\n+            Component[] b_comps_backward = revertArray(b_comps);\n+\n+            testForwardStage(aFCR, aCont, bCont,\n+                    false, a_comps, false, b_comps);\n+            testBackwardStage(aFCR, aCont, bCont,\n+                    false, a_comps_backward,\n+                    false, b_comps_backward);\n+\n+            System.out.println(\"Both containers are Providers.\");\n+            testForwardStage(aFCR, aCont, bCont,\n+                    true, a_comps, true, b_comps);\n+            testForwardStage(aFCR, aCont, bCont,\n+                             true, shakeArray(a_comps),\n+                             true, shakeArray(b_comps));\n+\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              true, a_comps_backward,\n+                    true, b_comps_backward);\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              true, shakeArray(a_comps_backward),\n+                              true, shakeArray(b_comps_backward));\n+\n+            System.out.println(\"aContainer.isProvider = true. \"\n+                    + \"bContainer.isProvider = false.\");\n+            testForwardStage(aFCR, aCont, bCont,\n+                             true, a_comps, false, b_comps);\n+            testForwardStage(aFCR, aCont, bCont,\n+                             true, shakeArray(a_comps),\n+                    false, b_comps);\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              true, a_comps_backward,\n+                    false, b_comps_backward);\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              true, shakeArray(a_comps_backward),\n+                              false, b_comps_backward);\n+\n+            System.out.println(\"aContainer.isProvider = false. \"\n+                    + \"bContainer.isProvider = true.\");\n+            testForwardStage(aFCR, aCont, bCont,\n+                             false, a_comps,\n+                    true, b_comps);\n+            testForwardStage(aFCR, aCont, bCont,\n+                             false, a_comps,\n+                    true, shakeArray(b_comps));\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              false, a_comps_backward,\n+                    true, b_comps_backward);\n+            testBackwardStage(aFCR, aCont, bCont,\n+                              false, a_comps_backward,\n+                              true, shakeArray(b_comps_backward));\n+\n+            System.out.println(\"Stage completed.\");\n+    }\n+\n+    public void printGoldOrder(Component[] comps) {\n+        String goldOrderStr = \"\";\n+        for (int i =0;i < jumps; i++){\n+            goldOrderStr += \" \" + comps[i].getName();\n+        }\n+        System.out.println(\"GoldOrder: \" + goldOrderStr);\n+    }\n+\n+    public void testForwardStage(Container focusCycleRoot,\n+                                 Container aContainer,\n+                                 Container bContainer,\n+                                 boolean aProvider, Component[] aComps,\n+                                 boolean bProvider, Component[] bComps) {\n+        System.out.println(\"test forward traversal\");\n+        System.out.println(\"\\taProvider = \" + aProvider);\n+        System.out.println(\"\\tbProvider = \" + bProvider);\n+        Component[] goldOrder = new Component[2*aComps.length + bComps.length];\n+        System.arraycopy(aComps, 0, goldOrder, 0, aComps.length);\n+        System.arraycopy(bComps, 0, goldOrder,\n+                aComps.length, bComps.length);\n+        System.arraycopy(aComps, 0, goldOrder,\n+                aComps.length + bComps.length,\n+                         aComps.length);\n+        printGoldOrder(goldOrder);\n+\n+        String jumpStr = \"\";\n+        aContainer.setFocusTraversalPolicyProvider(aProvider);\n+        aContainer.setFocusTraversalPolicy(\n+            new ArrayOrderFocusTraversalPolicy(aContainer, aComps));\n+        bContainer.setFocusTraversalPolicyProvider(bProvider);\n+        bContainer.setFocusTraversalPolicy(\n+            new ArrayOrderFocusTraversalPolicy(bContainer, bComps));\n+        FocusTraversalPolicy policy = focusCycleRoot.getFocusTraversalPolicy();\n+        System.out.println(\"policy=\" + policy);\n+        Component current = policy.getFirstComponent(focusCycleRoot);\n+\n+        for (int i = 0;i<jumps;i++){\n+            jumpStr += \" \" + current.getName();\n+            if (current != goldOrder[i]) {\n+                System.out.println(\"i=\" + i + \" label = \"+ current.getName()\n+                               + \" i%8= \" + i%goldOrder.length );\n+                throw new RuntimeException(errorOrderMessage);\n+            }\n+            System.out.println(\"getComponentAfter() on \" + focusCycleRoot + \", \" + current);\n+            current = policy.getComponentAfter(focusCycleRoot, current);\n+            System.out.println(\"RealOrder :\" + jumpStr);\n+        }\n+        System.out.println(successStage);\n+    }\n+\n+    public void testBackwardStage(Container focusCycleRoot,\n+                                  Container aContainer,\n+                                  Container bContainer,\n+                                  boolean aProvider, Component[] aComps,\n+                                  boolean bProvider, Component[] bComps)\n+    {\n+        System.out.println(\"test backward traversal\");\n+        System.out.println(\"\\taProvider = \" + aProvider);\n+        System.out.println(\"\\tbProvider = \" + bProvider);\n+        Component[] goldOrder = new Component[2*bComps.length + bComps.length];\n+        System.arraycopy(bComps, 0, goldOrder, 0, bComps.length);\n+        System.arraycopy(aComps, 0, goldOrder, bComps.length, aComps.length);\n+        System.arraycopy(bComps, 0, goldOrder,\n+                aComps.length + bComps.length, bComps.length);\n+        printGoldOrder(goldOrder);\n+\n+        String jumpStr = \"\";\n+        aContainer.setFocusTraversalPolicyProvider(aProvider);\n+        aContainer.setFocusTraversalPolicy(\n+            new ArrayOrderFocusTraversalPolicy(aContainer, revertArray(aComps)));\n+        bContainer.setFocusTraversalPolicyProvider(bProvider);\n+        bContainer.setFocusTraversalPolicy(\n+            new ArrayOrderFocusTraversalPolicy(bContainer, revertArray(bComps)));\n+        FocusTraversalPolicy policy = focusCycleRoot.getFocusTraversalPolicy();\n+        System.out.println(\"policy=\" + policy);\n+        Component current = policy.getLastComponent(focusCycleRoot);\n+\n+        for (int i = 0;i<jumps;i++){\n+            jumpStr += \" \" + current.getName();\n+            if (current != goldOrder[i]) {\n+                System.out.println(\"i=\" + i + \" label = \"+ current.getName());\n+                throw new RuntimeException(errorOrderMessage);\n+            }\n+            System.out.println(\"getComponentBefore() on \"\n+                    + focusCycleRoot.getName() + \", \" + current.getName());\n+            current = policy.getComponentBefore(focusCycleRoot, current);\n+            System.out.println(\"RealOrder :\" + jumpStr);\n+        }\n+        System.out.println(successStage);\n+    }\n+\n+    Component[] shakeArray(Component[] comps) {\n+        Component[] new_comps = new Component[comps.length];\n+        System.arraycopy(comps, 0, new_comps, 0, comps.length);\n+        new_comps[0] = comps[1];\n+        new_comps[1] = comps[0];\n+        return new_comps;\n+    }\n+\n+    Component[] revertArray(Component[] comps) {\n+        Component[] new_comps = new Component[comps.length];\n+        for (int i=0; i < comps.length; i++) {\n+            new_comps[i] = comps[comps.length - 1 - i];\n+        }\n+\n+        return new_comps;\n+    }\n+\n+    public void initSwingContInFrame()  {\n+        System.out.println(\"test Swing policy provider in AWT Frame.\");\n+\n+        jframe = new JFrame(\"FocusTraversalPolicyProviderTest - JFrame\");\n+        jframe.setName(\"JFrame\");\n+        JPanel panel1 = createPanel();\n+        jframe.getContentPane().add(panel1);\n+\n+        frame = new Frame(\"FocusTraversalPolicyProviderTest - Frame\");\n+        frame.setName(\"Frame\");\n+        JPanel panel2 = createPanel();\n+        panel2.setFocusTraversalPolicyProvider(true);\n+        panel2.setFocusTraversalPolicy(jframe.getFocusTraversalPolicy());\n+        frame.add(panel2);\n+\n+        jframe.pack();\n+        jframe.setVisible(true);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void testSwingContInFrame() {\n+        FocusTraversalPolicy policy = frame.getFocusTraversalPolicy();\n+        FocusTraversalPolicy jpolicy = jframe.getFocusTraversalPolicy();\n+\n+        System.out.println(\"policy = \" + policy);\n+        System.out.println(\"jpolicy = \" + jpolicy);\n+\n+        assertEquals(\"Different default components.\",\n+                jpolicy.getDefaultComponent(jframe),\n+                policy.getDefaultComponent(frame));\n+\n+        assertEquals(\"Different first components.\",\n+                jpolicy.getFirstComponent(jframe),\n+                policy.getFirstComponent(frame));\n+\n+        assertEquals(\"Different last components.\",\n+                jpolicy.getLastComponent(jframe),\n+                policy.getLastComponent(frame));\n+\n+        System.out.println(\"test forward traversal order.\");\n+\n+        Component jcur = jpolicy.getFirstComponent(jframe);\n+        Component cur = jpolicy.getFirstComponent(frame);\n+\n+        for (int i = 0; i < 2 * n_buttons; i++) {\n+            assertEquals(\"Wrong sequence (step=\" + i + \")\",\n+                    jcur, cur);\n+            jcur = jpolicy.getComponentAfter(jframe, jcur);\n+            cur = policy.getComponentAfter(frame, cur);\n+        }\n+\n+        System.out.println(\"test backward traversal order.\");\n+\n+        jcur = jpolicy.getLastComponent(jframe);\n+        cur = jpolicy.getLastComponent(frame);\n+\n+        for (int i = 0; i < 2 * n_buttons; i++) {\n+            assertEquals(\"Wrong sequence (step=\" + i + \")\",\n+                    jcur, cur);\n+            jcur = jpolicy.getComponentBefore(jframe, jcur);\n+            cur = policy.getComponentBefore(frame, cur);\n+        }\n+    }\n+\n+    public void assertEquals(String msg, Component expected, Component actual) {\n+        if (expected == null && actual != null\n+            || actual == null && expected != null)\n+        {\n+            throw new RuntimeException(msg + \"(expected=\" + expected\n+                                       + \", actual=\" + actual + \")\");\n+        }\n+\n+        String expected_name = expected.getName();\n+        String actual_name = actual.getName();\n+\n+        if ((expected_name != null && !expected_name.equals(actual_name))\n+            || (actual_name != null && !actual_name.equals(expected_name)))\n+        {\n+            throw new RuntimeException(msg + \"(expected_name=\" + expected_name\n+                                       + \", actual_name=\" + actual_name + \")\");\n+        }\n+    }\n+\n+    public JPanel createPanel() {\n+        JPanel pane = new JPanel();\n+        pane.setName(\"jpanel\");\n+        for (int i = 0; i < n_buttons; i++) {\n+            JButton btn = new JButton(\"jbtn\" + i);\n+            btn.setName(\"jbtn\" + i);\n+            pane.add(btn);\n+        }\n+        return pane;\n+    }\n+}\n+\n+class ArrayOrderFocusTraversalPolicy extends FocusTraversalPolicy {\n+\n+    final Component[] comps;\n+    final Container cont;\n+\n+    public ArrayOrderFocusTraversalPolicy(Container aCont, Component[] aComps) {\n+        if (aCont == null) {\n+            throw new NullPointerException(\"aCont is null.\");\n+        }\n+        cont = aCont;\n+        comps = new Component[aComps.length];\n+        for (int i = 0; i < comps.length; i++) {\n+            comps[i] = aComps[i];\n+        }\n+    }\n+\n+    private void checkContainer(Container aCont) {\n+        if (aCont != cont) {\n+            System.err.println(\"aCont = \" + aCont);\n+            System.err.println(\"cont = \" + cont);\n+            throw new IllegalArgumentException(\n+                    \"Policy is not registered for this container.\");\n+        }\n+    }\n+\n+    private int findIndex(Component aComp) {\n+        for (int i = 0; i < comps.length; i++) {\n+            if (aComp == comps[i]) {\n+                return i;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public Component getComponentAfter(Container focusCycleRoot,\n+                                       Component aComponent) {\n+        checkContainer(focusCycleRoot);\n+\n+        int current_index = findIndex(aComponent);\n+        if (current_index < 0) {\n+            return null;\n+        }\n+\n+        current_index++;\n+\n+        if (current_index < comps.length) {\n+            return comps[current_index];\n+        }\n+\n+        if (focusCycleRoot.isFocusCycleRoot()) {\n+            return getFirstComponent(focusCycleRoot);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Component getComponentBefore(Container focusCycleRoot,\n+                                        Component aComponent) {\n+        checkContainer(focusCycleRoot);\n+\n+        int current_index = findIndex(aComponent);\n+        if (current_index < 0) {\n+            return null;\n+        }\n+\n+        current_index--;\n+\n+        if (current_index >= 0) {\n+            return comps[current_index];\n+        }\n+\n+        if (focusCycleRoot.isFocusCycleRoot()) {\n+            return getLastComponent(focusCycleRoot);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Component getFirstComponent(Container focusCycleRoot) {\n+        checkContainer(focusCycleRoot);\n+        return comps[0];\n+    }\n+\n+    public Component getLastComponent(Container focusCycleRoot) {\n+        checkContainer(focusCycleRoot);\n+        return comps[comps.length - 1];\n+    }\n+\n+    public Component getDefaultComponent(Container focusCycleRoot) {\n+        return getFirstComponent(focusCycleRoot);\n+    }\n+\n+    public Component getInitialComponent(Window window) {\n+        throw new UnsupportedOperationException(\"getInitialComponent() is not supported.\");\n+    }\n+\n+    public Component[] getCycle(Container focusCycleRoot) {\n+        checkContainer(focusCycleRoot);\n+        Component[] temp = new Component[comps.length];\n+        System.arraycopy(comps, 0, temp, 0, comps.length);\n+        return temp;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Container\/FocusTraversalPolicyProviderTest.java","additions":509,"deletions":0,"binary":false,"changes":509,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @summary unit test for ability of FocusTraversalPolicyProvider\n+*\/\n+\n+import java.awt.Container;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+\n+public class PropertyEventsTest implements PropertyChangeListener {\n+    final String PROPERTY = \"focusTraversalPolicyProvider\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        new PropertyEventsTest().start();\n+    }\n+\n+    public void start () {\n+        Container c1 = new Container();\n+        c1.addPropertyChangeListener(PROPERTY, this);\n+\n+        assertEquals(\"Container shouldn't be a provider by default\",\n+                     false, c1.isFocusTraversalPolicyProvider());\n+\n+        prepareForEvent(false, true);\n+        c1.setFocusTraversalPolicyProvider(true);\n+        assertEventOccured();\n+        assertEquals(\"Policy provider property was not set.\",\n+                     true, c1.isFocusTraversalPolicyProvider());\n+\n+        prepareForEvent(true, false);\n+        c1.setFocusTraversalPolicyProvider(false);\n+        assertEventOccured();\n+        assertEquals(\"Policy provider property was not reset.\",\n+                     false, c1.isFocusTraversalPolicyProvider());\n+\n+        prepareForEvent(false, true);\n+        c1.setFocusCycleRoot(true);\n+        assertEventMissed();\n+        assertEquals(\"Cycle root shouldn't be a policy provider.\",\n+                     false, c1.isFocusTraversalPolicyProvider());\n+\n+        prepareForEvent(true, false);\n+        c1.setFocusCycleRoot(false);\n+        assertEventMissed();\n+        assertEquals(\"setFocusCycleRoot(false) should reset \"\n+                        + \"policy provider property.\",\n+                     false, c1.isFocusTraversalPolicyProvider());\n+\n+        System.out.println(\"Test passed.\");\n+    }\/\/ start()\n+\n+    void assertEquals(String msg, boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            Assert(msg + \"(expected=\" + expected + \", actual=\" + actual + \")\");\n+        }\n+    }\n+\n+    void assertEquals(String msg, Object expected, Object actual) {\n+        if ((expected != null && !expected.equals(actual))\n+            || (actual != null && !actual.equals(expected)))\n+        {\n+            Assert(msg + \"(expected=\" + expected + \", actual=\" + actual + \")\");\n+        }\n+    }\n+\n+    void Assert(String msg) {\n+        throw new RuntimeException(msg);\n+    }\n+\n+    void prepareForEvent(boolean old_val, boolean new_val) {\n+        property_change_fired = false;\n+        expected_new_value = Boolean.valueOf(new_val);\n+        expected_old_value = Boolean.valueOf(old_val);\n+    }\n+\n+    void assertEventOccured() {\n+        if (!property_change_fired) {\n+            Assert(\"Property Change Event missed.\");\n+        }\n+    }\n+\n+    void assertEventMissed() {\n+        if (property_change_fired) {\n+            Assert(\"Unexpected property change event.\");\n+        }\n+    }\n+\n+    boolean property_change_fired;\n+    Boolean expected_new_value;\n+    Boolean expected_old_value;\n+\n+    public void propertyChange(PropertyChangeEvent e) {\n+        System.out.println(\"PropertyChangeEvent[property=\" + e.getPropertyName()\n+                       + \", new=\" + e.getNewValue()\n+                       + \", old=\" + e.getOldValue() + \"]\");\n+\n+        assertEquals(\"Wrong proeprty name.\",\n+                PROPERTY, e.getPropertyName());\n+        assertEquals(\"Wrong new value.\",\n+                expected_new_value, e.getNewValue());\n+        assertEquals(\"Wrong old value.\",\n+                expected_old_value, e.getOldValue());\n+        property_change_fired = true;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Container\/PropertyEventsTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}