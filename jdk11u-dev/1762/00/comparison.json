{"files":[{"patch":"@@ -109,111 +109,0 @@\n-\n-    \/* This class is used to match an ObjectName against a pattern. *\/\n-    private final static class ObjectNamePattern {\n-        private final String[] keys;\n-        private final String[] values;\n-        private final String   properties;\n-        private final boolean  isPropertyListPattern;\n-        private final boolean  isPropertyValuePattern;\n-\n-        \/**\n-         * The ObjectName pattern against which ObjectNames are matched.\n-         **\/\n-        public final ObjectName pattern;\n-\n-        \/**\n-         * Builds a new ObjectNamePattern object from an ObjectName pattern.\n-         * @param pattern The ObjectName pattern under examination.\n-         **\/\n-        public ObjectNamePattern(ObjectName pattern) {\n-            this(pattern.isPropertyListPattern(),\n-                 pattern.isPropertyValuePattern(),\n-                 pattern.getCanonicalKeyPropertyListString(),\n-                 pattern.getKeyPropertyList(),\n-                 pattern);\n-        }\n-\n-        \/**\n-         * Builds a new ObjectNamePattern object from an ObjectName pattern\n-         * constituents.\n-         * @param propertyListPattern pattern.isPropertyListPattern().\n-         * @param propertyValuePattern pattern.isPropertyValuePattern().\n-         * @param canonicalProps pattern.getCanonicalKeyPropertyListString().\n-         * @param keyPropertyList pattern.getKeyPropertyList().\n-         * @param pattern The ObjectName pattern under examination.\n-         **\/\n-        ObjectNamePattern(boolean propertyListPattern,\n-                          boolean propertyValuePattern,\n-                          String canonicalProps,\n-                          Map<String,String> keyPropertyList,\n-                          ObjectName pattern) {\n-            this.isPropertyListPattern = propertyListPattern;\n-            this.isPropertyValuePattern = propertyValuePattern;\n-            this.properties = canonicalProps;\n-            final int len = keyPropertyList.size();\n-            this.keys   = new String[len];\n-            this.values = new String[len];\n-            int i = 0;\n-            for (Map.Entry<String,String> entry : keyPropertyList.entrySet()) {\n-                keys[i]   = entry.getKey();\n-                values[i] = entry.getValue();\n-                i++;\n-            }\n-            this.pattern = pattern;\n-        }\n-\n-        \/**\n-         * Return true if the given ObjectName matches the ObjectName pattern\n-         * for which this object has been built.\n-         * WARNING: domain name is not considered here because it is supposed\n-         *          not to be wildcard when called. PropertyList is also\n-         *          supposed not to be zero-length.\n-         * @param name The ObjectName we want to match against the pattern.\n-         * @return true if <code>name<\/code> matches the pattern.\n-         **\/\n-        public boolean matchKeys(ObjectName name) {\n-            \/\/ If key property value pattern but not key property list\n-            \/\/ pattern, then the number of key properties must be equal\n-            \/\/\n-            if (isPropertyValuePattern &&\n-                !isPropertyListPattern &&\n-                (name.getKeyPropertyList().size() != keys.length))\n-                return false;\n-\n-            \/\/ If key property value pattern or key property list pattern,\n-            \/\/ then every property inside pattern should exist in name\n-            \/\/\n-            if (isPropertyValuePattern || isPropertyListPattern) {\n-                for (int i = keys.length - 1; i >= 0 ; i--) {\n-                    \/\/ Find value in given object name for key at current\n-                    \/\/ index in receiver\n-                    \/\/\n-                    String v = name.getKeyProperty(keys[i]);\n-                    \/\/ Did we find a value for this key ?\n-                    \/\/\n-                    if (v == null) return false;\n-                    \/\/ If this property is ok (same key, same value), go to next\n-                    \/\/\n-                    if (isPropertyValuePattern &&\n-                        pattern.isPropertyValuePattern(keys[i])) {\n-                        \/\/ wildmatch key property values\n-                        \/\/ values[i] is the pattern;\n-                        \/\/ v is the string\n-                        if (Util.wildmatch(v,values[i]))\n-                            continue;\n-                        else\n-                            return false;\n-                    }\n-                    if (v.equals(values[i])) continue;\n-                    return false;\n-                }\n-                return true;\n-            }\n-\n-            \/\/ If no pattern, then canonical names must be equal\n-            \/\/\n-            final String p1 = name.getCanonicalKeyPropertyListString();\n-            final String p2 = properties;\n-            return (p1.equals(p2));\n-        }\n-    }\n-\n@@ -222,3 +111,1 @@\n-     * result set for the given ObjectNamePattern\n-     * Do not check whether the domains match (only check for matching\n-     * key property lists - see <i>matchKeys()<\/i>)\n+     * result set for the given pattern\n@@ -228,1 +115,1 @@\n-                                final ObjectNamePattern pattern) {\n+                                final ObjectName pattern) {\n@@ -233,1 +120,1 @@\n-                if (pattern.matchKeys(on)) result.add(no);\n+                if (pattern.apply(ObjectName.getInstance(on))) result.add(no);\n@@ -523,1 +410,1 @@\n-        else name = pattern;\n+        else name = ObjectName.getInstance(pattern);\n@@ -547,2 +434,1 @@\n-            final ObjectNamePattern namePattern =\n-                (allNames?null:new ObjectNamePattern(name));\n+            final String dom2Match = name.getDomain();\n@@ -551,1 +437,1 @@\n-            if (name.getDomain().length() == 0) {\n+            if (dom2Match.length() == 0) {\n@@ -556,1 +442,1 @@\n-                    addAllMatching(moiTb, result, namePattern);\n+                    addAllMatching(moiTb, result, Util.newObjectName(domain + name.getCanonicalName()));\n@@ -561,1 +447,1 @@\n-                final Map<String,NamedObject> moiTb = domainTb.get(name.getDomain());\n+                final Map<String,NamedObject> moiTb = domainTb.get(dom2Match);\n@@ -566,1 +452,1 @@\n-                    addAllMatching(moiTb, result, namePattern);\n+                    addAllMatching(moiTb, result, name);\n@@ -571,1 +457,0 @@\n-            final String dom2Match = name.getDomain();\n@@ -578,1 +463,1 @@\n-                        addAllMatching(moiTb, result, namePattern);\n+                        addAllMatching(moiTb, result, name);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Repository.java","additions":10,"deletions":125,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    private static boolean wildmatch(final String str, final String pat,\n+    public static boolean wildmatch(final String str, final String pat,\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2020,0 +2020,3 @@\n+        boolean useOptimized = (this.getClass() == ObjectName.class) &&\n+                               (name.getClass() == ObjectName.class);\n+\n@@ -2024,0 +2027,4 @@\n+            if (useOptimized) {\n+                return Util.wildmatch(name._canonicalName, _canonicalName,\n+                           0, name.getDomainLength(), 0, getDomainLength());\n+            }\n@@ -2026,0 +2033,4 @@\n+        if (useOptimized) {\n+            return getDomainLength() == name.getDomainLength() &&\n+                   _canonicalName.regionMatches(0, name._canonicalName, 0, getDomainLength());\n+        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ObjectName.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4716807\n+ * @bug 4716807 8299234\n@@ -78,0 +78,4 @@\n+\n+        { \"*:k=a\", \"d:k=a\" },\n+        { \"*b*:k=a\", \"abc:k=a\" },\n+        { \"?b?:k=a\", \"abc:k=a\" },\n@@ -118,0 +122,4 @@\n+\n+        { \"?:k=a\", \"dd:k=a\" },\n+        { \"*b*:k=a\", \"adc:k=a\" },\n+        { \"?b?:k=a\", \"adc:k=a\" },\n","filename":"test\/jdk\/javax\/management\/ObjectName\/ApplyWildcardTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}