{"files":[{"patch":"@@ -277,1 +277,1 @@\n-vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8208255 generic-all\n+vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8257761 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.management.MemoryUsage;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.ManagementFactory;\n@@ -32,0 +35,2 @@\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n@@ -68,0 +73,21 @@\n+    private static final Optional<MemoryPoolMXBean> NON_SEGMENTED_CODE_CACHE_POOL;\n+    private static final Optional<MemoryPoolMXBean> NON_NMETHODS_POOL;\n+    private static final Optional<MemoryPoolMXBean> PROFILED_NMETHODS_POOL;\n+    private static final Optional<MemoryPoolMXBean> NON_PROFILED_NMETHODS_POOL ;\n+\n+    \/\/ Limit numbers are arbitrary, feel free to change if arguably necessary\n+    private static final int NON_SEGMENTED_CACHE_ALLOWANCE = 2_000_000;\n+    private static final int SEGMENTED_CACHE_ALLOWANCE = 1_000_000;\n+\n+    static {\n+        var pools = ManagementFactory.getMemoryPoolMXBeans();\n+        NON_SEGMENTED_CODE_CACHE_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeCache\")).findFirst();\n+        NON_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-nmethods'\")).findFirst();\n+        PROFILED_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'profiled nmethods'\")).findFirst();\n+        NON_PROFILED_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-profiled nmethods'\")).findFirst();\n+    }\n+\n@@ -72,0 +98,16 @@\n+    private static final boolean isCodeCacheEffectivelyFull() {\n+        var result = new Object() { boolean value = false; };\n+\n+        BiConsumer<MemoryPoolMXBean, Integer> check = (pool, limit) -> {\n+            var usage = pool.getUsage();\n+            result.value |= usage.getMax() - usage.getUsed() < limit;\n+        };\n+\n+        NON_SEGMENTED_CODE_CACHE_POOL.ifPresent(pool -> check.accept(pool, NON_SEGMENTED_CACHE_ALLOWANCE));\n+        NON_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+        PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+        NON_PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+\n+        return result.value;\n+    }\n+\n@@ -92,1 +134,8 @@\n-        for ( int i = nextInt(MAX_CYCLES); i > 0; i-- ) {\n+        final int cyclesToBuild = nextInt(MAX_CYCLES);\n+        for ( int i = 0; i < cyclesToBuild; i++) {\n+            if (isCodeCacheEffectivelyFull()) {\n+                Env.traceNormal(\"Not enought code cache to build up MH sequences anymore. \" +\n+                        \" Has only been able to achieve \" + i + \" out of \" + cyclesToBuild);\n+                break;\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/share\/MHTransformationGen.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"}]}