{"files":[{"patch":"@@ -609,1 +609,1 @@\n-  Method* m = get_interesting_method_entry(NULL);\n+  Method* m = get_interesting_method_entry();\n@@ -619,1 +619,1 @@\n-Method* ConstantPoolCacheEntry::get_interesting_method_entry(Klass* k) {\n+Method* ConstantPoolCacheEntry::get_interesting_method_entry() {\n@@ -640,3 +640,1 @@\n-  if (m == NULL || !m->is_method() || (k != NULL && m->method_holder() != k)) {\n-    \/\/ robustness for above sanity checks or method is not in\n-    \/\/ the interesting class\n+  if (m == NULL || !m->is_method()) {\n@@ -645,1 +643,0 @@\n-  \/\/ the method is in the interesting class so the entry is interesting\n@@ -804,1 +801,1 @@\n-void ConstantPoolCache::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n+void ConstantPoolCache::adjust_method_entries(bool * trace_name_printed) {\n@@ -807,1 +804,1 @@\n-    Method* old_method = entry->get_interesting_method_entry(holder);\n+    Method* old_method = entry->get_interesting_method_entry();\n@@ -816,5 +813,1 @@\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n@@ -828,1 +821,1 @@\n-    if (entry_at(i)->get_interesting_method_entry(NULL) != NULL &&\n+    if (entry_at(i)->get_interesting_method_entry() != NULL &&\n@@ -838,1 +831,1 @@\n-    if (entry_at(i)->get_interesting_method_entry(NULL) != NULL) {\n+    if (entry_at(i)->get_interesting_method_entry() != NULL) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  Method* get_interesting_method_entry(Klass* k);\n+  Method* get_interesting_method_entry();\n@@ -509,1 +509,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool* trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2952,1 +2952,1 @@\n-void InstanceKlass::adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed) {\n+void InstanceKlass::adjust_default_methods(bool* trace_name_printed) {\n@@ -2957,1 +2957,1 @@\n-      if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+      if (old_method == NULL || !old_method->is_old()) {\n@@ -2961,6 +2961,1 @@\n-\n-      Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-      assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-      assert(old_method != new_method, \"sanity check\");\n-\n+      Method* new_method = old_method->get_new_method();\n@@ -2968,0 +2963,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1158,1 +1158,1 @@\n-  void adjust_default_methods(InstanceKlass* holder, bool* trace_name_printed);\n+  void adjust_default_methods(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -967,1 +967,1 @@\n-void klassVtable::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n+void klassVtable::adjust_method_entries(bool * trace_name_printed) {\n@@ -971,1 +971,1 @@\n-    if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+    if (old_method == NULL || !old_method->is_old()) {\n@@ -976,5 +976,1 @@\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n@@ -982,0 +978,1 @@\n+\n@@ -1297,1 +1294,1 @@\n-void klassItable::adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed) {\n+void klassItable::adjust_method_entries(bool * trace_name_printed) {\n@@ -1302,1 +1299,1 @@\n-    if (old_method == NULL || old_method->method_holder() != holder || !old_method->is_old()) {\n+    if (old_method == NULL || !old_method->is_old()) {\n@@ -1306,6 +1303,1 @@\n-\n-    Method* new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-    assert(old_method != new_method, \"sanity check\");\n-\n+    Method* new_method = old_method->get_new_method();\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n@@ -325,1 +325,1 @@\n-  void adjust_method_entries(InstanceKlass* holder, bool * trace_name_printed);\n+  void adjust_method_entries(bool* trace_name_printed);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,4 +62,5 @@\n-int         VM_RedefineClasses::_matching_methods_length = 0;\n-int         VM_RedefineClasses::_deleted_methods_length  = 0;\n-int         VM_RedefineClasses::_added_methods_length    = 0;\n-Klass*      VM_RedefineClasses::_the_class = NULL;\n+int       VM_RedefineClasses::_matching_methods_length = 0;\n+int       VM_RedefineClasses::_deleted_methods_length  = 0;\n+int       VM_RedefineClasses::_added_methods_length    = 0;\n+bool      VM_RedefineClasses::_has_redefined_Object = false;\n+bool      VM_RedefineClasses::_has_null_class_loader = false;\n@@ -76,0 +77,3 @@\n+  _the_class = NULL;\n+  _has_redefined_Object = false;\n+  _has_null_class_loader = false;\n@@ -210,1 +214,2 @@\n-  \/\/ Clean out MethodData pointing to old Method*\n+  \/\/ Adjust constantpool caches and vtables for all classes\n+  \/\/ that reference methods of the evolved classes.\n@@ -213,2 +218,2 @@\n-  MethodDataCleaner clean_weak_method_links;\n-  ClassLoaderDataGraph::classes_do(&clean_weak_method_links);\n+  AdjustAndCleanMetadata adjust_and_clean_metadata(thread);\n+  ClassLoaderDataGraph::classes_do(&adjust_and_clean_metadata);\n@@ -3426,1 +3431,2 @@\n-\/\/ to fix up these pointers.\n+\/\/ to fix up these pointers.  MethodData also points to old methods and\n+\/\/ must be cleaned.\n@@ -3429,1 +3435,1 @@\n-void VM_RedefineClasses::AdjustCpoolCacheAndVtable::do_klass(Klass* k) {\n+void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {\n@@ -3434,1 +3440,0 @@\n-  InstanceKlass *the_class = InstanceKlass::cast(_the_class);\n@@ -3438,2 +3443,2 @@\n-  if (k->is_array_klass() && _the_class == SystemDictionary::Object_klass()) {\n-    k->vtable().adjust_method_entries(the_class, &trace_name_printed);\n+  if (k->is_array_klass() && _has_redefined_Object) {\n+    k->vtable().adjust_method_entries(&trace_name_printed);\n@@ -3445,0 +3450,10 @@\n+    \/\/ Clean MethodData of this class's methods so they don't refer to\n+    \/\/ old methods that are no longer running.\n+    Array<Method*>* methods = ik->methods();\n+    int num_methods = methods->length();\n+    for (int index = 0; index < num_methods; ++index) {\n+      if (methods->at(index)->method_data() != NULL) {\n+        methods->at(index)->method_data()->clean_weak_method_links();\n+      }\n+    }\n+\n@@ -3457,2 +3472,1 @@\n-    bool is_user_defined = (_the_class->class_loader() != NULL);\n-    if (is_user_defined && ik->class_loader() == NULL) {\n+    if (!_has_null_class_loader && ik->class_loader() == NULL) {\n@@ -3462,22 +3476,5 @@\n-    \/\/ Fix the vtable embedded in the_class and subclasses of the_class,\n-    \/\/ if one exists. We discard scratch_class and we don't keep an\n-    \/\/ InstanceKlass around to hold obsolete methods so we don't have\n-    \/\/ any other InstanceKlass embedded vtables to update. The vtable\n-    \/\/ holds the Method*s for virtual (but not final) methods.\n-    \/\/ Default methods, or concrete methods in interfaces are stored\n-    \/\/ in the vtable, so if an interface changes we need to check\n-    \/\/ adjust_method_entries() for every InstanceKlass, which will also\n-    \/\/ adjust the default method vtable indices.\n-    \/\/ We also need to adjust any default method entries that are\n-    \/\/ not yet in the vtable, because the vtable setup is in progress.\n-    \/\/ This must be done after we adjust the default_methods and\n-    \/\/ default_vtable_indices for methods already in the vtable.\n-    \/\/ If redefining Unsafe, walk all the vtables looking for entries.\n-    if (ik->vtable_length() > 0 && (_the_class->is_interface()\n-        || _the_class == SystemDictionary::internal_Unsafe_klass()\n-        || ik->is_subtype_of(_the_class))) {\n-      \/\/ ik->vtable() creates a wrapper object; rm cleans it up\n-      ResourceMark rm(_thread);\n-\n-      ik->vtable().adjust_method_entries(the_class, &trace_name_printed);\n-      ik->adjust_default_methods(the_class, &trace_name_printed);\n+    \/\/ Adjust all vtables, default methods and itables, to clean out old methods.\n+    ResourceMark rm(_thread);\n+    if (ik->vtable_length() > 0) {\n+      ik->vtable().adjust_method_entries(&trace_name_printed);\n+      ik->adjust_default_methods(&trace_name_printed);\n@@ -3486,12 +3483,2 @@\n-    \/\/ If the current class has an itable and we are either redefining an\n-    \/\/ interface or if the current class is a subclass of the_class, then\n-    \/\/ we potentially have to fix the itable. If we are redefining an\n-    \/\/ interface, then we have to call adjust_method_entries() for\n-    \/\/ every InstanceKlass that has an itable since there isn't a\n-    \/\/ subclass relationship between an interface and an InstanceKlass.\n-    \/\/ If redefining Unsafe, walk all the itables looking for entries.\n-    if (ik->itable_length() > 0 && (_the_class->is_interface()\n-        || _the_class == SystemDictionary::internal_Unsafe_klass()\n-        || ik->is_subclass_of(_the_class))) {\n-      ResourceMark rm(_thread);\n-      ik->itable().adjust_method_entries(the_class, &trace_name_printed);\n+    if (ik->itable_length() > 0) {\n+      ik->itable().adjust_method_entries(&trace_name_printed);\n@@ -3501,1 +3488,1 @@\n-    \/\/ methods in the_class. We have to update method information in\n+    \/\/ old methods.  We have to update method information in\n@@ -3507,1 +3494,1 @@\n-    \/\/ Special case: if the current class is the_class, then new_cp\n+    \/\/ Special case: if the current class being redefined, then new_cp\n@@ -3516,1 +3503,1 @@\n-    if (ik != _the_class) {\n+    if (!ik->is_being_redefined()) {\n@@ -3521,1 +3508,1 @@\n-        cp_cache->adjust_method_entries(the_class, &trace_name_printed);\n+        cp_cache->adjust_method_entries(&trace_name_printed);\n@@ -3531,17 +3518,1 @@\n-        cp_cache->adjust_method_entries(pv_node, &trace_name_printed);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Clean method data for this class\n-void VM_RedefineClasses::MethodDataCleaner::do_klass(Klass* k) {\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    \/\/ Clean MethodData of this class's methods so they don't refer to\n-    \/\/ old methods that are no longer running.\n-    Array<Method*>* methods = ik->methods();\n-    int num_methods = methods->length();\n-    for (int index = 0; index < num_methods; ++index) {\n-      if (methods->at(index)->method_data() != NULL) {\n-        methods->at(index)->method_data()->clean_weak_method_links();\n+        cp_cache->adjust_method_entries(&trace_name_printed);\n@@ -3979,0 +3950,4 @@\n+  \/\/ Set some flags to control and optimize adjusting method entries\n+  _has_redefined_Object |= the_class == SystemDictionary::Object_klass();\n+  _has_null_class_loader |= the_class->class_loader() == NULL;\n+\n@@ -4203,5 +4178,0 @@\n-  \/\/ Adjust constantpool caches and vtables for all classes\n-  \/\/ that reference methods of the evolved class.\n-  AdjustCpoolCacheAndVtable adjust_cpool_cache_and_vtable(THREAD);\n-  ClassLoaderDataGraph::classes_do(&adjust_cpool_cache_and_vtable);\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":44,"deletions":74,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  \/\/ facility and the AdjustCpoolCacheAndVtable helper:\n+  \/\/ facility and the CheckClass and AdjustAndCleanMetadata helpers.\n@@ -344,4 +344,4 @@\n-  static Method**      _matching_old_methods;\n-  static Method**      _matching_new_methods;\n-  static Method**      _deleted_methods;\n-  static Method**      _added_methods;\n+  static Method**        _matching_old_methods;\n+  static Method**        _matching_new_methods;\n+  static Method**        _deleted_methods;\n+  static Method**        _added_methods;\n@@ -351,1 +351,2 @@\n-  static Klass*          _the_class;\n+  static bool            _has_redefined_Object;\n+  static bool            _has_null_class_loader;\n@@ -355,0 +356,1 @@\n+  Klass*                      _the_class;\n@@ -515,2 +517,2 @@\n-  \/\/ to fix up these pointers.\n-  class AdjustCpoolCacheAndVtable : public KlassClosure {\n+  \/\/ to fix up these pointers and clean MethodData out.\n+  class AdjustAndCleanMetadata : public KlassClosure {\n@@ -519,1 +521,1 @@\n-    AdjustCpoolCacheAndVtable(Thread* t) : _thread(t) {}\n+    AdjustAndCleanMetadata(Thread* t) : _thread(t) {}\n@@ -523,6 +525,0 @@\n-  \/\/ Clean MethodData out\n-  class MethodDataCleaner : public KlassClosure {\n-   public:\n-    MethodDataCleaner() {}\n-    void do_klass(Klass* k);\n-  };\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,5 +225,1 @@\n-          InstanceKlass* holder = old_method->method_holder();\n-          new_method = holder->method_with_idnum(old_method->orig_method_idnum());\n-          assert(holder == new_method->method_holder(), \"call after swapping redefined guts\");\n-          assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n-          assert(old_method != new_method, \"sanity check\");\n+          new_method = old_method->get_new_method();\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}