{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -76,1 +77,1 @@\n-        Thread thread = new hs201t002Thread();\n+        hs201t002Thread thread = new hs201t002Thread();\n@@ -81,1 +82,0 @@\n-        setThread(thread);\n@@ -84,0 +84,10 @@\n+        \/\/ setThread(thread) enables JVMTI events, and that can only be done on a live thread,\n+        \/\/ so wait until the thread has started.\n+        try {\n+            thread.ready.await();\n+        } catch (InterruptedException e) {\n+        }\n+        setThread(thread);\n+\n+        thread.go.countDown();\n+\n@@ -117,0 +127,4 @@\n+            for (int i = 0; i < stackTrace.length; i++) {\n+                log.display(\"\\t\" + i + \". \" + stackTrace[i]);\n+            }\n+            log.display(\"Retrying...\");\n@@ -139,0 +153,3 @@\n+    CountDownLatch ready = new CountDownLatch(1);\n+    CountDownLatch go = new CountDownLatch(1);\n+\n@@ -145,0 +162,5 @@\n+        ready.countDown();\n+        try {\n+            go.await();\n+        } catch (InterruptedException e) {\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,2 @@\n- *      \"-agentlib:hs201t002=pathToNewByteCode=.\/bin -waittime=5\"\n- *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002\n+ *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5,-verbose\n+ *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002 -verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/TestDescription.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-static int redefineNumber;\n-static jint newClassSize;\n-static unsigned char* newClassBytes;\n@@ -53,1 +50,0 @@\n-char chbuffer[255];\n@@ -55,1 +51,7 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread);\n+\/\/ callbackException (isCatch == false) and callbackExceptionCatch (isCatch == true) handler\n+void handleException(bool isCatch,\n+    jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+    jmethodID method, jlocation location,\n+    jobject exception);\n+\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread);\n@@ -57,1 +59,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti);\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes);\n@@ -102,1 +104,0 @@\n-\n@@ -104,0 +105,2 @@\n+    jint newClassSize;\n+    unsigned char* newClassBytes;\n@@ -110,1 +113,1 @@\n-    if (!NSK_VERIFY(readNewBytecode(jvmti_env))) {\n+    if (!NSK_VERIFY(readNewBytecode(jvmti_env, &newClassSize, &newClassBytes))) {\n@@ -113,0 +116,1 @@\n+        jvmti_env->Deallocate((unsigned char*)className);\n@@ -124,1 +128,0 @@\n-        return;\n@@ -130,0 +133,3 @@\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate(newClassBytes))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n@@ -139,1 +145,0 @@\n-    redefineNumber = 1;\n@@ -147,1 +152,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n+    NSK_DISPLAY0(\">>>> Debugge started, waiting for class loading \\n\");\n@@ -186,1 +191,0 @@\n-    char *generic;\n@@ -188,1 +192,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -196,2 +200,1 @@\n-        NSK_DISPLAY1(\"\\n\\n>>>> Class loaded: %s\", className);\n-        NSK_DISPLAY0(\", activating breakpoint\\n\");\n+        NSK_DISPLAY1(\">>>> Class loaded: %s, activating breakpoint\\n\", className);\n@@ -204,5 +207,0 @@\n-\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n@@ -221,1 +219,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n+    NSK_DISPLAY0(\">>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n@@ -271,1 +269,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Checking if redefined method is not obsolete\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Checking if redefined method is not obsolete\\n\", testStep);\n@@ -288,1 +286,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Popping the currently executing frame\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Popping the currently executing frame\\n\", testStep);\n@@ -297,1 +295,1 @@\n-                    NSK_DISPLAY1(\"\\n\\n>>>> Disabling single step\\n\", testStep);\n+                    NSK_DISPLAY1(\">>>> Disabling single step\\n\", testStep);\n@@ -307,1 +305,1 @@\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to declaringClassName\\n\\n\");\n@@ -329,18 +327,1 @@\n-    const char *className;\n-\n-    className = getClassName(jvmti_env, jni_env, exception);\n-\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n-        jclass klass;\n-\n-        NSK_DISPLAY2(\"\\n\\n>>>> Exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n-\n-        testStep++;\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n-            nsk_jvmti_setFailStatus();\n-            return;\n-        }\n-\n-        redefineClass(jvmti_env, klass);\n-    }\n+    handleException(false, jvmti_env, jni_env, thread, method, location, exception);\n@@ -360,1 +341,4 @@\n-    const char *className;\n+    handleException(true, jvmti_env, jni_env, thread, method, location, exception);\n+}\n+\n+\/* ============================================================================= *\/\n@@ -362,1 +346,5 @@\n-    className = getClassName(jvmti_env, jni_env, exception);\n+void handleException(bool isCatch,\n+                     jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+                     jmethodID method, jlocation location,\n+                     jobject exception) {\n+    const char* className = getClassName(jvmti_env, jni_env, exception);\n@@ -364,1 +352,1 @@\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -367,2 +355,7 @@\n-        NSK_DISPLAY2(\"\\n\\n>>>> Caught exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n+        const char* threadName = getThreadName(jvmti_env, jni_env, thread);\n+        NSK_DISPLAY3(\">>>> %s %s in thread - %s\\n\", isCatch ? \"Caught exception\" : \"Exception\",\n+            className, threadName != NULL ? threadName : \"NULL\");\n+        jvmti->Deallocate((unsigned char*)className);\n+        if (threadName != NULL) {\n+            jvmti->Deallocate((unsigned char*)threadName);\n+        }\n@@ -378,0 +371,1 @@\n+\n@@ -380,1 +374,0 @@\n-\/* ============================================================================= *\/\n@@ -382,1 +375,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti) {\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes) {\n@@ -408,1 +401,1 @@\n-    newClassSize = ftell(bytecode);\n+    *newClassSize = ftell(bytecode);\n@@ -411,1 +404,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(newClassSize, &newClassBytes))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(*newClassSize, newClassBytes))) {\n@@ -415,1 +408,1 @@\n-    read_bytes = (jint) fread(newClassBytes, 1, newClassSize, bytecode);\n+    read_bytes = (jint) fread(*newClassBytes, 1, *newClassSize, bytecode);\n@@ -417,1 +410,1 @@\n-    if (read_bytes != newClassSize) {\n+    if (read_bytes != *newClassSize) {\n@@ -419,0 +412,2 @@\n+        jvmti->Deallocate(*newClassBytes);\n+        *newClassBytes = NULL;\n@@ -427,1 +422,1 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread) {\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread) {\n@@ -431,0 +426,2 @@\n+    jsize jthreadNameLen;\n+    unsigned char *result = NULL;\n@@ -433,2 +430,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -437,1 +432,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -443,1 +438,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -448,0 +443,7 @@\n+    jthreadNameLen = jni_env->GetStringUTFLength(jthreadName);\n+\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(jthreadNameLen + 1, &result))) {\n+        NSK_COMPLAIN0(\"buffer couldn't be allocated\\n\");\n+        return NULL;\n+    }\n+\n@@ -450,1 +452,1 @@\n-    strcpy(chbuffer, threadName);\n+    memcpy(result, threadName, jthreadNameLen + 1);\n@@ -454,1 +456,1 @@\n-    return chbuffer;\n+    return (char*)result;\n@@ -462,1 +464,0 @@\n-    char *generic;\n@@ -465,2 +466,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -469,6 +468,1 @@\n-        return chbuffer;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-        return chbuffer;\n+        return NULL;\n@@ -477,3 +471,1 @@\n-    strcpy(chbuffer, className);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)className))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -481,0 +473,1 @@\n+        return NULL;\n@@ -483,6 +476,1 @@\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n-\n-    return chbuffer;\n+    return className;\n@@ -551,0 +539,4 @@\n+    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n@@ -670,5 +662,0 @@\n-    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/hs201t002.cpp","additions":72,"deletions":85,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+        System.out.println(\"Current step: \" + hs201t002.currentStep); \/\/ Avoid calling classloader to find hs201t002 in doInit()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/newclass\/hs201t002a.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}