{"files":[{"patch":"@@ -45,0 +45,2 @@\n+\n+import static jdk.internal.net.http.frame.SettingsFrame.INITIAL_CONNECTION_WINDOW_SIZE;\n@@ -250,0 +252,4 @@\n+        \/\/ The min value is the max between the streamWindow and\n+        \/\/ the initial connection window size\n+        int minValue = Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow);\n+\n@@ -252,1 +258,1 @@\n-                streamWindow, Integer.MAX_VALUE, defaultValue);\n+                minValue, Integer.MAX_VALUE, defaultValue);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -972,0 +972,28 @@\n+    \/\/ This method is called when a DataFrame that was added\n+    \/\/ to a Stream::inputQ is later dropped from the queue\n+    \/\/ without being consumed.\n+    \/\/\n+    \/\/ Before adding a frame to the queue, the Stream calls\n+    \/\/ connection.windowUpdater.canBufferUnprocessedBytes(), which\n+    \/\/ increases the count of unprocessed bytes in the connection.\n+    \/\/ After consuming the frame, it calls connection.windowUpdater::processed,\n+    \/\/ which decrements the count of unprocessed bytes, and possibly\n+    \/\/ sends a window update to the peer.\n+    \/\/\n+    \/\/ This method is called when connection.windowUpdater::processed\n+    \/\/ will not be called, which can happen when consuming the frame\n+    \/\/ fails, or when an empty DataFrame terminates the stream,\n+    \/\/ or when the stream is cancelled while data is still\n+    \/\/ sitting in its inputQ. In the later case, it is called for\n+    \/\/ each frame that is dropped from the queue.\n+    final void releaseUnconsumed(DataFrame df) {\n+        windowUpdater.released(df.payloadLength());\n+        dropDataFrame(df);\n+    }\n+\n+    \/\/ This method can be called directly when a DataFrame is dropped\n+    \/\/ before\/without having been added to any Stream::inputQ.\n+    \/\/ In that case, the number of unprocessed bytes hasn't been incremented\n+    \/\/ by the stream, and does not need to be decremented.\n+    \/\/ Otherwise, if the frame is dropped after having been added to the\n+    \/\/ inputQ, releaseUnconsumed above should be called.\n@@ -1090,0 +1118,4 @@\n+    boolean isOpen() {\n+        return !closed && connection.channel().isOpen();\n+    }\n+\n@@ -1280,2 +1312,3 @@\n-        final int len = windowUpdater.initialWindowSize - DEFAULT_INITIAL_WINDOW_SIZE;\n-        if (len != 0) {\n+        final int len = windowUpdater.initialWindowSize - INITIAL_CONNECTION_WINDOW_SIZE;\n+        assert len >= 0;\n+        if (len > 0) {\n@@ -1284,1 +1317,1 @@\n-                        len, windowUpdater.initialWindowSize, DEFAULT_INITIAL_WINDOW_SIZE);\n+                        len, windowUpdater.initialWindowSize, INITIAL_CONNECTION_WINDOW_SIZE);\n@@ -1661,0 +1694,13 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            if (connection.isOpen()) {\n+                try {\n+                    connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"connection window exceeded\");\n+                } catch (IOException io) {\n+                    connection.shutdown(io);\n+                }\n+            }\n+            return true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    private final WindowUpdateSender windowUpdater;\n+    private final WindowUpdateSender streamWindowUpdater;\n@@ -206,1 +206,2 @@\n-                    connection.ensureWindowUpdated(df); \/\/ must update connection window\n+                    \/\/ consumed will not be called\n+                    connection.releaseUnconsumed(df); \/\/ must update connection window\n@@ -222,1 +223,5 @@\n-                        connection.dropDataFrame(df); \/\/ must update connection window\n+                        \/\/ Data frames that have been added to the inputQ\n+                        \/\/ must be released using releaseUnconsumed() to\n+                        \/\/ account for the amount of unprocessed bytes\n+                        \/\/ tracked by the connection.windowUpdater.\n+                        connection.releaseUnconsumed(df);\n@@ -275,1 +280,5 @@\n-                connection.dropDataFrame((DataFrame)frame);\n+                \/\/ Data frames that have been added to the inputQ\n+                \/\/ must be released using releaseUnconsumed() to\n+                \/\/ account for the amount of unprocessed bytes\n+                \/\/ tracked by the connection.windowUpdater.\n+                connection.releaseUnconsumed((DataFrame)frame);\n@@ -300,2 +309,1 @@\n-        connection.windowUpdater.update(len);\n-\n+        connection.windowUpdater.processed(len);\n@@ -303,0 +311,2 @@\n+            streamWindowUpdater.processed(len);\n+        } else {\n@@ -305,1 +315,1 @@\n-            windowUpdater.update(len);\n+            streamWindowUpdater.released(len);\n@@ -346,2 +356,15 @@\n-        inputQ.add(df);\n-        sched.runOrSchedule();\n+        try {\n+            int len = df.payloadLength();\n+            if (len > 0) {\n+                \/\/ we return from here if the connection is being closed.\n+                if (!connection.windowUpdater.canBufferUnprocessedBytes(len)) return;\n+                \/\/ we return from here if the stream is being closed.\n+                if (closed || !streamWindowUpdater.canBufferUnprocessedBytes(len)) {\n+                    connection.releaseUnconsumed(df);\n+                    return;\n+                }\n+            }\n+            inputQ.add(df);\n+        } finally {\n+            sched.runOrSchedule();\n+        }\n@@ -432,1 +455,1 @@\n-        this.windowUpdater = new StreamWindowUpdateSender(connection);\n+        this.streamWindowUpdater = new StreamWindowUpdateSender(connection);\n@@ -1284,0 +1307,4 @@\n+        onProtocolError(cause, ResetFrame.PROTOCOL_ERROR);\n+    }\n+\n+    void onProtocolError(final IOException cause, int code) {\n@@ -1285,1 +1312,3 @@\n-            debug.log(\"cancelling exchange on stream %d due to protocol error: %s\", streamid, cause.getMessage());\n+            debug.log(\"cancelling exchange on stream %d due to protocol error [%s]: %s\",\n+                    streamid, ErrorFrame.stringForCode(code),\n+                    cause.getMessage());\n@@ -1289,1 +1318,1 @@\n-        cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+        cancelImpl(cause, code);\n@@ -1557,0 +1586,8 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            onProtocolError(new ProtocolException(\"stream \" + streamid +\n+                            \" flow control window exceeded\"),\n+                    ResetFrame.FLOW_CONTROL_ERROR);\n+            return true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -35,0 +36,4 @@\n+\/**\n+  * A class that tracks the amount of flow controlled\n+  * data received on an HTTP\/2 connection\n+  *\/\n@@ -40,0 +45,1 @@\n+    \/\/ The threshold at which window updates are sent in bytes\n@@ -41,0 +47,2 @@\n+    \/\/ The flow control window in bytes\n+    final int windowSize;\n@@ -42,1 +50,8 @@\n-    final AtomicInteger received = new AtomicInteger(0);\n+    \/\/ The amount of flow controlled data received and processed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong received = new AtomicLong();\n+    \/\/ The amount of flow controlled data received and unprocessed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong unprocessed = new AtomicLong();\n@@ -54,0 +69,1 @@\n+        this.windowSize = initWindowSize;\n@@ -67,0 +83,1 @@\n+    \/\/ O for the connection window, > 0 for a stream window\n@@ -69,0 +86,99 @@\n+\n+    \/**\n+     * {@return {@code true} if buffering the given amount of\n+     * flow controlled data would not exceed the flow control\n+     * window}\n+     * <p>\n+     * This method is called before buffering and processing\n+     * a DataFrame. The count of unprocessed bytes is incremented\n+     * by the given amount, and checked against the number of\n+     * available bytes in the flow control window.\n+     * <p>\n+     * This method returns {@code true} if the bytes can be buffered\n+     * without exceeding the flow control window, {@code false}\n+     * if the flow control window is exceeded and corrective\n+     * action (close\/reset) has been taken.\n+     * <p>\n+     * When this method returns true, either {@link #processed(int)}\n+     * or {@link #released(int)} must eventually be called to release\n+     * the bytes from the flow control window.\n+     *\n+     * @implSpec\n+     * an HTTP\/2 endpoint may disable its own flow control\n+     * (see <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9113.html#section-5.2.1\">\n+     *     RFC 9113, section 5.2.1<\/a>), in which case this\n+     * method may return true even if the flow control window would\n+     * be exceeded: that is, the flow control window is exceeded but\n+     * the endpoint decided to take no corrective action.\n+     *\n+     * @param  len a number of unprocessed bytes, which\n+     *             the caller wants to buffer.\n+     *\/\n+    boolean canBufferUnprocessedBytes(int len) {\n+        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    }\n+\n+    \/\/ adds the provided amount to the amount of already\n+    \/\/ received and processed bytes and checks whether the\n+    \/\/ flow control window is exceeded. If so, take\n+    \/\/ corrective actions and return true.\n+    private boolean checkWindowSizeExceeded(long len) {\n+        \/\/ because windowSize is bound by Integer.MAX_VALUE\n+        \/\/ we will never reach the point where received.get() + len\n+        \/\/ could overflow\n+        long rcv = received.get() + len;\n+        return rcv > windowSize && windowSizeExceeded(rcv);\n+    }\n+\n+    \/**\n+     * Called after unprocessed buffered bytes have been\n+     * processed, to release part of the flow control window\n+     *\n+     * @apiNote this method is called only when releasing bytes\n+     * that where buffered after calling\n+     * {@link #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of processed bytes to release\n+     *\/\n+    void processed(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        update(delta);\n+    }\n+\n+    \/**\n+     * Called when it is desired to release unprocessed bytes\n+     * without processing them, or without triggering the\n+     * sending of a window update. This method can be called\n+     * instead of calling {@link #processed(int)}.\n+     * When this method is called instead of calling {@link #processed(int)},\n+     * it should generally be followed by a call to {@link #update(int)},\n+     * unless the stream or connection is being closed.\n+     *\n+     * @apiNote this method should only be called to release bytes that\n+     * have been buffered after calling {@link\n+     * #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of bytes to release from the window\n+     *\n+     * @return the amount of remaining unprocessed bytes\n+     *\/\n+    long released(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        return rest;\n+    }\n+\n+    \/**\n+     * This method is called to update the flow control window,\n+     * and possibly send a window update\n+     *\n+     * @apiNote this method can be called directly if a frame is\n+     * dropped before calling {@link #canBufferUnprocessedBytes(int)}.\n+     * Otherwise, either {@link #processed(int)} or {@link #released(int)}\n+     * should be called, depending on whether sending a window update\n+     * is desired or not. It is typically not desired to send an update\n+     * if the stream or connection is being closed.\n+     *\n+     * @param delta the amount of bytes released from the window.\n+     *\/\n@@ -70,1 +186,1 @@\n-        int rcv = received.addAndGet(delta);\n+        long rcv = received.addAndGet(delta);\n@@ -72,0 +188,3 @@\n+        if (rcv > windowSize && windowSizeExceeded(rcv)) {\n+            return;\n+        }\n@@ -74,2 +193,2 @@\n-                int tosend = received.get();\n-                if( tosend > limit) {\n+                int tosend = (int)Math.min(received.get(), Integer.MAX_VALUE);\n+                if (tosend > limit) {\n@@ -85,0 +204,1 @@\n+        assert delta > 0 : \"illegal window update delta: \" + delta;\n@@ -102,0 +222,12 @@\n+    \/**\n+     * Called when the flow control window size is exceeded\n+     * This method may return false if flow control is disabled\n+     * in this endpoint.\n+     *\n+     * @param received the amount of data received, which is greater\n+     *                 than {@code windowSize}\n+     * @return {@code true} if the error was reported to the peer\n+     *         and no further window update should be sent.\n+     *\/\n+    protected abstract boolean windowSizeExceeded(long received);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowUpdateSender.java","additions":137,"deletions":5,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,0 +466,10 @@\n+                if (id == SettingsFrame.INITIAL_WINDOW_SIZE && val < 0) {\n+                    return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"SettingsFrame with INITIAL_WINDOW_SIZE > 2^31 -1: \"\n+                                    + (val & 0xffffffffL));\n+                }\n+                if (id == SettingsFrame.MAX_FRAME_SIZE && (val < 16384 || val > 16777215)) {\n+                    return new MalformedFrame(ErrorFrame.PROTOCOL_ERROR,\n+                            \"SettingsFrame with MAX_FRAME_SIZE out of range: \"\n+                                    + (val & 0xffffffffL));\n+                }\n@@ -533,1 +543,6 @@\n-        return new WindowUpdateFrame(streamid, getInt() & 0x7fffffff);\n+        int update = getInt();\n+        if (update < 0) {\n+            return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                    \"WindowUpdateFrame with value > 2^31 -1 \" + (update & 0xffffffffL));\n+        }\n+        return new WindowUpdateFrame(streamid, update & 0x7fffffff);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/FramesDecoder.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,5 @@\n+    \/\/ Initial connection window size. This cannot be updated using the\n+    \/\/ SETTINGS frame.\n+    public static final int INITIAL_CONNECTION_WINDOW_SIZE = DEFAULT_INITIAL_WINDOW_SIZE;\n+\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/SettingsFrame.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(1500);\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxySelectorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @summary checks connection flow control\n+ * @library \/test\/lib server\/ ..\/\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *        Http2TestServer\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      ConnectionFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.ResponseInfo;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import jdk.internal.net.http.frame.Http2Frame;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.util.List.of;\n+import static java.util.Map.entry;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ConnectionFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpServerAdapters.HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpServerAdapters.HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI },\n+                { https2URI },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri) throws Exception {\n+        System.out.printf(\"%ntesting %s%n\", uri);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        ConcurrentHashMap<String, HttpResponse<InputStream>> responses = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+        int connectionWindowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.connectionWindowSize\", 65535), 65535);\n+        int windowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.windowsize\", 65535), 16384);\n+        int max = connectionWindowSize \/ windowSize + 2;\n+        System.out.printf(\"connection window: %s, stream window: %s, will make %s requests%n\",\n+                connectionWindowSize, windowSize, max);\n+\n+        String label = null;\n+\n+        Throwable t = null;\n+        HttpClient client = HttpClient.newBuilder().executor(Executors.newCachedThreadPool()).sslContext(sslContext).build();\n+        try {\n+            try {\n+                String[] keys = new String[max];\n+                for (int i = 0; i < max; i++) {\n+                    String query = \"reqId=\" + reqid.incrementAndGet();\n+                    keys[i] = query;\n+                    URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                    CompletableFuture<String> sent = new CompletableFuture<>();\n+                    responseSent.put(query, sent);\n+                    HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                            .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                            .build();\n+                    System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                    final HttpClient cc = client;\n+                    var response = cc.send(request, BodyHandlers.ofInputStream());\n+                    responses.put(query, response);\n+                    String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                    if (label == null) label = ckey;\n+                    try {\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n+                    } catch (AssertionError ass) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        ExecutorService exec = (ExecutorService)client.executor().get();\n+                        exec.shutdownNow();\n+                        throw ass;\n+                    }\n+                }\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore\n+                }\n+                CompletableFuture<?> allsent = CompletableFuture.allOf(responseSent.values().stream()\n+                        .toArray(CompletableFuture<?>[]::new));\n+                allsent.get();\n+                for (int i = 0; i < max; i++) {\n+                    try {\n+                        String query = keys[i];\n+                        var response = responses.get(keys[i]);\n+                        String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = ckey;\n+                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        int wait = uri.startsWith(\"https:\/\/\") ? 500 : 250;\n+                        try (InputStream is = response.body()) {\n+                            Thread.sleep(Utils.adjustTimeout(wait));\n+                            is.readAllBytes();\n+                        }\n+                        System.out.printf(\"%s did not fail: %s%n\", query, response.statusCode());\n+                    } catch (AssertionError t1) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        ExecutorService exec = (ExecutorService)client.executor().get();\n+                        exec.shutdownNow();\n+                        throw t1;\n+                    } catch (Throwable t0) {\n+                        System.out.println(\"Got EXPECTED: \" + t0);\n+                        if (t0 instanceof ExecutionException) {\n+                            t0 = t0.getCause();\n+                        }\n+                        t = t0;\n+                        try {\n+                            assertDetailMessage(t0, i);\n+                        } catch (AssertionError e) {\n+                            \/\/ since we won't pull all responses, the client\n+                            \/\/ will not exit unless we ask it to shutdown now.\n+                            ExecutorService exec = (ExecutorService)client.executor().get();\n+                            exec.shutdownNow();\n+                            throw e;\n+                        }\n+                    }\n+                }\n+            } catch (Throwable t0) {\n+                System.out.println(\"Got EXPECTED: \" + t0);\n+                if (t0 instanceof ExecutionException) {\n+                    t0 = t0.getCause();\n+                }\n+                t = t0;\n+            }\n+            if (t == null) {\n+                \/\/ we could fail here if we haven't waited long enough\n+                fail(\"Expected exception, got all responses, should sleep time be raised?\");\n+            } else {\n+                assertDetailMessage(t, max);\n+            }\n+            String query = \"reqId=\" + reqid.incrementAndGet();\n+            URI uriWithQuery = URI.create(uri + \"?\" + query);\n+            CompletableFuture<String> sent = new CompletableFuture<>();\n+            responseSent.put(query, sent);\n+            HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                    .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                    .build();\n+            System.out.println(\"\\nSending last request:\" + uriWithQuery);\n+            var response = client.send(request, BodyHandlers.ofString());\n+            if (label != null) {\n+                String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                assertNotEquals(ckey, label);\n+                System.out.printf(\"last request %s sent on different connection as expected:\" +\n+                        \"\\n\\tlast: %s\\n\\tprevious: %s%n\", query, ckey, label);\n+            }\n+        } finally {\n+            ExecutorService exec = (ExecutorService)client.executor().get();\n+            exec.shutdownNow();\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().contains(\"connection window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"protocol error: connection window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpServerAdapters.HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpServerAdapters.HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Math.max(16384, Integer.getInteger(\"jdk.httpclient.windowsize\", 2*16*1024));\n+                 final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange) {\n+                    maxChunkSize = Math.min(window, ((FCHttp2TestExchange)t).conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length < maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length);\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                int sent = 0;\n+                for (int i=0; i<=max; i++) {\n+                    int len = Math.min(resp.length, window - sent);\n+                    if (len <= 0) break;\n+                    if (os instanceof BodyOutputStream) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            ((BodyOutputStream)os).waitForStreamWindow(len);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, len);\n+                    sent += len;\n+                }\n+                if (sent != window) fail(\"should have sent \" + window + \", sent \" + sent);\n+            }\n+            if (t instanceof FCHttp2TestExchange) {\n+                ((FCHttp2TestExchange)t).responseSent(query);\n+            } else {\n+                fail(\"Exchange is not \" + FCHttp2TestExchange.class.getName() +\n+                        \" but \" + t.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @library \/test\/lib server\/ ..\/\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *        Http2TestServer\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      StreamFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class StreamFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpServerAdapters.HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpServerAdapters.HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI,  false },\n+                { https2URI, false },\n+                { http2URI,  true },\n+                { https2URI, true },\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri,\n+              boolean sameClient)\n+        throws Exception\n+    {\n+        System.out.printf(\"%ntesting test(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>>  responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 10 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder()\n+                            .executor(Executors.newCachedThreadPool())\n+                            .sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+                try {\n+                    HttpResponse<InputStream> response = cc.send(request, BodyHandlers.ofInputStream());\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    \/\/ we have to pull to get the exception, but slow enough\n+                    \/\/ so that DataFrames are buffered up to the point that\n+                    \/\/ the window is exceeded...\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (IOException ioe) {\n+                    System.out.println(\"Got EXPECTED: \" + ioe);\n+                    assertDetailMessage(ioe, i);\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        ExecutorService exec = (ExecutorService)client.executor().get();\n+                        exec.shutdown();\n+                        client = null;\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (sameClient && client != null) {\n+                ExecutorService exec = (ExecutorService)client.executor().get();\n+                exec.shutdown();\n+            }\n+        }\n+\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void testAsync(String uri,\n+                   boolean sameClient)\n+    {\n+        System.out.printf(\"%ntesting testAsync(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 5 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder()\n+                            .executor(Executors.newCachedThreadPool())\n+                            .sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+\n+                Throwable t = null;\n+                try {\n+                    HttpResponse<InputStream> response = cc.sendAsync(request, BodyHandlers.ofInputStream()).get();\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (Throwable t0) {\n+                    System.out.println(\"Got EXPECTED: \" + t0);\n+                    if (t0 instanceof ExecutionException) {\n+                        t0 = t0.getCause();\n+                    }\n+                    t = t0;\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        ExecutorService exec = (ExecutorService)client.executor().get();\n+                        exec.shutdown();\n+                        client = null;\n+                    }\n+                }\n+                assertDetailMessage(t, i);\n+            }\n+        } finally {\n+            if (sameClient && client != null) {\n+                ExecutorService exec = (ExecutorService)client.executor().get();\n+                exec.shutdown();\n+            }\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().matches(\"stream [0-9]+ flow control window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"stream X flow control window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpServerAdapters.HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpServerAdapters.HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Integer.getInteger(\"jdk.httpclient.windowsize\", 2 * 16 * 1024);\n+                final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange) {\n+                    maxChunkSize = Math.min(window, ((FCHttp2TestExchange)t).conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length <= maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length) + 2;\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                for (int i = 0; i <= max; i++) {\n+                    if (t instanceof FCHttp2TestExchange) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            ((FCHttp2TestExchange)t).conn.obtainConnectionWindow(resp.length);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                }\n+            }\n+            if (t instanceof FCHttp2TestExchange) {\n+                ((FCHttp2TestExchange)t).responseSent(query);\n+            } else fail(\"Exchange is not \" + FCHttp2TestExchange.class.getName() +\n+                    \" but \" + t.getClass().getName());\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.util.Objects;\n@@ -63,0 +64,4 @@\n+        waitForStreamWindow(demand);\n+    }\n+\n+    public void waitForStreamWindow(int demand) throws InterruptedException {\n@@ -81,0 +86,1 @@\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n@@ -102,0 +108,28 @@\n+    \/**\n+     * This method pushes frames onto the stack without checking\n+     * for flow control, allowing the sender to bypass flow\n+     * control for testing purposes\n+     * @param buf     data to send\n+     * @param offset  offset at which the data starts\n+     * @param len     length of the data to send\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public void writeUncontrolled(byte[] buf, int offset, int len)\n+            throws IOException {\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n+        if (closed) {\n+            throw new IOException(\"closed\");\n+        }\n+\n+        if (!goodToGo) {\n+            throw new IllegalStateException(\"sendResponseHeaders must be called first\");\n+        }\n+        int max = conn.getMaxFrameSize();\n+        while (len > 0) {\n+            int n = len > max ? max : len;\n+            send(buf, offset, n, 0);\n+            offset += n;\n+            len -= n;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/BodyOutputStream.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+\n@@ -85,0 +86,5 @@\n+    \/**\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n+     *\/\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestExchange.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -633,0 +633,4 @@\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -1289,1 +1293,1 @@\n-    synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n+    public synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n@@ -1299,3 +1303,7 @@\n-    synchronized void updateConnectionWindow(int amount) {\n-        sendWindow += amount;\n-        notifyAll();\n+    void updateConnectionWindow(int amount) {\n+        System.out.printf(\"sendWindow (window=%s, amount=%s) is now: %s%n\",\n+                sendWindow, amount, sendWindow + amount);\n+        synchronized (this) {\n+            sendWindow += amount;\n+            notifyAll();\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestServerConnection.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}