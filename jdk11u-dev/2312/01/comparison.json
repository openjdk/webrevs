{"files":[{"patch":"@@ -39,0 +39,2 @@\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n@@ -2390,0 +2392,1 @@\n+                addTypeAnnotationsToSymbol(sym, newList);\n@@ -2396,0 +2399,307 @@\n+    \/**\n+     * Rewrites types in the given symbol to include type annotations.\n+     *\n+     * <p>The list of type annotations includes annotations for all types in the signature of the\n+     * symbol. Associating the annotations with the correct type requires interpreting the JVMS\n+     * 4.7.20-A target_type to locate the correct type to rewrite, and then interpreting the JVMS\n+     * 4.7.20.2 type_path to associate the annotation with the correct contained type.\n+     *\/\n+    private static void addTypeAnnotationsToSymbol(\n+            Symbol s, List<Attribute.TypeCompound> attributes) {\n+        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    }\n+\n+    private static class TypeAnnotationSymbolVisitor\n+            extends Types.DefaultSymbolVisitor<Void, Void> {\n+\n+        private final List<Attribute.TypeCompound> attributes;\n+\n+        private TypeAnnotationSymbolVisitor(List<Attribute.TypeCompound> attributes) {\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public Void visitClassSymbol(Symbol.ClassSymbol s, Void unused) {\n+            ClassType t = (ClassType) s.type;\n+            int i = 0;\n+            ListBuffer<Type> interfaces = new ListBuffer<>();\n+            for (Type itf : t.interfaces_field) {\n+                interfaces.add(addTypeAnnotations(itf, classExtends(i++)));\n+            }\n+            t.interfaces_field = interfaces.toList();\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            if (t.typarams_field != null) {\n+                t.typarams_field =\n+                        rewriteTypeParameters(\n+                                t.typarams_field, TargetType.CLASS_TYPE_PARAMETER_BOUND);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethodSymbol(Symbol.MethodSymbol s, Void unused) {\n+            Type t = s.type;\n+            if (t.hasTag(TypeTag.FORALL)) {\n+                Type.ForAll fa = (Type.ForAll) t;\n+                fa.tvars = rewriteTypeParameters(fa.tvars, TargetType.METHOD_TYPE_PARAMETER_BOUND);\n+                t = fa.qtype;\n+            }\n+            MethodType mt = (MethodType) t;\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            int i = 0;\n+            for (Symbol.VarSymbol param : s.params) {\n+                param.type = addTypeAnnotations(param.type, methodFormalParameter(i++));\n+                argtypes.add(param.type);\n+            }\n+            mt.argtypes = argtypes.toList();\n+            ListBuffer<Type> thrown = new ListBuffer<>();\n+            i = 0;\n+            for (Type thrownType : mt.thrown) {\n+                thrown.add(addTypeAnnotations(thrownType, thrownType(i++)));\n+            }\n+            mt.thrown = thrown.toList();\n+            \/* possible information loss if the type of the method is void then we can't add type\n+             * annotations to it\n+             *\/\n+            if (!mt.restype.hasTag(TypeTag.VOID)) {\n+                mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            }\n+            if (mt.recvtype != null) {\n+                mt.recvtype = addTypeAnnotations(mt.recvtype, TargetType.METHOD_RECEIVER);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVarSymbol(Symbol.VarSymbol s, Void unused) {\n+            s.type = addTypeAnnotations(s.type, TargetType.FIELD);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitSymbol(Symbol s, Void unused) {\n+            return null;\n+        }\n+\n+        private List<Type> rewriteTypeParameters(List<Type> tvars, TargetType boundType) {\n+            ListBuffer<Type> tvarbuf = new ListBuffer<>();\n+            int typeVariableIndex = 0;\n+            for (Type tvar : tvars) {\n+                Type bound = tvar.getUpperBound();\n+                if (bound.isCompound()) {\n+                    ClassType ct = (ClassType) bound;\n+                    int boundIndex = 0;\n+                    if (ct.supertype_field != null) {\n+                        ct.supertype_field =\n+                                addTypeAnnotations(\n+                                        ct.supertype_field,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++));\n+                    }\n+                    ListBuffer<Type> itfbuf = new ListBuffer<>();\n+                    for (Type itf : ct.interfaces_field) {\n+                        itfbuf.add(\n+                                addTypeAnnotations(\n+                                        itf,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++)));\n+                    }\n+                    ct.interfaces_field = itfbuf.toList();\n+                } else {\n+                    bound =\n+                            addTypeAnnotations(\n+                                    bound,\n+                                    typeParameterBound(\n+                                            boundType,\n+                                            typeVariableIndex,\n+                                            bound.isInterface() ? 1 : 0));\n+                }\n+                ((TypeVar) tvar).setUpperBound(bound);\n+                tvarbuf.add(tvar);\n+                typeVariableIndex++;\n+            }\n+            return tvarbuf.toList();\n+        }\n+\n+        private Type addTypeAnnotations(Type type, TargetType targetType) {\n+            return addTypeAnnotations(type, pos -> pos.type == targetType);\n+        }\n+\n+        private Type addTypeAnnotations(Type type, Predicate<TypeAnnotationPosition> filter) {\n+            Assert.checkNonNull(type);\n+\n+            \/\/ Find type annotations that match the given target type\n+            ListBuffer<Attribute.TypeCompound> filtered = new ListBuffer<>();\n+            for (Attribute.TypeCompound attribute : this.attributes) {\n+                if (filter.test(attribute.position)) {\n+                    filtered.add(attribute);\n+                }\n+            }\n+            if (filtered.isEmpty()) {\n+                return type;\n+            }\n+\n+            \/\/ Group the matching annotations by their type path. Each group of annotations will be\n+            \/\/ added to a type at that location.\n+            Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                    attributesByPath = new HashMap<>();\n+            for (Attribute.TypeCompound attribute : filtered.toList()) {\n+                attributesByPath\n+                        .computeIfAbsent(attribute.position.location, k -> new ListBuffer<>())\n+                        .add(attribute);\n+            }\n+\n+            \/\/ Search the structure of the type to find the contained types at each type path\n+            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n+            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n+\n+            \/\/ Rewrite the type and add the annotations\n+            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n+            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+\n+            return type;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> typeParameterBound(\n+                TargetType targetType, int parameterIndex, int boundIndex) {\n+            return pos ->\n+                    pos.type == targetType\n+                            && pos.parameter_index == parameterIndex\n+                            && pos.bound_index == boundIndex;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> methodFormalParameter(int index) {\n+            return pos ->\n+                    pos.type == TargetType.METHOD_FORMAL_PARAMETER && pos.parameter_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> thrownType(int index) {\n+            return pos -> pos.type == TargetType.THROWS && pos.type_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> classExtends(int index) {\n+            return pos -> pos.type == TargetType.CLASS_EXTENDS && pos.type_index == index;\n+        }\n+    }\n+\n+    \/**\n+     * Visit all contained types, assembling a type path to represent the current location, and\n+     * record the types at each type path that need to be annotated.\n+     *\/\n+    private static class TypeAnnotationLocator\n+            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+        private final Map<List<TypeAnnotationPosition.TypePathEntry>,\n+                          ListBuffer<Attribute.TypeCompound>> attributesByPath;\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationLocator(\n+                Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                        attributesByPath,\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByPath = attributesByPath;\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            \/\/ As described in JVMS 4.7.20.2, type annotations on nested types are located with\n+            \/\/ 'left-to-right' steps starting on 'the outermost part of the type for which a type\n+            \/\/ annotation is admissible'. So the current path represents the outermost containing\n+            \/\/ type of the type being visited, and we add type path steps for every contained nested\n+            \/\/ type.\n+            List<ClassType> enclosing = List.nil();\n+            for (Type curr = t;\n+                    curr != null && curr != Type.noType;\n+                    curr = curr.getEnclosingType()) {\n+                enclosing = enclosing.prepend((ClassType) curr);\n+            }\n+            for (ClassType te : enclosing) {\n+                if (te.typarams_field != null) {\n+                    int i = 0;\n+                    for (Type typaram : te.typarams_field) {\n+                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(\n+                                TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n+                    }\n+                }\n+                visitType(te, path);\n+                path = path.append(TypeAnnotationPosition.TypePathEntry.INNER_TYPE);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(\n+                WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            return super.visitWildcardType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            return super.visitArrayType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            if (attributes != null) {\n+                attributesByType.put(t, attributes.toList());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/** A type mapping that rewrites the type to include type annotations. *\/\n+    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n+\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationTypeMapping(\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n+            \/\/ We're relying on object identify of Type instances to record where the annotations\n+            \/\/ need to be added, so we have to retrieve the annotations for each type before\n+            \/\/ rewriting it, and then add them after its contained types have been rewritten.\n+            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n+            Type mapped = f.apply(t, null);\n+            if (attributes == null) {\n+                return mapped;\n+            }\n+            \/\/ Runtime-visible and -invisible annotations are completed separately, so if the same\n+            \/\/ type has annotations from both it will get annotated twice.\n+            TypeMetadata metadata = mapped.getMetadata();\n+            TypeMetadata.Annotations existing =\n+                    (TypeMetadata.Annotations) metadata.get(TypeMetadata.Entry.Kind.ANNOTATIONS);\n+            if (existing != null) {\n+                TypeMetadata.Annotations combined = new TypeMetadata.Annotations(\n+                        existing.getAnnotations().appendList(attributes));\n+                return mapped.cloneWithMetadata(\n+                        metadata.without(TypeMetadata.Entry.Kind.ANNOTATIONS).combine(combined));\n+            }\n+            return mapped.annotatedType(attributes);\n+        }\n+\n+        @Override\n+        public Type visitClassType(ClassType t, Void unused) {\n+            return reannotate(t, super::visitClassType);\n+        }\n+\n+        @Override\n+        public Type visitWildcardType(WildcardType t, Void unused) {\n+            return reannotate(t, super::visitWildcardType);\n+        }\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Void unused) {\n+            return reannotate(t, super::visitArrayType);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void unused) {\n+            return reannotate(t, (x, u) -> x);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320001\n+ * @summary javac crashes while adding type annotations to the return type of a constructor\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main TypeAnnosOnConstructorsTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TypeAnnosOnConstructorsTest extends TestRunner {\n+    protected ToolBox tb;\n+\n+    TypeAnnosOnConstructorsTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TypeAnnosOnConstructorsTest().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testAnnoOnConstructors(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path y = src.resolve(\"Y.java\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(src,\n+                \"import java.lang.annotation.Target;\\n\" +\n+                \"import java.lang.annotation.ElementType;\\n\" +\n+                \"import java.lang.annotation.Retention;\\n\" +\n+                \"import java.lang.annotation.RetentionPolicy;\\n\" +\n+                \"class Y {\\n\" +\n+                \"    @TA public Y() {}\\n\" +\n+                \"}\\n\" +\n+                \"@Target(ElementType.TYPE_USE)\\n\" +\n+                \"@Retention(RetentionPolicy.RUNTIME)\\n\" +\n+                \"@interface TA {}\");\n+\n+        \/\/ we need to compile Y first\n+        new JavacTask(tb)\n+                .files(y)\n+                .outdir(classes)\n+                .run();\n+\n+        Path classDir = getClassDir();\n+        new JavacTask(tb)\n+                .classpath(classes, classDir)\n+                .options(\"-processor\", SimpleProcessor.class.getName())\n+                .classes(\"Y\")\n+                .outdir(classes)\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public Path getClassDir() {\n+        String classes = ToolBox.testClasses;\n+        if (classes == null) {\n+            return Paths.get(\"build\");\n+        } else {\n+            return Paths.get(classes);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class SimpleProcessor extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnosOnConstructorsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8013852 8031744\n+ * @bug 8013852 8031744 8225377\n@@ -36,0 +36,1 @@\n+ * @compile\/process -XDaccessInternalAPI -processor BasicAnnoTests -proc:only BasicAnnoTests\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}