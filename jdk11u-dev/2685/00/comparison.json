{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -326,0 +327,34 @@\n+    public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {\n+#if[rw]\n+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n+            Objects.checkFromIndexSize(index, length, limit());\n+            Objects.checkFromIndexSize(offset, length, dst.length);\n+\n+            long dstOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n+            try {\n+#if[!byte]\n+                if (order() != ByteOrder.nativeOrder())\n+                    UNSAFE.copySwapMemory(null,\n+                                          ix(index),\n+                                          dst,\n+                                          dstOffset,\n+                                          (long)length << $LG_BYTES_PER_VALUE$,\n+                                          (long)1 << $LG_BYTES_PER_VALUE$);\n+                else\n+#end[!byte]\n+                    UNSAFE.copyMemory(null,\n+                                      ix(index),\n+                                      dst,\n+                                      dstOffset,\n+                                      (long)length << $LG_BYTES_PER_VALUE$);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        } else {\n+            super.get(index, dst, offset, length);\n+        }\n+        return this;\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n@@ -441,0 +476,36 @@\n+    public $Type$Buffer put(int index, $type$[] src, int offset, int length) {\n+#if[rw]\n+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {\n+            Objects.checkFromIndexSize(index, length, limit());\n+            Objects.checkFromIndexSize(offset, length, src.length);\n+\n+\n+            long srcOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);\n+            try {\n+#if[!byte]\n+                if (order() != ByteOrder.nativeOrder())\n+                    UNSAFE.copySwapMemory(src,\n+                                          srcOffset,\n+                                          null,\n+                                          ix(index),\n+                                          (long)length << $LG_BYTES_PER_VALUE$,\n+                                          (long)1 << $LG_BYTES_PER_VALUE$);\n+                else\n+#end[!byte]\n+                    UNSAFE.copyMemory(src,\n+                                      srcOffset,\n+                                      null,\n+                                      ix(index),\n+                                      (long)length << $LG_BYTES_PER_VALUE$);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        } else {\n+            super.put(index, src, offset, length);\n+        }\n+        return this;\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.util.Objects;\n+\n@@ -188,0 +190,7 @@\n+    public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {\n+        Objects.checkFromIndexSize(index, length, limit());\n+        Objects.checkFromIndexSize(offset, length, dst.length);\n+        System.arraycopy(hb, ix(index), dst, offset, length);\n+        return this;\n+    }\n+\n@@ -261,0 +270,11 @@\n+    public $Type$Buffer put(int index, $type$[] src, int offset, int length) {\n+#if[rw]\n+        Objects.checkFromIndexSize(index, length, limit());\n+        Objects.checkFromIndexSize(offset, length, src.length);\n+        System.arraycopy(src, offset, hb, ix(index), length);\n+        return this;\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -53,1 +54,1 @@\n- *   <li><p> Relative {@link #get($type$[]) <i>bulk get<\/i>}\n+ *   <li><p> Absolute and relative {@link #get($type$[]) <i>bulk get<\/i>}\n@@ -57,1 +58,1 @@\n- *   <li><p> Relative {@link #put($type$[]) <i>bulk put<\/i>}\n+ *   <li><p> Absolute and relative {@link #put($type$[]) <i>bulk put<\/i>}\n@@ -437,1 +438,0 @@\n-     * @throws NullPointerException if target is null\n@@ -773,0 +773,83 @@\n+    \/**\n+     * Absolute bulk <i>get<\/i> method.\n+     *\n+     * <p> This method transfers {@code length} $type$s from this\n+     * buffer into the given array, starting at the given index in this\n+     * buffer and at the given offset in the array.  The position of this\n+     * buffer is unchanged.\n+     *\n+     * <p> An invocation of this method of the form\n+     * <code>src.get(index,&nbsp;dst,&nbsp;offset,&nbsp;length)<\/code>\n+     * has exactly the same effect as the following loop except that it first\n+     * checks the consistency of the supplied parameters and it is potentially\n+     * much more efficient:\n+     *\n+     * <pre>{@code\n+     *     for (int i = offset, j = index; i < offset + length; i++, j++)\n+     *         dst[i] = src.get(j);\n+     * }<\/pre>\n+     *\n+     * @param  index\n+     *         The index in this buffer from which the first $type$ will be\n+     *         read; must be non-negative and less than {@code limit()}\n+     *\n+     * @param  dst\n+     *         The destination array\n+     *\n+     * @param  offset\n+     *         The offset within the array of the first $type$ to be\n+     *         written; must be non-negative and less than\n+     *         {@code dst.length}\n+     *\n+     * @param  length\n+     *         The number of $type$s to be written to the given array;\n+     *         must be non-negative and no larger than the smaller of\n+     *         {@code limit() - index} and {@code dst.length - offset}\n+     *\n+     * @return  This buffer\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If the preconditions on the {@code index}, {@code offset}, and\n+     *          {@code length} parameters do not hold\n+     *\n+     * @since 13\n+     *\/\n+    public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {\n+        Objects.checkFromIndexSize(index, length, limit());\n+        Objects.checkFromIndexSize(offset, length, dst.length);\n+        int end = offset + length;\n+        for (int i = offset, j = index; i < end; i++, j++)\n+            dst[i] = get(j);\n+        return this;\n+    }\n+\n+    \/**\n+     * Absolute bulk <i>get<\/i> method.\n+     *\n+     * <p> This method transfers $type$s from this buffer into the given\n+     * destination array.  The position of this buffer is unchanged.  An\n+     * invocation of this method of the form\n+     * <code>src.get(index,&nbsp;dst)<\/code> behaves in exactly the same\n+     * way as the invocation:\n+     *\n+     * <pre>\n+     *     src.get(index, dst, 0, dst.length) <\/pre>\n+     *\n+     * @param  index\n+     *         The index in this buffer from which the first $type$ will be\n+     *         read; must be non-negative and less than {@code limit()}\n+     *\n+     * @param  dst\n+     *         The destination array\n+     *\n+     * @return  This buffer\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If {@code index} is negative, not smaller than {@code limit()},\n+     *          or {@code limit() - index < dst.length}\n+     *\n+     * @since 13\n+     *\/\n+    public $Type$Buffer get(int index, $type$[] dst) {\n+        return get(index, dst, 0, dst.length);\n+    }\n@@ -851,1 +934,1 @@\n-     *         dst.put(a[i]);\n+     *         dst.put(src[i]);\n@@ -862,1 +945,1 @@\n-     *         must be non-negative and no larger than {@code array.length}\n+     *         must be non-negative and no larger than {@code src.length}\n@@ -867,1 +950,1 @@\n-     *         {@code array.length - offset}\n+     *         {@code src.length - offset}\n@@ -917,0 +1000,89 @@\n+    \/**\n+     * Absolute bulk <i>put<\/i> method&nbsp;&nbsp;<i>(optional operation)<\/i>.\n+     *\n+     * <p> This method transfers {@code length} $type$s from the given\n+     * array, starting at the given offset in the array and at the given index\n+     * in this buffer.  The position of this buffer is unchanged.\n+     *\n+     * <p> An invocation of this method of the form\n+     * <code>dst.put(index,&nbsp;src,&nbsp;offset,&nbsp;length)<\/code>\n+     * has exactly the same effect as the following loop except that it first\n+     * checks the consistency of the supplied parameters and it is potentially\n+     * much more efficient:\n+     *\n+     * <pre>{@code\n+     *     for (int i = offset, j = index; i < offset + length; i++, j++)\n+     *         dst.put(j, src[i]);\n+     * }<\/pre>\n+     *\n+     * @param  index\n+     *         The index in this buffer at which the first $type$ will be\n+     *         written; must be non-negative and less than {@code limit()}\n+     *\n+     * @param  src\n+     *         The array from which $type$s are to be read\n+     *\n+     * @param  offset\n+     *         The offset within the array of the first $type$ to be read;\n+     *         must be non-negative and less than {@code src.length}\n+     *\n+     * @param  length\n+     *         The number of $type$s to be read from the given array;\n+     *         must be non-negative and no larger than the smaller of\n+     *         {@code limit() - index} and {@code src.length - offset}\n+     *\n+     * @return  This buffer\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If the preconditions on the {@code index}, {@code offset}, and\n+     *          {@code length} parameters do not hold\n+     *\n+     * @throws  ReadOnlyBufferException\n+     *          If this buffer is read-only\n+     *\n+     * @since 13\n+     *\/\n+    public $Type$Buffer put(int index, $type$[] src, int offset, int length) {\n+        if (isReadOnly())\n+            throw new ReadOnlyBufferException();\n+        Objects.checkFromIndexSize(index, length, limit());\n+        Objects.checkFromIndexSize(offset, length, src.length);\n+        int end = offset + length;\n+        for (int i = offset, j = index; i < end; i++, j++)\n+            this.put(j, src[i]);\n+        return this;\n+    }\n+\n+    \/**\n+     * Absolute bulk <i>put<\/i> method&nbsp;&nbsp;<i>(optional operation)<\/i>.\n+     *\n+     * <p> This method copies $type$s into this buffer from the given source\n+     * array.  The position of this buffer is unchanged.  An invocation of this\n+     * method of the form <code>dst.put(index,&nbsp;src)<\/code>\n+     * behaves in exactly the same way as the invocation:\n+     *\n+     * <pre>\n+     *     dst.put(index, src, 0, src.length); <\/pre>\n+     *\n+     * @param  index\n+     *         The index in this buffer at which the first $type$ will be\n+     *         written; must be non-negative and less than {@code limit()}\n+     *\n+     * @param  src\n+     *         The array from which $type$s are to be read\n+     *\n+     * @return  This buffer\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If {@code index} is negative, not smaller than {@code limit()},\n+     *          or {@code limit() - index < src.length}\n+     *\n+     * @throws  ReadOnlyBufferException\n+     *          If this buffer is read-only\n+     *\n+     * @since 13\n+     *\/\n+    public $Type$Buffer put(int index, $type$[] src) {\n+        return put(index, src, 0, src.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":178,"deletions":6,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet($Type$Buffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        $type$[] a = new $type$[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)(($type$)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray($Type$Buffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        $type$[] a = new $type$[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = ($type$)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, ($type$[])null, 0, 42));\n+\n+        $type$[] tmpa = new $type$[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -906,0 +963,7 @@\n+        \/\/ absolute bulk get\n+        char[] c = new char[end + 1 - (start - 1) + 1]; \/\/ [start - 1, end + 1]\n+        b.limit(end + 2);\n+        b.get(start - 1, c, 0, c.length);\n+        for (int i = 0; i < c.length; i++)\n+            ck(b, c[i], s.charAt(start - 1 + i));\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic-X.java.template","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n- *      4526177 4463011 4660660 4661219 4663521 4782970 4804304 4938424 6231529\n- *      6221101 6234263 6535542 6591971 6593946 6795561 7190219 7199551 8065556\n- *      8149469 8230665\n+ *      4526177 4463011 4660660 4661219 4663521 4782970 4804304 4938424 5029431\n+ *      6231529 6221101 6234263 6535542 6591971 6593946 6795561 7190219 7199551\n+ *      8065556 8149469 8230665\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(ByteBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        byte[] a = new byte[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((byte)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(ByteBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        byte[] a = new byte[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (byte)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (byte[])null, 0, 42));\n+\n+        byte[] tmpa = new byte[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicByte.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(CharBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        char[] a = new char[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((char)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(CharBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        char[] a = new char[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (char)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (char[])null, 0, 42));\n+\n+        char[] tmpa = new char[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -906,0 +963,7 @@\n+        \/\/ absolute bulk get\n+        char[] c = new char[end + 1 - (start - 1) + 1]; \/\/ [start - 1, end + 1]\n+        b.limit(end + 2);\n+        b.get(start - 1, c, 0, c.length);\n+        for (int i = 0; i < c.length; i++)\n+            ck(b, c[i], s.charAt(start - 1 + i));\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicChar.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(DoubleBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        double[] a = new double[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((double)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(DoubleBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        double[] a = new double[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (double)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (double[])null, 0, 42));\n+\n+        double[] tmpa = new double[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicDouble.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(FloatBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        float[] a = new float[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((float)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(FloatBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        float[] a = new float[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (float)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (float[])null, 0, 42));\n+\n+        float[] tmpa = new float[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicFloat.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(IntBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        int[] a = new int[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((int)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(IntBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        int[] a = new int[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (int)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (int[])null, 0, 42));\n+\n+        int[] tmpa = new int[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicInt.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(LongBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        long[] a = new long[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((long)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(LongBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        long[] a = new long[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (long)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (long[])null, 0, 42));\n+\n+        long[] tmpa = new long[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicLong.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,12 @@\n+    private static void absBulkGet(ShortBuffer b) {\n+        int n = b.capacity();\n+        int len = n - 7*2;\n+        short[] a = new short[n + 7];\n+        b.position(42);\n+        b.get(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+        for (int i = 0; i < len; i++) {\n+            ck(b, (long)a[i + 7], (long)((short)ic(i)));\n+        }\n+    }\n+\n@@ -139,0 +151,14 @@\n+    private static void absBulkPutArray(ShortBuffer b) {\n+        int n = b.capacity();\n+        b.clear();\n+        int lim = n - 7;\n+        int len = lim - 7;\n+        b.limit(lim);\n+        short[] a = new short[len + 7];\n+        for (int i = 0; i < len; i++)\n+            a[i + 7] = (short)ic(i);\n+        b.position(42);\n+        b.put(7, a, 7, len);\n+        ck(b, b.position() == 42);\n+    }\n+\n@@ -455,0 +481,4 @@\n+    private static void catchNullArgument(Buffer b, Runnable thunk) {\n+        tryCatch(b, NullPointerException.class, thunk);\n+    }\n+\n@@ -479,1 +509,4 @@\n-                fail(x.getMessage() + \" not expected\");\n+                String s = x.getMessage();\n+                if (s == null)\n+                    s = x.getClass().getName();\n+                fail(s + \" not expected\");\n@@ -516,0 +549,3 @@\n+        absBulkPutArray(b);\n+        absBulkGet(b);\n+\n@@ -615,0 +651,20 @@\n+        \/\/ Exceptions in absolute bulk operations\n+\n+        catchNullArgument(b, () -> b.get(7, null, 0, 42));\n+        catchNullArgument(b, () -> b.put(7, (short[])null, 0, 42));\n+\n+        short[] tmpa = new short[42];\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.get(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.get(b.limit() - 41, tmpa, 0, 42));\n+\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, -1, 42));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 42, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(7, tmpa, 41, -1));\n+        catchIndexOutOfBounds(b, () -> b.put(-1, tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit(), tmpa, 0, 1));\n+        catchIndexOutOfBounds(b, () -> b.put(b.limit() - 41, tmpa, 0, 42));\n+\n@@ -822,0 +878,1 @@\n+        catchReadOnlyBuffer(b, () -> absBulkPutArray(rb));\n@@ -923,0 +980,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicShort.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"}]}