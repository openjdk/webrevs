{"files":[{"patch":"@@ -1037,0 +1037,134 @@\n+\/\/ Collapse the \"addition with overflow-protection\" pattern, and the symmetrical\n+\/\/ \"subtraction with underflow-protection\" pattern. These are created during the\n+\/\/ unrolling, when we have to adjust the limit by subtracting the stride, but want\n+\/\/ to protect against underflow: MaxL(SubL(limit, stride), min_jint).\n+\/\/ If we have more than one of those in a sequence:\n+\/\/\n+\/\/   x  con2\n+\/\/   |  |\n+\/\/   AddL  clamp2\n+\/\/     |    |\n+\/\/    Max\/MinL con1\n+\/\/          |  |\n+\/\/          AddL  clamp1\n+\/\/            |    |\n+\/\/           Max\/MinL (n)\n+\/\/\n+\/\/ We want to collapse it to:\n+\/\/\n+\/\/   x  con1  con2\n+\/\/   |    |    |\n+\/\/   |   AddLNode (new_con)\n+\/\/   |    |\n+\/\/  AddLNode  clamp1\n+\/\/        |    |\n+\/\/       Max\/MinL (n)\n+\/\/\n+\/\/ Note: we assume that SubL was already replaced by an AddL, and that the stride\n+\/\/ has its sign flipped: SubL(limit, stride) -> AddL(limit, -stride).\n+static bool is_clamp(PhaseGVN* phase, Node* n, Node* c) {\n+  \/\/ Check that the two clamps have the correct values.\n+  jlong clamp = (n->Opcode() == Op_MaxL) ? min_jint : max_jint;\n+  const TypeLong* t = phase->type(c)->isa_long();\n+  return t != NULL && t->is_con() &&\n+          t->get_con() == clamp;\n+}\n+\n+static bool is_sub_con(PhaseGVN* phase, Node* n, Node* c) {\n+  \/\/ Check that the constants are negative if MaxL, and positive if MinL.\n+  const TypeLong* t = phase->type(c)->isa_long();\n+  return t != NULL && t->is_con() &&\n+          t->get_con() < max_jint && t->get_con() > min_jint &&\n+          (t->get_con() < 0) == (n->Opcode() == Op_MaxL);\n+}\n+\n+Node* fold_subI_no_underflow_pattern(Node* n, PhaseGVN* phase) {\n+  assert(n->Opcode() == Op_MaxL || n->Opcode() == Op_MinL, \"sanity\");\n+  \/\/ Verify the graph level by level:\n+  Node* add1   = n->in(1);\n+  Node* clamp1 = n->in(2);\n+  if (add1->Opcode() == Op_AddL && is_clamp(phase, n, clamp1)) {\n+    Node* max2 = add1->in(1);\n+    Node* con1 = add1->in(2);\n+    if (max2->Opcode() == n->Opcode() && is_sub_con(phase, n, con1)) {\n+      Node* add2   = max2->in(1);\n+      Node* clamp2 = max2->in(2);\n+      if (add2->Opcode() == Op_AddL && is_clamp(phase, n, clamp2)) {\n+        Node* x    = add2->in(1);\n+        Node* con2 = add2->in(2);\n+        if (is_sub_con(phase, n, con2)) {\n+          Node* new_con = phase->transform(new AddLNode(con1, con2));\n+          Node* new_sub = phase->transform(new AddLNode(x, new_con));\n+          n->set_req_X(1, new_sub, phase);\n+          return n;\n+        }\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+const Type* MaxLNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n+\n+  return TypeLong::make(MAX2(r0->_lo, r1->_lo), MAX2(r0->_hi, r1->_hi), MAX2(r0->_widen, r1->_widen));\n+}\n+\n+Node* MaxLNode::Identity(PhaseGVN* phase) {\n+  const TypeLong* t1 = phase->type(in(1))->is_long();\n+  const TypeLong* t2 = phase->type(in(2))->is_long();\n+\n+  \/\/ Can we determine maximum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(1);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(2);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n+Node* MaxLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != NULL) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return NULL;\n+}\n+\n+const Type* MinLNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n+\n+  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MIN2(r0->_widen, r1->_widen));\n+}\n+\n+Node* MinLNode::Identity(PhaseGVN* phase) {\n+  const TypeLong* t1 = phase->type(in(1))->is_long();\n+  const TypeLong* t2 = phase->type(in(2))->is_long();\n+\n+  \/\/ Can we determine minimum statically?\n+  if (t1->_lo >= t2->_hi) {\n+    return in(2);\n+  } else if (t2->_lo >= t1->_hi) {\n+    return in(1);\n+  }\n+\n+  return MaxNode::Identity(phase);\n+}\n+\n+Node* MinLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != NULL) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -282,0 +282,34 @@\n+\/\/------------------------------MaxLNode---------------------------------------\n+\/\/ MAXimum of 2 longs.\n+class MaxLNode : public MaxNode {\n+public:\n+  MaxLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+  virtual int Opcode() const;\n+  virtual const Type* add_ring(const Type* t0, const Type* t1) const;\n+  virtual const Type* add_id() const { return TypeLong::make(min_jlong); }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n+};\n+\n+\/\/------------------------------MinLNode---------------------------------------\n+\/\/ MINimum of 2 longs.\n+class MinLNode : public MaxNode {\n+public:\n+  MinLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+  virtual int Opcode() const;\n+  virtual const Type* add_ring(const Type* t0, const Type* t1) const;\n+  virtual const Type* add_id() const { return TypeLong::make(max_jlong); }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+macro(MaxL)\n@@ -223,0 +224,1 @@\n+macro(MinL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,0 +263,14 @@\n+Node* ConvI2LNode::Identity(PhaseGVN* phase) {\n+  \/\/ If type is in \"int\" sub-range, we can\n+  \/\/ convert I2L(L2I(x)) => x\n+  \/\/ since the conversions have no effect.\n+  if (in(1)->Opcode() == Op_ConvL2I) {\n+    Node* x = in(1)->in(1);\n+    const TypeLong* t = phase->type(x)->isa_long();\n+    if (t != NULL && t->_lo >= min_jint && t->_hi <= max_jint) {\n+      return x;\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2020,1 +2020,1 @@\n-      \/\/ Limit is not constant.\n+      \/\/ Limit is not constant. Int subtraction could lead to underflow.\n@@ -2032,0 +2032,5 @@\n+\n+        \/\/ The Opaque2 node created above (in the case of the first unrolling) hides the type of the loop limit.\n+        \/\/ Propagate this precise type information.\n+        limit = new CastIINode(limit, limit_type);\n+        register_new_node(limit, opaq_ctrl);\n@@ -2033,4 +2038,17 @@\n-      if ((stride_con > 0 && (java_subtract(limit_type->_lo, stride_con) < limit_type->_lo)) ||\n-          (stride_con < 0 && (java_subtract(limit_type->_hi, stride_con) > limit_type->_hi))) {\n-        \/\/ No underflow.\n-        new_limit = new SubINode(limit, stride);\n+      \/\/ (1) Convert to long.\n+      Node* limit_l = new ConvI2LNode(limit);\n+      register_new_node(limit_l, get_ctrl(limit));\n+      Node* stride_l = _igvn.longcon(stride_con);\n+      set_ctrl(stride_l, C->root());\n+\n+      \/\/ (2) Subtract: compute in long, to prevent underflow.\n+      Node* new_limit_l = new SubLNode(limit_l, stride_l);\n+      register_new_node(new_limit_l, ctrl);\n+\n+      \/\/ (3) Clamp to int range, in case we had subtraction underflow.\n+      Node* underflow_clamp_l = _igvn.longcon((stride_con > 0) ? min_jint : max_jint);\n+      set_ctrl(underflow_clamp_l, C->root());\n+      Node* new_limit_no_underflow_l = NULL;\n+      if (stride_con > 0) {\n+        \/\/ limit = MaxL(limit - stride, min_jint)\n+        new_limit_no_underflow_l = new MaxLNode(C, new_limit_l, underflow_clamp_l);\n@@ -2038,40 +2056,2 @@\n-        \/\/ (limit - stride) may underflow.\n-        \/\/ Clamp the adjustment value with MININT or MAXINT:\n-        \/\/\n-        \/\/   new_limit = limit-stride\n-        \/\/   if (stride > 0)\n-        \/\/     new_limit = (limit < new_limit) ? MININT : new_limit;\n-        \/\/   else\n-        \/\/     new_limit = (limit > new_limit) ? MAXINT : new_limit;\n-        \/\/\n-        BoolTest::mask bt = loop_end->test_trip();\n-        assert(bt == BoolTest::lt || bt == BoolTest::gt, \"canonical test is expected\");\n-        Node* adj_max = _igvn.intcon((stride_con > 0) ? min_jint : max_jint);\n-        set_ctrl(adj_max, C->root());\n-        Node* old_limit = NULL;\n-        Node* adj_limit = NULL;\n-        Node* bol = limit->is_CMove() ? limit->in(CMoveNode::Condition) : NULL;\n-        if (loop_head->unrolled_count() > 1 &&\n-            limit->is_CMove() && limit->Opcode() == Op_CMoveI &&\n-            limit->in(CMoveNode::IfTrue) == adj_max &&\n-            bol->as_Bool()->_test._test == bt &&\n-            bol->in(1)->Opcode() == Op_CmpI &&\n-            bol->in(1)->in(2) == limit->in(CMoveNode::IfFalse)) {\n-          \/\/ Loop was unrolled before.\n-          \/\/ Optimize the limit to avoid nested CMove:\n-          \/\/ use original limit as old limit.\n-          old_limit = bol->in(1)->in(1);\n-          \/\/ Adjust previous adjusted limit.\n-          adj_limit = limit->in(CMoveNode::IfFalse);\n-          adj_limit = new SubINode(adj_limit, stride);\n-        } else {\n-          old_limit = limit;\n-          adj_limit = new SubINode(limit, stride);\n-        }\n-        assert(old_limit != NULL && adj_limit != NULL, \"\");\n-        register_new_node(adj_limit, ctrl); \/\/ adjust amount\n-        Node* adj_cmp = new CmpINode(old_limit, adj_limit);\n-        register_new_node(adj_cmp, ctrl);\n-        Node* adj_bool = new BoolNode(adj_cmp, bt);\n-        register_new_node(adj_bool, ctrl);\n-        new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);\n+        \/\/ limit = MinL(limit - stride, max_jint)\n+        new_limit_no_underflow_l = new MinLNode(C, new_limit_l, underflow_clamp_l);\n@@ -2079,0 +2059,4 @@\n+      register_new_node(new_limit_no_underflow_l, ctrl);\n+\n+      \/\/ (4) Convert back to int.\n+      new_limit = new ConvL2INode(new_limit_no_underflow_l);\n@@ -2287,0 +2271,3 @@\n+  Node* old_limit_long = new ConvI2LNode(old_limit);\n+  register_new_node(old_limit_long, pre_ctrl);\n+\n@@ -2312,3 +2299,2 @@\n-  \/\/ We use CMove nodes to implement long versions of min\/max (MINL\/MAXL).\n-  \/\/ We use helper methods for inner MINL\/MAXL which return CMoveL nodes to keep a long value for the outer MINL\/MAXL comparison:\n-  Node* inner_result_long;\n+  Node* inner_result_long = NULL;\n+  Node* outer_result_long = NULL;\n@@ -2316,1 +2302,2 @@\n-    inner_result_long = MaxNode::signed_max(limit, _igvn.longcon(min_jint), TypeLong::LONG, _igvn);\n+    inner_result_long = new MaxLNode(C, limit, _igvn.longcon(min_jint));\n+    outer_result_long = new MinLNode(C, inner_result_long, old_limit_long);\n@@ -2318,1 +2305,2 @@\n-    inner_result_long = MaxNode::signed_min(limit, _igvn.longcon(max_jint), TypeLong::LONG, _igvn);\n+    inner_result_long = new MinLNode(C, limit, _igvn.longcon(max_jint));\n+    outer_result_long = new MaxLNode(C, inner_result_long, old_limit_long);\n@@ -2320,1 +2308,2 @@\n-  set_subtree_ctrl(inner_result_long);\n+  register_new_node(inner_result_long, pre_ctrl);\n+  register_new_node(outer_result_long, pre_ctrl);\n@@ -2322,11 +2311,1 @@\n-  \/\/ Outer MINL\/MAXL:\n-  \/\/ The comparison is done with long values but the result is the converted back to int by using CmovI.\n-  Node* old_limit_long = new ConvI2LNode(old_limit);\n-  register_new_node(old_limit_long, pre_ctrl);\n-  Node* cmp = new CmpLNode(old_limit_long, limit);\n-  register_new_node(cmp, pre_ctrl);\n-  Node* bol = new BoolNode(cmp, is_positive_stride ? BoolTest::gt : BoolTest::lt);\n-  register_new_node(bol, pre_ctrl);\n-  Node* inner_result_int = new ConvL2INode(inner_result_long); \/\/ Could under-\/overflow but that's fine as comparison was done with CmpL\n-  register_new_node(inner_result_int, pre_ctrl);\n-  limit = new CMoveINode(bol, old_limit, inner_result_int, TypeInt::INT);\n+  limit = new ConvL2INode(outer_result_long);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":41,"deletions":62,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2633,0 +2633,2 @@\n+               n->Opcode() == Op_MaxL      ||\n+               n->Opcode() == Op_MinL      ||\n@@ -2704,0 +2706,12 @@\n+      } else if (n->Opcode() == Op_MaxL) {\n+        \/\/ Since MaxL and MinL are not implemented in the backend, we expand them to\n+        \/\/ a CMoveL construct now. At least until here, the type could be computed\n+        \/\/ precisely. CMoveL is not so smart, but we can give it at least the best\n+        \/\/ type we know abouot n now.\n+        Node* repl = MaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        _igvn.replace_node(n, repl);\n+        success = true;\n+      } else if (n->Opcode() == Op_MinL) {\n+        Node* repl = MaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        _igvn.replace_node(n, repl);\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1555,0 +1555,2 @@\n+  declare_c2_type(MaxLNode, MaxNode)                                      \\\n+  declare_c2_type(MinLNode, MaxNode)                                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=test1\n+ * @bug 8298935\n+ * @summary CMoveI for underflow protection of the limit did not compute a type that was precise enough.\n+ *          This lead to dead data but zero-trip-guard control did not die -> \"malformed control flow\".\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestUnrollLimitPreciseType::test1\n+ *      -XX:CompileCommand=dontinline,compiler.loopopts.TestUnrollLimitPreciseType::*\n+ *      -XX:MaxVectorSize=64\n+ *      -Xcomp\n+ *      -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n+ *      compiler.loopopts.TestUnrollLimitPreciseType test1\n+ *\/\n+\n+\/*\n+ * @test id=test2\n+ * @bug 8298935\n+ * @summary CMoveI for underflow protection of the limit did not compute a type that was precise enough.\n+ *          This lead to dead data but zero-trip-guard control did not die -> \"malformed control flow\".\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestUnrollLimitPreciseType::*\n+ *      -Xcomp\n+ *      compiler.loopopts.TestUnrollLimitPreciseType test2\n+ *\/\n+\n+\n+package compiler.loopopts;\n+\n+public class TestUnrollLimitPreciseType {\n+    static final int RANGE = 512;\n+\n+    public static void main(String args[]) {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Need exactly one argument.\");\n+        }\n+        if (args[0].equals(\"test1\")) {\n+            byte[] data = new byte[RANGE];\n+            test1(data);\n+        } else if (args[0].equals(\"test2\")) {\n+            test2();\n+        } else {\n+            throw new RuntimeException(\"Do not have: \" + args[0]);\n+        }\n+    }\n+\n+    public static void test1(byte[] data) {\n+        \/\/ Did not fully analyze this. But it is also unrolled, SuperWorded,\n+        \/\/ and further unrolled with vectorlized post loop.\n+        \/\/ Only seems to reproduce with avx512, and not with avx2.\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j - 192] = (byte)(data[j] * 11);\n+        }\n+    }\n+\n+    static void test2() {\n+        \/\/ Loop is SuperWord'ed.\n+        \/\/ We unroll more afterwards, and so add vectorized post loop.\n+        \/\/ But it turns out that the vectorized post loop is never entered.\n+        \/\/ This lead to assert, because the zero-trip-guard did not collaspse,\n+        \/\/ but the CastII with the trip count did die.\n+        \/\/ Only seems to reproduce with avx512, and not with avx2.\n+        double dArr[][] = new double[100][100];\n+        for (int i = 2, j = 2; j < 68; j++) {\n+            dArr[i][j] = 8;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnrollLimitPreciseType.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}