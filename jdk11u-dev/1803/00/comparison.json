{"files":[{"patch":"@@ -379,0 +379,4 @@\n+        private static boolean equalsIgnoreCase(String s1, String s2) {\n+            return s1 == s2 || (s1 != null && s1.equalsIgnoreCase(s2));\n+        }\n+\n@@ -380,3 +384,7 @@\n-            for (CacheEntry entry : entries) {\n-                if (entry.equalsKey(domain, proxy)) {\n-                    entries.remove(entry);\n+            var iterator = entries.iterator();\n+            while (iterator.hasNext()) {\n+                var entry = iterator.next();\n+                if (equalsIgnoreCase(entry.scheme, authscheme)) {\n+                    if (entry.equalsKey(domain, proxy)) {\n+                        iterator.remove();\n+                    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+\n+\/**\n+ * @test\n+ * @bug 8232853\n+ * @summary AuthenticationFilter.Cache::remove may throw ConcurrentModificationException\n+ * @library \/lib\/testlibrary http2\/server\n+ * @build jdk.testlibrary.SimpleSSLContext HttpServerAdapters DigestEchoServer\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ * java.net.http\/jdk.internal.net.http.frame\n+ * java.net.http\/jdk.internal.net.http.hpack\n+ * java.logging\n+ * java.base\/sun.net.www.http\n+ * java.base\/sun.net.www\n+ * java.base\/sun.net\n+ * @run testng\/othervm -Dtest.requiresHost=true\n+ * -Djdk.httpclient.HttpClient.log=headers\n+ * -Djdk.internal.httpclient.debug=false\n+ * AuthFilterCacheTest\n+ *\/\n+\n+public class AuthFilterCacheTest implements HttpServerAdapters {\n+\n+    static final String RESPONSE_BODY = \"Hello World!\";\n+    static final int REQUEST_COUNT = 5;\n+    static final int URI_COUNT = 6;\n+    static final CyclicBarrier barrier = new CyclicBarrier(REQUEST_COUNT * URI_COUNT);\n+    static final SSLContext context;\n+\n+    static {\n+        try {\n+            context = new jdk.testlibrary.SimpleSSLContext().get();\n+            SSLContext.setDefault(context);\n+        } catch (Exception x) {\n+            throw new ExceptionInInitializerError(x);\n+        }\n+    }\n+\n+    HttpTestServer http1Server;\n+    HttpTestServer http2Server;\n+    HttpTestServer https1Server;\n+    HttpTestServer https2Server;\n+    DigestEchoServer.TunnelingProxy proxy;\n+    URI http1URI;\n+    URI https1URI;\n+    URI http2URI;\n+    URI https2URI;\n+    InetSocketAddress proxyAddress;\n+    ProxySelector proxySelector;\n+    MyAuthenticator auth;\n+    HttpClient client;\n+    Executor executor = Executors.newCachedThreadPool();\n+\n+    @DataProvider(name = \"uris\")\n+    Object[][] testURIs() {\n+        Object[][] uris = new Object[][]{\n+                {List.of(http1URI.resolve(\"direct\/orig\/\"),\n+                        https1URI.resolve(\"direct\/orig\/\"),\n+                        https1URI.resolve(\"proxy\/orig\/\"),\n+                        http2URI.resolve(\"direct\/orig\/\"),\n+                        https2URI.resolve(\"direct\/orig\/\"),\n+                        https2URI.resolve(\"proxy\/orig\/\"))}\n+        };\n+        return uris;\n+    }\n+\n+    public HttpClient newHttpClient(ProxySelector ps, Authenticator auth) {\n+        HttpClient.Builder builder = HttpClient\n+                .newBuilder()\n+                .sslContext(context)\n+                .authenticator(auth)\n+                .proxy(ps);\n+        return builder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp() throws Exception {\n+        try {\n+            InetSocketAddress sa =\n+                    new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+            auth = new MyAuthenticator();\n+\n+            \/\/ HTTP\/1.1\n+            HttpServer server1 = HttpServer.create(sa, 0);\n+            server1.setExecutor(executor);\n+            http1Server = HttpTestServer.of(server1);\n+            http1Server.addHandler(new TestHandler(), \"\/AuthFilterCacheTest\/http1\/\");\n+            http1Server.start();\n+            http1URI = new URI(\"http:\/\/\" + http1Server.serverAuthority()\n+                    + \"\/AuthFilterCacheTest\/http1\/\");\n+\n+            \/\/ HTTPS\/1.1\n+            HttpsServer sserver1 = HttpsServer.create(sa, 100);\n+            sserver1.setExecutor(executor);\n+            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            https1Server = HttpTestServer.of(sserver1);\n+            https1Server.addHandler(new TestHandler(), \"\/AuthFilterCacheTest\/https1\/\");\n+            https1Server.start();\n+            https1URI = new URI(\"https:\/\/\" + https1Server.serverAuthority()\n+                    + \"\/AuthFilterCacheTest\/https1\/\");\n+\n+            \/\/ HTTP\/2.0\n+            http2Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server.addHandler(new TestHandler(), \"\/AuthFilterCacheTest\/http2\/\");\n+            http2Server.start();\n+            http2URI = new URI(\"http:\/\/\" + http2Server.serverAuthority()\n+                    + \"\/AuthFilterCacheTest\/http2\/\");\n+\n+            \/\/ HTTPS\/2.0\n+            https2Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server.addHandler(new TestHandler(), \"\/AuthFilterCacheTest\/https2\/\");\n+            https2Server.start();\n+            https2URI = new URI(\"https:\/\/\" + https2Server.serverAuthority()\n+                    + \"\/AuthFilterCacheTest\/https2\/\");\n+\n+            proxy = DigestEchoServer.createHttpsProxyTunnel(\n+                    DigestEchoServer.HttpAuthSchemeType.NONE);\n+            proxyAddress = proxy.getProxyAddress();\n+            proxySelector = new HttpProxySelector(proxyAddress);\n+            client = newHttpClient(proxySelector, auth);\n+\n+            System.out.println(\"Setup: done\");\n+        } catch (Exception x) {\n+            tearDown();\n+            throw x;\n+        } catch (Error e) {\n+            tearDown();\n+            throw e;\n+        }\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        proxy = stop(proxy, DigestEchoServer.TunnelingProxy::stop);\n+        http1Server = stop(http1Server, HttpTestServer::stop);\n+        https1Server = stop(https1Server, HttpTestServer::stop);\n+        http2Server = stop(http2Server, HttpTestServer::stop);\n+        https2Server = stop(https2Server, HttpTestServer::stop);\n+        client = null;\n+\n+        System.out.println(\"Teardown: done\");\n+    }\n+\n+    private interface Stoppable<T> {\n+        void stop(T service) throws Exception;\n+    }\n+\n+    static <T> T stop(T service, Stoppable<T> stop) {\n+        try {\n+            if (service != null) stop.stop(service);\n+        } catch (Throwable x) {\n+        }\n+        return null;\n+    }\n+\n+    static class HttpProxySelector extends ProxySelector {\n+        private static final List<Proxy> NO_PROXY = List.of(Proxy.NO_PROXY);\n+        private final List<Proxy> proxyList;\n+\n+        HttpProxySelector(InetSocketAddress proxyAddress) {\n+            proxyList = List.of(new Proxy(Proxy.Type.HTTP, proxyAddress));\n+        }\n+\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+            \/\/ Our proxy only supports tunneling\n+            if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n+                if (uri.getPath().contains(\"\/proxy\/\")) {\n+                    return proxyList;\n+                }\n+            }\n+            return NO_PROXY;\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n+            System.err.println(\"Connection to proxy failed: \" + ioe);\n+            System.err.println(\"Proxy: \" + sa);\n+            System.err.println(\"\\tURI: \" + uri);\n+            ioe.printStackTrace();\n+        }\n+    }\n+\n+    public static class TestHandler implements HttpTestHandler {\n+        static final AtomicLong respCounter = new AtomicLong();\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            var count = respCounter.incrementAndGet();\n+            System.out.println(\"Responses handled: \" + count);\n+            t.getRequestBody().readAllBytes();\n+\n+            if (t.getRequestMethod().equalsIgnoreCase(\"GET\")) {\n+                if (!t.getRequestHeaders().containsKey(\"Authorization\")) {\n+                    t.getResponseHeaders()\n+                            .addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"Earth\\\"\");\n+                    t.sendResponseHeaders(401, 0);\n+                } else {\n+                    byte[] resp = RESPONSE_BODY.getBytes(StandardCharsets.UTF_8);\n+                    t.sendResponseHeaders(200, resp.length);\n+                    try {\n+                        barrier.await();\n+                    } catch (Exception e) {\n+                        throw new IOException(e);\n+                    }\n+                    t.getResponseBody().write(resp);\n+                }\n+            }\n+            t.close();\n+        }\n+    }\n+\n+    void doClient(List<URI> uris) {\n+        assert uris.size() == URI_COUNT;\n+        barrier.reset();\n+        System.out.println(\"Client opening connection to: \" + uris.toString());\n+\n+        List<CompletableFuture<HttpResponse<String>>> cfs = new ArrayList<>();\n+\n+        for (int i = 0; i < REQUEST_COUNT; i++) {\n+            for (URI uri : uris) {\n+                HttpRequest req = HttpRequest.newBuilder()\n+                        .uri(uri)\n+                        .build();\n+                cfs.add(client.sendAsync(req, HttpResponse.BodyHandlers.ofString()));\n+            }\n+        }\n+        CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();\n+    }\n+\n+    static class MyAuthenticator extends Authenticator {\n+        private int count = 0;\n+\n+        MyAuthenticator() {\n+            super();\n+        }\n+\n+        public PasswordAuthentication getPasswordAuthentication() {\n+            System.out.println(\"Authenticator called: \" + ++count);\n+            return (new PasswordAuthentication(\"user\" + count,\n+                    (\"passwordNotCheckedAnyway\" + count).toCharArray()));\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void test(List<URI> uris) throws Exception {\n+        System.out.println(\"Server listening at \" + uris.toString());\n+        doClient(uris);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"}]}