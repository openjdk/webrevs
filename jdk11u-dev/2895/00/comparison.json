{"files":[{"patch":"@@ -332,1 +332,5 @@\n-        initialStream.registerStream(1);\n+        boolean opened = initialStream.registerStream(1, true);\n+        if (debug.on() && !opened) {\n+            debug.log(\"Initial stream was cancelled - but connection is maintained: \" +\n+                    \"reset frame will need to be sent later\");\n+        }\n@@ -341,0 +345,5 @@\n+        if (!opened) {\n+            debug.log(\"ensure reset frame is sent to cancel initial stream\");\n+            initialStream.sendCancelStreamFrame();\n+        }\n+\n@@ -850,1 +859,1 @@\n-        pushStream.registerStream(promisedStreamid);\n+        pushStream.registerStream(promisedStreamid, true);\n@@ -875,1 +884,1 @@\n-    void resetStream(int streamid, int code) throws IOException {\n+    void resetStream(int streamid, int code) {\n@@ -883,0 +892,1 @@\n+                markStream(streamid, code);\n@@ -895,0 +905,5 @@\n+    private void markStream(int streamid, int code) {\n+        Stream<?> s = streams.get(streamid);\n+        if (s != null) s.markStream(code);\n+    }\n+\n@@ -1196,6 +1211,13 @@\n-        nextstreamid += 2;\n-        stream.registerStream(streamid);\n-        \/\/ set outgoing window here. This allows thread sending\n-        \/\/ body to proceed.\n-        windowController.registerStream(streamid, getInitialSendWindowSize());\n-        return stream;\n+        if (stream.registerStream(streamid, false)) {\n+            \/\/ set outgoing window here. This allows thread sending\n+            \/\/ body to proceed.\n+            nextstreamid += 2;\n+            windowController.registerStream(streamid, getInitialSendWindowSize());\n+            return stream;\n+        } else {\n+            stream.cancelImpl(new IOException(\"Request cancelled\"));\n+            if (finalStream() && streams.isEmpty()) {\n+                close();\n+            }\n+            return null;\n+        }\n@@ -1215,1 +1237,3 @@\n-                    publisher.enqueue(encodeHeaders(oh, stream));\n+                    if (stream != null) {\n+                        publisher.enqueue(encodeHeaders(oh, stream));\n+                    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -249,1 +249,1 @@\n-            debug().log(() -> \"abort: \" + error);\n+            debug().log(() -> this.getClass().getSimpleName() + \" abort: \" + error);\n@@ -727,0 +727,1 @@\n+                if (debug.on()) debug.log(\"Read subscription cancelled\");\n@@ -731,0 +732,1 @@\n+                if (debug.on()) debug.log(\"Stopping read scheduler\");\n@@ -751,0 +753,1 @@\n+                if (debug.on()) debug.log(\"signal read error: \" + error);\n@@ -811,0 +814,1 @@\n+                            if (debug.on()) debug.log(\"Stopping read scheduler\");\n@@ -834,0 +838,1 @@\n+                                        if (debug.on()) debug.log(\"Stopping read scheduler\");\n@@ -853,0 +858,1 @@\n+                                    if (errorRef.get() != null) continue;\n@@ -864,0 +870,1 @@\n+                                    if (errorRef.get() != null) continue;\n@@ -882,0 +889,1 @@\n+                            if (errorRef.get() != null) continue;\n@@ -949,0 +957,1 @@\n+                if (debug.on()) debug.log(\"signalError to %s (%s)\", sub, error);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -137,2 +139,5 @@\n-\n-    final AtomicBoolean deRegistered = new AtomicBoolean(false);\n+    \/\/ Indicates the first reason that was invoked when sending a ResetFrame\n+    \/\/ to the server. A streamState of 0 indicates that no reset was sent.\n+    \/\/ (see markStream(int code)\n+    private volatile int streamState; \/\/ assigned using STREAM_STATE varhandle.\n+    private volatile boolean deRegistered; \/\/ assigned using DEREGISTERED varhandle.\n@@ -143,0 +148,3 @@\n+    \/\/ send lock: prevent sending DataFrames after reset occurred.\n+    private final Object sendLock = new Object();\n+\n@@ -296,1 +304,1 @@\n-        return deRegistered.compareAndSet(false, true);\n+        return DEREGISTERED.compareAndSet(this, false, true);\n@@ -339,0 +347,30 @@\n+    \/**\n+     * Records the first reason which was invoked when sending a ResetFrame\n+     * to the server in the streamState, and return the previous value\n+     * of the streamState. This is an atomic operation.\n+     * A possible use of this method would be to send a ResetFrame only\n+     * if no previous reset frame has been sent.\n+     * For instance: <pre>{@code\n+     *  if (markStream(ResetFrame.CANCEL) == 0) {\n+     *      connection.sendResetFrame(streamId, ResetFrame.CANCEL);\n+     *  }\n+     *  }<\/pre>\n+     * @param code the reason code as per HTTP\/2 protocol\n+     * @return the previous value of the stream state.\n+     *\/\n+    int  markStream(int code) {\n+        if (code == 0) return streamState;\n+        synchronized (sendLock) {\n+            return (int) STREAM_STATE.compareAndExchange(this, 0, code);\n+        }\n+    }\n+\n+    private void sendDataFrame(DataFrame frame) {\n+         synchronized (sendLock) {\n+             \/\/ must not send DataFrame after reset.\n+             if (streamState == 0) {\n+                connection.sendDataFrame(frame);\n+             }\n+        }\n+    }\n+\n@@ -395,0 +433,1 @@\n+        var cancelled = closed || streamState != 0;\n@@ -406,1 +445,2 @@\n-            receiveDataFrame((DataFrame)frame);\n+            if (cancelled) connection.dropDataFrame((DataFrame) frame);\n+            else receiveDataFrame((DataFrame) frame);\n@@ -408,1 +448,1 @@\n-            otherFrame(frame);\n+            if (!cancelled) otherFrame(frame);\n@@ -737,0 +777,10 @@\n+\n+        \/\/ At this point the stream doesn't have a streamid yet.\n+        \/\/ It will be allocated if we send the request headers.\n+        Throwable t = errorRef.get();\n+        if (t != null) {\n+            if (debug.on()) debug.log(\"stream already cancelled, headers not sent: %s\", (Object)t);\n+            return MinimalFuture.failedFuture(t);\n+        }\n+\n+        \/\/ sending the headers will cause the allocation of the stream id\n@@ -762,4 +812,11 @@\n-    void registerStream(int id) {\n-        this.streamid = id;\n-        connection.putStream(this, streamid);\n-        if (debug.on()) debug.log(\"Registered stream %d\", id);\n+    boolean registerStream(int id, boolean registerIfCancelled) {\n+        boolean cancelled = closed;\n+        if (!cancelled || registerIfCancelled) {\n+            this.streamid = id;\n+            connection.putStream(this, streamid);\n+            if (debug.on()) {\n+                debug.log(\"Stream %d registered (cancelled: %b, registerIfCancelled: %b)\",\n+                        streamid, cancelled, registerIfCancelled);\n+            }\n+        }\n+        return !cancelled;\n@@ -870,0 +927,1 @@\n+                int state = streamState;\n@@ -882,1 +940,1 @@\n-                    while (item.hasRemaining()) {\n+                    while (item.hasRemaining() && state == 0) {\n@@ -900,0 +958,1 @@\n+                                assert streamid > 0;\n@@ -910,0 +969,4 @@\n+                        if ((state = streamState) != 0) {\n+                            if (debug.on()) debug.log(\"trySend: cancelled: %s\", String.valueOf(t));\n+                            break;\n+                        }\n@@ -912,1 +975,1 @@\n-                        connection.sendDataFrame(df);\n+                        sendDataFrame(df);\n@@ -914,0 +977,1 @@\n+                    if (state != 0) break;\n@@ -919,0 +983,6 @@\n+                if (state != 0) {\n+                    t = errorRef.get();\n+                    if (t == null) t = new IOException(ResetFrame.stringForCode(streamState));\n+                    throw t;\n+                }\n+\n@@ -1121,1 +1191,5 @@\n-        cancel(new IOException(\"Stream \" + streamid + \" cancelled\"));\n+        if ((streamid == 0)) {\n+            cancel(new IOException(\"Stream cancelled before streamid assigned\"));\n+        } else {\n+            cancel(new IOException(\"Stream \" + streamid + \" cancelled\"));\n+        }\n@@ -1154,1 +1228,4 @@\n-        if (debug.on()) debug.log(\"cancelling stream {0}: {1}\", streamid, e);\n+        if (debug.on()) {\n+            if (streamid == 0) debug.log(\"cancelling stream: %s\", (Object)e);\n+            else debug.log(\"cancelling stream %d: %s\", streamid, e);\n+        }\n@@ -1156,1 +1233,2 @@\n-            Log.logTrace(\"cancelling stream {0}: {1}\\n\", streamid, e);\n+            if (streamid == 0) Log.logTrace(\"cancelling stream: {0}\\n\", e);\n+            else Log.logTrace(\"cancelling stream {0}: {1}\\n\", streamid, e);\n@@ -1179,2 +1257,1 @@\n-            if (streamid != 0) {\n-                connection.decrementStreamsCount(streamid);\n+            if (streamid != 0 && streamState == 0) {\n@@ -1184,0 +1261,1 @@\n+                    connection.decrementStreamsCount(streamid);\n@@ -1186,1 +1264,2 @@\n-                    connection.resetStream(streamid, ResetFrame.CANCEL);\n+                    \/\/ no use to send CANCEL if already closed.\n+                    sendCancelStreamFrame();\n@@ -1194,0 +1273,8 @@\n+    void sendCancelStreamFrame() {\n+        \/\/ do not reset a stream until it has a streamid.\n+        if (streamid > 0 && markStream(ResetFrame.CANCEL) == 0) {\n+            connection.resetStream(streamid, ResetFrame.CANCEL);\n+        }\n+        close();\n+    }\n+\n@@ -1409,0 +1496,13 @@\n+\n+    private static final VarHandle STREAM_STATE;\n+    private static final VarHandle DEREGISTERED;\n+    static {\n+        try {\n+            STREAM_STATE = MethodHandles.lookup()\n+                    .findVarHandle(Stream.class, \"streamState\", int.class);\n+            DEREGISTERED = MethodHandles.lookup()\n+                    .findVarHandle(Stream.class, \"deRegistered\", boolean.class);\n+        } catch (Exception x) {\n+            throw new ExceptionInInitializerError(x);\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":117,"deletions":17,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsInputStreamCustom.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsInputStreamIO.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsLinesCustom.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsLinesIO.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsStringCustom.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesAsStringIO.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8229822\n","filename":"test\/jdk\/java\/net\/httpclient\/ThrowingPushPromisesSanity.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}