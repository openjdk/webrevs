{"files":[{"patch":"@@ -51,1 +51,3 @@\n-    vm.gc.Z \\\n+    vm.gc.G1 \\\n+    vm.gc.Serial \\\n+    vm.gc.Parallel \\\n@@ -53,0 +55,2 @@\n+    vm.gc.Epsilon \\\n+    vm.gc.Z \\\n","filename":"test\/jdk\/TEST.ROOT","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,39 @@\n-\/* @test\n+\/*\n+ * @test id=G1\n+ * @requires vm.gc.G1\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (G1 GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseG1GC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @requires vm.gc.Parallel\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Parallel GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseParallelGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Z\n+ * @requires vm.gc.Z\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Z GC)\n+ * @run testng\/othervm -Xmx256m -XX:+UnlockExperimentalVMOptions -XX:+UseZGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Shenandoah GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @requires vm.gc.Serial\n@@ -38,2 +76,2 @@\n- * @summary ObjectStreamClass caches keep ClassLoaders alive\n- * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Serial GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseSerialGC ObjectStreamClassCaching\n@@ -43,0 +81,4 @@\n+    \/**\n+     * Test methods execute in same VM and are ordered by name.\n+     * We test effectiveness 1st which is sensitive to previous allocations when ZGC is used.\n+     *\/\n@@ -44,2 +86,19 @@\n-    public void testCachingEffectiveness() throws Exception {\n-        var ref = lookupObjectStreamClass(TestClass.class);\n+    public void test1CacheEffectiveness() throws Exception {\n+        var list = new ArrayList<>();\n+        var ref1 = lookupObjectStreamClass(TestClass1.class);\n+        var ref2 = newWeakRef();\n+        boolean oome = false;\n+        try {\n+            while (ref2.get() != null) {\n+                list.add(new byte[1024 * 1024 * 1]); \/\/ 1 MiB chunks\n+                System.out.println(\"1MiB allocated...\");\n+                Thread.sleep(5L);\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+            list = null;\n+            oome = true;\n+        }\n+        assertFalse(oome, \"WeakReference was not cleared although memory was pressed hard\");\n+        assertNotNull(ref1.get(),\n+                    \"Cache lost entry together with WeakReference being cleared although memory was not under pressure\");\n@@ -48,3 +107,0 @@\n-        \/\/ to trigger any ReferenceQueue processing...\n-        lookupObjectStreamClass(AnotherTestClass.class);\n-        assertNotNull(ref.get(), \"Cache lost entry although memory was not under pressure\");\n@@ -54,3 +110,12 @@\n-    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n-        var ref = lookupObjectStreamClass(TestClass.class);\n-        pressMemoryHard(ref);\n+    public void test2CacheReleaseUnderMemoryPressure() throws Exception {\n+        var list = new ArrayList<>();\n+        var ref = lookupObjectStreamClass(TestClass2.class);\n+        try {\n+            while (ref.get() != null) {\n+                list.add(new byte[1024 * 1024 * 4]); \/\/ 4 MiB chunks\n+                System.out.println(\"4MiB allocated...\");\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+            list = null;\n+        }\n@@ -63,1 +128,1 @@\n-    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n+    private static Reference<?> lookupObjectStreamClass(Class<?> cl) {\n@@ -67,9 +132,3 @@\n-    private static void pressMemoryHard(Reference<?> ref) {\n-        try {\n-            var list = new ArrayList<>();\n-            while (ref.get() != null) {\n-                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n-            }\n-        } catch (OutOfMemoryError e) {\n-            \/\/ release\n-        }\n+    \/\/ separate method so that the new Object() is not kept on stack\n+    private static Reference<?> newWeakRef() {\n+        return new WeakReference<>(new Object());\n@@ -77,1 +136,0 @@\n-}\n@@ -79,2 +137,2 @@\n-class TestClass implements Serializable {\n-}\n+    static class TestClass1 implements Serializable {\n+    }\n@@ -82,1 +140,2 @@\n-class AnotherTestClass implements Serializable {\n+    static class TestClass2 implements Serializable {\n+    }\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":85,"deletions":26,"binary":false,"changes":111,"status":"modified"}]}