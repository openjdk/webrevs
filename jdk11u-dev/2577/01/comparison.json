{"files":[{"patch":"@@ -557,0 +557,12 @@\n+# Native files needed by the testlib\n+\n+build-test-lib-native:\n+\t+($(CD) $(TOPDIR)\/make\/test && $(MAKE) $(MAKE_ARGS) -f BuildTestLibNative.gmk \\\n+\t    build-test-lib-native)\n+\n+test-image-lib-native:\n+\t+($(CD) $(TOPDIR)\/make\/test && $(MAKE) $(MAKE_ARGS) -f BuildTestLibNative.gmk \\\n+\t    test-image-lib-native)\n+\n+# Native files needed when testing the testlib itself\n+\n@@ -1145,0 +1157,1 @@\n+    test-image-lib-native \\\n","filename":"make\/Main.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-# test-lib.jar will contain only hprof classes until JDK-8081381 is resolved\n@@ -51,1 +50,2 @@\n-    SRC := $(TEST_LIB_SOURCE_DIR)\/jdk\/test\/lib\/hprof, \\\n+    SRC := $(TEST_LIB_SOURCE_DIR), \\\n+    EXCLUDES := jdk\/test\/lib\/containers jdk\/test\/lib\/security, \\\n@@ -53,0 +53,1 @@\n+    HEADERS := $(TEST_LIB_SUPPORT)\/test-lib_headers, \\\n@@ -54,0 +55,1 @@\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# This file builds the native component of testlib.\n+# It also covers the test-image part, where the built files are copied to the\n+# test image.\n+################################################################################\n+\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include TestFilesCompilation.gmk\n+\n+################################################################################\n+# Targets for building the native tests themselves.\n+################################################################################\n+\n+BUILD_LIBTEST_NATIVE_SRC := $(TOPDIR)\/test\/lib\n+\n+BUILD_LIBTEST_OUTPUT_DIR := $(OUTPUTDIR)\/support\/test\/lib\/native\n+\n+BUILD_LIBTEST_IMAGE_DIR := $(TEST_IMAGE_DIR)\/lib\n+\n+# This evaluation is expensive and should only be done if this target was\n+# explicitly called.\n+ifneq ($(filter build-test-lib-native, $(MAKECMDGOALS)), )\n+  $(eval $(call SetupTestFilesCompilation, BUILD_LIBTEST_LIBRARIES, \\\n+      TYPE := LIBRARY, \\\n+      SOURCE_DIRS := $(BUILD_LIBTEST_NATIVE_SRC), \\\n+      OUTPUT_DIR := $(BUILD_LIBTEST_OUTPUT_DIR), \\\n+  ))\n+endif\n+\n+build-test-lib-native: $(BUILD_LIBTEST_LIBRARIES)\n+\n+################################################################################\n+# Targets for building test-image.\n+################################################################################\n+\n+# Copy to testlib test image. We need it in both hotspot and jdk.\n+$(eval $(call SetupCopyFiles, COPY_LIBTEST_NATIVE_TO_HOTSPOT, \\\n+    SRC := $(BUILD_LIBTEST_OUTPUT_DIR), \\\n+    DEST := $(TEST_IMAGE_DIR)\/hotspot\/jtreg\/native, \\\n+    FILES := $(wildcard $(addprefix $(BUILD_LIBTEST_OUTPUT_DIR), \/lib\/*)), \\\n+    FLATTEN := true, \\\n+))\n+\n+$(eval $(call SetupCopyFiles, COPY_LIBTEST_NATIVE_TO_JDK, \\\n+    SRC := $(BUILD_LIBTEST_OUTPUT_DIR), \\\n+    DEST := $(TEST_IMAGE_DIR)\/jdk\/jtreg\/native, \\\n+    FILES := $(wildcard $(addprefix $(BUILD_LIBTEST_OUTPUT_DIR), \/lib\/*)), \\\n+    FLATTEN := true, \\\n+))\n+\n+test-image-lib-native: $(COPY_LIBTEST_NATIVE_TO_HOTSPOT) $(COPY_LIBTEST_NATIVE_TO_JDK)\n+\n+all: build-test-lib-native\n+\n+.PHONY: default all build-test-lib-native test-image-lib-native\n","filename":"make\/test\/BuildTestLibNative.gmk","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -177,1 +177,1 @@\n-serviceability\/sa\/ClhsdbPmap.java 8294316,8193639,8211767,8267433 solaris-all,linux-ppc64le,linux-ppc64,macosx-x64\n+serviceability\/sa\/ClhsdbPmap.java 8294316,8269982,8193639,8211767,8267433 solaris-all,linux-ppc64le,linux-ppc64,macosx-aarch64,macosx-x64\n@@ -205,2 +205,2 @@\n-serviceability\/sa\/TestJmapCore.java 8294316,8193639,8267433 solaris-all,macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8294316,8193639,8267433 solaris-all,macosx-x64\n+serviceability\/sa\/TestJmapCore.java 8294316,8269982,8193639,8267433 solaris-all,macosx-aarch64,macosx-x64\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8294316,8269982,8193639,8267433 solaris-all,macosx-aarch64,macosx-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @requires os.family != \"windows\"\n@@ -50,1 +49,0 @@\n-import java.nio.file.Path;\n@@ -53,2 +51,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n@@ -56,1 +52,0 @@\n-import java.util.Scanner;\n@@ -59,0 +54,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -67,4 +63,0 @@\n-\n-    private static final String TEST_CDS_CORE_FILE_NAME = \"cds_core_file\";\n-    private static final String LOCATIONS_STRING = \"location: \";\n-    private static final String RUN_SHELL_NO_LIMIT = \"ulimit -c unlimited && \";\n@@ -72,1 +64,1 @@\n-    private static final String CORE_PATTERN_FILE_NAME = \"\/proc\/sys\/kernel\/core_pattern\";\n+    private static String coreFileName;\n@@ -93,1 +85,1 @@\n-            OutputAnalyzer crashOut;\n+            OutputAnalyzer crashOutput;\n@@ -97,3 +89,4 @@\n-               crashOut =\n-                   ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n-                   RUN_SHELL_NO_LIMIT, options.toArray(new String[0])));\n+               ProcessBuilder pb = ProcessTools.createTestJvm(options);\n+               \/\/ Add \"ulimit -c unlimited\" if we can since we are generating a core file.\n+               pb = CoreUtils.addCoreUlimitCommand(pb);\n+               crashOutput = ProcessTools.executeProcess(pb);\n@@ -104,37 +97,0 @@\n-            System.out.println(crashOut.getOutput());\n-            String crashOutputString = crashOut.getOutput();\n-            String coreFileLocation = getCoreFileLocation(crashOutputString);\n-            if (coreFileLocation == null) {\n-                if (Platform.isOSX()) {\n-                    File coresDir = new File(\"\/cores\");\n-                    if (!coresDir.isDirectory()) {\n-                        cleanup();\n-                        throw new Error(coresDir + \" is not a directory\");\n-                    }\n-                    \/\/ the \/cores directory is usually not writable on macOS 10.15\n-                    if (!coresDir.canWrite()) {\n-                        cleanup();\n-                        throw new SkippedException(\"Directory \\\"\" + coresDir +\n-                            \"\\\" is not writable\");\n-                    }\n-                } else if (Platform.isLinux()) {\n-                    \/\/ Check if a crash report tool is installed.\n-                    File corePatternFile = new File(CORE_PATTERN_FILE_NAME);\n-                    try (Scanner scanner = new Scanner(corePatternFile)) {\n-                        while (scanner.hasNextLine()) {\n-                            String line = scanner.nextLine();\n-                            line = line.trim();\n-                            System.out.println(line);\n-                            if (line.startsWith(\"|\")) {\n-                                System.out.println(\n-                                    \"\\nThis system uses a crash report tool ($cat \/proc\/sys\/kernel\/core_pattern).\\n\" +\n-                                    \"Core files might not be generated. Please reset \/proc\/sys\/kernel\/core_pattern\\n\" +\n-                                    \"to enable core generation. Skipping this test.\");\n-                                cleanup();\n-                                throw new SkippedException(\"This system uses a crash report tool\");\n-                            }\n-                        }\n-                    }\n-                }\n-                throw new Error(\"Couldn't find core file location in: '\" + crashOutputString + \"'\");\n-            }\n@@ -142,4 +98,4 @@\n-                Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n-                Files.move(Paths.get(coreFileLocation), Paths.get(TEST_CDS_CORE_FILE_NAME));\n-            } catch (IOException ioe) {\n-                throw new Error(\"Can't move core file: \" + ioe, ioe);\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput.getStdout());\n+            } catch (Exception e) {\n+                cleanup();\n+                throw e;\n@@ -153,2 +109,1 @@\n-            String useSharedSpacesOutput = test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds,\n-                                                          null, null);\n+            String useSharedSpacesOutput = test.runOnCore(coreFileName, cmds, null, null);\n@@ -208,1 +163,1 @@\n-            test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds, expStrMap, unExpStrMap);\n+            test.runOnCore(coreFileName, cmds, expStrMap, unExpStrMap);\n@@ -218,52 +173,0 @@\n-    \/\/ lets search for a few possible locations using process output and return existing location\n-    private static String getCoreFileLocation(String crashOutputString) {\n-        Asserts.assertTrue(crashOutputString.contains(LOCATIONS_STRING),\n-            \"Output doesn't contain the location of core file.\");\n-        String stringWithLocation = Arrays.stream(crashOutputString.split(\"\\\\r?\\\\n\"))\n-            .filter(str -> str.contains(LOCATIONS_STRING))\n-            .findFirst()\n-            .get();\n-        stringWithLocation = stringWithLocation.substring(stringWithLocation\n-            .indexOf(LOCATIONS_STRING) + LOCATIONS_STRING.length());\n-        System.out.println(\"getCoreFileLocation found stringWithLocation = \" + stringWithLocation);\n-        String coreWithPid;\n-        if (stringWithLocation.contains(\"or \")) {\n-            Matcher m = Pattern.compile(\"or.* ([^ ]+[^\\\\)])\\\\)?\").matcher(stringWithLocation);\n-            if (!m.find()) {\n-                throw new Error(\"Couldn't find path to core inside location string\");\n-            }\n-            coreWithPid = m.group(1);\n-        } else {\n-            coreWithPid = stringWithLocation.trim();\n-        }\n-        if (new File(coreWithPid).exists()) {\n-            return coreWithPid;\n-        }\n-        String justCore = Paths.get(\"core\").toString();\n-        if (new File(justCore).exists()) {\n-            return justCore;\n-        }\n-        Path coreWithPidPath = Paths.get(coreWithPid);\n-        String justFile = coreWithPidPath.getFileName().toString();\n-        if (new File(justFile).exists()) {\n-            return justFile;\n-        }\n-        Path parent = coreWithPidPath.getParent();\n-        if (parent != null) {\n-            String coreWithoutPid = parent.resolve(\"core\").toString();\n-            if (new File(coreWithoutPid).exists()) {\n-                return coreWithoutPid;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static String[] getTestJvmCommandlineWithPrefix(String prefix, String... args) {\n-        try {\n-            String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJvm(args));\n-            return new String[]{\"sh\", \"-c\", prefix + cmd};\n-        } catch (Throwable t) {\n-            throw new Error(\"Can't create process builder: \" + t, t);\n-        }\n-    }\n-\n@@ -271,1 +174,1 @@\n-        remove(TEST_CDS_CORE_FILE_NAME);\n+        if (coreFileName != null) remove(coreFileName);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbCDSCore.java","additions":14,"deletions":111,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -35,1 +36,1 @@\n- * @summary Test the clhsdb 'findpc' command\n+ * @summary Test the clhsdb 'findpc' command with Xcomp on live process\n@@ -39,1 +40,34 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC true false\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command with Xcomp on core file\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC true true\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command w\/o Xcomp on live process\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC false false\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command w\/o Xcomp on core file\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC false true\n@@ -44,1 +78,1 @@\n-    private static void testFindPC(boolean withXcomp) throws Exception {\n+    private static void testFindPC(boolean withXcomp, boolean withCore) throws Exception {\n@@ -46,0 +80,1 @@\n+        String coreFileName = null;\n@@ -50,0 +85,1 @@\n+            theApp.setForceCrash(withCore);\n@@ -63,3 +99,4 @@\n-            \/\/ Run 'jstack -v' command to get the pc\n-            List<String> cmds = List.of(\"jstack -v\");\n-            String output = test.run(theApp.getPid(), cmds, null, null);\n+            \/\/ Get the core file name if we are debugging a core instead of live process\n+            if (withCore) {\n+                coreFileName = CoreUtils.getCoreFileLocation(theApp.getOutput().getStdout());\n+            }\n@@ -67,3 +104,8 @@\n-            \/\/ Test the 'findpc' command passing in the pc obtained from\n-            \/\/ the 'jstack -v' command\n-            cmds = new ArrayList<String>();\n+            \/\/ Run 'jstack -v' command to get the findpc address\n+            List<String> cmds = List.of(\"jstack -v\");\n+            String output;\n+            if (withCore) {\n+                output = test.runOnCore(coreFileName, cmds, null, null);\n+            } else {\n+                output = test.run(theApp.getPid(), cmds, null, null);\n+            }\n@@ -71,1 +113,3 @@\n-            String cmdStr = null;\n+            \/\/ Extract pc address from the following line:\n+            \/\/   - LingeredAppWithTrivialMain.main(java.lang.String[]) @bci=1, line=33, pc=0x00007ff18ff519f0, ...\n+            String pcAddress = null;\n@@ -76,4 +120,3 @@\n-                    String[] address = token.split(\"=\");\n-                    \/\/ address[1] represents the address of the Method\n-                    cmdStr = \"findpc \" + address[1].replace(\",\",\"\");\n-                    cmds.add(cmdStr);\n+                    String[] addresses = token.split(\"=\");\n+                    \/\/ addresses[1] represents the address of the Method\n+                    pcAddress = addresses[1].replace(\",\",\"\");\n@@ -83,0 +126,3 @@\n+            if (pcAddress == null) {\n+                throw new RuntimeException(\"Cannot find LingeredAppWithTrivialMain.main pc in output\");\n+            }\n@@ -84,0 +130,4 @@\n+            \/\/ Test the 'findpc' command passing in the pc obtained from above\n+            cmds = new ArrayList<String>();\n+            String cmdStr = \"findpc \" + pcAddress;\n+            cmds.add(cmdStr);\n@@ -96,1 +146,5 @@\n-            test.run(theApp.getPid(), cmds, expStrMap, null);\n+            if (withCore) {\n+                test.runOnCore(coreFileName, cmds, expStrMap, null);\n+            } else {\n+                test.run(theApp.getPid(), cmds, expStrMap, null);\n+            }\n@@ -102,1 +156,3 @@\n-            LingeredApp.stopApp(theApp);\n+            if (!withCore) {\n+                LingeredApp.stopApp(theApp);\n+            }\n@@ -107,0 +163,2 @@\n+        boolean withXcomp = Boolean.parseBoolean(args[0]);\n+        boolean withCore = Boolean.parseBoolean(args[1]);\n@@ -108,2 +166,1 @@\n-        testFindPC(true);\n-        testFindPC(false);\n+        testFindPC(withXcomp, withCore);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":75,"deletions":18,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -45,2 +46,0 @@\n-    static final String pidSeparator = \":KILLED_PID\";\n-\n@@ -53,2 +52,0 @@\n-            \/\/ If 1 argument is set prints pid so main process could find corefile\n-            System.out.println(ProcessHandle.current().pid() + pidSeparator);\n@@ -75,13 +72,0 @@\n-    \/\/ Test tries to run java with ulimit unlimited if it is possible\n-    static boolean useDefaultUlimit() {\n-        if (Platform.isWindows()) {\n-            return true;\n-        }\n-        try {\n-            OutputAnalyzer output = ProcessTools.executeProcess(\"sh\", \"-c\", \"ulimit -c unlimited && ulimit -c\");\n-            return !(output.getExitValue() == 0 && output.getStdout().contains(\"unlimited\"));\n-        } catch (Throwable t) {\n-            return true;\n-        }\n-    }\n-\n@@ -96,23 +80,6 @@\n-        boolean useDefaultUlimit = useDefaultUlimit();\n-        System.out.println(\"Run test with ulimit: \" + (useDefaultUlimit ? \"default\" : \"unlimited\"));\n-        OutputAnalyzer output = useDefaultUlimit\n-            ? ProcessTools.executeProcess(pb)\n-            : ProcessTools.executeProcess(\"sh\", \"-c\", \"ulimit -c unlimited && \"\n-                    + ProcessTools.getCommandLine(pb));\n-        File core;\n-        String pattern = Platform.isWindows() ? \".*\\\\.mdmp\" : \"core(\\\\.\\\\d+)?\";\n-        File[] cores = new File(\".\").listFiles((dir, name) -> name.matches(pattern));\n-        if (cores.length == 0) {\n-            \/\/ \/cores\/core.$pid might be generated on macosx by default\n-            String pid = output.firstMatch(\"^(\\\\d+)\" + pidSeparator, 1);\n-            core = new File(\"cores\/core.\" + pid);\n-            if (!core.exists()) {\n-                throw new SkippedException(\"Has not been able to find coredump\");\n-            }\n-        } else {\n-            Asserts.assertTrue(cores.length == 1,\n-                    \"There are unexpected files containing core \"\n-                    + \": \" + String.join(\",\", new File(\".\").list()) + \".\");\n-            core = cores[0];\n-        }\n-        System.out.println(\"Found corefile: \" + core.getAbsolutePath());\n+        \/\/ If we are going to force a core dump, apply \"ulimit -c unlimited\" if we can.\n+        pb = CoreUtils.addCoreUlimitCommand(pb);\n+        OutputAnalyzer output =  ProcessTools.executeProcess(pb);\n+\n+        String coreFileName = CoreUtils.getCoreFileLocation(output.getStdout());\n+        File core = new File(coreFileName);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJmapCore.java","additions":7,"deletions":40,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Test verifies that jhsdb jmap could generate heap dump from core when metspace is full\n+ * @summary Test verifies that jhsdb jmap could generate heap dump from core when metaspace is full\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJmapCoreMetaspace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-                \"isSignedOSX\");\n+                \"isHardenedOSX\", \"hasOSXPlistEntries\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/TestMutuallyExclusivePlatformPredicates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- *     private static List<Window> createTestUI() {\n+ *     private static Window createTestUI() {\n@@ -99,1 +99,1 @@\n- *         return List.of(testUI);\n+ *         return testUI;\n@@ -111,0 +111,4 @@\n+ * The {@code Builder.testUI} methods accept interfaces which create one window\n+ * or a list of windows if the test needs multiple windows,\n+ * or directly a single window, an array of windows or a list of windows.\n+ * <p>\n@@ -147,1 +151,1 @@\n-public class PassFailJFrame {\n+public final class PassFailJFrame {\n@@ -266,1 +270,1 @@\n-        if (builder.windowCreator != null) {\n+        if (builder.windowListCreator != null) {\n@@ -268,1 +272,4 @@\n-                    builder.testWindows = builder.windowCreator.createTestUI());\n+                    builder.testWindows = builder.windowListCreator.createTestUI());\n+            if (builder.testWindows == null) {\n+                throw new IllegalStateException(\"Window list creator returned null list\");\n+            }\n@@ -272,0 +279,3 @@\n+            if (builder.testWindows.isEmpty()) {\n+                throw new IllegalStateException(\"Window list is empty\");\n+            }\n@@ -282,2 +292,0 @@\n-\n-                    windowList.forEach(w -> w.setVisible(true));\n@@ -288,1 +296,0 @@\n-                window.setVisible(true);\n@@ -293,0 +300,1 @@\n+        showAllWindows();\n@@ -373,1 +381,1 @@\n-        windowList.add(frame);\n+        addTestWindow(frame);\n@@ -404,1 +412,1 @@\n-     * Creates one or more windows for test UI.\n+     * Creates a test UI window.\n@@ -408,0 +416,13 @@\n+        \/**\n+         * Creates a window for test UI.\n+         * This method is called by the framework on the EDT.\n+         * @return a test UI window\n+         *\/\n+        Window createTestUI();\n+    }\n+\n+    \/**\n+     * Creates a list of test UI windows.\n+     *\/\n+    @FunctionalInterface\n+    public interface WindowListCreator {\n@@ -411,1 +432,1 @@\n-         * @return a list of windows.\n+         * @return a list of test UI windows\n@@ -427,2 +448,7 @@\n-         * that were passed to the framework via\n-         * {@link Builder#testUI(WindowCreator) testUI} method.\n+         * that were passed to the framework via the\n+         * {@link Builder#testUI(Window...) testUI(Window...)} method or\n+         * that were created with {@code WindowCreator}\n+         * or {@code WindowListCreator} which were passed via\n+         * {@link Builder#testUI(WindowCreator) testUI(WindowCreator)} or\n+         * {@link Builder#testUI(WindowListCreator) testUI(WindowListCreator)}\n+         * correspondingly.\n@@ -802,0 +828,23 @@\n+    \/**\n+     * Displays all the windows in {@code windowList}.\n+     *\n+     * @throws InterruptedException if the thread is interrupted while\n+     *              waiting for the event dispatch thread to finish running\n+     *              the {@link #showUI() showUI}\n+     * @throws InvocationTargetException if an exception is thrown while\n+     *              the event dispatch thread executes {@code showUI}\n+     *\/\n+    private static void showAllWindows()\n+            throws InterruptedException, InvocationTargetException {\n+        invokeOnEDT(PassFailJFrame::showUI);\n+    }\n+\n+    \/**\n+     * Displays all the windows in {@code windowList}; it has to be called on\n+     * the EDT &mdash; use {@link #showAllWindows() showAllWindows} to ensure it.\n+     *\/\n+    private static synchronized void showUI() {\n+        windowList.forEach(w -> w.setVisible(true));\n+    }\n+\n+\n@@ -844,1 +893,1 @@\n-        private WindowCreator windowCreator;\n+        private WindowListCreator windowListCreator;\n@@ -880,0 +929,51 @@\n+        \/**\n+         * Adds a {@code WindowCreator} which the framework will use\n+         * to create the test UI window.\n+         *\n+         * @param windowCreator a {@code WindowCreator}\n+         *              to create the test UI window\n+         * @return this builder\n+         * @throws IllegalArgumentException if {@code windowCreator} is {@code null}\n+         * @throws IllegalStateException if a window creator\n+         *              or a list of test windows is already set\n+         *\/\n+        public Builder testUI(WindowCreator windowCreator) {\n+            if (windowCreator == null) {\n+                throw new IllegalArgumentException(\"The window creator can't be null\");\n+            }\n+\n+            checkWindowsLists();\n+\n+            this.windowListCreator = () -> List.of(windowCreator.createTestUI());\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a {@code WindowListCreator} which the framework will use\n+         * to create a list of test UI windows.\n+         *\n+         * @param windowListCreator a {@code WindowListCreator}\n+         *              to create test UI windows\n+         * @return this builder\n+         * @throws IllegalArgumentException if {@code windowListCreator} is {@code null}\n+         * @throws IllegalStateException if a window creator\n+         *              or a list of test windows is already set\n+         *\/\n+        public Builder testUI(WindowListCreator windowListCreator) {\n+            if (windowListCreator == null) {\n+                throw new IllegalArgumentException(\"The window list creator can't be null\");\n+            }\n+\n+            checkWindowsLists();\n+\n+            this.windowListCreator = windowListCreator;\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds an already created test UI window.\n+         * The window is positioned and shown automatically.\n+         *\n+         * @param window a test UI window\n+         * @return this builder\n+         *\/\n@@ -884,0 +984,6 @@\n+        \/**\n+         * Adds an array of already created test UI windows.\n+         *\n+         * @param windows an array of test UI windows\n+         * @return this builder\n+         *\/\n@@ -888,1 +994,11 @@\n-        public Builder testUI(List<Window> windows) {\n+        \/**\n+         * Adds a list of already created test UI windows.\n+         *\n+         * @param windows a list of test UI windows\n+         * @return this builder\n+         * @throws IllegalArgumentException if {@code windows} is {@code null}\n+         *              or the list contains {@code null}\n+         * @throws IllegalStateException if a window creator\n+         *              or a list of test windows is already set\n+         *\/\n+        public Builder testUI(List<? extends Window> windows) {\n@@ -894,1 +1010,1 @@\n-                throw new IllegalArgumentException(\"The windows list can't contain null\");\n+                throw new IllegalArgumentException(\"The list of windows can't contain null\");\n@@ -897,3 +1013,2 @@\n-            if (windowCreator != null) {\n-                throw new IllegalStateException(\"windowCreator is already set\");\n-            }\n+            checkWindowsLists();\n+\n@@ -904,3 +1019,9 @@\n-        public Builder testUI(WindowCreator windowCreator) {\n-            if (windowCreator == null) {\n-                throw new IllegalArgumentException(\"The window creator can't be null\");\n+        \/**\n+         * Verifies the state of window list and window creator.\n+         *\n+         * @throws IllegalStateException if a windows list creator\n+         *              or a list of test windows is already set\n+         *\/\n+        private void checkWindowsLists() {\n+            if (windowListCreator != null) {\n+                throw new IllegalStateException(\"Window list creator is already set\");\n@@ -909,1 +1030,1 @@\n-                throw new IllegalStateException(\"testWindows are already set\");\n+                throw new IllegalStateException(\"The list of test windows is already set\");\n@@ -911,2 +1032,0 @@\n-            this.windowCreator = windowCreator;\n-            return this;\n@@ -954,1 +1073,1 @@\n-                && (testWindows != null || windowCreator != null)) {\n+                && (testWindows != null || windowListCreator != null)) {\n@@ -960,1 +1079,1 @@\n-                if (testWindows == null && windowCreator == null) {\n+                if (testWindows == null && windowListCreator == null) {\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":146,"deletions":27,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.io.BufferedReader;\n@@ -28,0 +29,1 @@\n+import java.io.InputStreamReader;\n@@ -256,0 +258,30 @@\n+    private static Process launchCodesignOnJavaBinary() throws IOException {\n+        String jdkPath = System.getProperty(\"java.home\");\n+        Path javaPath = Paths.get(jdkPath + \"\/bin\/java\");\n+        String javaFileName = javaPath.toAbsolutePath().toString();\n+        if (Files.notExists(javaPath)) {\n+            throw new FileNotFoundException(\"Could not find file \" + javaFileName);\n+        }\n+        ProcessBuilder pb = new ProcessBuilder(\"codesign\", \"--display\", \"--verbose\", javaFileName);\n+        pb.redirectErrorStream(true); \/\/ redirect stderr to stdout\n+        Process codesignProcess = pb.start();\n+        return codesignProcess;\n+    }\n+\n+    public static boolean hasOSXPlistEntries() throws IOException {\n+        Process codesignProcess = launchCodesignOnJavaBinary();\n+        BufferedReader is = new BufferedReader(new InputStreamReader(codesignProcess.getInputStream()));\n+        String line;\n+        while ((line = is.readLine()) != null) {\n+            System.out.println(\"STDOUT: \" + line);\n+            if (line.indexOf(\"Info.plist=not bound\") != -1) {\n+                return false;\n+            }\n+            if (line.indexOf(\"Info.plist entries=\") != -1) {\n+                return true;\n+            }\n+        }\n+        System.out.println(\"No matching Info.plist entry was found\");\n+        return false;\n+    }\n+\n@@ -257,1 +289,1 @@\n-     * Return true if the test JDK is signed, otherwise false. Only valid on OSX.\n+     * Return true if the test JDK is hardened, otherwise false. Only valid on OSX.\n@@ -259,2 +291,2 @@\n-    public static boolean isSignedOSX() throws IOException {\n-        \/\/ We only care about signed binaries for 10.14 and later (actually 10.14.5, but\n+    public static boolean isHardenedOSX() throws IOException {\n+        \/\/ We only care about hardened binaries for 10.14 and later (actually 10.14.5, but\n@@ -263,1 +295,1 @@\n-            return false; \/\/ assume not signed\n+            return false; \/\/ assume not hardened\n@@ -265,7 +297,24 @@\n-\n-        \/\/ Find the path to the java binary.\n-        String jdkPath = System.getProperty(\"java.home\");\n-        Path javaPath = Paths.get(jdkPath + \"\/bin\/java\");\n-        String javaFileName = javaPath.toAbsolutePath().toString();\n-        if (!javaPath.toFile().exists()) {\n-            throw new FileNotFoundException(\"Could not find file \" + javaFileName);\n+        Process codesignProcess = launchCodesignOnJavaBinary();\n+        BufferedReader is = new BufferedReader(new InputStreamReader(codesignProcess.getInputStream()));\n+        String line;\n+        boolean isHardened = false;\n+        boolean hardenedStatusConfirmed = false; \/\/ set true when we confirm whether or not hardened\n+        while ((line = is.readLine()) != null) {\n+            System.out.println(\"STDOUT: \" + line);\n+            if (line.indexOf(\"flags=0x10000(runtime)\") != -1 ) {\n+                hardenedStatusConfirmed = true;\n+                isHardened = true;\n+                System.out.println(\"Target JDK is hardened. Some tests may be skipped.\");\n+            } else if (line.indexOf(\"flags=0x20002(adhoc,linker-signed)\") != -1 ) {\n+                hardenedStatusConfirmed = true;\n+                isHardened = false;\n+                System.out.println(\"Target JDK is adhoc signed, but not hardened.\");\n+            } else if (line.indexOf(\"code object is not signed at all\") != -1) {\n+                hardenedStatusConfirmed = true;\n+                isHardened = false;\n+                System.out.println(\"Target JDK is not signed, therefore not hardened.\");\n+            }\n+        }\n+        if (!hardenedStatusConfirmed) {\n+            System.out.println(\"Could not confirm if TargetJDK is hardened. Assuming not hardened.\");\n+            isHardened = false;\n@@ -274,5 +323,0 @@\n-        \/\/ Run codesign on the java binary.\n-        ProcessBuilder pb = new ProcessBuilder(\"codesign\", \"-d\", \"-v\", javaFileName);\n-        pb.redirectError(ProcessBuilder.Redirect.DISCARD);\n-        pb.redirectOutput(ProcessBuilder.Redirect.DISCARD);\n-        Process codesignProcess = pb.start();\n@@ -281,1 +325,1 @@\n-                System.err.println(\"Timed out waiting for the codesign process to complete. Assuming not signed.\");\n+                System.err.println(\"Timed out waiting for the codesign process to complete. Assuming not hardened.\");\n@@ -283,1 +327,1 @@\n-                return false; \/\/ assume not signed\n+                return false; \/\/ assume not hardened\n@@ -289,18 +333,1 @@\n-        \/\/ Check codesign result to see if java binary is signed. Here are the\n-        \/\/ exit code meanings:\n-        \/\/    0: signed\n-        \/\/    1: not signed\n-        \/\/    2: invalid arguments\n-        \/\/    3: only has meaning with the -R argument.\n-        \/\/ So we should always get 0 or 1 as an exit value.\n-        if (codesignProcess.exitValue() == 0) {\n-            System.out.println(\"Target JDK is signed. Some tests may be skipped.\");\n-            return true; \/\/ signed\n-        } else if (codesignProcess.exitValue() == 1) {\n-            System.out.println(\"Target JDK is not signed.\");\n-            return false; \/\/ not signed\n-        } else {\n-            System.err.println(\"Executing codesign failed. Assuming unsigned: \" +\n-                               codesignProcess.exitValue());\n-            return false; \/\/ not signed\n-        }\n+        return isHardened;\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":64,"deletions":37,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.List;\n@@ -39,0 +38,1 @@\n+import java.util.List;\n@@ -66,2 +66,2 @@\n-                if (Platform.isSignedOSX()) {\n-                    throw new SkippedException(\"SA Attach not expected to work. JDK is signed.\");\n+                if (Platform.isHardenedOSX()) {\n+                    throw new SkippedException(\"SA Attach not expected to work. JDK is hardened.\");\n","filename":"test\/lib\/jdk\/test\/lib\/SA\/SATestUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -88,0 +89,2 @@\n+    protected boolean forceCrash = false; \/\/ set true to force a crash and core file\n+\n@@ -103,0 +106,6 @@\n+    public void setForceCrash(boolean forceCrash) {\n+        this.forceCrash = forceCrash;\n+    }\n+\n+    native private static int crash();\n+\n@@ -276,1 +285,5 @@\n-                throw new IOException(\"App exited unexpectedly with \" + appProcess.exitValue());\n+                if (forceCrash) {\n+                    return; \/\/ This is expected. Just return.\n+                } else {\n+                    throw new IOException(\"App exited unexpectedly with \" + appProcess.exitValue());\n+                }\n@@ -324,0 +337,5 @@\n+        if (forceCrash) {\n+            cmd.add(\"-XX:+CreateCoredumpOnCrash\");\n+            \/\/ We need to find libLingeredApp.so for the crash() native method\n+            cmd.add(\"-Djava.library.path=\" + System.getProperty(\"java.library.path\"));\n+        }\n@@ -359,0 +377,3 @@\n+        if (forceCrash) {\n+            cmd.add(\"forceCrash\"); \/\/ Let the subprocess know to force a crash\n+        }\n@@ -363,0 +384,4 @@\n+        if (forceCrash) {\n+            \/\/ If we are going to force a core dump, apply \"ulimit -c unlimited\" if we can.\n+            pb = CoreUtils.addCoreUlimitCommand(pb);\n+        }\n@@ -496,1 +521,2 @@\n-     * This part is the application it self\n+     * This part is the application itself. First arg is optional \"forceCrash\".\n+     * Following arg is the lock file name.\n@@ -499,0 +525,1 @@\n+        boolean forceCrash = false;\n@@ -500,1 +527,1 @@\n-        if (args.length != 1) {\n+        if (args.length == 0) {\n@@ -503,0 +530,12 @@\n+        } else if (args.length > 2) {\n+            System.err.println(\"Too many arguments specified: \"  + args.length);\n+            System.exit(7);\n+        }\n+\n+        if (args.length == 2) {\n+            if (args[1].equals(\"forceCrash\")) {\n+                forceCrash = true;\n+            } else {\n+                System.err.println(\"Invalid 1st argment: \" + args[1]);\n+                System.exit(7);\n+            }\n@@ -509,0 +548,4 @@\n+            if (forceCrash) {\n+                System.loadLibrary(\"LingeredApp\"); \/\/ location of native crash() method\n+                crash();\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+\/\/ Borrowed from hotspot vmError.cpp.\n+\/\/ Returns an address which is guaranteed to generate a SIGSEGV on read,\n+\/\/ which is not NULL and contains bits in every word\n+void* get_segfault_address() {\n+  return (void*)\n+#ifdef _LP64\n+    0xABC0000000000ABCULL;\n+#else\n+    0x00000ABC;\n+#endif\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_test_lib_apps_LingeredApp_crash(JNIEnv *env, jclass clss)\n+{\n+    return *(jint *)get_segfault_address();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/libLingeredApp.c","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.util;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+import java.util.zip.GZIPInputStream;\n+\n+public class CoreUtils {\n+\n+    private static final String RUN_SHELL_NO_LIMIT = \"ulimit -c unlimited && \";\n+\n+    \/**\n+     * Returns a {@code ulimit} command that will allow for an unlimited core file size\n+     * if the platform supports it.\n+     *\n+     * @return {@code String} for the ulimit command if supported by the platform,\n+     * otherwise {@code null}.\n+     *\/\n+    private static String getCoreUlimitCommand() {\n+        String result = null;\n+        try {\n+            OutputAnalyzer output = ProcessTools.executeProcess(\"sh\", \"-c\", RUN_SHELL_NO_LIMIT + \"ulimit -c\");\n+            if (output.getExitValue() != 0) {\n+                result = null;\n+            } else if (!output.getStdout().contains(\"unlimited\")) {\n+                result = null;\n+            } else {\n+                result = RUN_SHELL_NO_LIMIT; \/\/ success\n+            }\n+        } catch (Throwable t) {\n+            System.out.println(\"Exception in getCoreUlimitCommand(): \" + t.toString());\n+            result = null;\n+        }\n+        System.out.println(\"Run test with ulimit -c: \" +\n+                           (result == null ? \"default\" : \"unlimited\"));\n+        return result;\n+    }\n+\n+    \/**\n+     * Return a {@code ProcessBuilder} that has been prefixed with\n+     * a {@code ulimit} command to allow for an unlimited core file size.\n+     *\n+     * @param pb {@code ProcessBuilder} to prefix with the ulimit command\n+     * @return New {@code ProcessBuilder} with prefixed {@code ulimit} command if\n+     * supported. Otherwise the passed in {@code ProcessBuilder} is returned.\n+     *\/\n+    public static ProcessBuilder addCoreUlimitCommand(ProcessBuilder pb) {\n+        String cmd = ProcessTools.getCommandLine(pb);\n+        String ulimitCmd = getCoreUlimitCommand();\n+        if (ulimitCmd == null) {\n+            return pb;\n+        } else {\n+            if (Platform.isWindows()) {\n+                \/\/ In order to launch on Windows using \"sh -c\", we need to first\n+                \/\/ convert the path to use forward slashes and do some extra quoting.\n+                cmd = cmd.replace('\\\\', '\/').replace(\";\", \"\\\\;\").replace(\"|\", \"\\\\|\");\n+            }\n+            return new ProcessBuilder(\"sh\", \"-c\", ulimitCmd + cmd);\n+        }\n+    }\n+\n+    \/**\n+     * Find the path to the core file mentioned in the output and return its path.\n+     *\n+     * @param crashOutputString {@code String} to search in for the core file path\n+     * @return Location of core file if found in the output, otherwise {@code null}.\n+     *\/\n+    public static String getCoreFileLocation(String crashOutputString) throws IOException {\n+        unzipCores(new File(\".\"));\n+\n+        \/\/ Find the core file\n+        String coreFileLocation = parseCoreFileLocationFromOutput(crashOutputString);\n+        if (coreFileLocation != null) {\n+            Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n+            System.out.println(\"Found core file: \" + coreFileLocation);\n+            return coreFileLocation; \/\/ success!\n+        }else {\n+            System.out.println(\"Core file not found. Trying to find a reason why...\");\n+        }\n+\n+        \/\/ See if we can figure out the likely reason the core file was not found.\n+        \/\/ Throw SkippedException if appropriate.\n+        if (Platform.isOSX()) {\n+            File coresDir = new File(\"\/cores\");\n+            if (!coresDir.isDirectory()) {\n+                throw new RuntimeException(coresDir + \" is not a directory\");\n+            }\n+            \/\/ The \/cores directory is usually not writable on macOS 10.15\n+            if (!coresDir.canWrite()) {\n+                throw new SkippedException(\"Directory \\\"\" + coresDir + \"\\\" is not writable\");\n+            }\n+            if (Platform.isHardenedOSX()) {\n+                if (Platform.getOsVersionMajor() > 10 ||\n+                        (Platform.getOsVersionMajor() == 10 && Platform.getOsVersionMinor() >= 15))\n+                {\n+                    \/\/ We can't generate cores files with hardened binaries on OSX 10.15 and later.\n+                    throw new SkippedException(\"Cannot produce core file with hardened binary on OSX 10.15 and later\");\n+                }\n+            } else {\n+                \/\/ codesign has to add entitlements using the plist. If this is not present we might not generate a core file.\n+                if (!Platform.hasOSXPlistEntries()) {\n+                    throw new SkippedException(\"Cannot produce core file with binary having no plist entitlement entries\");\n+                }\n+            }\n+        } else if (Platform.isLinux()) {\n+            \/\/ Check if a crash report tool is installed.\n+            File corePatternFile = new File(CORE_PATTERN_FILE_NAME);\n+            try (Scanner scanner = new Scanner(corePatternFile)) {\n+                while (scanner.hasNextLine()) {\n+                    String line = scanner.nextLine();\n+                    line = line.trim();\n+                    System.out.println(line);\n+                    if (line.startsWith(\"|\")) {\n+                        System.out.println(\n+                            \"\\nThis system uses a crash report tool ($cat \/proc\/sys\/kernel\/core_pattern).\\n\" +\n+                            \"Core files might not be generated. Please reset \/proc\/sys\/kernel\/core_pattern\\n\" +\n+                            \"to enable core generation. Skipping this test.\");\n+                        throw new SkippedException(\"This system uses a crash report tool\");\n+                    }\n+                }\n+            }\n+        }\n+        throw new RuntimeException(\"Couldn't find core file location in: '\" + crashOutputString + \"'\");\n+    }\n+\n+    private static final String CORE_PATTERN_FILE_NAME = \"\/proc\/sys\/kernel\/core_pattern\";\n+    private static final String LOCATION_STRING = \"location: \";\n+\n+    private static String parseCoreFileLocationFromOutput(String crashOutputString) {\n+        System.out.println(\"crashOutputString = [\" + crashOutputString + \"]\");\n+\n+        \/\/ Find the line of output that contains LOCATION_STRING\n+        Asserts.assertTrue(crashOutputString.contains(LOCATION_STRING),\n+            \"Output doesn't contain the location of core file.\");\n+        String stringWithLocation = Arrays.stream(crashOutputString.split(\"\\\\r?\\\\n\"))\n+            .filter(str -> str.contains(LOCATION_STRING))\n+            .findFirst()\n+            .get();\n+        stringWithLocation = stringWithLocation.substring(stringWithLocation\n+            .indexOf(LOCATION_STRING) + LOCATION_STRING.length());\n+        System.out.println(\"getCoreFileLocation found stringWithLocation = \" + stringWithLocation);\n+\n+        \/\/ Find the core file name in the output.\n+        String coreWithPid;\n+        if (stringWithLocation.contains(\"or \") && !Platform.isWindows()) {\n+            Matcher m = Pattern.compile(\"or.* ([^ ]+[^\\\\)])\\\\)?\").matcher(stringWithLocation);\n+            if (!m.find()) {\n+                throw new RuntimeException(\"Couldn't find path to core inside location string\");\n+            }\n+            coreWithPid = m.group(1);\n+        } else {\n+            coreWithPid = stringWithLocation.trim();\n+        }\n+        if (new File(coreWithPid).exists()) {\n+            return coreWithPid;\n+        }\n+\n+        \/\/ Look for file named \"core\" in the cwd.\n+        String justCore = Paths.get(\"core\").toString();\n+        if (new File(justCore).exists()) {\n+            return justCore;\n+        }\n+\n+        \/\/ Look for the core file name found in the output, but do so in the cwd.\n+        Path coreWithPidPath = Paths.get(coreWithPid);\n+        String justFile = coreWithPidPath.getFileName().toString();\n+        if (new File(justFile).exists()) {\n+            return justFile;\n+        }\n+\n+        \/\/ Look for file named \"core\" in the path to the core file found in the output.\n+        Path parent = coreWithPidPath.getParent();\n+        if (parent != null) {\n+            String coreWithoutPid = parent.resolve(\"core\").toString();\n+            if (new File(coreWithoutPid).exists()) {\n+                return coreWithoutPid;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void unzipCores(File dir) {\n+        File[] gzCores = dir.listFiles((directory, name) -> name.matches(\"core(\\\\.\\\\d+)?\\\\.gz\"));\n+        for (File gzCore : gzCores) {\n+            String coreFileName = gzCore.getName().replace(\".gz\", \"\");\n+            System.out.println(\"Unzipping core into \" + coreFileName);\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(gzCore.toPath()))) {\n+                Files.copy(gzis, Paths.get(coreFileName));\n+            } catch (IOException e) {\n+                throw new SkippedException(\"Not able to unzip file: \" + gzCore.getAbsolutePath(), e);\n+            }\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/jdk\/test\/lib\/util\/CoreUtils.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}