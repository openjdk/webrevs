{"files":[{"patch":"@@ -130,1 +130,1 @@\n-        if (FileUtils.areAllMountPointsAccessible()) {\n+        if (FileUtils.areMountPointsAccessibleAndUnique()) {\n","filename":"test\/jdk\/java\/nio\/file\/FileStore\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.Set;\n@@ -246,5 +247,5 @@\n-     * Checks whether all file systems are accessible. This is performed\n-     * by checking free disk space on all mounted file systems via a\n-     * separate, spawned process. File systems are considered to be\n-     * accessible if this process completes successfully before a given\n-     * fixed duration has elapsed.\n+     * Checks whether all file systems are accessible and there are no\n+     * duplicate mount points. This is performed by checking free disk\n+     * space on all mounted file systems via a separate, spawned process.\n+     * File systems are considered to be accessible if this process completes\n+     * successfully before a given fixed duration has elapsed.\n@@ -255,4 +256,1 @@\n-     * @return whether file systems appear to be accessible\n-     *\n-     * @throws RuntimeException if there are duplicate mount points or some\n-     * other execution problem occurs\n+     * @return whether file systems appear to be accessible and duplicate-free\n@@ -260,1 +258,3 @@\n-    public static boolean areAllMountPointsAccessible() {\n+    public static boolean areMountPointsAccessibleAndUnique() {\n+        if (IS_WINDOWS) return true;\n+\n@@ -262,18 +262,16 @@\n-        if (!IS_WINDOWS) {\n-            Thread thr = new Thread(() -> {\n-                try {\n-                    Process proc = new ProcessBuilder(\"df\").start();\n-                    BufferedReader reader = new BufferedReader\n-                        (new InputStreamReader(proc.getInputStream()));\n-                    \/\/ Skip the first line as it is the \"df\" output header.\n-                    if (reader.readLine() != null ) {\n-                        String prevMountPoint = null, mountPoint = null;\n-                        while ((mountPoint = reader.readLine()) != null) {\n-                            if (prevMountPoint != null &&\n-                                mountPoint.equals(prevMountPoint)) {\n-                                throw new RuntimeException\n-                                    (\"System configuration error: \" +\n-                                    \"duplicate mount point \" + mountPoint +\n-                                    \" detected\");\n-                            }\n-                            prevMountPoint = mountPoint;\n+        Thread thr = new Thread(() -> {\n+            try {\n+                Process proc = new ProcessBuilder(\"df\").start();\n+                BufferedReader reader = new BufferedReader\n+                    (new InputStreamReader(proc.getInputStream()));\n+                \/\/ Skip the first line as it is the \"df\" output header.\n+                if (reader.readLine() != null ) {\n+                    Set mountPoints = new HashSet();\n+                    String mountPoint = null;\n+                    while ((mountPoint = reader.readLine()) != null) {\n+                        if (!mountPoints.add(mountPoint)) {\n+                            System.err.printf\n+                                (\"Config error: duplicate mount point %s%n\",\n+                                mountPoint);\n+                            areMountPointsOK.set(false);\n+                            break;\n@@ -282,0 +280,1 @@\n+                }\n@@ -283,13 +282,9 @@\n-                    try {\n-                        proc.waitFor(90, TimeUnit.SECONDS);\n-                    } catch (InterruptedException ignored) {\n-                    }\n-                    try {\n-                        int exitValue = proc.exitValue();\n-                        if (exitValue != 0) {\n-                            System.err.printf(\"df process exited with %d != 0%n\",\n-                                exitValue);\n-                            areMountPointsOK.set(false);\n-                        }\n-                    } catch (IllegalThreadStateException ignored) {\n-                        System.err.println(\"df command apparently hung\");\n+                try {\n+                    proc.waitFor(90, TimeUnit.SECONDS);\n+                } catch (InterruptedException ignored) {\n+                }\n+                try {\n+                    int exitValue = proc.exitValue();\n+                    if (exitValue != 0) {\n+                        System.err.printf(\"df process exited with %d != 0%n\",\n+                            exitValue);\n@@ -298,4 +293,8 @@\n-                } catch (IOException ioe) {\n-                    throw new RuntimeException(ioe);\n-                };\n-            });\n+                } catch (IllegalThreadStateException ignored) {\n+                    System.err.println(\"df command apparently hung\");\n+                    areMountPointsOK.set(false);\n+                }\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe);\n+            };\n+        });\n@@ -303,8 +302,8 @@\n-            final AtomicReference throwableReference =\n-                new AtomicReference<Throwable>();\n-            thr.setUncaughtExceptionHandler(\n-                new Thread.UncaughtExceptionHandler() {\n-                    public void uncaughtException(Thread t, Throwable e) {\n-                        throwableReference.set(e);\n-                    }\n-                });\n+        final AtomicReference throwableReference =\n+            new AtomicReference<Throwable>();\n+        thr.setUncaughtExceptionHandler(\n+            new Thread.UncaughtExceptionHandler() {\n+                public void uncaughtException(Thread t, Throwable e) {\n+                    throwableReference.set(e);\n+                }\n+            });\n@@ -312,6 +311,6 @@\n-            thr.start();\n-            try {\n-                thr.join(120*1000L);\n-            } catch (InterruptedException ie) {\n-                throw new RuntimeException(ie);\n-            }\n+        thr.start();\n+        try {\n+            thr.join(120*1000L);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        }\n@@ -319,4 +318,4 @@\n-            Throwable uncaughtException = (Throwable)throwableReference.get();\n-            if (uncaughtException != null) {\n-                throw new RuntimeException(uncaughtException);\n-            }\n+        Throwable uncaughtException = (Throwable)throwableReference.get();\n+        if (uncaughtException != null) {\n+            throw new RuntimeException(uncaughtException);\n+        }\n@@ -324,3 +323,2 @@\n-            if (thr.isAlive()) {\n-                throw new RuntimeException(\"df thread did not join in time\");\n-            }\n+        if (thr.isAlive()) {\n+            throw new RuntimeException(\"df thread did not join in time\");\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":65,"deletions":67,"binary":false,"changes":132,"status":"modified"}]}