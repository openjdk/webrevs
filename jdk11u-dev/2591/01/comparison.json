{"files":[{"patch":"@@ -30,1 +30,0 @@\n- * @requires os.family != \"windows\"\n@@ -50,1 +49,0 @@\n-import java.nio.file.Path;\n@@ -53,2 +51,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n@@ -56,1 +52,0 @@\n-import java.util.Scanner;\n@@ -59,0 +54,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -67,4 +63,0 @@\n-\n-    private static final String TEST_CDS_CORE_FILE_NAME = \"cds_core_file\";\n-    private static final String LOCATIONS_STRING = \"location: \";\n-    private static final String RUN_SHELL_NO_LIMIT = \"ulimit -c unlimited && \";\n@@ -72,1 +64,1 @@\n-    private static final String CORE_PATTERN_FILE_NAME = \"\/proc\/sys\/kernel\/core_pattern\";\n+    private static String coreFileName;\n@@ -93,1 +85,1 @@\n-            OutputAnalyzer crashOut;\n+            OutputAnalyzer crashOutput;\n@@ -97,3 +89,4 @@\n-               crashOut =\n-                   ProcessTools.executeProcess(getTestJvmCommandlineWithPrefix(\n-                   RUN_SHELL_NO_LIMIT, options.toArray(new String[0])));\n+               ProcessBuilder pb = ProcessTools.createTestJvm(options);\n+               \/\/ Add \"ulimit -c unlimited\" if we can since we are generating a core file.\n+               pb = CoreUtils.addCoreUlimitCommand(pb);\n+               crashOutput = ProcessTools.executeProcess(pb);\n@@ -104,37 +97,0 @@\n-            System.out.println(crashOut.getOutput());\n-            String crashOutputString = crashOut.getOutput();\n-            String coreFileLocation = getCoreFileLocation(crashOutputString);\n-            if (coreFileLocation == null) {\n-                if (Platform.isOSX()) {\n-                    File coresDir = new File(\"\/cores\");\n-                    if (!coresDir.isDirectory()) {\n-                        cleanup();\n-                        throw new Error(coresDir + \" is not a directory\");\n-                    }\n-                    \/\/ the \/cores directory is usually not writable on macOS 10.15\n-                    if (!coresDir.canWrite()) {\n-                        cleanup();\n-                        throw new SkippedException(\"Directory \\\"\" + coresDir +\n-                            \"\\\" is not writable\");\n-                    }\n-                } else if (Platform.isLinux()) {\n-                    \/\/ Check if a crash report tool is installed.\n-                    File corePatternFile = new File(CORE_PATTERN_FILE_NAME);\n-                    try (Scanner scanner = new Scanner(corePatternFile)) {\n-                        while (scanner.hasNextLine()) {\n-                            String line = scanner.nextLine();\n-                            line = line.trim();\n-                            System.out.println(line);\n-                            if (line.startsWith(\"|\")) {\n-                                System.out.println(\n-                                    \"\\nThis system uses a crash report tool ($cat \/proc\/sys\/kernel\/core_pattern).\\n\" +\n-                                    \"Core files might not be generated. Please reset \/proc\/sys\/kernel\/core_pattern\\n\" +\n-                                    \"to enable core generation. Skipping this test.\");\n-                                cleanup();\n-                                throw new SkippedException(\"This system uses a crash report tool\");\n-                            }\n-                        }\n-                    }\n-                }\n-                throw new Error(\"Couldn't find core file location in: '\" + crashOutputString + \"'\");\n-            }\n@@ -142,4 +98,4 @@\n-                Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n-                Files.move(Paths.get(coreFileLocation), Paths.get(TEST_CDS_CORE_FILE_NAME));\n-            } catch (IOException ioe) {\n-                throw new Error(\"Can't move core file: \" + ioe, ioe);\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput.getStdout());\n+            } catch (Exception e) {\n+                cleanup();\n+                throw e;\n@@ -153,2 +109,1 @@\n-            String useSharedSpacesOutput = test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds,\n-                                                          null, null);\n+            String useSharedSpacesOutput = test.runOnCore(coreFileName, cmds, null, null);\n@@ -208,1 +163,1 @@\n-            test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds, expStrMap, unExpStrMap);\n+            test.runOnCore(coreFileName, cmds, expStrMap, unExpStrMap);\n@@ -218,52 +173,0 @@\n-    \/\/ lets search for a few possible locations using process output and return existing location\n-    private static String getCoreFileLocation(String crashOutputString) {\n-        Asserts.assertTrue(crashOutputString.contains(LOCATIONS_STRING),\n-            \"Output doesn't contain the location of core file.\");\n-        String stringWithLocation = Arrays.stream(crashOutputString.split(\"\\\\r?\\\\n\"))\n-            .filter(str -> str.contains(LOCATIONS_STRING))\n-            .findFirst()\n-            .get();\n-        stringWithLocation = stringWithLocation.substring(stringWithLocation\n-            .indexOf(LOCATIONS_STRING) + LOCATIONS_STRING.length());\n-        System.out.println(\"getCoreFileLocation found stringWithLocation = \" + stringWithLocation);\n-        String coreWithPid;\n-        if (stringWithLocation.contains(\"or \")) {\n-            Matcher m = Pattern.compile(\"or.* ([^ ]+[^\\\\)])\\\\)?\").matcher(stringWithLocation);\n-            if (!m.find()) {\n-                throw new Error(\"Couldn't find path to core inside location string\");\n-            }\n-            coreWithPid = m.group(1);\n-        } else {\n-            coreWithPid = stringWithLocation.trim();\n-        }\n-        if (new File(coreWithPid).exists()) {\n-            return coreWithPid;\n-        }\n-        String justCore = Paths.get(\"core\").toString();\n-        if (new File(justCore).exists()) {\n-            return justCore;\n-        }\n-        Path coreWithPidPath = Paths.get(coreWithPid);\n-        String justFile = coreWithPidPath.getFileName().toString();\n-        if (new File(justFile).exists()) {\n-            return justFile;\n-        }\n-        Path parent = coreWithPidPath.getParent();\n-        if (parent != null) {\n-            String coreWithoutPid = parent.resolve(\"core\").toString();\n-            if (new File(coreWithoutPid).exists()) {\n-                return coreWithoutPid;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static String[] getTestJvmCommandlineWithPrefix(String prefix, String... args) {\n-        try {\n-            String cmd = ProcessTools.getCommandLine(ProcessTools.createTestJvm(args));\n-            return new String[]{\"sh\", \"-c\", prefix + cmd};\n-        } catch (Throwable t) {\n-            throw new Error(\"Can't create process builder: \" + t, t);\n-        }\n-    }\n-\n@@ -271,1 +174,1 @@\n-        remove(TEST_CDS_CORE_FILE_NAME);\n+        if (coreFileName != null) remove(coreFileName);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbCDSCore.java","additions":14,"deletions":111,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -35,1 +36,1 @@\n- * @summary Test the clhsdb 'findpc' command\n+ * @summary Test the clhsdb 'findpc' command with Xcomp on live process\n@@ -38,0 +39,1 @@\n+ * @requires vm.opt.DeoptimizeALot != true\n@@ -39,1 +41,34 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC true false\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command with Xcomp on core file\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC true true\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command w\/o Xcomp on live process\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC false false\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193124\n+ * @summary Test the clhsdb 'findpc' command w\/o Xcomp on core file\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @requires vm.hasSA\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=480 ClhsdbFindPC false true\n@@ -44,1 +79,1 @@\n-    private static void testFindPC(boolean withXcomp) throws Exception {\n+    private static void testFindPC(boolean withXcomp, boolean withCore) throws Exception {\n@@ -46,0 +81,1 @@\n+        String coreFileName = null;\n@@ -50,0 +86,1 @@\n+            theApp.setForceCrash(withCore);\n@@ -63,3 +100,4 @@\n-            \/\/ Run 'jstack -v' command to get the pc\n-            List<String> cmds = List.of(\"jstack -v\");\n-            String output = test.run(theApp.getPid(), cmds, null, null);\n+            \/\/ Get the core file name if we are debugging a core instead of live process\n+            if (withCore) {\n+                coreFileName = CoreUtils.getCoreFileLocation(theApp.getOutput().getStdout());\n+            }\n@@ -67,3 +105,8 @@\n-            \/\/ Test the 'findpc' command passing in the pc obtained from\n-            \/\/ the 'jstack -v' command\n-            cmds = new ArrayList<String>();\n+            \/\/ Run 'jstack -v' command to get the findpc address\n+            List<String> cmds = List.of(\"jstack -v\");\n+            String output;\n+            if (withCore) {\n+                output = test.runOnCore(coreFileName, cmds, null, null);\n+            } else {\n+                output = test.run(theApp.getPid(), cmds, null, null);\n+            }\n@@ -71,1 +114,3 @@\n-            String cmdStr = null;\n+            \/\/ Extract pc address from the following line:\n+            \/\/   - LingeredAppWithTrivialMain.main(java.lang.String[]) @bci=1, line=33, pc=0x00007ff18ff519f0, ...\n+            String pcAddress = null;\n@@ -76,4 +121,3 @@\n-                    String[] address = token.split(\"=\");\n-                    \/\/ address[1] represents the address of the Method\n-                    cmdStr = \"findpc \" + address[1].replace(\",\",\"\");\n-                    cmds.add(cmdStr);\n+                    String[] addresses = token.split(\"=\");\n+                    \/\/ addresses[1] represents the address of the Method\n+                    pcAddress = addresses[1].replace(\",\",\"\");\n@@ -83,0 +127,3 @@\n+            if (pcAddress == null) {\n+                throw new RuntimeException(\"Cannot find LingeredAppWithTrivialMain.main pc in output\");\n+            }\n@@ -84,0 +131,4 @@\n+            \/\/ Test the 'findpc' command passing in the pc obtained from above\n+            cmds = new ArrayList<String>();\n+            String cmdStr = \"findpc \" + pcAddress;\n+            cmds.add(cmdStr);\n@@ -96,1 +147,5 @@\n-            test.run(theApp.getPid(), cmds, expStrMap, null);\n+            if (withCore) {\n+                test.runOnCore(coreFileName, cmds, expStrMap, null);\n+            } else {\n+                test.run(theApp.getPid(), cmds, expStrMap, null);\n+            }\n@@ -102,1 +157,3 @@\n-            LingeredApp.stopApp(theApp);\n+            if (!withCore) {\n+                LingeredApp.stopApp(theApp);\n+            }\n@@ -107,0 +164,2 @@\n+        boolean withXcomp = Boolean.parseBoolean(args[0]);\n+        boolean withCore = Boolean.parseBoolean(args[1]);\n@@ -108,2 +167,1 @@\n-        testFindPC(true);\n-        testFindPC(false);\n+        testFindPC(withXcomp, withCore);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":76,"deletions":18,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -45,2 +46,0 @@\n-    static final String pidSeparator = \":KILLED_PID\";\n-\n@@ -53,2 +52,0 @@\n-            \/\/ If 1 argument is set prints pid so main process could find corefile\n-            System.out.println(ProcessHandle.current().pid() + pidSeparator);\n@@ -75,13 +72,0 @@\n-    \/\/ Test tries to run java with ulimit unlimited if it is possible\n-    static boolean useDefaultUlimit() {\n-        if (Platform.isWindows()) {\n-            return true;\n-        }\n-        try {\n-            OutputAnalyzer output = ProcessTools.executeProcess(\"sh\", \"-c\", \"ulimit -c unlimited && ulimit -c\");\n-            return !(output.getExitValue() == 0 && output.getStdout().contains(\"unlimited\"));\n-        } catch (Throwable t) {\n-            return true;\n-        }\n-    }\n-\n@@ -96,23 +80,6 @@\n-        boolean useDefaultUlimit = useDefaultUlimit();\n-        System.out.println(\"Run test with ulimit: \" + (useDefaultUlimit ? \"default\" : \"unlimited\"));\n-        OutputAnalyzer output = useDefaultUlimit\n-            ? ProcessTools.executeProcess(pb)\n-            : ProcessTools.executeProcess(\"sh\", \"-c\", \"ulimit -c unlimited && \"\n-                    + ProcessTools.getCommandLine(pb));\n-        File core;\n-        String pattern = Platform.isWindows() ? \".*\\\\.mdmp\" : \"core(\\\\.\\\\d+)?\";\n-        File[] cores = new File(\".\").listFiles((dir, name) -> name.matches(pattern));\n-        if (cores.length == 0) {\n-            \/\/ \/cores\/core.$pid might be generated on macosx by default\n-            String pid = output.firstMatch(\"^(\\\\d+)\" + pidSeparator, 1);\n-            core = new File(\"cores\/core.\" + pid);\n-            if (!core.exists()) {\n-                throw new SkippedException(\"Has not been able to find coredump\");\n-            }\n-        } else {\n-            Asserts.assertTrue(cores.length == 1,\n-                    \"There are unexpected files containing core \"\n-                    + \": \" + String.join(\",\", new File(\".\").list()) + \".\");\n-            core = cores[0];\n-        }\n-        System.out.println(\"Found corefile: \" + core.getAbsolutePath());\n+        \/\/ If we are going to force a core dump, apply \"ulimit -c unlimited\" if we can.\n+        pb = CoreUtils.addCoreUlimitCommand(pb);\n+        OutputAnalyzer output =  ProcessTools.executeProcess(pb);\n+\n+        String coreFileName = CoreUtils.getCoreFileLocation(output.getStdout());\n+        File core = new File(coreFileName);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJmapCore.java","additions":7,"deletions":40,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.List;\n@@ -39,0 +38,1 @@\n+import java.util.List;\n","filename":"test\/lib\/jdk\/test\/lib\/SA\/SATestUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.test.lib.util.CoreUtils;\n@@ -88,0 +89,2 @@\n+    protected boolean forceCrash = false; \/\/ set true to force a crash and core file\n+\n@@ -103,0 +106,6 @@\n+    public void setForceCrash(boolean forceCrash) {\n+        this.forceCrash = forceCrash;\n+    }\n+\n+    native private static int crash();\n+\n@@ -276,1 +285,5 @@\n-                throw new IOException(\"App exited unexpectedly with \" + appProcess.exitValue());\n+                if (forceCrash) {\n+                    return; \/\/ This is expected. Just return.\n+                } else {\n+                    throw new IOException(\"App exited unexpectedly with \" + appProcess.exitValue());\n+                }\n@@ -324,0 +337,5 @@\n+        if (forceCrash) {\n+            cmd.add(\"-XX:+CreateCoredumpOnCrash\");\n+            \/\/ We need to find libLingeredApp.so for the crash() native method\n+            cmd.add(\"-Djava.library.path=\" + System.getProperty(\"java.library.path\"));\n+        }\n@@ -359,0 +377,3 @@\n+        if (forceCrash) {\n+            cmd.add(\"forceCrash\"); \/\/ Let the subprocess know to force a crash\n+        }\n@@ -363,0 +384,4 @@\n+        if (forceCrash) {\n+            \/\/ If we are going to force a core dump, apply \"ulimit -c unlimited\" if we can.\n+            pb = CoreUtils.addCoreUlimitCommand(pb);\n+        }\n@@ -496,1 +521,2 @@\n-     * This part is the application it self\n+     * This part is the application itself. First arg is optional \"forceCrash\".\n+     * Following arg is the lock file name.\n@@ -499,0 +525,1 @@\n+        boolean forceCrash = false;\n@@ -500,1 +527,1 @@\n-        if (args.length != 1) {\n+        if (args.length == 0) {\n@@ -503,0 +530,12 @@\n+        } else if (args.length > 2) {\n+            System.err.println(\"Too many arguments specified: \"  + args.length);\n+            System.exit(7);\n+        }\n+\n+        if (args.length == 2) {\n+            if (args[1].equals(\"forceCrash\")) {\n+                forceCrash = true;\n+            } else {\n+                System.err.println(\"Invalid 1st argment: \" + args[1]);\n+                System.exit(7);\n+            }\n@@ -509,0 +548,4 @@\n+            if (forceCrash) {\n+                System.loadLibrary(\"LingeredApp\"); \/\/ location of native crash() method\n+                crash();\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.util;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+import java.util.zip.GZIPInputStream;\n+\n+public class CoreUtils {\n+\n+    private static final String RUN_SHELL_NO_LIMIT = \"ulimit -c unlimited && \";\n+\n+    \/**\n+     * Returns a {@code ulimit} command that will allow for an unlimited core file size\n+     * if the platform supports it.\n+     *\n+     * @return {@code String} for the ulimit command if supported by the platform,\n+     * otherwise {@code null}.\n+     *\/\n+    private static String getCoreUlimitCommand() {\n+        String result = null;\n+        try {\n+            OutputAnalyzer output = ProcessTools.executeProcess(\"sh\", \"-c\", RUN_SHELL_NO_LIMIT + \"ulimit -c\");\n+            if (output.getExitValue() != 0) {\n+                result = null;\n+            } else if (!output.getStdout().contains(\"unlimited\")) {\n+                result = null;\n+            } else {\n+                result = RUN_SHELL_NO_LIMIT; \/\/ success\n+            }\n+        } catch (Throwable t) {\n+            System.out.println(\"Exception in getCoreUlimitCommand(): \" + t.toString());\n+            result = null;\n+        }\n+        System.out.println(\"Run test with ulimit -c: \" +\n+                (result == null ? \"default\" : \"unlimited\"));\n+        return result;\n+    }\n+\n+    \/**\n+     * Return a {@code ProcessBuilder} that has been prefixed with\n+     * a {@code ulimit} command to allow for an unlimited core file size.\n+     *\n+     * @param pb {@code ProcessBuilder} to prefix with the ulimit command\n+     * @return New {@code ProcessBuilder} with prefixed {@code ulimit} command if\n+     * supported. Otherwise the passed in {@code ProcessBuilder} is returned.\n+     *\/\n+    public static ProcessBuilder addCoreUlimitCommand(ProcessBuilder pb) {\n+        String cmd = ProcessTools.getCommandLine(pb);\n+        String ulimitCmd = getCoreUlimitCommand();\n+        if (ulimitCmd == null) {\n+            return pb;\n+        } else {\n+            if (Platform.isWindows()) {\n+                \/\/ In order to launch on Windows using \"sh -c\", we need to first\n+                \/\/ convert the path to use forward slashes and do some extra quoting.\n+                cmd = cmd.replace('\\\\', '\/').replace(\";\", \"\\\\;\").replace(\"|\", \"\\\\|\");\n+            }\n+            return new ProcessBuilder(\"sh\", \"-c\", ulimitCmd + cmd);\n+        }\n+    }\n+\n+    \/**\n+     * Find the path to the core file mentioned in the output and return its path.\n+     *\n+     * @param crashOutputString {@code String} to search in for the core file path\n+     * @return Location of core file if found in the output, otherwise {@code null}.\n+     *\/\n+    public static String getCoreFileLocation(String crashOutputString) throws IOException {\n+        unzipCores(new File(\".\"));\n+\n+        \/\/ Find the core file\n+        String coreFileLocation = parseCoreFileLocationFromOutput(crashOutputString);\n+        if (coreFileLocation != null) {\n+            Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n+            System.out.println(\"Found core file: \" + coreFileLocation);\n+            return coreFileLocation; \/\/ success!\n+        }\n+\n+        \/\/ See if we can figure out the likely reason the core file was not found.\n+        \/\/ Throw SkippedException if appropriate.\n+        if (Platform.isOSX()) {\n+            File coresDir = new File(\"\/cores\");\n+            if (!coresDir.isDirectory()) {\n+                throw new RuntimeException(coresDir + \" is not a directory\");\n+            }\n+            \/\/ The \/cores directory is usually not writable on macOS 10.15\n+            if (!coresDir.canWrite()) {\n+                throw new SkippedException(\"Directory \\\"\" + coresDir + \"\\\" is not writable\");\n+            }\n+        } else if (Platform.isLinux()) {\n+            \/\/ Check if a crash report tool is installed.\n+            File corePatternFile = new File(CORE_PATTERN_FILE_NAME);\n+            try (Scanner scanner = new Scanner(corePatternFile)) {\n+                while (scanner.hasNextLine()) {\n+                    String line = scanner.nextLine();\n+                    line = line.trim();\n+                    System.out.println(line);\n+                    if (line.startsWith(\"|\")) {\n+                        System.out.println(\n+                                \"\\nThis system uses a crash report tool ($cat \/proc\/sys\/kernel\/core_pattern).\\n\" +\n+                                        \"Core files might not be generated. Please reset \/proc\/sys\/kernel\/core_pattern\\n\" +\n+                                        \"to enable core generation. Skipping this test.\");\n+                        throw new SkippedException(\"This system uses a crash report tool\");\n+                    }\n+                }\n+            }\n+        }\n+        throw new RuntimeException(\"Couldn't find core file location in: '\" + crashOutputString + \"'\");\n+    }\n+\n+    private static final String CORE_PATTERN_FILE_NAME = \"\/proc\/sys\/kernel\/core_pattern\";\n+    private static final String LOCATION_STRING = \"location: \";\n+\n+    private static String parseCoreFileLocationFromOutput(String crashOutputString) {\n+        System.out.println(\"crashOutputString = [\" + crashOutputString + \"]\");\n+        if(crashOutputString == null || crashOutputString.equals(\"\")) {\n+            return null;\n+        }\n+        \/\/ Find the line of output that contains LOCATION_STRING\n+        Asserts.assertTrue(crashOutputString.contains(LOCATION_STRING),\n+                \"Output doesn't contain the location of core file.\");\n+        String stringWithLocation = Arrays.stream(crashOutputString.split(\"\\\\r?\\\\n\"))\n+                .filter(str -> str.contains(LOCATION_STRING))\n+                .findFirst()\n+                .get();\n+        stringWithLocation = stringWithLocation.substring(stringWithLocation\n+                .indexOf(LOCATION_STRING) + LOCATION_STRING.length());\n+        System.out.println(\"getCoreFileLocation found stringWithLocation = \" + stringWithLocation);\n+\n+        \/\/ Find the core file name in the output.\n+        String coreWithPid;\n+        if (stringWithLocation.contains(\"or \") && !Platform.isWindows()) {\n+            Matcher m = Pattern.compile(\"or.* ([^ ]+[^\\\\)])\\\\)?\").matcher(stringWithLocation);\n+            if (!m.find()) {\n+                throw new RuntimeException(\"Couldn't find path to core inside location string\");\n+            }\n+            coreWithPid = m.group(1);\n+        } else {\n+            coreWithPid = stringWithLocation.trim();\n+        }\n+        if (new File(coreWithPid).exists()) {\n+            return coreWithPid;\n+        }\n+\n+        \/\/ Look for file named \"core\" in the cwd.\n+        String justCore = Paths.get(\"core\").toString();\n+        if (new File(justCore).exists()) {\n+            return justCore;\n+        }\n+\n+        \/\/ Look for the core file name found in the output, but do so in the cwd.\n+        Path coreWithPidPath = Paths.get(coreWithPid);\n+        String justFile = coreWithPidPath.getFileName().toString();\n+        if (new File(justFile).exists()) {\n+            return justFile;\n+        }\n+\n+        \/\/ Look for file named \"core\" in the path to the core file found in the output.\n+        Path parent = coreWithPidPath.getParent();\n+        if (parent != null) {\n+            String coreWithoutPid = parent.resolve(\"core\").toString();\n+            if (new File(coreWithoutPid).exists()) {\n+                return coreWithoutPid;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void unzipCores(File dir) {\n+        File[] gzCores = dir.listFiles((directory, name) -> name.matches(\"core(\\\\.\\\\d+)?\\\\.gz\"));\n+        for (File gzCore : gzCores) {\n+            String coreFileName = gzCore.getName().replace(\".gz\", \"\");\n+            System.out.println(\"Unzipping core into \" + coreFileName);\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(gzCore.toPath()))) {\n+                Files.copy(gzis, Paths.get(coreFileName));\n+            } catch (IOException e) {\n+                throw new SkippedException(\"Not able to unzip file: \" + gzCore.getAbsolutePath(), e);\n+            }\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/jdk\/test\/lib\/util\/CoreUtils.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"}]}