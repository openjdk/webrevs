{"files":[{"patch":"@@ -825,0 +825,2 @@\n+  assert(osthread->pthread_id() != 0, \"pthread_id was not set as expected\");\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,0 @@\n-  this->initialize_named_thread();\n","filename":"src\/hotspot\/share\/gc\/parallel\/gcTaskThread.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-  this->initialize_named_thread();\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -315,1 +315,0 @@\n-  this->initialize_named_thread();\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -338,1 +338,2 @@\n-\n+ protected:\n+  virtual void post_run();\n@@ -499,0 +500,4 @@\n+}\n+\n+void JfrThreadSampler::post_run() {\n+  this->NonJavaThread::post_run();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+DEBUG_ONLY(Thread* Thread::_starting_thread = NULL;)\n@@ -223,0 +224,3 @@\n+\n+  DEBUG_ONLY(_run_state = PRE_CALL_RUN;)\n+\n@@ -321,0 +325,6 @@\n+  } else {\n+    \/\/ Only the main thread should be created before the barrier set\n+    \/\/ and that happens just before Thread::current is set. No other thread\n+    \/\/ can attach as the VM is not created yet, so they can't execute this code.\n+    \/\/ If the main thread creates other threads before the barrier set that is an error.\n+    assert(Thread::current_or_null() == NULL, \"creating thread before barrier set\");\n@@ -372,0 +382,2 @@\n+  DEBUG_ONLY(_run_state = CALL_RUN;)\n+\n@@ -375,0 +387,5 @@\n+  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() == this, \"current thread is wrong\");\n+\n+  \/\/ Perform common initialization actions\n+\n@@ -386,0 +403,4 @@\n+  \/\/ Perform <ChildClass> initialization actions\n+  DEBUG_ONLY(_run_state = PRE_RUN;)\n+  this->pre_run();\n+\n@@ -387,0 +408,1 @@\n+  DEBUG_ONLY(_run_state = RUN;)\n@@ -390,2 +412,1 @@\n-  \/\/ Note: at this point the thread object may already have deleted itself.\n-  \/\/ So from here on do not dereference *this*.\n+  \/\/ Perform common tear-down actions\n@@ -393,8 +414,2 @@\n-  \/\/ If a thread has not deleted itself (\"delete this\") as part of its\n-  \/\/ termination sequence, we have to ensure thread-local-storage is\n-  \/\/ cleared before we actually terminate. No threads should ever be\n-  \/\/ deleted asynchronously with respect to their termination.\n-  if (Thread::current_or_null_safe() != NULL) {\n-    assert(Thread::current_or_null_safe() == this, \"current thread is wrong\");\n-    Thread::clear_thread_current();\n-  }\n+  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() == this, \"current thread is wrong\");\n@@ -402,0 +417,11 @@\n+  \/\/ Perform <ChildClass> tear-down actions\n+  DEBUG_ONLY(_run_state = POST_RUN;)\n+  this->post_run();\n+\n+  \/\/ Note: at this point the thread object may already have deleted itself,\n+  \/\/ so from here on do not dereference *this*. Not all thread types currently\n+  \/\/ delete themselves when they terminate. But no thread should ever be deleted\n+  \/\/ asynchronously with respect to its termination - that is what _run_state can\n+  \/\/ be used to check.\n+\n+  assert(Thread::current_or_null() == NULL, \"current thread still present\");\n@@ -405,0 +431,8 @@\n+\n+  \/\/ Attached threads will remain in PRE_CALL_RUN, as will threads that don't actually\n+  \/\/ get started due to errors etc. Any active thread should at least reach post_run\n+  \/\/ before it is deleted (usually in post_run()).\n+  assert(_run_state == PRE_CALL_RUN ||\n+         _run_state == POST_RUN, \"Active Thread deleted before post_run(): \"\n+         \"_run_state=%d\", (int)_run_state);\n+\n@@ -451,1 +485,2 @@\n-  \/\/ clear Thread::current if thread is deleting itself.\n+  \/\/ Clear Thread::current if thread is deleting itself and it has not\n+  \/\/ already been done. This must be done before the memory is deallocated.\n@@ -453,1 +488,1 @@\n-  if (this == Thread::current()) {\n+  if (this == Thread::current_or_null()) {\n@@ -1061,0 +1096,2 @@\n+  assert(_starting_thread == NULL, \"already initialized: \"\n+         \"_starting_thread=\" INTPTR_FORMAT, p2i(_starting_thread));\n@@ -1062,0 +1099,1 @@\n+  DEBUG_ONLY(_starting_thread = this;)\n@@ -1310,1 +1348,6 @@\n-  \/\/ Add this thread to _the_list.\n+  assert(BarrierSet::barrier_set() != NULL, \"NonJavaThread created too soon!\");\n+}\n+\n+NonJavaThread::~NonJavaThread() { }\n+\n+void NonJavaThread::add_to_the_list() {\n@@ -1316,3 +1359,1 @@\n-NonJavaThread::~NonJavaThread() {\n-  JFR_ONLY(Jfr::on_thread_exit(this);)\n-  \/\/ Remove this thread from _the_list.\n+void NonJavaThread::remove_from_the_list() {\n@@ -1324,1 +1365,2 @@\n-      \/\/ Wait for any in-progress iterators.\n+      \/\/ Wait for any in-progress iterators.  Concurrent synchronize is\n+      \/\/ not allowed, so do it while holding the list lock.\n@@ -1331,0 +1373,17 @@\n+void NonJavaThread::pre_run() {\n+  assert(BarrierSet::barrier_set() != NULL, \"invariant\");\n+  add_to_the_list();\n+\n+  \/\/ This is slightly odd in that NamedThread is a subclass, but\n+  \/\/ in fact name() is defined in Thread\n+  assert(this->name() != NULL, \"thread name was not set before it was started\");\n+  this->set_native_thread_name(this->name());\n+}\n+\n+void NonJavaThread::post_run() {\n+  JFR_ONLY(Jfr::on_thread_exit(this);)\n+  remove_from_the_list();\n+  \/\/ Ensure thread-local-storage is cleared before termination.\n+  Thread::clear_thread_current();\n+}\n+\n@@ -1357,4 +1416,0 @@\n-void NamedThread::initialize_named_thread() {\n-  set_native_thread_name(name());\n-}\n-\n@@ -1457,1 +1512,0 @@\n-  this->set_native_thread_name(this->name());\n@@ -1818,1 +1872,8 @@\n-\/\/ The first routine called by a new Java thread\n+\/\/ First JavaThread specific code executed by a new Java thread.\n+void JavaThread::pre_run() {\n+  \/\/ empty - see comments in run()\n+}\n+\n+\/\/ The main routine called by a new Java thread. This isn't overridden\n+\/\/ by subclasses, instead different subclasses define a different \"entry_point\"\n+\/\/ which defines the actual logic for that kind of thread.\n@@ -1823,1 +1884,5 @@\n-  \/\/ used to test validity of stack trace backs\n+  \/\/ Used to test validity of stack trace backs.\n+  \/\/ This can't be moved into pre_run() else we invalidate\n+  \/\/ the requirement that thread_main_inner is lower on\n+  \/\/ the stack. Consequently all the initialization logic\n+  \/\/ stays here in run() rather than pre_run().\n@@ -1830,1 +1895,1 @@\n-  \/\/ Thread is now sufficient initialized to be handled by the safepoint code as being\n+  \/\/ Thread is now sufficiently initialized to be handled by the safepoint code as being\n@@ -1849,1 +1914,1 @@\n-  \/\/ from there will be lower than the stack base just computed\n+  \/\/ from there will be lower than the stack base just computed.\n@@ -1851,2 +1916,0 @@\n-\n-  \/\/ Note, thread is no longer valid at this point!\n@@ -1855,1 +1918,0 @@\n-\n@@ -1875,0 +1937,5 @@\n+  \/\/ Cleanup is handled in post_run()\n+}\n+\n+\/\/ Shared teardown for all JavaThreads\n+void JavaThread::post_run() {\n@@ -1876,0 +1943,2 @@\n+  \/\/ Defer deletion to here to ensure 'this' is still referenceable in call_run\n+  \/\/ for any shared tear-down.\n@@ -1879,1 +1948,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":98,"deletions":30,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -115,0 +115,21 @@\n+\/\/ Thread execution sequence and actions:\n+\/\/ All threads:\n+\/\/  - thread_native_entry  \/\/ per-OS native entry point\n+\/\/    - stack initialization\n+\/\/    - other OS-level initialization (signal masks etc)\n+\/\/    - handshake with creating thread (if not started suspended)\n+\/\/    - this->call_run()  \/\/ common shared entry point\n+\/\/      - shared common initialization\n+\/\/      - this->pre_run()  \/\/ virtual per-thread-type initialization\n+\/\/      - this->run()      \/\/ virtual per-thread-type \"main\" logic\n+\/\/      - shared common tear-down\n+\/\/      - this->post_run()  \/\/ virtual per-thread-type tear-down\n+\/\/      - \/\/ 'this' no longer referenceable\n+\/\/    - OS-level tear-down (minimal)\n+\/\/    - final logging\n+\/\/\n+\/\/ For JavaThread:\n+\/\/   - this->run()  \/\/ virtual but not normally overridden\n+\/\/     - this->thread_main_inner()  \/\/ extra call level to ensure correct stack calculations\n+\/\/       - this->entry_point()  \/\/ set differently for each kind of JavaThread\n+\n@@ -125,1 +146,0 @@\n- private:\n@@ -147,0 +167,3 @@\n+\n+  DEBUG_ONLY(static Thread* _starting_thread;)\n+\n@@ -400,0 +423,15 @@\n+  virtual void pre_run() = 0;\n+  virtual void post_run() = 0;  \/\/ Note: Thread must not be deleted prior to calling this!\n+\n+#ifdef ASSERT\n+  enum RunState {\n+    PRE_CALL_RUN,\n+    CALL_RUN,\n+    PRE_RUN,\n+    RUN,\n+    POST_RUN\n+    \/\/ POST_CALL_RUN - can't define this one as 'this' may be deleted when we want to set it\n+  };\n+  RunState _run_state;  \/\/ for lifecycle checks\n+#endif\n+\n@@ -800,0 +838,7 @@\n+  void add_to_the_list();\n+  void remove_from_the_list();\n+\n+ protected:\n+  virtual void pre_run();\n+  virtual void post_run();\n+\n@@ -807,6 +852,6 @@\n-\/\/ Provides iteration over the list of NonJavaThreads.  Because list\n-\/\/ management occurs in the NonJavaThread constructor and destructor,\n-\/\/ entries in the list may not be fully constructed instances of a\n-\/\/ derived class.  Threads created after an iterator is constructed\n-\/\/ will not be visited by the iterator.  The scope of an iterator is a\n-\/\/ critical section; there must be no safepoint checks in that scope.\n+\/\/ Provides iteration over the list of NonJavaThreads.\n+\/\/ List addition occurs in pre_run(), and removal occurs in post_run(),\n+\/\/ so that only live fully-initialized threads can be found in the list.\n+\/\/ Threads created after an iterator is constructed will not be visited\n+\/\/ by the iterator. The scope of an iterator is a critical section; there\n+\/\/ must be no safepoint checks in that scope.\n@@ -846,1 +891,0 @@\n-  void initialize_named_thread();\n@@ -877,1 +921,1 @@\n- public:\n+ protected:\n@@ -1844,1 +1888,1 @@\n- private:\n+ protected:\n@@ -1846,1 +1890,1 @@\n-  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+  virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n@@ -1903,1 +1947,2 @@\n- public:\n+ protected:\n+  virtual void pre_run();\n@@ -1906,0 +1951,2 @@\n+  virtual void post_run();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":59,"deletions":12,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -288,2 +288,0 @@\n-  this->initialize_named_thread();\n-\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}