{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.net.ProtocolException;\n@@ -413,0 +414,2 @@\n+        \/\/ after 101 is handled we check for other 1xx responses\n+        cf = cf.thenCompose(this::ignore1xxResponse);\n@@ -417,0 +420,50 @@\n+    \/**\n+     * Checks whether the passed Response has a status code between 102 and 199 (both inclusive).\n+     * If so, then that {@code Response} is considered intermediate informational response and is\n+     * ignored by the client. This method then creates a new {@link CompletableFuture} which\n+     * completes when a subsequent response is sent by the server. Such newly constructed\n+     * {@link CompletableFuture} will not complete till a \"final\" response (one which doesn't have\n+     * a response code between 102 and 199 inclusive) is sent by the server. The returned\n+     * {@link CompletableFuture} is thus capable of handling multiple subsequent intermediate\n+     * informational responses from the server.\n+     * <p>\n+     * If the passed Response doesn't have a status code between 102 and 199 (both inclusive) then\n+     * this method immediately returns back a completed {@link CompletableFuture} with the passed\n+     * {@code Response}.\n+     * <\/p>\n+     *\n+     * @param rsp The response\n+     * @return A {@code CompletableFuture} with the final response from the server\n+     *\/\n+    private CompletableFuture<Response> ignore1xxResponse(final Response rsp) {\n+        final int statusCode = rsp.statusCode();\n+        \/\/ we ignore any response code which is 1xx.\n+        \/\/ For 100 (with the request configured to expect-continue) and 101, we handle it\n+        \/\/ specifically as defined in the RFC-9110, outside of this method.\n+        \/\/ As noted in RFC-9110, section 15.2.1, if response code is 100 and if the request wasn't\n+        \/\/ configured with expectContinue, then we ignore the 100 response and wait for the final\n+        \/\/ response (just like any other 1xx response).\n+        \/\/ Any other response code between 102 and 199 (both inclusive) aren't specified in the\n+        \/\/ \"HTTP semantics\" RFC-9110. The spec states that these 1xx response codes are informational\n+        \/\/ and interim and the client can choose to ignore them and continue to wait for the\n+        \/\/ final response (headers)\n+        if ((statusCode >= 102 && statusCode <= 199)\n+                || (statusCode == 100 && !request.expectContinue)) {\n+            Log.logTrace(\"Ignoring (1xx informational) response code {0}\", rsp.statusCode());\n+            if (debug.on()) {\n+                debug.log(\"Ignoring (1xx informational) response code \"\n+                        + rsp.statusCode());\n+            }\n+            assert exchImpl != null : \"Illegal state - current exchange isn't set\";\n+            \/\/ ignore this Response and wait again for the subsequent response headers\n+            final CompletableFuture<Response> cf = exchImpl.getResponseAsync(parentExecutor);\n+            \/\/ we recompose the CF again into the ignore1xxResponse check\/function because\n+            \/\/ the 1xx response is allowed to be sent multiple times for a request, before\n+            \/\/ a final response arrives\n+            return cf.thenCompose(this::ignore1xxResponse);\n+        } else {\n+            \/\/ return the already completed future\n+            return MinimalFuture.completedFuture(rsp);\n+        }\n+    }\n+\n@@ -447,1 +500,24 @@\n-        return cf;\n+        \/\/ websocket requests use \"Connection: Upgrade\" and \"Upgrade: websocket\" headers.\n+        \/\/ however, the \"upgrading\" flag we maintain in this class only tracks a h2 upgrade\n+        \/\/ that we internally triggered. So it will be false in the case of websocket upgrade, hence\n+        \/\/ this additional check. If it's a websocket request we allow 101 responses and we don't\n+        \/\/ require any additional checks when a response arrives.\n+        if (request.isWebSocket()) {\n+            return cf;\n+        }\n+        \/\/ not expecting an upgrade, but if the server sends a 101 response then we fail the\n+        \/\/ request and also let the ExchangeImpl deal with it as a protocol error\n+        return cf.thenCompose(r -> {\n+            if (r.statusCode == 101) {\n+                final ProtocolException protoEx = new ProtocolException(\"Unexpected 101 \" +\n+                        \"response, when not upgrading\");\n+                assert exchImpl != null : \"Illegal state - current exchange isn't set\";\n+                try {\n+                    exchImpl.onProtocolError(protoEx);\n+                } catch (Throwable ignore){\n+                    \/\/ ignored\n+                }\n+                return MinimalFuture.failedFuture(protoEx);\n+            }\n+            return MinimalFuture.completedFuture(r);\n+        });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -202,0 +202,10 @@\n+    \/**\n+     * Invoked whenever there is a (HTTP) protocol error when dealing with the response\n+     * from the server. The implementations of {@code ExchangeImpl} are then expected to\n+     * take necessary action that is expected by the corresponding specifications whenever\n+     * a protocol error happens. For example, in HTTP\/1.1, such protocol error would result\n+     * in the connection being closed.\n+     * @param cause The cause of the protocol violation\n+     *\/\n+    abstract void onProtocolError(IOException cause);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -427,0 +427,9 @@\n+    }\n+\n+    @Override\n+    void onProtocolError(final IOException cause) {\n+        if (debug.on()) {\n+            debug.log(\"cancelling exchange due to protocol error: %s\", cause.getMessage());\n+        }\n+        Log.logError(\"cancelling exchange due to protocol error: {0}\\n\", cause);\n+        cancelImpl(cause);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-            initialStream.sendCancelStreamFrame();\n+            initialStream.sendResetStreamFrame(ResetFrame.CANCEL);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.net.ProtocolException;\n@@ -564,0 +565,2 @@\n+            } else if (throwable instanceof ProtocolException) {\n+                throw new ProtocolException(msg);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1216,0 +1216,10 @@\n+    @Override\n+    void onProtocolError(final IOException cause) {\n+        if (debug.on()) {\n+            debug.log(\"cancelling exchange on stream %d due to protocol error: %s\", streamid, cause.getMessage());\n+        }\n+        Log.logError(\"cancelling exchange on stream {0} due to protocol error: {1}\\n\", streamid, cause);\n+        \/\/ send a RESET frame and close the stream\n+        cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+    }\n+\n@@ -1227,0 +1237,4 @@\n+        cancelImpl(e, ResetFrame.CANCEL);\n+    }\n+\n+    private void cancelImpl(final Throwable e, final int resetFrameErrCode) {\n@@ -1258,2 +1272,2 @@\n-                e = Utils.getCompletionCause(e);\n-                if (e instanceof EOFException) {\n+                final Throwable cause = Utils.getCompletionCause(e);\n+                if (cause instanceof EOFException) {\n@@ -1265,1 +1279,1 @@\n-                    sendCancelStreamFrame();\n+                    sendResetStreamFrame(resetFrameErrCode);\n@@ -1273,1 +1287,1 @@\n-    void sendCancelStreamFrame() {\n+    void sendResetStreamFrame(final int resetFrameErrCode) {\n@@ -1275,2 +1289,2 @@\n-        if (streamid > 0 && markStream(ResetFrame.CANCEL) == 0) {\n-            connection.resetStream(streamid, ResetFrame.CANCEL);\n+        if (streamid > 0 && markStream(resetFrameErrCode) == 0) {\n+            connection.resetStream(streamid, resetFrameErrCode);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,497 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ProtocolException;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8292044\n+ * @summary Tests behaviour of HttpClient when server responds with 102 or 103 status codes\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          jdk.httpserver\n+ * @library \/test\/lib http2\/server\n+ * @build Http2TestServer HttpServerAdapters SpecialHeadersTest\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ * *                   -Djdk.httpclient.HttpClient.log=headers,requests,responses,errors Response1xxTest\n+ *\/\n+public class Response1xxTest implements HttpServerAdapters {\n+    private static final String EXPECTED_RSP_BODY = \"Hello World\";\n+\n+    private ServerSocket serverSocket;\n+    private Http11Server server;\n+    private String http1RequestURIBase;\n+\n+\n+    private HttpTestServer http2Server; \/\/ h2c\n+    private String http2RequestURIBase;\n+\n+\n+    private SSLContext sslContext;\n+    private HttpTestServer https2Server;  \/\/ h2\n+    private String https2RequestURIBase;\n+\n+    private final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        server = new Http11Server(serverSocket);\n+        new Thread(server).start();\n+        http1RequestURIBase = URIBuilder.newBuilder().scheme(\"http\").loopback()\n+                .port(serverSocket.getLocalPort()).build().toString();\n+\n+        http2Server = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/102\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/103\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/100\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/101\");\n+        http2Server.addHandler(new OKHandler(), \"\/http2\/200\");\n+        http2Server.addHandler(new OnlyInformationalHandler(), \"\/http2\/only-informational\");\n+        http2RequestURIBase = URIBuilder.newBuilder().scheme(\"http\").loopback()\n+                .port(http2Server.getAddress().getPort())\n+                .path(\"\/http2\").build().toString();\n+\n+        http2Server.start();\n+        System.out.println(\"Started HTTP2 server at \" + http2Server.getAddress());\n+\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        https2Server = HttpTestServer.of(new Http2TestServer(\"localhost\",\n+                true, sslContext));\n+        https2Server.addHandler(new Http2Handler(), \"\/http2\/101\");\n+        https2RequestURIBase = URIBuilder.newBuilder().scheme(\"https\").loopback()\n+                .port(https2Server.getAddress().getPort())\n+                .path(\"\/http2\").build().toString();\n+        https2Server.start();\n+        System.out.println(\"Started (https) HTTP2 server at \" + https2Server.getAddress());\n+\n+    }\n+\n+    @AfterClass\n+    public void teardown() throws Throwable {\n+        try {\n+            assertNoOutstandingClientOps();\n+        } finally {\n+            if (server != null) {\n+                server.stop = true;\n+                System.out.println(\"(HTTP 1.1) Server stop requested\");\n+            }\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+                System.out.println(\"Closed (HTTP 1.1) server socket\");\n+            }\n+            if (http2Server != null) {\n+                http2Server.stop();\n+                System.out.println(\"Stopped HTTP2 server\");\n+            }\n+            if (https2Server != null) {\n+                https2Server.stop();\n+                System.out.println(\"Stopped (https) HTTP2 server\");\n+            }\n+        }\n+    }\n+\n+    private static final class Http11Server implements Runnable {\n+        private static final int CONTENT_LENGTH = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8).length;\n+\n+        private static final String HTTP_1_1_RSP_200 = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Content-Length: \" + CONTENT_LENGTH + \"\\r\\n\\r\\n\" +\n+                EXPECTED_RSP_BODY;\n+\n+        private static final String REQ_LINE_FOO = \"GET \/test\/foo HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BAR = \"GET \/test\/bar HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_HELLO = \"GET \/test\/hello HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BYE = \"GET \/test\/bye HTTP\/1.1\\r\\n\";\n+\n+\n+        private final ServerSocket serverSocket;\n+        private volatile boolean stop;\n+\n+        private Http11Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            System.out.println(\"Server running at \" + serverSocket);\n+            while (!stop) {\n+                Socket socket = null;\n+                try {\n+                    \/\/ accept a connection\n+                    socket = serverSocket.accept();\n+                    System.out.println(\"Accepted connection from client \" + socket);\n+                    \/\/ read request\n+                    final String requestLine;\n+                    try {\n+                        requestLine = readRequestLine(socket);\n+                    } catch (Throwable t) {\n+                        \/\/ ignore connections from potential rogue client\n+                        System.err.println(\"Ignoring connection\/request from client \" + socket\n+                                + \" due to exception:\");\n+                        t.printStackTrace();\n+                        \/\/ close the socket\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    System.out.println(\"Received following request line from client \" + socket\n+                            + \" :\\n\" + requestLine);\n+                    final int informationalResponseCode;\n+                    if (requestLine.startsWith(REQ_LINE_FOO)) {\n+                        \/\/ we will send intermediate\/informational 102 response\n+                        informationalResponseCode = 102;\n+                    } else if (requestLine.startsWith(REQ_LINE_BAR)) {\n+                        \/\/ we will send intermediate\/informational 103 response\n+                        informationalResponseCode = 103;\n+                    } else if (requestLine.startsWith(REQ_LINE_HELLO)) {\n+                        \/\/ we will send intermediate\/informational 100 response\n+                        informationalResponseCode = 100;\n+                    } else if (requestLine.startsWith(REQ_LINE_BYE)) {\n+                        \/\/ we will send intermediate\/informational 101 response\n+                        informationalResponseCode = 101;\n+                    } else {\n+                        \/\/ unexpected client. ignore and close the client\n+                        System.err.println(\"Ignoring unexpected request from client \" + socket);\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    try (final OutputStream os = socket.getOutputStream()) {\n+                        \/\/ send informational response headers a few times (spec allows them to\n+                        \/\/ be sent multiple times)\n+                        for (int i = 0; i < 3; i++) {\n+                            \/\/ send 1xx response header\n+                            if (informationalResponseCode == 101) {\n+                                os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\" +\n+                                        \"Connection: upgrade\\r\\n\" +\n+                                        \"Upgrade: websocket\\r\\n\\r\\n\")\n+                                        .getBytes(StandardCharsets.UTF_8));\n+                            } else {\n+                                os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\\r\\n\")\n+                                        .getBytes(StandardCharsets.UTF_8));\n+                            }\n+                            os.flush();\n+                            System.out.println(\"Sent response code \" + informationalResponseCode\n+                                    + \" to client \" + socket);\n+                        }\n+                        \/\/ now send a final response\n+                        System.out.println(\"Now sending 200 response code to client \" + socket);\n+                        os.write(HTTP_1_1_RSP_200.getBytes(StandardCharsets.UTF_8));\n+                        os.flush();\n+                        System.out.println(\"Sent 200 response code to client \" + socket);\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ close the client connection\n+                    safeClose(socket);\n+                    \/\/ continue accepting any other client connections until we are asked to stop\n+                    System.err.println(\"Ignoring exception in server:\");\n+                    t.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        static String readRequestLine(final Socket sock) throws IOException {\n+            final InputStream is = sock.getInputStream();\n+            final StringBuilder sb = new StringBuilder(\"\");\n+            byte[] buf = new byte[1024];\n+            while (!sb.toString().endsWith(\"\\r\\n\\r\\n\")) {\n+                final int numRead = is.read(buf);\n+                if (numRead == -1) {\n+                    return sb.toString();\n+                }\n+                final String part = new String(buf, 0, numRead, StandardCharsets.ISO_8859_1);\n+                sb.append(part);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void safeClose(final Socket socket) {\n+            try {\n+                socket.close();\n+            } catch (Throwable t) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    private static class Http2Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final URI requestURI = exchange.getRequestURI();\n+            final int informationResponseCode;\n+            if (requestURI.getPath().endsWith(\"\/102\")) {\n+                informationResponseCode = 102;\n+            } else if (requestURI.getPath().endsWith(\"\/103\")) {\n+                informationResponseCode = 103;\n+            } else if (requestURI.getPath().endsWith(\"\/100\")) {\n+                informationResponseCode = 100;\n+            } else if (requestURI.getPath().endsWith(\"\/101\")) {\n+                informationResponseCode = 101;\n+            } else {\n+                \/\/ unexpected request\n+                System.err.println(\"Unexpected request \" + requestURI + \" from client \"\n+                        + exchange.getRemoteAddress());\n+                exchange.sendResponseHeaders(400, -1);\n+                return;\n+            }\n+            \/\/ send informational response headers a few times (spec allows them to\n+            \/\/ be sent multiple times)\n+            for (int i = 0; i < 3; i++) {\n+                exchange.sendResponseHeaders(informationResponseCode, -1);\n+                System.out.println(\"Sent \" + informationResponseCode + \" response code from H2 server\");\n+            }\n+            \/\/ now send 200 response\n+            try {\n+                final byte[] body = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, body.length);\n+                System.out.println(\"Sent 200 response from H2 server\");\n+                try (OutputStream os = exchange.getResponseBody()) {\n+                    os.write(body);\n+                }\n+                System.out.println(\"Sent response body from H2 server\");\n+            } catch (Throwable e) {\n+                System.err.println(\"Failed to send response from HTTP2 handler:\");\n+                e.printStackTrace();\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static class OnlyInformationalHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            \/\/ we only send informational response and then return\n+            for (int i = 0; i < 5; i++) {\n+                exchange.sendResponseHeaders(102, -1);\n+                System.out.println(\"Sent 102 response code from H2 server\");\n+                \/\/ wait for a while before sending again\n+                try {\n+                    Thread.sleep(2000);\n+                } catch (InterruptedException e) {\n+                    \/\/ just return\n+                    System.err.println(\"Handler thread interrupted\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class OKHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(200, -1);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP\/1.1 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP11() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_1_1)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http1RequestURIBase + \"\/test\/foo\"),\n+                new URI(http1RequestURIBase + \"\/test\/bar\"),\n+                new URI(http1RequestURIBase + \"\/test\/hello\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_1_1,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP2 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP2() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http2RequestURIBase + \"\/102\"),\n+                new URI(http2RequestURIBase + \"\/103\"),\n+                new URI(http2RequestURIBase + \"\/100\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_2,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Tests that when a request is issued with a specific request timeout and the server\n+     * responds with intermediate 1xx response code but doesn't respond with a final response within\n+     * the timeout duration, then the application fails with a request timeout\n+     *\/\n+    @Test\n+    public void test1xxRequestTimeout() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/only-informational\");\n+        final Duration requestTimeout = Duration.ofSeconds(2);\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).timeout(requestTimeout)\n+                .build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to timeout\n+        Assert.assertThrows(HttpTimeoutException.class, () -> {\n+            client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+        });\n+    }\n+\n+    \/**\n+     * Tests that when the HTTP\/1.1 server sends a 101 response when the request hasn't asked\n+     * for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testHTTP11Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_1_1)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(http1RequestURIBase + \"\/test\/bye\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        Assert.assertThrows(ProtocolException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+\n+    \/**\n+     * Tests that when the HTTP2 server (over HTTPS) sends a 101 response when the request\n+     * hasn't asked for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testSecureHTTP2Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .sslContext(sslContext)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(https2RequestURIBase + \"\/101\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        \/\/ Backport note: Later JDK versions (e.g. 17 or 21) throw a ProtocolException.\n+        Assert.assertThrows(IOException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+    \/**\n+     * Tests that when the HTTP2 server (over plain HTTP) sends a 101 response when the request\n+     * hasn't asked for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testPlainHTTP2Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        \/\/ when using HTTP2 version against a \"http:\/\/\" (non-secure) URI\n+        \/\/ the HTTP client (implementation) internally initiates a HTTP\/1.1 connection\n+        \/\/ and then does an \"Upgrade:\" to \"h2c\". This it does when there isn't already a\n+        \/\/ H2 connection against the target\/destination server. So here we initiate a dummy request\n+        \/\/ using the client instance against the same target server and just expect it to return\n+        \/\/ back successfully. Once that connection is established (and internally pooled), the client\n+        \/\/ will then reuse that connection and won't issue an \"Upgrade:\" and thus we can then\n+        \/\/ start our testing\n+        warmupH2Client(client);\n+        \/\/ start the actual testing\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/101\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        Assert.assertThrows(ProtocolException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+    \/\/ sends a request and expects a 200 response back\n+    private void warmupH2Client(final HttpClient client) throws Exception {\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/200\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing (warmup) request to \" + requestURI);\n+        final HttpResponse<Void> response = client.send(request, HttpResponse.BodyHandlers.discarding());\n+        Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+    }\n+\n+    \/\/ verifies that the HttpClient being tracked has no outstanding operations\n+    private void assertNoOutstandingClientOps() throws AssertionError {\n+        System.gc();\n+        final AssertionError refCheckFailure = TRACKER.check(1000);\n+        if (refCheckFailure != null) {\n+            throw refCheckFailure;\n+        }\n+        \/\/ successful test completion\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/Response1xxTest.java","additions":497,"deletions":0,"binary":false,"changes":497,"status":"added"}]}