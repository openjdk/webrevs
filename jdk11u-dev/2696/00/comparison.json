{"files":[{"patch":"@@ -35,4 +35,4 @@\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl ManyRequests\n- * @run main\/othervm\/timeout=40 -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n@@ -41,1 +41,1 @@\n- \/\/ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl ManyRequests\n+ \/\/ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n@@ -50,0 +50,1 @@\n+import java.net.ConnectException;\n@@ -56,0 +57,1 @@\n+import java.net.http.HttpResponse;\n@@ -61,0 +63,1 @@\n+import java.util.Map;\n@@ -65,0 +68,5 @@\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n@@ -66,0 +74,3 @@\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.RandomFactory;\n@@ -67,0 +78,1 @@\n+import jdk.test.lib.net.URIBuilder;\n@@ -70,1 +82,5 @@\n-    volatile static int counter = 0;\n+    static final int MAX_COUNT = 20;\n+    static final int MAX_LIMIT = 40;\n+    static final AtomicInteger COUNT = new AtomicInteger();\n+    static final AtomicInteger LIMIT = new AtomicInteger(MAX_LIMIT);\n+    static final Random RANDOM = RandomFactory.getRandom();\n@@ -76,0 +92,1 @@\n+        Stream.of(Logger.getLogger(\"\").getHandlers()).forEach((h) -> h.setLevel(Level.ALL));\n@@ -98,1 +115,1 @@\n-    static final int REQUESTS = 20;\n+    static final int REQUESTS = MAX_COUNT;\n@@ -105,1 +122,1 @@\n-        final Random rand = new Random();\n+        final Random rand = RANDOM;\n@@ -131,0 +148,16 @@\n+    static String now(long start) {\n+        long elapsed = System.nanoTime() - start;\n+        long ms = elapsed \/ 1000_000L;\n+        long s = ms \/ 1000L;\n+        if (s == 0) return ms + \"ms: \";\n+        return s + \"s, \" + (ms - s * 1000L) + \"ms: \";\n+    }\n+\n+    static String failure(Throwable t) {\n+        String s = \"\\n\\t failed: \" + t;\n+        for (t = t.getCause(); t != null ; t = t.getCause()) {\n+            s = s + \"\\n\\t\\t  Caused by: \" + t;\n+        }\n+        return s;\n+    }\n+\n@@ -133,1 +166,6 @@\n-        URI baseURI = new URI(\"https:\/\/localhost:\" + port + \"\/foo\/x\");\n+\n+        URI baseURI = URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .host(InetAddress.getLoopbackAddress().getHostName())\n+                .port(port)\n+                .path(\"\/foo\/x\").build();\n@@ -137,45 +175,92 @@\n-        RequestLimiter limiter = new RequestLimiter(40);\n-        Random rand = new Random();\n-        CompletableFuture<?>[] results = new CompletableFuture<?>[REQUESTS];\n-        HashMap<HttpRequest,byte[]> bodies = new HashMap<>();\n-\n-        for (int i=0; i<REQUESTS; i++) {\n-            byte[] buf = new byte[(i+1)*CHUNK_SIZE+i+1];  \/\/ different size bodies\n-            rand.nextBytes(buf);\n-            URI uri = new URI(baseURI.toString() + String.valueOf(i+1));\n-            HttpRequest r = HttpRequest.newBuilder(uri)\n-                                       .header(\"XFixed\", \"true\")\n-                                       .POST(BodyPublishers.ofByteArray(buf))\n-                                       .build();\n-            bodies.put(r, buf);\n-\n-            results[i] =\n-                limiter.whenOkToSend()\n-                       .thenCompose((v) -> {\n-                           System.out.println(\"Client: sendAsync: \" + r.uri());\n-                           return client.sendAsync(r, BodyHandlers.ofByteArray());\n-                       })\n-                       .thenCompose((resp) -> {\n-                           limiter.requestComplete();\n-                           if (resp.statusCode() != 200) {\n-                               String s = \"Expected 200, got: \" + resp.statusCode();\n-                               System.out.println(s + \" from \"\n-                                                  + resp.request().uri().getPath());\n-                               return completedWithIOException(s);\n-                           } else {\n-                               counter++;\n-                               System.out.println(\"Result (\" + counter + \") from \"\n-                                                   + resp.request().uri().getPath());\n-                           }\n-                           return CompletableFuture.completedStage(resp.body())\n-                                      .thenApply((b) -> new Pair<>(resp, b));\n-                       })\n-                      .thenAccept((pair) -> {\n-                          HttpRequest request = pair.t.request();\n-                          byte[] requestBody = bodies.get(request);\n-                          check(Arrays.equals(requestBody, pair.u),\n-                                \"bodies not equal:[\" + bytesToHexString(requestBody)\n-                                + \"] [\" + bytesToHexString(pair.u) + \"]\");\n-\n-                      });\n-        }\n+        \/\/ This loop implements a retry mechanism to work around an issue\n+        \/\/ on some systems (observed on Windows 10) that seem to be trying to\n+        \/\/ throttle the number of connections that can be made concurrently by\n+        \/\/ rejecting connection attempts.\n+        \/\/ On the first iteration of this loop, we will attempt 20 concurrent\n+        \/\/ requests. If this fails with ConnectException, we will retry the\n+        \/\/ 20 requests, but limiting the concurrency to 10 (LIMIT <- 10).\n+        \/\/ If this fails again, the test will fail.\n+        boolean done = false;\n+        LOOP: do {\n+            RequestLimiter limiter = new RequestLimiter(LIMIT.get());\n+            Random rand = RANDOM;\n+            CompletableFuture<?>[] results = new CompletableFuture<?>[REQUESTS];\n+            Map<HttpRequest,byte[]> bodies = new ConcurrentHashMap<>();\n+\n+            long start = System.nanoTime();\n+\n+            for (int i = 0; i < REQUESTS; i++) {\n+                byte[] buf = new byte[(i + 1) * CHUNK_SIZE + i + 1];  \/\/ different size bodies\n+                rand.nextBytes(buf);\n+                URI uri = new URI(baseURI.toString() + String.valueOf(i + 1));\n+                HttpRequest r = HttpRequest.newBuilder(uri)\n+                        .header(\"XFixed\", \"true\")\n+                        .POST(BodyPublishers.ofByteArray(buf))\n+                        .build();\n+                bodies.put(r, buf);\n+\n+                results[i] =\n+                        limiter.whenOkToSend()\n+                                .thenCompose((v) -> {\n+                                    System.out.println(\"Client: sendAsync: \" + r.uri());\n+                                    return client.sendAsync(r, BodyHandlers.ofByteArray());\n+                                })\n+                                .handle((resp, t) -> {\n+                                    limiter.requestComplete();\n+                                    CompletionStage<Pair<HttpResponse<byte[]>, byte[]>> res;\n+                                    String now = now(start);\n+                                    if (t == null) {\n+                                        if (resp.statusCode() != 200) {\n+                                            String s = \"Expected 200, got: \" + resp.statusCode();\n+                                            System.out.println(now + s + \" from \"\n+                                                    + resp.request().uri().getPath());\n+                                            res = completedWithIOException(s);\n+                                            return res;\n+                                        } else {\n+                                            int counter = COUNT.incrementAndGet();\n+                                            System.out.println(now + \"Result (\" + counter + \") from \"\n+                                                    + resp.request().uri().getPath());\n+                                        }\n+                                        res = CompletableFuture.completedStage(resp.body())\n+                                                .thenApply((b) -> new Pair<>(resp, b));\n+                                        return res;\n+                                    } else {\n+                                        int counter = COUNT.incrementAndGet();\n+                                        System.out.println(now + \"Result (\" + counter + \") from \"\n+                                                + r.uri().getPath()\n+                                                + failure(t));\n+                                        res = CompletableFuture.failedFuture(t);\n+                                        return res;\n+                                    }\n+                                })\n+                                .thenCompose(c -> c)\n+                                .thenAccept((pair) -> {\n+                                    HttpRequest request = pair.t.request();\n+                                    byte[] requestBody = bodies.get(request);\n+                                    check(Arrays.equals(requestBody, pair.u),\n+                                            \"bodies not equal:[\" + bytesToHexString(requestBody)\n+                                                    + \"] [\" + bytesToHexString(pair.u) + \"]\");\n+\n+                                });\n+            }\n+\n+            \/\/ wait for them all to complete and throw exception in case of err\n+            try {\n+                CompletableFuture.allOf(results).join();\n+                done = true;\n+            } catch (CompletionException e) {\n+                if (!Platform.isWindows()) throw e;\n+                if (LIMIT.get() < REQUESTS) throw e;\n+                Throwable cause = e;\n+                while ((cause = cause.getCause()) != null) {\n+                    if (cause instanceof ConnectException) {\n+                        \/\/ try again, limit concurrency by half\n+                        COUNT.set(0);\n+                        LIMIT.set(REQUESTS\/2);\n+                        System.out.println(\"*** Retrying due to \" + cause);\n+                        continue LOOP;\n+                    }\n+                }\n+                throw e;\n+            }\n+        } while (!done);\n@@ -183,2 +268,0 @@\n-        \/\/ wait for them all to complete and throw exception in case of error\n-        CompletableFuture.allOf(results).join();\n@@ -206,0 +289,3 @@\n+        private final T t;\n+        private final U u;\n+\n@@ -207,1 +293,2 @@\n-            this.t = t; this.u = u;\n+            this.t = t;\n+            this.u = u;\n@@ -209,2 +296,0 @@\n-        T t;\n-        U u;\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":144,"deletions":59,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,6 @@\n- * @run main\/othervm\/timeout=40 -Dtest.XFixed=true ManyRequests2\n- * @run main\/othervm\/timeout=40 -Dtest.XFixed=true -Dtest.insertDelay=true ManyRequests2\n- * @run main\/othervm\/timeout=40 -Dtest.XFixed=true -Dtest.chunkSize=64 ManyRequests2\n+ * @run main\/othervm\/timeout=40 -Dtest.XFixed=true\n+ *                              -Djdk.httpclient.HttpClient.log=channel ManyRequests2\n+ * @run main\/othervm\/timeout=40 -Dtest.XFixed=true -Dtest.insertDelay=true\n+ *                              -Djdk.httpclient.HttpClient.log=channel ManyRequests2\n+ * @run main\/othervm\/timeout=40 -Dtest.XFixed=true -Dtest.chunkSize=64\n+ *                              -Djdk.httpclient.HttpClient.log=channel ManyRequests2\n@@ -40,0 +43,1 @@\n+ *                              -Djdk.httpclient.HttpClient.log=channel\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests2.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+\n@@ -53,0 +54,1 @@\n+import java.net.ConnectException;\n@@ -57,0 +59,1 @@\n+import java.util.Map;\n@@ -59,0 +62,4 @@\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -76,0 +83,3 @@\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.RandomFactory;\n@@ -81,0 +91,6 @@\n+    static final int MAX_COUNT = 20;\n+    static final int MAX_LIMIT = 40;\n+    static final AtomicInteger COUNT = new AtomicInteger();\n+    static final AtomicInteger LIMIT = new AtomicInteger(MAX_LIMIT);\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n@@ -112,1 +128,1 @@\n-    static final int REQUESTS = 20;\n+    static final int REQUESTS = MAX_COUNT;\n@@ -196,1 +212,1 @@\n-        final Random rand = new Random();\n+        final Random rand = RANDOM;\n@@ -222,0 +238,16 @@\n+    static String now(long start) {\n+        long elapsed = System.nanoTime() - start;\n+        long ms = elapsed \/ 1000_000L;\n+        long s = ms \/ 1000L;\n+        if (s == 0) return ms + \"ms: \";\n+        return s + \"s, \" + (ms - s * 1000L) + \"ms: \";\n+    }\n+\n+    static String failure(Throwable t) {\n+        String s = \"\\n\\t failed: \" + t;\n+        for (t = t.getCause(); t != null ; t = t.getCause()) {\n+            s = s + \"\\n\\t\\t  Caused by: \" + t;\n+        }\n+        return s;\n+    }\n+\n@@ -228,45 +260,15 @@\n-        RequestLimiter limiter = new RequestLimiter(40);\n-        Random rand = new Random();\n-        CompletableFuture<?>[] results = new CompletableFuture<?>[REQUESTS];\n-        HashMap<HttpRequest,byte[]> bodies = new HashMap<>();\n-\n-        for (int i=0; i<REQUESTS; i++) {\n-            byte[] buf = new byte[(i+1)*CHUNK_SIZE+i+1];  \/\/ different size bodies\n-            rand.nextBytes(buf);\n-            URI uri = new URI(baseURI.toString() + String.valueOf(i+1));\n-            HttpRequest r = HttpRequest.newBuilder(uri)\n-                                       .header(\"XFixed\", \"true\")\n-                                       .POST(BodyPublishers.ofByteArray(buf))\n-                                       .build();\n-            bodies.put(r, buf);\n-\n-            results[i] =\n-                limiter.whenOkToSend()\n-                       .thenCompose((v) -> {\n-                           System.out.println(\"Client: sendAsync: \" + r.uri());\n-                           return client.sendAsync(r, buf);\n-                       })\n-                       .thenCompose((resp) -> {\n-                           limiter.requestComplete();\n-                           if (resp.statusCode() != 200) {\n-                               String s = \"Expected 200, got: \" + resp.statusCode();\n-                               System.out.println(s + \" from \"\n-                                                  + resp.request().uri().getPath());\n-                               return completedWithIOException(s);\n-                           } else {\n-                               counter++;\n-                               System.out.println(\"Result (\" + counter + \") from \"\n-                                                   + resp.request().uri().getPath());\n-                           }\n-                           return CompletableFuture.completedStage(resp.body())\n-                                      .thenApply((b) -> new Pair<>(resp, b));\n-                       })\n-                      .thenAccept((pair) -> {\n-                          HttpRequest request = pair.t.request();\n-                          byte[] requestBody = bodies.get(request);\n-                          check(Arrays.equals(requestBody, pair.u),\n-                                \"bodies not equal:[\" + bytesToHexString(requestBody)\n-                                + \"] [\" + bytesToHexString(pair.u) + \"]\");\n-\n-                      });\n-        }\n+        \/\/ This loop implements a retry mechanism to work around an issue\n+        \/\/ on some systems (observed on Windows 10) that seem to be trying to\n+        \/\/ throttle the number of connections that can be made concurrently by\n+        \/\/ rejecting connection attempts.\n+        \/\/ On the first iteration of this loop, we will attempt 20 concurrent\n+        \/\/ requests. If this fails with ConnectException, we will retry the\n+        \/\/ 20 requests, but limiting the concurrency to 10 (LIMIT <- 10).\n+        \/\/ If this fails again, the test will fail.\n+        boolean done = false;\n+        LOOP: do {\n+            RequestLimiter limiter = new RequestLimiter(LIMIT.get());\n+            Random rand = RANDOM;\n+            CompletableFuture<?>[] results = new CompletableFuture<?>[REQUESTS];\n+            Map<HttpRequest,byte[]> bodies = new ConcurrentHashMap<>();\n+            long start = System.nanoTime();\n@@ -274,2 +276,75 @@\n-        \/\/ wait for them all to complete and throw exception in case of error\n-        CompletableFuture.allOf(results).join();\n+            for (int i = 0; i < REQUESTS; i++) {\n+                byte[] buf = new byte[(i + 1) * CHUNK_SIZE + i + 1];  \/\/ different size bodies\n+                rand.nextBytes(buf);\n+                URI uri = new URI(baseURI.toString() + String.valueOf(i + 1));\n+                HttpRequest r = HttpRequest.newBuilder(uri)\n+                        .header(\"XFixed\", \"true\")\n+                        .POST(BodyPublishers.ofByteArray(buf))\n+                        .build();\n+                bodies.put(r, buf);\n+\n+                results[i] =\n+                        limiter.whenOkToSend()\n+                                .thenCompose((v) -> {\n+                                    System.out.println(\"Client: sendAsync: \" + r.uri());\n+                                    return client.sendAsync(r, buf);\n+                                })\n+                                .handle((resp, t) -> {\n+                                    limiter.requestComplete();\n+                                    CompletionStage<Pair<HttpResponse<byte[]>, byte[]>> res;\n+                                    String now = now(start);\n+                                    if (t == null) {\n+                                        if (resp.statusCode() != 200) {\n+                                            String s = \"Expected 200, got: \" + resp.statusCode();\n+                                            System.out.println(now + s + \" from \"\n+                                                    + resp.request().uri().getPath());\n+                                            res = completedWithIOException(s);\n+                                            return res;\n+                                        } else {\n+                                            int counter = COUNT.incrementAndGet();\n+                                            System.out.println(now + \"Result (\" + counter + \") from \"\n+                                                    + resp.request().uri().getPath());\n+                                        }\n+                                        res = CompletableFuture.completedStage(resp.body())\n+                                                .thenApply((b) -> new Pair<>(resp, b));\n+                                        return res;\n+                                    } else {\n+                                        int counter = COUNT.incrementAndGet();\n+                                        System.out.println(now + \"Result (\" + counter + \") from \"\n+                                                + r.uri().getPath()\n+                                                + failure(t));\n+                                        res = CompletableFuture.failedFuture(t);\n+                                        return res;\n+                                    }\n+                                })\n+                                .thenCompose(c -> c)\n+                                .thenAccept((pair) -> {\n+                                    HttpRequest request = pair.t.request();\n+                                    byte[] requestBody = bodies.get(request);\n+                                    check(Arrays.equals(requestBody, pair.u),\n+                                            \"bodies not equal:[\" + bytesToHexString(requestBody)\n+                                                    + \"] [\" + bytesToHexString(pair.u) + \"]\");\n+\n+                                });\n+            }\n+\n+            try {\n+                \/\/ wait for them all to complete and throw exception in case of error\n+                CompletableFuture.allOf(results).join();\n+                done = true;\n+            } catch (CompletionException e) {\n+                if (!Platform.isWindows()) throw e;\n+                if (LIMIT.get() < REQUESTS) throw e;\n+                Throwable cause = e;\n+                while ((cause = cause.getCause()) != null) {\n+                    if (cause instanceof ConnectException) {\n+                        \/\/ try again, limit concurrency by half\n+                        COUNT.set(0);\n+                        LIMIT.set(REQUESTS\/2);\n+                        System.out.println(\"*** Retrying due to \" + cause);\n+                        continue LOOP;\n+                    }\n+                }\n+                throw e;\n+            }\n+        } while (!done);\n@@ -297,0 +372,3 @@\n+        private final T t;\n+        private final U u;\n+\n@@ -298,1 +376,2 @@\n-            this.t = t; this.u = u;\n+            this.t = t;\n+            this.u = u;\n@@ -300,2 +379,0 @@\n-        T t;\n-        U u;\n@@ -304,0 +381,1 @@\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequestsLegacy.java","additions":131,"deletions":53,"binary":false,"changes":184,"status":"modified"}]}