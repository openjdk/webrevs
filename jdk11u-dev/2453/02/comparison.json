{"files":[{"patch":"@@ -60,3 +60,2 @@\n-        int port = findFreePort();\n-        try (Debuggee debuggee = Debuggee.launcher(\"ThrowCaughtException\").setAddress(\"localhost:\" + port)\n-                                         .enableOnThrow(\"Ex\", \"Start\").setSuspended(true).launch()) {\n+        try (Debuggee debuggee = Debuggee.launcher(\"ThrowCaughtException\")\n+                                         .enableOnThrow(\"Ex\").setSuspended(true).launch()) {\n@@ -65,1 +64,1 @@\n-                vm = attach(\"localhost\", \"\" + port);\n+                vm = attach(\"localhost\", debuggee.getAddress());\n@@ -114,8 +113,0 @@\n-    private static int findFreePort() {\n-        try (ServerSocket socket = new ServerSocket(0)) {\n-            return socket.getLocalPort();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpOnThrowTest.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.lib.util.Pair;\n@@ -35,0 +36,1 @@\n+import java.util.function.Function;\n@@ -68,0 +70,1 @@\n+        private String vmOptions = null;\n@@ -72,2 +75,1 @@\n-        private boolean waitForPortPrint = true;\n-        private String expectedOutputBeforeThrow = \"\";\n+        private static final String LAUNCH_ECHO_STRING = \"Listen Args:\";\n@@ -86,0 +88,4 @@\n+        public Launcher addVMOptions(String vmOptions) {\n+            this.vmOptions = vmOptions;\n+            return this;\n+        }\n@@ -102,5 +108,2 @@\n-        \/\/ required to pass non null port with address and emit string before the throw\n-        public Launcher enableOnThrow(String value, String expectedOutputBeforeThrow) {\n-            this.onthrow = value;\n-            this.waitForPortPrint = false;\n-            this.expectedOutputBeforeThrow = expectedOutputBeforeThrow;\n+        public Launcher enableOnThrow(String exceptionClassName) {\n+            this.onthrow = exceptionClassName;\n@@ -112,1 +115,4 @@\n-            String onthrowArgs = onthrow.isEmpty() ? \"\" : \",onthrow=\" + onthrow + \",launch=exit\";\n+            if (vmOptions != null) {\n+                debuggeeArgs.add(vmOptions);\n+            }\n+            String onthrowArgs = onthrow.isEmpty() ? \"\" : \",onthrow=\" + onthrow + \",launch=echo \" + LAUNCH_ECHO_STRING;\n@@ -123,1 +129,5 @@\n-            return new Debuggee(prepare(), name, waitForPortPrint, expectedOutputBeforeThrow);\n+            return new Debuggee(prepare(), name,\n+                onthrow.isEmpty() ?\n+                    Launcher::parseListenAddress :\n+                    Launcher::parseLaunchEchoListenAddress\n+            );\n@@ -128,1 +138,0 @@\n-    }\n@@ -130,12 +139,9 @@\n-    \/\/ starts the process, waits for \"Listening for transport\" output and detects transport\/address\n-    private Debuggee(ProcessBuilder pb, String name, boolean waitForPortPrint, String expectedOutputBeforeThrow) {\n-        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n-        String[] debuggeeListen = new String[2];\n-        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n-        if (!waitForPortPrint) {\n-            try {\n-                p = ProcessTools.startProcess(name, pb, s -> {output.add(s);}, s -> {\n-                    return s.equals(expectedOutputBeforeThrow);\n-                }, 30, TimeUnit.SECONDS);\n-            } catch (IOException | InterruptedException | TimeoutException ex) {\n-                throw new RuntimeException(\"failed to launch debuggee\", ex);\n+        \/**\n+         * Parses debuggee output to get listening transport and address, printed by `launch=echo`.\n+         * Returns null if the string specified does not contain required info.\n+         *\/\n+        private static Pair<String, String> parseLaunchEchoListenAddress(String debuggeeOutput) {\n+            Pattern listenRegexp = Pattern.compile(LAUNCH_ECHO_STRING + \" \\\\b(.+)\\\\b \\\\b(.+)\\\\b\");\n+            Matcher m = listenRegexp.matcher(debuggeeOutput);\n+            if (m.find()) {\n+                return new Pair<String, String>(m.group(1), m.group(2));\n@@ -143,3 +149,1 @@\n-            transport = null;\n-            address = null;\n-            return;\n+            return null;\n@@ -147,0 +151,18 @@\n+\n+        \/**\n+         * Parses debuggee output to get listening transport and address, printed by `launch=echo`.\n+         * Returns null if the string specified does not contain required info.\n+         *\/\n+        private static Pair<String, String> parseListenAddress(String debuggeeOutput) {\n+            Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+            Matcher m = listenRegexp.matcher(debuggeeOutput);\n+            if (m.find()) {\n+                return new Pair<String, String>(m.group(1), m.group(2));\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/\/ starts the process, waits until the provided addressDetector detects transport\/address from the process output\n+    private Debuggee(ProcessBuilder pb, String name, Function<String, Pair<String, String>> addressDetector) {\n+        String[] debuggeeListen = new String[2];\n@@ -150,4 +172,6 @@\n-                    s -> {  \/\/ warm-up predicate\n-                        Matcher m = listenRegexp.matcher(s);\n-                        if (!m.matches()) {\n-                            return false;\n+                    s -> {\n+                        Pair<String, String> addr = addressDetector.apply(s);\n+                        if (addr != null) {\n+                            debuggeeListen[0] = addr.first;\n+                            debuggeeListen[1] = addr.second;\n+                            return true;\n@@ -155,3 +179,1 @@\n-                        debuggeeListen[0] = m.group(1);\n-                        debuggeeListen[1] = m.group(2);\n-                        return true;\n+                        return false;\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":55,"deletions":33,"binary":false,"changes":88,"status":"modified"}]}