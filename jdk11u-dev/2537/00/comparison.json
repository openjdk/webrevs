{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- * @summary AsyncSSLSocketClose.java has timing issue\n+ * @summary AsyncSSLSocketClose.java has timing issue.\n+ * @library \/javax\/net\/ssl\/templates\n@@ -41,0 +42,1 @@\n+import java.util.Arrays;\n@@ -43,0 +45,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -44,1 +48,6 @@\n-public class BlockedAsyncClose implements Runnable {\n+\/*\n+ * To manually verify that the write thread was blocked when socket.close() is called,\n+ * run the test with -Djavax.net.debug=ssl. You should see the message\n+ * \"SSLSocket output duplex close failed: SO_LINGER timeout, close_notify message cannot be sent.\"\n+ *\/\n+public class BlockedAsyncClose extends SSLContextTemplate implements Runnable {\n@@ -50,6 +59,1 @@\n-\n-    \/\/ Where do we find the keystores?\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n+    private final Lock writeLock = new ReentrantLock();\n@@ -58,13 +62,1 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n-        new BlockedAsyncClose();\n+        new BlockedAsyncClose().runTest();\n@@ -73,3 +65,2 @@\n-    public BlockedAsyncClose() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-                (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();\n+    public void runTest() throws Exception {\n+        SSLServerSocketFactory sslssf = createServerSSLContext().getServerSocketFactory();\n@@ -80,2 +71,1 @@\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory)SSLSocketFactory.getDefault();\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -86,1 +76,1 @@\n-        (new Thread(this)).start();\n+        new Thread(this).start();\n@@ -97,1 +87,0 @@\n-        System.out.println(\"Calling Socket.close\");\n@@ -99,3 +88,5 @@\n-        \/\/ Sleep for a while so that the write thread blocks by hitting the\n-        \/\/ output stream buffer limit.\n-        Thread.sleep(1000);\n+        \/\/ if the writeLock is not released by the other thread within 10\n+        \/\/ seconds it is probably blocked, and we can try to close the socket\n+        while (writeLock.tryLock(10, TimeUnit.SECONDS)) {\n+            writeLock.unlock();\n+        }\n@@ -103,0 +94,1 @@\n+        System.out.println(\"Calling socket.close()\");\n@@ -104,1 +96,0 @@\n-        System.out.println(\"ssl socket get closed\");\n@@ -111,3 +102,1 @@\n-        for (int i = 0; i < ba.length; i++) {\n-            ba[i] = 0x7A;\n-        }\n+        Arrays.fill(ba, (byte) 0x7A);\n@@ -131,0 +120,1 @@\n+\n@@ -132,0 +122,2 @@\n+\n+                writeLock.lock();\n@@ -133,0 +125,5 @@\n+                \/\/ This isn't in a try\/finally. If an exception is thrown\n+                \/\/ and the lock is released, the main thread will\n+                \/\/ loop until the test times out. So don't release it.\n+                writeLock.unlock();\n+\n@@ -147,1 +144,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/BlockedAsyncClose.java","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"}]}