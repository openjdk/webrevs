{"files":[{"patch":"@@ -2860,1 +2860,1 @@\n-        if (!method.equals(\"HEAD\")) {\n+        if (!method.equals(\"HEAD\") || tunnelState == TunnelState.SETUP) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270290\n+ * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n+ * @run main\/othervm NTLMHeadTest SERVER\n+ * @run main\/othervm NTLMHeadTest PROXY\n+ * @run main\/othervm NTLMHeadTest TUNNEL\n+ * @summary test for the incorrect logic in reading (and discarding) HTTP\n+ *      response body when processing NTLMSSP_CHALLENGE response\n+ *      (to CONNECT request) from proxy server. When this response is received\n+ *      by client, reset() is called on the connection to read and discard the\n+ *      response body. This code path was broken when initial client request\n+ *      uses HEAD method and HTTPS resource, in this case CONNECT is sent to\n+ *      proxy server (to establish TLS tunnel) and response body is not read\n+ *      from a socket (because initial method on client connection is HEAD).\n+ *      This does not cause problems with the majority of proxy servers because\n+ *      InputStream opened over the response socket is buffered with 8kb buffer\n+ *      size. Problem is only reproducible if the response size (headers +\n+ *      body) is larger than 8kb. The code path with HTTPS tunneling is checked\n+ *      with TUNNEL argument. Additional checks for HEAD handling are included\n+ *      for direct server (SERVER) and HTTP proxying (PROXY) code paths, in\n+ *      these (non-tunnel) cases client must NOT attempt to read response data\n+ *      (to not block on socket read) because HEAD is sent to server and\n+ *      NTLMSSP_CHALLENGE response includes Content-Length, but does not\n+ *      include the body.\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.util.*;\n+import sun.net.www.MessageHeader;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class NTLMHeadTest {\n+\n+    enum Mode { SERVER, PROXY, TUNNEL }\n+\n+    static final int BODY_LEN = 8192;\n+\n+    static final String RESP_SERVER_AUTH =\n+            \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+            \"WWW-Authenticate: NTLM\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_SERVER_NTLM =\n+            \"HTTP\/1.1 401 Unauthorized\\r\\n\" +\n+            \"WWW-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==\\r\\n\" +\n+            \"Connection: Keep-Alive\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_SERVER_OR_PROXY_DEST =\n+            \"HTTP\/1.1 200 OK\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: 42\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_PROXY_AUTH =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM\\r\\n\" +\n+            \"Proxy-Connection: close\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_PROXY_NTLM =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==\\r\\n\" +\n+            \"Proxy-Connection: Keep-Alive\\r\\n\" +\n+            \"Connection: Keep-Alive\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\";\n+\n+    static final String RESP_TUNNEL_AUTH =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM\\r\\n\" +\n+            \"Proxy-Connection: close\\r\\n\" +\n+            \"Connection: close\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\" +\n+            generateBody(BODY_LEN);\n+\n+    static final String RESP_TUNNEL_NTLM =\n+            \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+            \"Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==\\r\\n\" +\n+            \"Proxy-Connection: Keep-Alive\\r\\n\" +\n+            \"Connection: Keep-Alive\\r\\n\" +\n+            \"Content-Length: \" + BODY_LEN + \"\\r\\n\" +\n+            \"\\r\\n\" +\n+            generateBody(BODY_LEN);\n+\n+    static final String RESP_TUNNEL_ESTABLISHED =\n+            \"HTTP\/1.1 200 Connection Established\\r\\n\\r\\n\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Authenticator.setDefault(new TestAuthenticator());\n+        if (1 != args.length) {\n+            throw new IllegalArgumentException(\"Mode value must be specified, one of: [SERVER, PROXY, TUNNEL]\");\n+        }\n+        Mode mode = Mode.valueOf(args[0]);\n+        System.out.println(\"Running with mode: \" + mode);\n+        switch (mode) {\n+            case SERVER: testSever(); return;\n+            case PROXY: testProxy(); return;\n+            case TUNNEL: testTunnel(); return;\n+            default: throw new IllegalArgumentException(\"Invalid mode: \" + mode);\n+        }\n+    }\n+\n+    static void testSever() throws Exception {\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, InetAddress.getLoopbackAddress()), Mode.SERVER)) {\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getLocalPort())\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n+            uc.setRequestMethod(\"HEAD\");\n+            uc.getInputStream().readAllBytes();\n+        }\n+    }\n+\n+    static void testProxy() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, loopback), Mode.PROXY)) {\n+            SocketAddress proxyAddr = new InetSocketAddress(loopback, server.getLocalPort());\n+            Proxy proxy = new Proxy(java.net.Proxy.Type.HTTP, proxyAddr);\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(8080)\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection(proxy);\n+            uc.setRequestMethod(\"HEAD\");\n+            uc.getInputStream().readAllBytes();\n+        }\n+    }\n+\n+    static void testTunnel() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try (NTLMServer server = startServer(new ServerSocket(0, 0, loopback), Mode.TUNNEL)) {\n+            SocketAddress proxyAddr = new InetSocketAddress(loopback, server.getLocalPort());\n+            Proxy proxy = new Proxy(java.net.Proxy.Type.HTTP, proxyAddr);\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(8443)\n+                    .path(\"\/\")\n+                    .toURLUnchecked();\n+            HttpURLConnection uc = (HttpURLConnection) url.openConnection(proxy);\n+            uc.setRequestMethod(\"HEAD\");\n+            try {\n+                uc.getInputStream().readAllBytes();\n+            } catch (IOException e) {\n+                \/\/ can be SocketException or SSLHandshakeException\n+                \/\/ Tunnel established and closed by server\n+                System.out.println(\"Tunnel established successfully\");\n+            } catch (NoSuchElementException e) {\n+                System.err.println(\"Error: cannot read 200 response code\");\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static class NTLMServer extends Thread implements AutoCloseable {\n+        final ServerSocket ss;\n+        final Mode mode;\n+        volatile boolean closed;\n+\n+        NTLMServer(ServerSocket serverSS, Mode mode) {\n+            super();\n+            setDaemon(true);\n+            this.ss = serverSS;\n+            this.mode = mode;\n+        }\n+\n+        int getLocalPort() { return ss.getLocalPort(); }\n+\n+        @Override\n+        public void run() {\n+            boolean doing2ndStageNTLM = false;\n+            while (!closed) {\n+                try {\n+                    Socket s = ss.accept();\n+                    InputStream is = s.getInputStream();\n+                    OutputStream os = s.getOutputStream();\n+                    switch(mode) {\n+                        case SERVER:\n+                            doServer(is, os, doing2ndStageNTLM);\n+                            break;\n+                        case PROXY:\n+                            doProxy(is, os, doing2ndStageNTLM);\n+                            break;\n+                        case TUNNEL:\n+                            doTunnel(is, os, doing2ndStageNTLM);\n+                            break;\n+                        default: throw new IllegalArgumentException();\n+                    }\n+                    if (!doing2ndStageNTLM) {\n+                        doing2ndStageNTLM = true;\n+                    } else {\n+                        os.close();\n+                    }\n+                } catch (IOException ioe) {\n+                    if (!closed) {\n+                        ioe.printStackTrace();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+           if (closed) return;\n+           synchronized(this) {\n+               if (closed) return;\n+               closed = true;\n+           }\n+           try { ss.close(); } catch (IOException x) { };\n+        }\n+    }\n+\n+    static NTLMServer startServer(ServerSocket serverSS, Mode mode) {\n+        NTLMServer server = new NTLMServer(serverSS, mode);\n+        server.start();\n+        return server;\n+    }\n+\n+    static String generateBody(int length) {\n+        StringBuilder sb = new StringBuilder();\n+        for(int i = 0; i < length; i++) {\n+            sb.append(i % 10);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static void doServer(InputStream is, OutputStream os, boolean doing2ndStageNTLM) throws IOException {\n+        if (!doing2ndStageNTLM) {\n+            new MessageHeader(is);\n+            os.write(RESP_SERVER_AUTH.getBytes(\"ASCII\"));\n+        } else {\n+            new MessageHeader(is);\n+            os.write(RESP_SERVER_NTLM.getBytes(\"ASCII\"));\n+            new MessageHeader(is);\n+            os.write(RESP_SERVER_OR_PROXY_DEST.getBytes(\"ASCII\"));\n+        }\n+    }\n+\n+    static void doProxy(InputStream is, OutputStream os, boolean doing2ndStageNTLM) throws IOException {\n+        if (!doing2ndStageNTLM) {\n+            new MessageHeader(is);\n+            os.write(RESP_PROXY_AUTH.getBytes(\"ASCII\"));\n+        } else {\n+            new MessageHeader(is);\n+            os.write(RESP_PROXY_NTLM.getBytes(\"ASCII\"));\n+            new MessageHeader(is);\n+            os.write(RESP_SERVER_OR_PROXY_DEST.getBytes(\"ASCII\"));\n+        }\n+    }\n+\n+    static void doTunnel(InputStream is, OutputStream os, boolean doing2ndStageNTLM) throws IOException {\n+        if (!doing2ndStageNTLM) {\n+            new MessageHeader(is);\n+            os.write(RESP_TUNNEL_AUTH.getBytes(\"ASCII\"));\n+        } else {\n+            new MessageHeader(is);\n+            os.write(RESP_TUNNEL_NTLM.getBytes(\"ASCII\"));\n+            new MessageHeader(is);\n+            os.write(RESP_TUNNEL_ESTABLISHED.getBytes(\"ASCII\"));\n+        }\n+    }\n+\n+    static class TestAuthenticator extends java.net.Authenticator {\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(\"test\", \"secret\".toCharArray());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NTLMHeadTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"}]}