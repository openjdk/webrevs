{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,1 @@\n-import javax.swing.*;\n-import javax.swing.border.*;\n-import javax.swing.plaf.*;\n-import javax.swing.plaf.basic.BasicBorders;\n-import javax.swing.text.JTextComponent;\n-\n-import java.awt.Component;\n-import java.awt.Insets;\n+import java.awt.BasicStroke;\n@@ -37,0 +30,1 @@\n+import java.awt.Component;\n@@ -40,0 +34,3 @@\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Stroke;\n@@ -41,0 +38,26 @@\n+import java.awt.geom.AffineTransform;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonModel;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JOptionPane;\n+import javax.swing.JScrollPane;\n+import javax.swing.JToolBar;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.border.AbstractBorder;\n+import javax.swing.border.Border;\n+import javax.swing.border.CompoundBorder;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.LineBorder;\n+import javax.swing.border.MatteBorder;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicBorders;\n+import javax.swing.text.JTextComponent;\n@@ -45,1 +68,0 @@\n-\n@@ -206,1 +228,13 @@\n-        private static final int corner = 14;\n+        private static final int CORNER = 14;\n+\n+        \/**\n+         * Rounds a double to the nearest integer. It rounds 0.5 down,\n+         * for example 1.5 is rounded to 1.0.\n+         *\n+         * @param d number to be rounded\n+         * @return the rounded value\n+         *\/\n+        private static int roundHalfDown(double d) {\n+            double decP = (Math.ceil(d) - d);\n+            return (int)((decP == 0.5) ?  Math.floor(d) :  Math.round(d));\n+        }\n@@ -209,1 +243,1 @@\n-                          int w, int h) {\n+                                int w, int h) {\n@@ -225,35 +259,87 @@\n-              g.setColor(background);\n-              \/\/ Draw outermost lines\n-              g.drawLine( 1, 0, w-2, 0);\n-              g.drawLine( 0, 1, 0, h-2);\n-              g.drawLine( w-1, 1, w-1, h-2);\n-              g.drawLine( 1, h-1, w-2, h-1);\n-\n-              \/\/ Draw the bulk of the border\n-              for (int i = 1; i < 5; i++) {\n-                  g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-              }\n-\n-              if (c instanceof JInternalFrame &&\n-                               ((JInternalFrame)c).isResizable()) {\n-                  g.setColor(highlight);\n-                  \/\/ Draw the Long highlight lines\n-                  g.drawLine( corner+1, 3, w-corner, 3);\n-                  g.drawLine( 3, corner+1, 3, h-corner);\n-                  g.drawLine( w-2, corner+1, w-2, h-corner);\n-                  g.drawLine( corner+1, h-2, w-corner, h-2);\n-\n-                  g.setColor(shadow);\n-                  \/\/ Draw the Long shadow lines\n-                  g.drawLine( corner, 2, w-corner-1, 2);\n-                  g.drawLine( 2, corner, 2, h-corner-1);\n-                  g.drawLine( w-3, corner, w-3, h-corner-1);\n-                  g.drawLine( corner, h-3, w-corner-1, h-3);\n-              }\n-\n-          }\n-\n-          public Insets getBorderInsets(Component c, Insets newInsets) {\n-              newInsets.set(5, 5, 5, 5);\n-              return newInsets;\n-          }\n+            Graphics2D g2d = (Graphics2D) g;\n+            AffineTransform at = g2d.getTransform();\n+            Stroke oldStk = g2d.getStroke();\n+            Color oldColor = g2d.getColor();\n+            int stkWidth = 1;\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n+            \/\/ skip resetting the transform\n+            boolean resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0));\n+\n+            int xtranslation;\n+            int ytranslation;\n+            int width;\n+            int height;\n+\n+            if (resetTransform) {\n+                g2d.setTransform(new AffineTransform());\n+                stkWidth = roundHalfDown(Math.min(at.getScaleX(), at.getScaleY()));\n+\n+                double xx = at.getScaleX() * x + at.getTranslateX();\n+                double yy = at.getScaleY() * y + at.getTranslateY();\n+                xtranslation = roundHalfDown(xx);\n+                ytranslation = roundHalfDown(yy);\n+                width = roundHalfDown(at.getScaleX() * w + xx) - xtranslation;\n+                height = roundHalfDown(at.getScaleY() * h + yy) - ytranslation;\n+            } else {\n+                width = w;\n+                height = h;\n+                xtranslation = x;\n+                ytranslation = y;\n+            }\n+            g2d.translate(xtranslation, ytranslation);\n+\n+            \/\/ scaled border\n+            int thickness = (int) Math.ceil(4 * at.getScaleX());\n+\n+            g.setColor(background);\n+            \/\/ Draw the bulk of the border\n+            for (int i = 0; i <= thickness; i++) {\n+                g.drawRect(i, i, width - (i * 2), height - (i * 2));\n+            }\n+\n+            if (c instanceof JInternalFrame && ((JInternalFrame)c).isResizable()) {\n+                \/\/ set new stroke to draw shadow and highlight lines\n+                g2d.setStroke(new BasicStroke((float) stkWidth));\n+\n+                \/\/ midpoint at which highlight & shadow lines\n+                \/\/ are positioned on the border\n+                int midPoint = thickness \/ 2;\n+                int offset = ((at.getScaleX() - stkWidth) >= 0 && stkWidth % 2 != 0) ? 1 : 0;\n+                int loc1 = thickness % 2 == 0 ? midPoint + stkWidth \/ 2 - stkWidth : midPoint;\n+                int loc2 = thickness % 2 == 0 ? midPoint + stkWidth \/ 2 : midPoint + stkWidth;\n+                \/\/ scaled corner\n+                int corner = (int) Math.round(CORNER * at.getScaleX());\n+\n+                \/\/ Draw the Long highlight lines\n+                g.setColor(highlight);\n+                g.drawLine(corner + 1, loc2, width - corner, loc2); \/\/top\n+                g.drawLine(loc2, corner + 1, loc2, height - corner); \/\/left\n+                g.drawLine((width - offset) - loc1, corner + 1,\n+                        (width - offset) - loc1, height - corner); \/\/right\n+                g.drawLine(corner + 1, (height - offset) - loc1,\n+                        width - corner, (height - offset) - loc1); \/\/bottom\n+\n+                \/\/ Draw the Long shadow lines\n+                g.setColor(shadow);\n+                g.drawLine(corner, loc1, width - corner - 1, loc1);\n+                g.drawLine(loc1, corner, loc1, height - corner - 1);\n+                g.drawLine((width - offset) - loc2, corner,\n+                        (width - offset) - loc2, height - corner - 1);\n+                g.drawLine(corner, (height - offset) - loc2,\n+                        width - corner - 1, (height - offset) - loc2);\n+            }\n+\n+            \/\/ restore previous transform\n+            g2d.translate(-xtranslation, -ytranslation);\n+            if (resetTransform) {\n+                g2d.setColor(oldColor);\n+                g2d.setTransform(at);\n+                g2d.setStroke(oldStk);\n+            }\n+        }\n+\n+        public Insets getBorderInsets(Component c, Insets newInsets) {\n+            newInsets.set(4, 4, 4, 4);\n+            return newInsets;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":133,"deletions":47,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.GridBagLayout;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.MultiResolutionImage;\n+import java.awt.image.RenderedImage;\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8015739\n+ * @key headful\n+ * @summary Tests whether background color of JInternalFrame is visible\n+ * in the border region at different scales by checking the midpoints\n+ * and corners of the border.\n+ *\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.25 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.5 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.75 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2.5 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=3 InternalFrameBorderTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015739\n+ * @key headful\n+ * @summary Tests whether background color of JInternalFrame is visible\n+ * in the border region at different scales by checking the midpoints\n+ * and corners of the border.\n+ *\n+ * @requires (os.family == \"mac\" | os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n+ *\/\n+\n+public class InternalFrameBorderTest {\n+    private static final int FRAME_SIZE = 300;\n+    private static final int INTFRAME_SIZE = 150;\n+    private static final int MIDPOINT = INTFRAME_SIZE \/ 2;\n+    private static final int BORDER_THICKNESS = 4;\n+\n+    private static final StringBuffer errorLog = new StringBuffer();\n+\n+    private static JFrame jFrame;\n+    private static Rectangle jFrameBounds;\n+    private static JInternalFrame iFrame;\n+    private static Point iFrameLoc;\n+    private static int iFrameMaxX;\n+    private static int iFrameMaxY;\n+\n+    private static Robot robot;\n+    private static String uiScale;\n+\n+    public static void main(String[] args) throws AWTException,\n+            InterruptedException, InvocationTargetException {\n+        try {\n+            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+        } catch (Exception e) {\n+            System.out.println(\"Metal LAF class not supported\");\n+            return;\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(200);\n+            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n+\n+            SwingUtilities.invokeAndWait(InternalFrameBorderTest::createAndShowGUI);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                iFrameLoc = iFrame.getLocationOnScreen();\n+                iFrameMaxX = iFrameLoc.x + INTFRAME_SIZE;\n+                iFrameMaxY = iFrameLoc.y + INTFRAME_SIZE;\n+                jFrameBounds = jFrame.getBounds();\n+            });\n+\n+            \/\/ Check Borders\n+            checkBorderMidPoints(\"TOP\");\n+            checkBorderMidPoints(\"RIGHT\");\n+            checkBorderMidPoints(\"BOTTOM\");\n+            checkBorderMidPoints(\"LEFT\");\n+\n+            \/\/ Check Corner Diagonals\n+            checkCorners(\"TOP_LEFT\");\n+            checkCorners(\"TOP_RIGHT\");\n+            checkCorners(\"BOTTOM_RIGHT\");\n+            checkCorners(\"BOTTOM_LEFT\");\n+\n+            if (errorLog.length() != 0) {\n+                saveScreenCapture(\"JIF_uiScale_\" + uiScale + \".png\");\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+        } finally {\n+            if (jFrame != null) {\n+                jFrame.dispose();\n+            }\n+            robot.delay(500);\n+        }\n+    }\n+\n+    private static void checkBorderMidPoints(String borderDirection) {\n+        int x, y;\n+        int start, stop;\n+\n+        switch (borderDirection) {\n+            case \"TOP\": {\n+                x = iFrameLoc.x + MIDPOINT;\n+                y = iFrameLoc.y + BORDER_THICKNESS;\n+                start = iFrameLoc.y;\n+                stop = iFrameLoc.y + BORDER_THICKNESS - 1;\n+            } break;\n+            case \"RIGHT\": {\n+                x = iFrameMaxX - BORDER_THICKNESS;\n+                y = iFrameLoc.y + MIDPOINT;\n+                start = iFrameMaxX - BORDER_THICKNESS + 1;\n+                stop = iFrameMaxX;\n+            } break;\n+            case \"BOTTOM\": {\n+                x = iFrameLoc.x + MIDPOINT;\n+                y = iFrameMaxY - BORDER_THICKNESS;\n+                start = iFrameMaxY - BORDER_THICKNESS + 1;\n+                stop = iFrameMaxY;\n+            } break;\n+            case \"LEFT\": {\n+                x = iFrameLoc.x;\n+                y = iFrameLoc.y + MIDPOINT;\n+                start = iFrameLoc.x;\n+                stop = iFrameLoc.x + BORDER_THICKNESS - 1;\n+            } break;\n+            default: throw new IllegalStateException(\"Unexpected value: \"\n+                    + borderDirection);\n+        }\n+\n+        boolean isVertical = borderDirection.equals(\"RIGHT\")\n+                || borderDirection.equals(\"LEFT\");\n+        boolean isHorizontal = borderDirection.equals(\"TOP\")\n+                || borderDirection.equals(\"BOTTOM\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = start; i < stop; i++) {\n+            int locX = isVertical ? i : (iFrameLoc.x + MIDPOINT);\n+            int locY = isHorizontal ? i : (iFrameLoc.y + MIDPOINT);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale\n+                        + \", Red background color detected at \"\n+                        + borderDirection + \" border.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(300);\n+    }\n+\n+    private static void checkCorners(String cornerLocation) {\n+        int x, y;\n+\n+        switch (cornerLocation) {\n+            case \"TOP_LEFT\": {\n+                x = iFrameLoc.x;\n+                y = iFrameLoc.y;\n+            } break;\n+            case \"TOP_RIGHT\": {\n+                x = iFrameMaxX;\n+                y = iFrameLoc.y;\n+            } break;\n+            case \"BOTTOM_RIGHT\": {\n+                x = iFrameMaxX;\n+                y = iFrameMaxY;\n+            } break;\n+            case \"BOTTOM_LEFT\": {\n+                x = iFrameLoc.x;\n+                y = iFrameMaxY;\n+            } break;\n+            default: throw new IllegalStateException(\"Unexpected value: \"\n+                    + cornerLocation);\n+        }\n+\n+        boolean isTop = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"TOP_RIGHT\");\n+        boolean isLeft = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"BOTTOM_LEFT\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = 0; i < BORDER_THICKNESS - 1; i++) {\n+            int locX = isLeft ? (x + i) : (x - i);\n+            int locY = isTop ? (y + i) : (y - i);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale + \", Red background color\"\n+                        + \" detected at \" + cornerLocation + \" corner.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(300);\n+    }\n+\n+    private static void createAndShowGUI() {\n+        jFrame = new JFrame();\n+        jFrame.setSize(FRAME_SIZE, FRAME_SIZE);\n+        jFrame.setLayout(null);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+\n+        JLabel scale = new JLabel(\"UI Scale: \" + uiScale);\n+        iFrame = new JInternalFrame(\"iframe\", true);\n+        iFrame.setLayout(new GridBagLayout());\n+        iFrame.setBackground(Color.RED);\n+        iFrame.add(scale);\n+        iFrame.setLocation(30, 30);\n+        jFrame.getContentPane().add(iFrame);\n+        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n+        iFrame.setVisible(true);\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture(String filename) {\n+        MultiResolutionImage mrImage = robot.createMultiResolutionScreenCapture(jFrameBounds);\n+        List<Image> variants = mrImage.getResolutionVariants();\n+        RenderedImage image = (RenderedImage) variants.get(variants.size() - 1);\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/InternalFrameBorderTest.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"}]}