{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -900,0 +900,10 @@\n+\n+    \/**\n+     * Returns the value of 'finish' flag.\n+     * 'finish' will be set to true if def.finish() method is called.\n+     *\/\n+    boolean shouldFinish() {\n+        synchronized (zsRef) {\n+            return finish;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,9 @@\n-            def.finish();\n-            while (!def.finished()) {\n-                deflate();\n+            try{\n+                def.finish();\n+                while (!def.finished()) {\n+                    deflate();\n+                }\n+            } catch(IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,1 @@\n-                if (usesDefaultDeflater && !(e instanceof ZipException))\n+                if (def.shouldFinish() && usesDefaultDeflater && !(e instanceof ZipException))\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8193682\n- * @summary Test Infinite loop while writing on closed GZipOutputStream , ZipOutputStream and JarOutputStream.\n- * @run testng CloseDeflaterTest\n- *\/\n-import java.io.*;\n-import java.util.Random;\n-import java.util.jar.JarOutputStream;\n-import java.util.zip.GZIPOutputStream;\n-import java.util.zip.ZipOutputStream;\n-import java.util.zip.ZipEntry;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.fail;\n-\n-\n-public class CloseDeflaterTest {\n-\n-    \/\/number of bytes to write\n-    private static final int INPUT_LENGTH= 512;\n-    \/\/OutputStream that will throw an exception during a write operation\n-    private static OutputStream outStream = new OutputStream() {\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            \/\/throw exception during write\n-            throw new IOException();\n-        }\n-        @Override\n-        public void write(byte b[]) throws IOException {}\n-        @Override\n-        public void write(int b) throws IOException {}\n-    };\n-    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n-    private static Random rand = new Random();\n-\n-    @DataProvider(name = \"testgzipinput\")\n-    public Object[][] testGZipInput() {\n-     \/\/testGZip will close the GZipOutputStream using close() method when the boolean\n-     \/\/useCloseMethod is set to true and finish() method if the value is set to false\n-     return new Object[][] {\n-      { GZIPOutputStream.class, true },\n-      { GZIPOutputStream.class, false },\n-     };\n-    }\n-\n-    @DataProvider(name = \"testzipjarinput\")\n-    public Object[][] testZipAndJarInput() {\n-     \/\/testZipAndJarInput will perfrom write\/closeEntry operations on JarOutputStream when the boolean\n-     \/\/useJar is set to true and on ZipOutputStream if the value is set to false\n-     return new Object[][] {\n-      { JarOutputStream.class, true },\n-      { ZipOutputStream.class, false },\n-     };\n-    }\n-\n-    @BeforeTest\n-    public void before_test()\n-    {\n-       \/\/add inputBytes array with random bytes to write into Zip\n-       rand.nextBytes(inputBytes);\n-    }\n-\n-    \/\/Test for infinite loop by writing bytes to closed GZIPOutputStream\n-    @Test(dataProvider = \"testgzipinput\")\n-    public void testGZip(Class<?> type, boolean useCloseMethod) throws IOException {\n-        GZIPOutputStream zip = new GZIPOutputStream(outStream);\n-        try {\n-            zip.write(inputBytes, 0, INPUT_LENGTH);\n-            \/\/close zip\n-            if(useCloseMethod) {\n-               zip.close();\n-            } else {\n-               zip.finish();\n-            }\n-        } catch (IOException e) {\n-            \/\/expected\n-        }\n-        for (int i = 0; i < 3; i++) {\n-            try {\n-                \/\/write on a closed GZIPOutputStream\n-                zip.write(inputBytes, 0, INPUT_LENGTH);\n-                fail(\"Deflater closed exception not thrown\");\n-            } catch (NullPointerException e) {\n-                \/\/expected , Deflater has been closed exception\n-            }\n-        }\n-    }\n-\n-    \/\/Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n-    @Test(dataProvider = \"testzipjarinput\")\n-    public void testZipCloseEntry(Class<?> type,boolean useJar) throws IOException {\n-        ZipOutputStream zip = null;\n-        if(useJar) {\n-           zip = new JarOutputStream(outStream);\n-        } else {\n-           zip = new ZipOutputStream(outStream);\n-        }\n-        try {\n-            zip.putNextEntry(new ZipEntry(\"\"));\n-        } catch (IOException e) {\n-            \/\/expected to throw IOException since putNextEntry calls write method\n-        }\n-        try {\n-            zip.write(inputBytes, 0, INPUT_LENGTH);\n-            \/\/close zip entry\n-            zip.closeEntry();\n-        } catch (IOException e) {\n-            \/\/expected\n-        }\n-        for (int i = 0; i < 3; i++) {\n-            try {\n-                \/\/write on a closed ZipOutputStream\n-                zip.write(inputBytes, 0, INPUT_LENGTH);\n-                fail(\"Deflater closed exception not thrown\");\n-            } catch (NullPointerException e) {\n-                \/\/expected , Deflater has been closed exception\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/zip\/CloseDeflaterTest.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193682 8278794\n+ * @summary Test Infinite loop while writing on closed Deflater and Inflater.\n+ * @run testng CloseInflaterDeflaterTest\n+ *\/\n+import java.io.*;\n+import java.util.Random;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.InflaterOutputStream;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\n+public class CloseInflaterDeflaterTest {\n+\n+    \/\/ Number of bytes to write\/read from Deflater\/Inflater\n+    private static final int INPUT_LENGTH= 512;\n+    \/\/ OutputStream that will throw an exception during a write operation\n+    private static OutputStream outStream = new OutputStream() {\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public void write(byte[] b) throws IOException {}\n+        @Override\n+        public void write(int b) throws IOException {}\n+    };\n+    \/\/ InputStream that will throw an exception during a read operation\n+    private static InputStream inStream = new InputStream() {\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public int read(byte[] b) throws IOException { throw new IOException();}\n+        @Override\n+        public int read() throws IOException { throw new IOException();}\n+    };\n+    \/\/ Input bytes for read\/write operation\n+    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n+    \/\/ Random function to add bytes to inputBytes\n+    private static Random rand = new Random();\n+\n+    \/**\n+     * DataProvider to specify whether to use close() or finish() of OutputStream\n+     *\n+     * @return Entry object indicating which method to use for closing OutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testOutputStreams() {\n+     return new Object[][] {\n+      { true },\n+      { false },\n+     };\n+    }\n+\n+    \/**\n+     * DataProvider to specify on which outputstream closeEntry() has to be called\n+     *\n+     * @return Entry object returning either JarOutputStream or ZipOutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testZipAndJar() throws IOException{\n+     return new Object[][] {\n+      { new JarOutputStream(outStream)},\n+      { new ZipOutputStream(outStream)},\n+     };\n+    }\n+\n+    \/**\n+     * Add inputBytes array with random bytes to write into OutputStream\n+     *\/\n+    @BeforeTest\n+    public void before_test()\n+    {\n+       rand.nextBytes(inputBytes);\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed GZIPOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testGZip(boolean useCloseMethod) throws IOException {\n+        GZIPOutputStream gzip = new GZIPOutputStream(outStream);\n+        gzip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close GZIPOutputStream\n+            if (useCloseMethod) {\n+                gzip.close();\n+            } else {\n+                gzip.finish();\n+            }\n+        });\n+        \/\/ Write on a closed GZIPOutputStream, closed Deflater IOException expected\n+        assertThrows(NullPointerException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed DeflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testDeflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        DeflaterOutputStream def = new DeflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close DeflaterOutputStream\n+            if (useCloseMethod) {\n+                def.close();\n+            } else {\n+                def.finish();\n+            }\n+        });\n+        \/\/ Write on a closed DeflaterOutputStream, 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by reading bytes from closed DeflaterInputStream\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testDeflaterInputStream() throws IOException {\n+        DeflaterInputStream def = new DeflaterInputStream(inStream);\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Close DeflaterInputStream\n+        def.close();\n+        \/\/ Read from a closed DeflaterInputStream, closed Deflater IOException expected\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed InflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testInflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        InflaterOutputStream inf = new InflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class , () -> {\n+            \/\/ Close InflaterOutputStream\n+            if (useCloseMethod) {\n+                inf.close();\n+            } else {\n+                inf.finish();\n+            }\n+        });\n+        \/\/ Write on a closed InflaterOutputStream , closed Inflater IOException expected\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n+     *\n+     * @param zip will be the instance of either JarOutputStream or ZipOutputStream\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testZipAndJar\")\n+    public void testZipCloseEntry(ZipOutputStream zip) throws IOException {\n+        assertThrows(IOException.class , () -> zip.putNextEntry(new ZipEntry(\"\")));\n+        zip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class , () -> zip.closeEntry());\n+        \/\/ Write on a closed ZipOutputStream , 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CloseInflaterDeflaterTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"}]}