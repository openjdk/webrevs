{"files":[{"patch":"@@ -4341,2 +4341,2 @@\n-          Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);\n-          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);\n+          \/\/ Clones are always tightly coupled.\n+          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -289,2 +289,3 @@\n-  Node* original_dest      = dest;\n-  bool  dest_uninitialized = false;\n+  Node* original_dest = dest;\n+  bool  dest_needs_zeroing   = false;\n+  bool  acopy_to_uninitialized = false;\n@@ -302,14 +303,22 @@\n-      && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0\n-      && alloc->maybe_set_complete(&_igvn)) {\n-    \/\/ \"You break it, you buy it.\"\n-    InitializeNode* init = alloc->initialization();\n-    assert(init->is_complete(), \"we just did this\");\n-    init->set_complete_with_arraycopy();\n-    assert(dest->is_CheckCastPP(), \"sanity\");\n-    assert(dest->in(0)->in(0) == init, \"dest pinned\");\n-    adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n-    \/\/ From this point on, every exit path is responsible for\n-    \/\/ initializing any non-copied parts of the object to zero.\n-    \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n-    \/\/ with G1, eliding pre-barriers. See CR 6627983.\n-    dest_uninitialized = true;\n+      && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0) {\n+    assert(ac->is_alloc_tightly_coupled(), \"sanity\");\n+    \/\/ acopy to uninitialized tightly coupled allocations\n+    \/\/ needs zeroing outside the copy range\n+    \/\/ and the acopy itself will be to uninitialized memory\n+    acopy_to_uninitialized = true;\n+    if (alloc->maybe_set_complete(&_igvn)) {\n+      \/\/ \"You break it, you buy it.\"\n+      InitializeNode* init = alloc->initialization();\n+      assert(init->is_complete(), \"we just did this\");\n+      init->set_complete_with_arraycopy();\n+      assert(dest->is_CheckCastPP(), \"sanity\");\n+      assert(dest->in(0)->in(0) == init, \"dest pinned\");\n+      adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n+      \/\/ From this point on, every exit path is responsible for\n+      \/\/ initializing any non-copied parts of the object to zero.\n+      \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n+      \/\/ with G1, eliding pre-barriers. See CR 6627983.\n+      dest_needs_zeroing = true;\n+    } else {\n+      \/\/ dest_need_zeroing = false;\n+    }\n@@ -317,4 +326,5 @@\n-    \/\/ No zeroing elimination here.\n-    alloc             = NULL;\n-    \/\/original_dest   = dest;\n-    \/\/dest_uninitialized = false;\n+    \/\/ No zeroing elimination needed here.\n+    alloc                  = NULL;\n+    acopy_to_uninitialized = false;\n+    \/\/original_dest        = dest;\n+    \/\/dest_needs_zeroing   = false;\n@@ -354,1 +364,1 @@\n-    assert(!dest_uninitialized, \"\");\n+    assert(!dest_needs_zeroing, \"\");\n@@ -358,1 +368,1 @@\n-                                          copy_length, dest_uninitialized);\n+                                          copy_length, acopy_to_uninitialized);\n@@ -379,1 +389,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n@@ -414,1 +424,1 @@\n-  if (!(*ctrl)->is_top() && dest_uninitialized) {\n+  if (!(*ctrl)->is_top() && dest_needs_zeroing) {\n@@ -455,1 +465,1 @@\n-                                         dest_size, dest_uninitialized);\n+                                         dest_size, acopy_to_uninitialized);\n@@ -543,1 +553,1 @@\n-                                                ConvI2X(copy_length), dest_uninitialized);\n+                                                ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -571,1 +581,1 @@\n-                                 ConvI2X(copy_length), dest_uninitialized);\n+                                 ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -660,1 +670,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -555,2 +555,2 @@\n-#define RETURN_STUB_PARM(xxx_arraycopy, parm) {           \\\n-  name = #xxx_arraycopy; \\\n+#define RETURN_STUB_PARM(xxx_arraycopy, parm) { \\\n+  name = parm ? #xxx_arraycopy \"_uninit\": #xxx_arraycopy; \\\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}