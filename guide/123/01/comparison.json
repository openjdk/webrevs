{"files":[{"patch":"@@ -10,1 +10,1 @@\n-Development of the latest version of the JDK often results in bug fixes that might be interesting to include in some of the JDK update releases still being maintained or in a feature release stabilization repository. Moving a fix from a more recent release train (e.g. JDK 21) to an older release train (e.g. JDK 17) is called *backporting*.\n+Development of the latest version of the JDK often results in bug fixes that might be interesting to include in some of the JDK Update releases still being maintained or in a feature release stabilization branch. Moving a fix from a more recent release train (e.g. JDK 21) to an older release train (e.g. JDK 17) is called *backporting*.\n@@ -18,1 +18,1 @@\n-## Backporting to a feature release stabilization repository\n+## Backporting to a feature release stabilization branch\n@@ -20,1 +20,1 @@\n-During rampdown of a feature release there are two repositories in play, the release stabilization repository for the outgoing release, and the mainline repository where the next release is being developed. Any change going into the release stabilization repository is likely to be desired in mainline as well. When making a change intended both for the stabilization release and the mainline repository, you should always create your pull request targeting the mainline repository first, and then, once the pull request is integrated, backport the resulting commit to the release stabilization repository. For bugfixes that are **only** applicable to the release stabilization repository, regular pull requests targeting the stabilization fork should be created.\n+During ramp down of a feature release there are two branches of the mainline repository in play, the release stabilization branch for the outgoing release, and the `master` branch where the next release is being developed. Any change going into the release stabilization branch is likely to be desired in `master` as well. When making a change intended for both the stabilization branch and `master`, you should always create your pull request targeting `master` first, and then, once the pull request is integrated, backport the resulting commit to the release stabilization branch. For bug fixes that are **only** applicable to the release stabilization branch, regular pull requests targeting the stabilization branch should be created.\n@@ -22,1 +22,1 @@\n-Please note that special rules applies during rampdown regarding what can and can't be included into the rampdown repository. See the [The JDK Release Process] for more information.\n+Please note that special rules applies during ramp down regarding what can and can't be included into the stabilization branch. See the [The JDK Release Process] for more information.\n@@ -47,1 +47,1 @@\n-Obviously it's possible to set the [Fix Version\/s]{.jbs-field} to the exact release the backport is targeting, but in general this isn't recommended unless you are targeting a feature release in rampdown. When a change is pushed to an update release repository, the bots will look at the main issue as indicated in the PR title, and look for backports with the current `N.0.x` release version as [Fix Version\/s]{.jbs-field}, if no such backport is found they will look for `N-pool`, and if that isn't found either, a new backport issue will be created. This means that if the backport has an exact [Fix Version\/s]{.jbs-field} set, but is delayed and misses the release indicated by this [Fix Version\/s]{.jbs-field}, a new backport issue is created with a small mess as the result. (See [How to fix an incorrect backport creation in JBS].)\n+Obviously it's possible to set the [Fix Version\/s]{.jbs-field} to the exact release the backport is targeting, but in general this isn't recommended unless you are targeting a feature release in ramp down. When a change is pushed to an update release repository, the bots will look at the main issue as indicated in the PR title, and look for backports with the current `N.0.x` release version as [Fix Version\/s]{.jbs-field}, if no such backport is found they will look for `N-pool`, and if that isn't found either, a new backport issue will be created. This means that if the backport has an exact [Fix Version\/s]{.jbs-field} set, but is delayed and misses the release indicated by this [Fix Version\/s]{.jbs-field}, a new backport issue is created with a small mess as the result. (See [How to fix an incorrect backport creation in JBS].)\n@@ -55,1 +55,1 @@\n-If the update release is in rampdown, changes are pushed to the release repository (e.g. [`jdk17u`](https:\/\/github.com\/openjdk\/jdk17u)). During rampdown the bar to get changes in are significantly higher and fixes need to be approved with [jdk&lt;release&gt;u-critical-request]{.jbs-label} \/ [jdk&lt;release&gt;u-critical-yes]{.jbs-label}.\n+If the update release is in ramp down, changes are pushed to the release repository (e.g. [`jdk17u`](https:\/\/github.com\/openjdk\/jdk17u)). During ramp down the bar to get changes in is significantly higher and fixes need to be approved with [jdk&lt;release&gt;u-critical-request]{.jbs-label} \/ [jdk&lt;release&gt;u-critical-yes]{.jbs-label}.\n@@ -61,1 +61,1 @@\n-The Skara tooling includes support for backports. [The official Skara documentation](https:\/\/wiki.openjdk.org\/display\/SKARA\/Backports) describes in detail how to work with the tooling to create backport PRs on GitHub or using the CLI tools. As described in the documentation, the [`\/backport`](https:\/\/wiki.openjdk.org\/display\/SKARA\/Commit+Commands#CommitCommands-\/backport) command can be used on a commit or a PR to create the backport PR. If a backport PR is manually created, set the PR title to `Backport <original commit hash>`. This ensures that the bots will recognize it as a backport as opposed to a main fix specifically targeting an older release. One can tell whether or not the bots recognized a PR as a backport by the [backport]{.label} label being added if it's recognized.\n+The Skara tooling includes support for backports. [The official Skara documentation](https:\/\/wiki.openjdk.org\/display\/SKARA\/Backports) describes in detail how to work with the tooling to create backport PRs on [GitHub](https:\/\/github.com) or using the CLI tools. As described in the documentation, the [`\/backport`](https:\/\/wiki.openjdk.org\/display\/SKARA\/Commit+Commands#CommitCommands-\/backport) command can be used on a commit or a PR to create the backport PR. If a backport PR is manually created, set the PR title to `Backport <original commit hash>`. This ensures that the bots will recognize it as a backport as opposed to a main fix specifically targeting an older release. One can tell whether or not the bots recognized a PR as a backport by the [backport]{.label} label being added if it's recognized.\n@@ -65,1 +65,1 @@\n-If an issue is targeted to a release and a fix referring to that issue is pushed to a different release repository, then a backport issue is automatically created in JBS. Usually this is a \"good thing\", e.g., when you are backporting a fix to an earlier release, but not always... If the main issue is targeted to a later release (due to schedule planning) but someone finds the time to fix that issue in the current release, or if the main issue is targeted to a feature release in rampdown and the fix is pushed to the mainline repository, then the issue should be retargeted to the correct release before pushing the fix. However, sometimes we forget.\n+If an issue is targeted to a release and a fix referring to that issue is pushed to a different release repository, then a backport issue is automatically created in JBS. Usually this is a \"good thing\", e.g., when you are backporting a fix to an earlier release, but not always... If the main issue is targeted to a later release (due to schedule planning) but someone finds the time to fix that issue in the current release, or if the main issue is targeted to a feature release in ramp down and the fix is pushed to the master branch, then the issue should be retargeted to the correct release before pushing the fix. However, sometimes we forget.\n@@ -70,1 +70,1 @@\n-In this example a fix was pushed to JDK N+1 (the mainline repository) while the JBS bug was targeted to JDK N (a feature release in rampdown). The same procedure can be used in the opposite situation, when a fix has been pushed to JDK N when the JBS bug was targeted to JDK N+1, by switching N and N+1 below. Remember, to keep the record clean for the future, what matters the most is that the **bug id used in the commit comment is the main bug**, and that **the \"backports\"** (regardless of if they are to earlier or later releases) **are Backport type issues of that main issue**. Also make sure there are never more than one Backport issue of the same main issue targeted to any given release.\n+In this example a fix was pushed to JDK N+1 (the mainline master branch) while the JBS bug was targeted to JDK N (a feature release in ramp down). The same procedure can be used in the opposite situation, when a fix has been pushed to JDK N when the JBS bug was targeted to JDK N+1, by switching N and N+1 below. Remember, to keep the record clean for the future, what matters the most is that the **bug id used in the commit comment is the main bug**, and that **the \"backports\"** (regardless of if they are to earlier or later releases) **are Backport type issues of that main issue**. Also make sure there are never more than one Backport issue of the same main issue targeted to any given release.\n@@ -96,1 +96,1 @@\n-   * Resolve the _main_ issue as [Fixed]{.jbs-value} in build \"team\" or in build \"master\" depending on where the fix was pushed - or to an actual build number if the change has already made it to a promoted build (look in the _backport_ issue if you are unsure). Pushes to 'openjdk\/jdk' are fixed in build \"master\" and pushes to project repositories are fixed in build \"team\".\n+   * Resolve the _main_ issue as [Fixed]{.jbs-value} in build \"team\" or in build \"master\" depending on where the fix was pushed - or to an actual build number if the change has already made it to a promoted build (look in the _backport_ issue if you are unsure). Pushes to 'openjdk\/jdk' are fixed in build \"master\" and pushes to Project repositories are fixed in build \"team\".\n","filename":"src\/guide\/backporting.md","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+## Working with git branches\n+\n@@ -52,0 +54,4 @@\n+If you intend to work on a backport to a feature release stabilization branch, your new local branch should of course be based on the stabilization branch instead of `master`.\n+\n+    $ git switch -c JDK-8272373 origin\/jdk23u\n+\n","filename":"src\/guide\/cloning-the-jdk.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-   :   Submission of a CSR request is required. The CSR must be [approved] before the bug fix is pushed to a feature release or update release repository. The work may begin concurrently with the CSR review, but may need to be modified in response to CSR feedback.\n+   :   Submission of a CSR request is required. The CSR must be [approved](#approved) before the bug fix is pushed to a feature release or update release repository. The work may begin concurrently with the CSR review, but may need to be modified in response to CSR feedback.\n@@ -43,1 +43,1 @@\n-#. [**Is it possible to write a test to detect the bug?**]\n+#. **Is it possible to write a test to detect the bug?**\n","filename":"src\/guide\/fixing-a-bug.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,1 +597,1 @@\n-<\/td>\n+    <\/td>\n@@ -658,1 +658,1 @@\n-<\/td>\n+    <\/td>\n","filename":"src\/guide\/jbs-jdk-bug-system.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-\n","filename":"src\/guide\/release-notes.md","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-* **Code review**: ProblemListing a test is considered a [trivial] change.\n+* **Code review**: ProblemListing a test is considered a [trivial](#trivial) change.\n@@ -301,1 +301,1 @@\n-The backout is a regular change and will have to go through the standard code review process, but is considered a [trivial] change. The rationale is that a backout is usually urgent in nature and the change itself is automatically generated. In areas where two reviewers are normally required, only one additional Reviewer is required for a backout since the person who is performing the backout also will review the change.\n+The backout is a regular change and will have to go through the standard code review process, but is considered a [trivial](#trivial) change. The rationale is that a backout is usually urgent in nature and the change itself is automatically generated. In areas where two reviewers are normally required, only one additional Reviewer is required for a backout since the person who is performing the backout also will review the change.\n","filename":"src\/guide\/testing-the-jdk.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-The JDK project has a well defined release process. [JEP 3](https:\/\/openjdk.org\/jeps\/3) describes this process in detail. This section intends to clarify some topics that often cause questions.\n+The JDK Project has a well defined release process. [JEP 3](https:\/\/openjdk.org\/jeps\/3) describes this process in detail. This section intends to clarify some topics that often cause questions.\n@@ -13,1 +13,1 @@\n-The release cycle starts when development of a new release begins, and ends when that release is delivered to the public. The current release cadence is six months. This means that every six months we start development of a new release, and every six months a new release is delivered. However, this doesn't mean that each release cycle is six months. As described below, the total development time for a release (the release cycle) is actually nine months. Obviously this in turn doesn't mean that all features are developed in nine months. Most features are developed for a much longer time than that, and goes through long time development in other project repositories, and through a series of preview and experimental stages. But any feature that is to be included in a specific release has a specific window of nine months to integrate the code into mainline and fix all the remaining bugs.\n+The release cycle starts when development of a new release begins, and ends when that release is delivered to the public. The current release cadence is six months. This means that every six months we start development of a new release, and every six months a new release is delivered. However, this doesn't mean that each release cycle is six months. As described below, the total development time for a release (the release cycle) is actually nine months. Obviously this in turn doesn't mean that all features are developed in nine months. Most features are developed for a much longer time than that, and goes through long time development in other Project repositories, and through a series of preview and experimental stages. But any feature that is to be included in a specific release has a specific window of nine months to integrate the code into mainline and fix all the remaining bugs.\n@@ -17,1 +17,1 @@\n-Integrating early in a release is preferable, but all new features can't be integrated at the same time. If many large changes enters the repository at the same time it will be more difficult to determine which change that caused all the new bugs. If you're about to integrate a larger change you must therefore communicate this on the relevant [mailing lists] to synchronize with other projects that may also be planning to integrate something soon.\n+Integrating early in a release is preferable, but all new features can't be integrated at the same time. If many large changes enters the repository at the same time it will be more difficult to determine which change that caused all the new bugs. If you're about to integrate a larger change you must therefore communicate this on the relevant [mailing lists] to synchronize with other Projects that may also be planning to integrate something soon.\n@@ -24,1 +24,1 @@\n-:    Since development is always ongoing in the mainline repository ([openjdk\/jdk](https:\/\/github.com\/openjdk\/jdk)), the start of a new release can be said to be when the former release is forked from mainline. After the start of the release follows six months of development to implement and integrate all the cool stuff that will go into the next release. After these six months ramp down begins.\n+:    Since development is always ongoing in the master branch of the mainline repository ([openjdk\/jdk](https:\/\/github.com\/openjdk\/jdk)), the start of a new release can be said to be when the former release is branched for stabilization. After the start of the release follows six months of development to implement and integrate all the cool stuff that will go into the next release. After these six months ramp down begins.\n@@ -27,1 +27,1 @@\n-:    The ramp down of a release starts with a fork of the mainline repository. A clone of the entire code base is made and hosted in a separate ramp down repository (e.g. [openjdk\/jdk17](https:\/\/github.com\/openjdk\/jdk17)). During the ramp down of a release we focus on bug fixing and stabilization in order to get the JDK ready for release. In RDP1 you may continue to fix P1-P3 product bugs (and some other issues) in the stabilization repo. For detailed information on what can be fixed when, see [Push or defer during rampdown] below. The start of RDP1 is essentially the deadline for integrating JEPs and enhancements into this particular release.\n+:    The ramp down of a release starts with a new branch being created (the stabilization branch) from the master branch in the mainline repository. During the ramp down of a release we focus on bug fixing and stabilization in order to get the JDK ready for release. In RDP1 you may continue to fix P1-P3 product bugs (and some other issues) in the stabilization branch. For detailed information on what can be fixed when, see [Push or defer during ramp down] below. The start of RDP1 is essentially the deadline for integrating JEPs and enhancements into a particular release.\n@@ -33,1 +33,1 @@\n-:    In RDP2 the bar is higher to get changes into the release. For product bugs, only P1:s and P2:s are supposed to be fixed here, and to do so an approval is needed. See the [Fix-Request Process](https:\/\/openjdk.org\/jeps\/3#Fix-Request-Process) for details on how to obtain one. All other product bugs should be deferred. See [Push or defer during rampdown] below for more details.\n+:    In RDP2 the bar is higher to get changes into the release. For product bugs, only P1:s and P2:s are supposed to be fixed here, and to do so an approval is needed. See the [Fix-Request Process](https:\/\/openjdk.org\/jeps\/3#Fix-Request-Process) for details on how to obtain one. All other product bugs should be deferred. See [Push or defer during ramp down] below for more details.\n@@ -41,1 +41,1 @@\n-### Push or defer during rampdown\n+### Push or defer during ramp down\n@@ -45,1 +45,1 @@\n-![Push and defer guidelines during rampdown](push-defer.png)\n+![Push and defer guidelines during ramp down](push-defer.png)\n","filename":"src\/guide\/the-jdk-release-process.md","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+Most changes are made to the `master` branch of the mainline repository. In these cases, rebase using:\n+\n@@ -29,0 +31,2 @@\n+Note that if you are working on a backport to a stabilization branch you should replace `master` above with the name of the branch you are targeting. This would be the same name as when you cloned the branch.\n+\n@@ -93,1 +97,1 @@\n-   If your PR is out for review for a longer time it's a good habit to pull from the target repository regularly to keep the change up to date. This will make it easier to review the change and it will help you find issues caused by other changes sooner. Typically this involves fetching changes from the master branch of the main JDK repo, merging them into your local branch, resolving conflicts if necessary, and then pushing these changes to the PR branch. Pushing additional commits and merges into the PR branch is fine; they will be squashed into a single commit when the PR is integrated. Avoid rebasing changes, and prefer merging instead.\n+   If your PR is out for review for a longer time it's a good habit to pull from the target repository regularly to keep the change up to date. This will make it easier to review the change and it will help you find issues caused by other changes sooner. Typically this involves fetching changes from the `master` branch of the main JDK repo, merging them into your local branch, resolving conflicts if necessary, and then pushing these changes to the PR branch. Pushing additional commits and merges into the PR branch is fine; they will be squashed into a single commit when the PR is integrated. Avoid rebasing changes, and prefer merging instead.\n@@ -96,0 +100,1 @@\n+   If your PR is targeting some other branch than `master`, make sure to merge the correct upstream branch (the target branch). Verify that your PR doesn't include changes from some other branch (e.g. `master`) that aren't supposed to be there.\n@@ -103,1 +108,1 @@\n-   After you have integrated your change you are expected to stay around in case there are any issues with it. As mentioned above, you are expected to have run all relevant testing on your change before creating your PR, but regardless of how thorough you test it, things might slip through. After your change has been integrated an automatic pipeline of tests is triggered and your change will be tested on a variety of platforms and in a variety of different modes that the JDK can be executed in. A change that causes failures in this testing may be backed out if a fix can't be provided fast enough, or if the developer isn't responsive when noticed about the failure. Note that this directive should be interpreted as \"it's a really bad idea to push a change the last thing you do before bedtime, or the day before going on vacation\".\n+   After you have integrated your change you are expected to stay around in case there are any issues with it. As mentioned above, you are expected to have run all relevant testing on your change before integrating your PR, but regardless of how thorough you test it, things might slip through. After your change has been integrated an automatic pipeline of tests is triggered and your change will be tested on a variety of platforms and in a variety of different modes that the JDK can be executed in. A change that causes failures in this testing may be backed out if a fix can't be provided fast enough, or if the developer isn't responsive when noticed about the failure. Note that this directive should be interpreted as \"it's a really bad idea to push a change the last thing you do before bedtime, or the day before going on vacation\".\n","filename":"src\/guide\/working-with-pull-requests.md","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-Some Projects may recommend additional tools or scripts that help with repository manipulation and code development. For instance, in JDK 8u, the utility script `common\/bin\/hgforest.sh` may be used to apply commands to all the repositories in the [forest]. Some useful Mercurial extensions for OpenJDK developers are [jcheck](https:\/\/openjdk.org\/projects\/code-tools\/jcheck\/), [trees](https:\/\/openjdk.org\/projects\/code-tools\/trees\/), and [Mercurial Queues](http:\/\/hgbook.red-bean.com\/read\/managing-change-with-mercurial-queues.html) (mq). Note that `trees` is enabled on the OpenJDK Mercurial server.\n+Some Projects may recommend additional tools or scripts that help with repository manipulation and code development. For instance, in JDK 8u, the utility script `common\/bin\/hgforest.sh` may be used to apply commands to all the repositories in the forest. Some useful Mercurial extensions for OpenJDK developers are [jcheck](https:\/\/openjdk.org\/projects\/code-tools\/jcheck\/), [trees](https:\/\/openjdk.org\/projects\/code-tools\/trees\/), and [Mercurial Queues](http:\/\/hgbook.red-bean.com\/read\/managing-change-with-mercurial-queues.html) (mq). Note that `trees` is enabled on the OpenJDK Mercurial server.\n","filename":"src\/guide\/working-with-the-legacy-mercurial-servers.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}