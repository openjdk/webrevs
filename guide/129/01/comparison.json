{"files":[{"patch":"@@ -30,1 +30,1 @@\n-* A [GitHub](https:\/\/github.com) project is a different thing. --- Not an OpenJDK Project, however GitHub is a keyword and has is therefore correctly capitalized and has it's own link. If we were writing about a specific GitHub project then a link to that project would be appropriate.\n+* A [GitHub](https:\/\/github.com) project is a different thing. --- Not an OpenJDK Project, however GitHub is a keyword and is therefore correctly capitalized and has it's own link. If we were writing about a specific GitHub project then a link to that project would be appropriate.\n","filename":"README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,10 @@\n+## Backporting multiple related changes\n+\n+When backporting a number of changes that are dependent on each other, like a change with a tail of bug fixes, it can sometimes seem attractive to merge all those commits into a single change to avoid backporting a broken change. Please don't. The general recommendation is to backport each commit individually. There are several reasons for this recommendation.\n+\n+If, for instance, there are other changes between the original one and the followup fix(es) there may be a dependency on other changes that are unrelated to the issue itself. By merging the original change, the fix(es), and the unrelated changes to meet the dependency, a single very different change is created. It's unlikely that this change will match the description in the single JBS issue used for the merged backport. Backporting each commit individually will preserve the git history and make it easy to figure out what has actually been backported.\n+\n+Testing each individual change is more likely to find issues than just testing the single merged change. It's also easier and less error prone to use the `\/backport` command on each commit instead of manually cherrypick and deal with the merges etc.\n+\n+And finally, if backporting each commit individually, the JBS records will clearly indicate that the followup changes have been backported as well. This is important as there is tooling that verifies that everything is done in the right way. That tooling will be confused if it can't deduct from JBS what has happened.\n+\n@@ -29,1 +39,1 @@\n-Main issue - The top issue in a backport hierarchy. Eg. [JDK-8272373](https:\/\/bugs.openjdk.org\/browse\/JDK-8272373) is a main issue, while [JDK-8277498](https:\/\/bugs.openjdk.org\/browse\/JDK-8277498) and [JDK-8277499](https:\/\/bugs.openjdk.org\/browse\/JDK-8277499) are backport issues of this main issue.\n+Main issue - The top issue in a backport hierarchy. Eg. [JDK-8272373](https:\/\/bugs.openjdk.org\/browse\/JDK-8272373) is a _main issue_, while [JDK-8277498](https:\/\/bugs.openjdk.org\/browse\/JDK-8277498) and [JDK-8277499](https:\/\/bugs.openjdk.org\/browse\/JDK-8277499) are _backport issues_ of this main issue.\n@@ -38,2 +48,2 @@\n-  main --> |backport| backport1\n-  main --> |backport| backport2\n+  main --> |backport to JDK 17| backport1\n+  main --> |backport to JDK 11| backport2\n@@ -47,1 +57,1 @@\n-Obviously it's possible to set the [Fix Version\/s]{.jbs-field} to the exact release the backport is targeting, but in general this isn't recommended unless you are targeting a feature release in ramp down. When a change is pushed to an update release repository, the bots will look at the main issue as indicated in the PR title, and look for backports with the current `N.0.x` release version as [Fix Version\/s]{.jbs-field}, if no such backport is found they will look for `N-pool`, and if that isn't found either, a new backport issue will be created. This means that if the backport has an exact [Fix Version\/s]{.jbs-field} set, but is delayed and misses the release indicated by this [Fix Version\/s]{.jbs-field}, a new backport issue is created with a small mess as the result. (See [How to fix an incorrect backport creation in JBS].)\n+Obviously it's possible to set the [Fix Version\/s]{.jbs-field} to the exact release the backport is targeting, but in general this isn't recommended unless you are targeting a feature release in ramp down. When a change is integrated to an update release repository, the bots will look at the main issue as indicated in the PR title, and look for backports with the current `N.0.x` release version as [Fix Version\/s]{.jbs-field}, if no such backport is found they will look for `N-pool`, and if that isn't found either, a new backport issue will be created. This means that if the backport has an exact [Fix Version\/s]{.jbs-field} set, but is delayed and misses the release indicated by this [Fix Version\/s]{.jbs-field}, a new, superfluous backport issue is created with a small mess as the result. (See [How to fix an incorrect backport creation in JBS].)\n@@ -53,1 +63,1 @@\n-In order to be allowed to push a change to one of the OpenJDK update development repositories (e.g. [`jdk17u-dev`](https:\/\/github.com\/openjdk\/jdk17u-dev)), an approval is required. The [official process for how to request push approval for a backport](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) describes in detail how to work with JBS when requesting approvals. In short, there's a label [jdk&lt;release&gt;u-fix-request]{.jbs-label} that should be added to the main JBS issue. Also put a motivation as to why the issue needs to be backported as a comment in the main issue. Once the label and motivation has been added, wait for the maintainers of the release to approve your request. The approval will be indicated with a label, [jdk&lt;release&gt;u-fix-yes]{.jbs-label}, added to the main issue.\n+In order to be allowed to integrate a change to one of the OpenJDK update development repositories (e.g. [`jdk17u-dev`](https:\/\/github.com\/openjdk\/jdk17u-dev)), an approval is required. The [official process for how to request push approval for a backport](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) describes in detail how to work with JBS when requesting approvals. In short, there's a label [jdk&lt;release&gt;u-fix-request]{.jbs-label} that should be added to the main JBS issue. Also put a motivation as to why the issue needs to be backported as a comment in the main issue. Once the label and motivation has been added, wait for the maintainers of the release to approve your request. The approval will be indicated with a label, [jdk&lt;release&gt;u-fix-yes]{.jbs-label}, added to the main issue.\n@@ -55,1 +65,1 @@\n-If the update release is in ramp down, changes are pushed to the release repository (e.g. [`jdk17u`](https:\/\/github.com\/openjdk\/jdk17u)). During ramp down the bar to get changes in is significantly higher and fixes need to be approved with [jdk&lt;release&gt;u-critical-request]{.jbs-label} \/ [jdk&lt;release&gt;u-critical-yes]{.jbs-label}.\n+If the update release is in ramp down, changes are integrated to the release repository (e.g. [`jdk17u`](https:\/\/github.com\/openjdk\/jdk17u)). During ramp down the bar to get changes in is significantly higher and fixes need to be approved with [jdk&lt;release&gt;u-critical-request]{.jbs-label} \/ [jdk&lt;release&gt;u-critical-yes]{.jbs-label}.\n@@ -75,1 +85,1 @@\n-If an issue is targeted to a release and a fix referring to that issue is pushed to a different release repository, then a backport issue is automatically created in JBS. Usually this is a \"good thing\", e.g., when you are backporting a fix to an earlier release, but not always... If the main issue is targeted to a later release (due to schedule planning) but someone finds the time to fix that issue in the current release, or if the main issue is targeted to a feature release in ramp down and the fix is pushed to the master branch, then the issue should be retargeted to the correct release before pushing the fix. However, sometimes we forget.\n+If an issue is targeted to a release and a fix referring to that issue is integrated to a different release repository, then a backport issue is automatically created in JBS. Usually this is a \"good thing\", e.g., when you are backporting a fix to an earlier release, but not always... If the main issue is targeted to a later release (due to schedule planning) but someone finds the time to fix that issue in the current release, or if the main issue is targeted to a feature release in ramp down and the fix is integrated to the master branch, then the issue should be retargeted to the correct release before integrating the fix. However, sometimes we forget.\n@@ -80,1 +90,1 @@\n-In this example a fix was pushed to JDK N+1 (the mainline master branch) while the JBS bug was targeted to JDK N (a feature release in ramp down). The same procedure can be used in the opposite situation, when a fix has been pushed to JDK N when the JBS bug was targeted to JDK N+1, by switching N and N+1 below. Remember, to keep the record clean for the future, what matters the most is that the **bug id used in the commit comment is the main bug**, and that **the \"backports\"** (regardless of if they are to earlier or later releases) **are Backport type issues of that main issue**. Also make sure there are never more than one Backport issue of the same main issue targeted to any given release.\n+In this example a fix was integrated to JDK N+1 (the mainline master branch) while the JBS bug was targeted to JDK N (a feature release in ramp down). The same procedure can be used in the opposite situation, when a fix has been integrated to JDK N when the JBS bug was targeted to JDK N+1, by switching N and N+1 below. Remember, to keep the record clean for the future, what matters the most is that the **bug id used in the commit comment is the main bug**, and that **the \"backports\"** (regardless of if they are to earlier or later releases) **are Backport type issues of that main issue**. Also make sure there are never more than one Backport issue of the same main issue targeted to any given release.\n@@ -86,1 +96,1 @@\n-Fix was pushed while main issue was targeted to 'N'. Reset the main issue to fixed in 'N+1', reset this issue to fix in 'na' and closed as Not An Issue to avoid confusion.\n+Fix was integrated while main issue was targeted to 'N'. Reset the main issue to fixed in 'N+1', reset this issue to fix in 'na' and closed as Not An Issue to avoid confusion.\n@@ -103,1 +113,1 @@\n-Fix was pushed to 'N+1' while this main issue was targeted to 'N'. Reset this issue to fixed in 'N+1' and copied the Robo Duke entry here.\n+Fix was integrated to 'N+1' while this main issue was targeted to 'N'. Reset this issue to fixed in 'N+1' and copied the Robo Duke entry here.\n@@ -106,1 +116,1 @@\n-   * Resolve the _main_ issue as [Fixed]{.jbs-value} in build \"team\" or in build \"master\" depending on where the fix was pushed - or to an actual build number if the change has already made it to a promoted build (look in the _backport_ issue if you are unsure). Pushes to 'openjdk\/jdk' are fixed in build \"master\" and pushes to Project repositories are fixed in build \"team\".\n+   * Resolve the _main_ issue as [Fixed]{.jbs-value} in build \"team\" or in build \"master\" depending on where the fix was integrated - or to an actual build number if the change has already made it to a promoted build (look in the _backport_ issue if you are unsure). Integrations to 'openjdk\/jdk' are fixed in build \"master\" and integrations to other Project repositories are fixed in build \"team\".\n","filename":"src\/guide\/backporting.md","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -788,6 +788,0 @@\n-  <tr>\n-    <td class=\"dictionary\">[[vthreads]{.jbs-label}]{#vthreads}<\/td>\n-    <td class=\"dictionary\">\n-      Used to identify an issue in the virtual thread implementation.\n-    <\/td>\n-  <\/tr>\n","filename":"src\/guide\/jbs-jdk-bug-system.md","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}