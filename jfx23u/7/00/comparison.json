{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+#define MEDIA_FORMAT_DEBUG 0\n@@ -209,2 +210,5 @@\n-    decoder->pColorConvert = NULL;\n-    decoder->pColorConvertOutput = NULL;\n+    for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+    {\n+        decoder->pColorConvert[i] = NULL;\n+        decoder->pColorConvertOutput[i] = NULL;\n+    }\n@@ -219,0 +223,4 @@\n+\n+    decoder->defaultStride = 0;\n+    decoder->pixel_num = 0;\n+    decoder->pixel_den = 0;\n@@ -228,2 +236,5 @@\n-    SafeRelease(&decoder->pColorConvertOutput);\n-    SafeRelease(&decoder->pColorConvert);\n+    for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+    {\n+        SafeRelease(&decoder->pColorConvertOutput[i]);\n+        SafeRelease(&decoder->pColorConvert[i]);\n+    }\n@@ -360,0 +371,59 @@\n+#if MEDIA_FORMAT_DEBUG\n+static void mfwrapper_print_media_format(GUID format)\n+{\n+    if (IsEqualGUID(format, MFVideoFormat_I420))\n+        g_print(\"JFXMEDIA MFVideoFormat_I420\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_IYUV))\n+        g_print(\"JFXMEDIA MFVideoFormat_IYUV\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_NV12))\n+        g_print(\"JFXMEDIA MFVideoFormat_NV12\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_YUY2))\n+        g_print(\"JFXMEDIA MFVideoFormat_YUY2\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_YV12))\n+        g_print(\"JFXMEDIA MFVideoFormat_YV12\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_P010))\n+        g_print(\"JFXMEDIA MFVideoFormat_P010\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_ARGB32))\n+        g_print(\"JFXMEDIA MFVideoFormat_ARGB32\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_RGB32))\n+        g_print(\"JFXMEDIA MFVideoFormat_RGB32\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_A2R10G10B10))\n+        g_print(\"JFXMEDIA MFVideoFormat_A2R10G10B10\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_A16B16G16R16F))\n+        g_print(\"JFXMEDIA MFVideoFormat_A16B16G16R16F\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_RGB24))\n+        g_print(\"JFXMEDIA MFVideoFormat_RGB24\\n\");\n+    else if (IsEqualGUID(format, MFVideoFormat_AYUV))\n+        g_print(\"JFXMEDIA MFVideoFormat_AYUV\\n\");\n+    else\n+        g_print(\"JFXMEDIA Unknown MF Format\\n\");\n+}\n+\n+static void mfwrapper_print_output_media_formats(IMFTransform *pMFTrasnform, const char *name)\n+{\n+    HRESULT hr = S_OK;\n+    GUID subType;\n+    DWORD dwTypeIndex = 0;\n+    IMFMediaType *pType = NULL;\n+\n+    g_print(\"JFXMEDIA MF Transform (%s) output formats:\\n\", name);\n+    if (pMFTrasnform == NULL)\n+    {\n+        g_print(\"JFXMEDIA Error: pMFTrasnform == NULL\\n\");\n+        return;\n+    }\n+\n+    do\n+    {\n+        hr = pMFTrasnform->GetOutputAvailableType(0, dwTypeIndex, &pType);\n+        if (SUCCEEDED(hr))\n+        {\n+            hr = pType->GetGUID(MF_MT_SUBTYPE, &subType);\n+            mfwrapper_print_media_format(subType);\n+            SafeRelease(&pType);\n+            dwTypeIndex++;\n+        }\n+    } while (hr != MF_E_NO_MORE_TYPES && SUCCEEDED(hr));\n+}\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+\n@@ -496,1 +566,3 @@\n-static HRESULT mfwrapper_init_colorconvert(GstMFWrapper *decoder)\n+static HRESULT mfwrapper_configure_colorconvert_input_type(GstMFWrapper *decoder,\n+                                                           IMFTransform *pInput,\n+                                                           IMFTransform *pColorConvert)\n@@ -498,6 +570,3 @@\n-    DWORD dwStatus = 0;\n-\n-    IMFMediaType *pDecoderOutputType = NULL;\n-    IMFMediaType *pInputType = NULL;\n-    IMFMediaType *pConverterOutputType = NULL;\n-    IMFMediaType *pOutputType = NULL;\n+    HRESULT hr = S_OK;\n+    IMFMediaType *pInputOutputType = NULL;\n+    IMFMediaType *pColorConvertInputType = NULL;\n@@ -505,4 +574,0 @@\n-    UINT32 unDefaultStride = 0;\n-    UINT32 unNumerator = 0;\n-    UINT32 unDenominator = 0;\n-    MFT_OUTPUT_STREAM_INFO outputStreamInfo;\n@@ -510,1 +575,2 @@\n-    HRESULT hr = CoCreateInstance(CLSID_VideoProcessorMFT, NULL, CLSCTX_ALL, IID_PPV_ARGS(&decoder->pColorConvert));\n+    if (decoder == NULL || pInput == NULL || pColorConvert == NULL)\n+        return E_POINTER;\n@@ -512,3 +578,24 @@\n-    \/\/ Set input type\n-    DWORD dwTypeIndex = 0;\n-    do\n+    \/\/ Get decoder output type. It should be already configured.\n+    if (SUCCEEDED(hr))\n+        hr = pInput->GetOutputCurrentType(0, &pInputOutputType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pInputOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+#if MEDIA_FORMAT_DEBUG\n+    g_print(\"JFXMEDIA mfwrapper_configure_colorconvert_input_type() Input output type:\\n\");\n+    mfwrapper_print_media_format(subType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+\n+    \/\/ Set input type on color converter. Create new one with all information we know.\n+    \/\/ Setting one from decoder will not work since it does not contain all information.\n+    if (SUCCEEDED(hr))\n+        hr = MFCreateMediaType(&pColorConvertInputType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pColorConvertInputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pColorConvertInputType->SetGUID(MF_MT_SUBTYPE, subType);\n+\n+    if (SUCCEEDED(hr))\n@@ -516,2 +603,3 @@\n-        hr = decoder->pDecoder->GetOutputAvailableType(0, dwTypeIndex, &pDecoderOutputType);\n-        dwTypeIndex++;\n+        hr = MFSetAttributeSize(pColorConvertInputType, MF_MT_FRAME_SIZE,\n+                decoder->width, decoder->height);\n+    }\n@@ -519,2 +607,5 @@\n-        if (SUCCEEDED(hr))\n-            hr = pDecoderOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+    if (SUCCEEDED(hr))\n+    {\n+        hr = MFSetAttributeRatio(pColorConvertInputType, MF_MT_FRAME_RATE,\n+                decoder->framerate_num, decoder->framerate_den);\n+    }\n@@ -522,6 +613,5 @@\n-        if (SUCCEEDED(hr) && !IsEqualGUID(subType, MFVideoFormat_NV12))\n-        {\n-            SafeRelease(&pDecoderOutputType);\n-            hr = E_FAIL;\n-            continue;\n-        }\n+    if (SUCCEEDED(hr) && decoder->defaultStride != 0)\n+    {\n+        hr = pColorConvertInputType->SetUINT32(MF_MT_DEFAULT_STRIDE,\n+                (UINT32)decoder->defaultStride);\n+    }\n@@ -529,2 +619,5 @@\n-        if (SUCCEEDED(hr))\n-            hr = MFCreateMediaType(&pInputType);\n+    if (SUCCEEDED(hr) && decoder->pixel_num != 0 && decoder->pixel_den != 0)\n+    {\n+        hr = MFSetAttributeRatio(pColorConvertInputType, MF_MT_PIXEL_ASPECT_RATIO,\n+                (UINT32)decoder->pixel_num, (UINT32)decoder->pixel_den);\n+    }\n@@ -532,2 +625,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = pInputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+    if (SUCCEEDED(hr))\n+        hr = pColorConvert->SetInputType(0, pColorConvertInputType, 0);\n@@ -535,2 +628,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = pInputType->SetGUID(MF_MT_SUBTYPE, subType);\n+    SafeRelease(&pColorConvertInputType);\n+    SafeRelease(&pInputOutputType);\n@@ -538,2 +631,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = MFSetAttributeSize(pInputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+    return hr;\n+}\n@@ -541,2 +634,11 @@\n-        if (SUCCEEDED(hr))\n-            hr = MFSetAttributeRatio(pInputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+static HRESULT mfwrapper_set_colorconvert_output_type(GstMFWrapper *decoder,\n+                                                      IMFMediaType *pOutputType,\n+                                                      IMFTransform *pColorConvert)\n+{\n+    HRESULT hr = S_OK;\n+    GUID subType;\n+    IMFMediaType *pNewOutputType = NULL;\n+    IMFMediaType *pCurrentOutputType = NULL;\n+    GUID currentSubType;\n+    guint width = 0;\n+    guint height = 0;\n@@ -544,1 +646,33 @@\n-        if (SUCCEEDED(hr))\n+    if (decoder == NULL || pOutputType == NULL || pColorConvert == NULL)\n+    {\n+        return E_POINTER;\n+    }\n+\n+    \/\/ We only need subtype\n+    hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+    \/\/ For color convert we need to re-create output type with more information\n+    if (SUCCEEDED(hr))\n+        hr = MFCreateMediaType(&pNewOutputType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pNewOutputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+\n+    if (SUCCEEDED(hr))\n+        hr = pNewOutputType->SetGUID(MF_MT_SUBTYPE, subType);\n+\n+    if (SUCCEEDED(hr))\n+        hr = MFSetAttributeSize(pNewOutputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+\n+    if (SUCCEEDED(hr))\n+        hr = MFSetAttributeRatio(pNewOutputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+\n+    if (SUCCEEDED(hr))\n+    {\n+#if MEDIA_FORMAT_DEBUG\n+        g_print(\"JFXMEDIA Setting color convert output type:\\n\");\n+        mfwrapper_print_media_format(subType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+        hr = pColorConvert->SetOutputType(0, pNewOutputType, 0);\n+        SafeRelease(&pNewOutputType);\n+        if (hr != S_OK) \/\/ S_OK means format was set\n@@ -546,3 +680,5 @@\n-            hr = pDecoderOutputType->GetUINT32(MF_MT_DEFAULT_STRIDE, &unDefaultStride);\n-            if (SUCCEEDED(hr))\n-                hr = pInputType->SetUINT32(MF_MT_DEFAULT_STRIDE, unDefaultStride);\n+#if MEDIA_FORMAT_DEBUG\n+            g_print(\"JFXMEDIA Failed setting color convert output type (hr=0x%X):\\n\", hr);\n+            mfwrapper_print_media_format(subType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+            return E_FAIL;\n@@ -551,0 +687,2 @@\n+        \/\/ Re-check format just in case\n+        hr = pColorConvert->GetOutputCurrentType(0, &pCurrentOutputType);\n@@ -552,0 +690,5 @@\n+            hr = pCurrentOutputType->GetGUID(MF_MT_SUBTYPE, &currentSubType);\n+\n+        SafeRelease(&pCurrentOutputType);\n+\n+        if (SUCCEEDED(hr) && !IsEqualGUID(subType, currentSubType))\n@@ -553,3 +696,6 @@\n-            hr = MFGetAttributeRatio(pDecoderOutputType, MF_MT_PIXEL_ASPECT_RATIO, &unNumerator, &unDenominator);\n-            if (SUCCEEDED(hr))\n-                hr = MFSetAttributeRatio(pInputType, MF_MT_PIXEL_ASPECT_RATIO, unNumerator, unDenominator);\n+#if MEDIA_FORMAT_DEBUG\n+            g_print(\"JFXMEDIA Error: unexpected sub type vs current sub type\\n\");\n+            mfwrapper_print_media_format(subType);\n+            mfwrapper_print_media_format(currentSubType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+            return E_FAIL;\n@@ -557,0 +703,1 @@\n+    }\n@@ -558,2 +705,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = decoder->pColorConvert->SetInputType(0, pInputType, 0);\n+    return hr;\n+}\n@@ -561,1 +708,8 @@\n-        SafeRelease(&pInputType);\n+static HRESULT mfwrapper_configure_colorconvert_output_type(GstMFWrapper *decoder,\n+                                                            IMFTransform *pColorConvert,\n+                                                            GUID *outputType)\n+{\n+    HRESULT hr = S_OK;\n+    IMFMediaType *pOutputType = NULL;\n+    GUID subType;\n+    DWORD dwTypeIndex = 0;\n@@ -563,2 +717,5 @@\n-        if (SUCCEEDED(hr))\n-            hr = decoder->pDecoder->SetOutputType(0, pDecoderOutputType, 0);\n+    \/\/ We need following types:\n+    \/\/ MFVideoFormat_IYUV (prefered)\n+    \/\/ MFVideoFormat_NV12 (requires second converter)\n+    IMFMediaType *pOutputTypeIYUV = NULL;\n+    IMFMediaType *pOutputTypeNV12 = NULL;\n@@ -566,1 +723,2 @@\n-        SafeRelease(&pDecoderOutputType);\n+    if (decoder == NULL || pColorConvert == NULL || outputType == NULL)\n+        return E_POINTER;\n@@ -568,1 +726,3 @@\n-    } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n+#if MEDIA_FORMAT_DEBUG\n+    mfwrapper_print_output_media_formats(pColorConvert, \"Color Converter\");\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n@@ -570,2 +730,0 @@\n-    \/\/ Set output type\n-    dwTypeIndex = 0;\n@@ -574,2 +732,3 @@\n-        hr = decoder->pColorConvert->GetOutputAvailableType(0, dwTypeIndex, &pConverterOutputType);\n-        dwTypeIndex++;\n+        hr = pColorConvert->GetOutputAvailableType(0, dwTypeIndex, &pOutputType);\n+        if (hr == MF_E_NO_MORE_TYPES)\n+            break;\n@@ -578,1 +737,1 @@\n-            hr = pConverterOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+            hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n@@ -580,6 +739,6 @@\n-        if (SUCCEEDED(hr) && !(IsEqualGUID(subType, MFVideoFormat_IYUV) || IsEqualGUID(subType, MFVideoFormat_I420)))\n-        {\n-            SafeRelease(&pConverterOutputType);\n-            hr = E_FAIL;\n-            continue;\n-        }\n+        if (SUCCEEDED(hr) && IsEqualGUID(subType, MFVideoFormat_IYUV))\n+            pOutputTypeIYUV = pOutputType;\n+        else if (SUCCEEDED(hr) && IsEqualGUID(subType, MFVideoFormat_NV12))\n+            pOutputTypeNV12 = pOutputType;\n+        else if (SUCCEEDED(hr))\n+            SafeRelease(&pOutputType);\n@@ -587,1 +746,1 @@\n-        SafeRelease(&pConverterOutputType);\n+        pOutputType = NULL;\n@@ -589,2 +748,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = MFCreateMediaType(&pOutputType);\n+        dwTypeIndex++;\n+    } while (hr != MF_E_NO_MORE_TYPES && SUCCEEDED(hr));\n@@ -592,2 +751,4 @@\n-        if (SUCCEEDED(hr))\n-            hr = pOutputType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);\n+    \/\/ Set hr to error code, it might be SUCCEEDED after loop\n+    \/\/ and pOutputTypeIYUV can be NULL, so we will try other\n+    \/\/ formats as well.\n+    hr = E_FAIL;\n@@ -595,0 +756,6 @@\n+    \/\/ We should cache as much supported formats as possible.\n+    \/\/ Try them in order we prefered.\n+    if (pOutputTypeIYUV)\n+    {\n+        hr = mfwrapper_set_colorconvert_output_type(decoder, pOutputTypeIYUV,\n+                                                    pColorConvert);\n@@ -596,1 +763,2 @@\n-            hr = pOutputType->SetGUID(MF_MT_SUBTYPE, subType);\n+            (*outputType) = MFVideoFormat_IYUV;\n+    }\n@@ -598,0 +766,5 @@\n+    \/\/ Try only if previous one failed\n+    if (hr != S_OK && pOutputTypeNV12)\n+    {\n+        hr = mfwrapper_set_colorconvert_output_type(decoder, pOutputTypeNV12,\n+                                                    pColorConvert);\n@@ -599,1 +772,2 @@\n-            hr = MFSetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, decoder->width, decoder->height);\n+            (*outputType) = MFVideoFormat_NV12;\n+    }\n@@ -601,2 +775,2 @@\n-        if (SUCCEEDED(hr))\n-            hr = MFSetAttributeRatio(pOutputType, MF_MT_FRAME_RATE, decoder->framerate_num, decoder->framerate_den);\n+    SafeRelease(&pOutputTypeIYUV);\n+    SafeRelease(&pOutputTypeNV12);\n@@ -604,2 +778,22 @@\n-        if (SUCCEEDED(hr))\n-            hr = decoder->pColorConvert->SetOutputType(0, pOutputType, 0);\n+    return hr;\n+}\n+\n+\/\/ pInput - Input transform for which mfwrapper_init_colorconvert() will create\n+\/\/ color convert with best possible output type.\n+\/\/ ppColorConvert - Receives pointer to color convert.\n+\/\/ ppColorConvertOutput - Receives pointer to color convert output buffer.\n+\/\/ outputType - Will be set to color convert output type (IYUV or NV12)\n+static HRESULT mfwrapper_init_colorconvert(GstMFWrapper *decoder,\n+                                           IMFTransform *pInput,\n+                                           IMFTransform **ppColorConvert,\n+                                           IMFSample **ppColorConvertOutput,\n+                                           GUID *outputType)\n+{\n+    DWORD dwStatus = 0;\n+    MFT_OUTPUT_STREAM_INFO outputStreamInfo;\n+\n+    if (pInput == NULL || ppColorConvert == NULL ||\n+        ppColorConvertOutput == NULL || outputType == NULL)\n+    {\n+        return E_POINTER;\n+    }\n@@ -607,1 +801,3 @@\n-        SafeRelease(&pOutputType);\n+    HRESULT hr = CoCreateInstance(CLSID_VideoProcessorMFT, NULL, CLSCTX_ALL, IID_PPV_ARGS(ppColorConvert));\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_configure_colorconvert_input_type(decoder, pInput, (*ppColorConvert));\n@@ -609,1 +805,2 @@\n-    } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_configure_colorconvert_output_type(decoder, (*ppColorConvert), outputType);\n@@ -612,1 +809,1 @@\n-        hr = decoder->pColorConvert->GetOutputStreamInfo(0, &outputStreamInfo);\n+        hr = (*ppColorConvert)->GetOutputStreamInfo(0, &outputStreamInfo);\n@@ -616,1 +813,2 @@\n-        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) || (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n+        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) ||\n+              (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n@@ -618,1 +816,1 @@\n-            hr = MFCreateSample(&decoder->pColorConvertOutput);\n+            hr = MFCreateSample(ppColorConvertOutput);\n@@ -624,1 +822,1 @@\n-                    hr = decoder->pColorConvertOutput->AddBuffer(pBuffer);\n+                    hr = (*ppColorConvertOutput)->AddBuffer(pBuffer);\n@@ -631,1 +829,1 @@\n-        hr = decoder->pColorConvert->GetInputStatus(0, &dwStatus);\n+        hr = (*ppColorConvert)->GetInputStatus(0, &dwStatus);\n@@ -638,1 +836,1 @@\n-        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n+        hr = (*ppColorConvert)->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n@@ -641,1 +839,1 @@\n-        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n+        hr = (*ppColorConvert)->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n@@ -644,1 +842,1 @@\n-        hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+        hr = (*ppColorConvert)->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n@@ -649,1 +847,190 @@\n-static gboolean mfwrapper_convert_output(GstMFWrapper *decoder)\n+static HRESULT mfwrapper_set_decoder_output_type(GstMFWrapper *decoder,\n+                                                 IMFMediaType *pOutputType,\n+                                                 gboolean bInitColorConverter)\n+{\n+    HRESULT hr = S_OK;\n+    GUID subType;\n+    IMFMediaType *pCurrentOutputType = NULL;\n+    GUID currentSubType;\n+    guint width = 0;\n+    guint height = 0;\n+\n+    if (decoder == NULL && pOutputType == NULL)\n+        return E_POINTER;\n+\n+    hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+    if (SUCCEEDED(hr))\n+    {\n+#if MEDIA_FORMAT_DEBUG\n+        g_print(\"JFXMEDIA Setting decoder output type:\\n\");\n+        mfwrapper_print_media_format(subType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+        hr = decoder->pDecoder->SetOutputType(0, pOutputType, 0);\n+        if (hr != S_OK) \/\/ S_OK means format was set\n+        {\n+#if MEDIA_FORMAT_DEBUG\n+            g_print(\"JFXMEDIA Failed setting decoder output type (hr=0x%X):\\n\", hr);\n+            mfwrapper_print_media_format(subType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+            return E_FAIL;\n+        }\n+\n+        \/\/ Re-check format just in case\n+        hr = decoder->pDecoder->GetOutputCurrentType(0, &pCurrentOutputType);\n+        if (SUCCEEDED(hr))\n+            hr = pCurrentOutputType->GetGUID(MF_MT_SUBTYPE, &currentSubType);\n+\n+        SafeRelease(&pCurrentOutputType);\n+\n+        if (SUCCEEDED(hr) && !IsEqualGUID(subType, currentSubType))\n+        {\n+#if MEDIA_FORMAT_DEBUG\n+            g_print(\"JFXMEDIA Error: unexpected sub type vs current sub type\\n\");\n+            mfwrapper_print_media_format(subType);\n+            mfwrapper_print_media_format(currentSubType);\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+            return E_FAIL;\n+        }\n+    }\n+\n+    if (SUCCEEDED(hr))\n+    {\n+        \/\/ Update width and height from configured decoder output type.\n+        \/\/ We need to do this before color convert, so we pass correct\n+        \/\/ resolution to color convert and caps.\n+        hr = MFGetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, &width, &height);\n+        if (SUCCEEDED(hr) && (decoder->width != width || decoder->height != height))\n+        {\n+            decoder->width = width;\n+            decoder->height = height;\n+        }\n+        hr = S_OK; \/\/ Ok if we do not have above attribute\n+\n+        \/\/ Cache stride and pixel aspect ratio. Ok if we do not have it.\n+        UINT32 unDefaultStride = 0;\n+        hr = pOutputType->GetUINT32(MF_MT_DEFAULT_STRIDE, &unDefaultStride);\n+        if (SUCCEEDED(hr))\n+        {\n+            decoder->defaultStride = unDefaultStride;\n+        }\n+        hr = S_OK;\n+\n+        UINT32 unNumerator = 0;\n+        UINT32 unDenominator = 0;\n+        hr = MFGetAttributeRatio(pOutputType, MF_MT_PIXEL_ASPECT_RATIO, &unNumerator, &unDenominator);\n+        if (SUCCEEDED(hr))\n+        {\n+            decoder->pixel_num = unNumerator;\n+            decoder->pixel_den = unDenominator;\n+        }\n+        hr = S_OK;\n+    }\n+\n+    \/\/ Init color converter if needed\n+    if (SUCCEEDED(hr) && bInitColorConverter)\n+    {\n+        IMFTransform *pColorConvert = NULL;\n+        IMFSample *pColorConvertOutput = NULL;\n+        GUID outputType;\n+\n+        hr = mfwrapper_init_colorconvert(decoder, decoder->pDecoder,\n+                    &pColorConvert, &pColorConvertOutput, &outputType);\n+        if (SUCCEEDED(hr) && IsEqualGUID(outputType, MFVideoFormat_NV12)) {\n+            decoder->pColorConvert[COLOR_CONVERT_NV12] = pColorConvert;\n+            decoder->pColorConvertOutput[COLOR_CONVERT_NV12] = pColorConvertOutput;\n+\n+            \/\/ We got NV12, so init second one for NV12->IYUV\n+            hr = mfwrapper_init_colorconvert(decoder,\n+                    decoder->pColorConvert[COLOR_CONVERT_NV12], &pColorConvert,\n+                    &pColorConvertOutput, &outputType);\n+        }\n+\n+        if (SUCCEEDED(hr) && IsEqualGUID(outputType, MFVideoFormat_IYUV)) {\n+            decoder->pColorConvert[COLOR_CONVERT_IYUV] = pColorConvert;\n+            decoder->pColorConvertOutput[COLOR_CONVERT_IYUV] = pColorConvertOutput;\n+        }\n+    }\n+\n+    \/\/ Update caps on src pad in case if something changed\n+    if (SUCCEEDED(hr))\n+        mfwrapper_set_src_caps(decoder);\n+\n+    return hr;\n+}\n+\n+static HRESULT mfwrapper_configure_decoder_output_type(GstMFWrapper *decoder)\n+{\n+    HRESULT hr = S_OK;\n+    IMFMediaType *pOutputType = NULL;\n+    GUID subType;\n+    DWORD dwTypeIndex = 0;\n+\n+    \/\/ Note: See JDK-8336277. Looks like \"H.265 \/ HEVC Video Decoder\" has\n+    \/\/ a bug and if we succesfully called SetOutputType() on given media\n+    \/\/ type it does not mean that decoder actually switch format. So, to\n+    \/\/ consider format set succesfully we need to check return value of\n+    \/\/ SetOutputType() and re-read back format via GetOutputCurrentType().\n+\n+    \/\/ We need to support following formats:\n+    \/\/ MFVideoFormat_IYUV - Our prefered format, since we can render it directly.\n+    \/\/ MFVideoFormat_NV12 - Decoder prefered, but requires color converter.\n+    \/\/ MFVideoFormat_P010 - Decoder prefered, but requires color converter (10-bit video).\n+    IMFMediaType *pOutputTypeIYUV = NULL;\n+    IMFMediaType *pOutputTypeNV12 = NULL;\n+    IMFMediaType *pOutputTypeP010 = NULL;\n+\n+#if MEDIA_FORMAT_DEBUG\n+    mfwrapper_print_output_media_formats(decoder->pDecoder, \"Video Decoder\");\n+#endif \/\/ MEDIA_FORMAT_DEBUG\n+\n+    do\n+    {\n+        hr = decoder->pDecoder->GetOutputAvailableType(0, dwTypeIndex, &pOutputType);\n+        if (hr == MF_E_NO_MORE_TYPES)\n+            break;\n+\n+        if (SUCCEEDED(hr))\n+            hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+        if (SUCCEEDED(hr) && IsEqualGUID(subType, MFVideoFormat_IYUV))\n+            pOutputTypeIYUV = pOutputType;\n+        else if (SUCCEEDED(hr) && IsEqualGUID(subType, MFVideoFormat_NV12))\n+            pOutputTypeNV12 = pOutputType;\n+        else if (SUCCEEDED(hr) && IsEqualGUID(subType, MFVideoFormat_P010))\n+            pOutputTypeP010 = pOutputType;\n+        else if (SUCCEEDED(hr))\n+            SafeRelease(&pOutputType);\n+\n+        pOutputType = NULL;\n+\n+        dwTypeIndex++;\n+    } while (hr != MF_E_NO_MORE_TYPES && SUCCEEDED(hr));\n+\n+    \/\/ Set hr to error code, it might be SUCCEEDED after loop\n+    \/\/ and pOutputTypeIYUV can be NULL, so we will try other\n+    \/\/ formats as well.\n+    hr = E_FAIL;\n+\n+    \/\/ We should cache as much supported formats as possible.\n+    \/\/ Try them in order we prefered.\n+    if (pOutputTypeIYUV)\n+        hr = mfwrapper_set_decoder_output_type(decoder, pOutputTypeIYUV, false);\n+\n+    \/\/ Try only if previous one failed\n+    if (hr != S_OK && pOutputTypeNV12)\n+        hr = mfwrapper_set_decoder_output_type(decoder, pOutputTypeNV12, true);\n+\n+    if (hr != S_OK && pOutputTypeP010)\n+        hr = mfwrapper_set_decoder_output_type(decoder, pOutputTypeP010, true);\n+\n+    SafeRelease(&pOutputTypeIYUV);\n+    SafeRelease(&pOutputTypeNV12);\n+    SafeRelease(&pOutputTypeP010);\n+\n+    return hr;\n+}\n+\n+static gboolean mfwrapper_convert_output_helper(GstMFWrapper *decoder,\n+                                                IMFSample *pInputSample,\n+                                                IMFTransform *pColorConvert,\n+                                                IMFSample *pColorConvertOutput)\n@@ -655,1 +1042,1 @@\n-    outputDataBuffer.pSample = decoder->pColorConvertOutput;\n+    outputDataBuffer.pSample = pColorConvertOutput;\n@@ -660,1 +1047,1 @@\n-    if (decoder->pColorConvert == NULL || decoder->pColorConvertOutput == NULL)\n+    if (decoder == NULL || pColorConvert == NULL || pColorConvertOutput == NULL)\n@@ -665,1 +1052,1 @@\n-    HRESULT hr = decoder->pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n+    HRESULT hr = pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n@@ -667,1 +1054,1 @@\n-    hr = decoder->pColorConvert->ProcessInput(0, decoder->pDecoderOutput, 0);\n+    hr = pColorConvert->ProcessInput(0, pInputSample, 0);\n@@ -670,1 +1057,1 @@\n-        hr = decoder->pColorConvert->GetOutputStatus(&dwFlags);\n+        hr = pColorConvert->GetOutputStatus(&dwFlags);\n@@ -675,1 +1062,1 @@\n-    hr = decoder->pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n+    hr = pColorConvert->ProcessOutput(0, 1, &outputDataBuffer, &dwStatus);\n@@ -681,1 +1068,1 @@\n-            hr = decoder->pColorConvert->GetOutputAvailableType(0, 0, &pOutputType);\n+            hr = pColorConvert->GetOutputAvailableType(0, 0, &pOutputType);\n@@ -687,1 +1074,1 @@\n-                hr = decoder->pColorConvert->SetOutputType(0, pOutputType, 0);\n+                hr = pColorConvert->SetOutputType(0, pOutputType, 0);\n@@ -703,0 +1090,33 @@\n+static gboolean mfwrapper_convert_output(GstMFWrapper *decoder)\n+{\n+    gboolean result = TRUE;\n+    \/\/ Sample to convert. Always start from decoder\n+    IMFSample *pInputSample = decoder->pDecoderOutput;\n+\n+    if (decoder == NULL || pInputSample == NULL)\n+        return FALSE;\n+\n+    if (decoder->pColorConvert[COLOR_CONVERT_NV12] &&\n+        decoder->pColorConvertOutput[COLOR_CONVERT_NV12])\n+    {\n+        result = mfwrapper_convert_output_helper(decoder,\n+                                                 pInputSample,\n+                                                 decoder->pColorConvert[COLOR_CONVERT_NV12],\n+                                                 decoder->pColorConvertOutput[COLOR_CONVERT_NV12]);\n+        pInputSample = decoder->pColorConvertOutput[COLOR_CONVERT_NV12]; \/\/ Keep converting\n+    }\n+\n+    if (result && pInputSample != NULL &&\n+        decoder->pColorConvert[COLOR_CONVERT_IYUV] &&\n+        decoder->pColorConvertOutput[COLOR_CONVERT_IYUV])\n+    {\n+        result = mfwrapper_convert_output_helper(decoder,\n+                                                 pInputSample,\n+                                                 decoder->pColorConvert[COLOR_CONVERT_IYUV],\n+                                                 decoder->pColorConvertOutput[COLOR_CONVERT_IYUV]);\n+\n+    }\n+\n+    return result;\n+}\n+\n@@ -777,1 +1197,0 @@\n-    IMFMediaType *pOutputType = NULL;\n@@ -807,47 +1226,1 @@\n-            GUID subType;\n-            guint width = 0; guint height = 0;\n-            DWORD dwTypeIndex = 0;\n-\n-            do\n-            {\n-                hr = decoder->pDecoder->GetOutputAvailableType(0, dwTypeIndex, &pOutputType);\n-\n-                if (SUCCEEDED(hr))\n-                    hr = pOutputType->GetGUID(MF_MT_SUBTYPE, &subType);\n-\n-                if (SUCCEEDED(hr))\n-                    hr = MFGetAttributeSize(pOutputType, MF_MT_FRAME_SIZE, &width, &height);\n-\n-                if (SUCCEEDED(hr) && (decoder->width != width || decoder->height != height))\n-                {\n-                    decoder->width = width;\n-                    decoder->height = height;\n-                }\n-\n-                \/\/ If decoder prefers MFVideoFormat_P010, then it means we dealing with 10 or 12-bit\n-                \/\/ HEVC, in this case setup color converter\n-                if (SUCCEEDED(hr) && dwTypeIndex == 0 && IsEqualGUID(subType, MFVideoFormat_P010))\n-                {\n-                    hr = mfwrapper_init_colorconvert(decoder);\n-                    break;\n-                }\n-\n-                dwTypeIndex++;\n-\n-                \/\/ I420 and IYUV are same\n-                if (SUCCEEDED(hr) && !IsEqualGUID(subType, MFVideoFormat_IYUV) && !IsEqualGUID(subType, MFVideoFormat_I420))\n-                {\n-                    SafeRelease(&pOutputType);\n-                    hr = E_FAIL;\n-                    continue;\n-                }\n-\n-                if (SUCCEEDED(hr))\n-                    hr = decoder->pDecoder->SetOutputType(0, pOutputType, 0);\n-            } while (hr != MF_E_NO_MORE_TYPES && FAILED(hr));\n-\n-            \/\/ Update caps on src pad in case if something changed\n-            if (SUCCEEDED(hr))\n-                mfwrapper_set_src_caps(decoder);\n-\n-            SafeRelease(&pOutputType);\n+            hr = mfwrapper_configure_decoder_output_type(decoder);\n@@ -861,1 +1234,2 @@\n-            if (decoder->pColorConvert && decoder->pColorConvertOutput)\n+            if (decoder->pColorConvert[COLOR_CONVERT_IYUV] &&\n+                decoder->pColorConvertOutput[COLOR_CONVERT_IYUV])\n@@ -865,1 +1239,3 @@\n-                    ret = mfwrapper_deliver_sample(decoder, decoder->pColorConvertOutput);\n+                    \/\/ Deliver from IYUV color converter\n+                    ret = mfwrapper_deliver_sample(decoder,\n+                                decoder->pColorConvertOutput[COLOR_CONVERT_IYUV]);\n@@ -948,2 +1324,8 @@\n-        if (decoder->pColorConvert)\n-            decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+        for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+        {\n+            if (decoder->pColorConvert[i])\n+            {\n+                decoder->pColorConvert[i]->\n+                        ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+            }\n+        }\n@@ -961,1 +1343,2 @@\n-        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n+        hr = decoder->pDecoder->\n+                ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n@@ -965,1 +1348,4 @@\n-            decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);\n+        {\n+            decoder->pDecoder->\n+                    ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);\n+        }\n@@ -974,1 +1360,1 @@\n-        if (decoder->pColorConvert)\n+        for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n@@ -976,3 +1362,8 @@\n-            hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n-            if (SUCCEEDED(hr))\n-                hr = decoder->pColorConvert->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+            if (decoder->pColorConvert[i])\n+            {\n+                hr = decoder->pColorConvert[i]->\n+                        ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n+                if (SUCCEEDED(hr))\n+                    hr = decoder->pColorConvert[i]->\n+                            ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+            }\n@@ -994,1 +1385,4 @@\n-            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR, GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE, g_strdup(\"Failed to decode stream\"), NULL, (\"mfwrapper.c\"), (\"mfwrapper_sink_event\"), 0);\n+            gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                                     GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                                     g_strdup(\"Failed to decode stream\"), NULL,\n+                                     (\"mfwrapper.c\"), (\"mfwrapper_sink_event\"), 0);\n@@ -1164,2 +1558,0 @@\n-    hr = MFCreateMediaType(&pInputType);\n-\n@@ -1169,0 +1561,2 @@\n+    hr = MFCreateMediaType(&pInputType);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":550,"deletions":156,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,10 @@\n+\/\/ Media Foundation Color Convert:\n+\/\/ NV12 -> IYUV\n+\/\/ P010 -> NV12 -> IYUV\n+\/\/ Maximum number of color converters\n+#define MAX_COLOR_CONVERT 2\n+\/\/ Index in array for color convert with IYUV output format\n+#define COLOR_CONVERT_IYUV 0\n+\/\/ Index in array for color convert with NV12 output format\n+#define COLOR_CONVERT_NV12 1\n+\n@@ -71,1 +81,0 @@\n-\n@@ -74,3 +83,2 @@\n-    IMFTransform *pColorConvert;\n-\n-    IMFSample *pColorConvertOutput;\n+    IMFTransform *pColorConvert[MAX_COLOR_CONVERT];\n+    IMFSample *pColorConvertOutput[MAX_COLOR_CONVERT];\n@@ -85,0 +93,4 @@\n+\n+    guint defaultStride;\n+    guint pixel_num;\n+    guint pixel_den;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.h","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"}]}