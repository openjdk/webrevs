{"files":[{"patch":"@@ -43,0 +43,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -48,0 +50,2 @@\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n@@ -60,0 +64,3 @@\n+    private final Map<Menu, ListChangeListener<MenuItemBase>> menuListeners = new HashMap<>();\n+    private final Map<ListChangeListener<MenuItemBase>, ObservableList<MenuItemBase>> listenerItems = new HashMap<>();\n+    private BooleanProperty active;\n@@ -88,0 +95,4 @@\n+        if (active != null) {\n+            active.set(false);\n+        }\n+        active = new SimpleBooleanProperty(true);\n@@ -114,0 +125,8 @@\n+        ListChangeListener<MenuItemBase> lcl = menuListeners.get(menu);\n+        if (lcl != null) {\n+            ObservableList<MenuItemBase> target = listenerItems.get(lcl);\n+            target.removeListener(lcl);\n+            menuListeners.remove(menu);\n+            listenerItems.remove(lcl);\n+        }\n+\n@@ -116,1 +135,0 @@\n-\n@@ -119,0 +137,1 @@\n+                menu.remove(i);\n@@ -151,1 +170,27 @@\n-        filteredItems.addListener((ListChangeListener.Change<? extends MenuItemBase> change) -> {\n+        ListChangeListener<MenuItemBase> menuItemListener = createListener(glassMenu);\n+        filteredItems.addListener(menuItemListener);\n+        menuListeners.put(glassMenu, menuItemListener);\n+        listenerItems.put(menuItemListener, filteredItems);\n+\n+        for (MenuItemBase item : items) {\n+            if (item instanceof MenuBase baseItem) {\n+                \/\/ submenu\n+                addMenu(glassMenu, baseItem);\n+            } else {\n+                \/\/ menu item\n+                addMenuItem(glassMenu, item);\n+            }\n+        }\n+        glassMenu.setPixels(getPixels(mb));\n+\n+        setMenuBindings(glassMenu, mb);\n+\n+        if (parent != null) {\n+            parent.insert(glassMenu, pos);\n+        } else {\n+            glassSystemMenuBar.insert(glassMenu, pos);\n+        }\n+    }\n+\n+    private ListChangeListener<MenuItemBase> createListener(final Menu glassMenu) {\n+        return (ListChangeListener.Change<? extends MenuItemBase> change) -> {\n@@ -160,0 +205,2 @@\n+                        Object item = menuItemList.get(i);\n+                        if (item instanceof Menu menu) clearMenu(menu);\n@@ -172,20 +219,1 @@\n-        });\n-\n-        for (MenuItemBase item : items) {\n-            if (item instanceof MenuBase) {\n-                \/\/ submenu\n-                addMenu(glassMenu, (MenuBase)item);\n-            } else {\n-                \/\/ menu item\n-                addMenuItem(glassMenu, item);\n-            }\n-        }\n-        glassMenu.setPixels(getPixels(mb));\n-\n-        setMenuBindings(glassMenu, mb);\n-\n-        if (parent != null) {\n-            parent.insert(glassMenu, pos);\n-        } else {\n-            glassSystemMenuBar.insert(glassMenu, pos);\n-        }\n+        };\n@@ -194,4 +222,5 @@\n-    private void setMenuBindings(final Menu glassMenu, final MenuBase mb) {\n-        mb.textProperty().addListener(valueModel -> glassMenu.setTitle(parseText(mb)));\n-        mb.disableProperty().addListener(valueModel -> glassMenu.setEnabled(!mb.isDisable()));\n-        mb.mnemonicParsingProperty().addListener(valueModel -> glassMenu.setTitle(parseText(mb)));\n+\n+    protected void setMenuBindings(final Menu glassMenu, final MenuBase mb) {\n+        mb.textProperty().when(active).subscribe(valueModel -> glassMenu.setTitle(parseText(mb)));\n+        mb.disableProperty().when(active).subscribe(valueModel -> glassMenu.setEnabled(!mb.isDisable()));\n+        mb.mnemonicParsingProperty().when(active).subscribe(valueModel -> glassMenu.setTitle(parseText(mb)));\n@@ -259,1 +288,1 @@\n-            glassSubMenuItem.setEnabled(! menuitem.isDisable());\n+            glassSubMenuItem.setEnabled(!menuitem.isDisable());\n@@ -268,1 +297,1 @@\n-                final CheckMenuItemBase checkItem = (CheckMenuItemBase)menuitem;\n+                final CheckMenuItemBase checkItem = (CheckMenuItemBase) menuitem;\n@@ -272,1 +301,1 @@\n-                final RadioMenuItemBase radioItem = (RadioMenuItemBase)menuitem;\n+                final RadioMenuItemBase radioItem = (RadioMenuItemBase) menuitem;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassSystemMenu.java","additions":58,"deletions":29,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.tk.quantum;\n+\n+import com.sun.glass.ui.Menu;\n+import com.sun.javafx.menu.MenuBase;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class GlassSystemMenuShim extends GlassSystemMenu {\n+\n+    private GlassSystemMenu gsm;\n+    private final ArrayList<WeakReference<Menu>> uncollectedMenus = new ArrayList<>();\n+\n+    public GlassSystemMenuShim() {\n+        super();\n+    }\n+\n+    public void setMenus(List<MenuBase> menus) {\n+        super.setMenus(menus);\n+    }\n+\n+    public void createMenuBar() {\n+        super.createMenuBar();\n+    }\n+\n+    @Override\n+    protected void setMenuBindings(final Menu glassMenu, final MenuBase mb) {\n+        super.setMenuBindings(glassMenu, mb);\n+        uncollectedMenus.add(new WeakReference<>(glassMenu));\n+    }\n+\n+    public List<WeakReference<Menu>> getWeakMenuReferences() {\n+        return uncollectedMenus;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/com\/sun\/javafx\/tk\/quantum\/GlassSystemMenuShim.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+--add-exports=javafx.graphics\/com.sun.javafx.menu=ALL-UNNAMED\n@@ -30,0 +31,1 @@\n+--add-exports=javafx.graphics\/com.sun.javafx.tk.quantum=ALL-UNNAMED\n","filename":"tests\/system\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.tk.quantum;\n+\n+import com.sun.javafx.menu.MenuBase;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+import test.util.memory.JMemoryBuddy;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.sun.javafx.tk.quantum.GlassSystemMenuShim;\n+import com.sun.javafx.scene.control.GlobalMenuAdapter;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javafx.application.Platform;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class SystemMenuBarTest {\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        CountDownLatch startupLatch = new CountDownLatch(1);\n+        Platform.setImplicitExit(false);\n+\n+        Util.startup(startupLatch, () -> {\n+            startupLatch.countDown();\n+        });\n+    }\n+\n+    @AfterClass\n+    public static void teardownOnce() {\n+        Util.shutdown();\n+    }\n+\n+    CountDownLatch menubarLatch = new CountDownLatch(1);\n+    CountDownLatch memoryLatch = new CountDownLatch(1);\n+    CountDownLatch memoryFocusLatch = new CountDownLatch(1);\n+    AtomicBoolean failed = new AtomicBoolean(false);\n+\n+    @Test\n+    public void testFailingMenuBar() throws InterruptedException {\n+        Util.runAndWait(() -> {\n+            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n+                e.printStackTrace();\n+                failed.set(true);\n+            });\n+            createMenuBarStage();\n+        });\n+\n+        menubarLatch.await();\n+\n+        assertFalse(failed.get());\n+    }\n+\n+    public void createMenuBarStage() {\n+        Stage stage = new Stage();\n+        VBox root = new VBox();\n+\n+        root.getChildren().add(createFailingMenuBar());\n+\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    public MenuBar createFailingMenuBar() {\n+        MenuBar menuBar = new MenuBar();\n+\n+        menuBar.setUseSystemMenuBar(true);\n+\n+        Menu systemMenu = new Menu(\"systemMenu\");\n+        menuBar.getMenus().add(systemMenu);\n+\n+        var newItem = new MenuItem();\n+        newItem.setVisible(false);\n+        systemMenu.getItems().add(newItem);\n+\n+        Platform.runLater(() -> {\n+            javafx.scene.control.Menu systemMenuContributions = new Menu(\"123\");\n+            systemMenu.getItems().add(systemMenuContributions);\n+            menubarLatch.countDown();\n+        });\n+\n+        return menuBar;\n+    }\n+\n+    @Test\n+    public void testMemoryLeak() throws InterruptedException {\n+        Util.runAndWait(() -> {\n+            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n+                e.printStackTrace();\n+                failed.set(true);\n+                memoryLatch.countDown();\n+            });\n+            createMenuBarWithItemsStage();\n+        });\n+        memoryLatch.await();\n+        assertFalse(failed.get());\n+    }\n+\n+    private void createMenuBarWithItemsStage() {\n+        final ArrayList<WeakReference<MenuItem>> uncollectedMenuItems = new ArrayList<>();\n+\n+        Stage stage = new Stage();\n+        VBox root = new VBox();\n+        final MenuBar menuBar = new MenuBar();\n+        final Menu menu = new Menu(\"MyMenu\");\n+        menuBar.getMenus().add(menu);\n+        menuBar.setUseSystemMenuBar(true);\n+        root.getChildren().add(menuBar);\n+\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        stage.requestFocus();\n+        Thread t = new Thread() {\n+            @Override public void run() {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        Thread.sleep(20);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                    Platform.runLater(() -> {\n+                        menu.getItems().clear();\n+                        MenuItem menuItem = new MenuItem(\"MyItem\");\n+                        WeakReference<MenuItem> wr = new WeakReference<>(menuItem);\n+                        uncollectedMenuItems.add(wr);\n+                        menu.getItems().add(menuItem);\n+                    });\n+                }\n+                Platform.runLater( () -> {\n+                    int strongCount = 0;\n+                    for (WeakReference<MenuItem> wr: uncollectedMenuItems) {\n+                        if (!JMemoryBuddy.checkCollectable(wr)) strongCount++;\n+                    }\n+                    assertEquals(1, strongCount, \"Only the last menuItem should be alive\");\n+                    memoryLatch.countDown();\n+                });\n+            }\n+        };\n+        t.start();\n+    }\n+\n+    @Test\n+    public void testFocusMemoryLeak() throws InterruptedException {\n+        Util.runAndWait(() -> {\n+            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n+                e.printStackTrace();\n+                failed.set(true);\n+                memoryFocusLatch.countDown();\n+            });\n+            createAndRefocusMenuBarStage();\n+        });\n+        memoryFocusLatch.await();\n+        assertFalse(failed.get());\n+    }\n+\n+    public void createAndRefocusMenuBarStage() {\n+        Stage stage = new Stage();\n+        VBox root = new VBox();\n+\n+        final MenuBar menuBar = new MenuBar();\n+        final Menu menu = new Menu(\"MyMenu\");\n+        menuBar.getMenus().add(menu);\n+        menuBar.setUseSystemMenuBar(true);\n+        root.getChildren().add(menuBar);\n+\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        final ArrayList<WeakReference<MenuBase>> uncollectedMenus = new ArrayList<>();\n+        GlassSystemMenuShim gsmh = new GlassSystemMenuShim();\n+        assumeTrue(\"SystemMenu only supported on MacOS\", gsmh.isSupported());\n+        Menu m1 = new Menu(\"Menu\");\n+\n+        MenuBase menuBase = GlobalMenuAdapter.adapt(m1);\n+        ArrayList<MenuBase> menus = new ArrayList<>();\n+        gsmh.createMenuBar();\n+        for (int i = 0; i < 100; i++) {\n+            Platform.runLater(() -> {\n+                gsmh.setMenus(List.of(menuBase));\n+            });\n+        }\n+        Platform.runLater(() -> {\n+            int strongCount = 0;\n+            final List<WeakReference<com.sun.glass.ui.Menu>> u2 = gsmh.getWeakMenuReferences();\n+            for (WeakReference<com.sun.glass.ui.Menu> wr : u2) {\n+                if (!JMemoryBuddy.checkCollectable(wr)) {\n+                    strongCount++;\n+                    assertTrue(\"Too many references\", strongCount < 2);\n+                }\n+            }\n+            assertEquals(1, strongCount, \"Exactly one reference should be reachable\");\n+            memoryFocusLatch.countDown();\n+        });\n+    }\n+\n+    CountDownLatch removeMenuLatch = new CountDownLatch(1);\n+\n+    @Test\n+    public void testRemoveMenu() throws InterruptedException {\n+        failed.set(false);\n+        Util.runAndWait(() -> {\n+            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n+                e.printStackTrace();\n+                failed.set(true);\n+                removeMenuLatch.countDown();\n+            });\n+            createRemoveMenuStage();\n+        });\n+        removeMenuLatch.await();\n+        assertFalse(failed.get());\n+    }\n+\n+    public void createRemoveMenuStage() {\n+        Stage stage = new Stage();\n+        VBox root = new VBox();\n+\n+        final MenuBar menuBar = new MenuBar();\n+\n+        Menu mainMenu = new Menu(\"MainMenu\");\n+        Menu subMenu = new Menu(\"SubMenu\");\n+        subMenu.getItems().addAll(new MenuItem(\"submenuitem1\"), new MenuItem(\"submenuitem2\"));\n+        mainMenu.getItems().add(subMenu);\n+        menuBar.getMenus().add(mainMenu);\n+\n+        menuBar.setUseSystemMenuBar(true);\n+        root.getChildren().add(menuBar);\n+\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+\n+        Platform.runLater(() -> {\n+            mainMenu.getItems().clear();\n+            mainMenu.getItems().add(subMenu);\n+            subMenu.getItems().addAll(new MenuItem(\"new item 1\"), new MenuItem(\"new item 2\"));\n+            removeMenuLatch.countDown();\n+        });\n+    }\n+\n+    @Test \/\/ adding\/removing\/changing items should not throw an Exception\n+    public void testJDK8309935() throws InterruptedException {\n+        MenuBar menuBar = new MenuBar();\n+        AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n+        Util.runAndWait(() -> {\n+            Thread.currentThread().setUncaughtExceptionHandler((t, e) -> {\n+                e.printStackTrace();\n+                throwableRef.set(e);\n+            });\n+            menuBar.setUseSystemMenuBar(true);\n+            Menu menu1 = new Menu(\"menu 1\");\n+            menu1.getItems().add(new MenuItem(\"item 1\"));\n+            menu1.getItems().add(new MenuItem(\"item 2\"));\n+            menuBar.getMenus().add(menu1);\n+            Menu menu2 = new Menu(\" menu 2\");\n+            menu2.getItems().add(new MenuItem(\"item 1\"));\n+            menu2.getItems().add(new MenuItem(\"item 2\"));\n+            menu2.getItems().add(new SeparatorMenuItem());\n+            menuBar.getMenus().add(menu2);\n+            Menu test1 = new Menu(\"test 1\");\n+            test1.getItems().add(new MenuItem(\"item 1\"));\n+            test1.getItems().add(new MenuItem(\"item 2\"));\n+            Menu test2 = new Menu(\"test 2\");\n+            test2.getItems().add(new MenuItem(\"item 1\"));\n+            test2.getItems().add(new MenuItem(\"item 2\"));\n+            menu2.addEventFilter(Menu.ON_SHOWING, e -> {\n+                menu2.getItems().removeIf(o -> Objects.equals(o.getText(), test1.getText()));\n+                menu2.getItems().add(test1);\n+                menu2.getItems().removeIf(o -> Objects.equals(o.getText(), test2.getText()));\n+                menu2.getItems().add(test2);\n+            });\n+            BorderPane root = new BorderPane();\n+            root.setTop(menuBar);\n+            Stage stage = new Stage();\n+            stage.setScene(new Scene(root));\n+            stage.show();\n+        });\n+        Util.runAndWait(() -> {\n+            menuBar.getMenus().forEach(menu -> {\n+                menu.setVisible(false);\n+            });\n+        });\n+        Util.runAndWait(() -> {\n+            menuBar.getMenus().forEach(menu -> {\n+                menu.setVisible(true);\n+            });\n+        });\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            Menu test3 = new Menu(\"test 3\");\n+            test3.getItems().add(new MenuItem(\"item 1\"));\n+            test3.getItems().add(new MenuItem(\"item 2\"));\n+            Menu test4 = new Menu(\"test 4\");\n+            test4.getItems().add(new MenuItem(\"item 1\"));\n+            test4.getItems().add(new MenuItem(\"item 2\"));\n+            menuBar.getMenus().get(1).getItems().addAll(test3, test4);\n+            Platform.runLater(() -> cdl.countDown());\n+        });\n+        boolean success = cdl.await(10, TimeUnit.SECONDS);\n+        assertTrue(success);\n+        if (throwableRef.get() != null) {\n+            fail(throwableRef.get());\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/tk\/quantum\/SystemMenuBarTest.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.javafx.stage;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import javafx.application.Platform;\n-import javafx.scene.Scene;\n-import javafx.scene.control.Menu;\n-import javafx.scene.control.MenuBar;\n-import javafx.scene.control.MenuItem;\n-import javafx.scene.layout.VBox;\n-import javafx.stage.Stage;\n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n-import test.util.Util;\n-import test.util.memory.JMemoryBuddy;\n-\n-public class SystemMenuBarTest {\n-    @BeforeClass\n-    public static void initFX() throws Exception {\n-        CountDownLatch startupLatch = new CountDownLatch(1);\n-        Platform.setImplicitExit(false);\n-\n-        Util.startup(startupLatch, () -> {\n-            startupLatch.countDown();\n-        });\n-    }\n-\n-    @AfterClass\n-    public static void teardownOnce() {\n-        Util.shutdown();\n-    }\n-\n-    CountDownLatch menubarLatch = new CountDownLatch(1);\n-    CountDownLatch memoryLatch = new CountDownLatch(1);\n-    AtomicBoolean failed = new AtomicBoolean(false);\n-\n-    @Test\n-    public void testFailingMenuBar() throws InterruptedException {\n-        Util.runAndWait(() -> {\n-            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n-                e.printStackTrace();\n-                failed.set(true);\n-            });\n-            createMenuBarStage();\n-        });\n-\n-        menubarLatch.await();\n-\n-        assertFalse(failed.get());\n-    }\n-\n-    public void createMenuBarStage() {\n-        Stage stage = new Stage();\n-        VBox root = new VBox();\n-\n-        root.getChildren().add(createFailingMenuBar());\n-\n-        Scene scene = new Scene(root);\n-        stage.setScene(scene);\n-        stage.show();\n-    }\n-\n-    public MenuBar createFailingMenuBar() {\n-        MenuBar menuBar = new MenuBar();\n-\n-        menuBar.setUseSystemMenuBar(true);\n-\n-        Menu systemMenu = new Menu(\"systemMenu\");\n-        menuBar.getMenus().add(systemMenu);\n-\n-        var newItem = new MenuItem();\n-        newItem.setVisible(false);\n-        systemMenu.getItems().add(newItem);\n-\n-        Platform.runLater(() -> {\n-            javafx.scene.control.Menu systemMenuContributions = new Menu(\"123\");\n-            systemMenu.getItems().add(systemMenuContributions);\n-            menubarLatch.countDown();\n-        });\n-\n-        return menuBar;\n-    }\n-\n-    @Test\n-    public void testMemoryLeak() throws InterruptedException {\n-        Util.runAndWait(() -> {\n-            Thread.currentThread().setUncaughtExceptionHandler((t,e) -> {\n-                e.printStackTrace();\n-                failed.set(true);\n-                memoryLatch.countDown();\n-            });\n-            createMenuBarWithItemsStage();\n-        });\n-        memoryLatch.await();\n-        assertFalse(failed.get());\n-    }\n-\n-    private void createMenuBarWithItemsStage() {\n-        final ArrayList<WeakReference<MenuItem>> uncollectedMenuItems = new ArrayList<>();\n-\n-        Stage stage = new Stage();\n-        VBox root = new VBox();\n-        final MenuBar menuBar = new MenuBar();\n-        final Menu menu = new Menu(\"MyMenu\");\n-        menuBar.getMenus().add(menu);\n-        menuBar.setUseSystemMenuBar(true);\n-        root.getChildren().add(menuBar);\n-\n-        Scene scene = new Scene(root);\n-        stage.setScene(scene);\n-        stage.show();\n-        stage.requestFocus();\n-        Thread t = new Thread() {\n-            @Override public void run() {\n-                for (int i = 0; i < 10; i++) {\n-                    try {\n-                        Thread.sleep(20);\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n-                    Platform.runLater(() -> {\n-                        menu.getItems().clear();\n-                        MenuItem menuItem = new MenuItem(\"MyItem\");\n-                        WeakReference<MenuItem> wr = new WeakReference<>(menuItem);\n-                        uncollectedMenuItems.add(wr);\n-                        menu.getItems().add(menuItem);\n-                    });\n-                }\n-                Platform.runLater( () -> {\n-                    int strongCount = 0;\n-                    for (WeakReference<MenuItem> wr: uncollectedMenuItems) {\n-                        if (!JMemoryBuddy.checkCollectable(wr)) strongCount++;\n-                    }\n-                    assertEquals(1, strongCount, \"Only the last menuItem should be alive\");\n-                    memoryLatch.countDown();\n-                });\n-            }\n-        };\n-        t.start();\n-    }\n-\n-}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SystemMenuBarTest.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"}]}