{"files":[{"patch":"@@ -4245,0 +4245,13 @@\n+  \/\/ If the store is on the backedge, it is not executed in the last\n+  \/\/ iteration, and we must subtract 1 from the len.\n+  Node* backedge = head->loopexit()->proj_out(1);\n+  if (store->in(0) == backedge) {\n+    len = new SubINode(len, _igvn.intcon(1));\n+    _igvn.register_new_node_with_optimizer(len);\n+#ifndef PRODUCT\n+    if (TraceOptimizeFill) {\n+      tty->print_cr(\"ArrayFill store on backedge, subtract 1 from len.\");\n+    }\n+#endif\n+  }\n+\n@@ -4347,0 +4360,7 @@\n+#ifndef PRODUCT\n+  if (TraceOptimizeFill) {\n+    tty->print(\"ArrayFill call   \");\n+    call->dump();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestBackedgeLoadArrayFill\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_101:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: using try-catch\n+        ldc 6;\n+        istore_0; \/\/ i = 6\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+        try t0;\n+        aload_1;\n+        iload_0;\n+        aload_1;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr[i] = arr[i]\n+        goto FINALLY;\n+        endtry t0;\n+        catch t0 java\/lang\/Exception;\n+        pop; \/\/ exception\n+    FINALLY:\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_102:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: without try-catch\n+        ldc 5;\n+        istore_0; \/\/ i = 5\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+        \/\/ must have some material before inc, else it is partial peeled away\n+        \/\/ And if we set -XX:-PartialPeelLoop, then the counted loop is never detected\n+    SECOND:\n+        aload_1;\n+        iload_0;\n+        aload_1;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr[i] = arr[i]\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_103:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: without try-catch, and second array\n+        ldc 7;\n+        istore_0; \/\/ i = 7\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+        ldc 25;\n+        newarray int;\n+        astore_2; \/\/ arr2 = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+    SECOND:\n+        \/\/ we can also do the identity read-write on another array - it just has to eventually disappear\n+        aload_2;\n+        iload_0;\n+        aload_2;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr2[i] = arr2[i]\n+\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_104:\"()V\"\n+    stack 20 locals 20\n+    {\n+        ldc 9;\n+        istore_0; \/\/ i = 9\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+    SECOND:\n+        \/\/ CFG leads to partial peel -> load moved into loop body, then intrinsified\n+        iload_0;\n+        ldc 2;\n+        irem;\n+        ifeq SKIP;\n+\n+    SKIP:\n+\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBackedgeLoadArrayFill.jasm","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299179\n+ * @summary ArrayFill: if store is on backedge, last iteration is not to be executed.\n+ * @library \/test\/lib\n+ * @compile TestBackedgeLoadArrayFill.jasm\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestBackedgeLoadArrayFill*::test*\n+ *      -XX:-TieredCompilation -Xcomp -XX:+OptimizeFill\n+ *      TestBackedgeLoadArrayFillMain\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestBackedgeLoadArrayFill*::test*\n+ *      -XX:-TieredCompilation -Xcomp -XX:+OptimizeFill\n+ *      -XX:LoopUnrollLimit=1\n+ *      TestBackedgeLoadArrayFillMain\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestBackedgeLoadArrayFillMain {\n+    static long[]  longA;\n+    static int[]   intA;\n+    static short[] shortA;\n+    static byte[]  byteA;\n+\n+    static class Data {\n+        long longValue;\n+        int intValue;\n+        short shortValue;\n+        byte byteValue;\n+\n+        Data(int value) {\n+            longValue  = (long)  value;\n+            intValue   = (int)   value;\n+            shortValue = (short) value;\n+            longValue  = (byte)  value;\n+        }\n+    }\n+\n+    public static long longSum() {\n+        long s = 0;\n+        for (long v : longA) { s += v; }\n+        return s;\n+    }\n+\n+    public static int intSum() {\n+        int s = 0;\n+        for (int v : intA) { s += v; }\n+        return s;\n+    }\n+\n+    public static short shortSum() {\n+        short s = 0;\n+        for (short v : shortA) { s += v; }\n+        return s;\n+    }\n+\n+    public static byte byteSum() {\n+        byte s = 0;\n+        for (byte v : byteA) { s += v; }\n+        return s;\n+    }\n+\n+    static void test_001() {\n+        \/\/ long seems not yet supported\n+        int i = 6;\n+        long arr[] = new long[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        longA = arr;\n+    }\n+\n+    static void test_002() {\n+        \/\/ jint_fill\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_003() {\n+        \/\/ jshort_fill\n+        int i = 6;\n+        short arr[] = new short[22];\n+        do {\n+            \/\/ first block of loop: copied before loop, and onto backedge -> store on backedge\n+            arr[i] = 1;\n+            \/\/ second block of loop\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        shortA = arr;\n+    }\n+\n+    static void test_004() {\n+        \/\/ jbyte_fill\n+        int i = 6;\n+        byte arr[] = new byte[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        byteA = arr;\n+    }\n+\n+    static void test_005() {\n+        \/\/ Note: currently unrolled, not intrinsified (unless -XX:LoopUnrollLimit=1)\n+        int arr[] = new int[22];\n+        for (int i = 6; i < 20; i++) {\n+            arr[i] = 1;\n+        }\n+        intA = arr;\n+    }\n+\n+    static void test_006() {\n+        \/\/ Note: currently unrolled, not intrinsified (unless -XX:LoopUnrollLimit=1)\n+        \/\/ Load in normal body, because not moved to backedge during parsing.\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = 1;\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_007() {\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            \/\/ still not on backedge [7,20) partial peel\n+            arr[i] = 1;\n+            try { int x = arr[i]; } catch (Exception e) {}\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_008(Data data) {\n+        \/\/ Because of conditional in loop, at first not intrinsified, and also not unrolled.\n+        \/\/ After unswitching both loops are intrinsified.\n+        \/\/ I stole this idea from TestOptimizeFillWithStripMinedLoop.java\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = (data == null) ? 1 : data.intValue;\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_009() {\n+        \/\/ Cast to int leads to \"missing use of index\", not intrinsified\n+        int arr[] = new int[22];\n+        for (long i = 6; i < 20; i++) {\n+            arr[(int)i] = 1;\n+        }\n+        intA = arr;\n+    }\n+\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        Asserts.assertEQ(longSum(),  (long)14);\n+        test_002();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_003();\n+        Asserts.assertEQ(shortSum(), (short)14);\n+        test_004();\n+        Asserts.assertEQ(byteSum(),  (byte)14);\n+        test_005();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_006();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_007();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_008(new Data(1));\n+        Asserts.assertEQ(intSum(),   14);\n+        test_008(null);\n+        Asserts.assertEQ(intSum(),   14);\n+        test_009();\n+        Asserts.assertEQ(intSum(),   14);\n+        TestBackedgeLoadArrayFill t = new TestBackedgeLoadArrayFill();\n+        t.test_101();\n+        Asserts.assertEQ(intSum(),   15);\n+        t.test_102();\n+        Asserts.assertEQ(intSum(),   16);\n+        t.test_103();\n+        Asserts.assertEQ(intSum(),   14);\n+        t.test_104();\n+        Asserts.assertEQ(intSum(),   12);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBackedgeLoadArrayFillMain.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}