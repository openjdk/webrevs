{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,1 +355,8 @@\n-        return (numLocals + 1) ^ (numStack + 11) ^ (numLocks + 7);\n+        return Objects.hash(super.hashCode(),\n+                        duringCall,\n+                        numLocals,\n+                        numLocks,\n+                        numStack,\n+                        rethrowException,\n+                        Arrays.hashCode(slotKinds),\n+                        Arrays.hashCode(values));\n@@ -363,13 +370,5 @@\n-        if (obj instanceof BytecodeFrame && super.equals(obj)) {\n-            BytecodeFrame that = (BytecodeFrame) obj;\n-            \/\/ @formatter:off\n-            if (this.duringCall == that.duringCall &&\n-                this.rethrowException == that.rethrowException &&\n-                this.numLocals == that.numLocals &&\n-                this.numLocks == that.numLocks &&\n-                this.numStack == that.numStack &&\n-                Arrays.equals(this.values, that.values)) {\n-                return true;\n-            }\n-            \/\/ @formatter:off\n-            return true;\n+        if (!super.equals(obj)) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n@@ -377,1 +376,8 @@\n-        return false;\n+        BytecodeFrame that = (BytecodeFrame) obj;\n+        return duringCall == that.duringCall &&\n+                        numLocals == that.numLocals &&\n+                        numLocks == that.numLocks &&\n+                        numStack == that.numStack &&\n+                        rethrowException == that.rethrowException &&\n+                        Arrays.equals(slotKinds, that.slotKinds) &&\n+                        Arrays.equals(values, that.values);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.jvmci\n+ * @library ..\/..\/..\/..\/..\/\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          java.base\/jdk.internal.misc\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestBytecodeFrame\n+ *\/\n+\n+package jdk.vm.ci.runtime.test;\n+\n+import jdk.vm.ci.code.BytecodeFrame;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.JavaValue;\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.Iterator;\n+\n+import org.junit.Assert;\n+\n+public class TestBytecodeFrame extends MethodUniverse {\n+\n+    private static void assertEquals(BytecodeFrame f1, BytecodeFrame f2) {\n+        Assert.assertEquals(f1, f2);\n+        Assert.assertEquals(f1.hashCode(), f2.hashCode());\n+    }\n+\n+    private static void assertNotEquals(BytecodeFrame f1, BytecodeFrame f2) {\n+        Assert.assertNotEquals(f1, f2);\n+        Assert.assertNotEquals(f1.hashCode(), f2.hashCode());\n+    }\n+\n+    \/**\n+     * Tests the {@link BytecodeFrame#equals} and {@link BytecodeFrame#hashCode}.\n+     *\/\n+    @Test\n+    public void equalsAndHashcodeTest() {\n+        Iterator<ResolvedJavaMethod> iter = methods.values().iterator();\n+        ResolvedJavaMethod m1 = iter.next();\n+        ResolvedJavaMethod m2 = iter.next();\n+        ResolvedJavaMethod m3 = iter.next();\n+\n+        JavaValue[] values = {\n+            JavaConstant.INT_0,\n+            JavaConstant.INT_1,\n+            JavaConstant.INT_2,\n+            JavaConstant.NULL_POINTER,\n+        };\n+        JavaKind[] slotKinds = {\n+            JavaKind.Int,\n+            JavaKind.Int,\n+            JavaKind.Int,\n+            JavaKind.Object,\n+        };\n+        JavaValue[] values2 = {\n+            JavaConstant.INT_1,\n+            JavaConstant.INT_2,\n+            JavaConstant.NULL_POINTER,\n+            JavaConstant.INT_0,\n+        };\n+        JavaKind[] slotKinds2 = {\n+            JavaKind.Int,\n+            JavaKind.Int,\n+            JavaKind.Object,\n+            JavaKind.Int,\n+        };\n+\n+        \/\/ The BytecodeFrame objects below will not all pass BytecodeFrame.verifyInvariants\n+        \/\/ but that's fine for simply testing equals and hashCode.\n+        BytecodeFrame caller = new BytecodeFrame(null, m3, 0, false, true,  values,  slotKinds, 1, 1, 0);\n+        BytecodeFrame f1 =  new BytecodeFrame(caller, m1, 0, false,  true,  values,  slotKinds,  1, 1, 0);\n+                                                                                                           \/\/ Differing field\n+        assertNotEquals(f1, new BytecodeFrame(caller, m2, 0, false, true,  values,  slotKinds,  1, 1, 0)); \/\/ method\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 1, false, true,  values,  slotKinds,  1, 1, 0)); \/\/ bci\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, true,  true,  values,  slotKinds,  1, 1, 0)); \/\/ rethrowException\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, false, values,  slotKinds,  1, 1, 0)); \/\/ duringCall\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, true,  values2, slotKinds,  1, 1, 0)); \/\/ values\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, true,  values,  slotKinds2, 1, 1, 0)); \/\/ slotKinds\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, false, values,  slotKinds,  2, 1, 0)); \/\/ numLocals\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, false, values,  slotKinds,  1, 2, 0)); \/\/ numStack\n+        assertNotEquals(f1, new BytecodeFrame(caller, m1, 0, false, false, values,  slotKinds,  1, 1, 1)); \/\/ numLocks\n+        assertEquals(f1, f1);\n+\n+        BytecodeFrame f2 = new BytecodeFrame(caller, m1, 0, false,  true,  values,  slotKinds, 1, 1, 0);\n+        assertEquals(f1, f2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestBytecodeFrame.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}