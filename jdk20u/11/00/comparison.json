{"files":[{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/symbol.hpp\"\n+\n@@ -31,1 +33,0 @@\n-class Symbol;\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -666,2 +666,2 @@\n-  InstanceKlass* loaded_class = NULL;\n-  Symbol* superclassname = NULL;\n+  InstanceKlass* loaded_class = nullptr;\n+  SymbolHandle superclassname; \/\/ Keep alive while loading in parallel thread.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/placeholders.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Test that multiple threads calling handle_parallel_super_load don't underflow supername refcount.\n+TEST_VM(PlaceholderTable, supername) {\n+  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* T2 = THREAD;\n+  \/\/ the thread should be in vm to use locks\n+  ThreadInVMfromNative tivfn(THREAD);\n+\n+  \/\/ Assert messages assume these symbols are unique, and the refcounts start at one.\n+  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* super = SymbolTable::new_symbol(\"super2_8_2023_supername\");\n+  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+\n+  {\n+    MutexLocker ml(THREAD, SystemDictionary_lock);\n+\n+    PlaceholderTable::classloadAction super_action = PlaceholderTable::LOAD_SUPER;\n+    PlaceholderTable::classloadAction define_action = PlaceholderTable::DEFINE_CLASS;\n+\n+    \/\/ DefineClass A and D\n+    PlaceholderTable::find_and_add(A, loader_data, define_action, nullptr, THREAD);\n+    PlaceholderTable::find_and_add(D, loader_data, define_action, nullptr, T2);\n+\n+    \/\/ Load interfaces first to get supername replaced\n+    PlaceholderTable::find_and_add(A, loader_data, super_action, interf, THREAD);\n+    PlaceholderTable::find_and_remove(A, loader_data, super_action, THREAD);\n+\n+    PlaceholderTable::find_and_add(D, loader_data, super_action, interf, T2);\n+    PlaceholderTable::find_and_remove(D, loader_data, super_action, T2);\n+\n+    ASSERT_EQ(interf->refcount(), 3) << \"supername isn't replaced until super set\";\n+\n+    \/\/ Add placeholder to the table for loading A and super, and D also loading super\n+    PlaceholderTable::find_and_add(A, loader_data, super_action, super, THREAD);\n+    PlaceholderTable::find_and_add(D, loader_data, super_action, super, T2);\n+\n+    ASSERT_EQ(interf->refcount(), 1) << \"now should be one\";\n+\n+    \/\/ Another thread comes in and finds A loading Super\n+    PlaceholderEntry* placeholder = PlaceholderTable::get_entry(A, loader_data);\n+    SymbolHandle supername = placeholder->supername();\n+\n+    \/\/ Other thread is done before handle_parallel_super_load\n+    PlaceholderTable::find_and_remove(A, loader_data, super_action, THREAD);\n+\n+    \/\/ if THREAD drops reference to supername (loading failed or class unloaded), we're left with\n+    \/\/ a supername without refcount\n+    super->decrement_refcount();\n+\n+    \/\/ handle_parallel_super_load (same thread doesn't assert)\n+    PlaceholderTable::find_and_add(A, loader_data, super_action, supername, T2);\n+\n+    \/\/ Refcount should be 3: one in table for class A, one in table for class D\n+    \/\/ and one locally with SymbolHandle keeping it alive\n+    placeholder = PlaceholderTable::get_entry(A, loader_data);\n+    supername = placeholder->supername();\n+    EXPECT_EQ(super->refcount(), 3) << \"super class name refcount should be 3\";\n+\n+    \/\/ Second thread's done too\n+    PlaceholderTable::find_and_remove(D, loader_data, super_action, T2);\n+\n+    \/\/ Other threads are done.\n+    PlaceholderTable::find_and_remove(A, loader_data, super_action, THREAD);\n+\n+    \/\/ Remove A and D define_class placeholder\n+    PlaceholderTable::find_and_remove(A, loader_data, define_action, THREAD);\n+    PlaceholderTable::find_and_remove(D, loader_data, define_action, T2);\n+\n+    placeholder = PlaceholderTable::get_entry(A, loader_data);\n+    ASSERT_TRUE(placeholder == nullptr) << \"placeholder should be removed\";\n+    placeholder = PlaceholderTable::get_entry(D, loader_data);\n+    ASSERT_TRUE(placeholder == nullptr) << \"placeholder should be removed\";\n+\n+    EXPECT_EQ(super->refcount(), 1) << \"super class name refcount should be 1 - kept alive in this scope\";\n+  }\n+\n+  EXPECT_EQ(A->refcount(), 1) << \"first lass name refcount should be 1\";\n+  EXPECT_EQ(D->refcount(), 1) << \"second class name refcount should be 1\";\n+  EXPECT_EQ(super->refcount(), 0) << \"super class name refcount should be 0 - was unloaded.\";\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}